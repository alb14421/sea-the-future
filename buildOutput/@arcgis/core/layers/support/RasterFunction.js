/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import{JSONSupport as e}from"../../core/JSONSupport.js";import{clone as o}from"../../core/lang.js";import{property as r}from"../../core/accessorSupport/decorators/property.js";import"../../chunks/Logger.js";import{e as i}from"../../chunks/enumeration.js";import{r as n}from"../../chunks/reader.js";import{subclass as s}from"../../core/accessorSupport/decorators/subclass.js";import{w as p}from"../../chunks/writer.js";import{J as a}from"../../chunks/jsonMap.js";import{I as u}from"../../chunks/ensureType.js";import{p as c}from"../../chunks/rasterEnums.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/Lifecycle.js";import"../../chunks/metadata.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../core/Error.js";import"../../chunks/object.js";import"../../config.js";import"../../chunks/string.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/MapUtils.js";import"../../chunks/Warning.js";let y=class extends e{constructor(){super(...arguments),this.pixelType="unknown"}};t([r({type:String,json:{write:{isRequired:!0}}})],y.prototype,"name",void 0),t([r({type:String,json:{write:!0}})],y.prototype,"description",void 0),t([r({type:u,json:{type:u,write:!0,name:"_object_id"}})],y.prototype,"id",void 0),t([r({type:String,json:{type:c.jsonValues,read:c.read,write:{writer:c.write,isRequired:!0}}})],y.prototype,"pixelType",void 0),t([r({type:String,json:{write:{isRequired:!0}}})],y.prototype,"type",void 0),y=t([s("esri.layers.support.RasterFunctionInfo")],y);const m=y;let l=class extends e{constructor(){super(...arguments),this.isDataset=!1,this.isPublic=!1,this.type="RasterFunctionVariable"}};t([r({type:String,json:{write:!0}})],l.prototype,"name",void 0),t([r({type:Number,json:{type:u,write:!0,name:"_object_id"}})],l.prototype,"id",void 0),t([r({type:Boolean,json:{write:!0}})],l.prototype,"isDataset",void 0),t([r({type:Boolean,json:{write:!0}})],l.prototype,"isPublic",void 0),t([r({json:{write:!0}})],l.prototype,"value",void 0),t([r({type:String,json:{write:!0}})],l.prototype,"type",void 0),l=t([s("esri.layers.support.RasterFunctionVariable")],l);const d={key:"type",base:null,typeMap:{RasterFunctionVariable:l}};let j=class extends e{};t([r({types:d,json:{types:d,name:"MatchVariable"}})],j.prototype,"matchVariable",void 0),t([r({types:d,json:{types:d,name:"UnionDimension"}})],j.prototype,"unionDimension",void 0),t([r({type:Number,json:{type:u,write:!0,name:"_object_id"}})],j.prototype,"id",void 0),t([r({type:String,json:{write:!0}})],j.prototype,"type",void 0),j=t([s("esri.layers.support.RasterFunctionProperties")],j);const f=j,h=new a({0:"mosaic",1:"item",2:"item-group"},{useNumericKeys:!0});let w=class extends e{constructor(){super(...arguments),this.description="",this.functionType="mosaic",this.type="RasterFunctionTemplate"}};var g;t([r({type:[String],json:{write:!0}})],w.prototype,"aliases",void 0),t([r({type:Object,json:{write:{isRequired:!0}}})],w.prototype,"arguments",void 0),t([r({type:String,json:{write:{isRequired:!0}}})],w.prototype,"description",void 0),t([r({type:m,json:{write:{isRequired:!0},name:"function"}})],w.prototype,"functionInfo",void 0),t([r({type:h.apiValues,json:{type:[0,1,2],read:h.read,write:{writer:h.write,isRequired:!0}}})],w.prototype,"functionType",void 0),t([r({type:String,json:{write:!0}})],w.prototype,"group",void 0),t([r({type:String,json:{write:!0}})],w.prototype,"help",void 0),t([r({type:Number,json:{type:u,write:!0,name:"_object_id"}})],w.prototype,"id",void 0),t([r({type:String,json:{write:{isRequired:!0}}})],w.prototype,"name",void 0),t([r({type:String,json:{write:!0,name:"definition"}})],w.prototype,"queryDefinition",void 0),t([r({type:String,json:{write:!0}})],w.prototype,"tag",void 0),t([r({type:f,json:{write:!0}})],w.prototype,"properties",void 0),t([r({type:String,json:{write:!0}})],w.prototype,"thumbnail",void 0),t([r({type:String,json:{write:!0}})],w.prototype,"thumbnailEx",void 0),t([r({json:{type:["RasterFunctionTemplate"],write:!0}})],w.prototype,"type",void 0),w=t([s("esri.layers.support.RasterFunctionTemplate")],w);const v=new Set(["raster","raster2","dem","fillraster"]),k=new Set(["rasters"]),F=t=>t?.rasterFunction?R.fromJSON(t):t,S=t=>t&&t instanceof R?t.toJSON():t,b=t=>t?.functionName&&!t.declaredClass,N=t=>b(t)?new R(t):t,A=t=>t?w.fromJSON({type:"RasterFunctionTemplate",...t}):void 0,D={types:{key:"type",base:null,typeMap:{RasterFunctionTemplate:w}},json:{write:!0,name:"rasterFunctionDefinition",read:A}};let R=g=class extends e{constructor(t){super(t),this.functionName=null,this.outputPixelType="unknown",this.variableName=null,this.functionDefinition=null}set functionArguments(t){if(t){const e=Object.keys(t);if(e.some(e=>v.has(e.toLowerCase())&&b(t[e]))||e.some(e=>k.has(e.toLowerCase())&&Array.isArray(t[e])&&t[e].some(t=>b(t)))){t=o(t);for(const o of e)v.has(o.toLowerCase())?t[o]=N(t[o]):k.has(o.toLowerCase())&&Array.isArray(t[o])&&(t[o]=t[o].map(t=>N(t)))}}this._set("functionArguments",t)}readFunctionArguments(t){return(t=>{if(null==t)return null;t=o(t);const e={};for(const o of Object.keys(t))v.has(o.toLowerCase())?e[o]=F(t[o]):k.has(o.toLowerCase())&&Array.isArray(t[o])?e[o]=t[o].map(F):e[o]=t[o];return e})(t)}writeFunctionArguments(t,e,o){const r={};for(const e of Object.keys(t))v.has(e.toLowerCase())?r[e]=S(t[e]):k.has(e.toLowerCase())&&Array.isArray(t[e])?r[e]=t[e].map(S):r[e]=S(t[e]);e[o]=r}readFunctionName(t,e){const o=e.rasterFunctionInfos;return e.name||(o?.length&&"None"!==o[0].name?o[0].name:e.rasterFunction||e.rasterFunctionDefinition?.name)}get rasterFunctionDefinition(){return this.functionDefinition?.toJSON()}set rasterFunctionDefinition(t){this.functionDefinition=A(t)}get hasClipFunction(){return this.rasterFunctionDefinition?JSON.stringify(this.rasterFunctionDefinition).includes('"type":"ClipFunction"'):JSON.stringify(this).includes('"rasterFunction":"Clip"')}clone(){return new g({functionName:this.functionName,functionArguments:o(this.functionArguments),outputPixelType:this.outputPixelType,variableName:this.variableName,rasterFunctionDefinition:o(this.rasterFunctionDefinition)})}};t([r({json:{type:Object,name:"rasterFunctionArguments"}})],R.prototype,"functionArguments",null),t([n("functionArguments")],R.prototype,"readFunctionArguments",null),t([p("functionArguments")],R.prototype,"writeFunctionArguments",null),t([r({json:{type:String,write:{target:"rasterFunction"}}})],R.prototype,"functionName",void 0),t([n("functionName",["rasterFunction","rasterFunctionInfos","rasterFunctionDefinition"])],R.prototype,"readFunctionName",null),t([i({C128:"c128",C64:"c64",F32:"f32",F64:"f64",S16:"s16",S32:"s32",S8:"s8",U1:"u1",U16:"u16",U2:"u2",U32:"u32",U4:"u4",U8:"u8",UNKNOWN:"unknown"},{ignoreUnknown:!1,default:"unknown"})],R.prototype,"outputPixelType",void 0),t([r({type:String,json:{read:!0,write:!0}})],R.prototype,"variableName",void 0),t([r()],R.prototype,"rasterFunctionDefinition",null),t([r(D)],R.prototype,"functionDefinition",void 0),t([r()],R.prototype,"hasClipFunction",null),R=g=t([s("esri.layers.support.RasterFunction")],R);export{R as default};
