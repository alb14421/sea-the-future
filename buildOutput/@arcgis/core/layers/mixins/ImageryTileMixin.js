/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import e,{s}from"../../request.js";import i from"../../core/Error.js";import{L as r}from"../../chunks/Logger.js";import{property as o}from"../../core/accessorSupport/decorators/property.js";import{b as n,I as a}from"../../chunks/ensureType.js";import"../../core/lang.js";import{e as l}from"../../chunks/enumeration.js";import{r as p}from"../../chunks/reader.js";import{subclass as m}from"../../core/accessorSupport/decorators/subclass.js";import c from"../../geometry/Point.js";import u from"../../geometry/SpatialReference.js";import{h}from"../../chunks/unitUtils.js";import{u as d}from"../../chunks/commonProperties.js";import f from"../support/DimensionalDefinition.js";import y from"../support/MultidimensionalSubset.js";import{i as g}from"../../chunks/rasterEnums.js";import x from"../support/RasterFunction.js";import j from"../support/TileInfo.js";import{i as b}from"../../chunks/datasetUtils.js";import R from"../../geometry/Polygon.js";import{JSONSupport as I}from"../../core/JSONSupport.js";import{onAbort as k}from"../../core/promiseUtils.js";import{QueueProcessor as S}from"../../chunks/QueueProcessor.js";import w from"../../geometry/Extent.js";import v from"../support/LOD.js";import{R as T}from"../support/RasterInfo.js";import{i as _,g as F,c as P,a as C,b as D,d as M,e as B,f as U,h as H}from"../../chunks/multidimensionalUtils.js";import{g as E,a as z,p as L,d as J,b as O}from"../../chunks/RawBlockCache.js";import{c as N}from"../../chunks/pixelRangeUtils.js";import{d as A,R as V}from"../../chunks/RasterSymbolizer.js";import{m as W,f as q,h as G,i as $,j as Q}from"../../chunks/vectorFieldUtils.js";import{e as X,l as K,f as Y,s as Z,h as tt,i as et,c as st,j as it,k as rt,d as ot,b as nt}from"../../chunks/rasterProjectionHelper.js";import{c as at,s as lt}from"../../chunks/clipUtils.js";import pt from"../../rest/support/FeatureSet.js";import{c as mt}from"../../chunks/rasterFunctionHelper.js";import{h as ct}from"../../chunks/rasterRendererChecks.js";import{a as ut,o as ht,p as dt,h as ft,q as yt,r as gt,n as xt}from"../../chunks/rasterRendererHelper.js";import{w as jt,r as bt,a as Rt}from"../../chunks/rasterTypeUtils.js";import It from"../../rest/support/ImageHistogramParameters.js";import kt from"../../rest/support/ImageSample.js";import St from"../../rest/support/ImageSampleParameters.js";import wt from"../../rest/support/ImageSampleResult.js";import"../../config.js";import"../../chunks/object.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/string.js";import"../../chunks/MapUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../chunks/jsonMap.js";import"../../chunks/Lifecycle.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/writer.js";import"../../geometry/Geometry.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../geometry/support/webMercatorUtils.js";import"../../chunks/layerContainerType.js";import"../../symbols/support/ElevationInfo.js";import"../../core/Clonable.js";import"../../symbols/support/FeatureExpressionInfo.js";import"../support/fieldUtils.js";import"../../core/sql.js";import"../../chunks/guards.js";import"../../chunks/datetime.js";import"../../chunks/unitConversionUtils.js";import"../../chunks/lengthUtils.js";import"../../tables/AttributeTableTemplate.js";import"../../tables/elements/AttributeTableGroupElement.js";import"../../tables/elements/AttributeTableAttachmentElement.js";import"../../tables/elements/AttributeTableElement.js";import"../../tables/elements/AttributeTableFieldElement.js";import"../../tables/elements/AttributeTableRelationshipElement.js";import"../../chunks/opacityUtils.js";import"../../geometry/support/jsonUtils.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/Polyline.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/coordsUtils.js";import"../../chunks/TileKey.js";import"../../chunks/Queue.js";import"../../chunks/SimpleObservable.js";import"../../chunks/ReactiveMap.js";import"../../chunks/signal.js";import"../support/RasterBandInfo.js";import"../support/RasterSensorInfo.js";import"../support/PixelBlock.js";import"../../chunks/_commonjsHelpers.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../chunks/vec4.js";import"../../chunks/common.js";import"../../chunks/vec4f64.js";import"../../chunks/projectionUtils.js";import"../../chunks/vec3f64.js";import"../../chunks/projectBuffer.js";import"../../chunks/geodesicConstants.js";import"../../chunks/projectXYZToVector.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/support/AttachmentsOrderByInfo.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../chunks/date.js";import"../../chunks/locale.js";import"../../chunks/constants.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/content/UtilityNetworkAssociationsContent.js";import"../../popup/support/UtilityNetworkAssociationType.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../core/reactiveUtils.js";import"../../chunks/typeUtils.js";import"../../chunks/createFeatureId.js";import"../../chunks/typeUtils2.js";import"../../symbols/CIMSymbol.js";import"../../symbols/Symbol.js";import"../../symbols/LabelSymbol3D.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../core/Loadable.js";import"../../core/Promise.js";import"../../portal/PortalGroup.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils3.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils4.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../chunks/DoubleArray.js";import"../../symbols/IconSymbol3DLayer.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../chunks/lineMarkers.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/Font.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../support/rasterFunctionConstants.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../chunks/focalStatUtils.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/visualVariableUtils.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties2.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/layerUtils.js";import"../catalog/catalogUtils.js";import"../../chunks/defaults.js";import"../../chunks/defaultsJSON.js";import"../../chunks/RendererLegendOptions.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils9.js";import"../../chunks/utils10.js";import"../../chunks/utils8.js";import"../../chunks/asyncUtils.js";import"../../chunks/jsonUtils2.js";import"../../chunks/parser.js";import"../../chunks/utils5.js";import"../../chunks/mat4.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils6.js";import"../../chunks/defaultCIMValues.js";import"../../chunks/gfxUtils.js";import"../../chunks/LRUCache.js";import"../../chunks/MemCache.js";import"../../chunks/generateRendererUtils.js";import"../support/MosaicRule.js";import"../../time/TimeExtent.js";import"../../chunks/timeUtils.js";let vt=0,Tt=class extends I{constructor(){super(...arguments),this._tileFetchQueue=new S({concurrency:32,process:(t,e)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:e})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:j.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=X(t.spatialReference);return null!=e&&t.extent.width>=e/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return null==t||"gcs-shift"===t.type}set rasterJobHandler(t){this._set("rasterJobHandler",t),b(this)&&this.primaryRasters?.rasters?.forEach(e=>e.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+vt++}set url(t){this._set("url",s(t,r.getLogger(this)))}async open(t){return this._openPromise??=K().then(()=>this._open(t)),this._openPromise}async fetchTile(t,e,s,i={}){const r=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,e,s,r);return i={noClip:!0,...i},this.fetchPixels(o,r.size[0],r.size[1],i)}async identify(t,e={}){t=n(c,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:i}=e,{rasterInfo:r}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:a}=r;let{transposedVariableName:l}=e;const p=null!=a&&o&&(null!=i||_(s));p&&!l&&(l=null!=s&&s.length>0?s[0].variableName??void 0:a.variables[0].name,e={...e,transposedVariableName:l}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:m,extent:u}=r,{datumTransformation:h}=e;let d=Y(t,m,h);if(!u.intersects(d))return{location:d,value:null};if(null!=r.transform){const t=r.transform.inverseTransform(d);if(!r.nativeExtent.intersects(t))return{location:t,value:null};d=t}let f=0;const y=null!=l&&null!=a&&r.hasMultidimensionalTranspose;if(b(this)){const t=this.primaryRasters.rasters[0];if(y)return t.identify(d,e);const{pixelSize:i}=r,o=3,n=i.x*o/2,a=i.y*o/2,l=new w({xmin:d.x-n,xmax:d.x+n,ymin:d.y-a,ymax:d.y+a,spatialReference:m}),p={interpolation:"nearest",multidimensionalDefinition:s,sliceId:e.sliceId},{pixelBlock:c}=await t.fetchPixels(l,o,o,p),{pixelBlock:u}=await this.fetchPixels(l,o,o,p);if(null==c)return{location:d,value:null};const h=Math.floor(o*o*.5),f=!c.mask||c.mask[h]?c.pixels.map(t=>t[h]):null;let g;return null!=u&&(g=!u.mask||u.mask[h]?u.pixels.map(t=>t[h]):void 0),{location:d,value:f,processedValue:g,pyramidLevel:0}}if(!y)if(e.srcResolution)f=Z(e.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(f=await this.computeBestPyramidLevelForLocation(t,e),null==f)return{location:d,value:null};const g=this.identifyPixelLocation(d,f,null,y);if(null===g)return{location:d,value:null};const{row:x,col:j,rowOffset:R,colOffset:I,blockWidth:k}=g,S=await this._tileFetchQueue.push({pyramidLevel:f,row:x,col:j,options:e},{signal:e.signal});if(!S?.pixels?.length)return{location:d,value:null};const v=R*k+I;return this._processIdentifyResult(S,{srcLocation:d,position:v,pyramidLevel:f,useTransposedTile:!!y,requestSomeSlices:p,identifyOptions:e})}async fetchPixels(t,e,s,i={}){t=tt(t),i=this._getRequestOptionsWithSliceId(i);const{_hasNoneOrGCSShiftTransform:r}=this;if(i.requestRawData&&r)return this._fetchPixels(t,e,s,i);const o=X(t.spatialReference),n=et(t);if(null==o||0===n||1===n&&this._isGlobalWrappableSource&&r)return this._fetchPixels(t,e,s,i);if(n>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:l,xmax:p}=t,m=Math.round(o/(p-l)*e),c=m-Math.round((o/2-l)/(p-l)*e);let u=0;const h=[];for(let r=0;r<=n;r++){const d=new w({xmin:0===r?l:-o/2,xmax:r===n?p-o*r:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),f=0===r?m-c:r===n?e-u:m;u+=f,h.push(f);const y=i.disableWrapAround&&r>0?null:this._fetchPixels(d,f,s,i);a.push(y)}const d=(await Promise.all(a)).map(t=>t?.pixelBlock);let f=null;const y={width:e,height:s};return f=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},i)).pixelBlock:W(d,y,{blockWidths:h}),{extent:t,srcExtent:st(t,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:f}}async fetchRawPixels(t,e,s,i={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const r=await this._fetchRawTiles(t,e,s,i),{nativeExtent:o,nativePixelSize:n,storageInfo:a}=this.rasterInfo,l=2**t,p=n.x*l,m=n.y*l,c=new w({xmin:o.xmin+p*e.x,xmax:o.xmin+p*(e.x+s.width-1),ymin:o.ymax-m*(e.y+s.height-1),ymax:o.ymax-m*e.y,spatialReference:o.spatialReference});if(!r)return{extent:c,srcExtent:c,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=r;if(1===u.length&&null!=u[0]&&u[0].width===s.width&&u[0].height===s.height)return{extent:c,srcExtent:c,pixelBlock:r.pixelBlocks[0]};const d=t>0?a.pyramidBlockWidth:a.blockWidth,f=t>0?a.pyramidBlockHeight:a.blockHeight,y={x:e.x%d,y:e.y%f};let g;return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:s,clipOffset:y,clipSize:s,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:W(u,h,{clipOffset:y,clipSize:s}),{extent:c,srcExtent:c,pixelBlock:g}}fetchRawTile(t,e,s,r){throw new i("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return st(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?A(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,s,i=0){const{customFetchParameters:r}=this.ioConfig,{range:o,query:n,headers:a}=s;i=i??s.retryCount??this.ioConfig.retryCount;const l=o?{Range:`bytes=${o.from}-${o.to}`}:null;try{return await e(t,{...s,query:{...n,...r},headers:{...a,...l}})}catch(e){if(i>0)return i--,this.request(t,s,i);throw e}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return null==e||null==t||0===t.length?null:F(t,e)}getTileExtentFromTileInfo(t,e,s,i){const r=i.lodAt(t);return this.getTileExtent({x:r.resolution,y:r.resolution},e,s,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:s,pixelSize:i}=this.rasterInfo,{pyramidResolutions:r}=t;if(!t.tileInfo){const o=[],n=t.maximumPyramidLevel||0;let a=(i.x+i.y)/2,l=1/.0254*96*a;for(let t=0;t<=n&&(o.unshift(new v({level:n-t,resolution:a,scale:l})),t!==n);t++)if(r){const e=(r[t].x+r[t].y)/2;l*=e/a,a=e}else a*=2,l*=2;const p=new c({x:s.xmin,y:s.ymax,spatialReference:e});t.tileInfo=new j({origin:p,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:o}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,s=512,i){const{width:r,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=t,p=new c({x:n.xmin,y:n.ymax,spatialReference:l});null==i&&(i=Math.max(0,Math.round(Math.log(Math.max(r,o))/Math.LN2-8)));const m=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],i);t.storageInfo=new T({blockWidth:e,blockHeight:s,pyramidBlockWidth:e,pyramidBlockHeight:s,origin:p,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:m})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,s,i,r,o=0,n=2){if(1===r.length&&o>0){r=[...r];let{x:t,y:e}=r[0];for(let s=0;s<o;s++)t*=n,e*=n,r.push({x:t,y:e})}const a=[],{x:l,y:p}=i;for(let i=0;i<r.length;i++){const{x:o,y:n}=r[i];a.push({minCol:Math.floor((t.xmin-l+.1*o)/e/o),maxCol:Math.floor((t.xmax-l-.1*o)/e/o),minRow:Math.floor((p-t.ymax+.1*n)/s/n),maxRow:Math.floor((p-t.ymin-.1*n)/s/n)})}return a}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(0===t)return e;if(null!=s&&s.length)return s[t-1];const r=i**t;return{x:e.x*r,y:e.y*r}}identifyPixelLocation(t,e,s,i){const{spatialReference:r,nativeExtent:o,storageInfo:n}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:p}=n,m=i&&null!=p?p.tileSize[0]:n.blockWidth,c=i&&null!=p?p.tileSize[1]:n.blockHeight,u=Y(t,r,s);if(!o.intersects(u))return null;if(e<0||e>a)return null;const h=this.getPyramidPixelSize(e),{x:d,y:f}=h,y=(l.y-u.y)/f/c,g=(u.x-l.x)/d/m,x=Math.min(c-1,Math.floor((y-Math.floor(y))*c)),j=Math.min(m-1,Math.floor((g-Math.floor(g))*m));return{pyramidLevel:e,row:Math.floor(y),col:Math.floor(g),rowOffset:x,colOffset:j,blockWidth:m,srcLocation:u}}getTileExtent(t,e,s,i,r,o){const[n,a]=o,l=i.x+s*n*t.x,p=l+n*t.x,m=i.y-e*a*t.y,c=m-a*t.y;return new w({xmin:l,xmax:p,ymin:c,ymax:m,spatialReference:r})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,s){const i=this.rasterInfo.storageInfo.blockBoundary[t];return!i||i.maxRow<e||i.maxCol<s||i.minRow>e||i.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:e}=t,{width:s,height:i}=t,r=u.WebMercator;t.spatialReference=r,t.extent=t.nativeExtent=new w({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-i,spatialReference:r}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new c({x:1,y:1,spatialReference:r});const{extent:o,storageInfo:n}=t;if(n){n.origin=new c({x:o.xmin,y:o.ymax,spatialReference:r});const{pyramidResolutions:s,tileInfo:i}=n;if(s&&s.forEach(t=>{t.x/=e.x,t.y/=e.y}),i){i.origin=n.origin;const e=(t.nativePixelSize.x+t.nativePixelSize.y)/2;i.lods.forEach((t,s)=>{t.resolution=e*2**s,t.scale=96*t.resolution/.0254})}}}async _fetchPixels(t,e,s,i={}){let r=et(t);if(r>=2)return{extent:t,pixelBlock:null};const o=this._getSourceDataInfo(t,e,s,i),{pyramidLevel:n,srcResolution:a,srcExtent:l,srcWidth:p,srcHeight:m,ul:u}=o;if(0===p||0===m)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:h}=this,d=h.transform,f="gcs-shift"===d?.type,y=null!=X(t.spatialReference);!f&&y||(r=et(o.srcExtent,f));const g=await this._fetchRawTiles(n,u,{width:p,height:m,wrapCount:r},i);if(!g)return{extent:t,srcExtent:l,pixelBlock:null};const x=h.storageInfo,j=n>0?x.pyramidBlockWidth:x.blockWidth,b=n>0?x.pyramidBlockHeight:x.blockHeight;let{x:R,y:I}=h.pixelSize;if(n>0){const{pyramidResolutions:t,pyramidScalingFactor:e}=x;if(null!=t&&t[n-1])({x:R,y:I}=t[n-1]);else{const t=e**n;R*=t,I*=t}}const k=h.spatialReference,S=new c({x:R,y:I,spatialReference:k}),w=j===p&&b===m&&u.x%j===0&&u.y%b===0,v=new c({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),T=!t.spatialReference.equals(k),_=k.isGeographic?1e-9:1e-4,{datumTransformation:F}=i,P=!T&&w&&1===g.pixelBlocks.length&&j===e&&b===s&&function(t,e,s){return Math.abs(t.x-e.x)<s&&Math.abs(t.y-e.y)<s}(a,v,_);if(P)return{extent:t,srcExtent:l,srcTilePixelSize:S,pixelBlock:g.pixelBlocks[0]};const C=y&&null!=X(l.spatialReference)&&this._hasNoneOrGCSShiftTransform,D=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");D&&!this.rasterJobHandler&&await K();const M=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:v.toJSON(),datumTransformation:F,rasterTransform:d,hasWrapAround:r>0||C,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:D},i):it({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:v,datumTransformation:F,rasterTransform:d,hasWrapAround:r>0||C,isAdaptive:!1,includeGCSGrid:D});let B;const U=!i.requestRawData,H={rows:M.spacing[0],cols:M.spacing[1]},E=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(n,g.extent.xmin):void 0,{pixelBlocks:z,mosaicSize:L,isPartiallyFilled:J}=g;let O=null;if(this.rasterJobHandler){const t=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:z,srcMosaicSize:L,destDimension:U?{width:e,height:s}:null,coefs:U?M.coefficients:null,sampleSpacing:U?H:null,projectDirections:D,gcsGrid:D?M.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:i.interpolation,alignmentInfo:E,blockWidths:null},i);({pixelBlock:B,localNorthDirections:O}=t)}else{const t=W(z,L,{alignmentInfo:E});B=U?q(t,{width:e,height:s},M.coefficients,H,i.interpolation):t,D&&M.gcsGrid&&(O=G({width:e,height:s},M.gcsGrid),B=$(B,this.rasterInfo.dataType,O))}return i.requestRawData||D?{extent:t,srcExtent:l,srcTilePixelSize:S,pixelBlock:B,transformGrid:M,localNorthDirections:O,isPartiallyFilled:J}:{extent:t,srcExtent:l,srcTilePixelSize:S,pixelBlock:B}}async _fetchRawTiles(t,e,s,i){const{origin:r,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:n,blockHeight:a}=this.getBlockWidthHeight(t);let{x:l,y:p}=e,{width:m,height:c,wrapCount:u}=s;const h=this._getRasterTileAlignmentInfo(t,0);i.buffer&&(l-=i.buffer.cols,p-=i.buffer.rows,m+=2*i.buffer.cols,c+=2*i.buffer.rows);let d=0,f=0,y=0;u&&null!=h&&(({worldColumnCountFromOrigin:f,originColumnOffset:y,rightPadding:d}=h),f*h.blockWidth-d>=l+m&&(d=0));const g=Math.floor(l/n),x=Math.floor(p/a),j=Math.floor((l+m+d-1)/n),b=Math.floor((p+c+d-1)/a),R=o[t];if(!R)return null;const{minRow:I,minCol:k,maxCol:S,maxRow:v}=R;if(0===u&&(b<I||j<k||x>v||g>S))return null;const T=new Array;let _=!1;const F=null==this.ioConfig.allowPartialFill?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let e=x;e<=b;e++)for(let s=g;s<=j;s++){let r=s;if(!i.disableWrapAround&&u&&null!=h&&f<=s&&(r=s-f-y),e>=I&&r>=k&&v>=e&&S>=r){const s=this._tileFetchQueue.push({pyramidLevel:t,row:e,col:r,options:i},{signal:i.signal});F?T.push(new Promise(t=>{s.then(e=>t(e)).catch(()=>{_=!0,t(null)})})):T.push(s)}else T.push(Promise.resolve(null))}if(0===T.length)return null;const P=await Promise.all(T),C={height:(b-x+1)*a,width:(j-g+1)*n},{spatialReference:D}=this.rasterInfo,M=this.getPyramidPixelSize(t),{x:B,y:U}=M;return{extent:new w({xmin:r.x+g*n*B,xmax:r.x+(j+1)*n*B,ymin:r.y-(b+1)*a*U,ymax:r.y-x*a*U,spatialReference:D}),pixelBlocks:P,mosaicSize:C,isPartiallyFilled:_}}_fetchRawTile(t,e,s,i){const{storageInfo:r}=this.rasterInfo,o=null!=r.transposeInfo&&!!i.transposedVariableName;if(!o){const i=r.blockBoundary[t];if(!i)return Promise.resolve(null);const{minRow:o,minCol:n,maxCol:a,maxRow:l}=i;if(e<o||s<n||e>l||s>a)return Promise.resolve(null)}const n=o?i.transposeVariableName:i.sliceId,a=this.rasterInfo.storageInfo.isBsqTile?i.bandIds:null,l=E(this.rasterId,n,a),p=`${t}/${e}/${s}`;let m=z(l,i.registryId,p);if(null==m){const r=new AbortController;m=this.fetchRawTile(t,e,s,{...i,signal:r.signal}),L(l,i.registryId,p,m,r),m.catch(()=>J(l,i.registryId,p))}return i.signal&&k(i,()=>{O(l,i.registryId,p)}),m}_computeMagDirValues(t){const{bandCount:e,dataType:s}=this.rasterInfo;if((2!==e||"vector-magdir"!==s)&&"vector-uv"!==s||2!==t?.length||!t[0]?.length)return null;const i=t[0].length;if("vector-magdir"===s){const e=t[1].map(t=>(t+360)%360);return[t[0],e]}const[r,o]=t,n=[],a=[];for(let t=0;t<i;t++){const[e,s]=Q([r[t],o[t]]);n.push(e),a.push(s)}return[n,a]}_getRasterTileAlignmentInfo(t,e){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=rt(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:e,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,s,i={}){const r={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};i.srcResolution&&(r.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,r));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=r,p=n/e,m=a/s,u=l<o&&p*m>=16,h=l===o&&this._requireTooManySrcTiles(n,a,e,s);if(u||h||0===n||0===a){const n=new c({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let a=ot(n,this.rasterInfo.spatialReference,t,r.datumTransformation);const h=!a||i.srcResolution&&a.x+a.y<i.srcResolution.x+i.srcResolution.y;if(u&&i.srcResolution&&h){const t=Math.round(Math.log(Math.max(p,m))/Math.LN2)-1;if(o-l+3>=t){const e=2**t;a={x:i.srcResolution.x*e,y:i.srcResolution.y*e}}}a&&(r.srcResolution=a,this._updateSourceDataInfo(t,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,e,s)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(t,e,s,i){const{tileInfo:r}=this.rasterInfo.storageInfo,o=t/s,n=e/i;return Math.ceil(t/r.size[0])*Math.ceil(e/r.size[1])>=256*Math.max(1,(s+i)/1024)||o>8||n>8}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const{rasterInfo:s}=this,i=s.spatialReference,{srcResolution:r,datumTransformation:o}=e,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=Z(r,s,this.ioConfig.sampling);if(l)return;let p=e.srcExtent||st(t,i,o);if(null==p)return;const m=s.transform;m&&(p=m.inverseTransform(p)),e.srcExtent=p;const{x:c,y:u}=s.storageInfo.origin,h=Math.floor((p.xmin-c)/a.x+.1),d=Math.floor((u-p.ymax)/a.y+.1),f=Math.floor((p.xmax-c)/a.x-.1),y=Math.floor((u-p.ymin)/a.y-.1),g=p.width<.1*a.x?0:f-h+1,x=p.height<.1*a.y?0:y-d+1;e.pyramidLevel=n,e.pyramidResolution=a,e.srcWidth=g,e.srcHeight=x,e.ul={x:h,y:d}}_getRequestOptionsWithSliceId(t){return null!=this.rasterInfo.multidimensionalInfo&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:s,position:i,pyramidLevel:r,useTransposedTile:o}=e,n=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[i])return{location:s,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(null==a||!o){const e=t.pixels.map(t=>t[i]),o={location:s,value:e,pyramidLevel:r},n=this._computeMagDirValues(e.map(t=>[t]));return n?.length&&(o.magdirValue=n.map(t=>t[0])),o}let l=t.pixels.map(t=>t.slice(i*n,i*n+n)),p=this._computeMagDirValues(l);const{requestSomeSlices:m,identifyOptions:c}=e;let u=P(a,c.transposedVariableName);if(m){const t=C(u,c.multidimensionalDefinition,c.timeExtent);l=l.map(e=>t.map(t=>e[t])),p=p?.map(e=>t.map(t=>e[t])),u=t.map(t=>u[t])}const h=t.noDataValues||this.rasterInfo.noDataValue,d={pixels:l,pixelType:t.pixelType};let y;return null!=h&&(N(d,h),y=d.mask),{location:s,value:null,dataSeries:u.map((t,e)=>{const s={value:0===y?.[e]?null:l.map(t=>t[e]),multidimensionalDefinition:t.multidimensionalDefinition.map(t=>new f({...t,isSlice:!0}))};return p?.length&&(s.magdirValue=[p[0][e],p[1][e]]),s}),pyramidLevel:r}}};t([o()],Tt.prototype,"_rasterTileAlignmentInfo",void 0),t([o()],Tt.prototype,"_tileFetchQueue",void 0),t([o({readOnly:!0})],Tt.prototype,"_isGlobalWrappableSource",null),t([o({readOnly:!0})],Tt.prototype,"_hasNoneOrGCSShiftTransform",null),t([o()],Tt.prototype,"_openPromise",void 0),t([o()],Tt.prototype,"rasterJobHandler",null),t([o({readOnly:!0})],Tt.prototype,"rasterId",null),t([o(d)],Tt.prototype,"url",null),t([o({type:String,json:{write:!0}})],Tt.prototype,"datasetName",void 0),t([o({type:String,json:{write:!0}})],Tt.prototype,"datasetFormat",void 0),t([o()],Tt.prototype,"hasUniqueSourceStorageInfo",void 0),t([o()],Tt.prototype,"rasterInfo",void 0),t([o()],Tt.prototype,"ioConfig",void 0),t([o()],Tt.prototype,"sourceJSON",void 0),Tt=t([m("esri.layers.support.rasterDatasets.BaseRaster")],Tt);let _t=class extends Tt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,e,s,i={}){const{rasters:r,rasterIds:o}=this.primaryRasters;let n=!1;const{interpolation:a}=i,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!i.requestRawData&&l&&(n=1===r.length&&!i.skipRasterFunction,i={...i,interpolation:"bilinear",requestRawData:n}),i.requestRawData&&r.length>1&&!this.hasUniqueSourceStorageInfo&&(n=!1,i={...i,requestRawData:!1});const p=r.map(r=>r.fetchPixels(t,e,s,i)),m=await Promise.all(p),c=m.map(t=>t.pixelBlock),u=n||i.requestRawData?m.map(t=>t.srcTilePixelSize):null;if(i.skipRasterFunction||c.every(t=>null==t))return m[0];const h=m.find(t=>null!=t.pixelBlock)?.extent??t;let d=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:c,primaryPixelSizes:u,primaryRasterIds:o}):this.rasterFunction.process({extent:h,primaryPixelBlocks:c,primaryPixelSizes:u,primaryRasterIds:o});const{transformGrid:f}=m[0];if(!n||null==d||null==f){const t=i.noClip?null:this.getClippingGeometry(h.spatialReference);return i.noClip||i.requestRawData||null==d||!t||(d=await at(d,h,t)),{...m[0],pixelBlock:d}}const y={rows:f.spacing[0],cols:f.spacing[1]};let g;g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[d],srcMosaicSize:{width:d.width,height:d.height},destDimension:{width:e,height:s},coefs:f.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},i)).pixelBlock:q(d,{width:e,height:s},f.coefficients,y,a);const x=i.noClip?null:this.getClippingGeometry(t.spatialReference);return i.noClip||i.requestRawData||null==g||null==x||(g=await at(g,t,x)),{extent:t,srcExtent:m[0].srcExtent,pixelBlock:g}}getClippingGeometry(t){const e=this._clippingGeometry.get("0");if(!t||!e)return e;const s=function(t){return String(t.wkid??t.wkt??t.wkt2)}(t);let i=this._clippingGeometry.get(s);return null!=i||(i=t.equals(e.spatialReference)?e:nt(e,t),this._clippingGeometry.set(s,i)),i}async _open(t){const{rasterFunction:e}=this;e.isRoot=!0,this.primaryRasters?.rasters?.length?e.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(t=>t.rasterJobHandler=this.rasterJobHandler));const{rasters:s,rasterIds:r}=this.primaryRasters,o=s.map(e=>e.rasterInfo?void 0:e.open(t));await Promise.all(o);const n=s.map(({rasterInfo:t})=>t),a=e.bind({rasterInfos:n,rasterIds:r});if(e.rawSourceRasterInfos=n,!a.success||0===n.length)throw new i("raster-function:open",`cannot bind the function: ${a.error??""}`);const l="Table"===e.functionName?e:e.functionArguments?.raster;"Table"===l?.functionName&&(e.rasterInfo.attributeTable=pt.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const p=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every(t=>function(t,e){const{storageInfo:s,pixelSize:i,spatialReference:r,extent:o}=t,{storageInfo:n,pixelSize:a,spatialReference:l,extent:p}=e;return i.x===a.x&&i.y===a.y&&r.equals(l)&&o.equals(p)&&s.blockHeight===n.blockHeight&&s.blockWidth===n.blockWidth&&s.maximumPyramidLevel===n.maximumPyramidLevel&&s.firstPyramidLevel===n.firstPyramidLevel&&s.pyramidBlockWidth===n.pyramidBlockWidth&&s.pyramidBlockHeight===n.pyramidBlockHeight&&s.pyramidScalingFactor===n.pyramidScalingFactor}(t,p)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",e.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let e=t?.clippingGeometry;if(e&&"inside"===t.clippingType){const{extent:t}=this.rasterInfo,s=await import("../../geometry/operators/densifyOperator.js").then(t=>t.d),i=await import("../../geometry/operators/differenceOperator.js").then(t=>t.d);let r=s.execute(R.fromExtent(t),2*(t.width+t.height)/40);r=nt(r,e.spatialReference),e=i.execute(r,e)}this._clippingGeometry.clear(),e&&this._clippingGeometry.set("0",e)}};t([o({type:String,json:{write:!0}})],_t.prototype,"datasetFormat",void 0),t([o()],_t.prototype,"tileType",void 0),t([o()],_t.prototype,"rasterFunction",void 0),t([o()],_t.prototype,"primaryRasters",void 0),_t=t([m("esri.layers.support.rasterDatasets.FunctionRaster")],_t);const Ft=R=>{const I=R;let k=class extends I{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=b(t[0]?.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){"none"===t?.functionName?.toLowerCase()&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}set url(t){this._set("url",s(t,r.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:t,presetRenderers:e}=this;if(t){const s=e?.find(({name:e})=>e===t);return s?.renderer.clone()}return this.internalRenderer}set renderer(t){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=t}set internalRenderer(t){null==t&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",t),this.updateRenderer())}readRenderer(t,e,s){const i=e?.layerDefinition?.drawingInfo?.renderer;return Rt(i,s)||void 0}async computeStatisticsHistograms(t,e){await this.load(e),t=n(It,t).clone();const{serviceRasterInfo:s}=this;if(null==s)throw new i("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=t;if(null==r)throw new i("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=r;const{spatialReference:a}=s;if(!r.spatialReference.equals(a)){await K();const t="extent"===r.type?st(r,a):nt(r,a);if(null==t)throw new i("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");o=t}const l=t.pixelSize??new c({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:a}),{extent:p,width:m,height:u}=lt(s,o,l),h=await this.fetchPixels(p,m,u,{...e,interpolation:"nearest"});if(null==h.pixelBlock)throw new i("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const d=await at(h.pixelBlock,p,o),f=this._rasterJobHandler;return f?f.computeStatisticsHistograms({pixelBlock:d},e):ct(d)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.serviceRasterInfo??{};if(null==e)return t;const s=D({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:t.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:t.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...t,multidimensionalDefinition:s,timeExtent:void 0}}async updateRasterFunction(){return this.loaded&&"imagery-tile"===this.type&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:t,symbolizer:e,renderer:s}=this;if(!t||!e||!s)return;const{rasterInfo:i}=this.raster,r=M(i,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=r?.name,n=ut(i,o);return this._updateSymbolizer(e,s,o,n)}async applyRenderer(t,e,s){const i=t?.pixelBlock;if(!(null!=i&&i.pixels&&i.pixels.length>0))return null;await this.updateRenderer();const r=this.bandIds??[],{pixelBlock:o}=await this._symbolize({pixelData:t,simpleStretchParams:e,bandIds:r,symbolizer:this.symbolizer},s);return o}getTileUrl(t,e,s){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${t}/${e}/${s}`:""}getCompatibleTileInfo(t,e,s=!1){if(!this.loaded||null==e)return null;if(s&&t.equals(this.spatialReference))return this.tileInfo;const i=h(t);return j.create({size:256,spatialReference:t,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,s,i,r={}){if(S(this),r.requestAsImageElement){const o=this.getTileUrl(t,s,i);return e(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(t=>t.data)}const{serviceRasterInfo:o}=this;if(null!=o.multidimensionalInfo&&null==(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition){const e=r.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,s,i,e),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,s,i,r)}async fetchPixels(t,e,s,i={}){return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),e=Math.round(e),s=Math.round(s),this.raster.fetchPixels(t,e,s,i))}async getSamples(t,e){if(await this.load(),(t=n(St,t).clone()).interpolation&&"nearest"!==t.interpolation)throw new i("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const s=t.mosaicRule?.multidimensionalDefinition,r={...e,multidimensionalDefinition:s},o=(await this._getSampleLocations(t)).map(t=>this.identify(t,r).then(e=>(e.location=t,e))),a=(await Promise.all(o)).flatMap((t,e)=>this._convertRasterIdentifyResultToSample(t,e));return new wt({samples:a})}async identify(t,e={}){await this.load();const{raster:s,serviceRasterInfo:r}=this;if(null!=r?.multidimensionalInfo&&(!r.hasMultidimensionalTranspose||!_(e.multidimensionalDefinition)&&!e.transposedVariableName)&&null==(e=this.normalizeRasterFetchOptions(e)).multidimensionalDefinition)return{location:t,value:null};const o=this.multidimensionalSubset?.areaOfInterest;if(o&&!o.contains(t))throw new i("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const n=this.serviceRasterInfo?.storageInfo.isBsqTile&&this.bandIds?.length?this.bandIds:void 0;return s.identify(t,{...e,bandIds:n})}hasStandardTime(){const t=this.serviceRasterInfo?.multidimensionalInfo;if(null==t||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,s=e?.[0]?.variableName;return t.variables.some(t=>t.name===s&&(!e?.[0].dimensionName||t.dimensions.some(t=>"StdTime"===t.name)))}getStandardTimeValue(t){return new Date(B(t)).toISOString()}getMultidimensionalSubsetVariables(t){const e=t??this.serviceRasterInfo?.multidimensionalInfo;return U(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=H(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&b(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;S(this);const{raster:t}=this;t.rasterJobHandler=this._rasterJobHandler,b(t)&&t.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(t){const{geometry:e}=t;if("point"===e.type)return[e];const{spatialReference:s,type:i}=e;if("multipoint"===i)return e.points.map(t=>new c({x:t[0],y:t[1],spatialReference:s}));if("polyline"===i){let i=e;if(t.sampleCount||t.sampleDistance){const s=await import("../../geometry/operators/densifyOperator.js").then(t=>t.d),r=(await import("../../geometry/operators/lengthOperator.js").then(t=>t.l)).execute(e,{unit:"meters"}),o=Math.min(t.sampleCount||100,1e3);let n=t.sampleDistance;n||(n=r/(o+(2===i.paths[0].length?1:0))),i=s.execute(e,n,{unit:"meters"})}return i.paths.flatMap(t=>t.map(t=>new c({x:t[0],y:t[1],spatialReference:s})))}const r=Math.min(t.sampleCount||100,1e3),o="extent"===e.type,n=o?e:e.extent,a=Math.sqrt(n.width*n.height/r),l=n.height/a,p=n.width/a,{xmin:m,ymax:u}=n,h=[];for(let t=0;t<l;t++)for(let i=0;i<p;i++){const r=new c({x:m+(i+.5)*a,y:u-(t+.5)*a,spatialReference:s});(o||e.contains(r))&&h.push(r)}return h}_configDefaultInterpolation(){if(null==this.interpolation){S(this);const{raster:t}=this,e=ht(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(t="no"){S(this);const{rasterInfo:e}=this.raster,s=M(e,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=s?.name,o=dt({variableName:i,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&e.bandCount>1&&(this.bandIds=o?.bandIds??ft(e)),!this.renderer||"override"===t){const t=yt(this.raster),s=o?.renderer??gt(e,{bandIds:this.bandIds,variableName:i,rasterFunctionColorRamp:t}),r=e.statistics,n=r&&r.length>0?r[0]:null,a=n?.max??0,l=n?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===s.type&&(a>1e24||l<-1e24)&&(s.dynamicRangeAdjustment=!0,s.customStatistics=null,"none"===s.stretchType&&(s.stretchType="min-max")),this.renderer=s}const n=xt({...this.renderer.toJSON(),variableName:i}),a=ut(e,i);this.symbolizer?(this.symbolizer.rendererJSON=n,this.symbolizer.rasterInfo=a):this.symbolizer=new V({rendererJSON:n,rasterInfo:a});const l=this.symbolizer.bind();if(l.success){if("auto"===t){const{colormap:t}=this.raster.rasterInfo,e=this.renderer;if(null!=t&&"raster-colormap"===e.type){const t=gt(this.raster.rasterInfo);JSON.stringify(t)!==JSON.stringify(e)&&this._configDefaultRenderer("override")}else if("raster-stretch"===e.type){const t=this.bandIds?.length,s=e.customStatistics?.length;!e.dynamicRangeAdjustment&&s&&t&&s!==t&&this._configDefaultRenderer("override")}}}else r.getLogger(this).warn("imagery-tile-mixin",l.error||"The given renderer is not supported by the layer."),"auto"===t&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&b(this.raster)){const t=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&t&&this._set("rasterFunction",x.fromJSON(t)))}let t,e=this.raster,s=!1;b(e)?(t=e.primaryRasters.rasters,e=t[0],s=!0):t=[e];const{rasterFunction:i}=this;if(i){const s={raster:e};t.length>1&&t.forEach(t=>s[t.url]=t);const r=mt(i.functionDefinition?.toJSON()??i.toJSON(),s),o=new _t({rasterFunction:r});o.rasterJobHandler=this._rasterJobHandler,await o.open(),this.raster=o}else this.raster=e,await e.open();if(this._cachedRendererJson=void 0,!s&&!i)return;const{bandIds:r}=this,{bandCount:o}=this.raster.rasterInfo,n=r?.length?r.some(t=>t>=o):o>=3;r&&(n||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(t,e){const{rasterInfo:s}=this.raster,i=s.storageInfo.pyramidScalingFactor**(t.pyramidLevel??0),r=(s.pixelSize.x+s.pixelSize.y)/2*i;if(!t.dataSeries?.length)return[new kt({location:t.location,pixelValue:t.value,locationId:e,resolution:r})];const o=[];return t.dataSeries.forEach(({value:s,multidimensionalDefinition:i},n)=>{const a={Variables:i[0].variableName,Dimensions:i.flatMap(({dimensionName:t})=>t).join(",")};for(const{dimensionName:t,values:e}of i){a[t]=Array.isArray(e[0])?e[0][0]:e[0];const s=e[e.length-1];a[`${t}_Max`]=Array.isArray(s)?s[s.length-1]:s}const l=new kt({location:t.location,pixelValue:s,rasterId:n,locationId:e,resolution:r,attributes:a});o.push(l)}),o}};function S(t){if(!t.raster||!t.serviceRasterInfo)throw new i("imagery-tile","no raster")}return t([o({clonable:!1})],k.prototype,"_cachedRasterFunctionJson",void 0),t([o({clonable:!1})],k.prototype,"_compatibleFullExtent",void 0),t([o({clonable:!1})],k.prototype,"_isConstructedFromFunctionRaster",void 0),t([o({clonable:!1})],k.prototype,"_rasterFunctionUpdatePromise",void 0),t([o({type:[a],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],k.prototype,"bandIds",void 0),t([o({json:{origins:{service:{read:{source:"copyrightText"}}}}})],k.prototype,"copyright",void 0),t([o({json:{read:!1}})],k.prototype,"fullExtent",null),t([o({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),l(g)],k.prototype,"interpolation",void 0),t([o()],k.prototype,"ioConfig",void 0),t([o({type:[f],json:{write:!0}})],k.prototype,"multidimensionalDefinition",null),t([o({type:y,json:{write:!0}})],k.prototype,"multidimensionalSubset",void 0),t([o()],k.prototype,"raster",void 0),t([o({type:x})],k.prototype,"rasterFunction",null),t([o()],k.prototype,"serviceRasterInfo",void 0),t([o()],k.prototype,"sourceJSON",void 0),t([o({readOnly:!0,type:u,json:{read:!1}})],k.prototype,"spatialReference",void 0),t([o({type:j})],k.prototype,"tileInfo",void 0),t([o(d)],k.prototype,"url",null),t([o()],k.prototype,"renderer",null),t([o({types:bt,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const t="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!t}}},origins:{"web-scene":{types:jt,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&"vector-field"!==t.type&&"flow"!==t.type})}}}}})],k.prototype,"internalRenderer",null),t([p("internalRenderer")],k.prototype,"readRenderer",null),t([o({clonable:!1})],k.prototype,"symbolizer",void 0),k=t([m("esri.layers.mixins.ImageryTileMixin")],k),k};export{Tt as B,_t as F,Ft as ImageryTileMixin};
