/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{revision as e,fullVersion as s,buildDate as t}from"../../kernel.js";import r from"../Error.js";import{a as o}from"../../chunks/events.js";import{m as n}from"../../chunks/handleUtils.js";import{r as i}from"../../chunks/maybe.js";import{isAbortError as a,isAborted as c,createAbortError as l,onAbort as h,isPromiseLike as u}from"../promiseUtils.js";import{h as p}from"../lang.js";import"../urlUtils.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/Logger.js";import"../../chunks/string.js";import"../../chunks/jsonUtils.js";function k(e,s){return new Proxy({},{get:(t,r,o)=>(...t)=>{let o,n;const i=t[t.length-1];var a;return"object"!=typeof(a=i)||Array.isArray(a)||null==a||!("signal"in a)&&!("transferList"in a)&&0!==Object.keys(a).length||(o=i.signal,n=i.transferList,t.pop()),e.apply(s?`${s}.${r.toString()}`:r.toString(),t,{transferList:n,signal:o})}})}const _={statsWorker:()=>import("../../chunks/statsWorker.js"),geometryEngineWorker:()=>import("../../chunks/geometryEngineWorker.js"),arcadeGeometryOperatorsWorker:()=>import("../../chunks/operatorsWorker.js"),CSVSourceWorker:()=>import("../../chunks/CSVSourceWorker.js"),EdgeProcessingWorker:()=>import("../../chunks/EdgeProcessingWorker.js"),ElevationSamplerWorker:()=>import("../../chunks/ElevationSamplerWorker.js"),FeatureServiceSnappingSourceWorker:()=>import("../../chunks/FeatureServiceSnappingSourceWorker.js"),GaussianSplatSortWorker:()=>import("../../chunks/GaussianSplatSortWorker.js"),GeoJSONSourceWorker:()=>import("../../chunks/GeoJSONSourceWorker.js"),LercWorker:()=>import("../../chunks/LercWorker.js"),MemorySourceWorker:()=>import("../../chunks/MemorySourceWorker.js"),PBFDecoderWorker:()=>import("../../chunks/PBFDecoderWorker.js"),FeaturePipelineWorker:()=>import("../../chunks/FeaturePipelineWorker.js"),PointCloudWorker:()=>import("../../chunks/PointCloudWorker.js"),RasterWorker:()=>import("../../chunks/RasterWorker.js"),SceneLayerSnappingSourceWorker:()=>import("../../chunks/SceneLayerSnappingSourceWorker.js"),SceneLayerWorker:()=>import("../../chunks/SceneLayerWorker.js"),WFSSourceWorker:()=>import("../../chunks/WFSSourceWorker.js"),WorkerTileHandler:()=>import("../../chunks/WorkerTileHandler.js"),Lyr3DWorker:()=>import("../../chunks/Lyr3DWorker.js"),Feature3DPipelineWorker:()=>import("../../chunks/Feature3DPipelineWorker.js"),TextureCompressionWorker:()=>import("../../chunks/TextureCompressionWorker.js"),FlowWorker:()=>import("../../chunks/FlowWorker.js"),ParquetSourceWorker:()=>import("../../chunks/ParquetSourceWorker.js"),PanoramicMeshWorker:()=>import("../../chunks/PanoramicMeshWorker.js")},m="worker:port-closed",d={HANDSHAKE:0,OPEN:1,OPENED:2,RESPONSE:3,INVOKE:4,ABORT:5,CLOSE:6,OPEN_PORT:7,ON:8};let g=0;function f(){return g++}function b(e){return e?"string"==typeof e?JSON.stringify({name:"message",message:e}):e.toJSON?JSON.stringify(e):JSON.stringify({name:e.name,message:e.message,details:e.details||{stack:e.stack}}):null}function y(e,s,t,r){if(s.type===d.OPEN_PORT)return void e.postMessage(s,[s.port]);if(s.type!==d.INVOKE&&s.type!==d.RESPONSE)return void e.postMessage(s);let o;var n;if((n=t)&&"object"==typeof n&&("result"in n||"transferList"in n)?(o=W(t.transferList),s.data=t.result):(o=W(r),s.data=t),o){if(p("ff"))for(const t of o)if("byteLength"in t&&t.byteLength>267386880){const t="Worker call with large ArrayBuffer would crash Firefox";switch(s.type){case d.INVOKE:throw t;case d.RESPONSE:return void y(e,{type:d.RESPONSE,jobId:s.jobId,error:b(t)})}}e.postMessage(s,o)}else e.postMessage(s)}function j(e){if(!e)return null;const s=e.data;return s?"string"==typeof s?JSON.parse(s):s:null}function W(e){if(!e?.length)return null;if(p("esri-workers-arraybuffer-transfer"))return e;const s=e.filter(e=>{return!((s=e)instanceof ArrayBuffer||"ArrayBuffer"===s?.constructor?.name);var s});return s.length?s:null}async function S(e){try{return await e}catch(e){const s=e?.name===m;if(!a(e)&&!s)throw e;return}}const{CLOSE:v,ABORT:M,INVOKE:O,RESPONSE:P,OPEN_PORT:E,ON:w}=d;class J{constructor(e){this._invoke=e,this._timer=null,this._cancelledJobIds=new Set,this._invokeMessages=[],this._timer=null,this._process=this._process.bind(this)}push(e){e.type===M?this._cancelledJobIds.add(e.jobId):(this._invokeMessages.push(e),null===this._timer&&(this._timer=setTimeout(this._process,0)))}clear(){this._invokeMessages.length=0,this._cancelledJobIds.clear(),this._timer=null}_process(){this._timer=null;for(const e of this._invokeMessages)this._cancelledJobIds.has(e.jobId)||this._invoke(e);this._cancelledJobIds.clear(),this._invokeMessages.length=0}}class N{static{this.kernelInfo={buildDate:t,fullVersion:s,revision:e}}static{this.clients=new Map}static connect(e,s){const t=new MessageChannel;let r;r="function"==typeof e?new e:"default"in e&&"function"==typeof e.default?new e.default:e;const o=new N(t.port1,{channel:t,client:r,schedule:s});return"object"==typeof r&&"remoteClient"in r&&(r.remoteClient=o),N.clients.set(o,r),t.port2}static loadWorker(e){const s=_[e];return s?s():Promise.resolve(null)}constructor(e,s,t,r){this._port=e,this._jobQueue=t,this._lowPriorityJobQueue=r,this._outJobs=new Map,this._inJobs=new Map,this._invokeQueue=new J(e=>this._onInvokeMessage(e)),this._client=s.client,this._onMessage=this._onMessage.bind(this),this._channel=s.channel,this._schedule=s.schedule,this._port.addEventListener("message",this._onMessage),this._port.start()}close(){this._post({type:v}),this._close()}isBusy(){return this._outJobs.size>0}invoke(e,s,t){return this.apply(e,[s],t)}apply(e,s,t){const o=t?.signal,n=t?.transferList;if(!this._port)return Promise.reject(new r(m,`Cannot call invoke('${e}'), port is closed`,{methodName:e,data:s}));const a=f();return new Promise((t,r)=>{if(c(o))return this._processWork(),void r(l());const u=h(o,()=>{const e=this._outJobs.get(a);e&&(this._outJobs.delete(a),this._processWork(),i(e.abortHandle),this._post({type:M,jobId:a}),r(l()))}),p={resolve:t,reject:r,abortHandle:u,debugInfo:e};this._outJobs.set(a,p),this._post({type:O,jobId:a,methodName:e,abortable:null!=o},s,n)})}createInvokeProxy(e){return k(this,e)}on(e,s){const t=new MessageChannel;function r(e){s(e.data)}return this._port.postMessage({type:w,eventType:e,port:t.port2},[t.port2]),t.port1.addEventListener("message",r),t.port1.start(),n(()=>{t.port1.postMessage({type:v}),t.port1.close(),t.port1.removeEventListener("message",r)})}jobAdded(){this._processWork()}openPort(){const e=new MessageChannel;return this._post({type:E,port:e.port2}),e.port1}_processWork(){if(this._outJobs.size>=2)return;const e=this._jobQueue?.pop()??this._lowPriorityJobQueue?.pop();if(!e)return;const{methodName:s,data:t,invokeOptions:r,resolver:o}=e;this.apply(s,t,r).then(e=>o.resolve(e)).catch(e=>o.reject(e))}_close(){this._channel&&(this._channel=void 0),this._port.removeEventListener("message",this._onMessage),this._port.close(),this._outJobs.forEach(e=>{i(e.abortHandle),e.reject(l(`Worker closing, aborting job calling '${e.debugInfo}'`))}),this._inJobs.clear(),this._outJobs.clear(),this._invokeQueue.clear(),this._port=null,this._client=null,this._schedule=null,this._onMessage=null,this._channel=null,this._jobQueue=void 0,this._invokeQueue=void 0,this._lowPriorityJobQueue=void 0}_onMessage(e){null!=this._schedule?this._schedule(()=>this._processMessage(e,!0)):this._processMessage(e,!1)}_processMessage(e,s){const t=j(e);if(t)switch(t.type){case P:this._onResponseMessage(t);break;case O:s?this._onInvokeMessage(t):this._invokeQueue.push(t);break;case M:this._onAbortMessage(t);break;case v:this._onCloseMessage();break;case E:this._onOpenPortMessage(t);break;case w:this._onOnMessage(t)}}_onAbortMessage(e){const s=this._inJobs,t=e.jobId,r=s.get(t);this._invokeQueue.push(e),r&&(r.controller&&r.controller.abort(),s.delete(t))}_onCloseMessage(){const e=this._client;this._close(),e&&"destroy"in e&&N.clients.get(this)===e&&e.destroy(),N.clients.delete(this),e?.remoteClient&&(e.remoteClient=null)}_onInvokeMessage(e){const{methodName:s,jobId:t,data:r=[],abortable:o}=e,n=o?new AbortController:null,i=this._inJobs;let c,l=this._client,h=l[s];try{if(!h&&s&&s.includes(".")){const e=s.split(".");for(let s=0;s<e.length-1;s++)l=l[e[s]],h=l[e[s+1]]}if("function"!=typeof h)throw new TypeError(`${s} is not a function`);r.push({client:this,signal:n?n.signal:null}),c=h.apply(l,r)}catch(e){return void this._post({type:P,jobId:t,error:b(e)})}u(c)?(i.set(t,{controller:n,promise:c}),c.then(e=>{i.has(t)&&(i.delete(t),this._post({type:P,jobId:t},e))},e=>{i.has(t)&&(i.delete(t),a(e)||this._post({type:P,jobId:t,error:b(e||{message:`Error encountered at method ${s}`})}))})):this._post({type:P,jobId:t},c)}_onOpenPortMessage(e){new N(e.port,{client:this._client})}_onOnMessage(e){const{port:s}=e,t=this._client.on(e.eventType,e=>{s.postMessage(e)}),r=o(e.port,"message",e=>{const o=j(e);o?.type===v&&(r.remove(),t.remove(),s.close())})}_onResponseMessage(e){const{jobId:s,error:t,data:o}=e,n=this._outJobs;if(!n.has(s))return;const a=n.get(s);n.delete(s),this._processWork(),i(a.abortHandle),t?a.reject(r.fromJSON(JSON.parse(t))):a.resolve(o)}_post(e,s,t){return y(this._port,e,s,t)}}export{d as M,k as c,N as default,S as i,f as n,y as p,j as r,b as t};
