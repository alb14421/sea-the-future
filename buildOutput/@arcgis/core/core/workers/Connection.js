/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{h as e}from"../../chunks/handleUtils.js";import"../lang.js";import{isPromiseLike as s,createAbortError as t,createResolver as i,throwIfAborted as o}from"../promiseUtils.js";import{Q as n}from"../../chunks/Queue.js";import r,{c as l}from"./RemoteClient.js";import"../Error.js";import"../../chunks/Logger.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/events.js";import"../../chunks/maybe.js";import"../../chunks/tracking.js";import"../../chunks/utils.js";import"../../chunks/SimpleObservable.js";import"../../chunks/ObservableBase.js";import"../../kernel.js";import"../urlUtils.js";import"../../chunks/jsonUtils.js";const h=new FinalizationRegistry(e=>{e.close()});function c(e,s){h.register(e,s,s)}class g{constructor(){this._inUseClients=new Array,this._clients=new Array,this._clientPromises=new Array,this._ongoingJobsQueue=new n,this._ongoingLowPriorityJobsQueue=new n}destroy(){this.close()}get closed(){return!this._clients?.length}open(e,t){return new Promise((i,n)=>{let l=!0;const h=e=>{o(t.signal),l&&(l=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length,this._inUseClients.length=e.length;for(let o=0;o<e.length;++o){const l=e[o];s(l)?this._clientPromises[o]=l.then(e=>(this._clients[o]=new r(e,t,this._ongoingJobsQueue,this._ongoingLowPriorityJobsQueue),h(i),this._clients[o]),()=>(h(n),null)):(this._clients[o]=new r(l,t,this._ongoingJobsQueue,this._ongoingLowPriorityJobsQueue),this._clientPromises[o]=Promise.resolve(this._clients[o]),h(i))}})}broadcast(e,s,t){const i=new Array(this._clientPromises.length);for(let o=0;o<this._clientPromises.length;++o){const n=this._clientPromises[o];i[o]=n.then(i=>i?.invoke(e,s,t))}return i}close(){let e;for(;e=this._ongoingJobsQueue.pop();)e.resolver.reject(t(`Worker closing, aborting job calling '${e.methodName}'`));for(;e=this._ongoingLowPriorityJobsQueue.pop();)e.resolver.reject(t(`Worker closing, aborting job calling '${e.methodName}'`));for(const e of this._clientPromises)e.then(e=>e?.close());this._clients.length=0,this._clientPromises.length=0,this._inUseClients.length=0,h.unregister(this)}invoke(e,s,t){return this.apply(e,[s],t)}apply(e,s,t){const o=i();("low"===t?.priority?this._ongoingLowPriorityJobsQueue:this._ongoingJobsQueue).push({methodName:e,data:s,invokeOptions:t,resolver:o});for(let e=0;e<this._clientPromises.length;e++){const s=this._clients[e];s?s.jobAdded():this._clientPromises[e].then(e=>e?.jobAdded())}return o.promise}createInvokeProxy(e){return l(this,e)}on(s,t){return Promise.all(this._clientPromises).then(()=>e(this._clients.map(e=>e.on(s,t))))}openPorts(){return new Promise(e=>{const s=new Array(this._clientPromises.length);let t=s.length;for(let i=0;i<this._clientPromises.length;++i)this._clientPromises[i].then(o=>{o&&(s[i]=o.openPort()),0===--t&&e(s)})})}get test(){}}export{g as default,c as r};
