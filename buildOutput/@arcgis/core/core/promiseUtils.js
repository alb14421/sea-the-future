/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{m as t}from"../chunks/handleUtils.js";import n from"./Error.js";import{o as r}from"../chunks/events.js";import{L as e}from"../chunks/Logger.js";import{r as o}from"../chunks/maybe.js";import"./lang.js";import"../chunks/object.js";import"../config.js";import"../chunks/string.js";const i=(s=globalThis,{setTimeout:(n,r)=>{const e=s.setTimeout(n,r);return t(()=>s.clearTimeout(e))}});var s;async function u(t,n){const r=t.slice(),e=await Promise.all(t.map((t,r)=>n(t,r)));return r.filter((t,n)=>e[n])}function c(t="Aborted"){return new n("AbortError",t)}function l(t,n="Aborted"){if(m(t))throw c(n)}function a(t,n="Aborted"){if(t?.destroyed)throw c(n)}function f(t){return t instanceof AbortSignal?t:t?.signal??void 0}function m(t){const n=f(t);return null!=n&&n.aborted}function h(t){if(v(t))throw t}function w(t){if(!v(t))throw t}function p(t,n){const e=f(t);if(null!=e){if(!e.aborted)return r(e,"abort",()=>n());n()}}function b(t,n){const e=f(t);if(null!=e)return l(e),r(e,"abort",()=>n(c()))}function d(t,n){return null==f(n)?t:new Promise((r,e)=>{let i=p(n,()=>e(c()));const s=()=>{i=o(i)};t.then(s,s),t.then(r,e)})}function j(t,r,e){return Promise.race([t,E(r).then(()=>{throw new n("timeout",`Did not resolve within ${r} milliseconds (${e??"timeout"})`)})])}function v(t){return"AbortError"===t?.name}async function y(t){try{return await t}catch(t){if(!v(t))throw t;return}}async function g(t,n=e.getLogger("esri")){try{return await t}catch(t){v(t)||n.error(t)}}async function T(t){if(!t)return;if("function"!=typeof t.forEach){const n=Object.keys(t),r=n.map(n=>t[n]),e=await T(r),o={};return n.map((t,n)=>o[t]=e[n]),o}const n=t;return Promise.allSettled(n).then(t=>Array.from(n,(n,r)=>{const e=t[r];return"fulfilled"===e.status?{promise:n,value:e.value}:{promise:n,error:e.reason}}))}async function A(t){return(await T(t)).filter(t=>!!t.value).map(t=>t.value)}async function P(t){return(await Promise.allSettled(t)).filter(t=>"fulfilled"===t.status).map(t=>t.value)}async function k(t){return(await Promise.allSettled(t)).filter(t=>"rejected"===t.status).map(t=>t.reason)}function E(t,n=void 0,r){const e=new AbortController;return p(r,()=>e.abort()),new Promise((r,o)=>{let i=setTimeout(()=>{i=0,r(n)},t);p(e,()=>{i&&(clearTimeout(i),o(c()))})})}function S(t,r,e,o){const i=e&&"abort"in e?e:null;null!=o||i||(o=e);let s=setTimeout(()=>{s=0,i?.abort()},r);const u=()=>o||new n("promiseUtils:timeout","The wrapped promise did not resolve within "+r+" ms");return t.then(t=>{if(0===s)throw u();return clearTimeout(s),t},t=>{throw clearTimeout(s),0===s?u():t})}function C(t,n){const r=new AbortController,e=setTimeout(()=>r.abort(),n);return p(t,()=>{r.abort(),clearTimeout(e)}),{...t,signal:r.signal}}function L(t){return t&&"function"==typeof t.then}function U(t){return L(t)?t:Promise.resolve(t)}function $(t,n=-1){let r,e,o,i,s=null;const u=(...l)=>{if(r){e=l,i&&i.reject(c()),i=x();const t=i.promise;if(s){const t=s;s=null,t.abort()}return t}if(o=i||x(),i=null,n>0){const e=new AbortController;r=U(t(...l,e.signal));const o=r;E(n).then(()=>{r===o&&(i?e.abort():s=e)})}else r=1,r=U(t(...l));const a=()=>{const t=e;e=o=r=s=null,null!=t&&u(...t)},f=r,m=o;return f.then(a,a),f.then(m.resolve,m.reject),m.promise};return u}function x(){let t,n;const r=new Promise((r,e)=>{t=r,n=e}),e=n=>{t(n)};return e.resolve=n=>t(n),e.reject=t=>n(t),e.timeout=(t,n)=>i.setTimeout(()=>e.reject(n),t),e.promise=r,e}function D(t,n){return t.then(n,n)}function O(t,n){n.then(t.resolve,t.reject)}async function q(t){await Promise.resolve(),l(t)}export{E as after,k as allSettledErrors,P as allSettledValues,D as always,i as c,c as createAbortError,x as createResolver,$ as debounce,T as eachAlways,A as eachAlwaysValues,u as filter,y as ignoreAbortErrors,v as isAbortError,m as isAborted,L as isPromiseLike,g as logOnError,p as onAbort,b as onAbortOrThrow,O as settleWithPromise,f as signalFromSignalOrOptions,h as throwIfAbortError,l as throwIfAborted,a as throwIfDestroyed,w as throwIfNotAbortError,S as timeout,q as waitTick,U as when,d as whenOrAbort,j as whenOrTimeout,C as wrapAbortWithTimeout};
