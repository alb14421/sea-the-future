"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[3557,7725,8010],{13281:(t,e,i)=>{i.d(e,{D:()=>x,m:()=>a,s:()=>g,w:()=>p});var n=i(32816),s=i(23160),o=i(6550),r=i(82604),m=i(43802);function a(){return{outPoint:new s.P,index:-1,t:Number.NaN}}function u(t,e,i){return{outPoint:t.clone(),index:e,t:i}}function c(t,e,i,n){t.outPoint.assign(e),t.index=i,t.t=n}function h(t,e){t.outPoint.assign(e.outPoint),t.index=e.index,t.t=e.t}function l(t,e,i,n){t.index=i,t.t=n,e.queryCoord2D(t.t,t.outPoint)}function _(t,e){const i=a();h(i,t),h(t,e),h(e,i)}function p(t,e,i,n,r,m){if(t.getGeometryType()===s.G.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const e=n.nextSegment();if(0!==(0,o.q)(t,e.getEndXY(),0))return c(r,e.getEndXY(),-1,Number.NaN),c(m,e.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}if(e.getGeometryType()===s.G.enumPolygon){for(;i.nextPath();)if(i.hasNextSegment()){const t=i.nextSegment();if(0!==(0,o.q)(e,t.getEndXY(),0))return c(r,t.getEndXY(),-1,Number.NaN),c(m,t.getEndXY(),-1,Number.NaN),!0}i.resetToFirstPath()}return!1}function g(t){const e=t.getPathCount(),i=(0,s.r)(t.getSegmentCount(),0);let n=0;for(let s=0;s<e;++s){const e=n+t.getSegmentCountPath(s);for(let o=n,r=t.getPathStart(s);o<e;++o,++r)i[o]=r;n=e}return(0,o.t)(t.getPointCount(),i),i}function y(t,e){return!!Number.isNaN(e)||t<=e}function d(t){const e=new o.P;return e.addEnvelope(t,!1),e}class x{constructor(t,e){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=e,this.m_maxSqrDistance=t*t,this.m_maxDistance=t,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=t,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let t=Math.sqrt(this.m_maxSqrDistance);for(;t<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,t=Math.sqrt(this.m_maxSqrDistance)}}calculate(t,e,i,n){if((t.getGeometryType()!==m.P.type||e.getGeometryType()!==m.P.type)&&(this.m_env2DgeometryA=new r.Envelope2D,this.m_env2DgeometryB=new r.Envelope2D,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!y(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const o=u(new s.P,(0,s.x)(),Number.NaN),a=u(new s.P,(0,s.x)(),Number.NaN),c=this._ExecuteBruteForce(t,e,o,a);return y(c,this.m_maxDistance)?(null!==i&&h(i,o),null!==n&&h(n,a),c):Number.POSITIVE_INFINITY}isNear(t,e){if(this.m_bIsNearCalc=!0,t.isEmpty()||e.isEmpty())return!1;if(t===e)return!0;let i=!0;if(t.getGeometryType()!==m.P.type&&t.getGeometryType()!==m.E.type||e.getGeometryType()!==m.P.type&&e.getGeometryType()!==m.E.type||(i=!1),i){if(this.m_env2DgeometryA=new r.Envelope2D,this.m_env2DgeometryB=new r.Envelope2D,t.queryEnvelope(this.m_env2DgeometryA),e.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const n=u(new s.P,(0,s.x)(),Number.NaN),o=u(new s.P,(0,s.x)(),Number.NaN);return this._ExecuteBruteForce(t,e,n,o)<=this.m_maxDistance}progress_(t=!1){}_ExecuteBruteForce(t,e,i,n){switch(t.getGeometryType()){case s.G.enumPoint:return this.distancePointGeometry(t,e,i,n);case s.G.enumMultiPoint:return this.distanceMultipointGeometry(t,e,i,n);case s.G.enumEnvelope:return this.distanceEnvelopeGeometry(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathGeometry(t,e,i,n);default:return Number.NaN}}distancePointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointPoint(t,e,i,n);case s.G.enumMultiPoint:return this.distancePointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.distancePointMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distancePointEnvelope(t,e,i,n);default:return Number.NaN}}distancePointPoint(t,e,i,n){const o=t.getXY(),r=e.getXY();return c(i,o,0,0),c(n,r,0,0),Math.sqrt(s.P.sqrDistance(o,r))}distancePointMultipoint(t,e,i,n){const o=t.getXY();let r=this.m_maxSqrDistance,m=r,a=!1;const u=e.getPointCount(),h=new s.P;for(let t=0;t<u;++t)if(e.queryXY(t,h),m=s.P.sqrDistance(o,h),this.m_bIsNearCalc){if(m<=r)return 0}else if(!(m>r)&&(!a&&m===r||m<r)&&(r=m,c(i,o,0,0),c(n,h,t,0),a=!0,0===r))return 0;return a?Math.sqrt(r):Number.POSITIVE_INFINITY}distancePointMultipath(t,e,i,n){const m=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),a=t.getXY();if(!m&&e.getGeometryType()===s.G.enumPolygon&&0!==(0,o.q)(e,a,0))return c(i,a,0,0),c(n,a,-1,Number.NaN),0;e.getImpl().getAccelerators();let u=this.m_maxSqrDistance,h=u,l=-1;const _=new r.Envelope2D,p=e.querySegmentIterator();let g=!1;for(;p.nextPath();)for(;p.hasNextSegment();){const t=p.nextSegment();t.queryEnvelope(_);const e=_.sqrDistance(a);if(e>u)continue;if(!this.m_bIsNearCalc&&g&&e===u)continue;l=t.getClosestCoordinate(a,!1);const o=t.getCoord2D(l);if(h=s.P.sqrDistance(a,o),this.m_bIsNearCalc){if(h<=u)return 0}else if(!(h>u)&&(!g||h<u)&&(u=h,c(i,a,0,0),c(n,o,p.getStartPointIndex(),l),g=!0,0===u))return 0}return g?Math.sqrt(u):Number.POSITIVE_INFINITY}distancePointEnvelope(t,e,i,n){const s=t.getXY();c(i,s,0,0),c(n,s,-1,Number.NaN);const o=e.asEnvelope2D();return o.contains(s)?0:Math.sqrt(o.sqrDistance(s,n.outPoint))}distanceMultipointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distancePointMultipoint(e,t,n,i);return this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case s.G.enumMultiPoint:return this.distanceMultipointMultipoint(t,e,i,n,1,1);case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipointMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distanceMultipointMultipath(t,d(e),i,n);default:return Number.NaN}}distanceMultipointMultipoint(t,e,i,o,r,m){const a={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&1===r&&1===m){const n=Math.trunc((0,s.s)(Math.sqrt(t.getPointCount())+1,1,(0,s.n)())),r=Math.trunc((0,s.s)(Math.sqrt(e.getPointCount())+1,1,(0,s.n)()));if((n>=4||r>=4)&&this.distanceMultipointMultipoint(t,e,i,o,n,r)<=this.m_maxSqrDistance)return 0}let u=this.m_maxSqrDistance;const h=[t],l=[e],p=this.swapGeometriesIfBGtA(h,l);p&&(this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),m=(0,s.f)(r,r=m),_(i,o)),(0,n.a)(a,(0,s.q)(()=>{_(i,o),this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!p),!1);const g=h[0].getImpl(),y=l[0].getImpl(),d=g.getPointCount(),x=y.getPointCount(),P=x>1;let D=!1;const v=new s.P,G=new s.P;for(let t=0;t<d;t+=r){if(g.queryXY(t,v),P){const t=this.m_env2DgeometryB.sqrDistance(v);if(this.m_bIsNearCalc){if(t>u)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(v)<=u)return 0}else if(t>=u)continue}for(let e=0;e<x;e+=m){y.queryXY(e,G);const n=s.P.sqrDistance(v,G);if(this.m_bIsNearCalc){if(n<=u)return 0}else if(!(n>u||D&&n===u)&&(!D||n<u)&&(c(i,v,t,0),c(o,G,e,0),D=!0,u=n,0===u))return D?Math.sqrt(u):Number.POSITIVE_INFINITY}}return D?Math.sqrt(u):Number.POSITIVE_INFINITY}catch(t){a.error=t,a.hasError=!0}finally{(0,n.b)(a)}}distanceMultipointMultipath(t,e,i,n){let m=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&e.getGeometryType()===s.G.enumPolygon;const a=e.querySegmentIterator();a.stripAttributes();const u=new r.Envelope2D,h=new s.P;let l=this.m_maxSqrDistance;const _=t.getImpl(),p=_.getPointCount(),g=p>1;let y=!1;for(;a.nextPath();)for(;a.hasNextSegment();){const t=a.nextSegment();if(t.queryLooseEnvelope(u),g){const t=u.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(t>l)continue}else if(t>l||y&&t===l)continue}for(let s=0;s<p;s++){if(_.queryXY(s,h),m&&0!==(0,o.q)(e,h,0))return c(i,h,-1,Number.NaN),c(n,h,s,0),0;{const t=u.sqrDistance(h);if(this.m_bIsNearCalc){if(t>l)continue}else if(t>l)continue}const r=t.getClosestCoordinate(h,!1),p=t.getCoord2D(r);h.subThis(p);const g=h.sqrLength();if(this.m_bIsNearCalc){if(g<=l)return 0}else if(!(g>l)&&(!y||g<l)&&(l=g,c(i,_.getXY(s),s,0),c(n,p,a.getStartPointIndex(),r),y=!0,0===l))return 0}m=!1}return y?Math.sqrt(l):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.distancePointEnvelope(e,t,n,i);case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distanceMultipointMultipath(e,d(t),n,i);return this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(d(t),e,i,n);case s.G.enumEnvelope:return this.distanceEnvelopeEnvelope(t,e,i,n);default:return Number.NaN}}distanceEnvelopeEnvelope(t,e,i,n){i.t=Number.NaN,i.index=-1,n.t=Number.NaN,n.index=-1;const s=t.asEnvelope2D(),o=e.asEnvelope2D();return Math.sqrt(s.sqrDistanceEnvelope(o,i.outPoint,n.outPoint))}distanceMultipathGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:{this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distancePointMultipath(e,t,n,i);return this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case s.G.enumMultiPoint:{this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const o=this.distanceMultipointMultipath(e,t,n,i);return this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),o}case s.G.enumPolyline:case s.G.enumPolygon:return this.distanceMultipathMultipath(t,e,i,n);case s.G.enumEnvelope:return this.distanceMultipathMultipath(t,d(e),i,n);default:return Number.NaN}}distanceMultipathMultipath(t,e,i,m){const u={stack:[],error:void 0,hasError:!1};try{const c=[t],y=[e],d=this.swapGeometriesIfAGtB(c,y);d&&(this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),_(i,m)),(0,n.a)(u,(0,s.q)(()=>{_(i,m),this.m_env2DgeometryB=(0,s.f)(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!d),!1);const x=c[0],P=y[0],D=x.querySegmentIterator();D.stripAttributes();const v=P.querySegmentIterator();if(v.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const t=Math.trunc((0,s.s)(Math.sqrt(x.getPointCount())+1,1,(0,s.n)())),e=Math.trunc((0,s.s)(Math.sqrt(x.getPointCount())+1,1,(0,s.n)()));if(this.distanceMultipointMultipoint(x,P,i,m,t,e)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const t=a(),e=a();if(p(x,P,D,v,t,e))return h(i,t),h(m,e),0}const G=g(x),f=[],S=new o.S,b=new r.Envelope2D,M=new r.Envelope2D,E=new r.Envelope2D;let I=this.m_maxSqrDistance,T=!0,N=!1;for(let t=0,e=G.length;t<e;++t){x.querySegment(G[t],S,!0);const e=S.get();if(e.queryEnvelope(b),!(b.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>I)){if(this.m_bIsNearCalc&&b.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=I)return 0;for(;v.nextPath();){if(this.progress_(),T)P.queryPathEnvelope(v.getPathIndex(),E),f[v.getPathIndex()]=E.clone();else if(b.sqrDistanceEnvelope(f[v.getPathIndex()],null,null)>I)continue;for(;v.hasNextSegment();){const n=v.nextSegment();if(n.queryEnvelope(M),b.sqrDistanceEnvelope(M,null,null)<=I){const s=!b.isIntersecting(M),o=[0],r=[0];let a=e.distance(n,s,o,r);if(a*=a,this.m_bIsNearCalc&&a<=this.m_maxSqrDistance)return 0;if(a<I||a===I&&G[t]<i.index){if(N=!0,l(i,e,G[t],o[0]),l(m,n,v.getStartPointIndex(),r[0]),0===a)return 0;I=a}}}}v.resetToFirstPath(),T=!1}}return N?Math.sqrt(I):Number.POSITIVE_INFINITY}catch(t){u.error=t,u.hasError=!0}finally{(0,n.b)(u)}}swapGeometriesIfAGtB(t,e){return(0,s.w)(t[0])>(0,s.w)(e[0])&&(e[0]=(0,s.f)(t[0],t[0]=e[0]),!0)}swapGeometriesIfBGtA(t,e){return this.swapGeometriesIfAGtB(e,t)}}},33534:(t,e,i)=>{i.d(e,{O:()=>r});var n=i(88010),s=i(87725),o=i(23160);class r{getOperatorType(){return 10317}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,i,n,o,r){return new s.OperatorGeodeticDensifyCursor(t,e,4,i,n,o,r)}execute(t,e,i,s,r,m){const a=new n.S([t]),u=this.executeMany(a,e,i,s,r,m).next();return u||(0,o.p)("null output"),u}}},83557:(t,e,i)=>{i.d(e,{G:()=>D,a:()=>x,m:()=>g});var n=i(32816),s=i(23160),o=i(6550),r=i(43802),m=i(82604),a=i(94981),u=i(13281),c=i(33534);class h{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(t,e,i){this.m_peR1=new o.H,this.m_peR2=new o.H,this.m_peR3=new o.H,void 0!==t?this.reset(t,e,i):this.reset(1,0,1)}reset(t,e,i){this.m_a=t,this.m_e2=e,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(t,e,i,n){const r=this.m_peR1,a=this.m_peR2,u=this.m_peR3;o.I.geodeticDistance(this.m_a,this.m_e2,t*this.m_unitToRad,e*this.m_unitToRad,i*this.m_unitToRad,n*this.m_unitToRad,u,r,a,0);const c=Math.cos(r.val),h=Math.cos(a.val+3.141592653589793),l=e*this.m_unitToRad,_=o.R.phiToEta(this.m_e2,l),p=Math.sin(r.val)*Math.cos(_);let g=e;if(c*h<0){const t=c<0?-1:1,e=Math.acos(Math.abs(p))*t;g=o.R.etaToPhi(this.m_e2,e)/this.m_unitToRad}let y=(0,s.F)((i-t)*this.m_unitToRad,2*Math.PI);Math.abs(y)>Math.PI&&(y=y>0?y-2*Math.PI:y+2*Math.PI),y/=this.m_unitToRad,i=t+y;const d=new m.Envelope2D;return d.xmin=Math.min(t,i),d.xmax=Math.max(t,i),d.ymin=Math.min(e,n),d.ymin=Math.min(d.ymin,g),d.ymax=Math.max(e,n),d.ymax=Math.max(d.ymax,g),d}minDistanceGeodesic(t,e){const i=l(t),n=l(e);if(i&&n)return this.lowerDistanceGeodetic_(t.xmin,t.ymin,e.xmin,e.ymin);const s=this.normalizeGeodesic_(e,t);return function(t,e){return e.xmax<t.xmin||e.xmin>t.xmax||e.ymax<t.ymin||e.ymin>t.ymax}(t,s)?t.ymin>=s.ymax?this.minDistanceGeodesicUpDown_(t,s):s.ymin>=t.ymax?this.minDistanceGeodesicUpDown_(s,t):t.xmin>s.xmax?this.minDistanceGeodesicLeftRight_(s,t):this.minDistanceGeodesicLeftRight_(t,s):0}normalizeGeodesic_(t,e){const i=t.clone(),n=t.clone();let s=_(i,e);if(0===s)return i;for(;n.xmax>e.xmin;){n.xmin-=this.m_u360,n.xmax-=this.m_u360;const t=_(n,e);if(t<s&&(i.assign(n),s=t,0===s))return i}for(n.assign(t);n.xmin<e.xmax;){n.xmin+=this.m_u360,n.xmax+=this.m_u360;const t=_(n,e);if(t<s&&(i.assign(n),s=t,0===s))return i}return i}lowerDistanceGeodetic_(t,e,i,n){const s=this.m_peR1;{const r=this.m_b*this.m_b/this.m_a,m=o.R.phiToPhig(this.m_e2,this.m_unitToRad*e),a=o.R.phiToPhig(this.m_e2,this.m_unitToRad*n);o.I.geodeticDistance(r,0,this.m_unitToRad*t,m,this.m_unitToRad*i,a,s,null,null,0)}return s.val}minDistanceGeodesicUpDown_(t,e){if(e.xmin<=t.xmin?e.xmax>=t.xmin:t.xmax>=e.xmin)return this.lowerDistanceGeodetic_(0,t.ymin,0,e.ymax);if(e.xmin>t.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);return Math.min(i,n)}{const i=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);return Math.min(i,n)}}minDistanceGeodesicLeftRight_(t,e){let i=Math.abs(t.xmax-e.xmin);for(;i>this.m_u180;)i-=this.m_u360;let n=Math.abs(t.xmin-e.xmax);for(;n>this.m_u180;)n-=this.m_u360;return Math.abs(i)<=Math.abs(n)?this.minDistanceGeodesicLeftRightNormalized_(t,e):this.minDistanceGeodesicLeftRightNormalized_(e,t)}minDistanceGeodesicLeftRightNormalized_(t,e){let i,n;return i=this.lowerDistanceGeodetic_(t.xmax,t.ymin,e.xmin,e.ymin),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymin,e.xmin,e.ymin,e.ymax),i=Math.min(i,n)),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymin,t.xmax,t.ymin,t.ymax),i=Math.min(i,n)),n=this.lowerDistanceGeodetic_(t.xmax,t.ymax,e.xmin,e.ymax),i=Math.min(i,n),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymax,e.xmin,e.ymin,e.ymax),i=Math.min(i,n)),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymax,t.xmax,t.ymin,t.ymax),i=Math.min(i,n)),i}lowerDistanceGeodeticSegMeridional_(t,e,i,n,s,o){let r=this.lowerDistanceGeodeticPtMeridional_(t,e,n,s,o);const m=this.lowerDistanceGeodeticPtMeridional_(t,i,n,s,o);let a=this.lowerDistanceGeodeticPtMeridional_(n,s,t,e,i);const u=this.lowerDistanceGeodeticPtMeridional_(n,o,t,e,i);return r=Math.min(r,m),a=Math.min(a,u),Math.min(r,a)}lowerDistanceGeodeticPtMeridional_(t,e,i,n,m){const a=this.m_b*this.m_b/this.m_a,u=o.R.phiToPhig(this.m_e2,this.m_unitToRad*e),c=o.R.phiToPhig(this.m_e2,this.m_unitToRad*n),h=o.R.phiToPhig(this.m_e2,this.m_unitToRad*m),l=this.m_peR1,_=this.m_peR2;o.I.geodeticDistance(a,0,this.m_unitToRad*i,c,this.m_unitToRad*t,u,l,null,null,0),o.I.geodeticDistance(a,0,this.m_unitToRad*i,h,this.m_unitToRad*t,u,_,null,null,0);const p=(0,o.Q)(1,0,new s.P(this.m_unitToRad*t,u)),g=(0,o.Q)(1,0,new s.P(this.m_unitToRad*i,c)),y=(0,o.Q)(1,0,new s.P(this.m_unitToRad*i,h));let d=new r.d;d.setCrossProductVector(g,y);const x=g.dotProduct(y);if(d.length()<1.568e-10)return x>=0?Math.min(l.val,_.val):0;d=d.getUnitVector();let P=new r.d;if(P.setCrossProductVector(d,p),P.length()<1.568e-10)return Math.min(l.val,_.val)-1e-5*a;P=P.getUnitVector();let D=p.sub(d.mul(p.dotProduct(d)));{const e=new r.d;e.setCrossProductVector(g,D);const i=new r.d;i.setCrossProductVector(D,y);let n=d.dotProduct(e)>0&&d.dotProduct(i)>0;if(n||(D.negateThis(),e.setCrossProductVector(g,D),i.setCrossProductVector(D,y),n=d.dotProduct(e)>0&&d.dotProduct(i)>0),n){D=D.getUnitVector();const e=(0,o.ad)(1,0,D),i=this.m_peR3;o.I.geodeticDistance(a,0,this.m_unitToRad*t,u,e.x,e.y,i,null,null,0);const n=Math.min(l.val,_.val);return Math.min(n,i.val)}}return Math.min(l.val,_.val)}}function l(t){return t.xmin===t.xmax&&t.ymin===t.ymax}function _(t,e){let i,n=0;return i=t.xmin-e.xmax,i>n&&(n=i),i=e.xmin-t.xmax,i>n&&(n=i),n}class p{}function g(t){return{outPoint:void 0===t?new s.P:t.clone()}}function y(t,e){t.outPoint.assign(e.outPoint)}function d(){return new m.Envelope2D}class x{constructor(t,e,i,n,m=0,a=4){this.m_ptDistFrom=new s.P,this.m_segStartPt=new s.P,this.m_segEndPt=new s.P,this.m_geodeticLength=new o.H,this.m_az12=new o.H,this.m_minGeodeticDist=new o.H,this.m_segStartPt3d=new r.d,this.m_segEndPt3d=new r.d,this.m_sr=n,this.m_distCurveType=m,this.m_segCurveType=a,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();const u=(0,o.y)();this.m_inputGCS.querySpheroidData(u),this.m_a=u.majorSemiAxis,this.m_eSquared=u.e2,this.setPointDistFrom(t),this.setSegmentEndPoints(e,i)}setSegmentEndPoints(t,e){this.m_segStartPt.assign(t),this.m_segEndPt.assign(e),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),2===this.m_segCurveType&&(this.m_segStartPt3d.assign((0,o.Q)(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign((0,o.Q)(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(t){this.m_ptDistFrom.assign(t),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(t){this.m_segCurveType=t}setDistanceCurveType(t){this.m_distCurveType=t}makeFunctor(){return t=>{let e;switch(this.m_segCurveType){case 0:case 1:case 3:{const i={stack:[],error:void 0,hasError:!1};try{const r=(0,n.a)(i,new o.H,!1),m=(0,n.a)(i,new o.H,!1);o.I.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*t,this.m_az12.val,r,m,this.m_segCurveType),e=new s.P(r.val,m.val);break}catch(t){i.error=t,i.hasError=!0}finally{(0,n.b)(i)}}case 2:{const i=r.d.lerp(this.m_segStartPt3d,this.m_segEndPt3d,t);e=(0,o.ad)(this.m_a,this.m_eSquared,i);break}case 4:e=s.P.lerp(this.m_segStartPt,this.m_segEndPt,t),this.m_bIsPannablePcs&&((0,o.ak)(this.m_sr,0,[e],1),e.mulThis(this.m_rpu));break;default:(0,s.p)("Invalid curve type")}return o.I.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,e.x,e.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:o.I.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=s.P.distance(this.m_segStartPt,this.m_segEndPt);break;default:(0,s.p)("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}function P(){return new p}class D{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(t,e,i,n,s){this.m_boxGeomA=d(),this.m_boxGeomB=d(),this.m_envGeomA=new m.Envelope2D,this.m_envGeomB=new m.Envelope2D,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new a.T,this.m_scaleToDegrees=new a.T,this.m_inputSR=t,this.m_distCurveType=e,this.m_progressTracker=i,this.m_maxDistance=n,this.m_maxDeviation=s,this.m_inputGCS=t.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const r=(0,o.y)();this.m_inputGCS.querySpheroidData(r),this.m_a=r.majorSemiAxis,this.m_eSquared=r.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new h(this.m_a,this.m_eSquared,1),4===this.m_distCurveType&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(t=!1){}calculate(t,e,i,n){const s=g(),o=g();if(t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(t,e,s,o))return i&&y(i,s),n&&y(n,o),0;const r=this.prepareGeometry(t);if(r.isEmpty())return Number.NaN;const m=this.prepareGeometry(e);if(m.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(r,m);const a=this._ExecuteBruteForce(r,m,s,o);return a>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(s),y(i,s)),n&&(this.prepareOutput(o),y(n,o)),a)}createDistanceFunctor(t,e,i){const n=new x(t,e,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType()||n.setSegmentCurveType(2),n}_NormalizeAndProject(t){if(this.m_inputSR.isPannable()&&(t=(new o.G).foldInto360Range(t,this.m_inputSR)),2===this.m_inputSR.getCoordinateSystemType()){const e=(0,o.N)(this.m_inputSR,this.m_inputGCS,null);t=(new o.G).execute(t,e,this.m_progressTracker)}return t}_ExecuteBruteForce(t,e,i,n){switch(t.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointGeometry(t,e,i,n);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:case s.G.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticPointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointPoint(t,e,i,n);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticPointPoint(t,e,i,s){const r={stack:[],error:void 0,hasError:!1};try{const m=t.getXY();m.scale(this.m_rpu);const a=e.getXY();a.scale(this.m_rpu),i.outPoint.assign(m),s.outPoint.assign(a);const u=(0,n.a)(r,new o.H,!1);return o.I.geodeticDistance(this.m_a,this.m_eSquared,m.x,m.y,a.x,a.y,u,null,null,this.m_distCurveType),u.val}catch(t){r.error=t,r.hasError=!0}finally{(0,n.b)(r)}}calculateDistanceGeodeticPointMultipoint(t,e,i,m){const a={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(t,e);const u=this.estimateMinimumDistance(i,m);let c=u<this.m_maxDistance?u:this.m_maxDistance;const h=t.getXY();h.scale(this.m_rpu),i.outPoint.assign(h);const l=(0,o.Q)(this.m_a,this.m_eSquared,h),_=new s.P,p=e.getImpl(),g=(0,n.a)(a,new o.H,!1),y=p.getPointCount();for(let t=0;t<y;++t){p.queryXY(t,_),_.scale(this.m_rpu);const e=(0,o.Q)(this.m_a,this.m_eSquared,_);if(!(r.d.distance(l,e)>c)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>c)&&(o.I.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,_.x,_.y,g,null,null,this.m_distCurveType),g.val<c&&(c=g.val,m.outPoint=_,0===c)))return c}return c===this.m_maxDistance?Number.POSITIVE_INFINITY:c}catch(t){a.error=t,a.hasError=!0}finally{(0,n.b)(a)}}calculateDistanceGeodeticPointMultipath(t,e,i,r){const m={stack:[],error:void 0,hasError:!1};try{const a=new s.P,u=new s.P;a.assign(t.getXY()),u.assign(t.getXY()),i.outPoint.assign(u.mul(this.m_rpu)),this.m_bIsPannablePcs&&(0,o.aj)(this.m_inputSR,[a],1,!1),this.computeEnvelopesAndBoxes(t,e);const c=this.estimateMinimumDistance(i,r);let h=c<this.m_maxDistance?c:this.m_maxDistance;const l=e.getImpl(),_=new s.P(0,0),p=new s.P(0,0),g=[1],y=this.canUseSpatialTree(t,e),x=P();y&&this.buildSpatialTree(x,e);const D=d();D.setCoords({xmin:u.x,ymin:u.y,xmax:u.x,ymax:u.y});const v=(0,n.a)(m,this.createDistanceFunctor(u,_,p),!1),G=l.querySegmentIterator();if(G.stripAttributes(),y)(0,s.b)(0);else for(;G.nextPath();)for(;G.hasNextSegment();){const t=G.nextSegment(),e=this.findOrComputeBoxSegment(G.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(D,e)>h)continue;const i=this.calculateDistanceGeodeticPointSegment(a,u,t,g,v);if(i.second<h&&(this.updateOutputSegment(r,t,i.first),h=i.second,0===h))return 0}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){m.error=t,m.hasError=!0}finally{(0,n.b)(m)}}calculateDistanceGeodeticMultipointGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,n,i);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(t,e,i,n);case s.G.enumPolyline:case s.G.enumPolygon:case s.G.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticMultipointMultipoint(t,e,i,m){const a={stack:[],error:void 0,hasError:!1};try{const u=(0,n.a)(a,new o.H,!1);this.computeEnvelopesAndBoxes(t,e);const c=this.estimateMinimumDistance(i,m);let h=c<this.m_maxDistance?c:this.m_maxDistance;const l=new s.P,_=new s.P,p=t.getImpl(),g=e.getImpl(),y=d(),x=p.getPointCount(),P=g.getPointCount();for(let t=0;t<x;++t){if(l.assign(p.getXY(t)),y.setCoords({xmin:l.x,ymin:l.y,xmax:l.x,ymax:l.y}),this.m_envHelper.minDistanceGeodesic(y,this.m_boxGeomB)>h)continue;l.scale(this.m_rpu);const e=(0,o.Q)(this.m_a,this.m_eSquared,l);for(let t=0;t<P;++t){_.assign(g.getXY(t)),_.scale(this.m_rpu);const n=(0,o.Q)(this.m_a,this.m_eSquared,_);if(!(r.d.distance(e,n)>=h)&&(o.I.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,_.x,_.y,u,null,null,this.m_distCurveType),u.val<h&&(i.outPoint.assign(l),m.outPoint.assign(_),h=u.val,0===h)))return h}}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){a.error=t,a.hasError=!0}finally{(0,n.b)(a)}}calculateDistanceGeodeticMultipointMultipath(t,e,i,r){const m={stack:[],error:void 0,hasError:!1};try{const a=e.getImpl().querySegmentIterator();a.stripAttributes(),this.computeEnvelopesAndBoxes(t,e);const u=this.estimateMinimumDistance(i,r);let c=u<this.m_maxDistance?u:this.m_maxDistance;const h=new s.P,l=new s.P(0,0),_=new s.P(0,0),p=new s.P(0,0),g=[0],y=d(),x=(0,n.a)(m,this.createDistanceFunctor(l,_,p),!1),D=P(),v=this.canUseSpatialTree(t,e);v&&this.buildSpatialTree(D,e);const G=t.getPointCount();for(let e=0;e<G;++e)if(h.assign(t.getXY(e)),l.assign(t.getXY(e)),this.m_bIsPannablePcs&&(0,o.aj)(this.m_inputSR,[h],1,!1),y.setCoords({xmin:l.x,ymin:l.y,xmax:l.x,ymax:l.y}),!(this.m_envHelper.minDistanceGeodesic(y,this.m_boxGeomB)>c))if(x.setPointDistFrom(l),v)(0,s.b)(0);else{for(;a.nextPath();)for(;a.hasNextSegment();){const t=a.nextSegment();if(this.m_envHelper.minDistanceGeodesic(y,this.findOrComputeBoxSegment(a.getStartPointIndex(),t,this.m_segmentBoxesB))>c)continue;const e=this.calculateDistanceGeodeticPointSegment(h,l,t,g,x);if(e.second<c&&(i.outPoint.assign(l.mul(this.m_rpu)),this.updateOutputSegment(r,t,e.first),c=e.second,0===c))return 0}a.resetToFirstPath()}return c===this.m_maxDistance?Number.POSITIVE_INFINITY:c}catch(t){m.error=t,m.hasError=!0}finally{(0,n.b)(m)}}calculateDistanceGeodeticMultipathGeometry(t,e,i,n){switch(e.getGeometryType()){case s.G.enumPoint:return this.calculateDistanceGeodeticPointMultipath(e,t,n,i);case s.G.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(e,t,n,i);case s.G.enumPolyline:case s.G.enumPolygon:case s.G.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(t,e,i,n);default:(0,s.a)("")}}calculateDistanceGeodeticMultipathMultipath(t,e,i,n){const o=[t],r=[e],m=this.swapGeometries(o,r),a=o[0],u=r[0];this.computeEnvelopesAndBoxes(o[0],r[0]);const c=this.estimateMinimumDistance(i,n),h=this.calculateDistanceGeodeticMultipathMultipath_(a,u,i,n,c);return m&&(n.outPoint=(0,s.f)(i.outPoint,i.outPoint=n.outPoint)),h}calculateDistanceGeodeticMultipathMultipath_(t,e,i,r,m=Number.MAX_VALUE){const a={stack:[],error:void 0,hasError:!1};try{let c=m;const h=new s.P(0,0),l=new s.P,_=new s.P(0,0),p=new s.P,g=new s.P(0,0),y=new s.P,x=new s.P,D=new s.P,v=[new s.P],G=[0],f=[0],S=d(),b=d(),M=(0,n.a)(a,this.createDistanceFunctor(g,h,_),!1),E=P(),I=this.canUseSpatialTree(t,e);I&&this.buildSpatialTree(E,e);const T=e.querySegmentIterator();T.stripAttributes();const N=new o.S,w=(0,u.s)(t);for(let e=0;e<w.length;++e){const n=w[e];t.getSegmentBuffer(n,N,!0);const m=N.get();if(S.assign(this.findOrComputeBoxSegment(n,m,this.m_segmentBoxesA)),I)(0,s.b)(0);else{if(g.assign(m.getStartXY()),y.assign(m.getStartXY()),x.assign(m.getEndXY()),D.assign(m.getEndXY()),this.m_bIsPannablePcs&&((0,o.ak)(this.m_inputSR,0,[y],1),(0,o.ak)(this.m_inputSR,0,[D],1)),this.m_envHelper.minDistanceGeodesic(S,this.m_boxGeomB)>c)continue;for(;T.nextPath();){for(;T.hasNextSegment();){const t=T.nextSegment();if(h.assign(t.getStartXY()),l.assign(t.getStartXY()),_.assign(t.getEndXY()),p.assign(t.getEndXY()),m.intersect(t,v,G,f,this.m_tolerance))return this.updateOutputSegment(i,m,G[0]),this.updateOutputSegment(r,t,f[0]),0;if(this.m_bIsPannablePcs&&((0,o.ak)(this.m_inputSR,0,[l],1),(0,o.ak)(this.m_inputSR,0,[p],1)),b.assign(this.findOrComputeBoxPoint(T.getStartPointIndex(),l,p,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(S,b)>c)continue;M.setSegmentEndPoints(h,_),M.setPointDistFrom(y);let e=(0,o.al)(M.makeFunctor(),0,1,1e-10);if(e.second<c&&(i.outPoint.assign(y.mul(this.m_rpu)),this.updateOutputSegment(r,t,e.first),c=e.second,0===c))break;if(M.setPointDistFrom(D),e=(0,o.al)(M.makeFunctor(),0,1,1e-10),e.second<c&&(i.outPoint.assign(D.mul(this.m_rpu)),this.updateOutputSegment(r,t,e.first),c=e.second,0===c))break;if(M.setSegmentEndPoints(g,x),M.setPointDistFrom(l),e=(0,o.al)(M.makeFunctor(),0,1,1e-10),e.second<c&&(this.updateOutputSegment(i,m,e.first),r.outPoint.assign(l.mul(this.m_rpu)),c=e.second,0===c))break;if(M.setPointDistFrom(p),e=(0,o.al)(M.makeFunctor(),0,1,1e-10),e.second<c&&(this.updateOutputSegment(i,m,e.first),r.outPoint.assign(p.mul(this.m_rpu)),c=e.second,0===c))break}if(0===c)return 0}T.resetToFirstPath()}}return c===this.m_maxDistance?Number.POSITIVE_INFINITY:c}catch(t){a.error=t,a.hasError=!0}finally{(0,n.b)(a)}}calculateDistanceGeodeticPointSegment(t,e,i,n,r){const m=i.getStartXY(),a=i.getEndXY();return i.intersectPoint(t,n,this.m_tolerance)?(0,s.D)(n[0],0):(r.setPointDistFrom(e),r.setSegmentEndPoints(m,a),(0,o.al)(r.makeFunctor(),0,1,1e-10))}prepareGeometry(t){let e=t.clone();const i=t.getGeometryType();if(i===s.G.enumPoint||i===s.G.enumMultiPoint)return this._NormalizeAndProject(e);if(i===s.G.enumEnvelope&&(e=this.envelopeToPolygon(e)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(e,4);if(2===this.m_inputSR.getCoordinateSystemType()){if(e=(0,o.a8)(e,this.m_inputSR,0,null),e.isEmpty())return e;e=(new c.O).execute(e,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const t=this.m_inputSR.getSRToGCSTransform();return(new o.G).execute(e,t,this.m_progressTracker)}const n=new m.Envelope2D;e.queryLooseEnvelope(n);const r=this.m_inputSR.getPannableExtent();if(n.ymin<r.ymin||n.ymax>r.ymax){const t=new m.Envelope2D(n.xmin-1,r.ymin,n.xmax+1,r.ymax);if(e=(new o.K).execute(e,t,this.m_inputSR,this.m_progressTracker),e.isEmpty())return e}return n.width()>2*r.width()?(e=(0,o.am)(e,-2*r.width(),2*r.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker),e):e}prepareGeometryPannable(t,e){const i=new m.Envelope2D;t.queryEnvelope(i);const n=this.m_inputSR.getPannableExtent();if(n.containsEnvelope(i))return t;const r=new s.E;n.queryIntervalX(r);const a=new s.E;return i.queryIntervalX(a),r.contains(a)?(0,o.A)(t,this.m_inputSR):(new o.G).foldInto360RangeGeodetic(t,this.m_inputSR,e)}prepareOutput(t){t.outPoint.scale(1/this.m_rpu),2===this.m_inputSR.getCoordinateSystemType()&&(0,o.aj)(this.m_inputSR,[t.outPoint],1,!1)}updateOutputSegment(t,e,i){e.queryCoord2D(i,t.outPoint),this.m_bIsPannablePcs&&(0,o.ak)(this.m_inputSR,0,[t.outPoint],1),t.outPoint.mulThis(this.m_rpu)}computeTolerance(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB);const i=new m.Envelope2D(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),(0,r.a)(null,i)}envelopeToPolygon(t){const e=new o.P;return e.addEnvelope(t,!1),e}computeEnvelopesAndBoxes(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(t,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(e,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(t,e,i){switch(t.getGeometryType()){case s.G.enumPoint:return this.computeBoxPoint(t,e);case s.G.enumMultiPoint:return this.computeBoxMultiPoint(t,e);case s.G.enumPolyline:case s.G.enumPolygon:return this.computeBoxMultiPath(t,e,i);default:(0,s.p)("Invalid geometry type")}}computeBoxPoint(t,e){const i=t.getXY();e.length=0,e.push(i.mul(this.m_rpu));const n=d();return n.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),n}computeBoxMultiPoint(t,e){let i=!0;for(let n=0;n<t.getPointCount();++n){const s=t.getXY(n);if(i){e.length=0;for(let t=0;t<4;++t)e.push(s.clone());i=!1}s.x<e[0].x&&e[0].assign(s),s.y>e[1].y&&e[1].assign(s),s.x>e[2].x&&e[2].assign(s),s.y<e[3].y&&e[3].assign(s)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);const n=d();return t.queryEnvelope(n),n}computeBoxMultiPath(t,e,i){let n=!0;const s=d();s.setEmpty();const r=t.querySegmentIterator();for(r.stripAttributes();r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment(),m=t.getStartXY(),a=t.getEndXY();if(this.m_bIsPannablePcs&&((0,o.ak)(this.m_inputSR,0,[m],1),(0,o.ak)(this.m_inputSR,0,[a],1)),n){for(let t=0;t<4;++t)e.push(m.clone());n=!1}m.x<e[0].x&&e[0].assign(m),m.y>e[1].y&&e[1].assign(m),m.x>e[2].x&&e[2].assign(m),m.y<e[3].y&&e[3].assign(m),a.x<e[0].x&&e[0].assign(a),a.y>e[1].y&&e[1].assign(a),a.x>e[2].x&&e[2].assign(a),a.y<e[3].y&&e[3].assign(a);const u=this.findOrComputeBoxPoint(r.getStartPointIndex(),m,a,i);s.mergeEnvelope2D(u)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);return s}findOrComputeBoxSegment(t,e,i){if(!i.has(t)){let n=d();if(e.queryEnvelope(n),this.m_bIsPannablePcs){const t=s.P.construct(n.xmin,n.ymin),e=s.P.construct(n.xmax,n.ymax);(0,o.ak)(this.m_inputSR,0,[t],1),(0,o.ak)(this.m_inputSR,0,[e],1),n=this.m_envHelper.calculateBbox(t.x,t.y,e.x,e.y)}return i.set(t,n),n}return i.get(t)}findOrComputeBoxPoint(t,e,i,n){if(!n.has(t)){let s=d();return s.setCoords({xmin:e.x,ymin:e.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(s=this.m_envHelper.calculateBbox(s.xmin,s.ymin,s.xmax,s.ymax)),n.set(t,s),s}return n.get(t)}estimateMinimumDistance(t,e){const i={stack:[],error:void 0,hasError:!1};try{const s=t=>(0,o.Q)(this.m_a,this.m_eSquared,t),m=this.m_boundaryPtsA.map(s),a=this.m_boundaryPtsB.map(s);let u=Number.MAX_VALUE,c=0,h=0;for(let t=0;t<m.length;++t)for(let e=0;e<a.length;++e){const i=r.d.distance(m[t],a[e]);i<u&&(u=i,c=t,h=e)}t.outPoint.assign(this.m_boundaryPtsA[c]),e.outPoint.assign(this.m_boundaryPtsB[h]);const l=(0,n.a)(i,new o.H,!1);return o.I.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[c].x,this.m_boundaryPtsA[c].y,this.m_boundaryPtsB[h].x,this.m_boundaryPtsB[h].y,l,null,null,this.m_distCurveType),l.val}catch(t){i.error=t,i.hasError=!0}finally{(0,n.b)(i)}}swapGeometries(t,e){return(0,s.w)(t[0])>(0,s.w)(e[0])&&(e[0]=(0,s.f)(t[0],t[0]=e[0]),this.m_envGeomB=(0,s.f)(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(t,e){return!1}checkGeometriesIntersect(t,e,i,n){let r=t.getGeometryType(),m=e.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(r===s.G.enumPoint&&2===e.getDimension()){const s=[0],r=[t.getXY()];if((0,o.an)(e,r,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(r[0]),n.outPoint.assign(r[0]),!0}else if(m===s.G.enumPoint&&2===t.getDimension()){const s=[2],r=[e.getXY()];if((0,o.an)(t,r,1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(r[0]),n.outPoint.assign(r[0]),!0}if(r===s.G.enumMultiPoint&&2===e.getDimension())return this.multipointIntersectsArea(t,e,i,n);if(m===s.G.enumMultiPoint&&2===t.getDimension())return this.multipointIntersectsArea(e,t,n,i);let a,c,h=t,l=e;if(r===s.G.enumEnvelope&&(a=this.envelopeToPolygon(t),h=a,r=s.G.enumPolygon),m===s.G.enumEnvelope&&(c=this.envelopeToPolygon(e),l=c,m=s.G.enumPolygon),(0,s.u)(r)&&(0,s.u)(m)){const t=h.querySegmentIterator(),e=l.querySegmentIterator(),s=(0,u.m)(),o=(0,u.m)();if((0,u.w)(h,l,t,e,s,o))return i.outPoint.assign(s.outPoint),n.outPoint.assign(s.outPoint),!0}}return!1}multipointIntersectsArea(t,e,i,n){const s=t.getPointCount();for(let r=0;r<s;++r){const s=[2],m=t.getXY(r);if((0,o.an)(e,[m],1,this.m_tolerance,s),0!==s[0])return i.outPoint.assign(m),n.outPoint.assign(m),!0}return!1}getNearestNeighbourVisitor(t,e,i,n,o,r,m){return(0,s.b)(0),{}}buildSpatialTree(t,e){(0,s.b)(0)}}},87725:(t,e,i)=>{i.r(e),i.d(e,{OperatorGeodeticDensifyByLength:()=>r,OperatorGeodeticDensifyCursor:()=>m});var n=i(88010),s=i(23160),o=i(6550);i(82604),i(43802),i(94981),i(32816);class r{getOperatorType(){return 10310}supportsCurves(){return!0}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,i,n,s){return new m(t,i,n,e,-1,-1,s)}execute(t,e,i,o,r){const m=new n.S([t]),a=this.executeMany(m,e,i,o,r).next();return a||(0,s.p)("null output"),a}}class m extends n.G{constructor(t,e,i,n,o,r,m){super(),this.m_progressTracker=m,r>0&&(0,s.t)(""),4!==i&&o>0&&(0,s.t)(""),e||(0,s.a)(""),0===e.getCoordinateSystemType()&&(0,s.a)(""),n>0||o>0||(0,s.a)(""),this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_curveType=i,this.m_maxLengthMeters=n,this.m_maxDeviationMeters=o,this.m_maxAngle=r}next(){{let t;for(;t=this.m_inputGeoms.next();)return(0,s.v)(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.geodeticDensify(t);return null}}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodeticDensify(t){return(0,o.U)(t,this.m_spatialReference,this.m_curveType,this.m_maxLengthMeters,this.m_maxDeviationMeters,this.m_progressTracker)}}},88010:(t,e,i)=>{i.d(e,{G:()=>n,S:()=>s});class n{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class s extends n{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}}}]);