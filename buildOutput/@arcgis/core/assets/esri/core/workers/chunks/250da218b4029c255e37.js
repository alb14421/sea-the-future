"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[2269],{42269:(e,t,s)=>{s.r(t),s.d(t,{OperatorGeodesicBuffer:()=>v});var n=s(88010),i=s(23160),r=s(82604),o=s(6550),m=s(32816),a=s(43802),h=s(94981),u=s(63227);class c{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){const t=new o.P,s=new w(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferPolyline(e){const t=new w(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){const t=new S(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){const t=e.getXY();t.scale(this.m_rpu);let s=new o.P;if(this.bufferPoint2D(t,!1,s)){const e=(0,a.b)(null,s,!0);s=(0,o.p)(s,e,!0,!0,-1,this.m_progressTracker,0,!1)}return s=(new o.G).foldInto360RangeGeodetic(s,this.m_gcs,2),s}processGnomonicBufferPiecesCursor(e,t){const s=t;let n=s.getGnomonic();const m=(0,o.W)((0,o.X)());let u=new o.Y,c=(new o.O).executeMany(u,m,this.m_progressTracker,2);const l=(0,i.r)(6,!1),_=(0,i.m)(r.Envelope2D,6);this.initializeGrid(l,_);const f=[null,null,null,null,null,null],d=[null,null,null,null,null,null],g=[null,null,null,null,null,null];let P,p,x;for(;null!==(P=s.next());){if(p=s.getGnomonic(),p!==n){if(null!==n){let t=c.next();if(u=null,c=null,null!=t){const s=(0,a.b)(m,t,!0),i=(0,a.e)(s);t=n.unproject(t,i,this.m_progressTracker),this.putInGridCursors(e,t,m,!0,l,_,f,d,g)}}null!==p&&(u=new o.Y,c=(new o.O).executeMany(u,m,this.m_progressTracker,2)),n=p}if(s.isRunningInGnomonic()){if(p.project(P),s.needsSimplify()){const e=(0,a.b)(null,P,!0);P=(0,o.p)(P,e,!0,!0,-1,this.m_progressTracker,0,!1)}u.tick(y(P)),c.tock()}else this.putInGridCursors(e,P,m,!0,l,_,f,d,g)}let b=!1;for(let e=0;e<6;e++)if(null!=g[e]){b=!0;break}if(b){let t=!1;const i=[null,null,null,null,null,null];if(e){const n=s.m_densified;if(s.m_densified=null,null!==n){const s=new h.T;s.scale(1/this.m_rpu,1/this.m_rpu),n.applyTransformation(s),this.m_distance>0?this.putInGridCursors(e,n,m,!1,l,_,f,d,g):(this.processInGrid(e,n,!1,l,_,f,i),t=!0)}}const r=new o.Y,P=(new o.O).executeMany(r,this.m_gcs,this.m_progressTracker,2);if(null!==c){let t=c.next();u=null,c=null;const s=(0,a.b)(m,t,!0),i=(0,a.e)(s);t=n.unproject(t,i,this.m_progressTracker),this.putInGridCursors(e,t,m,!0,l,_,f,d,g)}for(let e=0;e<6;e++)if(null!=g[e]){let s=g[e].next();g[e]=null,d[e]=null,t&&null!==i[e]&&(s=(new o.Z).execute(i[e],s,m,this.m_progressTracker));const n=(0,a.b)(m,s,!0),h=(0,a.e)(n);s=f[e].unproject(s,h,this.m_progressTracker),s=(new o.d).execute(s,this.m_gcs,!0,this.m_progressTracker),r.tick(y(s)),P.tock()}x=P.next()}else{let t,i=!1;if(e){let e=s.m_densified;if(s.m_densified=null,null!==e){const s=new h.T;s.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(s),p.project(e);const n=(0,a.b)(null,e,!0);e=(0,o.p)(e,n,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(u.tick(y(e)),c.tock()):(t=e,i=!0)}}let r=c.next();u=null,c=null,i&&(r=(new o.Z).execute(t,r,m,this.m_progressTracker));const l=(0,a.b)(m,r,!0),_=(0,a.e)(l);x=n.unproject(r,_,this.m_progressTracker),x=(new o.d).execute(x,this.m_gcs,!0,this.m_progressTracker)}return x=(new o.G).foldInto360RangeGeodetic(x,this.m_gcs,2),x}putInGridCursors(e,t,s,n,i,r,m,a,h){const u=[null,null,null,null,null,null];this.processInGrid(e,t,n,i,r,m,u);for(let e=0;e<6;e++)null!==u[e]&&(null===a[e]&&(a[e]=new o.Y,h[e]=(new o.O).executeMany(a[e],s,this.m_progressTracker,2)),a[e].tick(y(u[e])),h[e].tock())}processInGrid(e,t,s,n,r,m,h){const u=.01,c=this.insertGeodeticPointsAlongGrid(t,r,u);for(let e=0;e<6;e++){if(n[e])continue;const l=r[e].clone();l.inflateCoords(u,u);const _=(0,a.f)(t,l),f=(0,a.c)(null,_,!1).total();let d=(0,o._)(c,l,f,Number.NaN,this.m_progressTracker);if(null!==d&&!d.isEmpty()){if(d===c&&(d=d.clone()),null===m[e]){const t=new i.P;e<3?t.setCoords(0,1):t.setCoords(0,-1);const s=new i.P;s.setAdd(r[e].getCenter(),t),m[e]=b(this.m_gcs,s)}m[e].project(d);const t=(0,a.b)(null,d,!0);d=(0,o.p)(d,t,s,!0,-1,this.m_progressTracker,0,!1),h[e]=d}}}insertGeodeticPointsAlongGrid(e,t,s){const n=r.Envelope2D.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),i=(0,o.$)(this.m_gcs,n,e,!0,this.m_progressTracker),m=new o.E,a=m.addGeometry(i);return(0,o.a0)(m,a,this.m_gcs,0,2,!0,t[0].xmax+s),(0,o.a0)(m,a,this.m_gcs,0,2,!0,t[1].xmax+s),(0,o.a0)(m,a,this.m_gcs,0,2,!1,t[1].ymin+s),0!==s&&((0,o.a0)(m,a,this.m_gcs,0,2,!0,t[0].xmax-s),(0,o.a0)(m,a,this.m_gcs,0,2,!0,t[1].xmax-s),(0,o.a0)(m,a,this.m_gcs,0,2,!1,t[1].ymin-s)),m.getGeometry(a)}initializeGrid(e,t){for(let t=0;t<6;t++)e[t]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,s,n,r,m){const a=e[0],h=e.at(-1),u=a.y<h.y?a.y:h.y,c=a.y>h.y?a.y:h.y,l=o.R.q(this.m_a,this.m_eSquared,u),g=o.R.q(this.m_a,this.m_eSquared,c);if(this.m_q90-(l+t+this.m_absDistance)>.001&&this.m_q90+(g-t-this.m_absDistance)>.001)return!1;const P=s-i.B,p=n+i.B,x=P-Math.PI,b=P+Math.PI,y=p+Math.PI,C=[Number.NaN],w=[Number.NaN],S=[Number.NaN],v=[Number.NaN];let I=!1;if(d(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,P,x,h,p,C,w),d(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,h,y,p,a,x,S,v),(p<C[0]&&C[0]<y||p<w[0]&&w[0]<y)&&(I=!0),I||(x<S[0]&&S[0]<P||x<v[0]&&v[0]<P)&&(I=!0),!I&&r)return!1;const D=[];for(let t=e.length-1;t>=0;t--)D.push(e[t]);m.setEmpty(),m.addPathPoint2D(null,0,!0);let G=0;G=_(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,P,p,r,G,m),G=f(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,h,p,y,this.m_cornerStep,r,G,m,C[0],w[0]),G=_(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,D,y,b,r,G,m),G=f(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,x,P,this.m_cornerStep,r,G,m,S[0],v[0]);let T=!1;return r||(T=this.checkAndPrepForPole(m)),I||T}bufferPoint2D(e,t,s){s.setEmpty(),s.addPathPoint2D(null,0,!0),f(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,0,s);let n=!1;return t||(n=this.checkAndPrepForPole(s)),n}checkAndPrepForPole(e){const t=this.checkAndPrepForPoleTouch(e),s=this.checkAndPrepForPoleWrap(e);return t||s}checkAndPrepForPoleTouch(e){const t=new r.Envelope2D;return e.queryEnvelope(t),!(!(0,o.a1)(t.ymax,this.m_gcs90)&&!(0,o.a1)(t.ymin,-this.m_gcs90)||(this.prepPoleTouch(e),0))}checkAndPrepForPoleWrap(e){const t=e.getXY(0),s=e.getXY(e.getPointCount()-1);return Math.abs(t.x-s.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){const t=new o.P;t.insertPath2D(-1,null,0,0,!0);const s=e.getPathStart(0),n=e.getPathEnd(0),r=n-s;let m=-1;for(m=s;m<n;m++){const t=e.getXY(m),s=(0,o.a1)(t.y,this.m_gcs90),n=(0,o.a1)(t.y,-this.m_gcs90);if(!s&&!n)break}let a=m,h=!1,u=Number.NaN;do{const n=e.getXY(a),m=(0,o.a1)(n.y,this.m_gcs90),c=(0,o.a1)(n.y,-this.m_gcs90),l=s+(a+1-s)%r;if(m||c){let s=i.P.construct(u,n.y);t.insertPoint2D(0,-1,s);const r=e.getXY(l),m=(0,o.a1)(r.y,this.m_gcs90),a=(0,o.a1)(r.y,-this.m_gcs90);m||a||(s=i.P.construct(r.x,n.y),h?t.setXY(t.getPointCount()-1,s):t.insertPoint2D(0,-1,s)),h=!0}else t.insertPoint2D(0,-1,n),u=n.x,h=!1;a=l}while(a!==m);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){const t=new o.P,s=new o.P,n=new h.T,m=e.getXY(e.getPathStart(0)),u=e.getXY(e.getPathEnd(0)-1),c=this.m_gcs360,l=this.m_gcs180,_=new r.Envelope2D;_.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const f=new r.Envelope2D;e.queryEnvelope(f);const d=Math.ceil(f.width()/c);let g,P;m.x>u.x?(g=-c,P=this.m_gcs90):(g=c,P=-this.m_gcs90),n.setShiftCoords(g,0),t.addPath(e,0,!0),s.add(t,!1);const p=new a.P;for(let e=0;e<d;e++)s.applyTransformation(n),s.getPointByVal(0,p),t.lineToPoint(p),t.addSegmentsFromPath(s,0,0,s.getSegmentCount()-1,!1);const x=t.getXY(0),b=t.getXY(t.getPointCount()-1);x.y=P,b.y=P,t.lineTo(b);const y=new i.P;for(y.setCoordsPoint2D(b),y.x-=.5*g;Math.abs(y.x-x.x)>l;)t.lineTo(y),y.x-=.5*g;t.lineTo(x);const C=_.getCenterX(),w=new r.Envelope2D;t.queryEnvelope(w);let S=0;const v=w.getCenter().x;v-C>l?S=-Math.ceil((v-C-l)/c):C-v>l&&(S=Math.ceil((C-v-l)/c)),0!==S&&(n.setShiftCoords(S*c,0),t.applyTransformation(n));const I=new o.E,D=I.addGeometry(t);(0,o.a0)(I,D,this.m_gcs,0,2,!0,_.xmin),(0,o.a0)(I,D,this.m_gcs,0,2,!0,_.xmax);const G=I.getGeometry(D),T=(0,a.f)(G,_);T.inflateCoords(0,1);const M=(0,a.c)(null,T,!0).total(),E=(0,o._)(G,_,M,Number.NaN,this.m_progressTracker);e.setEmpty(),e.add(E,!1)}prepDoublePoleWrap(e){const t=this.m_gcs360,s=this.m_gcs180,n=new r.Envelope2D;n.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const m=n.getCenter().x,u=new r.Envelope2D;e.queryPathEnvelope(0,u);let c,l=0,_=u.getCenter().x;if(_-m>s?l=-Math.ceil((_-m-s)/t):m-_>s&&(l=Math.ceil((m-_-s)/t)),0!==l){const s=new h.T;s.setShiftCoords(l*t,0),e.getImpl().applyTransformationToPath(s,0),e.queryPathEnvelope(0,u),_=u.getCenter().x}const f=new r.Envelope2D;n.containsExclusiveEnvelope(u)?(c=!1,f.setCoords({env2D:n})):(c=!0,f.setCoords({env2D:n}),f.xmin-=t,f.xmax+=t);let d=e.createInstance();d.addPathPoint2D(null,0,!0);const g=new i.P;if(g.setCoords(f.xmin,f.ymin),d.insertPoint2D(0,-1,g),g.setCoords(f.xmin,f.ymax),d.insertPoint2D(0,-1,g),g.setCoords(.5*(f.xmin+f.xmax),f.ymax),d.insertPoint2D(0,-1,g),g.setCoords(f.xmax,f.ymax),d.insertPoint2D(0,-1,g),g.setCoords(f.xmax,f.ymin),d.insertPoint2D(0,-1,g),g.setCoords(.5*(f.xmin+f.xmax),f.ymin),d.insertPoint2D(0,-1,g),c){d.addPath(e,0,!0);const s=new h.T;_<m?s.setShiftCoords(t,0):s.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(s,0),d.addPath(e,0,!0);const i=new o.E,r=i.addGeometry(d);(0,o.a0)(i,r,this.m_gcs,0,2,!0,n.xmin),(0,o.a0)(i,r,this.m_gcs,0,2,!0,n.xmax),d=i.getGeometry(r);const u=(0,a.f)(d,n);u.inflateCoords(0,1);const c=(0,a.c)(null,u,!0).total();d=(0,o._)(d,n,c,Number.NaN,this.m_progressTracker)}else d.addPath(e,0,!0);e.setEmpty(),e.add(d,!1)}setMinCornerStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new i.P;s.setCoords(0,10*this.m_rpu);const n=0;let r=45*this.m_rpu;const a=(0,m.a)(e,new i.S(new o.H,new o.H),!1),h=(0,m.a)(e,new i.S(new o.H,new o.H),!1),u=(0,m.a)(e,new i.S(new o.H,new o.H),!1),c=(0,m.a)(e,new i.S(new o.H,new o.H),!1),l=new i.P,_=new i.P,f=new i.P,d=new i.P;for(o.I.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,n,a.at(0),a.at(1)),l.setCoords(a.at(0).val,a.at(1).val),o.I.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,r,h.at(0),h.at(1)),_.setCoords(h.at(0).val,h.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const i=.5*(n+r);o.I.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,i,u.at(0),u.at(1)),f.setCoords(u.at(0).val,u.at(1).val);const a=(0,m.a)(e,new o.H,!1),g=(0,m.a)(e,new o.H,!1);o.I.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,_.x,_.y,a,g,null,2),o.I.geodeticCoordinate(this.m_a,this.m_eSquared,l.x,l.y,.5*a.val,g.val,c.at(0),c.at(1),2),d.setCoords(c.at(0).val,c.at(1).val);const P=(0,m.a)(e,new o.H,!1);if(o.I.geodeticDistance(this.m_a,this.m_eSquared,f.x,f.y,d.x,d.y,P,null,null,2),P.val<=this.m_convergenceOffset)break;r*=.9,o.I.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,r,h.at(0),h.at(1)),_.setCoords(h.at(0).val,h.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{(0,m.b)(e)}}const g=r-n,P=2*Math.PI/Math.ceil(2*Math.PI/g);this.m_cornerStep=P}catch(t){e.error=t,e.hasError=!0}finally{(0,m.b)(e)}}setMinSegmentStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new i.P,n=new i.P;s.setCoords(0,10*this.m_rpu),n.setCoords(10*this.m_rpu,10*this.m_rpu);const r=(0,m.a)(e,new o.H,!1),a=(0,m.a)(e,new o.H,!1),h=(0,m.a)(e,new o.H,!1);o.I.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,h,r,a,this.m_curveType);const u=(0,m.a)(e,new i.S(new o.H,new o.H),!1),c=(0,m.a)(e,new i.S(new o.H,new o.H),!1),l=new i.P,_=(0,m.a)(e,new o.H,!1),f=(0,m.a)(e,new i.S(new o.H,new o.H),!1),d=(0,m.a)(e,new i.S(new o.H,new o.H),!1),g=(0,m.a)(e,new i.S(new o.H,new o.H),!1),P=(0,m.a)(e,new i.S(new o.H,new o.H),!1),p=new i.P,x=new i.P,b=new i.P,y=new i.P,C=0;let w=1;const S=r.val,v=a.val,I=S-.5*Math.PI,D=v+.5*Math.PI,G=h.val;for(o.I.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,I,f.at(0),f.at(1)),p.setCoords(f.at(0).val,f.at(1).val),o.I.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,t,D,d.at(0),d.at(1)),x.setCoords(d.at(0).val,d.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const i=.5*(C+w);o.I.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,i*G,S,u.at(0),u.at(1),this.m_curveType),l.setCoords(u.at(0).val,u.at(1).val),o.I.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,l.x,l.y,null,null,_,this.m_curveType);const r=_.val+.5*Math.PI;o.I.geodesicCoordinate(this.m_a,this.m_eSquared,l.x,l.y,t,r,g.at(0),g.at(1)),b.setCoords(g.at(0).val,g.at(1).val);const a=(0,m.a)(e,new o.H,!1),h=(0,m.a)(e,new o.H,!1);o.I.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,x.x,x.y,a,h,null,2),o.I.geodeticCoordinate(this.m_a,this.m_eSquared,p.x,p.y,.5*a.val,h.val,P.at(0),P.at(1),2),y.setCoords(P.at(0).val,P.at(1).val);const f=(0,m.a)(e,new o.H,!1);if(o.I.geodeticDistance(this.m_a,this.m_eSquared,b.x,b.y,y.x,y.y,f,null,null,2),f.val<=this.m_convergenceOffset)break;{const e={stack:[],error:void 0,hasError:!1};try{w*=.9,o.I.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,w*G,S,c.at(0),c.at(1),this.m_curveType),n.setCoords(c.at(0).val,c.at(1).val);const i=(0,m.a)(e,new o.H,!1);o.I.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,null,null,i,this.m_curveType);const r=i.val+.5*Math.PI;o.I.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,t,r,d.at(0),d.at(1)),x.setCoords(d.at(0).val,d.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{(0,m.b)(e)}}}catch(t){e.error=t,e.hasError=!0}finally{(0,m.b)(e)}}let T=w*G;T>1e5&&(T=1e5),this.m_segmentStep=T}catch(t){e.error=t,e.hasError=!0}finally{(0,m.b)(e)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}}function l(e,t,s,n,m,h,u){if(e.isEmpty())return new o.P({vd:e.getDescription()});let l=e;if((0,i.l)(l)){const e=10*t.getTolerance(0);l=(new o.f).execute(l,0,e,0,u,12e3)}const _=new c(u);_.m_sr=t,_.m_gcs=t.getGCS(),_.m_transform=(0,o.N)(t,_.m_gcs,null);const f=(0,o.y)();_.m_gcs.querySpheroidData(f);const d=new r.Envelope2D;l.queryEnvelope(d),_.m_a=f.majorSemiAxis,_.m_eSquared=f.e2,_.m_rpu=_.m_gcs.getUnit().getUnitToBaseFactor(),_.m_gcs90=.5*Math.PI/_.m_rpu,_.m_gcs180=Math.PI/_.m_rpu,_.m_gcs360=2*Math.PI/_.m_rpu,_.m_gcs60=_.m_gcs360/6,_.m_q90=o.R.q90(_.m_a,_.m_eSquared),_.m_ellipticToGeodesicMaxRatio=.5*_.m_a*Math.PI/_.m_q90;const g=_.m_gcs.getTolerance(0);_.m_radTolerance=g*_.m_rpu,4===s?(_.m_curveType=2,_.m_bShapePreserving=!0):(_.m_curveType=s,_.m_bShapePreserving=!1),_.m_distance=n,_.m_absDistance=Math.abs(n),Number.isNaN(m)||m<=0?_.setConvergenceOffset():_.m_convergenceOffset=Math.max(m,.001),_.m_convergenceOffset/=h;let P,p=l.getGeometryType();if((0,i.o)(p)){const e=new o.b({vd:l.getDescription()});e.addSegment(l,!0),P=e,p=i.G.enumPolyline}else if(p===i.G.enumEnvelope){const e=l,t=new r.Envelope2D;e.queryEnvelope(t);const s=(0,a.e)((0,a.c)(_.m_sr,d,!0));if(t.minDimension()<=s)if(0===t.maxDimension()){const t=new a.P({vd:l.getDescription()});e.getCenter(t),P=t,p=i.G.enumPoint}else{const t=new o.b({vd:l.getDescription()});t.addEnvelope(e,!1),P=t,p=i.G.enumPolyline}else{const t=new o.P({vd:l.getDescription()});t.addEnvelope(e,!1),P=t,p=i.G.enumPolygon}}else P=l;if(_.setMinCornerStep(),(0,i.j)(p)||_.setMinSegmentStep(),_.m_absDistance<=.5*_.m_convergenceOffset)return p!==i.G.enumPolygon?new o.P({vd:P.getDescription()}):_.m_bShapePreserving?P:(0,o.U)(P,_.m_sr,_.m_curveType,_.m_segmentStep,-1,u);if(_.m_distance<0&&p!==i.G.enumPolygon)return new o.P({vd:P.getDescription()});if(_.m_bShapePreserving&&(0,i.u)(p)){const e=(0,o.U)(P,t,4,Number.NaN,_.m_convergenceOffset,u);P=(new o.G).execute(e,_.m_transform,u)}else P=(new o.G).execute(P,_.m_transform,u);if(P=(0,o.A)(P,_.m_gcs),P.isEmpty())return new o.P({vd:P.getDescription()});!_.m_bShapePreserving&&(0,i.u)(p)&&(P=(0,o.V)(_.m_rpu,P)),P=function(e,t){const s=e.getGeometryType();let n;if(n=(0,i.u)(s)?e.getPathCount():s===i.G.enumMultiPoint?e.getPointCount():1,1===n)return e;const o=[],m=[];for(let a=0;a<n;a++){o.push(a);const n=new i.P;if((0,i.u)(s)){const t=new r.Envelope2D;e.queryPathEnvelope(a,t),n.assign(t.getCenter())}else n.assign(e.getXY(a));const h=t.toGeohash(n);m.push(h)}o.sort((e,t)=>m[e]<m[t]?-1:m[e]>m[t]?1:0);const a=e.createInstance();for(let t=0;t<n;t++){const n=o[t];(0,i.u)(s)?a.addPath(e,n,!0):a.addPoints(e,n,n+1)}return a}(P,_.m_gcs);let x=new o.P;switch(p){case i.G.enumPolygon:x=_.bufferPolygon(P);break;case i.G.enumPolyline:x=_.bufferPolyline(P);break;case i.G.enumMultiPoint:x=_.bufferMultiPoint(P);break;case i.G.enumPoint:x=_.bufferPoint(P);break;default:(0,i.A)("")}const b=(new o.G).execute(x,_.m_transform.getInverse(),u);return b.mergeVertexDescription(P.getDescription()),b}function _(e,t,s,n,r,a,h,u,c,l,_){const f={stack:[],error:void 0,hasError:!1};try{const d=new i.P;d.setNAN(),c||_.getPointCount()>0&&(d.setCoordsPoint2D(_.getXY(_.getPointCount()-1)),d.scale(s));const P=(0,m.a)(f,new o.H,!1),p=(0,m.a)(f,new i.S(new o.H,new o.H),!1),x=new i.P,b=new i.P,y=a.at(-1),C=1/s;for(let s=0;s<a.length;s++){const i=a[s];let m;0===s?m=h:s===a.length-1?m=u:(o.I.geodeticDistance(e,t,y.x,y.y,i.x,i.y,null,null,P,r),m=P.val-.5*Math.PI),o.I.geodesicCoordinate(e,t,i.x,i.y,n,m,p.at(0),p.at(1)),c?b.setCoords(p.at(0).val,p.at(1).val):(x.setCoords(p.at(0).val,p.at(1).val),l=g(i.x,x.x,d.x,l),b.setCoords(l+x.x,x.y),d.setCoordsPoint2D(b)),b.scale(C),_.insertPoint2D(0,-1,b)}return l}catch(e){f.error=e,f.hasError=!0}finally{(0,m.b)(f)}}function f(e,t,s,n,r,a,h,u,c,l,_,f=Number.NaN,d=Number.NaN){const P={stack:[],error:void 0,hasError:!1};try{if(h-a<u)return l;const p=(0,m.a)(P,new i.S(new o.H,new o.H),!1),x=new i.P,b=new i.P,y=new i.P;b.setNAN(),c||_.getPointCount()>0&&(b.setCoordsPoint2D(_.getXY(_.getPointCount()-1)),b.scale(s));let C=Math.ceil(a/u),w=C++*u;w===a&&(w=C++*u);let S=a;const v=1/s;for(;w<h+u&&(S<f&&f<w?(w=f,C--):S<d&&d<w&&(w=d,C--),!(w>=h));)o.I.geodesicCoordinate(e,t,r.x,r.y,n,w,p.at(0),p.at(1)),c?y.setCoords(p.at(0).val,p.at(1).val):(x.setCoords(p.at(0).val,p.at(1).val),l=g(r.x,x.x,b.x,l),y.setCoords(l+x.x,x.y),b.setCoordsPoint2D(y)),y.scale(v),_.insertPoint2D(0,-1,y),S=w,w=C++*u;return l}catch(e){P.error=e,P.hasError=!0}finally{(0,m.b)(P)}}function d(e,t,s,n,r,a,h,u,c,l,_){const f={stack:[],error:void 0,hasError:!1};try{const s=new i.P,d=new i.P,g=(0,m.a)(f,new i.S(new o.H,new o.H),!1);o.I.geodesicCoordinate(e,t,r.x,r.y,n,a,g.at(0),g.at(1)),s.setCoords(g.at(0).val,g.at(1).val),o.I.geodesicCoordinate(e,t,r.x,r.y,n,h,g.at(0),g.at(1)),d.setCoords(g.at(0).val,g.at(1).val);const P=(0,m.a)(f,new o.H,!1);for(o.I.geodeticDistance(e,t,u.x,u.y,s.x,s.y,null,P,null,0),l[0]=P.val,o.I.geodeticDistance(e,t,u.x,u.y,d.x,d.y,null,P,null,0),_[0]=P.val;l[0]<=_[0];)l[0]+=i.C;for(;l[0]>_[0];)l[0]-=i.C;for(;l[0]>=c;)l[0]-=i.C,_[0]-=i.C;for(;l[0]<c;)l[0]+=i.C,_[0]+=i.C}catch(e){f.error=e,f.hasError=!0}finally{(0,m.b)(f)}}function g(e,t,s,n){if(Number.isNaN(s)){for(;n+t-e>Math.PI;)n-=i.C;for(;e-(n+t)>Math.PI;)n+=i.C;return n}return n+t-s>Math.PI?n-=i.C:s-(n+t)>Math.PI&&(n+=i.C),n}function P(e,t,s,n,i,r){const a={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const h=s[0],u=s.at(-1),c=(0,m.a)(a,new o.H,!1),l=(0,m.a)(a,new o.H,!1),_=(0,m.a)(a,new o.H,!1);o.I.greatEllipticDistance(e,t,i.x,i.y,h.x,h.y,c,null,null),o.I.greatEllipticDistance(e,t,i.x,i.y,u.x,u.y,l,null,null),o.I.greatEllipticDistance(e,t,h.x,h.y,u.x,u.y,_,null,null);let f=Math.min(c.val,l.val)+_.val,d=f+n;if(d<r)return!0;const g=(0,m.a)(a,new o.H,!1);f=Math.max(c.val,l.val);for(let n=1;n<s.length-1;n++){const r=s[n];o.I.greatEllipticDistance(e,t,i.x,i.y,r.x,r.y,g,null,null),g.val>f&&(f=g.val)}return d=f+n,d<r}catch(e){a.error=e,a.hasError=!0}finally{(0,m.b)(a)}}function p(e,t,s,n,r,m,a,h){let u;if(n.length%2==0){const e=n.length>>1,t=n[e],s=n[e-1];u=i.P.lerp(t,s,.5)}else u=n[n.length-1>>1].clone();const c=u.clone(),l=(0,o.a2)(e,t,c,75/180*Math.PI);return!!P(e,t,n,r,c,l)&&(null!==m&&(m.setCoordsPoint2D(u),m.scale(1/s)),null!==a&&a.setCoordsPoint2D(c),null!==h&&(h[0]=l),!0)}function x(e,t,s,n,i,r){const a={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const h=(0,m.a)(a,new o.H,!1);return o.I.greatEllipticDistance(e,t,i.x,i.y,s.x,s.y,h,null,null),h.val+n<r}catch(e){a.error=e,a.hasError=!0}finally{(0,m.b)(a)}}function b(e,t){return new o.a7(e,t)}function y(e){return(0,a.h)(e,0)||(0,a.s)(e,0),e}class C{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new i.P,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class w extends C{constructor(e,t,s){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new o.P,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=s,this.m_bNeedsSimplify=!0;const n=new r.Envelope2D;this.m_multiPath.queryEnvelope(n);const i=n.getCenter(),m=i.clone();m.scale(this.m_bufferer.m_rpu),this.m_gnomonic=b(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=m.clone(),this.m_minGnomonicRadius=(0,o.a2)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,m,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let s=0;const n=new i.P,r=new i.P;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){const e=this.m_segIter.nextSegment();if(n.setCoordsPoint2D(e.getStartXY()),r.setCoordsPoint2D(e.getEndXY()),n.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),(0,o.a3)(n,r))n.x=r.x;else if((0,o.a4)(n,r))r.x=n.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),i=this.m_multiPath.getPathStart(s),m=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<i&&(e=this.m_multiPath.isClosedPath(s)?m-1:-1),t>m-1&&(t=this.m_multiPath.isClosedPath(s)?i:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),(0,o.a4)(t,n)&&(n.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),(0,o.a3)(r,e)&&(r.x=e.x)}}this.m_densifiedPoints.length=0;const i=(0,o.a5)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,n,r,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===s)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(p(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(0===i||(0,o.a6)(n,r)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(n,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(i,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===t&&(t=new o.P,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),s++}if(this.m_currentDensifiedDelta=[0],s>0){const e=this.m_segIter.getStartPointIndex(),i=this.m_segIter.getPathIndex();for(;s>0;){if(this.m_segIter.previousSegment(),n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),n.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if((0,o.a3)(n,r))n.x=r.x;else if((0,o.a4)(n,r))r.x=n.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),i=this.m_multiPath.getPathStart(s),m=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<i&&(e=this.m_multiPath.isClosedPath(s)?m-1:-1),t>m-1&&(t=this.m_multiPath.isClosedPath(s)?i:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),(0,o.a4)(t,n)&&(n.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),(0,o.a3)(r,e)&&(r.x=e.x)}}this.m_densifiedPoints.length=0,(0,o.a5)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,n,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),s--}return n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),n.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=f(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,n,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,i),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&P(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new i.P,s=new i.P,n=[0];return p(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=b(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){const t=this.m_densifiedPoints[0];let s=Number.NaN,n=this.m_startAzimuth[0]-i.B;const r=this.m_endAzimuth[0]+i.B;let o=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(s=this.m_lastAzimuth+i.B,n=s+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(s=this.m_lastAzimuth+i.B,n=s+Math.PI-(i.C-(this.m_startAzimuth[0]-this.m_lastAzimuth))),o=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI||this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let r=!1;if(Math.abs(n-s)<=.5*this.m_bufferer.m_cornerStep&&(o||(r=!0)),r){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){const t=new i.P;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=i.C:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=i.C)}n=.5*(n+s)}else if(o){const s=new i.P;s.setCoordsPoint2D(t),s.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,s)}else f(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],s,n,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,_(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,n,r,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}}class S extends C{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;const s=new r.Envelope2D;this.m_multiPoint.queryEnvelope(s);const n=s.getCenter(),i=n.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=b(this.m_bufferer.m_gcs,n),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=(0,o.a2)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(e));const t=new o.P,s=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t);return this.m_bNeedsSimplify=s,t}isPointBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&x(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new i.P,s=new i.P,n=[0];return function(e,t,s,n,i,r,m,a){const h=(0,o.a2)(e,t,n,75/180*Math.PI);return!!x(e,t,n,i,n,h)&&(null!==r&&(r.setCoordsPoint2D(n),r.scale(1/s)),null!==m&&m.setCoordsPoint2D(n),null!==a&&(a[0]=h),!0)}(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=b(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}}class v{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n,i,r,m,a){if(m){const m=new I(e,t,s,n,i,!1,r,a);return(new o.O).executeMany(m,t,a)}return new I(e,t,s,n,i,!1,r,a)}execute(e,t,s,r,o,m,a){const h=new n.S([e]),u=[r],c=this.executeMany(h,t,s,u,o,!1,m,a).next();return c||(0,i.p)("geodesic buffer null output"),c}}class I extends n.G{constructor(e,t,s,n,o,m,a,h){super(),this.m_currentUnionEnvelope2D=new r.Envelope2D,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=h,m&&(0,i.t)(""),t||(0,i.a)(""),0===t.getCoordinateSystemType()&&(0,i.a)(""),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=s,this.m_distances=n,this.m_convergenceOffset=o,this.m_bOutlineOnly=m,this.m_bUnion=a}next(){let e;for(;e=this.m_inputGeoms.next();)return(0,i.v)(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return function(e,t,s,n,r,o){n<Number.MAX_VALUE&&n>-Number.MAX_VALUE||(0,i.a)("Geodesic_bufferer.buffer - bad distance"),(0,i.v)(e);const m=(0,u.c)(e),a=m.getGeometryType();if((0,i.z)(a)){const e=m.getPointCount(),h=8e6;if(Math.abs(n)>h&&(e>50||a!==i.G.enumMultiPoint&&4===s&&e>2)){let e=m;const i=n>0?1:-1,a=7e6;let u=n,c=1;do{c++,u=(Math.abs(u)-a)*i}while(Math.abs(u)>h);u=n;for(let n=0;n<c-1;n++)e=l(e,t,s,a*i,r,c,o),u=(Math.abs(u)-a)*i;return e=l(e,t,s,u,r,c,o),e}}return l(m,t,s,n,r,1,o)}(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}}},63227:(e,t,s)=>{s.d(t,{c:()=>i});var n=s(23160);function i(e,t){const s=e.getGeometryType();return s===n.G.enumPoint?e:(0,n.u)(s)?function(e){if(function(e){for(let t=0,s=e.getPathCount();t<s;t++){const s=e.getPathSize(t);if(0===s)return!1;if(1===s){if(0===e.getSegmentCountPath(t))return!1;if(e.getSegmentType(e.getPathStart(t))===n.G.enumLine)return!1;if(!e.isClosedPath(t))return!1}}return!0}(e))return e;const t=e.createInstance();for(let s=0,i=e.getPathCount();s<i;s++){const i=e.getPathSize(s);if(0!==i){if(1===i){if(0===e.getSegmentCountPath(s))continue;if(e.getSegmentType(e.getPathStart(s))===n.G.enumLine)continue;if(!e.isClosedPath(s))continue}t.addPath(e,s,!0)}}return t}(e):s===n.G.enumMultiPoint||s===n.G.enumEnvelope?e:s===n.G.enumMultipatch?((0,n.t)("not implemented for multipatch"),e):e}}}]);