/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../Color.js";import{EventedAccessor as s}from"../../core/Evented.js";import{h as n}from"../../chunks/handleUtils.js";import{m as o}from"../../chunks/memoize.js";import{watch as i,syncAndInitial as r,sync as l}from"../../core/reactiveUtils.js";import{g as a}from"../../chunks/uuid.js";import{property as u}from"../../core/accessorSupport/decorators/property.js";import{i as c,J as p}from"../../core/lang.js";import"../../chunks/Logger.js";import{subclass as m}from"../../core/accessorSupport/decorators/subclass.js";import h from"../../geometry/Point.js";import{c as f,m as d,E as v,h as g}from"../../chunks/unitUtils.js";import{f as y}from"../../chunks/vec4f64.js";import{k as j,l as k}from"../../chunks/mathUtils.js";import{throwIfAborted as S,after as w,isAbortError as x,throwIfNotAbortError as E}from"../../core/promiseUtils.js";import P from"../../geometry/Multipoint.js";import{k as b}from"../../chunks/coordsUtils.js";import{S as R}from"../../chunks/ScheduledQueueProcessor.js";import{T as _}from"../../chunks/Scheduler.js";import{u as Z,l as M}from"../../chunks/vec2.js";import{m as U}from"../../chunks/vec3.js";import D from"../../geometry/Polyline.js";import{initializeProjection as O,project as C}from"../../chunks/projectionUtils.js";import z from"../../geometry/SpatialReference.js";import{geodesicLengths as A,isSupported as N,inverseGeodeticSolver as T,directGeodeticSolver as L}from"../../geometry/support/geodesicUtils.js";import{u as G}from"../../chunks/elevationInfoUtils.js";import{b as q}from"../../chunks/traversalUtils.js";import"../../chunks/colorUtils.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/Lifecycle.js";import"../../chunks/metadata.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/Error.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/Warning.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/reader.js";import"../../chunks/writer.js";import"../../geometry/Geometry.js";import"../../core/JSONSupport.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../geometry/Extent.js";import"../../chunks/zmUtils.js";import"../../chunks/Queue.js";import"../../chunks/SimpleObservable.js";import"../../chunks/ReactiveMap.js";import"../../chunks/signal.js";import"../../chunks/debugFlags.js";import"../../chunks/common.js";import"../../chunks/vec3f64.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../geometry/Polygon.js";import"../../chunks/projectBuffer.js";import"../../chunks/geodesicConstants.js";import"../../chunks/projectXYZToVector.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../../chunks/unitConversionUtils.js";import"../../chunks/lengthUtils.js";let H={noDataValue:-5e5,defaultQueryOptions:()=>({noDataValue:H.noDataValue,demResolution:"auto",maximumAutoTileRequests:150,ignoreInvisibleLayers:!0}),updateThrottleMillis:100,delayAfterPreviewMillis:500,defaultDemResolution:f(10,"centimeters","meters"),densificationMaxSamples:3e3,largeChartSamples:1e4,maxTotalSamples:1e5,maxChartRatio:300,minSlopeSampleDistance:10,formatPrecision:1,profileLinesStyle3D:{width:3,falloff:0,innerWidth:0,innerColor:y(0,0,0,0),renderOccluded:16},profileLinesUpdateThrottleMillis:100,hoveredPointsStyle:{size:14,borderStyle:"solid",borderWidth:3,borderColor:"#ffffff",boxShadow:"0px 0px 0px 5px rgba(255,255,255,0.2)"}};function V(){return H}const F=" â€• ",W={progress:1,hasZ:!1,samples:[],statistics:null,spatialReference:null},I="ProfileGenerationError";class Q extends Error{constructor(e){super("profile could not be generated",{cause:e}),this.type=I}}function B(e){return e.type===I}function Y(e,t){const s=e/t.densificationMaxSamples;return Math.max(t.samplingDistance,s)}function J(e,t,s){if(null==t)return X(e);const n=e.spatialReference,o=t.mode,i=G(t,n);let r=null;switch(s.type){case"2d":r=function({hasZ:e},t,s){return"absolute-height"===t?e?([e,t,n])=>[e,t,n+s]:([e,t])=>[e,t,s]:null}(e,o,i);break;case"3d":r=function({spatialReference:e,hasZ:t},s,n,{elevationProvider:o}){const i=(t,s,n,i)=>o?.getElevation(t,s,n,e,i)??0;switch(s){case"on-the-ground":return([e,t])=>[e,t,i(e,t,0,"ground")];case"absolute-height":return t?([e,t,s])=>[e,t,s+n]:([e,t])=>[e,t,n];case"relative-to-ground":return t?([e,t,s])=>[e,t,s+i(e,t,s,"ground")+n]:([e,t])=>[e,t,i(e,t,0,"ground")+n];case"relative-to-scene":return t?([e,t,s])=>[e,t,s+i(e,t,s,"scene")+n]:([e,t])=>[e,t,i(e,t,0,"scene")+n];default:return null}}(e,o,i,s)}return null==r?X(e):new D({hasZ:!0,hasM:!1,spatialReference:n,paths:K(e.paths,r)})}function X(e){return e.hasZ?new D({hasZ:!1,hasM:!1,spatialReference:e.spatialReference,paths:K(e.paths,([e,t])=>[e,t])}):e}function K(e,t){const s=e.length,n=new Array(s);for(let o=0;o<s;++o){const s=e[o],i=s.length,r=new Array(s.length);n[o]=r;for(let e=0;e<i;++e)r[e]=t(s[e])}return n}function $(e){return ee(e)&&e.paths.length>0&&e.paths.every(e=>e.length>=2)}function ee(e){return null!=e&&"polyline"===e.type}function te(e,t,s,n,o){const{spatialReference:i,hasZ:r}=e,l={from:null,to:null,distance:0,azimuth:0,reverseAzimuth:0,spatialReference:i,metersPerSR:d(i)},a=[],u=[];let c=0;for(let i=0;i<e.paths.length;++i){const r=e.paths[i],p=new Array,m=new Array;let h=0;for(let e=1;e<r.length;++e){const i=r[e-1],a=r[e],u=n(l,i,a);let f;for(f=h;f<u.distance&&!j(f,u.distance);f+=t)p.push(o(u,f)),m.push((c+f)*s);h=f-u.distance,c+=u.distance,p.push(a),m.push(c*s)}a[i]=p,u[i]=m}return{densifiedPath:new D({spatialReference:i,hasZ:r,paths:a}),distances:u}}function se(e,t,s){return e.distance=0,T(e,t,s,e.spatialReference),e.from=t,e.to=s,e}function ne(e,t,s){return e.from=t,e.to=s,e.distance=Z(s,t)*e.metersPerSR,e}function oe({from:e,azimuth:t,spatialReference:s},n){return L([0,0],e,t,n,s)}function ie({from:e,to:t,azimuth:s,distance:n,spatialReference:o},i){const r=i/n,l=[0,0,k(e[2],t[2],r)];return L(l,e,s,i,o),l}function re({from:e,to:t,distance:s},n){return M([0,0],e,t,n/s)}function le({from:e,to:t,distance:s},n){return U([0,0,0],e,t,n/s)}function ae(e){return e.paths.reduce((e,t)=>e+t.length,0)}function ue(e,t,s){return ae(e)+Math.floor(t/s)+Math.max(0,e.paths.reduce(e=>1+e,0)-1)}function ce(e){const t=e.filter(c),s=t.length;if(0===s)return null;const n=t[0];if(1===s)return n;let o=n.maxDistance,i=n.minElevation,r=n.maxElevation,l=n.maxPositiveSlope,a=n.maxNegativeSlope;for(let e=1;e<t.length;++e){const s=t[e];o=he(o,s.maxDistance),i=me(i,s.minElevation),r=he(r,s.maxElevation),l=he(l,s.maxPositiveSlope),a=he(a,s.maxNegativeSlope)}return{maxDistance:o,minElevation:i,maxElevation:r,avgElevation:null,elevationGain:null,elevationLoss:null,maxPositiveSlope:l,maxNegativeSlope:a,avgPositiveSlope:null,avgNegativeSlope:null}}function pe(e){let t=null,s=null,n=null;for(const o of e){if(null==o)continue;const{statistics:e,spatialReference:i}=o;if(null==e)continue;const r=d(i);t=he(t,fe(e.maxDistance,r));const l=v(i);n=me(n,fe(e.minElevation,l)),s=he(s,fe(e.maxElevation,l))}return{minDistance:0,maxDistance:t??0,minElevation:n??0,maxElevation:s??0}}function me(e,t){return null==t?e:null!=e?Math.min(e,t):t}function he(e,t){return null==t?e:null!=e?Math.max(e,t):t}function fe(e,t){return null!=e&&null!=t?e*t:null}class de{constructor(){this._start=0,this._totalElevation=0,this._sampleCount=0}get avgElevation(){return this._totalElevation/this._sampleCount}get isHole(){return 0===this._sampleCount}get start(){return this._start}copy(e){this._start=e._start,this._sampleCount=e._sampleCount,this._totalElevation=e._totalElevation}reset(){this._start=0,this._sampleCount=0,this._totalElevation=0}restart(e,t){this._start=e,this._sampleCount=1,this._totalElevation=t}insert(e){++this._sampleCount,this._totalElevation+=e}}async function*ve(e,t){const{view:s,geometry:n,elevationInfo:o,providers:i,options:r}=e,l=s.spatialReference;if(!l||null==n||!$(n))throw new Q("invalid-geometry");const a=i.length;if(0===a)return null;const u=Math.round(r.maxTotalSamples/a);if(ae(n)>u)throw new Q("too-complex");const c=await async function(e,t,s,n,o,i,r){let l,a,u;const c=e.spatialReference,p=c.isGeographic||c.isWebMercator;let m=0;if(!p){const{execute:t}=await import("../../geometry/operators/lengthOperator.js").then(e=>e.l);S(r),m=t(e,{unit:"meters"}),S(r)}const h=1/d(n);if(p){await O([{source:c,dest:n},{source:c,dest:z.WGS84}],r);const p=N((f=e).spatialReference)?f:C(f,z.WGS84);l=A([p],"meters")[0];const m=Y(l,o);if(ue(e,l,m)>i)throw new Q("too-complex");const d=J(p,t,s);({densifiedPath:a,distances:u}=function(e,t,s){const{hasZ:n}=e;return te(e,t,s,se,n?ie:oe)}(d,m,h)),a=C(a,n)}else{await O([{source:c,dest:n}],r),l=m;const p=Y(l,o);if(ue(e,l,p)>i)throw new Q("too-complex");const f=J(e,t,s);({densifiedPath:a,distances:u}=function(e,t,s){const{hasZ:n}=e;return te(e,t,s,ne,n?le:re)}(f,p,h)),S(r),a=C(a,n)}var f;return{densifiedPath:a,pathLength:l*h,distances:u}}(n,o,s,l,r,u,t);let p=0;const m=new Array(a),h=new Array(a);for(let s=0;s<a;s++){const n=Se(c);m[s]=n,p+=n.samples.length;const o={...e,provider:i[s],result:n,densificationResult:c};h[s]=ge(o,t)[Symbol.iterator]()}if(p>r.maxTotalSamples)throw new Q("too-complex");const f=await Promise.all(h.map(e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value}));S(t);for(let e=0;e<a;e++)m[e]=f[e];yield m,await w(e.delayAfterPreview??V().delayAfterPreviewMillis,null,t.signal);const v=[];try{let e;do{e=!1;for(let t=0;t<a;t++){const s=h[t].next();!1===s.done&&(v.push({resultPromise:s.value,index:t}),e=!0)}}while(e)}finally{h.forEach(e=>e.return?.())}for(const{resultPromise:e,index:s}of v)m[s]=await e,S(t),yield m;for(const e of m)null!=e&&(e.progress=1);yield m}function*ge(e,t){const{densificationResult:s}=e,n={...e,abortOptions:t,densificationResult:s},o=q(0,n.result.samples.length),i=o.slice(0,n.provider.numSamplesForPreview);yield ye(n,i,!0);const r=p(o,n.provider.numSamplesPerChunk);for(const e of r)yield ye(n,e,!1)}async function ye({densificationResult:e,result:t,provider:s,queue:n,abortOptions:o,cache:i},r,l){const{densifiedPath:a,pathLength:u}=e,c=t.spatialReference,{samples:p}=t,m=[];for(let e=0;e<r.length;e++){const t=p[r[e]];m[e]=t.coordinate}try{return await n.push({geometry:new P({spatialReference:c,points:m,hasZ:a.hasZ}),provider:s,indices:r,preview:l,result:t,queryOptions:{...V().defaultQueryOptions(),minDemResolution:l?Math.round(u/s.numSamplesForPreview):Math.round(u/p.length),cache:i}},o),{...t}}catch(e){return x(e)?null:W}}function je(e){return new R({priority:_.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{S(e.queryOptions);try{await async function({geometry:e,provider:t,indices:s,preview:n,result:o,queryOptions:i}){if(0===s.length)return;const r=(await async function(e,t,s){try{return await e.queryElevation(t,s)}catch(e){throw new Q("elevation-query-error")}}(t,e,i)).geometry,{hasZ:l,points:a}=r,u=i.noDataValue,{samples:c}=o;for(let e=0;e<s.length;e++){const t=c[s[e]];if(t.isHole)continue;const n=l?a[e][2]:null;null===n||n===u?t.sampledZ=null:(o.hasZ=!0,t.sampledZ=n),t.sampled=!0}(function(e){const t=e.length-1;let s=0;for(let n=1;n<=t;n++)(e[n].sampled||n===t)&&(ke(e,s,n),s=n)})(c),o.progress=n?0:o.progress+s.length/c.length,o.statistics=function(e,t){const s=e.length;if(0===s)return null;const n=e[0],o=n.sampledZ;let i=o,r=o,l=0,a=0,u=null,c=null,p=null!=o?o:0,m=0,h=0,g=null!=o?1:0,y=0,j=0;const k=d(t),S=v(t),w=V().minSlopeSampleDistance/k,x=2*w,E=new de,P=new de,b=()=>{_(),E.copy(P),P.reset()},R=(e,t)=>{b(),e>0&&e-E.start<=x&&(e=E.start+w),P.restart(e,t)},_=()=>{if(E.isHole||P.isHole)return;const e=P.avgElevation-E.avgElevation,t=P.start-E.start,s=e*S,n=t*k,o=f(Math.atan2(s,n),"radians","degrees");o>0?(m+=o,u=he(u,o),y++):o<0&&(h-=o,c=he(c,-o),j++)};null!=n.sampledZ&&R(n.distance,n.sampledZ);for(let t=1;t<s;++t){const s=e[t-1],n=e[t],o=n.sampledZ;if(null==o){P.isHole||b();continue}g++,p+=o,i=me(i,o),r=he(r,o),P.isHole||n.distance-P.start>=w?R(n.distance,o):P.insert(o);const u=s.sampledZ;if(null!=u){const e=o-u;e>0?l+=e:e<0&&(a-=e)}}return b(),0===g?null:{maxDistance:e[s-1].distance,minElevation:i,maxElevation:r,avgElevation:0===g?null:p/g,elevationGain:l,elevationLoss:a,maxPositiveSlope:u,maxNegativeSlope:c,avgPositiveSlope:0===y?null:m/y,avgNegativeSlope:0===j?null:h/j}}(o.samples,o.spatialReference)}(e)}catch(e){E(e)}}})}function ke(e,t,s){if(s-t===1)return;const n=e[t],o=n.sampledZ,i=e[s],r=i.sampledZ;if(null==o||null==r){for(let n=t+1;n<s;n++)e[n].sampledZ=null;return}const l=n.distance,a=i.distance-l;for(let n=t+1;n<s;n++){const t=e[n],s=(t.distance-l)/a;t.sampledZ=k(o,r,s)}}function Se({densifiedPath:e,distances:t}){const s=e.spatialReference,n=g(s),o=e.paths,i=o.length,r=[];let l=null,a=0;for(let e=0;e<i;e++){const s=o[e],i=s.length,u=t[e];for(let e=0;e<i;e++){const t=s[e],o=u[e];n&&(t[0]=b(t[0],n.valid[0],n.valid[1])),l&&0===e&&we(r,l,t,a,o),r.push(xe(t,o)),l=t,a=o}}return{progress:0,samples:r,hasZ:!1,statistics:null,spatialReference:s}}function we(e,t,s,n,o){e.push(Ee(t,n)),e.push(Ee(s,o))}function xe(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function Ee(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}function Pe(e,t,s){if(!e||0===e.length)return;const n=e.length-1,o=e[0];if(t<=s(o))return o;const i=e[n];if(t>=s(i))return i;let r=0,l=0,a=n;for(;r<a;){l=r+Math.floor((a-r)/2);const o=e[l],i=s(o);if(i===t)return o;if(t<i){if(l>0){const n=e[l-1],r=s(n);if(t>r)return t-r>=i-t?o:n}a=l}else{if(l<n){const n=e[l+1],r=s(n);if(t<r)return t-i>=r-t?n:o}r=l+1}}return e[l]}function be(e,t,s){return null==e?null:f(e*t,"meters",s)}function Re(e,t,s){return null==e?null:f(e*t,"meters",s)}let _e=class extends s{constructor(e){super(e),this.type=null,this.id=a(),this.title=null,this.color=new t("#000000"),this.visible=!0,this._getSamplesMemoized=o((e,t)=>function(e,t){if(null==e||null==t)return null;const{samples:s,spatialReference:n}=e,{distance:o,elevation:i}=t,r=d(n),l=v(n),a=s.length,u=new Array(a);for(let e=0;e<a;++e){const t=s[e],n=t.sampledZ,a=t.coordinate;u[e]={x:a[0],y:a[1],z:n,distance:be(t.distance,r,o),elevation:Re(n,l,i)}}return u}(e,t)),this._getStatisticsMemoized=o((e,t)=>function(e,t){if(null==e||null==t||null==e.statistics||null==e.spatialReference)return null;const{distance:s,elevation:n}=t,{statistics:o,spatialReference:i}=e,r=d(i),l=v(i);return{maxDistance:be(o.maxDistance,r,s),minElevation:Re(o.minElevation,l,n),maxElevation:Re(o.maxElevation,l,n),avgElevation:Re(o.avgElevation,l,n),elevationGain:Re(o.elevationGain,l,n),elevationLoss:Re(o.elevationLoss,l,n),maxPositiveSlope:o.maxPositiveSlope,maxNegativeSlope:o.maxNegativeSlope,avgPositiveSlope:o.avgPositiveSlope,avgNegativeSlope:o.avgNegativeSlope}}(e,t)),this.viewVisualizationEnabled=!0,this.result=null,this.effectiveUnits=null,this.numSamplesForPreview=30,this.numSamplesPerChunk=200,this.chartFillEnabled=!0,this.chartStrokeWidth=1.5,this.chartStrokeOffsetY=0,this._viewModel=null}get progress(){return null!=this.result&&this.visible?this.result.progress:0}get samples(){return this._getSamplesMemoized(this.result,this.effectiveUnits)}get statistics(){return this._getStatisticsMemoized(this.result,this.effectiveUnits)}get hoveredPoint(){const e=this._viewModel?.hoveredChartPosition;return null!=e?this._getPoint(e):null}get available(){return!0}get hasZ(){const e=this.result;return null!=e&&e.hasZ}get minDemResolution(){return V().defaultDemResolution}queryElevation(){throw new Error("not implemented")}attach(e){return this._viewModel=e,n([i(()=>e.effectiveUnits,e=>{this.effectiveUnits=e},r),i(()=>[e.input],()=>this._onChange(),l)])}toggleVisibility(e){this.visible=void 0===e?!this.visible:e}_onChange(){this.emit("change")}_getPoint(e){const{samples:t,result:s}=this;if(null==t||null==s)return null;const n=t.length;if(0===n)return null;const o=Pe(t,e*t[n-1].distance,e=>e.distance);if(null==o)return null;const{x:i,y:r,z:l}=o;return null==l?null:new h({x:i,y:r,z:l,spatialReference:s.spatialReference})}};e([u({nonNullable:!0})],_e.prototype,"id",void 0),e([u()],_e.prototype,"title",void 0),e([u({type:t,nonNullable:!0})],_e.prototype,"color",void 0),e([u({nonNullable:!0})],_e.prototype,"visible",void 0),e([u({readOnly:!0})],_e.prototype,"progress",null),e([u({readOnly:!0})],_e.prototype,"samples",null),e([u({readOnly:!0})],_e.prototype,"statistics",null),e([u()],_e.prototype,"hoveredPoint",null),e([u()],_e.prototype,"viewVisualizationEnabled",void 0),e([u()],_e.prototype,"available",null),e([u()],_e.prototype,"result",void 0),e([u()],_e.prototype,"effectiveUnits",void 0),e([u()],_e.prototype,"numSamplesForPreview",void 0),e([u()],_e.prototype,"numSamplesPerChunk",void 0),e([u()],_e.prototype,"chartFillEnabled",void 0),e([u()],_e.prototype,"chartStrokeWidth",void 0),e([u()],_e.prototype,"chartStrokeOffsetY",void 0),e([u({readOnly:!0})],_e.prototype,"hasZ",null),e([u({readOnly:!0})],_e.prototype,"minDemResolution",null),e([u()],_e.prototype,"_viewModel",void 0),_e=e([m("esri.widgets.ElevationProfile.ElevationProfileLine")],_e);const Ze=_e;export{$ as a,Pe as b,ve as c,je as d,Ze as default,pe as e,B as f,V as g,ee as i,ce as m,F as n};
