/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../core/Error.js";import{k as e,c as s,j as n,p as r}from"../../chunks/unitUtils.js";import{b as i}from"../../chunks/ensureType.js";import o from"../Point.js";import a from"../Polygon.js";import c from"../Polyline.js";import p from"../SpatialReference.js";import{t as h,s as u,w as l}from"../../chunks/geodesicConstants.js";import"../../core/lang.js";import"../../chunks/Logger.js";import"../../config.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/MapUtils.js";import"../../core/promiseUtils.js";import"../../chunks/handleUtils.js";import"../../chunks/events.js";import"../../chunks/maybe.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/tslib.es6.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../../chunks/get.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/reader.js";import"../../chunks/writer.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"./webMercatorUtils.js";import"../Extent.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/zmUtils.js";function m(t){if(!t)return null;const e=t.wkid;if(e)return u[e];const s=t.wkt2??t.wkt;return s?function(t){const e=l.exec(t);if(!e||2!==e.length)return null;const s=e[1].split(",");if(!s||s.length<3)return null;const n=parseFloat(s[1]),r=parseFloat(s[2]);return isNaN(n)||isNaN(r)?null:{a:n,f:0===r?0:1/r}}(s):null}function f(t){const e=m(t);if(function(t){return null!=t&&"b"in t&&"eSq"in t&&"radius"in t}(e))return e;const s=e.a*(1-e.f);return Object.assign(e,{b:s,eSq:1-(s/e.a)**2,radius:(2*e.a+s)/3,densificationRatio:1e4/((2*e.a+s)/3)})}function d(t){return null!=t&&t<0?t+360:t}function j(t,e,s){const{a:n,eSq:r}=f(s),i=Math.sqrt(r),o=Math.sin(e[1]*h),a=n*e[0]*h;let c;return c=r>0?n*((1-r)*(o/(1-r*(o*o))-1/(2*i)*Math.log((1-i*o)/(1+i*o))))*.5:n*o,t[0]=a,t[1]=c,t}function g(t){return e(t)&&!!m(t)}function M(e,n="square-meters"){if(e.some(t=>!g(t.spatialReference)))throw new t("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const r=[];for(let t=0;t<e.length;t++){const s=e[t],n=s.spatialReference,{radius:i,densificationRatio:o}=f(n),a=i*o;r.push(w(s,a))}const i=[],o=[0,0],a=[0,0];for(let t=0;t<r.length;t++){const{rings:e,spatialReference:c}=r[t];let p=0;for(let t=0;t<e.length;t++){const s=e[t];j(o,s[0],c),j(a,s[s.length-1],c);let n=a[0]*o[1]-o[0]*a[1];for(let t=0;t<s.length-1;t++)j(o,s[t+1],c),j(a,s[t],c),n+=a[0]*o[1]-o[0]*a[1];p+=n}p=s(p,"square-meters",n),i.push(p/-2)}return i}function k(e,n="meters"){if(!e)throw new t("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some(t=>!g(t.spatialReference)))throw new t("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const r=[];for(let t=0;t<e.length;t++){const i=e[t],{spatialReference:o}=i,a="polyline"===i.type?i.paths:i.rings;let c=0;for(let t=0;t<a.length;t++){const e=a[t];let s=0;for(let t=1;t<e.length;t++){const n=e[t-1][0],r=e[t][0],i=e[t-1][1],a=e[t][1];if(i!==a||n!==r){const t=new y;v(t,[n,i],[r,a],o),s+=t.distance}}c+=s}c=s(c,"meters",n),r.push(c)}return r}function w(e,s){if("polyline"!==e.type&&"polygon"!==e.type)throw new t("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!g(n))throw new t("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const r="polyline"===e.type?e.paths:e.rings,o=[],h=[0,0],u=new y;for(const t of r){const e=[];o.push(e),e.push([t[0][0],t[0][1]]);let r,i,a=t[0][0],c=t[0][1];for(let o=0;o<t.length-1;o++){if(r=t[o+1][0],i=t[o+1][1],a===r&&c===i)continue;const p=[a,c];v(u,[a,c],[r,i],n);const{azimuth:l,distance:m}=u,f=m/s;if(f>1){for(let t=1;t<=f-1;t++)b(h,p,l,t*s,n),e.push(h.slice());b(h,p,l,(m+Math.floor(f-1)*s)/2,n),e.push(h.slice())}b(h,p,l,m,n),e.push(h.slice()),a=h[0],c=h[1]}}const l=i(p,n);return"polyline"===e.type?new c({paths:o,spatialReference:l}):new a({rings:o,spatialReference:l})}class y{constructor(t=0,e=void 0,s=void 0){this.distance=t,this.azimuth=e,this.reverseAzimuth=s}}function b(t,e,s,n,r){const i=e[0],o=e[1],a=i*h,c=o*h,p=(s??0)*h,{a:u,b:l,f:m}=f(r),d=Math.sin(p),j=Math.cos(p),g=(1-m)*Math.tan(c),M=1/Math.sqrt(1+g*g),k=g*M,w=Math.atan2(g,j),y=M*d,b=y*y,v=1-b,R=v*(u*u-l*l)/(l*l),z=1+R/16384*(4096+R*(R*(320-175*R)-768)),U=R/1024*(256+R*(R*(74-47*R)-128));let S,x,q,A=n/(l*z),N=2*Math.PI;for(;Math.abs(A-N)>1e-12;)q=Math.cos(2*w+A),S=Math.sin(A),x=Math.cos(A),N=A,A=n/(l*z)+U*S*(q+U/4*(x*(2*q*q-1)-U/6*q*(4*S*S-3)*(4*q*q-3)));const P=k*S-M*x*j,O=Math.atan2(k*x+M*S*j,(1-m)*Math.sqrt(b+P*P)),T=m/16*v*(4+m*(4-3*v)),B=Math.atan2(S*d,M*x-k*S*j)-(1-T)*m*y*(A+T*S*(q+T*x*(2*q*q-1)));return t[0]=(a+B)/h,t[1]=O/h,t}function v(t,e,s,n){const r=e[0]*h,i=e[1]*h,o=s[0]*h,a=s[1]*h,{a:c,b:p,f:u,radius:l}=f(n),m=o-r,d=Math.atan((1-u)*Math.tan(i)),j=Math.atan((1-u)*Math.tan(a)),g=Math.sin(d),M=Math.cos(d),k=Math.sin(j),w=Math.cos(j);let y,b,v,R,z,U,S,x,q,A,N=1e3,P=m;do{if(S=Math.sin(P),x=Math.cos(P),v=Math.sqrt(w*S*(w*S)+(M*k-g*w*x)*(M*k-g*w*x)),0===v)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;z=g*k+M*w*x,U=Math.atan2(v,z),q=M*w*S/v,b=1-q*q,R=z-2*g*k/b,isNaN(R)&&(R=0),A=u/16*b*(4+u*(4-3*b)),y=P,P=m+(1-A)*u*q*(U+A*v*(R+A*z*(2*R*R-1)))}while(Math.abs(P-y)>1e-12&&--N>0);if(0===N){const e=l,s=Math.acos(Math.sin(i)*Math.sin(a)+Math.cos(i)*Math.cos(a)*Math.cos(o-r))*e,n=o-r,c=Math.sin(n)*Math.cos(a),p=Math.cos(i)*Math.sin(a)-Math.sin(i)*Math.cos(a)*Math.cos(n),u=Math.atan2(c,p);return t.azimuth=u/h,t.distance=s,t.reverseAzimuth=void 0,t}const O=b*(c*c-p*p)/(p*p),T=O/1024*(256+O*(O*(74-47*O)-128)),B=p*(1+O/16384*(4096+O*(O*(320-175*O)-768)))*(U-T*v*(R+T/4*(z*(2*R*R-1)-T/6*R*(4*v*v-3)*(4*R*R-3)))),E=Math.atan2(w*Math.sin(P),M*k-g*w*Math.cos(P)),F=Math.atan2(M*Math.sin(P),M*k*Math.cos(P)-g*w);return t.azimuth=E/h,t.distance=B,t.reverseAzimuth=F/h,t}function R(e,n,i="meters"){if(!e||!n)throw new t("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!n.spatialReference)throw new t("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!r(e.spatialReference,n.spatialReference))throw new t("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:o}=e;if(!g(o))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===n.x&&e.y===n.y)return new y(0,0,0);const a=new y;return v(a,[e.x,e.y],[n.x,n.y],o),a.distance=s(a.distance,"meters",i),a.azimuth=d(a.azimuth),a.reverseAzimuth=d(a.reverseAzimuth),a}function z(e,s,n){if(!e||null==s||null==n)throw new t("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new t("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new t("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:r}=e;if(!g(r))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");const i=[0,0];return b(i,[e.x,e.y],n,s,r),new o({x:i[0],y:i[1],spatialReference:r})}function U(t){return g(t)?t:n(t)?p.WGS84:null}export{y as InverseGeodeticSolverResult,b as directGeodeticSolver,M as geodesicAreas,U as geodesicCompatibleSpatialReference,w as geodesicDensify,R as geodesicDistance,k as geodesicLengths,v as inverseGeodeticSolver,g as isSupported,z as pointFromDistance};
