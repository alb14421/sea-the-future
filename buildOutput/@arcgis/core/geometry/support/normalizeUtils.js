/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../../config.js";import s from"../../core/Error.js";import{L as e}from"../../chunks/Logger.js";import n from"../Polygon.js";import o from"../Polyline.js";import{c as r,o as i,u as c,g as l}from"../../chunks/normalizeUtilsCommon.js";import{h as p}from"../../chunks/unitUtils.js";import{geographicToWebMercator as u,webMercatorToGeographic as h}from"./webMercatorUtils.js";import{c as a,s as m}from"../../chunks/simplify.js";import"../../core/lang.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/tslib.es6.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/metadata.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/tracking.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../chunks/Warning.js";import"../../chunks/get.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/writer.js";import"../Extent.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/zmUtils.js";import"./jsonUtils.js";import"../Multipoint.js";import"../../chunks/utils9.js";import"../../chunks/utils10.js";const f=()=>e.getLogger("esri.geometry.support.normalizeUtils");function j(t){return"polygon"===t[0].type}function g(t){return"polyline"===t[0].type}function k(t){const s=[];let e=0,n=0;for(let o=0;o<t.length;o++){const r=t[o];let i=null;for(let t=0;t<r.length;t++)i=r[t],s.push(i),0===t?(e=i[0],n=e):(e=Math.min(e,i[0]),n=Math.max(n,i[0]));i&&s.push([(e+n)/2,0])}return s}function y(t,e){if(!(t instanceof o||t instanceof n)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw f().error(t),new s("internal:geometry",t)}const r=l(t),i=[];for(const t of r){const s=[];i.push(s),s.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const o=t[n][0],r=t[n][1],i=t[n+1][0],c=t[n+1][1],l=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),p=(c-r)/l,u=(i-o)/l,h=l/e;if(h>1){for(let t=1;t<=h-1;t++){const n=t*e,i=u*n+o,c=p*n+r;s.push([i,c])}const t=(l+Math.floor(h-1)*e)/2,n=u*t+o,i=p*t+r;s.push([n,i])}s.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new n({rings:i,spatialReference:t.spatialReference}):new o({paths:i,spatialReference:t.spatialReference})}function d(t,s,e){if(s){const s=y(t,1e6);t=h(s,!0)}return e&&(t=c(t,e)),t}function x(t,s,e){if(Array.isArray(t)){const n=t[0];if(n>s){const e=i(n,s);t[0]=n+e*(-2*s)}else if(n<e){const s=i(n,e);t[0]=n+s*(-2*e)}}else{const n=t.x;if(n>s){const e=i(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<e){const s=i(n,e);t=t.clone().offset(s*(-2*e),0)}}return t}async function b(s,e,h){if(!Array.isArray(s))return b([s],e);e&&"string"!=typeof e&&f().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const k="string"==typeof e?e:e?.url??t.geometryServiceUrl;let y,M,U,w,R,P,S,L,v=0;const A=[],z=[];for(const t of s)if(null!=t)if(y||(y=t.spatialReference,M=p(y),U=y.isWebMercator,P=U?102100:4326,w=r[P].maxX,R=r[P].minX,S=r[P].plus180Line,L=r[P].minus180Line),M)if("mesh"===t.type)z.push(t);else if("point"===t.type)z.push(x(t.clone(),w,R));else if("multipoint"===t.type){const s=t.clone();s.points=s.points.map(t=>x(t,w,R)),z.push(s)}else if("extent"===t.type){const s=t.clone()._normalize(!1,!1,M);z.push(s.rings?new n(s):s)}else if(t.extent){const s=t.extent,e=i(s.xmin,R)*(2*w);let n=0===e?t.clone():c(t.clone(),e);s.offset(e,0);let{xmin:o,xmax:r}=s;o=Number(o.toFixed(9)),r=Number(r.toFixed(9)),s.intersects(S)&&r!==w?(v=r>v?r:v,n=d(n,U),A.push(n),z.push("cut")):s.intersects(L)&&o!==R?(v=r*(2*w)>v?r*(2*w):v,n=d(n,U,360),A.push(n),z.push("cut")):z.push(n)}else z.push(t.clone());else z.push(t);else z.push(t);let T=i(v,w),N=-90;const F=T,O=new o;for(;T>0;){const t=360*T-180;O.addPath([[t,N],[t,-1*N]]),N*=-1,T--}if(A.length>0&&F>0){const t=function(t,s){let e=-1;for(let n=0;n<s.cutIndexes.length;n++){const o=s.cutIndexes[n],r=s.geometries[n],c=l(r);for(let t=0;t<c.length;t++){const s=c[t];s.some(e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<s.length;t++){const n=s[t][0];e=n>e?n:e}e=Number(e.toFixed(9));const n=-360*i(e,180);for(let e=0;e<s.length;e++){const s=r.getPoint(t,e);r.setPoint(t,e,s.clone().offset(n,0))}return!0}})}if(o===e){if(j(t))for(const s of l(r))t[o]=t[o].addRing(s);else if(g(t))for(const s of l(r))t[o]=t[o].addPath(s)}else e=o,t[o]=r}return t}(A,await a(k,A,O,h)),e=[],n=[];for(let o=0;o<z.length;o++){const r=z[o];if("cut"!==r)n.push(r);else{const r=t.shift(),i=s[o];null!=i&&"polygon"===i.type&&i.rings&&i.rings.length>1&&r.rings.length>=i.rings.length?(e.push(r),n.push("simplify")):n.push(U?u(r):r)}}if(!e.length)return n;const o=await m(k,e,h),r=[];for(let t=0;t<n.length;t++){const s=n[t];"simplify"!==s?r.push(s):r.push(U?u(o.shift()):o.shift())}return r}const q=[];for(let t=0;t<z.length;t++){const s=z[t];if("cut"!==s)q.push(s);else{const t=A.shift();q.push(!0===U?u(t):t)}}return q}function M(t){if(!t)return null;const s=t.extent;if(!s)return null;const e=t.spatialReference&&p(t.spatialReference);if(!e)return s;const[n,o]=e.valid,r=2*o,{width:i}=s;let c,{xmin:l,xmax:u}=s;if([l,u]=[u,l],"extent"===t.type||0===i||i<=o||i>r||l<n||u>o)return s;switch(t.type){case"polygon":if(!(t.rings.length>1))return s;c=k(t.rings);break;case"polyline":if(!(t.paths.length>1))return s;c=k(t.paths);break;case"multipoint":c=t.points}const h=s.clone();for(let t=0;t<c.length;t++){let s=c[t][0];s<0?(s+=o,u=Math.max(s,u)):(s-=o,l=Math.min(s,l))}return h.xmin=l,h.xmax=u,h.width<i?(h.xmin-=o,h.xmax-=o,h):s}function U(t,s,e){const n=p(e);if(null==n)return t;const[o,r]=n.valid,i=2*r;let c=0,l=0;s>r?c=Math.ceil(Math.abs(s-r)/i):s<o&&(c=-Math.ceil(Math.abs(s-o)/i)),t>r?l=Math.ceil(Math.abs(t-r)/i):t<o&&(l=-Math.ceil(Math.abs(t-o)/i));let u=t+(c-l)*i;const h=u-s;return h>r?u-=i:h<o&&(u+=i),u}function w(t,s){const e=p(s);if(e){const[s,n]=e.valid,o=n-s;if(t<s)for(;t<s;)t+=o;if(t>n)for(;t>n;)t-=o}return t}export{U as getClosestDenormalizedXToReference,M as getDenormalizedExtent,b as normalizeCentralMeridian,w as normalizeMapX,y as straightLineDensify};
