/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{G as e,S as t}from"../../chunks/SimpleGeometryCursor.js";import{v as s,a as r,G as n,b as o,P as i,X as a,Y as c,m as u}from"../../chunks/Point2D.js";import{P as l,c as m}from"../../chunks/Envelope.js";import{P as p,aR as h,q as j,L as g}from"../../chunks/ProjectionTransformation.js";import{Envelope2D as N}from"../../chunks/Envelope2D.js";import{a as k}from"../../chunks/Centroid-DZi-eb9F.js";import{O as y}from"../../chunks/OperatorProximity.js";import{toPoint as d,getSpatialReference as P,fromGeometry as b}from"../../chunks/apiConverter.js";import"../../chunks/Transformation2D.js";import"../../chunks/tslib.es6.js";import"../../chunks/OperatorDefinitions.js";import"../../chunks/SideCalculator2D-BNwb5gvz.js";import"../Extent.js";import"../../chunks/string.js";import"../../chunks/object.js";import"../../core/lang.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/Logger.js";import"../../config.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/jsonConverter.js";class f extends e{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,t){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=t,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(s(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(null===e&&r("null pointer is not allowed"),e.getGeometryType()===n.enumPoint)return e;if(e.isEmpty())return new l({vd:e.getDescription()});switch(e.getGeometryType()){case n.enumPolygon:return this.labelPointPolygon(e);case n.enumPolyline:return this.labelPointPolyline(e);case n.enumMultiPoint:return this.labelPointMultiPoint(e);case n.enumEnvelope:return this.labelPointEnvelope(e);default:r("geometry is not supported")}}labelPointPolygon(e){const t=new N;e.queryEnvelope(t);const s=m(null,t,!0).total();let r=null,n=e;if(e.hasNonLinearSegments()){const t=new p({copy:e}),i=h(t,.25*s,s);o(i!==e),r=i,n=r}let u=0,g=0;for(let e=0,t=n.getPathCount();e<t;++e){const t=Math.abs(n.calculateRingArea2D(e));t>g&&(g=t,u=e)}const d=new i;if(Math.abs(g)<=2*s*s?d.setNAN():d.assign(k(n,u)),Number.isNaN(d.x)){const e=new N;return n.queryPathEnvelope(u,e),new l({pt:e.getCenter()})}if(n.getPointCount()<4)return new l({x:d.x,y:d.y});const P=i.getNAN(),b=[P.clone(),P.clone(),P.clone(),P.clone()],f=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],x=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let w=!1,C=(new y).getNearestCoordinate(n,d,!0,!1);if(0===C.m_distance&&(w=!0,b[0]=d,C=(new y).getNearestCoordinate(n,d,!1,!1),C.m_distance>.25*t.minDimension()*1.66666666))return new l({x:d.x,y:d.y});f[0]=C.m_distance,x[0]=0;const _=new i;let D=!1,S=.25,v=-1;const A=new N;n.queryPathEnvelope(u,A);do{let e=Number.NaN;if(b[1]=this.calculateParacentroid_(n,a(A.xmin,A.xmax,S),s),b[1].isNAN()||(C=(new y).getNearestCoordinate(n,b[1],!1,!1),e=C.m_distance),e>s&&1===j(n,b[1],s))D=!0,f[1]=e,x[1]=i.sqrDistance(b[1],d);else if(e>v&&(v=e,_.setCoordsPoint2D(b[1])),S-=.01,S<.1){if(!(v>=0))break;D=!0,f[1]=v,b[1]=_,x[1]=i.sqrDistance(b[1],d)}}while(!D);D=!1,S=.5,v=-1;let E=.01,M=1;do{let e=Number.NaN;if(b[2]=this.calculateParacentroid_(n,a(A.xmin,A.xmax,S),s),b[2].isNAN()||(C=(new y).getNearestCoordinate(n,b[2],!1,!1),e=C.m_distance),e>s&&1===j(n,b[2],s))D=!0,f[2]=e,x[2]=i.sqrDistance(b[2],d);else if(e>v&&(v=e,_.setCoordsPoint2D(b[2])),S=.5+E*M,E+=.01,M*=-1,S<.3||S>.7){if(!(v>=0))break;D=!0,f[2]=v,b[2]=_,x[2]=i.sqrDistance(b[2],d)}}while(!D);D=!1,S=.75,v=-1;do{let e=Number.NaN;if(b[3]=this.calculateParacentroid_(n,a(A.xmin,A.xmax,S),s),b[3].isNAN()||(C=(new y).getNearestCoordinate(n,b[3],!1,!1),e=C.m_distance),e>s&&1===j(n,b[3],s))D=!0,f[3]=e,x[3]=i.sqrDistance(b[3],d);else if(e>v&&(v=e,_.setCoordsPoint2D(b[3])),S+=.01,S>.9){if(!(v>=0))break;D=!0,f[3]=v,b[3]=_,x[3]=i.sqrDistance(b[3],d)}}while(!D);const U=[0,1,2,3],q=w?0:1;for(let e=q;e<4;e++)for(let e=q;e<3;e++){const t=x[e],s=x[e+1];if(c(t,s)>0){const r=U[e];U[e]=U[e+1],U[e+1]=r,x[e]=s,x[e+1]=t}}let G=q,T=0,L=0;for(let e=q;e<4;e++){switch(e){case 0:L=2*f[U[e]];break;case 1:L=1.66666666*f[U[e]];break;case 2:L=1.33333333*f[U[e]];break;case 3:L=f[U[e]]}L>T&&(T=L,G=U[e])}return o(!b[G].isNAN()),new l({x:b[G].x,y:b[G].y})}labelPointPolyline(e){const t=new i;if(e.getPointCount()>2*e.getPathCount()){let s=-1,r=-Number.MAX_VALUE;for(let t=0,n=e.getPathCount();t<n;t++)if(e.getPathSize(t)>2){const n=e.calculatePathLength2D(t);n>r&&(r=n,s=t)}const n=e.getPathStart(s),o=e.getPathEnd(s),i=Math.trunc((n+o)/2);t.assign(e.getXY(i))}else{let s=-Number.MAX_VALUE;const r=e.querySegmentIterator();for(;r.nextPath();)if(r.hasNextSegment()){const e=r.nextSegment(),n=e.calculateLength2D();n>s&&(s=n,t.assign(e.getCoord2D(e.lengthToT(.5*n))))}}return new l({x:t.x,y:t.y})}labelPointMultiPoint(e){const t=new N;e.queryEnvelope(t);const s=t.getCenter(),r=(new y).getNearestCoordinate(e,s,!1,!1).m_coordinate;return new l({x:r.x,y:r.y})}labelPointEnvelope(e){const t=e.getCenterXY();return new l({x:t.x,y:t.y})}calculateParacentroid_(e,t,s){const r=new N;e.queryEnvelope(r);const n=new i(t,0);let a=Number.MAX_VALUE,c=Number.MAX_VALUE,l=!1,m=!1;const p=new g;p.setStartXYCoords(n.x,r.ymin-1),p.setEndXYCoords(n.x,r.ymax+1);const h=new N,j=new i,k=new i,y=u(i,2),d=e.querySegmentIterator();for(;d.nextPath();)for(;d.hasNextSegment();){const e=d.nextSegment();if(e.queryEnvelope(h),o(e.isMonotoneQuickAndDirty()),j.setCoordsPoint2D(p.getStartXY()),k.setCoordsPoint2D(p.getEndXY()),0===h.clipLine(j,k))continue;if(1!==p.intersect(e,y,null,null,s))continue;const t=y[0].y;a>c?t<a&&(a=t,l=!0):t<c&&(c=t,m=!0)}return l&&m?n.y=(a+c)/2:n.setNAN(),n}}const x=new class{getOperatorType(){return 10203}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t){return new f(e,t)}execute(e,t){return new f(null,t).labelPoint(e)}};function w(e){return d((t=b(e),x.execute(t,null)),P(e));var t}function C(e){const s=e.map(b),r=P(e);return function(e){const s=x.executeMany(new t(e),null);return Array.from(s)}(s).map(e=>d(e,r))}const _=x.supportsCurves(),D=Object.freeze(Object.defineProperty({__proto__:null,execute:w,executeMany:C,supportsCurves:_},Symbol.toStringTag,{value:"Module"}));export{w as execute,C as executeMany,D as l,_ as supportsCurves};
