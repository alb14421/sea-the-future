/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{G as t,S as e}from"../../chunks/SimpleGeometryCursor.js";import{m as i,P as s,n,H as o,v as r,z as h,G as d,a as g,r as c,b as a,D as l,U as u,f as m,V as p}from"../../chunks/Point2D.js";import{P as f,M as E,aI as x,aJ as P}from"../../chunks/ProjectionTransformation.js";import{getSpatialReference as _,toPolygon as k,fromGeometry as F}from"../../chunks/apiConverter.js";import"../../chunks/Envelope2D.js";import"../../chunks/Envelope.js";import"../../chunks/Transformation2D.js";import"../../chunks/tslib.es6.js";import"../../chunks/OperatorDefinitions.js";import"../Extent.js";import"../../chunks/string.js";import"../../chunks/object.js";import"../../core/lang.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/Logger.js";import"../../config.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/jsonConverter.js";function w(t,e,i,s,n,o){const r=s-e;if(r<=o)return P(t,e,i,s,n),i;const h=function(t,e,i,s,n){const o=[];!function(t,e,i){const s=Math.trunc(e/2);let n=BigInt(s);const o=BigInt(e);for(let e=0;e<i;++e)t.push(Number(n%o)),n=6364136223846793005n*n+1442695040888963407n&0x7fffffffffffffffn,n=BigInt.asUintN(64,n);p(t);const r=u(t,(t,e)=>t===e);t.length=r}(o,i-e,n);const r=[];for(let i=0,s=o.length;i<s;i++){const s=o[i];r.push(l(t[e+s],s))}const h=Math.trunc(r.length/2);return r.sort((t,e)=>s(t.first,e.first)?-1:1),e+r[h].second}(t,e,s,n,Math.min(Math.max(r>>1,3),100)),d=t[h];t[e]=m(t[h],t[h]=t[e]);let g=e+1,c=!1;for(let i=e+1;i!==s;++i)n(t[i],d)&&(t[g]=m(t[i],t[i]=t[g]),++g,c=!0);if(!c)for(let s=e+1;s<i;++s)n(d,t[s])||(s!==g&&(t[g]=m(t[s],t[s]=t[g])),++g);return--g,t[g]=m(t[e],t[e]=t[g]),g}function j(){return{p:new s,userData:Number.NaN,edge:null}}class T{constructor(){this.info=0,this.mask=!1,this.p=null,this.a=[null,null],this.twin=null}nextFreeEdge(){return this.twin}setIndex(t){this.info=t,this.mask=!1}getIndex(){return this.info}setMask(){this.mask=!0}getMask(){return this.mask}}function b(t,e){return{first:t,second:e}}function y(t,e){t.first=e.first,t.second=e.second}function C(){return this.i1-this.i0}function D(){return{i0:Number.NaN,i1:Number.NaN,nextFreeEdgeIndex:[-1],box:[b(null,null),b(null,null)],size:C}}function I(){return{p:[new s,new s],points:[null,null]}}function X(){return{p:[null,null,null]}}class Y{constructor(){this.m_nextFreePairEdge=b(null,null),this.m_points=[],this.m_pointZero=null,this.m_edges=[],this.m_voronoiToEdge=[],this.m_nextFreeEdge=0}clear(){this.m_nextFreePairEdge=b(null,null),this.m_points.length=0,this.m_pointZero=null,this.m_edges.length=0,this.m_voronoiToEdge.length=0,this.m_nextFreeEdge=0}reservePoints(t){a(t>1)}prepare(t){{const e=j();e.p.x=Number.POSITIVE_INFINITY,e.p.y=Number.POSITIVE_INFINITY,e.userData=t,this.m_points.push(e)}}addVertex(t,e){const i=j();i.p.assign(t),i.userData=e,i.edge=null,this.m_points.push(i)}removeDuplicates(){const t=this.m_points.shift();this.m_points.sort((t,e)=>t.p.compareX(e.p));const e=u(this.m_points,(t,e)=>t.p.equals(e.p)),i=e!==this.m_points.length;return this.m_points.length=e,this.m_points.unshift(t),i}boundVoronoiCells(t,e){const i=this.m_points.length;if(i<2)return!1;const n=[this.m_points[1].p.clone(),this.m_points[1].p.clone()];for(let t=2;t<i;t++){const e=this.m_points[t].p;e.x<n[0].x&&(n[0].x=e.x),n[1].x<e.x&&(n[1].x=e.x),e.y<n[0].y&&(n[0].y=e.y),n[1].y<e.y&&(n[1].y=e.y)}const o=new s;o.x=.5*(n[0].x+n[1].x),o.y=.5*(n[0].y+n[1].y);let r=0;for(let t=1;t<i;t++){const e=this.m_points[t].p,i=s.sqrDistanceCoords(e.x,e.y,o.x,o.y);r<i&&(r=i)}const h=Math.sqrt(r),d=Math.max(h+2*t,1.5*h);{const t=.8660254037844386,i=.5;let n=1,r=0;for(let h=0;h<12;h++){const h=new s;h.x=o.x+d*n,h.y=o.y+d*r,this.addVertex(h,e);const g=n*i+r*t;n=n*t-r*i,r=g}}return!0}construct(){const t=D();return!!this.constructTask(t)&&(this.solveTask(t),!0)}constructTask(t){if(this.m_pointZero=this.createZeroHandle(),a(void 0!==this.m_pointZero),this.m_points.length<3)return!1;const e=6*(this.m_points.length-2);this.m_edges=i(T,e);for(let t=0;t<e;t++)this.m_edges[t].setIndex(t);return t.i0=1,t.i1=this.m_points.length,t.nextFreeEdgeIndex[0]=0,!0}splitTask(t,e,i,s){const n=t,o=e,r=i,h=s;n.k=this.findMaxSide(h.i0,h.i1);let d=h.i0+h.i1>>1;d=0===n.k?w(this.m_points,h.i0,d,h.i1,(t,e)=>t.p[0]!==e.p[0]?t.p[0]<e.p[0]:t.p[1]<e.p[1],1250):w(this.m_points,h.i0,d,h.i1,(t,e)=>t.p[1]!==e.p[1]?t.p[1]<e.p[1]:t.p[0]<e.p[0],1250),o.i0=h.i0,o.i1=d,o.nextFreeEdgeIndex[0]=h.nextFreeEdgeIndex[0],h.nextFreeEdgeIndex[0]+=6*(o.i1-o.i0-1)+2,r.i0=d,r.i1=h.i1,r.nextFreeEdgeIndex[0]=h.nextFreeEdgeIndex[0],h.nextFreeEdgeIndex[0]+=6*(r.i1-r.i0-1)+2,n.pTask=h,n.pTask0=o,n.pTask1=r}solveMergeTask(t){const e=this.newPairEdgeEx(t.pTask.nextFreeEdgeIndex,!1);if(t.pTask.box[t.k]=b(t.pTask0.box[t.k].first,t.pTask1.box[t.k].second),t.pTask.box[1-t.k]=b(v(this.getPointXYFromEdge(t.pTask0.box[1-t.k].first),this.getPointXYFromEdge(t.pTask1.box[1-t.k].first),1-t.k)?t.pTask0.box[1-t.k].first:t.pTask1.box[1-t.k].first,v(this.getPointXYFromEdge(t.pTask0.box[1-t.k].second),this.getPointXYFromEdge(t.pTask1.box[1-t.k].second),1-t.k)?t.pTask1.box[1-t.k].second:t.pTask0.box[1-t.k].second),t.pTask.i0+2===t.pTask.i1){const i=t.pTask0.box[t.k].second,s=i.twin,n=t.pTask1.box[t.k].first,o=n.twin;return this.joinEdges2(s,o),this.joinEdges2(o,s),void this.join(i,n,0,1,e)}const i=[new Array(2),new Array(2)];i[0][0]=i[1][0]=b(t.pTask0.box[t.k].second,t.pTask0.box[t.k].second.twin),i[0][1]=i[1][1]=b(t.pTask1.box[t.k].first,t.pTask1.box[t.k].first.twin);const s=[!1,!1];if(t.pTask0.i0+1===t.pTask0.i1?(this.findEdgeSide(i[0],s,1,0),this.findEdgeSide(i[1],s,1,1)):(this.findEdge(i[0],s,0),this.findEdge(i[1],s,1)),s[0]||s[1]){if(s[0]){const e=this.newPairEdgeEx(t.pTask0.nextFreeEdgeIndex,!1);this.insertEdge(i[0][0].first,e.first,0),this.insertEdge(i[0][0].second,e.second,1)}if(s[1]){const e=this.newPairEdgeEx(t.pTask1.nextFreeEdgeIndex,!1);this.insertEdge(i[0][1].first,e.first,1),this.insertEdge(i[0][1].second,e.second,0)}}else this.getNextDEdge(i[0][0].first,0)!==i[0][0].first&&(i[1][0]=this.newPairEdgeEx(t.pTask0.nextFreeEdgeIndex,!1),this.insertEdge(i[0][0].first,i[1][0].first,0),this.insertEdge(i[0][0].second,i[1][0].second,1)),this.getNextDEdge(i[0][1].first,0)!==i[0][1].first&&(i[1][1]=this.newPairEdgeEx(t.pTask1.nextFreeEdgeIndex,!1),this.insertEdge(i[0][1].first,i[1][1].first,1),this.insertEdge(i[0][1].second,i[1][1].second,0));this.merge(i[1][0],i[0][0],i[0][1],i[1][1],e)}solveTask(t){const e=t;switch(e.i1-e.i0){case 1:{this.insertPoint(e.i0,e.nextFreeEdgeIndex);const t=this.m_points[e.i0].edge;e.box[0]=e.box[1]=l(t,t)}break;case 2:{const t=e.i0,i=t+1;this.insertPoint(t,e.nextFreeEdgeIndex),this.insertPoint(i,e.nextFreeEdgeIndex);const s=this.m_points[t],n=this.m_points[i],o=s.edge,r=n.edge,h=o.twin,d=r.twin;this.joinEdges2(h,d),this.joinEdges2(d,h);const g=this.newPairEdgeEx(e.nextFreeEdgeIndex,!1);this.join(o,r,0,1,g);for(let t=0;t<2;t++)e.box[t]=v(this.getPointXY(s),this.getPointXY(n),t)?b(o,r):b(r,o)}break;case 3:{const t=[e.i0,e.i0+1,e.i0+2];this.insertPoint(t[0],e.nextFreeEdgeIndex),this.insertPoint(t[1],e.nextFreeEdgeIndex),this.insertPoint(t[2],e.nextFreeEdgeIndex);const i=[this.m_points[t[0]],this.m_points[t[1]],this.m_points[t[2]]],s=this.caseFromCompare(i[0].p,i[1].p,i[2].p),n=[i[0].edge,i[1].edge,i[2].edge],o=Y.c_aTableDelaunayTriangulationSolution[s],r=S(19*S(1+(7&o))),h=S(19*S(1+(o>>5)));let d=S(o<<3)>>6;const g=3&r,c=r>>6,a=3&h,l=h>>6;e.box[0]=b(n[g],n[c]),e.box[1]=b(n[a],n[l]);const u=[n[0].twin,n[1].twin,n[2].twin],p=[this.newPairEdgeEx(e.nextFreeEdgeIndex,!1),this.newPairEdgeEx(e.nextFreeEdgeIndex,!1),this.newPairEdgeEx(e.nextFreeEdgeIndex,!1)];switch(3===d&&(d=this.orientation(i[0].p,i[1].p,i[2].p)+1),d){case 0:this.joinEdges2(u[0],u[2]),this.joinEdges2(u[2],u[1]),this.joinEdges2(u[1],u[0]),this.join(n[0],n[2],0,1,p[0]),this.join(n[2],n[1],0,1,p[1]),this.join(n[1],n[0],0,1,p[2]);break;case 1:{const t=[0,1,2];t[3-(g+c)]=m(t[1],t[1]=t[3-(g+c)]),this.joinEdges2(u[t[0]],u[t[1]]),this.joinEdges2(u[t[1]],u[t[2]]),this.joinEdges2(u[t[2]],u[t[0]]),this.join(n[t[0]],n[t[1]],0,1,p[0]),this.join(n[t[1]],n[t[2]],0,1,p[1]),this.join(p[1].first,u[t[2]],0,1,p[2])}break;case 2:this.joinEdges2(u[0],u[1]),this.joinEdges2(u[1],u[2]),this.joinEdges2(u[2],u[0]),this.join(n[0],n[1],0,1,p[0]),this.join(n[1],n[2],0,1,p[1]),this.join(n[2],n[0],0,1,p[2])}}break;default:{const e={k:0,pTask:null,pTask0:null,pTask1:null},i=D(),s=D();this.splitTask(e,i,s,t),this.solveTask(i),this.solveTask(s),this.solveMergeTask(e)}}}getOutsideHull(){const t=[],e=this.m_points[0].edge;let i=e;do{t.push(this.getPointFromEdge(this.getTwinEdge(i))),i=this.getNextDEdge(i,0)}while(i!==e);return t}getConvexHull(){const t=[],e=this.m_points[0].edge;let i=e;do{const e=this.getPointFromEdge(this.getTwinEdge(i));t.length<2||!this.insideLine(this.getPointXY(t.at(-2)),this.getPointXY(t.at(-1)),this.getPointXY(e))?t.push(e):t[t.length-1]=e,i=this.getNextDEdge(i,0)}while(i!==e);return 2<t.length&&this.insideLine(this.getPointXY(t[0]),this.getPointXY(t.at(-1)),this.getPointXY(t.at(-2)))&&t.pop(),2<t.length&&this.insideLine(this.getPointXY(t[1]),this.getPointXY(t[0]),this.getPointXY(t.at(-1)))&&(t[0]=t.at(-1),t.pop()),t}getVoronoiPolygon(t,e){t.length=0;const i=this.getEdgeFromPoint(e);let s=i;for(;;){const e=this.calculateCircleCenter(s);t.push(e);const n=this.getNextDEdge(s,1);if(n===i)break;s=n}}getNearestPoint(t){this.isInfinitePointFromPoint(t)&&g("Not supported for the infinite point");const e=this.getPointXY(t);let i=this.m_pointZero,n=Number.MAX_VALUE;const o=this.getEdgeFromPoint(t);let r=o;do{const t=this.getPointFromEdge(this.getTwinEdge(r));if(!this.isInfinitePointFromPoint(t)){const o=s.sqrDistance(e,this.getPointXY(t));o<n&&(i=t,n=o)}r=this.getCounterClockwiseEdge(r)}while(r!==o);return i}addConstraint(t,e){const i=[null],s=[null];if(!this.constraintFindFirstEdge(i,s,t,e))return b(s[0],i[0]);i[0]=this.getTwinEdge(i[0]);const n=this.getPointXY(t),o=this.getPointXY(e),r=[new Array(0),new Array(0)],h=i[0];for(;;){const t=this.getClockwiseEdge(s[0]);t.getMask()&&g("add_constraint");const h=b(t,this.getTwinEdge(t));this.deleteTwinEdges(h,!0);const d=this.getCounterClockwiseEdge(this.getTwinEdge(i[0])),c=this.getTwinEdge(this.getClockwiseEdge(s[0])),a=this.getPointFromEdge(c);if(a===e){r[0].push(i[0]),i[0]=d,r[1].push(s[0]),s[0]=c;break}const l=this.orientation(n,o,this.getPointXY(a));0===l&&g("add_constraint - point on constraint"),0<l?(r[0].push(i[0]),i[0]=d):(r[1].push(s[0]),s[0]=c)}r[0].push(i[0]),r[1].push(s[0]);const d=this.newPairEdge();d.first.setMask(),d.second.setMask(),this.join(s[0],h,1,1,d),this.triangulateConstraint(r[0],1,r[0].length-1,d),r[1].reverse();const c=b(d.second,d.first);return this.triangulateConstraint(r[1],1,r[1].length-1,c),c}verify(){for(let t=0,e=this.m_edges.length;t<e;t++){const e=this.m_edges[t];if(!e.getMask()&&!this.testEdge(e))return!1}return!0}getDelaunayTriangleCount(){return this.m_points.length-2<<1}getVoronoiSegments(t=Number.MAX_VALUE){const e=[];for(let n=0,o=this.m_edges.length;n<o;n+=2){const o=b(null,null);if(o.first=this.m_edges[n],o.second=o.first.twin,this.isInfinitePointFromEdge(o.first)&&(o.second=m(o.first,o.first=o.second)),this.isInfinitePointFromEdge(o.second)){const n=i(s,3);n[0]=this.calculateCircleCenter(this.getNextDEdge(o.first,0).twin,1),n[2]=this.calculateCircleCenter(this.getNextDEdge(o.first,1),1);const r=i(s,2);r[0].assign(n[0]),r[1].assign(n[2]),r[0].rightPerpendicularThis(),r[1].leftPerpendicularThis(),n[1]=n[0].add(r[0]).add(n[2].add(r[1])),n[1].normalize();for(const e of n)e.mulThis(t);const h=I();h.points[0]=o.first.p,h.points[1]=o.second.p;for(let t=0;t<n.length-1;t++){for(let e=0;e<2;e++)h.p[e]=n[t+e];h.p[0].equals(h.p[1])||e.push(h)}}else if(this.isInfinitePointFromEdge(this.getNextDEdge(o.first,0).twin)&&this.isInfinitePointFromEdge(this.getNextDEdge(o.first,1).twin)){const t=i(s,3);t[0]=this.calculateCircleCenter(o.first),t[1]=this.getPointXY(this.getPointFromEdge(o.first)).add(this.getPointXY(this.getPointFromEdge(o.second))).mul(.5),t[2]=this.calculateCircleCenter(o.second);const n=I();n.points[0]=o.first.p,n.points[1]=o.second.p;for(let i=0;i<t.length-1;i++){for(let e=0;e<2;e++)n.p[e]=t[i+e];n.p[0].equals(n.p[1])||e.push(n)}}else{const t=I();t.p[0]=this.calculateCircleCenter(o.first),t.p[1]=this.calculateCircleCenter(o.second),t.points[0]=o.first.p,t.points[1]=o.second.p,t.p[0].equals(t.p[1])||e.push(t)}}return e}startDelaunayTriangles(){return-1}nextDelaunayTriangle(t,e){for(;;){if(++e[0],e[0]===this.m_edges.length)return!1;const i=this.m_edges[e[0]];if(t.p[0]=this.getPointFromEdge(i),this.isInfinitePointFromPoint(t.p[0]))continue;const s=this.getTwinEdge(i);if(t.p[1]=this.getPointFromEdge(s),this.isInfinitePointFromPoint(t.p[1]))continue;if(this.getPointXY(t.p[1]).lt(this.getPointXY(t.p[0])))continue;const n=this.getTwinEdge(this.getNextDEdge(i,1));if(t.p[2]=this.getPointFromEdge(n),!this.isInfinitePointFromPoint(t.p[2])&&!this.getPointXY(t.p[2]).lt(this.getPointXY(t.p[0])))return!0}}getPointCount(){return this.m_points.length-1}getPoint(t){return this.m_points[t+1]}getInfinitePoint(){return this.m_pointZero}isInfinitePointFromPoint(t){return t===this.m_pointZero}getPointXY(t){return t.p}getPointIndex(t){return t.userData}setPointIndex(t,e){t.userData=e}getEdgeFromPoint(t){return t.edge}isInfinitePointFromEdge(t){return t.p===this.m_pointZero}getEdgeCount(){return this.m_edges.length}getEdge(t){return this.m_edges[t]}getEdgeIndex(t){return t.getIndex()}getPointFromEdge(t){return t.p}getPointXYFromEdge(t){return t.p.p}getCounterClockwiseEdge(t){return t.a[0]}getClockwiseEdge(t){return t.a[1]}getTwinEdge(t){return t.twin}getPreviousEdge(t){return this.getTwinEdge(this.getCounterClockwiseEdge(t))}getNextEdge(t){return this.getClockwiseEdge(this.getTwinEdge(t))}getNextDEdge(t,e=1){return t.a[e]}newPairEdge(){const t=b(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second);return this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge(),t.first.twin=t.second,t.second.twin=t.first,t}newPairEdgeEx(t,e){let i;if(e&&null!==this.m_nextFreePairEdge.first)i=b(this.m_nextFreePairEdge.first,this.m_nextFreePairEdge.second),this.m_nextFreePairEdge.first=this.m_nextFreePairEdge.first.nextFreeEdge(),this.m_nextFreePairEdge.second=this.m_nextFreePairEdge.second.nextFreeEdge();else{const e=t[0]++,s=t[0]++;i=b(this.m_edges[e],this.m_edges[s])}return i.first.twin=i.second,i.second.twin=i.first,i}insertEdge(t,e,i){e.p=t.p;const s=t.a[i],n=e.a;n[i]=s,n[1-i]=t,t.a[i]=e,s.a[1-i]=e}insertPoint(t,e){const i=this.m_points[t],s=this.newPairEdgeEx(e,!1),n=s.first,o=s.second;i.edge=s.first,n.p=this.m_points[t],n.a[0]=s.first,n.a[1]=s.first,o.p=this.m_pointZero,o.a[0]=s.second,o.a[1]=s.second,null===this.m_points[0].edge&&(this.m_points[0].edge=s.second)}deleteTwinEdges(t,e){this.deleteEdge(t.first),this.deleteEdge(t.second),e&&(t.first.twin=this.m_nextFreePairEdge.first,t.second.twin=this.m_nextFreePairEdge.second,this.m_nextFreePairEdge=t)}join(t,e,i,s,n){this.insertEdge(t,n.first,i),this.insertEdge(e,n.second,s)}joinEdges2(t,e){t.a[1]=e,e.a[0]=t}checkEdge(t,e,i,s,n){for(;;){const o=b(null,null);if(o.first=this.getNextDEdge(t.first,s),o.second=o.first.twin,this.isInfinitePointFromEdge(o.second))return t;const r=this.getPointXYFromEdge(t.second),h=this.getPointXYFromEdge(o.second);if(this.inCircle(e,i,r,h)<=0)return t;if(this.deleteTwinEdges(t,n),!n){const e=this.getNextDEdge(t.second,s).twin;this.join(o.second,e,s,s,t)}t=o}}calculateCircleCenter(t,e=Number.MAX_VALUE){const i=this.getPointXYFromEdge(t),n=this.getPointXYFromEdge(t.twin),o=this.getNextDEdge(t,0);if(this.isInfinitePointFromEdge(o.twin)){const t=new s;if(Number.isNaN(e))t.setNAN();else{const s=n.sub(i);s.leftPerpendicularThis(),t.assign(s),t.divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t.mulThis(e)}return t}const r=this.getPointXYFromEdge(o.twin);return this.calculateCircleCenterFromThreePoints(i,n,r)}createZeroHandle(){return this.m_points[0]}deleteEdge(t){const e=t,i=e.p;i.edge===t&&(i.edge=e.a[0]),e.a[0].a[1]=e.a[1],e.a[1].a[0]=e.a[0]}testEdge(t){if(this.isInfinitePointFromEdge(t))return!0;const e=t.twin;if(this.isInfinitePointFromEdge(e))return!0;const i=this.getNextDEdge(t,0).twin,s=this.getNextDEdge(e,0).twin;if(this.isInfinitePointFromEdge(i)||this.isInfinitePointFromEdge(s))return!0;const n=this.getPointXYFromEdge(t),o=this.getPointXYFromEdge(e),r=this.getPointXYFromEdge(i),h=this.getPointXYFromEdge(s);return!(this.orientation(n,o,r)<=0)&&!(0<=this.orientation(n,o,h))&&this.inCircle(n,o,r,h)<=0}findMaxSide(t,e){const i=[this.m_points[t].p.clone(),this.m_points[t].p.clone()];for(t++;t!==e;t++){const e=this.m_points[t].p;e.x<i[0].x&&(i[0].x=e.x),i[1].x<e.x&&(i[1].x=e.x),e.y<i[0].y&&(i[0].y=e.y),i[1].y<e.y&&(i[1].y=e.y)}return i[1].x-i[0].x<i[1].y-i[0].y?1:0}findEdge(t,e,i){let s=!1,n=0;for(;;){const o=b(null,null);if(o.second=this.getNextDEdge(t[n].second,i^n),o.first=o.second.twin,0===i&&this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(o.first))<0||1===i&&0<this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(o.first)))t[n]=o,e[n]=!0,s=!1;else{if(s)return;n^=1,s=!0}}}findEdgeSide(t,e,i,s){for(;;){const n=b(null,null);if(n.second=this.getNextDEdge(t[i].second,s^i),n.first=n.second.twin,!(0===s&&this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(n.first))<0||1===s&&0<this.orientation(this.getPointXYFromEdge(t[0].first),this.getPointXYFromEdge(t[1].first),this.getPointXYFromEdge(n.first))))return;t[i]=n,e[i]=!0}}merge(t,e,i,s,n){const o={...t},r={...s},h={...n};let d={...e},g={...i};const c=d.second,a=g.second;for(;;){if(this.join(d.first,g.first,0,1,h),d.first=this.getNextDEdge(h.first,0),g.first=this.getNextDEdge(h.second,1),d.first===o.first&&g.first===r.first){this.joinEdges2(c,a),this.joinEdges2(r.second,o.second);break}d.second=d.first.twin,g.second=g.first.twin;const t=this.getPointXYFromEdge(h.first),e=this.getPointXYFromEdge(h.second);if(d.first===o.first){let i=b(null,null);i.first=this.getNextDEdge(g.first,1),i.second=i.first.twin,i=this.checkEdge(i,t,e,1,!1),y(d,h),y(h,g),g=b(i.second,i.first)}else if(g.first===r.first){let i=b(null,null);i.first=this.getNextDEdge(d.first,0),i.second=i.first.twin,i=this.checkEdge(i,t,e,0,!1),g=b(h.second,h.first),y(h,d),d=b(i.second,i.first)}else{let i=b(null,null);i.first=this.getNextDEdge(d.first,0),i.second=i.first.twin,i=this.checkEdge(i,t,e,0,!1);let s=b(null,null);s.first=this.getNextDEdge(g.first,1),s.second=s.first.twin,s=this.checkEdge(s,t,e,1,!1);const n=this.getPointXYFromEdge(i.second),o=this.getPointXYFromEdge(s.second);let r=this.inCircle(t,e,n,o);0===r&&(r=this.orientation(t,e,o)),0<r?(y(d,h),y(h,g),g=b(s.second,s.first)):(g=b(h.second,h.first),y(h,d),d=b(i.second,i.first))}this.deleteTwinEdges(h,!1)}}findEdgeClockwise(t,e,i,s,n,o){for(t[0]=s;;){e[0]=t[0],++e[0]===i.length&&(e[0]=0);const s=this.orientation(n,o,this.getPointXYFromEdge(i[e[0]]));if(s<=0)return s<0;t[0]=e[0]}}findEdgeCounterClockwise(t,e,i,s,n,o){for(e[0]=s;;){t[0]=0!==e[0]?e[0]:i.length,t[0]--;const s=this.orientation(n,o,this.getPointXYFromEdge(i[t[0]]));if(0<=s)return 0<s;e[0]=t[0]}}constraintFindFirstEdge(t,e,i,s){const n=[];{const o=this.getEdgeFromPoint(i);let r=o;do{const i=this.getTwinEdge(r);if(this.getPointFromEdge(i)===s)return t[0]=i,e[0]=r,t[0].setMask(),e[0].setMask(),!1;n.push(i),r=this.getClockwiseEdge(r)}while(r!==o)}n.length<3&&g("add_constraint");let o=-1;for(let t=0,e=n.length;t<e;t++)this.isInfinitePointFromEdge(n[t])&&(-1!==o&&g("add_constraint"),o=t);const r=this.getPointXY(i),h=this.getPointXY(s);let d,c;if(-1!==o)for(x(n,0,o+1,n.length),n.pop(),0===this.orientation(r,h,this.getPointXYFromEdge(n[0]))&&g("add_constraint - point on constraint"),0===this.orientation(r,h,this.getPointXYFromEdge(n.at(-1)))&&g("add_constraint - point on constraint"),d=0,c=n.length-1;d+1!==c;){const t=d+c>>1,e=this.orientation(r,h,this.getPointXYFromEdge(n[t]));0===e&&g("add_constraint - point on constraint"),0<e?d=t:c=t}else{let t=0,e=this.orientation(r,h,this.getPointXYFromEdge(n[t]));if(0!==e)if(0<e){const e=[0],i=[0];this.findEdgeClockwise(e,i,n,t,r,h)||g("add_constraint"),d=e[0],c=i[0]}else{const e=[0],i=[0];this.findEdgeCounterClockwise(e,i,n,t,r,h)||g("add_constraint"),d=e[0],c=i[0]}else{t++,e=this.orientation(r,h,this.getPointXYFromEdge(n[t])),e<=0&&g("add_constraint");const i=[0],s=[0];this.findEdgeClockwise(i,s,n,t,r,h)||g("add_constraint"),d=i[0],c=s[0]}}return t[0]=n[d],e[0]=n[c],!0}triangulateConstraint(t,e,i,s){if(e===i)return;let n=i;for(let o=e;o!==i;++o)this.inCircle(this.getPointXYFromEdge(s.first),this.getPointXYFromEdge(s.second),this.getPointXYFromEdge(t[n]),this.getPointXYFromEdge(t[o]))<0&&(n=o);if(n!==i){const e=this.newPairEdge();this.join(s.first,t[n],1,1,e),t[n]=e.second,this.triangulateConstraint(t,n+1,i,e)}if(n!==e){const i=this.newPairEdge();this.join(t[n],s.second,1,0,i),this.triangulateConstraint(t,e,n-1,i)}}insideLine(t,e,i){return 0===this.orientation(t,e,i)&&(e.x<t.x!=e.x<i.x||e.y<t.y!=e.y<i.y)}orientation(t,e,i){return s.orientationRobust(t,e,i)}inCircle(t,e,i,n){return s.inCircleRobust(t,e,i,n)}calculateCircleCenterFromThreePoints(t,e,i){return e.lt(t)&&(e=m(t,t=e)),i.lt(e)&&(i=m(e,e=i)),e.lt(t)&&(e=m(t,t=e)),s.calculateCircleCenterFromThreePoints(t,e,i)}compare(t,e){return 3*((N(t[0]<e[0])<<1)+N(t[0]>e[0]))+(N(t[1]<e[1])<<1)+N(t[1]>e[1])-1}caseFromCompare(t,e,i){return(this.compare(t,e)<<6)+(this.compare(t,i)<<3)+this.compare(e,i)}}function N(t){return t?1:0}function v(t,e,i){return t[i]!==e[i]?t[i]<e[i]:t[1-i]<e[1-i]}function S(t){return 255&t}Y.c_aTableDelaunayTriangulationSolution=Uint8Array.from([41,74,0,0,0,0,0,0,0,206,0,0,0,0,0,0,0,0,0,0,65,0,0,0,0,0,33,33,65,0,0,0,0,0,0,0,193,0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,214,173,0,0,0,0,0,0,0,107,239,0,0,0,0,0,0,0,0,0,181,0,0,0,0,0,0,0,181,0,0,0,0,0,0,117,117,245,0,0,0,0,0,0,0,0,0,103,0,0,0,0,0,0,0,167,0,0,0,0,0,0,231,103,231,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,198,0,0,41,0,0,74,0,0,49,0,0,49,0,0,50,0,0,194,0,0,193,0,0,194,0,0,0,0,0,206,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,198,0,0,0,0,0,82,50,82,0,0,0,0,0,0,0,198,0,66,0,0,65,0,0,66,49,66,33,57,65,82,50,90,0,194,0,0,193,0,0,194,0,0,0,0,0,0,0,214,0,0,0,0,0,86,54,86,0,0,0,0,0,0,0,222,0,0,0,0,0,0,178,0,0,0,0,0,0,230,102,230,177,0,0,177,0,0,178,0,177,0,0,177,0,0,178,0,113,226,113,113,249,226,122,226,0,0,0,0,0,0,102,0,0,0,0,0,0,0,190,0,0,0,0,0,0,230,102,230,0,0,0,165,0,0,0,0,0,0,0,0,243,0,0,0,0,0,173,0,0,0,0,0,0,0,0,165,0,0,0,0,0,0,0,0,245,0,0,0,0,0,107,0,0,239,0,0,163,0,0,163,0,0,167,0,0,247,0,0,243,0,0,247,0,0,37,37,69,0,0,0,0,0,0,0,211,0,0,0,0,0,0,0,69,0,0,0,0,0,37,37,69,0,0,0,0,0,0,0,221,0,0,0,0,215,0,0,211,0,0,215,35,87,35,35,91,87,63,87,0,215,0,0,211,0,0,215,0,0,0,165,0,0,0,0,0,0,115,115,243,0,0,0,0,0,0,181,0,0,0,0,0,0,0,189,0,0,0,0,0,0,117,117,245,0,0,0,99,0,0,99,0,0,103,0,163,0,0,163,0,0,167,0,99,247,115,123,243,231,103,255]);class A{constructor(t){this.m_numberOfSets=t,this.m_elements=Array.from({length:t},(t,e)=>e),this.m_sizes=c(t,1)}getNumberOfSets(){return this.m_numberOfSets}connected(t,e){return this.findRoot(t)===this.findRoot(e)}connect(t,e){const i=this.findRoot(t),s=this.findRoot(e);return i!==s&&(this.m_sizes[i]<this.m_sizes[s]?(this.m_sizes[s]+=this.m_sizes[i],this.m_elements[i]=s):(this.m_sizes[i]+=this.m_sizes[s],this.m_elements[s]=i),--this.m_numberOfSets,!0)}connectRange(t,e,i){if(e!==i)for(let s=e;s<i;++s)this.connect(t[e],t[s])}size(){return this.m_elements.length}size1(t){return a(0),0}findRoot(t){let e=t;if(this.m_elements[e]!==e)do{this.m_elements[e]=this.m_elements[this.m_elements[e]],e=this.m_elements[e]}while(this.m_elements[e]!==e);return e}}function M(){return l(Number.NaN,l([0,0,0],[0,0,0]))}class U extends t{alphaShapeConstruct(t,e){const i=t.getEdgeCount(),s=new f({vd:this.m_vertexDescription});if(!s)throw new Error("alphaShapeConstruct");for(let n=0;n<i;++n){if(2!==e[n])continue;const i=b(null,null);if(i.first=t.getEdge(n),i.second=t.getTwinEdge(i.first),1!==e[t.getEdgeIndex(i.second)])continue;t.getPointXYFromEdge(i.first),s.startPath(t.getPointXYFromEdge(i.first));let o=n,r=i.second;for(;;){for(e[o]=3,r=t.getCounterClockwiseEdge(r);1===e[t.getEdgeIndex(r)];)r=t.getCounterClockwiseEdge(r);if(r===i.first)break;s.lineTo(t.getPointXYFromEdge(r)),o=t.getEdgeIndex(r),r=t.getTwinEdge(r)}}return s}alphaShape(t,e){const n=t.getEdgeCount(),o=new Uint8Array(n);for(let r=0;r<n;++r){if(0!==o[r])continue;const n=X(),h=t.getEdge(r);n.p[0]=t.getPointFromEdge(h);const d=t.getClockwiseEdge(t.getTwinEdge(h));n.p[1]=t.getPointFromEdge(d);const g=t.getEdgeIndex(d),c=t.getClockwiseEdge(t.getTwinEdge(d));n.p[2]=t.getPointFromEdge(c);const a=t.getEdgeIndex(c);let l=1;for(let e=0;e<3;++e)if(t.isInfinitePointFromPoint(n.p[e])){l=2;break}if(1===l){const o=i(s,3);for(let e=0;e<3;++e)o[e]=t.getPointXY(n.p[e]);const r=s.sqrDistance(o[0],o[1]),h=s.sqrDistance(o[1],o[2]),d=s.sqrDistance(o[2],o[0]),g=2*o[1].sub(o[0]).crossProduct(o[2].sub(o[0]));e<r*h*d/(g*g)&&(l=2)}o[r]=o[g]=o[a]=l}return this.alphaShapeConstruct(t,o)}alphaShapeAlphaOut(t,e){const i=t.getEdgeCount(),n=new Uint8Array(i),o=[],r=new A(t.getPointCount());for(let e=0;e<i;++e){if(0!==n[e])continue;const i=X(),r=t.getEdge(e);i.p[0]=t.getPointFromEdge(r);const h=t.getClockwiseEdge(t.getTwinEdge(r));i.p[1]=t.getPointFromEdge(h);const d=t.getEdgeIndex(h),g=t.getClockwiseEdge(t.getTwinEdge(h));i.p[2]=t.getPointFromEdge(g);const c=t.getEdgeIndex(g);let a=1;for(let e=0;e<3;++e)if(t.isInfinitePointFromPoint(i.p[e])){a=2;break}if(1===a){const n=new Array(3);for(let e=0;e<3;++e)n[e]=t.getPointXY(i.p[e]);const r=s.sqrDistance(n[0],n[1]),h=s.sqrDistance(n[1],n[2]),g=s.sqrDistance(n[2],n[0]),l=n[1].sub(n[0]).crossProduct(n[2].sub(n[0])),u=M();u.first=r*h*g/(l*l),u.second.first[0]=e,u.second.first[1]=d,u.second.first[2]=c,u.second.second[0]=t.getPointIndex(i.p[0]),u.second.second[1]=t.getPointIndex(i.p[1]),u.second.second[2]=t.getPointIndex(i.p[2]),o.push(u),a=2}n[e]=n[d]=n[c]=a}o.sort((t,e)=>function(t,e){if(t.first!==e.first)return t.first-e.first;let i=t.second.first,s=e.second.first;for(let t=0;t<3;++t)if(i[t]!==s[t])return i[t]-s[t];i=t.second.second,s=e.second.second;for(let t=0;t<3;++t)if(i[t]!==s[t])return i[t]-s[t];return 0}(t,e));let h=0;for(const t of o){if(1===r.getNumberOfSets()&&t.first!==h)break;n[t.second.first[0]]=n[t.second.first[1]]=n[t.second.first[2]]=1;const e=[t.second.second[0],t.second.second[1],t.second.second[2]];r.connectRange(e,0,3),h=t.first}return e&&(e[0]=.25*h),this.alphaShapeConstruct(t,n)}constructor(t,e,i,s){super(),this.m_multiPointForAttributes=null,this.m_inputGeometryCursor=null,this.m_index=-1,this.m_nDelaunayPoints=0,this.m_cDelaunay=new Y,this.m_vertexDescription=null,this.m_progressTracker=s,this.m_alpha=Number.isNaN(e)||!Number.isFinite(e)||e<0?-1:e<Number.MIN_VALUE?0:e,this.m_bMerge=i,this.m_bDone=!1,this.m_inputGeometryCursor=t,this.prepareDelaunay()}prepareDelaunay(){this.m_nDelaunayPoints=0,this.m_cDelaunay.clear(),0!==this.m_alpha&&this.m_cDelaunay.prepare(n())}next(){if(this.m_bMerge){if(!this.m_bDone){const t=this.calculateAlphaShapeMerging(this.m_inputGeometryCursor,this.m_progressTracker);return this.m_bDone=!0,t}return null}if(!this.m_bDone){const t=this.m_inputGeometryCursor.next();if(null!==t)return o(t),r(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.calculateAlphaShape(t,this.m_progressTracker);this.m_bDone=!0}return null}tock(){return!0}getRank(){return 1}getGeometryID(){return this.m_index}calculateAlphaShapeMerging(t,e){let i;for(;i=t.next();)o(i),r(i),this.addGeometry(i);return this.buildAlphaShape()}calculateAlphaShape(t,e){return t.isEmpty()?new f({vd:t.getDescription()}):(this.prepareDelaunay(),this.addGeometry(t),this.buildAlphaShape())}buildAlphaShape(t=null){if(t&&(t[0]=this.m_alpha),0===this.m_alpha)return this.m_vertexDescription?new f({vd:this.m_vertexDescription}):new f;if(this.m_cDelaunay.removeDuplicates())for(let t=0,e=this.m_cDelaunay.getPointCount();t<e;++t)this.m_cDelaunay.setPointIndex(this.m_cDelaunay.getPoint(t),t);return this.m_cDelaunay.construct()?this.m_alpha<0?this.alphaShapeAlphaOut(this.m_cDelaunay,t):this.alphaShape(this.m_cDelaunay,this.m_alpha):this.m_vertexDescription?new f({vd:this.m_vertexDescription}):new f}addGeometry(t){if(o(t),r(t),0===this.m_alpha)return;if(this.m_vertexDescription&&this.m_bMerge||(this.m_vertexDescription=t.getDescription(),this.m_vertexDescription.getAttributeCount()>1?this.m_multiPointForAttributes=new E({vd:this.m_vertexDescription}):this.m_multiPointForAttributes=null),t.isEmpty())return;const e=t.getGeometryType();if(h(e)){const e=t,i=new s;for(let t=0,s=e.getPointCount();t<s;t++)e.queryXY(t,i),this.m_cDelaunay.addVertex(i,this.m_nDelaunayPoints++);this.m_multiPointForAttributes&&this.m_multiPointForAttributes.addPoints(e,0,-1)}else if(e===d.enumPoint){const e=t,i=e.getXY();this.m_cDelaunay.addVertex(i,this.m_nDelaunayPoints++),this.m_multiPointForAttributes&&this.m_multiPointForAttributes.add(e)}else g("bad geometry type")}}const G=new class{getOperatorType(){return 10112}accelerateGeometry(t,e,i){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!1}executeMany(t,e,i,s){return new U(t,e,i,s)}execute(t,e,i,s=null){const n=new U(null,e,!1,i);return n.addGeometry(t),n.buildAlphaShape(s)}};function q(t,e){const i=_(t),s=[0],n=k(function(t,e,i){return G.execute(t,e,null,i)}(F(t),e,s),i);return{alphaShape:n,calculatedAlpha:s[0]}}function O(t,i,s={}){const{merge:n=!1}=s,o=t.map(F),r=_(t);return function(t,i,s){const n=G.executeMany(new e(t),i,s,null);return Array.from(n)}(o,i,n).map(t=>k(t,r))}const z=G.supportsCurves();export{q as execute,O as executeMany,z as supportsCurves};
