/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{S as e}from"../../chunks/SimpleGeometryCursor.js";import{l as t,p as r,i as o}from"../../chunks/pe.js";import"../../chunks/assets.js";import"../../config.js";import"../../core/lang.js";import"../../chunks/object.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../core/Error.js";import"../../chunks/Logger.js";import"../../chunks/string.js";import"../../chunks/jsonUtils.js";import"../../chunks/MapUtils.js";import"../../core/promiseUtils.js";import"../../chunks/handleUtils.js";import"../../chunks/events.js";import"../../chunks/maybe.js";import"../../chunks/persistableUrlUtils.js";let n,s,i,c,a,m,p,u,f,j,l,h,k;function g(){return!!n&&o()}async function T(){if(!g()){const[e,o]=await Promise.all([import("../../chunks/ProjectionTransformation.js").then(e=>e.bk),import("../../chunks/ProjectionTransformation.js").then(e=>e.bj).then(({injectPe:e})=>e),t()]);n=new e.OperatorProject,o(r)}}function x(){return!!i&&g()}async function E(){if(!x()){const[e,t,r,o]=await Promise.all([import("../../chunks/apiConverter.js"),import("../../chunks/ProjectionTransformation.js").then(e=>e.bl).then(({CompositeGeographicTransformationEditor:e})=>e),import("../../chunks/ProjectionTransformation.js").then(e=>e.bm).then(({create:e,createFromWKT:t})=>({create:e,createFromWKT:t})),import("../../chunks/ProjectionTransformation.js").then(e=>e.bn).then(({create:e,createEx:t,createFromAoi:r})=>({create:e,createEx:t,createFromAoi:r})),T()]);s=e.fromExtent,i=e.fromGeometry,c=e.fromSpatialReference,a=e.getSpatialReference,m=e.toGeometry,p=t,u=r.create,f=r.createFromWKT,j=o.createEx,l=o.createFromAoi,h=o.create,k=n.supportsCurves()}}function P(e,t,r={}){const o=w(a(e),t,r);return m(function(e,t){return n.execute(e,t,null)}(i(e),o),t)}function b(t,r,o={}){return function(t,r){const o=n.executeMany(new e(t),r,null);return Array.from(o)}(t.map(i),w(a(t),r,o)).map(e=>m(e,r))}function w(e,t,r={}){let o;const n=c(e),i=c(t);if(r?.geographicTransformation){const e=new p;e.setInputSpatialReference(n),e.setOutputSpatialReference(i);for(const t of r.geographicTransformation.steps){let r;r=t.wkid?u(t.wkid,t.isInverse):f(t.wkt,t.isInverse),e.add(r)}o=e.create()}else if(r?.areaOfInterestExtent)return l(n,i,s(r.areaOfInterestExtent).asEnvelope2D());return o?j(n,i,o):h(n,i)}export{P as execute,b as executeMany,x as isLoaded,E as load,k as supportsCurves};
