/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{V as t,c as e,m as s}from"../../chunks/unitUtils.js";import{G as r,S as n}from"../../chunks/SimpleGeometryCursor.js";import{K as i,a as o,D as a,b as u,E as m,m as l,P as c,f as h,X as p}from"../../chunks/Point2D.js";import{Envelope2D as _}from"../../chunks/Envelope2D.js";import{T as g}from"../../chunks/Transformation2D.js";import{a$ as f,b0 as y,b1 as d,b2 as x,b as T,K as E,b3 as A,E as v,n as k,P as j,b4 as N}from"../../chunks/ProjectionTransformation.js";import{P as S,b as w}from"../../chunks/Envelope.js";import{O as b}from"../../chunks/OperatorMultiPartToSinglePart.js";import{O as C}from"../../chunks/OperatorCut.js";import{getSpatialReference as P,fromSpatialReference as X,fromPolygon as H,toPolygon as Y}from"../../chunks/apiConverter.js";import"../../core/lang.js";import"../../chunks/jsonMap.js";import"../../chunks/object.js";import"../../chunks/string.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../config.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../core/Error.js";import"../../chunks/Logger.js";import"../../chunks/jsonUtils.js";import"../../chunks/MapUtils.js";import"../../core/promiseUtils.js";import"../../chunks/handleUtils.js";import"../../chunks/events.js";import"../../chunks/maybe.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/tslib.es6.js";import"../../chunks/OperatorDefinitions.js";import"../Extent.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/ensureType.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/jsonConverter.js";function O(t,e,s,r,n){return new J(n).findSlicesByArea(t,e,s,r)}function I(t,e,s,r,n){return new J(n).sliceIntoStrips(t,e,s,r)}function q(t,e,s,r){return new J(r).recursiveSliceEqualArea(t,e,s)}function M(t){this.currentX=this.calcX(t)}function R(t){if(null===this.curve){const e=(t-this.y0)/(this.y1-this.y0);return p(this.x0,this.x1,e)}return this.curve.intersectionOfYMonotonicWithAxisX(t,this.x0)}function D(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:M,calcX:R}}function U(t,e){const s=D();return s.x0=t.getStartX(),s.y0=t.getStartY(),s.x1=t.getEndX(),s.y1=t.getEndY(),e&&(s.y0=h(s.x0,s.x0=s.y0),s.y1=h(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=h(s.y0,s.y0=s.y1),s.x1=h(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function B(t){const e=D();return e.x0=t.getStartX(),e.y0=t.getStartY(),e.x1=t.getEndX(),e.y1=t.getEndY(),e.curve=t,e.y1<e.y0&&(e.y1=h(e.y0,e.y0=e.y1),e.x1=h(e.x0,e.x0=e.x1)),e.currentX=Number.NaN,e.nextAET=null,e.prevAET=null,e.startNodeNext=null,e.nextInChain=null,e}function V(t){if(this.x===t.x&&this.y===t.y){const e=null!==this.endEdge,s=null!==t.startEdge;return e&&s?-1:1}return this.y!==t.y?this.y-t.y:this.x-t.x}function z(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:V}}function L(t,e){return{y:t,startingEdges:e}}class G{constructor(t,e,s,r,n,i){this.m_parent=t,this.m_y0=e,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(t,e){return 1===t?0:this.getArea(e)-this.m_area}getError(t){return u(0),0}getArea(t){const e=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-e*(t+this.m_t0))*s*(t-this.m_t0),n=!1;for(let e=this.m_parent.m_AETHead;null!==e;e=e.nextAET)if(n=!n,n&&(null!==e.curve||null!==e.nextAET.curve)){const n=this.m_y0+s*this.m_t0,i=this.m_y0+s*t;e.curve&&(r+=F(e.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),e.nextAET.curve&&(r-=F(e.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),r+=(i-n)*(e.nextAET.calcX(n)-e.calcX(n)+(e.nextAET.calcX(i)-e.calcX(i)))*.5}return r}}function W(t,e,s){return{polygon:t,from:e,to:s}}function F(t,e,s){const r=[0,0],n=t.intersectionWithAxis2D(!0,e,null,r);u(1===n);const i=r[0],o=t.intersectionWithAxis2D(!0,s,null,r);u(1===o);const a=r[0],m=l(c,4);N(t,m,!0);const h=m[3],p=m[2],_=m[1],g=t.getCoordX(i)-t.getStartX(),f=t.getCoordY(i)-t.getStartY(),y=t=>{const e=t*t;return e*t*(10*(p.x*_.y-p.y*_.x)-15*t*(h.y*_.x-h.x*_.y)+6*e*(p.y*h.x-h.y*p.x))/60},d=t=>(-t*(_.y+t*(p.y+h.y*t))*g+t*(_.x+t*(p.x+h.x*t))*f)/2;return y(a)-y(i)-(d(a)-d(i))}class K extends r{constructor(t){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=t}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class J{constructor(t){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new i(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=t}findSlicesByArea(t,e,s,r){r<0&&o("remainingArea");let n=t,i=null;n.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,i=f(t,1e-16,!0),function(t){t.getImpl().ensureXYMonotoneSegments()}(i),n=i);const a=Math.abs(n.calculateArea2D());return 0===a||0===s||r>=a||1===s&&0===r?[]:(this.m_splitArea=(a-r)/s,this.m_numberOfCuts=s-1,r>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(n),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(t,e,s,r){if(0===r)return new n([t]);const i=new _;t.queryLooseEnvelope(i);const o=i.width()+i.height();return new K(this.splitPolygon(t,e,i.xmin-o-1+1,i.xmax+o+1,s,r))}recursiveSliceEqualArea(t,e,s){if(s<=1||t.isEmpty())return new n([t]);{const r=[],n=[];n.push(a(t.clone(),s));let i=0,o=0;for(;n.length>0;){u(o++<2*s);const t=n.at(-1);if(n.pop(),1===t.second){r.push(a(t.first,i++));continue}const m=new _;t.first.queryEnvelope(m);const l=m.width()+m.height(),c=new g;c.setIdentity(),m.width()>m.height()&&(c.setRotateCcw90(),t.first.applyTransformation(c),c.transformEnvInPlace(m));const h=t.first.calculateArea2D(),p=h/t.second,f=h-Math.trunc(t.second/2)*p,y=new J(this.m_progressTracker).findSlicesByArea(t.first,e,1,f),d=new J(this.m_progressTracker).splitPolygon(t.first,e,m.xmin-l-1+1,m.xmax+l+1,y,1),x=d.length;if(u(x>0&&x<=2),!c.isIdentity()){const t=new g;t.setRotateCw90(),d[0].first.applyTransformation(t),2===x&&d[1].first.applyTransformation(t)}2===x?(n.push(a(d[1].first,t.second-Math.trunc(t.second/2))),n.push(a(d[0].first,Math.trunc(t.second/2)))):n.push(a(d[0].first,t.second))}return new K(r)}}recursiveSliceEqualAreaImpl(t,e,s,r){return u(0),{}}processTraps(t,e,s){s?this.processTrapsCurves(t,e):this.processTrapsLinear(t,e)}processTrapsLinear(t,e){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),o=e-t,a=(this.m_sumBase-n*(r+s))*o*(r-s);if(a+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(a),void(this.m_areaTracking+=a);const u=new i(a),l=new m(0,1);let c=!1;for(;s<1;){const e=this.m_splitArea-this.m_areaTracking,i=[Number.NaN,Number.NaN];if(!(y(-n*o,this.m_sumBase*o,(n*s-this.m_sumBase)*o*s-e,l,!1,i)>0)){c?this.m_areaTracking=u.getResult():this.m_areaTracking+=a;break}{c=!0,r=i[0],this.m_areaTracking=0,s=r,u.me(e);const n=r*o+t;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+a-u.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(a-u.getResult())}}this.m_totalAreaOfTraps.pe(a)}processTrapsCurves(t,e){let s=0,r=1;const n=new G(this,t,e,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const o=e-t,a=new i(n);let u=!1;for(;s<1;){const i=this.m_splitArea-this.m_areaTracking,l=new G(this,t,e,s,1,i),c=[0],h=new m(s,1);if(!(d(l,h,1,c)>0)){u?this.m_areaTracking=a.getResult():this.m_areaTracking+=n;break}{u=!0,r=c[0],this.m_areaTracking=0,s=r,a.me(i);const e=r*o+t;if(this.m_cuts.push(e),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-a.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-a.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const t=this.m_sortedNodes[this.m_currentScan-1].y,e=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new i(0);for(let t=this.m_AETHead;null!==t;t=t.nextAET){const i=t.prevAET;s=!s,null!==t.nextAET&&s&&(this.m_bPolygonHasCurves&&(t.curve||t.nextAET.curve)||n.pe(t.nextAET.currentX-t.currentX)),t.advance(e.y),null!==i&&t.currentX<i.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const o=new i(0);s=!1;let a=!1;for(let t=this.m_AETHead;null!==t;t=t.nextAET)a=a||null!==t.curve,s=!s,null!==t.prevAET&&(s||this.m_bPolygonHasCurves&&(t.curve||t.prevAET.curve)||o.pe(t.currentX-t.prevAET.currentX));this.m_sumA=o.getResult(),this.processTraps(t,e.y,a);for(let t=this.m_AETHead;null!=t;){const s=t.prevAET,r=t.nextAET;if(e.y===t.y1)if(t.prevAET=null,t.nextAET=null,null!==t.nextInChain){const e=t.currentX;t=t.nextInChain,t.currentX=e,t.prevAET=s,s?s.nextAET=t:this.m_AETHead=t,t.nextAET=r,r&&(r.prevAET=t)}else s?s.nextAET=r:this.m_AETHead=r,r&&(r.prevAET=s);t=r}}mergeNewEdgesToAET(){for(let t=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==t;t=t.startNodeNext)Number.isNaN(t.currentX)&&(this.m_sortHelper.push(t),t.currentX=t.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let t=this.m_AETHead,e=0,s=t;for(;null!==t&&e<this.m_sortHelper.length;)t.currentX>this.m_sortHelper[e].currentX?(this.m_sortHelper[e].prevAET=t.prevAET,t.prevAET?t.prevAET.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=t,t.prevAET=this.m_sortHelper[e],e++):(s=t,t=t.nextAET);for(;e<this.m_sortHelper.length;)this.m_sortHelper[e].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=null,s=this.m_sortHelper[e],e++;this.m_sortHelper.length=0}sortAET(){for(let t=this.m_AETHead;null!==t;t=t.nextAET)this.m_sortHelper.push(t);this.sortHelper(),this.m_AETHead=null;let t=null;for(const e of this.m_sortHelper)e.prevAET=t,t?t.nextAET=e:this.m_AETHead=e,e.nextAET=null,t=e;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort((t,e)=>t.currentX-e.currentX)}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(t){const e=t.querySegmentIterator();for(e.stripAttributes();e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(t.isCurve()){const e=t;if(x(e),this.m_bHorizontalSweep){const t=l(c,4);e.queryControlPoints(t);for(const e of t)e.y=h(e.x,e.x=e.y);e.constructPoints(t)}const s=e.getStartY(),r=e.getEndY();if(r===s)continue;r<s&&e.reverse(),this.m_curves.push(e.clone()),this.m_edges.push(B(this.m_curves.at(-1)))}else{const e=this.m_bHorizontalSweep?t.getStartX():t.getStartY();if((this.m_bHorizontalSweep?t.getEndX():t.getEndY())===e)continue;this.m_edges.push(U(t,this.m_bHorizontalSweep))}}this.m_edges.sort((t,e)=>t.y0===e.y0?t.x0-e.x0:t.y0-e.y0)}buildScanNodes(){const t=[];for(const e of this.m_edges){const s=z();s.x=e.x0,s.y=e.y0,s.startEdge=e,s.endEdge=null,t.push(s);const r=z();r.x=e.x1,r.y=e.y1,r.startEdge=null,r.endEdge=e,t.push(r)}t.sort((t,e)=>t.compare(e));let e=0,s=t[e].y;this.m_sortedNodes.push(L(s,t[e].startEdge));let r=e;for(e++;e!==t.length;++e){t[e].y!==s&&(this.m_sortedNodes.push(L(t[e].y,null)),s=t[e].y);const n=t[e].startEdge;if(n){const t=this.m_sortedNodes.at(-1);n.startNodeNext=t.startingEdges,t.startingEdges=n}if(t[r].x!==t[e].x||t[r].y!==t[e].y){if(e-r===2){let e=r;e++,null!==t[r].endEdge&&null!==t[e].startEdge&&(t[r].endEdge.nextInChain=t[e].startEdge)}r=e}}}progress(){}splitPolygonLinear(t,e,s,r,i,o){const m=[];m.push([t,0,o]);const l=[],c=new T;for(c.startPathCoords(s,0),c.lineToCoords(r,0);m.length>0;){const h=m.at(-1);m.pop();const p=h[0],g=h[1],f=h[2],y=(new b).executeMany(new n([p]),e,this.m_progressTracker);for(let n=y.next();null!==n;n=y.next()){const h=n,p=new _;h.queryLooseEnvelope(p);let y=g,d=f;for(let t=g,e=f-1;t<f;++t,--e)p.ymin>=i[t]&&(y=t+1),p.ymax<=i[e]&&(d=e);if(y!==f)if(d!==g)if(y!==d)if(this.isYMonotone(h))this.splitYMonotone(l,h,e,i,y,d);else{const n=Math.trunc((y+d)/2);c.setXYCoords(0,s,i[n]),c.setXYCoords(1,r,i[n]);const g=(new C).execute(!1,h,c,null,this.m_progressTracker),f=g.next(),x=g.next(),T=g.next();if(null!==f){if(f.isEmpty()||(n===d-1?(l.push(a(f,n)),u($(l.at(-1).first,e,t,l.at(-1).second,i,o))):m.push([f,n+1,d])),x.isEmpty()||(n===y?(l.push(a(x,n-1)),u($(l.at(-1).first,e,t,l.at(-1).second,i,o))):m.push([x,y,n])),null!==T&&!T.isEmpty()){const t=new _;T.queryLooseEnvelope(t),t.ymin>=i[n]?m.push([T,n+1,d]):t.ymax<=i[n]?m.push([T,y,n]):m.push([T,y,d])}}else n+1===d?(i[n]-p.ymin<p.ymax-i[n]?l.push(a(h,n)):l.push(a(h,n+1)),u($(l.at(-1).first,e,t,l.at(-1).second,i,o))):m.push([h,n+1,d])}else l.push(a(n,y-1));else l.push(a(n,g-1));else l.push(a(n,f-1))}}return l}splitPolygon(t,e,s,r,n,i){const o=new _;t.queryLooseEnvelope(o),o.inflateCoords(0,Math.max(o.width(),o.height()));const u=[],m=[];for(m.push(W(t,0,i));m.length;){const i={...m.at(-1)};if(m.pop(),i.polygon.hasNonLinearSegments()){const t=Math.trunc((i.to+i.from)/2),l=n[t],c=new _(s,o.ymin,r,l),h=(new E).execute(i.polygon,c,e,this.m_progressTracker);h.isEmpty()||(t-i.from===0?u.push(a(h,t-1)):m.push(W(h,i.from,t)));const p=new _(s,l,r,o.ymax),g=(new E).execute(i.polygon,p,e,this.m_progressTracker);g.isEmpty()||(i.to-t===1?u.push(a(g,t)):m.push(W(g,t+1,i.to)))}else{const o=this.splitPolygonLinear(t,e,s,r,n.slice(i.from),i.to-i.from);u.push(...o)}}u.sort((t,e)=>t.second-e.second);const l=[];return A(u,(t,e)=>t.second===e.second,(t,e)=>{const s=new j;for(let r=t;r!==e;++r)s.add(u[r].first,!1);l.push(a(s,u[t].second))}),l}isYMonotone(t){if(1!==t.getPathCount())return!1;const e=t.getXY(0);let s=0,r=0;const n=new c;for(let i=1,o=t.getPointCount();i<=o;i++){t.queryXY(i===o?0:i,n);const a=n.y>e.y?1:n.y<e.y?-1:0;if(e.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(t,e,s,r,n,i){const o=new v;o.addGeometry(e);const m=o.getFirstPath(o.getFirstGeometry()),l=o.getFirstVertex(m),h=new c,p=new c;let _=l,g=l;{const t=o.getXY(l);h.setCoordsPoint2D(t),p.setCoordsPoint2D(t)}let f=o.getNextVertex(l);const y=new c;for(let t=0,e=o.getPathSize(m);t<e;t++,f=o.getNextVertex(f))o.queryXY(f,y),y.compare(h)<0?(_=f,h.setCoordsPoint2D(y)):y.compare(p)>0&&(g=f,p.setCoordsPoint2D(y));let d=_,x=_,T=d,E=x,A=!1,j=!1,N=n,S=h.y,w=h.y,b=!1;for(;N<i;)if(r[N]<=h.y)N++;else{if(r[N]>=p.y)break;if(!A){const t=o.getNextVertex(d),e=o.getY(t);if(e<S)break;const s=r[N];S<=s&&e>=s?A=!0:(S=e,d=t)}if(!j){const t=o.getPrevVertex(x),e=o.getY(t);if(e<w)break;const s=r[N];w<=s&&e>=s?j=!0:(w=e,x=t)}if(A&&j){b=!0;let e=o.getXY(d);const s=o.getNextVertex(d);let n=o.getXY(s),i=k;if(n.y===e.y)i=n.x<e.x?d:s;else{const t=(r[N]-e.y)/(n.y-e.y);if(0===t)i=d;else if(1===t)i=s;else{const e=o.splitSegmentAxisAware(d,[t],1,null,-1);u(1===e),i=o.getNextVertex(d),o.getY(i)!==r[N]&&o.setXYCoords(i,o.getX(i),r[N])}}const m=o.getPrevVertex(x);e=o.getXY(m),n=o.getXY(x);let l=k;if(n.y===e.y)l=n.x<e.x?x:m;else{const t=(r[N]-e.y)/(n.y-e.y);if(0===t)l=m;else if(1===t)l=x;else{const e=o.splitSegmentAxisAware(m,[t],1,null,-1);u(1===e),l=o.getNextVertex(m),o.getY(l)!==r[N]&&o.setXYCoords(l,o.getX(l),r[N])}}t.push(a(this.extractTrapezoid(o,T,i,E,l),N-1)),T=i,E=l,d=i,x=l,S=w=r[N],A=!1,j=!1,N++}}b?t.push(a(this.extractTrapezoid(o,T,g,E,g),N-1)):t.push(a(e,N))}extractTrapezoid(t,e,s,r,n){const i=new j({vd:t.getVertexDescription()}),o=new S;let a=!0;for(let r=e;;r=t.getNextVertex(r)){const e=t.getSegment(r);if(e?i.addSegment(e,a):(t.queryPoint(r,o),a?i.startPathPoint(o):i.lineToPoint(o)),a=!1,r===s)break}s!==n&&(t.queryPoint(n,o),i.lineToPoint(o)),a=!0;for(let s=n;;s=t.getNextVertex(s)){const n=t.getSegment(s);if(n?i.addSegment(n,a):a||s===e||(t.queryPoint(s,o),i.lineToPoint(o)),a=!1,s===r)break}return i}}function $(t,e,s,r,n,i){const o=new _;t.queryEnvelope(o);const a=4*w(e,s,!0).total();return!(r>=0&&!(o.ymin+a>=n[r])||r+1<i&&o.ymax>n[r+1]+a)}class Q extends r{constructor(t,e,s,r,n,i,o){super(),this.m_resultCursor=null,this.m_method=t,this.m_polygon=e,this.m_sr=s,this.m_ySplits=r?.slice()??null,this.m_transform=n,this.m_bReversePaths=n?.isReflective()??!1,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const t=this.m_resultCursor.next();return t?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(t.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&t.reverseAllPaths()),t):t}getGeometryID(){return this.m_resultCursor?this.m_resultCursor.getGeometryID():-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=I(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=I(t,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=q(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=q(t,this.m_sr,this.m_partCount,this.m_tracker)}}}const Z=new class{getOperatorType(){return 10011}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}sliceIntoStrips(t,e,s,r,n,i){return new Q(0,t,e,s,n,0,i)}findSlicesByArea(t,e,s,r,n,i){if(!n||n.isIdentity())return O(t,e,s,r,i);{const o=t.clone();return o.applyTransformation(n),O(o,e,s,r,i)}}recursiveSliceEqualArea(t,e,s,r,n){return new Q(1,t,e,null,r,s,n)}};function tt(r,n,i,o={}){const{transform:a,unit:u}=o,m=P(r);if(i&&u){if(m.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const r=t(m);r!==u&&(r?i=e(i,u,r):(i=e(i,u,"square-meters"),i=Math.sqrt(i),i/=s(m),i**=2))}return function(t,e,s,r,n){return Z.findSlicesByArea(t,e,s,r,n,null)}(H(r),X(m),n,i,a?.transform??null)}function et(t,e,s={}){const{transform:r}=s,n=P(t);return function(t,e,s,r){const n=Z.recursiveSliceEqualArea(t,e,s,r,null);return Array.from(n)}(H(t),X(n),e,r?.transform??null).map(t=>Y(t,n))}function st(t,e,s={}){const{transform:r}=s,n=P(t);return function(t,e,s,r){const n=Z.sliceIntoStrips(t,e,s,0,r,null);return Array.from(n)}(H(t),X(n),e,r?.transform??null).map(t=>Y(t,n))}const rt=Z.supportsCurves();export{tt as findSlicesByArea,et as recursiveSliceEqualArea,st as sliceIntoStrips,rt as supportsCurves};
