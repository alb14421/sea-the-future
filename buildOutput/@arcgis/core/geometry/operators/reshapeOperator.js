/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{t,H as e,G as s,p as r}from"../../chunks/Point2D.js";import{b as n,S as a,P as i,d as o}from"../../chunks/ProjectionTransformation.js";import{Envelope2D as m}from"../../chunks/Envelope2D.js";import{c,P as h}from"../../chunks/Envelope.js";import{getSpatialReference as u,fromGeometry as l,fromPolyline as p,fromSpatialReference as g,toGeometry as d}from"../../chunks/apiConverter.js";import"../../chunks/Transformation2D.js";import"../../chunks/SimpleGeometryCursor.js";import"../../chunks/tslib.es6.js";import"../../chunks/OperatorDefinitions.js";import"../Extent.js";import"../../chunks/string.js";import"../../chunks/object.js";import"../../core/lang.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/Logger.js";import"../../config.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/jsonConverter.js";class _{constructor(t){this.m_progressTracker=t,this.clearIndicesAndScalars()}setIndicesAndScalars(t,e,r){const n=new m,a=new m;if(t.queryEnvelope(n),t.queryEnvelope(a),n.inflateCoords(r,r),!n.intersect(a))return!1;const i=t.getImpl().querySegmentIterator(),o=e.getImpl().querySegmentIterator(),c=[0,0],h=[0,0];let u=-1,l=-1,p=-1,g=-1,d=-1,_=-1,x=Number.NaN,A=Number.NaN,S=Number.NaN,j=Number.NaN;for(o.nextPath();o.hasNextSegment();){const t=o.nextSegment(),e=new m;for(t.queryEnvelope(e),e.inflateCoords(r,r),i.resetToFirstPath();i.nextPath();){for(;i.hasNextSegment();){const s=i.nextSegment(),n=new m;if(s.queryEnvelope(n),e.isIntersecting(n)&&0!==t.intersect(s,null,h,c,r)&&(Number.isNaN(S)||h[0]<S)&&(u=i.getPathIndex(),p=i.getStartPointIndex(),d=o.getStartPointIndex(),x=c[0],S=h[0],0===S))break}if(0===S)break}if(!Number.isNaN(S)&&1!==S)break}if(Number.isNaN(S))return!1;this.m_pathA0=u,this.m_vertexA0=p,this.m_vertexB0=d,this.m_scalarA0=x,this.m_scalarB0=S;const y=t.getGeometryType();for(o.resetToLastSegment();o.hasPreviousSegment();){const t=o.previousSegment(),e=new m;for(t.queryEnvelope(e),e.inflateCoords(r,r),y===s.enumPolygon?i.resetToPath(u):i.resetToFirstPath();i.nextPath();){for(;i.hasNextSegment();){const s=i.nextSegment(),n=new m;if(s.queryEnvelope(n),e.isIntersecting(n)){const e=t.intersect(s,null,h,c,r);if(0!==e&&(Number.isNaN(j)||h[e-1]>j)&&(o.getStartPointIndex()!==this.m_vertexB0||h[e-1]!==this.m_scalarB0)&&(l=i.getPathIndex(),g=i.getStartPointIndex(),_=o.getStartPointIndex(),A=c[e-1],j=h[e-1],1===j))break}}if(1===j)break;if(y===s.enumPolygon)break}if(!Number.isNaN(j))break}return!Number.isNaN(j)&&(this.m_pathA1=l,this.m_vertexA1=g,this.m_vertexB1=_,this.m_scalarA1=A,this.m_scalarB1=j,!0)}getTrimmedPolyline(t,e){const s=new a,r=e.createInstance();let n=!0;const i=e.getImpl().querySegmentIterator();if(i.resetToVertex(this.m_vertexB0,0),this.m_vertexB0>this.m_vertexB1)return r;if(this.m_vertexB0===this.m_vertexB1)i.nextSegment().queryCut(this.m_scalarB0,this.m_scalarB1,s,!1),r.addSegment(s.get(),!0);else for(;;){const t=i.nextSegment(),e=i.getStartPointIndex();if(e===this.m_vertexB0)1!==this.m_scalarB0&&(t.queryCut(this.m_scalarB0,1,s,!1),r.addSegment(s.get(),n),n=!1);else{if(e===this.m_vertexB1){0!==this.m_scalarB1&&(t.queryCut(0,this.m_scalarB1,s),r.addSegment(s.get(),n),n=!1);break}r.addSegment(t,n)}}if(r.isEmpty())return r;if(t.getDescription().getAttributeCount()>1){const e=t.getImpl().querySegmentIterator(),s=new h,n=r.getPointCount();e.resetToVertex(this.m_vertexA0,this.m_pathA0),e.nextSegment().queryCoord(this.m_scalarA0,s),r.setPointByVal(0,s),e.resetToVertex(this.m_vertexA1,this.m_pathA1),e.nextSegment().queryCoord(this.m_scalarA1,s),r.setPointByVal(n-1,s),r.interpolateAttributesRange(0,0,0,n-1)}return r}getReshapedMultiPath(t,e,r){let n;return n=t.getGeometryType()===s.enumPolygon?this.getReshapedPolygon(t,e,r):this.getReshapedPolyline(t,e),n}getReshapedPolygon(t,e,s){const r=t.getImpl().querySegmentIterator();r.setCirculator(!0);const n=new a;new h;const m=new i({vd:t.getDescription()});if(m.addSegmentsFromPath(e,0,0,e.getSegmentCountPath(0),!0),r.resetToVertex(this.m_vertexA1,this.m_pathA0),this.m_vertexA1===this.m_vertexA0&&this.m_scalarA1<=this.m_scalarA0)r.nextSegment().queryCut(this.m_scalarA1,this.m_scalarA0,n),m.addSegment(n.get(),!1);else{{const t=r.nextSegment();1!==this.m_scalarA1&&(t.queryCut(this.m_scalarA1,1,n),m.addSegment(n.get(),!1))}for(;;){const t=r.nextSegment();if(r.getStartPointIndex()===this.m_vertexA0){0!==this.m_scalarA0&&(t.queryCut(0,this.m_scalarA0,n),m.addSegment(n.get(),!1));break}m.addSegment(t,!1)}}const c=new i({vd:t.getDescription()}),u=e.clone();if(u.reversePath(0),c.addSegmentsFromPath(u,0,0,u.getSegmentCountPath(0),!0),r.resetToVertex(this.m_vertexA0,this.m_pathA0),this.m_vertexA0===this.m_vertexA1&&this.m_scalarA0<this.m_scalarA1)r.nextSegment().queryCut(this.m_scalarA0,this.m_scalarA1,n),c.addSegment(n.get(),!1);else{{const t=r.nextSegment();1!==this.m_scalarA0&&(t.queryCut(this.m_scalarA0,1,n),c.addSegment(n.get(),!1))}for(;;){const t=r.nextSegment();if(r.getStartPointIndex()===this.m_vertexA1){0!==this.m_scalarA1&&(t.queryCut(0,this.m_scalarA1,n),c.addSegment(n.get(),!1));break}c.addSegment(t,!1)}}const l=Math.abs(m.calculateArea2D()),p=Math.abs(c.calculateArea2D());let g=t.createInstance();for(let e=0;e<t.getPathCount();e++)e===this.m_pathA0?l>=p?g.add(m,!1):g.add(c,!1):g.addPath(t,e,!0);return g=(new o).execute(g,s,!1,this.m_progressTracker),g}getReshapedPolyline(t,e){const s=t.getImpl().querySegmentIterator(),i=new n,o=new a;let m=!1,c=-1,h=Number.NaN;m=this.m_pathA0>this.m_pathA1||this.m_pathA0===this.m_pathA1&&(this.m_vertexA0>this.m_vertexA1||this.m_vertexA0===this.m_vertexA1&&this.m_scalarA0>this.m_scalarA1),m?(c=this.m_vertexA1,h=this.m_scalarA1,s.resetToPath(this.m_pathA1)):(c=this.m_vertexA0,h=this.m_scalarA0,s.resetToPath(this.m_pathA0));let u=!0;for(s.nextPath()||r("reshaper");;){const t=s.nextSegment();if(s.getStartPointIndex()===c){0!==h&&(t.queryCut(0,h,o),i.addSegment(o.get(),u),u=!1);break}i.addSegment(t,u),u=!1}if(m){const t=e.clone();t.reversePath(0),i.addSegmentsFromPath(t,0,0,t.getSegmentCount(),u)}else i.addSegmentsFromPath(e,0,0,e.getSegmentCount(),u);m?(h=this.m_scalarA0,s.resetToVertex(this.m_vertexA0,this.m_pathA0)):(h=this.m_scalarA1,s.resetToVertex(this.m_vertexA1,this.m_pathA1));{const t=s.nextSegment();1!==h&&(t.queryCut(h,1,o),i.addSegment(o.get(),!1))}for(;s.hasNextSegment();){const t=s.nextSegment();i.addSegment(t,!1)}const l=t.createInstance();let p=!1;for(let e=0;e<t.getPathCount();e++)e===this.m_pathA0||e===this.m_pathA1?p||(l.add(i,!1),p=!0):l.addPath(t,e,!0);return l}clearIndicesAndScalars(){this.m_pathA0=-1,this.m_pathA1=-1,this.m_vertexA0=-1,this.m_vertexA1=-1,this.m_vertexB0=-1,this.m_vertexB1=-1,this.m_scalarA0=Number.NaN,this.m_scalarA1=Number.NaN,this.m_scalarB0=Number.NaN,this.m_scalarB1=Number.NaN}}const x=new class{getOperatorType(){return 10006}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!1}execute(r,a,i,o){return function(r,a,i,o){if(a.getPathCount()>1&&t(""),r.isEmpty()||a.isEmpty())return null;e(r),e(a);let h=null;const u=new m;r.queryEnvelope(u);const l=new m;a.queryEnvelope(l);const p=new m;p.setCoords({env2D:u}),p.mergeEnvelope2D(l);const g=c(i,p,!1).total(),d=new _(o);let x=d.setIndicesAndScalars(r,a,g);if(x){const t=d.getTrimmedPolyline(r,a);if(t.isEmpty())return null;h=d.getReshapedMultiPath(r,t,i)}else{if(Number.isNaN(d.m_scalarB0)||r.getGeometryType()===s.enumPolyline)return null;const t=new n;if(t.add(a,!0),d.clearIndicesAndScalars(),x=d.setIndicesAndScalars(r,t,g),!x)return null;const e=d.getTrimmedPolyline(r,t);if(e.isEmpty())return null;h=d.getReshapedMultiPath(r,e,i)}return h}(r,a,i,o)}};function A(t,e){const s=u(t),r=x.execute(l(t),p(e),g(s),null);return d(r,s)}const S=x.supportsCurves();export{A as execute,S as supportsCurves};
