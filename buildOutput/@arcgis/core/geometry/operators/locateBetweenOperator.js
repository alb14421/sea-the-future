/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{v as t,G as e,a as s,h as r,o as n,p as o,E as i,f as u}from"../../chunks/Point2D.js";import{G as c,S as m}from"../../chunks/SimpleGeometryCursor.js";import{V as l,P as p}from"../../chunks/Envelope.js";import{au as a,M as h,S as j,b as g,aT as d}from"../../chunks/ProjectionTransformation.js";import{fromGeometry as k,getSpatialReference as y,toGeometry as _}from"../../chunks/apiConverter.js";import"../../chunks/Envelope2D.js";import"../../chunks/Transformation2D.js";import"../../chunks/tslib.es6.js";import"../../chunks/OperatorDefinitions.js";import"../Extent.js";import"../../chunks/string.js";import"../../chunks/object.js";import"../../core/lang.js";import"../../core/accessorSupport/decorators/property.js";import"../../chunks/Logger.js";import"../../config.js";import"../../chunks/ensureType.js";import"../../chunks/MapUtils.js";import"../../chunks/get.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/metadata.js";import"../../core/Error.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/Lifecycle.js";import"../../chunks/tracking.js";import"../../chunks/Warning.js";import"../Geometry.js";import"../../core/JSONSupport.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/watch.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../core/promiseUtils.js";import"../../chunks/events.js";import"../../chunks/SetUtils.js";import"../../chunks/SimpleTrackingTarget.js";import"../../chunks/reader.js";import"../SpatialReference.js";import"../../chunks/unitUtils.js";import"../../chunks/jsonMap.js";import"../../chunks/pe.js";import"../../chunks/assets.js";import"../../request.js";import"../../kernel.js";import"../../core/urlUtils.js";import"../../chunks/jsonUtils.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/writer.js";import"../Point.js";import"../../core/accessorSupport/decorators/cast.js";import"../support/webMercatorUtils.js";import"../Multipoint.js";import"../../chunks/zmUtils.js";import"../Polygon.js";import"../../chunks/coordsUtils.js";import"../../chunks/extentUtils.js";import"../../chunks/boundsUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../Polyline.js";import"../../chunks/jsonConverter.js";class b{constructor(t,e,r,n){this.m_interval=r,this.m_progressTracker=n,this.m_attribute=t,this.m_ord=e,(l.getComponentCount(this.m_attribute)<=e||e<0)&&s("LocateBetween: ordinate"),2===l.getInterpolation(this.m_attribute)&&s("LocateBetween: angular interpolation")}processGeometry(t){const i=t.getGeometryType();if(i===e.enumGeometryCollection)return this.processGeometryCollection(t);if(r(i)&&s("LocateBetween does not support Polygons and Envelopes."),t.isEmpty()||!t.hasAttribute(this.m_attribute))return new p({vd:t.getDescription()});if(n(i))return this.processSegment(t);switch(i){case e.enumPoint:return this.processPoint(t);case e.enumMultiPoint:return this.processMultiPoint(t);case e.enumPolyline:return this.processPolyline(t);default:o("LocateBetween")}}processPoint(t){const e=t.getAttributeAsDbl(this.m_attribute,this.m_ord);return this.m_interval.containsCoordinate(e)?new h({point:t}):new p({vd:t.getDescription()})}processMultiPoint(t){let e=null,s=-1;const r=t.getAttributeStreamRef(this.m_attribute),n=l.getComponentCount(this.m_attribute);for(let o=0,i=0,u=t.getPointCount();o<u;++o,i+=n){const n=r.readAsDbl(i);this.m_interval.containsCoordinate(n)?-1===s&&(s=o):s>=0&&(e||(e=new h({vd:t.getDescription()})),e.addPoints(t,s,o),s=-1)}return s>=0&&(e||(e=new h({vd:t.getDescription()})),e.addPoints(t,s,-1)),e||new p({vd:t.getDescription()})}processPolyline(t){const s=t.queryInterval(this.m_attribute,this.m_ord);if(this.m_interval.contains(s))return t;if(!this.m_interval.isIntersecting(s))return new p({vd:t.getDescription()});let r=null,n=null;const o=t.querySegmentIterator(),i=new j,u=new p,c=new p,m=new p;let l=!0,a=!1;for(;o.nextPath();)for(l=!0,a=!1;o.hasNextSegment();){const t=o.nextSegment(),s=[null],p=this.processSegmentHelper(t,i,s,u);if(p!==e.enumUnknown)if(p===e.enumPoint){if(!l&&(n.getPointByVal(n.getPointCount()-1,c),c.equals(u)))continue;if(l=!0,a&&(t.queryStart(c),u.equals(c)))continue;t.queryEnd(c),a=u.equals(c),r?r.add(u):r=new h({point:u})}else p===e.enumLine&&(a=!1,n||(n=new g),l&&(null===r||r.isEmpty()||(r.getPointByVal(r.getPointCount()-1,c),s[0].queryStart(u),c.equals(u)&&r.removePoint(r.getPointCount()-1))),n.addSegment(s[0],l),t.queryEnd(c),s[0].queryEnd(m),l=!c.equals(m));else l=!0,a=!1}if(null!==r&&r.isEmpty()&&(r=null),null!==r&&null!==n){const t=new d;return t.addGeometry(n),t.addGeometry(r),t}return null!==r?r:null!==n?n:new p({vd:t.getDescription()})}processSegment(t){const e=t.getAttributeAsDbl(0,this.m_attribute,this.m_ord),s=t.getAttributeAsDbl(1,this.m_attribute,this.m_ord),r=Number.isNaN(e)?s:e,n=Number.isNaN(s)?e:s,o=new i;o.setCoords(r,n);const c=o.clone();if(c.intersect(this.m_interval),c.isEmpty())return new p({vd:t.getDescription()});if(o.equals(c))return t;const m=n-r,l=t.calculateLength2D();if(0===c.width()){const e=new p({vd:t.getDescription()}),s=(c.vmin-r)/m,n=t.lengthToT(s*l);return t.queryCoord(n,e),e}let a=(c.vmin-r)/m,h=(c.vmax-r)/m;return a>h&&(h=u(a,a=h)),a=t.lengthToT(a*l),h=t.lengthToT(h*l),t.cut(a,h)}processGeometryCollection(t){if(t.isEmpty()||!t.hasAttribute(this.m_attribute))return new p({vd:t.getDescription()});const e=a(t),s=new d;for(let t=e.next();null!==t;t=e.next()){const e=this.processGeometry(t);e.isEmpty()||s.addGeometry(e)}return s.isEmpty()?new p({vd:t.getDescription()}):s}processSegmentHelper(t,s,r,n){const o=t.getAttributeAsDbl(0,this.m_attribute,this.m_ord),c=t.getAttributeAsDbl(1,this.m_attribute,this.m_ord),m=Number.isNaN(o)?c:o,l=Number.isNaN(c)?o:c,p=new i;p.setCoords(m,l);const a=p.clone();if(a.intersect(this.m_interval),a.isEmpty())return e.enumUnknown;if(p.equals(a))return r[0]=t,e.enumLine;const h=l-m,j=t.calculateLength2D();if(0===a.width()){const s=(a.vmin-m)/h,r=1===s?1:t.lengthToT(s*j);return t.queryCoord(r,n),e.enumPoint}let g=(a.vmin-m)/h,d=(a.vmax-m)/h;return g>d&&(d=u(g,g=d)),g=1===g?1:t.lengthToT(g*j),d=1===d?1:t.lengthToT(d*j),t.queryCut(g,d,s),r[0]=s.get(),e.enumLine}}class f extends c{constructor(t,e,s){super(),this.m_collectionCursor=null,this.m_interval=e,this.m_progressTracker=s,this.m_inputGeoms=t,this.m_index=-1}tock(){return!0}getRank(){return 1}next(){if(this.m_collectionCursor){const t=this.m_collectionCursor.next();if(t)return t;this.m_collectionCursor=null}const s=this.m_inputGeoms.next();if(null===s)return null;t(s),this.m_index=this.m_inputGeoms.getGeometryID();const r=(n=s,o=this.m_interval,i=this.m_progressTracker,new b(2,0,o,i).processGeometry(n));var n,o,i;return r.getGeometryType()===e.enumGeometryCollection?(this.m_collectionCursor=a(r),this.m_collectionCursor.next()):r}getGeometryID(){return this.m_index}}const v=new class{getOperatorType(){return 10801}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s){return new f(t,e,s)}};function w(t,e,s){const r=t.map(k),n=y(t);return function(t,e){const s=v.executeMany(new m(t),e,null);return Array.from(s)}(r,new i(e,s)).map(t=>_(t,n))}const C=v.supportsCurves();export{w as executeMany,C as supportsCurves};
