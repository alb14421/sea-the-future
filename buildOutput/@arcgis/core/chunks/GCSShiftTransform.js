/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{e as t}from"./enumeration.js";import{r as o}from"./reader.js";import{subclass as s}from"../core/accessorSupport/decorators/subclass.js";import{w as n}from"./writer.js";import i from"../geometry/Extent.js";import f from"../geometry/Point.js";import{JSONSupport as a}from"../core/JSONSupport.js";let l=class extends a{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};var p;function c(e,r,t){const{x:o,y:s}=r;if(t<2)return{x:e[0]+o*e[2]+s*e[4],y:e[1]+o*e[3]+s*e[5]};if(2===t){const r=o*o,t=s*s,n=o*s;return{x:e[0]+o*e[2]+s*e[4]+r*e[6]+n*e[8]+t*e[10],y:e[1]+o*e[3]+s*e[5]+r*e[7]+n*e[9]+t*e[11]}}const n=o*o,i=s*s,f=o*s,a=n*o,l=n*s,p=o*i,c=s*i;return{x:e[0]+o*e[2]+s*e[4]+n*e[6]+f*e[8]+i*e[10]+a*e[12]+l*e[14]+p*e[16]+c*e[18],y:e[1]+o*e[3]+s*e[5]+n*e[7]+f*e[9]+i*e[11]+a*e[13]+l*e[15]+p*e[17]+c*e[19]}}function m(e,r,t){const{xmin:o,ymin:s,xmax:n,ymax:f,spatialReference:a}=r;let l=[];if(t<2)l.push({x:o,y:f}),l.push({x:n,y:f}),l.push({x:o,y:s}),l.push({x:n,y:s});else{let e=10;for(let r=0;r<e;r++)l.push({x:o,y:s+(f-s)*r/(e-1)}),l.push({x:n,y:s+(f-s)*r/(e-1)});e=8;for(let r=1;r<=e;r++)l.push({x:o+(n-o)*r/e,y:s}),l.push({x:o+(n-o)*r/e,y:f})}l=l.map(r=>c(e,r,t));const p=l.map(e=>e.x),m=l.map(e=>e.y);return new i({xmin:Math.min.apply(null,p),xmax:Math.max.apply(null,p),ymin:Math.min.apply(null,m),ymax:Math.max.apply(null,m),spatialReference:a})}e([r()],l.prototype,"affectsPixelSize",null),e([r({json:{write:!0}})],l.prototype,"spatialReference",void 0),l=e([s("esri.layers.support.rasterTransforms.BaseRasterTransform")],l);let u=p=class extends l{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,r){const{coeffX:t,coeffY:o}=r;if(!t?.length||!o?.length||t.length!==o.length)return null;const s=[];for(let e=0;e<t.length;e++)s.push(t[e]),s.push(o[e]);return s}writeForwardCoefficients(e,r,t){const o=[],s=[];for(let r=0;r<e?.length;r++)r%2==0?o.push(e[r]):s.push(e[r]);r.coeffX=o,r.coeffY=s}get inverseCoefficients(){let e=this._get("inverseCoefficients");const r=this._get("forwardCoefficients");return!e&&r&&this.polynomialOrder<2&&(e=function(e){const[r,t,o,s,n,i]=e,f=o*i-n*s,a=n*s-o*i;return[(n*t-r*i)/f,(o*t-r*s)/a,i/f,s/a,-n/f,-o/a]}(r)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,r){const{inverseCoeffX:t,inverseCoeffY:o}=r;if(!t?.length||!o?.length||t.length!==o.length)return null;const s=[];for(let e=0;e<t.length;e++)s.push(t[e]),s.push(o[e]);return s}writeInverseCoefficients(e,r,t){const o=[],s=[];for(let r=0;r<e?.length;r++)r%2==0?o.push(e[r]):s.push(e[r]);r.inverseCoeffX=o,r.inverseCoeffY=s}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const r=c(this.forwardCoefficients,e,this.polynomialOrder);return new f({x:r.x,y:r.y,spatialReference:e.spatialReference})}return m(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const r=c(this.inverseCoefficients,e,this.polynomialOrder);return new f({x:r.x,y:r.y,spatialReference:e.spatialReference})}return m(this.inverseCoefficients,e,this.polynomialOrder)}clone(){return new p({polynomialOrder:this.polynomialOrder,forwardCoefficients:this.forwardCoefficients?[...this.forwardCoefficients]:null,inverseCoefficients:this.inverseCoefficients?[...this.inverseCoefficients]:null})}};var y;e([r({json:{write:!0}})],u.prototype,"polynomialOrder",void 0),e([r()],u.prototype,"forwardCoefficients",void 0),e([o("forwardCoefficients",["coeffX","coeffY"])],u.prototype,"readForwardCoefficients",null),e([n("forwardCoefficients")],u.prototype,"writeForwardCoefficients",null),e([r({json:{write:!0}})],u.prototype,"inverseCoefficients",null),e([o("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],u.prototype,"readInverseCoefficients",null),e([n("inverseCoefficients")],u.prototype,"writeInverseCoefficients",null),e([r()],u.prototype,"affectsPixelSize",null),e([t({PolynomialXform:"polynomial"})],u.prototype,"type",void 0),u=p=e([s("esri.layers.support.rasterTransforms.PolynomialTransform")],u);let h=y=class extends l{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(e){return"point"===(e=e.clone()).type?(e.x>180+this.tolerance&&(e.x-=360),e):(e.xmin>=180-this.tolerance?(e.xmax-=360,e.xmin-=360):e.xmax>180+this.tolerance&&(e.xmin=-180,e.xmax=180),e)}inverseTransform(e){return"point"===(e=e.clone()).type?(e.x<-this.tolerance&&(e.x+=360),e):(e.xmin<-this.tolerance&&(e.xmin+=360,e.xmax+=360),e)}clone(){return new y({tolerance:this.tolerance})}};e([t({GCSShiftXform:"gcs-shift"})],h.prototype,"type",void 0),e([r()],h.prototype,"tolerance",void 0),h=y=e([s("esri.layers.support.rasterTransforms.GCSShiftTransform")],h);export{l as B,h as G,u as P};
