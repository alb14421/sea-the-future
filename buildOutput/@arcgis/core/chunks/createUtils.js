/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{i as t,clone as e,e as o}from"../core/lang.js";import{m as a,A as n}from"./unitUtils.js";import{m as r}from"./vec3.js";import{c as l}from"./vec3f64.js";import s from"../geometry/Circle.js";import i from"../geometry/Multipoint.js";import c from"../geometry/Point.js";import p from"../geometry/Polygon.js";import y from"../geometry/Polyline.js";import{execute as u}from"../geometry/operators/distanceOperator.js";import{isSimple as m,execute as f}from"../geometry/operators/simplifyOperator.js";import{u as x,i as h,d as M}from"./coordsUtils.js";import{m as g}from"./surfaceCoordinateSystems.js";function d(t,e){const o=new c({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(o.z=t[2]),o}function R(t,e){return new i({points:t,spatialReference:e})}function T(t,e,o){const a=new y({paths:t,spatialReference:e});return o&&M(a),a}function j(t,a,r,l=!0){const s=e(t);s.forEach(t=>{const e=t[0],a=t[t.length-1];o(e,a)&&1!==t.length||t.push(t[0])});let i=new p({rings:s,spatialReference:a});return i.rings.forEach(t=>{h(t)||t.reverse()}),r&&M(i),l&&!m(i)&&n(a)&&(i=f(i)||i),i}function b(e,o,a){const n=o.mapToLocalMultiple(e),r=[],l={x:n[0].x,y:n[0].y},s=n[1].x,i=n[1].y,c=Math.round(s-l.x),p=Math.round(i-l.y),y=Math.max(Math.abs(c),Math.abs(p));if(a){const t={x:l.x+y,y:l.y+y},e={x:l.x-y,y:l.y-y};r.push(g(t.x,e.y),g(e.x,e.y),g(e.x,t.y),g(t.x,t.y))}else{const t={x:c>0?l.x+y:l.x-y,y:p>0?l.y+y:l.y-y};r.push(g(l.x,l.y),g(t.x,l.y),g(t.x,t.y),g(l.x,t.y))}return U(j([r.map(t=>o.localToMap(t)).filter(t)],o.spatialReference,o.doUnnormalization,!0),r,o)}function P(e,o,a){let n=o.mapToLocalMultiple(e);if(1===n.length){const t=48,e=n[0];n=[g(e.x-t,e.y+t),g(e.x+t,e.y-t),g(e.x+t,e.y-t),g(e.x-t,e.y+t)]}const r=[],l={x:n[0].x,y:n[0].y},s={x:n[1].x,y:n[1].y};if(a){const t=Math.round(s.x-l.x),e=Math.round(s.y-l.y);r.push(g(l.x-t,l.y-e),g(s.x,l.y-e),g(s.x,s.y),g(l.x-t,s.y))}else r.push(g(l.x,l.y),g(s.x,l.y),g(s.x,s.y),g(l.x,s.y));return U(j([r.map(t=>o.localToMap(t)).filter(t)],o.spatialReference,o.doUnnormalization,!0),r,o)}function U(t,e,o){const a=z(e[3],e[2],o),n=z(e[1],e[2],o),r=z(e[0],e[1],o),l=z(e[0],e[3],o);return{geometry:t,midpoints:null!=a&&null!=n&&null!=r&&null!=l?{top:a,right:n,bottom:r,left:l}:null}}function z(t,e,o){I[0]=t.x,I[1]=t.y,I[2]=0,L[0]=e.x,L[1]=e.y,L[2]=0,r(I,I,L,.5),w.x=I[0],w.y=L[1],w.z=L[2];const a=o.localToMap(w);return null!=a?d(a,o.spatialReference):null}const w=g(0,0,0),I=l(),L=l();function v(t,e,o,r){const l=e.mapToLocalMultiple(t);let i=null,c=null;if(o)i=l[0],c=l[1];else{const t=l[0],e=l[1],o=Math.round(e.x-t.x),a=Math.round(e.y-t.y),n=Math.max(Math.abs(o),Math.abs(a));i=g(o>0?t.x+n/2:t.x-n/2,a>0?t.y+n/2:t.y-n/2),c=g(Math.abs(o)>Math.abs(a)?i.x-n/2:i.x,Math.abs(o)>Math.abs(a)?i.y:i.y-n/2)}const p=e.localToMap(i),y=e.localToMap(c);if(null==p||null==y)return null;e.doUnnormalization&&x([[p,y]],e.spatialReference);const m=d(p,e.spatialReference),f=d(y,e.spatialReference),h=a(e.spatialReference);let M=0;if(n(e.spatialReference))M=h*u(m,f);else{const t=i.x-c.x,e=i.y-c.y;M=h*Math.sqrt(t*t+e*e)*(r||1)}const R=new s({center:m,radius:M,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:j(R.rings,R.spatialReference,!1),center:m,edge:f}}function C(e,o,a){const n=o.mapToLocalMultiple(e),r=n[0],l=n[1],s=Math.round(l.x-r.x),i=Math.round(l.y-r.y),c=g(a?r.x:r.x+s/2,a?r.y:r.y+i/2),p=a?s:s/2,y=a?i:i/2,u=[],m=2*Math.PI/60;function f(t){const e=Math.cos(t),o=Math.sin(t);return g(p*e+c.x,y*o+c.y)}for(let t=0;t<60;t++)u.push(f(t*m));u.push(u[0]);const{spatialReference:x,doUnnormalization:h}=o,M=j([u.map(t=>o.localToMap(t)).filter(t)],x,h,!1),R=o.localToMap(f(Math.PI/2)),T=o.localToMap(f(0)),b=o.localToMap(f(-Math.PI/2)),P=o.localToMap(f(Math.PI));return{geometry:M,midpoints:null!=R&&null!=T&&null!=b&&null!=P?{top:d(R,x),right:d(T,x),bottom:d(b,x),left:d(P,x)}:null}}export{b as a,C as b,v as c,P as d,T as e,j as f,R as g};
