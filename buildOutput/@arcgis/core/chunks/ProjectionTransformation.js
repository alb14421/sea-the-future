/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{Envelope2D as t}from"./Envelope2D.js";import{z as e,a as s,b as n,_ as i,E as r,G as o,a5 as a,r as h,a3 as m,P as l,a2 as u,n as c,e as g,a4 as d,a6 as _,f as p,t as f,a7 as x,M as y,p as P,X as C,a1 as E,a8 as S,a9 as v,aa as I,ab as b,g as w,ac as D,m as T,ad as N,s as A,ae as M,af as G,K as q,o as F,j as V,ag as Y,ah as X,ai as k,aj as R,ak as L,al as H,am as B,an as U,B as z,ao as O,x as W,a0 as j,u as Z,A as Q,I as K,ap as J,aq as $,ar as tt,as as et,at as st,au as nt,av as it,aw as rt,c as ot,ax as at,ay as ht,az as mt,V as lt,aA as ut,aB as ct,N as gt,i as dt,J as _t,aC as pt,D as ft,aD as xt,aE as yt,F as Pt,aF as Ct,aG as Et,aH as St,aI as vt,aJ as It,U as bt,aK as wt,aL as Dt,aM as Tt,aN as Nt,aO as At,aP as Mt,aQ as Gt,aR as qt,H as Ft,aS as Vt,aT as Yt,v as Xt,O as kt,aU as Rt,W as Lt,aV as Ht,aW as Bt,Y as Ut,aX as zt,aY as Ot,aZ as Wt,a_ as jt,k as Zt,w as Qt,a$ as Kt,b0 as Jt,b1 as $t,S as te,b2 as ee,b3 as se,b4 as ne,y as ie,b5 as re,b6 as oe,q as ae,b7 as he,b8 as me,b9 as le,ba as ue,bb as ce,bc as ge,R as de,bd as _e,C as pe}from"./Point2D.js";import{q as fe,r as xe,t as ye,u as Pe,v as Ce,V as Ee,d as Se,w as ve,x as Ie,O as be,y as we,z as De,p as Te,E as Ne,D as Ae,F as Me,G as Ge,P as qe,A as Fe,B as Ve,H as Ye,l as Xe,m as ke,j as Re,I as Le,J as He,K as Be,S as Ue,T as ze,c as Oe,L as We,i as je,a as Ze,b as Qe,M as Ke,e as Je,N as $e,Q as ts,R as es,U as ss,W as ns,g as is,X as rs,Y as os,Z as as,_ as hs,h as ms,$ as ls,a0 as us,C as cs,a1 as gs,f as ds,a2 as _s,a3 as ps,a4 as fs,a5 as xs,a6 as ys}from"./Envelope.js";import{T as Ps}from"./Transformation2D.js";import{G as Cs,S as Es}from"./SimpleGeometryCursor.js";import{a as Ss,b as vs}from"./tslib.es6.js";import{NonSimpleResult as Is}from"./OperatorDefinitions.js";class bs{constructor(){this.posStream=null,this.streams=null}get(t){return t>0?this.streams[t-1]:this.posStream}set(t,e){t>0?this.streams[t-1]=e:this.posStream=e}destroyAndSetSize(t){if(this.streams=null,t>1){this.streams=new Array(t-1);for(let e=0;e<t-1;++e)this.streams[e]=null}this.posStream=null}swap(t){[this.streams,t.streams]=[t.streams,this.streams],[this.posStream,t.posStream]=[t.posStream,this.posStream]}empty(){return null===this.posStream&&null===this.streams}}function ws(t,e){let s=d(t);const n=e.length/c();for(let t=0;t<e.length;++t){const t=Math.trunc(s*n);s=d(s);const i=Math.trunc(s*n),r=e[t];e[t]=e[i],e[i]=r}}function Ds(t,e,s){if(0===t.length)return;let n=0,i=0;for(++i;i!==t.length;++i)e(t[n],t[i])||(s(n,i),n=i);s(n,i)}function Ts(t,e,s,n,i){_(t,e,n-e,(t,e)=>i(t,e)?-1:1)}function Ns(t,e,s){if(!(s<=e))for(;e<s;)t[s]=p(t[e],t[e]=t[s]),e++,s--}function As(t,e,s,n){Ns(t,e,s-1),Ns(t,s,n-1),t.reverse()}var Ms=Ee;const Gs="can not assign an empty point to a vertex";class qs{constructor(t){if(this.m_accelerators=null,void 0!==t&&t.move)this.m_description=t.move.m_description,t.move.m_description=fe(),this.m_vertexAttributes=t.move.m_vertexAttributes,t.move.m_vertexAttributes=new bs,this.m_envelopeData=t.move.m_envelopeData,t.move.m_envelopeData=new xe,this.m_pointCount=t.move.m_pointCount,this.m_reservedPointCount=t.move.m_reservedPointCount,this.m_flags=t.move.m_flags,this.m_bFillRule=t.move.m_bFillRule,this.m_bPathStarted=t.move.m_bPathStarted,this.m_bPolygon=t.move.m_bPolygon,this.m_simpleTolerance=t.move.m_simpleTolerance;else{const e=void 0!==t&&t.vd?t.vd:fe();this.m_description=e,this.m_vertexAttributes=new bs,this.m_envelopeData=new xe,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,void 0!==t&&t.copy&&t.copy.copyTo(this)}}equalsBase(t,s){if(!e(t.getGeometryType()))return!1;const n=t;if(this===n)return!0;if(!this.m_description.equals(n.getDescription()))return!1;if(this.isEmptyImpl()!==n.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const i=this.getPointCount();if(i!==n.getPointCount())return!1;for(let t=0;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),r=this.getAttributeStreamRef(e),o=n.getAttributeStreamRef(e),a=Ms.getComponentCount(e);if(!r.equals(o,0,i*a,s))return!1}if(s){if(!this.equalsImplTol(t,s))return!1}else if(!this.equalsImpl(t))return!1;return!0}transformAttribute(t,e,n,i,r){if(this.addAttribute(t),!this.isEmpty()&&(0!==n||1!==i)){if(0===t){const t=new Ps;return 0===r?0===e?(t.setShiftCoords(n,0),t.scale(i,1)):1===e?(t.setShiftCoords(0,n),t.scale(1,i)):s(""):0===e?(t.setScaleCoords(1/i,1),t.shiftCoords(-n,0)):1===e?(t.setScaleCoords(1,1/i),t.shiftCoords(0,-n)):s(""),void this.applyTransformation(t)}!function(t,e,n,i,r){(e<0||n<0||i<1||e+i*(n-1)+1>t.size())&&s("Index out of bound");for(let s=e,o=e+i*(n-1)+1;s<o;s+=i)t.writeAsDbl(s,r(t.readAsDbl(s)))}(this.getAttributeStreamRef(t),e,this.getPointCount(),Ms.getComponentCount(t),Me(n,i,r)),this.notifyModified()}}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=ye(e,t);this.assignVertexDescription(s)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Pe(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Ce(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=fe();t!==this.m_description&&this.assignVertexDescription(t)}getAttributeStreamRef(t){this.throwIfEmpty(),this.m_description.hasAttribute(t)||s("AttributeStream : Geometry does not have the attribute");const e=this.m_description.getAttributeIndex(t);return this.m_vertexAttributes.get(e)}setAttributeStreamRef(t,e){e||s("stream"),e&&Ms.getPersistence(t)!==e.getPersistence()&&s(""),this.addAttribute(t);const n=this.m_description.getAttributeIndex(t);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(n,e),this.notifyModifiedFlags(2001)}notifyModifiedFlags(t){65535===t&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(t,!0),this.clearAccelerators(),32&t&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(t,e){const s=e;s.assignVertexDescription(this.m_description);for(let e=0;e<this.m_description.getAttributeCount();e++){const n=this.m_description.getSemantics(e);for(let i=0,r=Ms.getComponentCount(n);i<r;i++){const o=this.m_vertexAttributes.get(e).readAsDbl(r*t+i);s.setAttributeBasic(n,i,o)}}}setPointByValNoCurves(t,e){const n=e;n.isEmpty()&&s(Gs);const i=n.getDescription();i!==this.m_description&&this.mergeVertexDescription(i);const r=this.m_vertexAttributes.get(0);r.write(2*t,n.getX()),r.write(2*t+1,n.getY());for(let e=1,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),i=Ms.getComponentCount(s);for(let r=0;r<i;r++){const o=n.getAttributeAsDbl(s,r);this.m_vertexAttributes.get(e).writeAsDbl(t*i+r,o)}}this.notifyModifiedFlags(2001)}setPointByValFromArrayNoCurves(t,e,s,i){n(0)}getPointByValAsArray(t,e,s,i){n(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return 0===this.m_pointCount}getAttributeAsDbl(t,e,s){const n=Ms.getComponentCount(t);s>=n&&i("");const r=this.m_description.getAttributeIndex(t);return r>=0?this.m_vertexAttributes.get(r).readAsDbl(e*n+s):Ms.getDefaultValue(t)}queryAttributeAsDbl(t,e,s,n){const r=Ms.getComponentCount(t);n<r&&i("");const o=this.m_description.getAttributeIndex(t);if(o>=0){const t=e*r,n=this.m_vertexAttributes.get(o);for(let e=0;e<r;e++)s[e]=n.readAsDbl(t+e)}else{const e=Ms.getDefaultValue(t);for(let t=0;t<r;t++)s[t]=e}}getAttributeAsInt(t,e,s){return Math.trunc(this.getAttributeAsDbl(t,e,s))}queryAttributeAsInt(t,e,s,i){n(0)}setAttributeNoCurves(t,e,s,n){const r=Ms.getComponentCount(t);s>=r&&i(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(o).writeAsDbl(e*r+s,n)}setAttributeFromArrayNoCurves(t,e,s,n){(e<0||e>=this.m_pointCount)&&i("");const r=Ms.getComponentCount(t);n<r&&i(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001);const a=this.m_vertexAttributes.get(o);for(let t=0;t<r;++t)a.writeAsDbl(e*r+t,s[t])}getXY(t){return this.m_vertexAttributes.get(0).readPoint2D(2*t)}queryXY(t,e){return this.m_vertexAttributes.get(0).queryPoint2D(2*t,e)}setXYNoCurves(t,e){this.m_vertexAttributes.get(0).writePoint2D(2*t,e),this.notifyModifiedFlags(2001)}setXYCoordsNoCurves(t,e,s){const n=this.m_vertexAttributes.get(0);n.write(2*t,e),n.write(2*t+1,s),this.notifyModifiedFlags(2001)}getXYZ(t){const e=this.m_vertexAttributes.get(0),s=Se.getNAN();return s.x=e.read(2*t),s.y=e.read(2*t+1),this.m_description.hasAttribute(1)?s.z=this.m_vertexAttributes.get(1).read(t):s.z=Ms.getDefaultValue(1),s}setXYZNoCurves(t,e){this.addAttribute(1),this.notifyModifiedFlags(2001);const s=this.m_vertexAttributes.get(0);s.write(2*t,e.x),s.write(2*t+1,e.y),this.m_vertexAttributes.get(1).write(t,e.z)}queryEnvelope(e){e instanceof t||e instanceof ve?this.updateEnvelope(e):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,e))}queryLooseEnvelope(t){this.updateLooseEnvelope(t)}queryInterval(t,e){const s=r.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,t,e,s)),s}setAttributeBasic(t,e,s){this.setAttributeImpl(t,e,s)}setAttributeImpl(t,e,s){if(this.addAttribute(t),this.isEmpty())return;let n=!1;const i=Ms.getComponentCount(t),r=this.getAttributeStreamRef(t),o=Number.isNaN(s);if(1===r.getPersistence()){const t=r;for(let r=e,a=this.m_pointCount*i;r<a;r+=i){const e=t.read(r);(o||e===s)&&Number.isNaN(e)||(t.write(r,s),n=!0)}}else for(let t=e,o=this.m_pointCount*i;t<o;t+=i)r.readAsDbl(t)!==s&&(r.writeAsDbl(t,s),n=!0);n&&this.notifyModifiedFlags(2001)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;let s=!1;const n=Ms.getComponentCount(t),i=this.getAttributeStreamRef(t);for(let t=0;t<n;t++)if(1===i.getPersistence()){const t=i;for(let i=0,r=this.m_pointCount*n;i<r;i++){const n=t.read(i);Number.isNaN(n)&&(t.write(i,e),s=!0)}}else for(let t=0,r=this.m_pointCount*n;t<r;t++){const n=i.readAsDbl(t);Number.isNaN(n)&&(i.writeAsDbl(t,e),s=!0)}s&&this.notifyModifiedFlags(2001)}calculateLength3D(t){return n(0),0}setEnvelopeForImport(t){this.m_description.equals(t.getDescription())||s(""),this.m_envelopeData=new xe({moveEnv:t}),this.setDirtyFlagProtected(192,!1)}copyTo(t){t.getGeometryType()!==this.getGeometryType()&&s(""),this!==t&&this.copyToUnchecked(t,!1)}queryCoordinates(t,e,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+e),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&s(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);for(let e=2*n,s=2*r,i=0;e<s;e+=2,i++)o.queryPoint2D(e,t[i]);return r}queryCoordinates3D(t,e,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+e),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&s(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const h=Ms.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let l=0;for(let e=n;e<r;e++,l++)t[l].x=o.read(2*e),t[l].y=o.read(2*e+1),t[l].z=m?a.read(e):h;return r}clearAndSetDirtyFlagProtected(t,e){let s=0;const n=t&~e,i=e|n;s=this.m_flags,(s&i)!==e&&(this.m_flags=s&~n|e)}getIsSimple(t,e){e[0]=0;let s=-1;const n=this.m_flags,i=this.m_simpleTolerance;return 1&n||(s=(14&n)>>1,e[0]=i,i<t&&(s=-1)),s}setIsSimple(t,e,s=!1){if(2===t?n(this.getGeometryType()===o.enumPolyline):1===t?n(this.getGeometryType()===o.enumMultiPoint||this.getGeometryType()===o.enumPolyline):3===t&&n(this.getGeometryType()===o.enumPolygon),-1===t)this.setDirtyFlagProtected(17,!0);else{let n=t<<1;s||(n|=16);const i=31;this.clearAndSetDirtyFlagProtected(i,n),this.m_simpleTolerance!==e&&(this.m_simpleTolerance=e)}}attributeStreamIsAllocated(t){this.throwIfEmpty();const e=this.m_description.getAttributeIndex(t);return e>=0&&null!==this.m_vertexAttributes.get(e)}capacity(){return-1===this.m_reservedPointCount&&0===this.m_pointCount?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(t,e=!1){e&&this.hasDirtyFlag(32)&&a("Cannot do shallow clone on unprepared geometry");const s=t,i=this.getGeometryType(),r=s.getGeometryType();n(i===r||i===o.enumPolygon&&r===o.enumPolyline,"failure in copyToUnchcked"),s.clearAccelerators(),s.m_description=this.m_description,s.m_vertexAttributes.destroyAndSetSize(0),s.m_envelopeData.releaseAttributes();const h=this.m_description.getAttributeCount(),m=new bs;if(!this.m_vertexAttributes.empty()){m.destroyAndSetSize(h);for(let t=0;t<h;t++)if(this.m_vertexAttributes.get(t))if(e)m.set(t,this.m_vertexAttributes.get(t));else{const e=Ms.getComponentCount(this.m_description.getSemantics(t));m.set(t,this.m_vertexAttributes.get(t).restrictedClone(this.getPointCount()*e))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,s.m_envelopeData),s.m_flags=this.m_flags,s.m_simpleTolerance=this.m_simpleTolerance,i!==r){const t=[Number.NaN];s.getIsSimple(0,t)>=3?s.setIsSimple(1,t[0]):s.setIsSimple(-1,0)}s.m_vertexAttributes.swap(m),m.destroyAndSetSize(0),s.m_pointCount=this.m_pointCount,s.hasDirtyFlag(32)||s.m_vertexAttributes.empty()?(n(!e||0===s.m_pointCount),s.m_reservedPointCount=-1):s.m_reservedPointCount=s.m_pointCount;try{this.copyToImpl(s,e)}catch(t){throw s.setEmpty(),t}s.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(t,e){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const t=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=t}}interpolateTwoVertices(t,e,s,r){(t<0||t>=this.m_pointCount)&&i(""),(e<0||e>=this.m_pointCount)&&i(""),r.assignVertexDescription(this.m_description);const o=h(Ms.maxComponentCount(),Number.NaN),a=h(Ms.maxComponentCount(),Number.NaN),l=Ie();let u=0;for(let i=0;i<this.m_description.getAttributeCount();i++){const r=this.m_description.getSemantics(i),h=Ms.getInterpolation(r),c=Ms.getComponentCount(r),g=Ms.getDefaultValue(r);this.queryAttributeAsDbl(r,t,o,c),this.queryAttributeAsDbl(r,e,a,c),n(u+c<=be),m(h,o,a,l,u,c,s,g),u+=c}!function(t,e){const s=t.getDescription().getTotalComponentCount();t.setX(e[0]),t.setY(e[1]),g(t.getAttributeArray(),e,0,2,s-2)}(r,l)}getShortestDistance(t,e){return l.distance(this.getXY(t),this.getXY(e))}getShortestSqrDistance(t,e){return l.sqrDistance(this.getXY(t),this.getXY(e))}resizeImpl(t){if(t<0&&s(),(t=Math.ceil(t))===this.m_pointCount)return;this.m_pointCount=t;const e=this.m_pointCount<=this.m_reservedPointCount?2001:4095;this.notifyModifiedFlags(e)}assignVertexDescriptionImpl(t){if(!this.m_vertexAttributes.empty()){const e=we();De(t,this.m_description,e);const s=new bs;s.destroyAndSetSize(t.getAttributeCount());for(let n=0;n<t.getAttributeCount();n++){const t=e[n];-1!==t?s.set(n,this.m_vertexAttributes.get(t)):this.m_reservedPointCount=-1}s.swap(this.m_vertexAttributes)}this.m_description=t,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(t){return 0!==(this.m_flags&t)}setDirtyFlagProtected(t,e){e?this.m_flags|=t:this.m_flags&=~t}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=-1;let t=Number.MAX_SAFE_INTEGER,e=0;e=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:Math.trunc((4*this.m_pointCount+2)/3);for(let s=0;s<this.m_description.getAttributeCount();s++){const n=this.m_description.getSemantics(s);let i=0;if(null!==this.m_vertexAttributes.get(s)){const t=Ms.getComponentCount(n);i=this.m_vertexAttributes.get(s).size()/t,i<this.m_pointCount&&(this.m_vertexAttributes.get(s).resize(e*t,Ms.getDefaultValue(n)),i=e)}else this.m_vertexAttributes.set(s,Te(n,e)),i=e;i<t&&(t=i)}this.m_reservedPointCount=t}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(t){if(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const e=this.updateXYImpl(t),s=new Ne({vd:this.m_description});s.setEnvelope(e);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),n=Ms.getComponentCount(e),i=this.m_vertexAttributes.get(t);for(let t=0;t<n;t++){const o=new r;o.setEmpty();for(let e=0;e<this.m_pointCount;e++){const s=i.readAsDbl(e*n+t);o.mergeCoordinate(s)}s.setIntervalEnvelope(e,t,o)}}(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128))&&(this.m_envelopeData=new xe({moveEnv:s}),this.clearDirtyIntervalsFlag(t))}}updateXYImpl(e){const s=t.constructEmpty(),n=this.m_vertexAttributes.get(0);return s.mergePointsInterleaved(n,0,this.m_pointCount),s}updateEnvelope3D(t){n(0)}updateLooseEnvelope(e){this.updateAllDirtyIntervals(!1),e instanceof t?e.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,e)}updateEnvelope(t){this.updateAllDirtyIntervals(!0),t.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(t){this.setDirtyFlagProtected(192,!1)}reserveImpl(t,e){if(t<0&&s(""),0===t)return;let n=t=Math.ceil(t);if(this.m_reservedPointCount<n){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),e?(null===this.m_vertexAttributes.get(0)&&this.m_vertexAttributes.set(0,Ae(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*n),n=this.m_vertexAttributes.get(0).size()>>1):null===this.m_vertexAttributes.get(0)?this.m_vertexAttributes.set(0,Ae(0,n)):this.m_vertexAttributes.get(0).resize(2*n);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),s=Ms.getComponentCount(e);null!==this.m_vertexAttributes.get(t)?this.m_vertexAttributes.get(t).resize(n*s):this.m_vertexAttributes.set(t,Ae(e,n))}this.reserveImplImpl(n,e),this.m_reservedPointCount=n}}reserveRounded(t){t<0&&s(),t=Math.ceil(t),this.reserveImpl(t,!0)}reserveImplImpl(t,e){}throwIfEmpty(){this.isEmptyImpl()&&u("")}}class Fs extends qs{constructor(t){super(t),t&&(t.points?this.addPoints2D(t.points,t.pointsSize,0,-1):t.point&&this.add(t.point))}assignCopy(t){return t.copyTo(this),this}assignMove(t){return t.copyTo(this),t.setEmpty(),this}insertPoint2D(t,e){t>this.getPointCount()&&s("invalid point index"),t<0&&(t=this.getPointCount());const n=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let s=0,i=this.m_description.getAttributeCount();s<i;s++){const i=this.m_description.getSemantics(s),r=Ee.getComponentCount(i);if(0===i)this.m_vertexAttributes.get(s).insert(r*t,e,r*n);else{const e=Ee.getDefaultValue(i);this.m_vertexAttributes.get(s).insertRange(r*t,e,r,r*n)}}this.notifyModifiedFlags(2001)}insertPoint(t,e){e.isEmpty()&&s(Gs),t<0&&(t=this.getPointCount()),this.mergeVertexDescription(e.getDescription());const n=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let s=0,i=this.m_description.getAttributeCount();s<i;s++){const i=this.m_description.getSemantics(s),r=Ee.getComponentCount(i);if(e.hasAttribute(i))this.m_vertexAttributes.get(s).insertAttributes(r*t,e,i,r*n);else{const e=Ee.getDefaultValue(i);this.m_vertexAttributes.get(s).insertRange(r*t,e,r,r*n)}}this.notifyModifiedFlags(2001)}insertPoints(t,e,s){if((t>this.getPointCount()||s<0)&&i(""),t<0&&(t=this.getPointCount()),0===s)return;const n=e[0].getDescription();this.mergeVertexDescription(n);const r=this.m_pointCount;this.resizeNoInit(this.m_pointCount+s);for(let i=0,o=this.m_description.getAttributeCount();i<o;i++){const o=this.m_description.getSemantics(i),a=Ee.getComponentCount(o);if(this.m_vertexAttributes.get(i))if(n.hasAttribute(o))this.m_vertexAttributes.get(i).insertAttributesFromPoints(t*a,e,s,o,r*a);else{const e=Ee.getDefaultValue(o);this.m_vertexAttributes.get(i).insertRange(a*t,e,a*s,a*r)}}this.notifyModifiedFlags(2001)}insertPoints2D(t,e,n){if((t>this.getPointCount()||n<0)&&s("invalid point index"),t<0&&(t=this.getPointCount()),0===n)return;const i=this.m_pointCount;this.resizeNoInit(this.m_pointCount+n);for(let s=0,r=this.m_description.getAttributeCount();s<r;s++){const r=this.m_description.getSemantics(s),o=Ee.getComponentCount(r);if(this.m_vertexAttributes.get(s))if(0===r)this.m_vertexAttributes.get(s).insertRangeFromPoints(o*t,e,0,n,!0,o*i);else{const e=Ee.getDefaultValue(r);this.m_vertexAttributes.get(s).insertRange(o*t,e,o,o*i)}}this.notifyModifiedFlags(2001)}removePoints(t,e){if((t<0||e<0||t+e>this.getPointCount())&&i("remove_points"),0!==e){for(let s=0,n=this.m_description.getAttributeCount();s<n;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),i=Ee.getComponentCount(n);this.m_vertexAttributes.get(s).eraseRange(i*t,i*e,i*this.m_pointCount)}this.m_pointCount-=e,this.m_reservedPointCount>0&&(this.m_reservedPointCount-=e),this.notifyModifiedFlags(2001)}}removePoint(t){for(let e=0,s=this.m_description.getAttributeCount();e<s;e++)if(this.m_vertexAttributes.get(e)){const s=this.m_description.getSemantics(e),n=Ee.getComponentCount(s);this.m_vertexAttributes.get(e).eraseRange(n*t,n,n*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return this.updateXYImpl(!0)}resizeNoInit(t){this.resizeImpl(t)}resizeAndInitNonPositionAttributes(t){const e=this.m_pointCount;if(this.resizeImpl(t),this.m_pointCount>e)for(let t=1,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t),n=Ee.getDefaultValue(s),i=Ee.getComponentCount(s);this.m_vertexAttributes.get(t).insertRange(i*e,n,i*(this.m_pointCount-e),i*e)}}queryCoordinates3D(t,e,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+e),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&s(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const h=Ee.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let l=0;for(let e=n;e<r;e++,l++)t[l].x=o.read(2*e),t[l].y=o.read(2*e+1),t[l].z=m?a.read(e):h;return r}queryAttributeAsInt(t,e,s,i){n(0)}add(t){t.isEmpty()&&s(Gs),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByValNoCurves(this.m_pointCount-1,t)}addXY(t,e){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const s=new l(t,e);this.setXYNoCurves(this.m_pointCount-1,s)}addXYZ(t,e,s){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const n=new Se;n.setCoords(t,e,s),this.setXYZNoCurves(this.m_pointCount-1,n)}addPoint2D(t){this.addXY(t.x,t.y)}addPoint3D(t){this.addXYZ(t.x,t.y,t.z)}addPoints(t,e,n){this===t&&s("Multi_point_impl.add");const i=n<0?t.getPointCount():n;if((e<0||e>t.getPointCount()||i<e)&&s(""),e===i)return;const r=t.getDescription();this.mergeVertexDescription(r);const o=i-e,a=this.m_pointCount;this.resizeNoInit(this.m_pointCount+o);for(let s=0,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),i=Ee.getComponentCount(n),h=this.getAttributeStreamRef(n);if(r.hasAttribute(n)){const s=t.getAttributeStreamRef(n);h.insertRangeFromStream(a*i,s,e*i,o*i,!0,1,a*i)}else{const t=Ee.getDefaultValue(n);h.insertRange(a*i,t,o*i,a*i)}}}addPoints2D(t,e,n,i){let r=e;const o=i<0?r:i;if((r<0||n<0||n>r||o<n)&&s(""),n===o)return;r=o-n;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const h=this.getAttributeStreamRef(0);for(let e=0;e<r;++e)h.writePoint2D(2*(a+e),t[n+e]);this.notifyModifiedFlags(2001)}addPoints3D(t,e,n,i){let r=e;const o=i<0?r:i;if((r<0||n<0||n>r||o<n)&&s(""),this.addAttribute(1),n===o)return;r=o-n;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const h=this.getAttributeStreamRef(0),m=new l;for(let e=0;e<r;e++)m.x=t[n+e].x,m.y=t[n+e].y,h.writePoint2D(2*(a+e),m);const u=this.getAttributeStreamRef(1);for(let e=0;e<r;e++)u.write(a+e,t[n+e].z);this.notifyModifiedFlags(2001)}setPointByVal(t,e){this.setPointByValNoCurves(t,e)}setXY(t,e){this.setXYNoCurves(t,e)}setXYCoords(t,e,s){this.setXYCoordsNoCurves(t,e,s)}setXYZ(t,e){this.setXYZNoCurves(t,e)}setAttribute(t,e,s,n){this.setAttributeNoCurves(t,e,s,n)}getGeometryType(){return o.enumMultiPoint}getDimension(){return 0}createInstance(){return new Fs({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(t){if(this.isEmpty())return;if(t.isIdentity())return;const e=this.m_vertexAttributes.get(0);1===t.m_TransformationType?e.applyTransformation(t,0,this.m_pointCount):f("3d xform not impl"),this.notifyModifiedFlags(2001)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,e){return t.getGeometryType()===o.enumMultiPoint&&this.equalsBase(t,e)}queryEnvelope(t){4===t.m_EnvelopeType?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t)):2===t.m_EnvelopeType?this.updateEnvelope(t):f("")}getImpl(){return this}getBoundary(){return null}reserve(t){this.reserveImpl(t)}clone(){const t=this.createInstance();return this.copyTo(t),t}swap(t){n(0)}buildQuadTreeAccelerator(t){return!1}getHashCodeImpl(){return n(0),0}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}copyToImpl(t,e){}}Fs.type=o.enumMultiPoint;class Vs{constructor(){this.m_EnvelopeType=5,this.envAabb=t.constructEmpty(),this.envRot=t.constructEmpty()}static constructEmpty(){return new Vs}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(t){this.envAabb.setCoords(t),this.envRot.setCoords({x:Ys(t),y:Xs(t)})}setFromPoints(t,e){this.setEmpty(),this.mergePoints(t,e)}mergeNe(t){this.envAabb.mergeNe(t),this.envRot.mergeNeCoords(Ys(t),Xs(t))}mergePoints(t,e){this.envAabb.mergePoints(t,e);for(let s=0;s<e;){if(!this.envRot.isEmpty()){for(let n=s;n<e;n++){const e=Ys(t[n]),s=Xs(t[n]);this.envRot.mergeNeCoords(e,s)}break}{const e=Ys(t[s]),n=Xs(t[s]);this.envRot.setCoords({x:e,y:n}),s++}}}isIntersectingPoint2D(t){return!(!this.envAabb.contains(t)||!this.envRot.containsCoords(Ys(t),Xs(t)))}isIntersectingW(t){return this.envAabb.isIntersecting(t.envAabb)&&this.envRot.isIntersecting(t.envRot)}containsW(t){return!(!this.envAabb.containsEnvelope(t.envAabb)||!this.envRot.containsEnvelope(t.envRot))}containsPoint2D(t){return this.isIntersectingPoint2D(t)}intersectW(t){const e=this.envAabb.intersect(t.envAabb),s=this.envRot.intersect(t.envRot);return e&&!s&&this.envAabb.setEmpty(),s&&!e&&this.envRot.setEmpty(),e&&s}inflate(t){this.envAabb.inflateCoords(t,t);const e=t*x();this.envRot.inflateCoords(e,e),e<0&&Vs.st_reduceEmpty(this)}static st_reduceEmpty(t){const e=t.envAabb.isEmpty(),s=t.envRot.isEmpty();e&&!s?t.envRot.setEmpty():s&&!e&&t.envAabb.setEmpty()}sqrMaxMinDistance(t){const e=this.envAabb.sqrMaxMinDistance(t),s=this.envRot.sqrMaxMinDistance(ks(t))/2;return Math.max(e,s)}sqrMinDistance(t){const e=this.envAabb.sqrMinDistance(t),s=this.envRot.sqrMinDistance(ks(t))/2;return Math.max(e,s)}sqrMaxDistance(t){const e=this.envAabb.sqrMaxDistance(t),s=this.envRot.sqrMaxDistance(ks(t))/2;return Math.max(e,s)}getEnvelope2D(){return this.envAabb}getRotatedEnvelope2D(){return this.envRot}xyRot(t,e){const s=t.x-t.y,n=(i=t.x,r=t.y,i+r);var i,r;e.setCoords(s,n)}}function Ys(t){return t.x-t.y}function Xs(t){return t.x+t.y}function ks(t){return new l(Ys(t),Xs(t))}class Rs{constructor(){this.x=v.getNAN(),this.y=v.getNAN()}static getNAN(){return new Rs}static constructPoint2D(t){const e=new Rs;return e.x.set(t.x),e.y.set(t.y),e}static constructCoords(t,e){const s=new Rs;return s.x.set(t),s.y.set(e),s}static constructCoordsE(t,e){const s=new Rs;return s.setCoordsE(t,e),s}get 0(){return this.x.clone()}set 0(t){this.x.setE(t)}get 1(){return this.y.clone()}set 1(t){this.y.setE(t)}clone(){return(new Rs).setE(this)}scaleThis(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}setCoords(t,e){return this.x.set(t),this.y.set(e),this}setCoordsE(t,e){return this.x.setE(t),this.y.setE(e),this}set(t){return this.x.set(t.x),this.y.set(t.y),this}setE(t){return this.x.setE(t.x),this.y.setE(t.y),this}setWithEps(t,e){return this.x.setWithEps(t.x,e),this.y.setWithEps(t.y,e),this}getUnitVector(){const t=this.clone();return t.normalize(),t}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(t){const e=new Rs;return e.setCoordsE(this.x.mulE(t),this.y.mulE(t)),e}mul(t){const e=new Rs;return e.setCoordsE(this.x.mul(t),this.y.mul(t)),e}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mulThisE(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}divE(t){return this.clone().divThisE(t)}divThisE(t){return this.x.divThisE(t),this.y.divThisE(t),this}normalize(){const t=this.length();0===t.value()?(this.x=I.clone(),this.y=b.clone()):(this.x.divThisE(t),this.y.divThisE(t))}addE(t){return this.clone().addThisE(t)}addThisE(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this}subE(t){return this.clone().subThisE(t)}subThisE(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this}static distance(t,e){return t.subE(e).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(t,e){const s=this.x.mulE(t).subThisE(this.y.mulE(e)),n=this.x.mulE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}rotateReverse(t,e){const s=this.x.mulE(t).addThisE(this.y.mulE(e)),n=this.x.negate().mulThisE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y))}crossProduct(t){return this.x.mulE(t.y).subE(this.y.mulE(t.x))}value(){return l.construct(this.x.value(),this.y.value())}}class Ls{constructor(){this.a11=new v(1),this.a12=new v(0),this.a21=new v(0),this.a22=new v(1)}clone(){const t=new Ls;return t.a11.setE(this.a11),t.a12.setE(this.a12),t.a21.setE(this.a21),t.a22.setE(this.a22),t}assign(t){return this.a11.setE(t.a11),this.a12.setE(t.a12),this.a21.setE(t.a21),this.a22.setE(t.a22),this}mulThis(t){const e=this.a11.mulE(t.a11).addThisE(this.a12.mulE(t.a21)),s=this.a11.mulE(t.a12).addThisE(this.a12.mulE(t.a22)),n=this.a21.mulE(t.a11).addThisE(this.a22.mulE(t.a21)),i=this.a21.mulE(t.a12).addThisE(this.a22.mulE(t.a22));return this.a11=e,this.a12=s,this.a21=n,this.a22=i,this}mulLeftThis(t){const e=t.clone();return this.assign(e.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const t=this.det();if(0!==t.value()){const e=this.a22.divE(t),s=this.a12.negate().divThisE(t),n=this.a21.negate().divThisE(t),i=this.a11.divE(t);this.a11=e,this.a12=s,this.a21=n,this.a22=i}else this.setZero();return!t.isZero()}transposeThis(){return this.a21=p(this.a12,this.a12=this.a21),this}eigenSymmetric(t,e){const s=this.a12.clone();s.addThisE(this.a21),s.mulThisByPower2(.5);let n=new v(1),i=new v(0);if(s.isZero())t[0].setE(this.a11),t[1].setE(this.a22);else{const e=new v(1);if(this.a11.ne(this.a22)){const r=this.a11.subE(this.a22).divE(s);r.mulThisByPower2(.5);const o=r.sqr();e.setE(r),e.absThis(),e.subThisE(o.add(1).sqrtThis()),r.gt(b)&&e.negateThis();const a=e.sqr().addThis(1).sqrtThis().invThis();i=e.mulE(a),n.setE(a);const h=e.mulE(s);t[0]=this.a11.addE(h),t[1]=this.a22.subE(h)}else n=new v(1/Math.sqrt(2)),i=n.clone(),t[0]=this.a11.addE(s),t[1]=this.a22.subE(s)}e[0].x=n.toDouble(),e[0].y=i.toDouble(),e[1].x=i.negate().toDouble(),e[1].y=n.toDouble(),Math.abs(t[0].toDouble())>Math.abs(t[1].toDouble())&&(t[1]=p(t[0],t[0]=t[1]),e[1]=p(e[0],e[0]=e[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}class Hs{static constructPoint2D(t){return new Hs(y.constructDouble(t.x),y.constructDouble(t.y))}constructor(t,e){if(void 0===t)return this.x=(new y).setNAN(),void(this.y=(new y).setNAN());this.x=t.clone(),this.y=e.clone()}assignPoint2D(t){return this.x.setDouble(t.x),this.y.setDouble(t.y),this}setCoords(t,e){return this.x.setThis(t),this.y.setThis(e),this}asPoint2D(){return new l(this.x.value(),this.y.value())}crossProduct(t){return this.x.mul(t.y).sub(this.y.mul(t.x))}leftPerpendicularThis(){const t=this.x.clone();this.x=this.y.clone().negate(),this.y=t}clone(){return new Hs(this.x,this.y)}dotProduct(t){return this.x.mul(t.x).add(this.y.mul(t.y))}add(t){return new Hs(this.x.add(t.x),this.y.add(t.y))}sub(t){return new Hs(this.x.sub(t.x),this.y.sub(t.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mul(t){return this.clone().mulThis(t)}subThis(t){return this.x.subThis(t.x),this.y.subThis(t.y),this}addThis(t){return this.x.addThis(t.x),this.y.addThis(t.y),this}}var Bs=Ee;function Us(t){let e=!1;for(let s=0;s<2;s++){const n=S(t[0][s],t[3][s]);n>0?(S(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),S(t[1][s],t[3][s])<0&&(t[1][s]=t[3][s],e=!0),S(t[0][s],t[2][s])<0&&(t[2][s]=t[0][s],e=!0),S(t[2][s],t[3][s])<0&&(t[2][s]=t[3][s],e=!0),S(t[1][s],t[2][s])<0&&(t[2][s]=t[1][s],e=!0)):n<0?(S(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),S(t[1][s],t[3][s])>0&&(t[1][s]=t[3][s],e=!0),S(t[0][s],t[2][s])>0&&(t[2][s]=t[0][s],e=!0),S(t[2][s],t[3][s])>0&&(t[2][s]=t[3][s],e=!0),S(t[1][s],t[2][s])>0&&(t[2][s]=t[1][s],e=!0)):t[1][s]===t[0][s]&&t[2][s]===t[0][s]||(t[1][s]=t[0][s],t[2][s]=t[0][s],e=!0)}return e}function zs(t,e){const s=t.getStartXY();if(s.equals(e.getStartXY()))return!0;if(s.equals(e.getEndXY()))return!0;const n=t.getEndXY();return!!n.equals(e.getStartXY())||!!n.equals(e.getEndXY())}function Os(t,e){let s=t.calculateLowerLength2D();return!(s>e)&&(!!t.isLine()||(s=t.calculateUpperLength2D(),s<=e||0!==e&&t.calculateLength2D()<=e))}function Ws(t,e,s){const n=T(l,4);let i=t.queryControlPointsHelper(n);const r=T(l,4);let a=e.queryControlPointsHelper(r);n[0].equals(r[0])||N("");const h=t.getGeometryType();if(h===e.getGeometryType()&&n.map((t,e)=>r[e].equals(t)).reduce((t,e)=>t&&e)){if(h!==o.enumRationalBezier2)return 0;{const s=e,n=[0,0,0],i=[0,0,0];if(t.queryWeights(n),s.queryWeights(i),n.map((t,e)=>i[e]===t).reduce((t,e)=>t&&e))return 0}}for(;i>2&&n[1].equals(n[0]);)n.splice(1,1),i--;for(;a>2&&r[1].equals(r[0]);)r.splice(1,1),a--;(n[1].equals(n[0])||r[1].equals(n[0]))&&N("");const m=l.compareVectorsOrigin(n[0],n[1],r[1]);if(0===m){const s=Hs.constructPoint2D(n[0]),i=new Hs;t.queryCoord2DMP(1e-16,i),i.sub(s);const r=new Hs;return e.queryCoord2DMP(1e-16,r),r.sub(s),r.crossProduct(i).sign()}return m}function js(t,e,s,i,o,a,h,m){let u=t.calculateUpperLength2D(),c=e.calculateUpperLength2D(),g=t,d=e,_=!1;u>c&&(d=p(g,g=d),i=p(s,s=i),c=p(u,u=c),_=!0);const f=0===s;{h[0]=f?1:0;const t=g.getCoord2D(h[0]);m[0]=d.getClosestCoordinate(t,!1);const e=d.getCoord2D(m[0]);if(l.distance(t,e)<=o){const e=[.5,.75,.25,.1,.9];let s=!0;for(let n=0;n<e.length;n++)if(t.assign(g.getCoord2D(e[n])),!d.isCloserThanDistance(t,new r(0,1),o)){s=!1;break}if(s)return _&&(m[0]=p(h[0],h[0]=m[0])),1}}if(u<=3*o)return 0;let x=A(Math.max(o/u,.1),0,.5),y=.01*o,P=0,E=0,S=x,v=-1,I=0,b=1/32;for(let t=0;;t++){n(t<4095);const e=f?x:1-x,s=g.getCoord2D(e),r=d.getClosestCoordinate(s,!1);if(r===i)return I;const u=d.getCoord2D(r),c=l.distance(s,u);if(0===t&&(v=c),c<=y?(b=.5,E=c,P=x):(S=x,v=c),Math.abs(E-v)>.1*y&&S-P>1e-16)x=C(P,S,b);else{if(h[I]=e,m[I]=r,_&&(m[I]=p(h[I],h[I]=m[I])),1===a||1===I)return 1===I&&h[0]>h[1]&&(h[1]=p(h[0],h[0]=h[1]),m[1]=p(m[0],m[0]=m[1])),I+1;I++,P=S,E=v,S=.8,v=-1,x=.8,b=1/32,y=10*o,t=0}}}function Zs(t,e,s,n,i,r,o,a,h){if(M(s,0,1)&&M(n,0,1)&&0===l.distance(t.getCoord2D(s),e.getCoord2D(n))){const h=1e-12,m=new Rs,l=G();if(t.queryDerivative(new v(s,l),m),m.isTrueZero()){const e=1===s?-1e-12:h;t.queryDerivative(new v(s,l).add(e),m)}1===s&&m.negateThis();const u=new Rs;if(e.queryDerivative(new v(n,l),u),u.isTrueZero()){const t=1===s?-1e-12:h;e.queryDerivative(new v(n,l).add(t),u)}1===n&&u.negateThis(),m.isZero()||m.normalize(),u.isZero()||u.normalize();const c=m.dotProduct(u),g=m.crossProduct(u);g.scaleError(3);const d=()=>{{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*i/Math.min(s,n),1e-10)}};if(c.ge(b)&&(g.isZero()||Math.abs(g.value())<d()))return js(t,e,s,n,i,r,o,a)}return 0}function Qs(t,e){t.m_XStart=e.x,t.m_YStart=e.y}function Ks(t,e,s){t.m_XStart=e,t.m_YStart=s}function Js(t,e){t.m_XEnd=e.x,t.m_YEnd=e.y}function $s(t,e,s){t.m_XEnd=e,t.m_YEnd=s}function tn(t,e){const s=new Se;return e?(s.x=t.m_XEnd,s.y=t.m_YEnd):(s.x=t.m_XStart,s.y=t.m_YStart),s.z=function(t,e){return t.m_description.hasZ()?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)]:Bs.getDefaultValue(1)}(t,e),s}function en(t,e,s){t.m_description.hasZ()||t.addAttribute(1),e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified()),t.m_attributes[(t.m_description.getTotalComponentCount()-2)*e]=s.z}function sn(t,e,s){s.assignVertexDescription(t.m_description);const n=0===e?t.m_XStart:t.m_XEnd,i=0===e?t.m_YStart:t.m_YEnd;s.setXYCoords(n,i);for(let n=1;n<t.m_description.getAttributeCount();n++){const i=t.m_description.getSemantics(n);for(let n=0,r=Bs.getComponentCount(i);n<r;n++){const r=rn(t,e,i,n);s.setAttributeBasic(i,n,r)}}}function nn(t,e,s){s.isEmpty()&&u(""),function(t,e,s){e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified())}(t,e,s.getXY());const n=s.getDescription();n!==t.m_description&&t.mergeVertexDescription(n);for(let i=1,r=n.getAttributeCount();i<r;i++){const r=n.getSemantics(i),o=Bs.getComponentCount(r);for(let n=0;n<o;n++)on(t,e,r,n,s.getAttributeAsDbl(r,n))}}function rn(t,e,s,n){if((e<0||e>1)&&i(""),0===s)return(n<0||n>=2)&&i(""),0===e?0===n?t.m_XStart:t.m_YStart:0===n?t.m_XEnd:t.m_YEnd;const r=Bs.getComponentCount(s);(n<0||n>=r)&&i("");const o=t.m_description.getAttributeIndex(s);return o>=0?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(o)-2+n]:Bs.getDefaultValue(s)}function on(t,e,s,n,r){if((e<0||e>1)&&i(""),0===s)return 0===e?0===n?t.m_XStart=r:1===n?t.m_YStart=r:i(""):1===e?0===n?t.m_XEnd=r:1===n?t.m_YEnd=r:i(""):i(""),void t.endPointModified();const o=Bs.getComponentCount(s);(n<0||n>=o)&&i("");let a=t.m_description.getAttributeIndex(s);a<0&&(t.addAttribute(s),a=t.m_description.getAttributeIndex(s)),t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(a)-2+n]=r}function an(t,e){if(t===e)return;e.isEmpty()&&u("");const s=e.getDescription();s!==t.m_description&&t.mergeVertexDescription(s);for(let n=1,i=s.getAttributeCount();n<i;n++){const i=s.getSemantics(n),r=Bs.getComponentCount(i);for(let s=0;s<r;s++){let n=rn(e,0,i,s);on(t,0,i,s,n),n=rn(e,1,i,s),on(t,1,i,s,n)}}}function hn(t){return t.absNorm()*w()}function mn(t,e){return Math.max(t.absNorm(),e.absNorm())*w()}function ln(t,e,s){const n=new Vs;t.queryEnvelopeW(r.unit(),n);const i=new Vs;return e.queryEnvelopeW(r.unit(),i),i.inflate(s),!n.isIntersectingW(i)}function un(t,e,s){const n=D(t,s),i=D(e,s);n.sort((t,e)=>t.compare(e)),i.sort((t,e)=>t.compare(e));for(let t=0;t<3;t++){if(n[t].compare(i[t])<0)return-1;if(0!==n[t].compare(i[t]))return 1}return 0}var cn=Ee;class gn{constructor(t){if(t.copy)this.m_XStart=t.copy.m_XStart,this.m_YStart=t.copy.m_YStart,this.m_XEnd=t.copy.m_XEnd,this.m_YEnd=t.copy.m_YEnd,this.m_description=t.copy.m_description,this.m_attributes=null,this.m_description&&this.m_description.getTotalComponentCount()-2&&(this.m_attributes=t.copy.m_attributes.slice());else{if(t.move)return this.m_description=t.move.m_description,t.move.m_description=null,this.m_attributes=t.move.m_attributes,t.move.m_attributes=null,this.m_XStart=t.move.m_XStart,this.m_YStart=t.move.m_YStart,this.m_XEnd=t.move.m_XEnd,void(this.m_YEnd=t.move.m_YEnd);if(void 0!==t.XStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_attributes=null,this.m_description=t.vd?t.vd:fe(),void(t.vd&&this.setDefaultAttributeValues());if(void 0!==t.ZStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_description=t.vd?t.vd:Ge(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.ZEnd):this.m_attributes=[t.ZStart,t.ZEnd]);if(t.start)return this.m_XStart=t.start.x,this.m_YStart=t.start.y,this.m_XEnd=t.end.x,this.m_YEnd=t.end.y,this.m_attributes=null,void(this.m_description=fe());if(t.start3D)return this.m_XStart=t.start3D.x,this.m_YStart=t.start3D.y,this.m_XEnd=t.end3D.x,this.m_YEnd=t.end3D.y,this.m_description=t.vd?t.vd:Ge(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.end3D.z):this.m_attributes=[t.start3D.z,t.end3D.z]);P("bad constructor params"),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(null===this.m_attributes&&(this.m_attributes=h(2*t,Number.NaN)),g(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,t),g(this.m_attributes,this.m_description.getDefaultPointAttributes(),t,2,t))}absNormXYZ(t){return f("not implemented"),0}queryWeights(t){}snapControlPoints3D(){return f("not implemented"),!1}setCoordsForIntersector3D(t,e,s){f("not implemented")}transformAttribute(t,e,s,n,i){f("")}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=ye(e,t);this.assignVertexDescription(s)}changeEndPoints(t,e){const s=t.getXY(),n=e.getXY();this.changeEndPoints2D(s,n);let i=t.getDescription();i!==this.getDescription()&&this.mergeVertexDescription(i),i=e.getDescription(),i!==this.getDescription()&&this.mergeVertexDescription(i);for(let s=1,n=i.getAttributeCount();s<n;s++){const n=i.getSemantics(s),r=cn.getComponentCount(n);for(let s=0;s<r;s++)on(this,0,n,s,t.getAttributeAsDbl(n,s)),on(this,1,n,s,e.getAttributeAsDbl(n,s))}}getStartXY(){return new l(this.m_XStart,this.m_YStart)}setStartXY(t){this.m_XStart=t.x,this.m_YStart=t.y,this.endPointModified()}setStartXYCoords(t,e){this.m_XStart=t,this.m_YStart=e,this.endPointModified()}getStartXYZ(){return tn(this,0)}setStartXYZ(t){en(this,0,t)}setStartXYZCoords(t,e,s){en(this,0,Se.construct(t,e,s))}queryStart(t){sn(this,0,t)}setStart(t){nn(this,0,t)}setStart2D(t){this.setStartXY(t)}getStartAttributeAsDbl(t,e){return rn(this,0,t,e)}getStartAttributeAsInt(t,e){return n(0),0}setStartAttribute(t,e,s){on(this,0,t,e,s)}setStartAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=cn.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setStartAttribute(e,s,n)}}}setEndAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=cn.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setEndAttribute(e,s,n)}}}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return n(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return n(0),0}getEndXY(){return new l(this.m_XEnd,this.m_YEnd)}setEndXY(t){this.m_XEnd=t.x,this.m_YEnd=t.y,this.endPointModified()}setEndXYCoords(t,e){this.m_XEnd=t,this.m_YEnd=e,this.endPointModified()}getEndXYZ(){return tn(this,1)}setEndXYZ(t){en(this,1,t)}setEndXYZCoords(t,e,s){en(this,1,Se.construct(t,e,s))}queryEnd(t){sn(this,1,t)}setEnd(t){nn(this,1,t)}setEnd2D(t){this.setEndXY(t)}getEndAttributeAsDbl(t,e){return rn(this,1,t,e)}getEndAttributeAsInt(t,e){return n(0),Math.trunc(0)}setEndAttribute(t,e,s){on(this,1,t,e,s)}getDimension(){return 1}copyTo(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&s("");const e=t;e.assignVertexDescription(this.m_description),e.m_attributes&&g(e.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),e.m_XStart=this.m_XStart,e.m_YStart=this.m_YStart,e.m_XEnd=this.m_XEnd,e.m_YEnd=this.m_YEnd,this.copyToImpl(e)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(t,e){const s=r.constructEmpty();return s.vmin=rn(this,0,t,e),s.vmax=s.vmin,s.mergeNeCoordinate(rn(this,1,t,e)),s}calculateLength3D(t){return n(0),0}getCoord3D(t){return n(0),{}}getCoord2D(t){const e=l.getNAN();return this.queryCoord2D(t,e),e}queryCoord3D(t,e){n(0)}getCoordZ(t){return n(0),0}queryCoord(t,e){e.assignVertexDescription(this.m_description),e.setXY(this.getCoord2D(t));for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),i=cn.getComponentCount(n);for(let s=0;s<i;s++){const i=this.getAttributeAsDbl(t,n,s);e.setAttributeBasic(n,s,i)}}}isCloserThanDistance(e,s,n){const i=t.constructEmpty();if(this.queryLooseEnvelopeOnInterval(s,i),i.distance(e)>n)return!1;const r=this.getClosestCoordinateOnInterval(e,s,n);return!Number.isNaN(r)&&l.distance(e,this.getCoord2D(r))<=n}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const t=this.clone();return t.reverse(),t}reverse(){this.m_XEnd=p(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=p(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t);for(let t=0,s=cn.getComponentCount(e);t<s;t++){const s=rn(this,0,e,t);on(this,0,e,t,rn(this,1,e,t)),on(this,1,e,t,s)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(t,e,s,i){if(!e&&this.isIntersecting(t,0,!1)){if(null!==s||null!==i){const e=h(9,Number.NaN),r=h(9,Number.NaN),o=this.intersect(t,null,e,r,0);n(o<=9),0===o&&P(""),null!==s&&(s[0]=e[0]),null!==i&&(i[0]=r[0])}return 0}let r,o=Number.MAX_VALUE,a=-1,m=o;return r=this.getStartXY(),a=t.getClosestCoordinate(r,!1),r.subThis(t.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==i&&(i[0]=a),null!==s&&(s[0]=0)),r=this.getEndXY(),a=t.getClosestCoordinate(r,!1),r.subThis(t.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==i&&(i[0]=a),null!==s&&(s[0]=1)),r=t.getStartXY(),a=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==s&&(s[0]=a),null!==i&&(i[0]=0)),r=t.getEndXY(),a=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==s&&(s[0]=a),null!==i&&(i[0]=1)),o}calculateSubLengthFromStart(t){return this.tToLength(t)}calculateSubLength(t,e){return e===t?0:this.tToLength(e)-this.tToLength(t)}static recalculateParentT(t,e,s){return C(t,e,s)}moveTo(t){const e=this.isClosed(),s=new Ps;s.setShift(t.sub(this.getStartXY())),this.applyTransformation(s),e?this.changeEndPoints2D(t,t):this.changeEndPoints2D(t,this.getEndXY())}moveTo3D(t){n(0)}getDescription(){return this.m_description}assignVertexDescription(t){!function(t,e){const s=we();De(e,t.m_description,s);let n=null;const i=e.getTotalComponentCount()-2,r=t.m_description?t.m_description.getTotalComponentCount()-2:0;if(i>0&&(n=h(2*i,Number.NaN),g(n,e.getDefaultPointAttributes(),0,2,i),g(n,e.getDefaultPointAttributes(),i,2,i),null!==t.m_description))for(let o=1;o<e.getAttributeCount();o++){const a=s[o];if(-1!==a){const s=t.m_description.getPointAttributeOffset(a)-2,h=e.getPointAttributeOffset(o)-2,m=Bs.getComponentCount(e.getSemantics(o));for(let e=0;e<m;++e)n[h]=t.m_attributes[s],n[i+h]=t.m_attributes[r+s]}}t.m_attributes=n,t.m_description=e}(this,t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Pe(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Ce(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=fe();t!==this.m_description&&this.assignVertexDescription(t)}swap(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&s("wrong geometry type");const e=t;e.m_description=p(this.m_description,this.m_description=e.m_description),e.m_XStart=p(this.m_XStart,this.m_XStart=e.m_XStart),e.m_YStart=p(this.m_YStart,this.m_YStart=e.m_YStart),e.m_XEnd=p(this.m_XEnd,this.m_XEnd=e.m_XEnd),e.m_YEnd=p(this.m_YEnd,this.m_YEnd=e.m_YEnd),e.m_attributes=p(this.m_attributes,this.m_attributes=e.m_attributes),this.swapImpl(e)}equals(t,e){if(this.getGeometryType()!==t.getGeometryType())return!1;const s=void 0===e;s&&(e=0);const n=t;if(this===n)return!0;if(this.m_description!==n.m_description)return!1;if(Math.abs(this.m_XStart-n.m_XStart)>e||Math.abs(this.m_XEnd-n.m_XEnd)>e||Math.abs(this.m_YStart-n.m_YStart)>e||Math.abs(this.m_YEnd-n.m_YEnd)>e)return!1;for(let t=0,s=2*(this.m_description.getTotalComponentCount()-2);t<s;t++)if(!E(this.m_attributes[t],n.m_attributes[t],e))return!1;return s?this.equalsImpl(n):this.equalsImplTol(n,e)}getImpl(){return this}setAttributeBasic(t,e,n){if(this.addAttribute(t),0===t&&this.isCurve()){(e<0||e>1)&&s("");const t=new Ps,i=0===e?n:0,r=1===e?n:0;t.setShiftCoords(i,r),0===e?t.xx=0:t.yy=0,this.applyTransformation(t)}else this.setStartAttribute(t,e,n),this.setEndAttribute(t,e,n)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;const s=cn.getComponentCount(t);for(let n=0;n<s;n++){const s=this.getStartAttributeAsDbl(t,n);Number.isNaN(s)&&this.setStartAttribute(t,n,e);const i=this.getEndAttributeAsDbl(t,n);Number.isNaN(i)&&this.setEndAttribute(t,n,e)}}}gn.s_maxMonotonicPartParams=8;class dn extends Cs{constructor(t,e){super(),this.m_index=-1,this.gc=t,this.dim=e}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount())return null;if(this.m_index++,this.m_index===this.gc.getGeometryCount())return null;const t=this.gc.getGeometry(this.m_index);if(-1===this.dim||1<<t.getDimension()&this.dim)return t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class _n{constructor(t){this.m_geoms=[],this.m_description=fe(),t&&(t.vd?this.m_description=t.vd:t.copy?t.copy.copyTo(this):s("constructor argument not recognized"))}getGeometryCount(){return this.m_geoms.length}reserve(t){}addGeometry(t){if(t.getGeometryType()===o.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else this.m_geoms.push(t.clone()),this.mergeVertexDescription(t.getDescription())}addCursor(t){for(let e=t.next();null!==e;e=t.next())this.addGeometry(e)}getGeometry(t){return(t<0||t>=this.m_geoms.length)&&s("Geometry_collection.get_geometry"),this.m_geoms[t]}modifiedElementIndex(t){this.mergeVertexDescription(this.getGeometry(t).getDescription())}modifiedElement(t){this.mergeVertexDescription(t.getDescription())}getGeometryType(){return o.enumGeometryCollection}getDimension(){let t=0;for(const e of this.m_geoms)t=Math.max(t,e.getDimension());return t}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}assignVertexDescriptionImpl(t){for(const e of this.m_geoms)e.assignVertexDescription(t);this.m_description=t}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=Pe(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=Ce(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=fe();t!==this.m_description&&this.assignVertexDescription(t)}queryInterval(t,e){let s=new r;const n=new r;n.setEmpty();for(const i of this.m_geoms)s=i.queryInterval(t,e),n.merge(s);return n}queryEnvelope(e){if(4===e.m_EnvelopeType){const t=new Ne;e.setEmpty(),e.assignVertexDescription(this.m_description);for(const s of this.m_geoms)s.queryEnvelope(t),e.merge(t)}else if(2===e.m_EnvelopeType){const s=new t;e.setEmpty();for(const t of this.m_geoms)t.queryEnvelope(s),e.mergeEnvelope2D(s)}f("3d envelope case not implemented")}queryLooseEnvelope(e){if(2===e.m_EnvelopeType){const s=new t;e.setEmpty();for(const t of this.m_geoms)t.queryLooseEnvelope(s),e.mergeEnvelope2D(s)}f("3d not impl")}isEmpty(){return 0===this.m_geoms.length}setEmpty(){this.m_geoms.length=0}applyTransformation(t){if(1===t.m_TransformationType)for(const e of this.m_geoms)e.applyTransformation(t);f("3d xform not impl")}transformAttribute(t,e,s,n,i){for(const r of this.m_geoms)r.transformAttribute(t,e,s,n,i)}createInstance(){return new _n({vd:this.getDescription()})}copyTo(t){t.getGeometryType()!==o.enumGeometryCollection&&s("");const e=t;if(e!==this){e.m_geoms.length=0,e.assignVertexDescription(this.m_description);for(const t of this.m_geoms)e.m_geoms.push(t.clone())}}calculateArea2D(){const t=new q(0);for(const e of this.m_geoms)t.pe(e.calculateArea2D());return t.getResult()}calculateLength2D(){const t=new q(0);for(const e of this.m_geoms)t.pe(e.calculateLength2D());return t.getResult()}calculateLength3D(t){return n(0),0}getBoundary(){const t=this.createInstance(),e=t;for(const t of this.m_geoms){const s=t.getBoundary();s&&e.m_geoms.push(s)}return t}clone(){return new _n({copy:this})}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==o.enumGeometryCollection)return!1;const s=t;if(this.m_description!==s.m_description)return!1;if(this.m_geoms.length!==s.m_geoms.length)return!1;for(let t=0;t<this.m_geoms.length;++t)if(!this.m_geoms[t].equals(s.m_geoms[t],e))return!1;return!0}swap(t){t.getGeometryType()!==o.enumGeometryCollection&&s("");const e=t;e!==this&&(this.m_geoms=p(e.m_geoms,e.m_geoms=this.m_geoms))}setAttributeBasic(t,e,s){for(const n of this.m_geoms)n.setAttributeBasic(t,e,s)}replaceNaNs(t,e){for(const s of this.m_geoms)s.replaceNaNs(t,e)}getImpl(){return this}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=ye(e,t);this.assignVertexDescription(s)}}function pn(t,e=-1){return new dn(t,e)}_n.type=o.enumGeometryCollection;class fn extends gn{constructor(t){super(t)}}class xn extends fn{isTrue3D(){return!0}constructor(t){super(t)}}function yn(t,e,s){Pn(e,t.getStartXY(),t.getEndXY(),s)}function Pn(t,e,s,n){st(e,s,t,n)}function Cn(t,e){return C(t.m_XStart,t.m_XEnd,e)}function En(t,e){return C(t.m_YStart,t.m_YEnd,e)}function Sn(t,e,s){e.value()<=.5?J(2,Rs.constructPoint2D(t.getStartXY()),Rs.constructPoint2D(t.getEndXY()),e,s):$(2,Rs.constructPoint2D(t.getStartXY()),Rs.constructPoint2D(t.getEndXY()),e,s)}function vn(t,e,s){t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,t.afterCompletedModification()}function In(t){if(t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart){t.m_XEnd=p(t.m_XStart,t.m_XStart=t.m_XEnd),t.m_YEnd=p(t.m_YStart,t.m_YStart=t.m_YEnd);for(let e=0,s=t.m_description.getTotalComponentCount()-2;e<s;e++)t.m_attributes[e+s]=p(t.m_attributes[e],t.m_attributes[e]=t.m_attributes[e+s])}}function bn(t,e,s,n){let i=0;if((t.m_XStart===e.m_XStart&&t.m_YStart===e.m_YStart||t.m_XStart===e.m_XEnd&&t.m_YStart===e.m_YEnd)&&(i++,!n))return 1;if(t.m_XEnd===e.m_XStart&&t.m_YEnd===e.m_YStart||t.m_XEnd===e.m_XEnd&&t.m_YEnd===e.m_YEnd){if(i++,2===i)return 2;if(!n)return 1}return e.isIntersectingPoint(t.getStartXY(),s,!0)||e.isIntersectingPoint(t.getEndXY(),s,!0)||t.isIntersectingPoint(e.getStartXY(),s,!0)||t.isIntersectingPoint(e.getEndXY(),s,!0)?4:n&&i?0:function(t,e){const s=Nn(t,e.m_XStart,e.m_YStart),n=Nn(t,e.m_XEnd,e.m_YEnd);if(s<0&&n<0||s>0&&n>0)return!1;const i=Nn(e,t.m_XStart,t.m_YStart),r=Nn(e,t.m_XEnd,t.m_YEnd);return!(i<0&&r<0||i>0&&r>0)&&(Gn(t)>Gn(e)?Mn(t,e):Mn(e,t))}(t,e)?4:0}function wn(t,e,s,n,i,r,o,a){null!==n&&_t(n,2,Number.NaN),null!==i&&_t(i,2,Number.NaN),null!==s&&pt(s,l,2);const h=function(t,e,s,n,i,r,o,a,h){const m=Tn(t,e.getStartXY(),o,!1),u=Tn(t,e.getEndXY(),o,!1),c=Tn(e,t.getStartXY(),o,!1),g=Tn(e,t.getEndXY(),o,!1);let d=0,_=0;if(!Number.isNaN(m)){let s=!1;a&&M(m,0,1)&&t.getCoord2D(m).isEqualPoint2D(e.getStartXY())&&(d++,s=!0),s||(i&&(i[_]=m),r&&(r[_]=0),n&&n[_].setCoords(e.m_XStart,e.m_YStart),_++)}if(!Number.isNaN(u)){let s=!1;a&&M(u,0,1)&&t.getCoord2D(u).isEqualPoint2D(e.getEndXY())&&(d++,s=!0),s||(2>_&&(i&&(i[_]=u),r&&(r[_]=1),n&&n[_].setCoords(e.m_XEnd,e.m_YEnd)),_++)}if(2!==_&&!Number.isNaN(c)&&!(0===m&&0===c||0===u&&1===c)){let s=!1;a&&M(c,0,1)&&e.getCoord2D(c).isEqualPoint2D(t.getStartXY())&&(d++,s=!0),s||(2>_&&(i&&(i[_]=0),r&&(r[_]=c),n&&n[_].setCoords(t.m_XStart,t.m_YStart)),_++)}if(2!==_&&!Number.isNaN(g)&&!(1===m&&0===g||1===u&&1===g)){let s=!1;a&&M(g,0,1)&&e.getCoord2D(g).isEqualPoint2D(t.getEndXY())&&(d++,s=!0),s||(2>_&&(i&&(i[_]=1),r&&(r[_]=g),n&&n[_].setCoords(e.m_XEnd,e.m_YEnd)),_++)}if(_>0)return h&&(r=p(i,i=r)),2===_&&i&&i[0]>i[1]&&(i[1]=p(i[0],i[0]=i[1]),r&&(r[1]=p(r[0],r[0]=r[1])),n&&(n[1]=p(n[0],n[0]=n[1]))),_;if(d>0)return 0;const f=function(t,e,s){const n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*i-n*o;if(0===a)return l.getNAN();const h=4*G()*(Math.abs(r*i)+Math.abs(n*o)),m=e.m_XStart-t.m_XStart,u=e.m_YStart-t.m_YStart,c=r*u-m*o,g=4*G()*(Math.abs(r*u)+Math.abs(m*o)),d=c/a,_=Math.abs(a),p=(g*_+h*Math.abs(c))/(a*a)+G()*Math.abs(d);if(d<-p||d>1+p)return l.getNAN();const f=n*u-m*i,x=f/a,y=(4*G()*(Math.abs(n*u)+Math.abs(m*i))*_+h*Math.abs(f))/(a*a)+G()*Math.abs(x);if(x<-y||x>1+y)return l.getNAN();let P=A(d,0,1),C=A(x,0,1);const E=l.getNAN();yn(t,P,E);const S=l.getNAN();if(yn(e,C,S),!s||l.distance(E,S)>s){const n=l.getNAN();st(E,S,.5,n),P=t.getClosestCoordinate(n,!1),C=e.getClosestCoordinate(n,!1);const i=l.getNAN();yn(t,P,i);const r=l.getNAN();yn(e,C,r),i.subThis(r);const o=i.length(),a=(t.absNorm()+e.absNorm())*w();if(o>Math.max(s,a))return l.getNAN()}return new l(P,C)}(t,e,o);return Number.isNaN(f.x)?0:(n&&(n[0]=t.getCoord2D(f.x)),i&&(i[0]=f.x),r&&(r[0]=f.y),1)}(t,e,0,s,n,i,r,o,a);return n&&(n.length=h),i&&(i.length=h),s&&(s.length=h),h}function Dn(t,e){const s={bIntersect:!1,t1:Number.NaN,t2:Number.NaN},n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*i-n*o;if(0===a)return s;const h=e.m_XStart-t.m_XStart,m=e.m_YStart-t.m_YStart,l=r*m-h*o,u=n*m-h*i,c=1/a;return s.t1=l*c,s.t2=u*c,s.bIntersect=!0,s}function Tn(t,e,s,n){const i=l.getNAN(),r=l.getNAN();let o=!1;t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart?(i.setCoords(t.m_XEnd,t.m_YEnd),r.setCoords(t.m_XStart,t.m_YStart),o=!0):(i.setCoords(t.m_XStart,t.m_YStart),r.setCoords(t.m_XEnd,t.m_YEnd));const a=o?1:0,h=o?0:1,m=l.getNAN();m.setSub(e,i);let u=m.length(),c=3*u*G();if(u<=Math.max(s,c))return n&&0===u?Number.NaN:a;if(m.setSub(e,r),u=m.length(),c=3*u*G(),u<=Math.max(s,c))return n&&0===u?Number.NaN:h;m.setCoords(r.x-i.x,r.y-i.y);const g=m.length();if(g>0){const t=1/g;m.scale(t);const n=l.getNAN();n.setSub(e,i);const u=n.dotProduct(m),c=8*n.dotProductAbs(m)*G();m.leftPerpendicularThis();const d=n.dotProduct(m),_=8*n.dotProductAbs(m)*G(),p=Math.max(s,c);if(u<-p||u>g+p)return Number.NaN;const f=Math.max(s,_);if(Math.abs(d)<=f){let n=u*t;n=A(n,0,1);const m=l.getNAN();if(Pn(n,i,r,m),l.distance(m,e)<=s){if(n<.5){if(l.distance(m,i)<=s&&l.distance(e,i)<=s)return a}else if(l.distance(m,r)<=s&&l.distance(e,r)<=s)return h;return o?1-n:n}}}return Number.NaN}function Nn(t,e,s){const n=l.getNAN();n.setCoords(e,s),n.subThis(t.getStartXY());const i=l.getNAN();i.setSub(t.getEndXY(),t.getStartXY());const r=i.crossProduct(n),o=4*G()*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>o?-1:r<-o?1:0}function An(t,e,s,n){const i=n?t.m_XStart:t.m_XEnd,r=n?t.m_YStart:t.m_YEnd,o=l.getNAN();return o.x=e.getEndX()-i,o.y=e.getEndY()-r,!(s.dotProduct(o)>3*G()*s.dotProductAbs(o))||(o.x=e.getStartX()-i,o.y=e.getStartY()-r,s.dotProduct(o)<=3*G()*s.dotProductAbs(o))}function Mn(t,e){const s=l.getNAN();return s.x=t.m_XEnd-t.m_XStart,s.y=t.m_YEnd-t.m_YStart,!!An(t,e,s,!1)&&(s.negateThis(),!!An(t,e,s,!0))}function Gn(t){const e=t.m_XStart-t.m_XEnd,s=t.m_YStart-t.m_YEnd;return e*e+s*s}class qn{constructor(t){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=t.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=t.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),void 0!==t.pointIndex){(t.pointIndex<0||t.pointIndex>=t.parent.getPointCount())&&i("");const e=t.parent.getPathIndexFromPointIndex(t.pointIndex);this.m_currentPathIndex=e,this.m_nextPathIndex=e+1,this.m_nextSegmentIndex=t.pointIndex-t.parent.getPathStart(e),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(void 0!==t.pathIndex){(t.pathIndex<0||t.pathIndex>=t.parent.getPathCount()||t.segmentIndex<0)&&i("");const e=t.parent.isClosedPath(t.pathIndex)?0:1;t.segmentIndex>=t.parent.getPathSize(t.pathIndex)-e&&i(""),this.m_nextSegmentIndex=t.segmentIndex,this.m_currentPathIndex=t.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount()||(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,0))}previousPath(){return 0!==this.m_nextPathIndex&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(t){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(t)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(t){(t<0||t>this.m_parent.getPathCount())&&i(""),this.m_nextPathIndex=t,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return 0===this.m_currentSegmentIndex}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(t){this.m_parent!==t.m_parent&&K(""),this.m_currentSegmentIndex=t.m_currentSegmentIndex,this.m_nextSegmentIndex=t.m_nextSegmentIndex,this.m_currentPathIndex=t.m_currentPathIndex,this.m_nextPathIndex=t.m_nextPathIndex,this.m_segmentCount=t.m_segmentCount,this.m_bCirculator=t.m_bCirculator,this.m_pathBegin=t.m_pathBegin,this.m_bCurrentPathClosed=t.m_bCurrentPathClosed,this.m_bStripAttributes=t.m_bStripAttributes,this.m_description=t.m_description}resetToVertex(t,e){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const e=this.getPathBegin();if(t>=e&&t<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=t-e)}let s;s=e>=0&&e<this.m_parent.getPathCount()&&t>=this.m_parent.getPathStart(e)&&t<this.m_parent.getPathEnd(e)?e:this.m_parent.getPathIndexFromPointIndex(t),this.m_nextPathIndex=s+1,this.m_currentPathIndex=s,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=t-this.m_parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(s),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&i("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(0===this.m_nextSegmentIndex&&i(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let t=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||t===this.m_segmentCount)return null;const e=this.getPathBegin()+this.m_nextSegmentIndex;if(1!=(31&this.m_segFlagStream.read(e))){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,t++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&i(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&i(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){return null!==this.m_segFlagStream&&1!=(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(t){this.m_bCirculator=t}getImpl(){return this}}class Fn{constructor(t){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,t&&t.copyTo(this)}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(t){t!==this&&(n(t.uniqueUse()),t.m_quadTree=this.m_quadTree,t.m_quadTreeForPaths=this.m_quadTreeForPaths,t.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const t=new Fn;return this.copyTo(t),t}uniqueUse(){return 1===this.m_refCount}addRef(){++this.m_refCount}release(){0===--this.m_refCount&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(t){n(this.uniqueUse())}setQuadTree(t){n(this.uniqueUse()),this.m_quadTree=t}setQuadTreeForPaths(t){n(this.uniqueUse()),this.m_quadTreeForPaths=t}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}}function Vn(t){return!(t.isEmpty()||t.getGeometryType()!==o.enumPolyline&&t.getGeometryType()!==o.enumPolygon||t.getPointCount()<20)}function Yn(t){return!(t.isEmpty()||t.getGeometryType()!==o.enumPolyline&&t.getGeometryType()!==o.enumPolygon||t.getPointCount()<20)}function Xn(t,e){return t.readPoint2D(e+4)}function kn(t){const e=t.getGeometryType();return e===o.enumEllipticArc?10:e===o.enumBezier?4:e===o.enumRationalBezier2?5:e===o.enumBezier2?2:void P("")}function Rn(t){const e=31&t;return 4===e?10:2===e?4:8===e?5:16===e?2:0}function Ln(t,e,s,n){const i=t.getPathStart(e),r=t.getPathEnd(e);if(r-i<3)return;const o=2*i,a=l.getNAN();s.queryPoint2D(o,a);const h=a.x,m=a.y,u=l.getNAN();s.queryPoint2D(o+2,u);const c=l.getNAN();for(let t=o+4,e=2*r;t<e;t+=2)s.queryPoint2D(t,c),n.pe((c.x-a.x)*(u.y-m)),a.setCoordsPoint2D(u),u.setCoordsPoint2D(c);n.pe((h-a.x)*(u.y-m))}function Hn(t,e,s){for(;e.hasNextSegment();){const t=e.nextCurve();if(null===t)break;s.pe(2*t.calculateArea2DHelper())}}var Bn=Ee;class Un{static toSegType(t){let e=0;switch(t){case o.enumLine:e=1;break;case o.enumBezier:e=2;break;case o.enumEllipticArc:e=4;break;case o.enumRationalBezier2:e=8;break;case o.enumBezier2:e=16;break;default:P("")}return e}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(t){return this.m_segmentFlags=t.m_segmentFlags,this.m_segmentParamIndex=t.m_segmentParamIndex,this.m_segmentParams=t.m_segmentParams,this.m_curveCount=t.m_curveCount,this.m_bezierCount=t.m_bezierCount,this.m_arcCount=t.m_arcCount,this.m_rbezier2Count=t.m_rbezier2Count,this.m_bezier2Count=t.m_bezier2Count,this.m_curveParamWritePoint=t.m_curveParamWritePoint,this}}class zn extends qs{constructor(t){super(t),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,t.move?(this.m_bPolygon=t.move.m_bPolygon,this.m_cachedLength2D=t.move.m_cachedLength2D,this.m_cachedArea2D=t.move.m_cachedArea2D,this.m_currentPathIndex=t.move.m_currentPathIndex,this.m_cachedRingAreas2D=t.move.m_cachedRingAreas2D,this.m_paths=t.move.m_paths,this.m_pathFlags=t.move.m_pathFlags,this.m_curveData=t.move.m_curveData,t.move.m_curveData=null,t.move.setEmpty()):(this.m_bPolygon=t.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?o.enumPolygon:o.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(t){n(this.m_bPolygon);const e=this.getPathIndexFromPointIndex(t),i=this.getPathStart(e);if(i===t)return;const r=this.getPathEnd(e);(t>=r||t<i)&&s("change_ring_start_point");for(let e=0,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),n=Bn.getComponentCount(s);this.m_vertexAttributes.get(e).rotate(i*n,t*n,r*n)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(i,t,r),this.m_curveData.m_segmentParamIndex.rotate(i,t,r))}setFillRule(t){this.m_bFillRule=1===t}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(t){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(t)))}isExteriorRing(t){return this.calculateRingArea2D(t)>0}calculateRingArea2D(t){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(t)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const t=this.getPathCount();if(0===t)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const e=new Ye(t),s=new q(0),n=new q(0);if(0!==this.m_pointCount){const i=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const t=new qn({parent:this});for(t.stripAttributes();t.nextPath();){n.reset();const r=t.getPathIndex();Ln(this,r,i,n),Hn(0,t,n);const o=.5*n.getResult();s.add(o),e.write(r,o)}}else for(let r=0;r<t;r++){n.reset(),Ln(this,r,i,n);const t=.5*n.getResult();s.add(t),e.write(r,t)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=s.getResult(),this.m_cachedRingAreas2D=e,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)8&this.m_pathFlags.read(s)&&t++;return t}getHashCodeImpl(){return n(0),0}equalsImpl(t){const e=t,s=this.getPathCount();if(s!==e.getPathCount())return!1;const n=this.hasNonLinearSegments();if(n!==e.hasNonLinearSegments())return!1;if(n){if(this.m_curveData.m_curveCount!==e.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==e.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(e.m_paths,0,s+1))return!1;if(this.m_bFillRule!==e.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(e.m_pathFlags,0,s))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(e.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let t=0,s=this.getPointCount();t<s;t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!zn.isNonLinearSegmentFlag(s))continue;const n=this.m_curveData.m_segmentParamIndex.read(t),i=e.m_curveData.m_segmentParamIndex.read(t),r=Rn(s);for(let t=0;t<r;t++){const s=this.m_curveData.m_segmentParams.read(n+t),r=e.m_curveData.m_segmentParams.read(i+t);if(!j(s,r))return!1}}}return!0}equalsImplTol(t,e){const s=t,n=this.getPathCount();if(n!==s.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==s.hasNonLinearSegments())return!1;if(i){if(this.m_curveData.m_curveCount!==s.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==s.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(s.m_paths,0,n+1))return!1;if(this.m_bFillRule!==s.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(s.m_pathFlags,0,n))return!1;if(!i)return!0;if(!this.m_curveData.m_segmentFlags.equals(s.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const r=this.querySegmentIterator(),o=s.querySegmentIterator();for(;r.nextPath();){if(!o.nextPath())return!1;for(;r.hasNextSegment();){const t=r.nextCurve(),s=o.nextCurve();if(!(t&&s&&t.equals(s,e))){if(!t&&!s)break;return!1}}}return!0}reserveImplImpl(t,e){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(t,1),this.m_curveData.m_segmentParamIndex.resize(t,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=Xe(1,0),this.m_pathFlags=ke(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(t,e){const s=t;s.m_bPathStarted=!1,s.m_bFillRule=this.m_bFillRule,this.m_paths?s.m_paths=e?this.m_paths:this.m_paths.clone():s.m_paths=null,this.m_pathFlags?s.m_pathFlags=e?this.m_pathFlags:this.m_pathFlags.clone():s.m_pathFlags=null,this.m_curveData&&(s.m_curveData||(s.m_curveData=new Un),s.m_curveData.assignCopy(this.m_curveData),s.m_curveData.m_curveCount=0,s.updateCurveCounter(this.m_curveData.m_curveCount),e||(this.m_curveData.m_segmentParamIndex?s.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex.clone():s.m_curveData.m_segmentParamIndex=null,this.m_curveData.m_segmentFlags?s.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags.clone():s.m_curveData.m_segmentFlags=null,this.m_curveData.m_segmentParams?s.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams.clone():s.m_curveData.m_segmentParams=null)),s.hasDirtyFlag(512)||(s.m_cachedLength2D=this.m_cachedLength2D),s.m_cachedRingAreas2D=null,s.hasDirtyFlag(1024)||(s.m_cachedArea2D=this.m_cachedArea2D,null!==this.m_cachedRingAreas2D&&(s.m_cachedRingAreas2D=e?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const t=this.querySegmentIterator(),e=new q(0);for(;t.nextPath();)for(;t.hasNextSegment();)e.add(t.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=e.getResult()),this.setDirtyFlagProtected(512,!1),e.getResult()}calculatePathLength2D(t){const e=this.querySegmentIteratorAtVertex(this.getPathStart(t)),s=new q(0);for(;e.hasNextSegment();)s.add(e.nextSegment().calculateLength2D());return s.getResult()}calculateLength3D(t){return n(0),0}calculatePathLength3D(t,e){return n(0),0}copyTo(t){Z(t.getGeometryType())||s(""),this!==t&&super.copyTo(t)}swap(t){n(0)}setPointByVal(t,e){this.setPointByValWithCurves(t,e)}setPointByValWithCurves(t,e){if(this.hasNonLinearSegments()){const s=e.getXY();if(this.setXYCoordsWithCurves(t,s.x,s.y),1===this.m_description.getAttributeCount())return}this.setPointByValNoCurves(t,e)}setXYCoordsWithCurves(t,e,s){if(this.hasNonLinearSegments()){const n=zn.getPathIndexFromPointIndexImpl(this.m_paths,this.getPathCount(),t,this.m_currentPathIndex);this.m_currentPathIndex=n;const i=this.getPrevSegmentTypeFromPath(n,t),r=this.getNextSegmentType(t);if(1!==i||1!==r){let o=t-1;const a=new fm;1!==i&&(this.isClosedPath(n)&&t===this.getPathStart(n)&&(o=this.getPathEnd(n)-1),this.getSegmentBuffer(o,a,!0));const h=new fm;1!==r&&this.getSegmentBuffer(t,h,!0);const m=t+1;this.setXYCoordsNoCurves(t,e,s);const u=new l(e,s);return 1!==i&&(a.get().changeEndPoints2D(a.get().getStartXY(),u),this.replaceSegmentImpl(o,t,a.get(),!0)),void(1!==r&&(h.get().changeEndPoints2D(u,h.get().getEndXY()),this.replaceSegmentImpl(t,m,h.get(),!0)))}}this.setXYCoordsNoCurves(t,e,s)}setXYZWithCurves(t,e){this.hasNonLinearSegments()?(this.setXYCoordsWithCurves(t,e.x,e.y),this.setAttributeNoCurves(1,t,0,e.z)):this.setXYZNoCurves(t,e)}setAttributeWithCurves(t,e,s,n){if(0===t&&this.hasNonLinearSegments()){const t=this.getXY(e);0===s?t.x=n:t.y=n,this.setXYCoordsWithCurves(e,t.x,t.y)}else this.setAttributeNoCurves(t,e,s,n)}setXY(t,e){this.setXYCoordsWithCurves(t,e.x,e.y)}setXYCoords(t,e,s){this.setXYCoordsWithCurves(t,e,s)}setXYZ(t,e){this.setXYZWithCurves(t,e)}setAttribute(t,e,s,n){this.setAttributeWithCurves(t,e,s,n)}setAttributeWithCurvesFromArray(t,e,s,n){if(0===t&&this.hasNonLinearSegments()){n<2&&i("");const t=this.getXY(e);t.x=s[0],t.y=s[1],this.setXYCoordsWithCurves(e,t.x,t.y)}else this.setAttributeFromArrayNoCurves(t,e,s,n)}setAttributeFromArray(t,e,s,n){this.setAttributeWithCurvesFromArray(t,e,s,n)}hasNonLinearSegments(){return 0!==this.getCurveCount()}getSegmentCount(){let t=this.getPointCount();if(!this.m_bPolygon){t-=this.getPathCount();for(let e=0,s=this.getPathCount();e<s;e++)this.isClosedPath(e)&&t++}return t}getSegmentCountPath(t){let e=this.getPathSize(t);return!this.isClosedPath(t)&&e>0&&e--,e}add(t,e){this===t&&s("Multi_path_impl::add");for(let s=0,n=t.getPathCount();s<n;s++)this.addPath(t,s,!e)}addPath(t,e,s){this.insertPath(-1,t,e,s)}addPathPoint2D(t,e,s){this.insertPath2D(-1,t,0,e,s)}addPathMultiPoint(t,e,s,n){s<0&&(s=t.getPointCount()-e),this.insertPointsFromMultipoint(-1,0,t,e,s,n)}addSegmentsFromPath(t,e,n,r,o){if(this===t&&s("Multi_path_impl.add_segments_from_path"),o||0!==this.getPathCount()||(o=!0),e<0&&(e=t.getPathCount()-1),(e>=t.getPathCount()||n<0||r<0||n+r>t.getSegmentCountPath(e))&&i("add_segments_from_path"),0===r)return;const a=t.getPathStart(e),h=t.isClosedPath(e)&&n+r===t.getSegmentCountPath(e);this.m_bPathStarted=!1,this.mergeVertexDescription(t.getDescription());let m=r;const l=a+n;let u=l+1;o&&(m++,u--),!o&&t.hasNonLinearSegments()&&1!==t.m_curveData.m_segmentFlags.read(l)&&(t.getXY(l).equals(this.getXY(this.m_pointCount-1))||s("add_segments_from_path: start point mismatch"));const c=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+m),this.verifyAllStreamsAfterSizeChange(),o){if(0===m)return;this.m_paths.add(this.m_pointCount);let s=t.m_pathFlags.read(e);this.m_bPolygon&&(s|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,s),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const g=h?m-1:m;for(let e=0,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),n=Bn.getComponentCount(s),i=t.m_description.getAttributeIndex(s);if(g>0){if(i<0||!t.m_vertexAttributes.get(i)){const t=Bn.getDefaultValue(s);this.m_vertexAttributes.get(e).insertRange(n*c,t,g*n,n*c),h&&this.m_vertexAttributes.get(e).insertRange(n*c+g*n,t,n,n*c);continue}this.m_vertexAttributes.get(e).insertRangeFromStream(n*c,t.m_vertexAttributes.get(i),n*u,g*n,!0,n,n*c)}h&&this.m_vertexAttributes.get(e).insertRangeFromStream(n*(c+g),t.m_vertexAttributes.get(i),n*a,n,!0,n,n*(c+g))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),t.hasNonLinearSegments()){let e=0;for(let s=0,n=l;s<r;s++)e+=Rn(t.m_curveData.m_segmentFlags.read(n)),n++;if(e>0){this.initSegmentData(e);let s=l,n=c-(o?0:1),i=0;for(let e=0;e<r;e++){const e=t.m_curveData.m_segmentFlags.read(s);if(this.m_curveData.m_segmentFlags.write(n,e),zn.isNonLinearSegmentFlag(e)){i++;let r=t.m_curveData.m_segmentParamIndex.read(s);const o=Rn(e);this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint);for(let e=0;e<o;e++){const e=t.m_curveData.m_segmentParams.read(r);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,e),this.m_curveData.m_curveParamWritePoint++,r++}this.incCurveType(e,1)}else this.m_curveData.m_segmentParamIndex.write(n,-1);n++,s++}this.modifyCurveCounter(i)}}if(h){const t=this.getPathCount()-1,e=this.getPathStart(t),s=this.getPathEnd(t)-1,n=this.getXY(e),i=this.getXY(s);n.isEqualPoint2D(i)&&(--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let t=0,e=this.getPathCount();t<e;t++)this.reversePath(t)}reversePath(t){t>=this.getPathCount()&&s("");const e=this.getPathSize(t);if(0===e)return;const n=this.getPathStart(t),i=this.isClosedPath(t);if(this.hasNonLinearSegments()){let t=n;const s=new this.m_segmentBufferCTor;let r=!1;for(let n=0;n<e;n++,t++){const e=this.m_curveData.m_segmentFlags.read(t);if(!zn.isNonLinearSegmentFlag(e))continue;r=!0,this.querySegment(t,s,!0),s.get().reverse();const n=this.m_curveData.m_segmentParamIndex.read(t);s.get().writeInBufferStream(this.m_curveData.m_segmentParams,n)}if(r){const t=i?0:1;this.m_curveData.m_segmentFlags.reverseRange(n,e-t,1),this.m_curveData.m_segmentParamIndex.reverseRange(n,e-t,1)}}const r=i?1:0;for(let t=0,s=this.m_description.getAttributeCount();t<s;t++)if(this.m_vertexAttributes.get(t)){const s=this.m_description.getSemantics(t),i=Bn.getComponentCount(s);this.m_vertexAttributes.get(t).reverseRange(i*(n+r),i*(e-r),i)}const o=6&this.m_pathFlags.read(t);if(o){let e=0;4&o&&(e|=2),2&o&&(e|=4),this.m_pathFlags.clearBits(t,6),this.m_pathFlags.setBits(t,e)}this.notifyModifiedFlags(1233)}removePath(t){const e=this.getPathCount();t<0&&(t=e-1),t>=e&&s("");const n=this.getPathStart(t),i=this.getPathSize(t);for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=Bn.getComponentCount(e);this.m_vertexAttributes.get(t).eraseRange(s*n,s*i,s*this.m_pointCount)}if(this.hasNonLinearSegments()){let t=0;for(let e=n,s=n+i;e<s;e++){const s=this.m_curveData.m_segmentFlags.read(e);zn.isNonLinearSegmentFlag(s)&&(this.incCurveType(s,-1),t++)}this.modifyCurveCounter(-t),this.m_curveData.m_segmentFlags.eraseRange(n,i,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(n,i,this.m_pointCount)}for(let s=t+1;s<=e;s++){const t=this.m_paths.read(s);this.m_paths.write(s-1,t-i)}if(this.m_pathFlags)for(let s=t+1;s<=e;s++){const t=this.m_pathFlags.read(s);this.m_pathFlags.write(s-1,t)}this.m_paths.resize(e),this.m_pathFlags.resize(e),this.m_pointCount-=i,this.m_reservedPointCount-=i,t===e-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(t,e,n,i){this===e&&s("Multi_path_impl::insert_path");const r=this.getPathCount();if(!i&&e.hasNonLinearSegmentsPath(n))return t=this.insertPath(t,e,n,!0),this.reversePath(t),t;n>=e.getPathCount()&&s(""),t>r&&s(""),t<0&&(t=r),n<0&&(n=e.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(e.getDescription());const o=e.getPathStart(n),a=e.getPathSize(n);if(0===a)return this.insertPath2D(t,null,0,0,!0);const h=this.m_pointCount,m=e.isClosedPath(n)&&!i?1:0;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const l=t<r?this.getPathStart(t):h;for(let t=0,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t),n=e.getDescription().getAttributeIndex(s),r=Bn.getComponentCount(s);if(n>=0&&e.m_vertexAttributes.get(n))0!==m&&this.m_vertexAttributes.get(t).insertRangeFromStream(l*r,e.m_vertexAttributes.get(n),r*o,r,!0,r,r*h),this.m_vertexAttributes.get(t).insertRangeFromStream((l+m)*r,e.m_vertexAttributes.get(n),r*(o+m),r*(a-m),i,r,r*(h+m));else{const e=Bn.getDefaultValue(s);this.m_vertexAttributes.get(t).insertRange(l*r,e,r*a,r*h)}}const u=h+a;this.m_paths.add(u);for(let e=r;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+a)}this.m_pathFlags.add(0);for(let e=r-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let c=e.getPathFlagsStreamRef().read(n);if(c&=-9,this.m_bPolygon&&(c|=1),this.m_pathFlags.write(t,c),e.hasNonLinearSegments()){this.initSegmentData(0);let t=o,s=0;for(let n=0;n<a;n++)s+=Rn(e.m_curveData.m_segmentFlags.read(t)),t++;if(s>0){null===this.m_curveData.m_segmentFlags?(this.m_curveData.m_segmentFlags=ke(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=Xe(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(l,1,a,h),this.m_curveData.m_segmentParamIndex.insertRange(l,-1,a,h)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+s):this.m_curveData.m_segmentParams=Re(s),t=o;let n=l,i=0;for(let s=0;s<a;s++){const s=e.m_curveData.m_segmentFlags.read(t);if(zn.isNonLinearSegmentFlag(s)){this.m_curveData.m_segmentFlags.write(n,s),this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint);const r=Rn(s);let o=e.m_curveData.m_segmentParamIndex.read(t);for(let t=0;t<r;t++){const t=e.m_curveData.m_segmentParams.read(o);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,t),this.m_curveData.m_curveParamWritePoint++,o++}i++,this.incCurveType(s,1)}t++,n++}this.modifyCurveCounter(i)}}return this.notifyModifiedFlags(2001),t}insertPath2D(t,e,n,i,r){const o=this.getPathCount();(t>o||n<0)&&s(""),t<0&&(t=o),this.m_bPathStarted=!1;const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+i),0===i&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const h=t<o?this.getPathStart(t):a;if(e)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*h,e,n,i,r,2*a);else{const t=Bn.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*h,t,2*i,2*a)}for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=Bn.getComponentCount(e),n=Bn.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(h*s,n,s*i,s*a)}this.m_paths.add(this.m_pointCount);for(let e=o;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+i)}this.m_pathFlags.add(0);for(let e=o-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}return this.m_bPolygon&&this.m_pathFlags.write(t,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h,1,i,a),this.m_curveData.m_segmentParamIndex.insertRange(h,-1,i,a)),this.notifyModifiedFlags(2001),t}insertPathFromMultipoint(t,e,n,i,r){const o=e.getImpl(),a=this.getPathCount();(t>a||n<0)&&s("");const h=i<0?o.getPointCount()-n:i;if(h>o.getPointCount()&&s(""),n>=o.getPointCount()&&s("pointsOffset"),t<0&&(t=a),this.m_bPathStarted=!1,this.mergeVertexDescription(o.getDescription()),0===h)return void this.insertPath2D(t,null,0,0,!0);const m=this.m_pointCount,l=n;this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange();const u=t<a?this.getPathStart(t):m;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=o.getDescription().getAttributeIndex(e),n=Bn.getComponentCount(e);if(s>=0){const s=o.getAttributeStreamRef(e);this.m_vertexAttributes.get(t).insertRangeFromStream(u*n,s,n*l,n*h,r,n,n*m)}else{const s=Bn.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(u*n,s,n*h,n*m)}}const c=m+h;this.m_paths.add(c);for(let e=a;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+h)}this.m_pathFlags.add(0);for(let e=a-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let g=0;this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),this.notifyModifiedFlags(2001)}insertPoints(t,e,n,r,o,a,h){if(this===n&&s("Multi_path_impl.insert_points"),t<0&&(t=this.getPathCount()),r<0&&(r=n.getPathCount()-1),(t>this.getPathCount()||e>=0&&e>this.getPathSize(t)||r>=n.getPathCount()||a>n.getPathSize(r))&&i(""),!a)return;if(this.mergeVertexDescription(n.m_description),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);let t=n.m_pathFlags.read(r);t&=-9,this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}e<0&&(e=this.getPathSize(t));const m=this.m_pointCount;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const l=this.getPathStart(t),u=l+e;a<0&&(a=n.getPathSize(r));const c=n.getPathStart(r),g=c+a;for(let t=0,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t),i=Bn.getComponentCount(s),r=n.m_description.getAttributeIndex(s);if(r<0||!n.m_vertexAttributes.get(r)){const e=Bn.getDefaultValue(s);this.m_vertexAttributes.get(t).insertRange(i*u,e,g*i,i*m);continue}this.m_vertexAttributes.get(t)?.insertRangeFromStream(i*(l+e),n.m_vertexAttributes.get(r),i*(c+o),a*i,h,i,i*m)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(l+e,1,a,m),this.m_curveData.m_segmentParamIndex.insertRange(l+e,-1,a,m),e>0&&this.isNonLinearSegment(l+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(l+e-1),-1),this.m_curveData.m_segmentFlags.write(l+e-1,1),this.m_curveData.m_segmentParamIndex.write(l+e-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,s=this.getPathCount();e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e,t+a)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(t,e,s,n,r,o){if(t<0&&(t=this.getPathCount()),(t>this.getPathCount()||e>this.getPathSize(t)||n<0)&&i(""),!r)return;t===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_bPolygon?this.m_pathFlags.add(1):this.m_pathFlags.add(0)),e<0&&(e=this.getPathSize(t));const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const h=this.getPathStart(t);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(h+e),s,n,r,o,2*a);for(let t=1,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t),n=Bn.getComponentCount(s),i=Bn.getDefaultValue(s);this.m_vertexAttributes.get(t).insertRange((h+e)*n,i,n*r,n*a)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h+e,1,r,a),this.m_curveData.m_segmentParamIndex.insertRange(h+e,-1,r,a),e>0&&this.isNonLinearSegment(h+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h+e-1),-1),this.m_curveData.m_segmentFlags.write(h+e-1,1),this.m_curveData.m_segmentParamIndex.write(h+e-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,s=this.getPathCount();e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+r);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(t,e,s,n,r,o){const a=s.getImpl(),h=this.getPathCount();t<0&&(t=this.getPathCount());const m=a.getPointCount();if((n<0||n>m)&&i(""),(r<0||n+r>m)&&(r=m-n),e<0&&(e=t<h?this.getPathSize(t):0),(t>h||t<h&&e>this.getPathSize(t)||t===h&&e>0||r<0)&&i(""),!r)return;if(this.mergeVertexDescription(a.getDescription()),t===h){this.m_paths.add(this.m_pointCount);const t=0;this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}e<0&&(e=this.getPathSize(t));const l=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const u=this.getPathStart(t),c=u+e,g=0+r;for(let t=0,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t),i=Bn.getComponentCount(s);if(a.getDescription().getAttributeIndex(s)<0){const e=Bn.getDefaultValue(s);this.m_vertexAttributes.get(t).insertRange(i*c,e,g*i,i*l);continue}const h=a.getAttributeStreamRef(s);this.m_vertexAttributes.get(t).insertRangeFromStream(i*(u+e),h,i*(0+n),r*i,o,i,i*l)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(u+e,1,r,l),this.m_curveData.m_segmentParamIndex.insertRange(u+e,-1,r,l),e>0&&this.isNonLinearSegment(u+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(u+e-1),-1),this.m_curveData.m_segmentFlags.write(u+e-1,1),this.m_curveData.m_segmentParamIndex.write(u+e-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,s=this.getPathCount();e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e,t+r)}this.notifyModifiedFlags(2001)}insertPoint2D(t,e,s){const n=this.getPathCount();t<0&&(t=n),(t>n||t<n&&e>this.getPathSize(t))&&i(""),t===n&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o,h=this.m_vertexAttributes.get(0);if(a===r)this.m_paths.write(t+1,r+1),h.writePoint2D(2*a,s);else{h.insert(2*a,s,2*r);for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=Bn.getComponentCount(e),n=Bn.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(s*a,n,s,s*r)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=n;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(t,e,s){const n=this.getPathCount();t<0&&(t=n),(t>n||t<n&&e>this.getPathSize(t))&&i(""),t===n&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o;if(a===r)this.m_paths.write(t+1,r+1),this.setPointByValNoCurves(a,s);else{const e=s.getDescription();this.m_description!==e&&this.mergeVertexDescription(e);for(let t=0,n=this.m_description.getAttributeCount();t<n;t++){const n=this.m_description.getSemantics(t),i=Bn.getComponentCount(n);if(e.hasAttribute(n))this.m_vertexAttributes.get(t).insertAttributes(i*a,s,n,i*r);else{const e=Bn.getDefaultValue(n);this.m_vertexAttributes.get(t).insertRange(i*a,e,i,i*r)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=n;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(t,e){const s=this.getPathCount();t<0&&(t=s-1),(t>=s||e>=this.getPathSize(t))&&i("Multi_path.remove_point");const n=this.getPathStart(t),r=this.isClosedPath(t);e<0&&(e=this.getPathSize(t)-1),e<0&&i("Multi_path.remove_point");const o=n+e;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=Bn.getComponentCount(e);this.m_vertexAttributes.get(t).eraseRange(s*o,s,s*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let e=0;if(o>n&&this.isNonLinearSegment(o-1))e+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(o-1),-1),this.m_curveData.m_segmentFlags.write(o-1,1),this.m_curveData.m_segmentParamIndex.write(o-1,-1);else{const s=this.getPathEnd(t);r&&n+1<s&&this.isNonLinearSegment(s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(s-1),-1),this.m_curveData.m_segmentFlags.write(s-1,1),this.m_curveData.m_segmentParamIndex.write(s-1,-1),e+=1)}this.isNonLinearSegment(o)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(o),-1),e+=1),e>0&&this.modifyCurveCounter(-e),this.m_curveData.m_segmentFlags.eraseRange(o,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(o,1,this.m_pointCount)}for(let e=s;e>=t+1;e--){const t=this.m_paths.read(e);this.m_paths.write(e,t-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(t){let e;e=t<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(t),this.removePointFromPath(e,t-this.getPathStart(e))}getNextSegmentType(t){return this.hasNonLinearSegments()?this.m_curveData.m_segmentFlags.read(t):1}getPrevSegmentTypeFromPath(t,e){if(!this.hasNonLinearSegments())return 1;const s=this.getPathStart(t);if(e>s)return this.m_curveData.m_segmentFlags.read(e-1);if(e===s){if(this.isClosedPath(t)){const e=this.getPathEnd(t);return this.m_curveData.m_segmentFlags.read(e-1)}return 1}P("")}getNumberOfCurves(t){if(!this.hasNonLinearSegments())return 0;let e=0;for(let s=this.getPathStart(t),n=this.getPathEnd(t);s<n;s++)zn.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s))&&++e;return e}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(t){return this.m_paths.read(t+1)-this.m_paths.read(t)}getPathStart(t){return this.m_paths.read(t)}getPathEnd(t){return this.m_paths.read(t+1)}getPathIndexFromPointIndex(t,e=-1){-1===e&&(e=this.m_currentPathIndex);const s=this.getPathCount(),n=zn.getPathIndexFromPointIndexImpl(this.m_paths,s,t,e);return this.m_currentPathIndex=n,n}startPathCoords(t,e){this.startPathPoint(new qe({x:t,y:e}))}startPath(t){this.startPathPoint(new qe({pt:t}))}startPath3D(t){this.startPathPoint(new qe({x:t.x,y:t.y,z:t.z}))}startPath3DCoords(t,e,s){this.startPathPoint(new qe({x:t,y:e,z:s}))}startPathPoint(t){t.isEmpty()&&s("");const e=t.getDescription();let n;if(this.m_description!==e){this.mergeVertexDescription(e);const s=new qe({vd:this.m_description});t.copyCommonAttributesTo(s),n=s}else n=t;this.m_bPathStarted?this.setPointByValNoCurves(this.m_pointCount-1,n):(this.insertPoint(-1,-1,n),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=Xe(2),this.m_paths.write(0,0),this.m_pathFlags=ke(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){null!==this.m_paths?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(t){0!==this.m_pointCount||this.m_bPathStarted||this.startPathCoords(0,0);const e=this.m_pointCount,s=this.m_paths.size()-1,n=e+t;this.m_paths.write(s,n),this.resizeImpl(n),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const t=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);1!==t&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(t,-1))}}lineToCoords(t,e){if(this.beforeNewSegment(1),1===this.m_description.getAttributeCount())this.setXYCoordsNoCurves(this.m_pointCount-1,t,e);else{const s=Ie(),n=new qe({vd:this.m_description,attribBuffer:s,initDefaultValues:!0});n.setXYCoords(t,e),this.setPointByValNoCurves(this.m_pointCount-1,n)}this.finishLineTo()}lineTo(t){this.lineToCoords(t.x,t.y)}lineTo3D(t){this.beforeNewSegment(1);const e=ye(this.m_description,Ge()),s=Ie(),n=new qe({vd:e,attribBuffer:s,initDefaultValues:!0});n.setXYZ(t),this.setPointByValNoCurves(this.m_pointCount-1,n),this.finishLineTo()}lineTo3DCoords(t,e,s){this.lineTo3D(new Se(t,e,s))}lineToPoint(t){if(this.beforeNewSegment(1),this.m_description===t.getDescription())this.setPointByValNoCurves(this.m_pointCount-1,t);else{this.mergeVertexDescription(t.getDescription());const e=Ie(),s=new qe({vd:this.m_description,attribBuffer:e,initDefaultValues:!1});t.copyCommonAttributesTo(s),this.setPointByValNoCurves(this.m_pointCount-1,s)}this.finishLineTo()}openPathAndDuplicateStartVertex(t){this.m_bPolygon&&P("");const e=this.getPathCount();if(t>e&&s(""),!this.isClosedPath(t))return;this.m_pathFlags||P("");const n=this.m_pointCount,i=this.getPathStart(t),r=this.getPathEnd(t);if(r-i!==0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=Bn.getComponentCount(e);this.m_vertexAttributes.get(t).insertRangeFromStream(s*r,this.m_vertexAttributes.get(t),s*i,s,!0,1,s*n)}for(let s=e;s>t;s--){const t=this.m_paths.read(s);this.m_paths.write(s,t+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(r,1,1,n),this.m_curveData.m_segmentParamIndex.insertRange(r,-1,1,n)),this.m_pathFlags.clearBits(t,1)}}openPath(t){this.m_bPolygon&&P(""),t>this.getPathCount()&&s(""),this.m_pathFlags||P(""),this.m_pathFlags.clearBits(t,1)}isStrongPathStart(t){return!!(2&this.m_pathFlags.read(t))}setStrongPathStart(t,e){e?this.m_pathFlags.setBits(t,2):this.m_pathFlags.clearBits(t,2)}isStrongPathEnd(t){return!!(4&this.m_pathFlags.read(t))}setStrongPathEnd(t,e){e?this.m_pathFlags.setBits(t,4):this.m_pathFlags.clearBits(t,4)}clearStrongPathEnds(){for(let t=0,e=this.getPathCount();t<e;++t)this.m_pathFlags.clearBits(t,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&P(""),this.isEmpty())return;this.m_pathFlags||P("");let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)this.isClosedPath(s)&&(this.getPathSize(s)>0?t++:this.m_pathFlags.clearBits(s,1));if(0===t)return;const s=this.hasNonLinearSegments();let n=0;const i=this.getPathCount(),r=this.m_description.getAttributeCount(),o=new Array(r);let a=null,h=null;for(let e=0;e<i;++e){const i=this.getPathStart(e),m=this.getPathSize(e),l=this.isClosedPath(e);if(m>0){const e=i+n;for(let s=0;s<r;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),r=Bn.getComponentCount(n);if(!o[s]){const e=r*(this.m_pointCount+t),i=Ae(n,e);o[s]=i}o[s].writeRange(e*r,m*r,this.m_vertexAttributes.get(s),i*r,!0,1),l&&o[s].writeRange((e+m)*r,r,this.m_vertexAttributes.get(s),i*r,!0,1)}if(s){if(null===a){const e=this.m_pointCount+t;a=ke(e),h=Xe(e)}a.writeRange(e,m,this.m_curveData.m_segmentFlags,i,!0,1),h.writeRange(e,m,this.m_curveData.m_segmentParamIndex,i,!0,1),l&&(a.write(e+m,1),h.write(e+m,-1))}}this.m_paths.write(e,i+n),l&&(this.m_pathFlags.clearBits(e,1),++n)}this.m_paths.write(i,this.m_pointCount+t),this.m_pathFlags.clearBits(i,1);for(let t=0;t<r;t++)this.m_vertexAttributes.get(t)&&this.m_vertexAttributes.set(t,o[t]);s&&(this.m_curveData.m_segmentFlags=a,this.m_curveData.m_segmentParamIndex=h),this.m_pointCount+=t,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(t){void 0===t&&(t=this.getPathCount()-1),this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&s("close_path_with_line"),t===this.getPathCount()-1&&(this.m_bPathStarted=!1);const e=this.m_pathFlags.read(t);if(1&e||this.m_pathFlags.write(t,1|e),this.m_curveData&&this.m_curveData.m_segmentFlags){const e=this.getPathEnd(t)-1,s=this.m_curveData.m_segmentFlags.read(e);1!==s&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(s,-1),this.modifyCurveCounter(-1))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(t){this.closePathWithSegment(this.getPathCount()-1,t)}closePathWithSegment(t,e){if(this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&s("close_path_with_line"),e.getEndXY().equals(this.getXY(this.getPathStart(t)))||s("close_path_with_segment: end point mismatch"),t===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(e,!1),--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount);else{this.mergeVertexDescription(e.getDescription());const n=e.getStartXY(),i=this.getPathEnd(t)-1;n.equals(this.getXY(i))||s("close_path_with_segment: start point mismatch");const r=e.getGeometryType();if(r===o.enumLine)return void this.closePathWithLine(t);{const t=kn(e);this.initSegmentData(t);const s=Un.toSegType(r),n=this.m_curveData.m_segmentFlags.read(i);if(n!==s)this.m_curveData.m_segmentParamIndex.write(i,this.m_curveData.m_curveParamWritePoint),e.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=t,this.incCurveType(s,1),1!==n?this.incCurveType(n,-1):this.modifyCurveCounter(1);else{const t=this.m_curveData.m_segmentParamIndex.read(i);e.writeInBufferStream(this.m_curveData.m_segmentParams,t)}this.m_curveData.m_segmentFlags.write(i,s)}}const n=this.m_pathFlags.read(t);1&n||this.m_pathFlags.write(t,1|n),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let t=!1;for(let e=0,s=this.m_paths.size()-1;e<s;e++){if(this.isClosedPath(e))continue;const s=this.m_pathFlags.read(e);this.m_pathFlags.write(e,1|s),t=!0}t&&this.notifyModifiedFlags(512)}isClosedPath(t){return!!(1&this.m_pathFlags.read(t))}isClosedPathInXYPlane(t){if(this.isClosedPath(t))return!0;const e=this.getPathStart(t),s=this.getPathEnd(t)-1;if(e>s)return!1;const n=this.getXY(e),i=this.getXY(s);return n.isEqualPoint2D(i)}isClosedPathIn3D(t){return n(0),!1}hasNonLinearSegmentsPath(t){if(!this.hasNonLinearSegments())return!1;for(let e=this.getPathStart(t),s=this.getPathEnd(t);e<s;e++)if(zn.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e)))return!0;return!1}isNonLinearSegment(t){return!(1&this.getSegmentFlags(t))}addEnvelope(e,s){if(e.isEmpty())return;const n=0===this.m_pointCount;if(e instanceof t)this.startPathCoords(e.xmin,e.ymin),s?(this.lineToCoords(e.xmax,e.ymin),this.lineToCoords(e.xmax,e.ymax),this.lineToCoords(e.xmin,e.ymax)):(this.lineToCoords(e.xmin,e.ymax),this.lineToCoords(e.xmax,e.ymax),this.lineToCoords(e.xmax,e.ymin));else{const t=e.getDescription(),n=Ie(),i=new qe({vd:t,attribBuffer:n,initDefaultValues:!1});for(let t=0,n=4;t<n;t++){const r=s?n-t-1:t;e.queryCornerByVal(r,i),0===t?this.startPathPoint(i):this.lineToPoint(i)}}this.closePathWithLine(),this.m_bPathStarted=!1,n&&!s&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(e.width(),e.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(t,e){if(t.isClosed()||s("add_path_from_closedSegment: segment must be closed"),e){const e=t.getReversed(),s=new qe;e.queryStart(s),this.startPathPoint(s),this.closeLastPathWithSegment(e)}else{const e=new qe;t.queryStart(e),this.startPathPoint(e),this.closeLastPathWithSegment(t)}}addSegment_(t,e){const n=t.getDescription();this.mergeVertexDescription(n);const i=Ie(),r=new qe({vd:n,attribBuffer:i,initDefaultValues:!1}),a=t.getGeometryType();if(a===o.enumLine)(e||this.isEmptyImpl())&&(t.queryStart(r),this.startPathPoint(r)),t.queryEnd(r),this.lineToPoint(r);else{let n=!1;if((e||this.isEmptyImpl())&&(n=!0),n||t.getStartXY().equals(this.getXY(this.m_pointCount-1))||s("add_segment: start point mismatch"),n&&(t.queryStart(r),this.startPathPoint(r)),this.beforeNewSegment(1),t.queryEnd(r),r.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,r);else{const t=Ie(),e=new qe({vd:this.m_description,attribBuffer:t,initDefaultValues:!1});r.copyCommonAttributesTo(e),this.setPointByVal(this.m_pointCount-1,e)}const i=kn(t);this.initSegmentData(i),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),t.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=i;const o=Un.toSegType(a);this.incCurveType(o,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,o)}}addSegment(t,e,s){s?e?this.addPathFromClosedSegment(t,!1):this.closeLastPathWithSegment(t):this.addSegment_(t,e)}interpolateAttributesRange(t,e,n,i){for(let e=t;e<n-1;e++)this.isClosedPath(e)&&s("cannot interpolate across closed paths");const r=this.m_description.getAttributeCount();if(1===r)return;const o=this.calculateSubLength2D(t,e,n,i);if(0!==o)for(let s=1;s<r;s++){const r=this.m_description.getSemantics(s);this.interpolateAttributesSemanticsImpl(r,t,e,n,i,o)}}interpolateAttributesSemantics(t,e,n,i,r){if(0===t)return;this.hasAttribute(t)||s("does not have the given attribute"),2===Bn.getInterpolation(t)&&s("angular interpolation");for(let t=e;t<i-1;t++)this.isClosedPath(t)&&s("cannot interpolate across closed paths");const o=this.calculateSubLength2D(e,n,i,r);0!==o&&this.interpolateAttributesSemanticsImpl(t,e,n,i,r,o)}interpolateAttributesPath(t,e,s){const n=this.m_description.getAttributeCount();if(1===n)return;if(e===s)return;const i=this.calculatePathSubLength2D(t,e,s);for(let r=1;r<n;r++){const n=this.m_description.getSemantics(r);this.interpolateAttributesSemanticsPathImpl(n,t,e,s,i)}}interpolateAttributesSemanticsPath(t,e,n,i){if(0===t)return;this.hasAttribute(t)||s("does not have the given attribute"),2===Bn.getInterpolation(t)&&s("angular interpolation");const r=this.calculatePathSubLength2D(e,n,i);0!==r&&this.interpolateAttributesSemanticsPathImpl(t,e,n,i,r)}interpolateAttributesSemanticsImpl(t,e,s,n,i,r){const o=this.querySegmentIterator(),a=this.getPathStart(e)+s,l=this.getPathStart(n)+i,u=Bn.getComponentCount(t),c=h(Bn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,a,c,u);const d=h(Bn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,l,d,u);const _=h(Bn.maxComponentCount(),Number.NaN);g(_,c,0,0,u);let p=0;const f=Bn.getDefaultValue(t),x=Bn.getInterpolation(t);o.resetToVertex(a,e);do{if(o.hasNextSegment()){if(o.nextSegment(),o.getStartPointIndex()===l)return;this.setAttributeFromArray(t,o.getStartPointIndex(),_,u),o.previousSegment();do{const e=o.nextSegment();if(o.getEndPointIndex()===l)return;p+=e.calculateLength2D(),m(x,c,d,_,0,u,p/r,f),o.isClosingSegment()||this.setAttributeFromArray(t,o.getEndPointIndex(),_,u)}while(o.hasNextSegment())}}while(o.nextPath())}interpolateAttributesSemanticsPathImpl(t,e,s,i,r){n(0!==t);const o=this.querySegmentIterator(),a=Bn.getInterpolation(t),l=this.getPathStart(e)+s,u=this.getPathStart(e)+i;if(u===l)return;const c=Bn.getComponentCount(t),d=h(Bn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,l,d,c);const _=h(Bn.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,u,_,c);const p=new q(0);o.resetToVertex(l,e),o.setCirculator(this.isClosedPath(e));const f=Bn.getDefaultValue(t),x=h(Bn.maxComponentCount(),Number.NaN);g(x,d,0,0,c);const y=0===r;let P=.5;do{const e=o.nextSegment();if(this.setAttributeFromArrayNoCurves(t,o.getStartPointIndex(),x,c),!y){const t=e.calculateLength2D();p.pe(t),P=p.getResult()/r}m(a,d,_,x,0,c,P,f)}while(o.getEndPointIndex()!==u)}querySegment(t,e,n){const i=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(i);r>=this.getSegmentCountPath(i)&&s("get_segment"),this.getSegmentFromPath(i,r,e,n)}getSegment(t,e){const s=new this.m_segmentBufferCTor;return this.getSegmentBuffer(t,s,e),s.releaseSegment()}getSegmentType(t){const e=this.getPathIndexFromPointIndex(t),n=t-this.getPathStart(e);return n>=this.getSegmentCountPath(e)&&s("get_segment"),this.getSegmentTypeFromPath(e,n)}getSegmentFromPath(t,e,s,n){const i=this.getPathStart(t)+e,r=this.getSegmentFlagsStreamRef();let o=1;switch(r&&(o=31&r.read(i)),o){case 1:s.createLine();break;case 2:s.createCubicBezier();break;case 4:s.createEllipticArc();break;case 8:s.createQuadraticRationalBezier();break;case 16:s.createQuadraticBezier();break;default:P("")}const a=s.get();let h,m=null;if(n?(m=fe(),a.assignVertexDescription(m)):a.assignVertexDescription(this.m_description),h=i===this.getPathEnd(t)-1&&this.isClosedPath(t)?this.getPathStart(t):i+1,Qs(a,this.getXY(i)),Js(a,this.getXY(h)),!n)for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=Bn.getComponentCount(e);for(let t=0;t<s;t++){const s=this.getAttributeAsDbl(e,i,t);a.setStartAttribute(e,t,s);const n=this.getAttributeAsDbl(e,h,t);a.setEndAttribute(e,t,n)}}if(zn.isNonLinearSegmentFlag(o)){const t=this.m_curveData.m_segmentParamIndex.read(i);a.readFromBufferStream(this.m_curveData.m_segmentParams,t)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments())return!1;if(0===this.m_curveData.m_arcCount)return!1;let t=!1;for(let e=0,s=this.getPointCount();e<s;e++)if(4===this.m_curveData.m_segmentFlags.read(e)){const s=this.m_curveData.m_segmentParamIndex.read(e);Xn(this.m_curveData.m_segmentParams,s).isNAN()&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),t=!0)}return t&&this.checkCompactSegmentParams(),t}queryPointAlongPath(t,e,n,i=!1){const r={iSegment:-1},o=i?r:{tSegment:0};if(n.setEmpty(),this.isEmpty())return r;if((t<0||t>=this.getPathCount())&&s("query_point_along_path"),e<0)return r;const a=this.getPathSize(t);if(0===a)return r;if(1===a)return this.getPointByVal(this.getPathStart(t),n),o.tSegment=0,r.iSegment=this.getPathStart(t),r;const h=this.querySegmentIteratorAtVertex(this.getPathStart(t)),m=new q(0);for(;h.hasNextSegment();){const t=h.nextSegment(),s=t.calculateLength2D(),i=m.getResult();if(m.add(s),m.getResult()>=e){let a=e-i;a>s&&(a=s);const m=t.lengthToT(a);return t.queryCoord(m,n),o.tSegment=m,r.iSegment=h.getStartPointIndex(),r}}if(this.isClosedPath(t)){const e=this.getPathStart(t);return this.getPointByVal(e,n),o.tSegment=1,r.iSegment=this.getPathEnd(t)-1,r}{const e=this.getPathEnd(t)-1;return this.getPointByVal(e,n),this.getPathSize(t)>1?(o.tSegment=1,r.iSegment=this.getPathEnd(t)-2,r):(o.tSegment=0,r.iSegment=this.getPathStart(t),r)}}queryPointsAlongPath(t,e,n,i,r,o){{let t=0;for(let a=0;a<e;++a)i&&i[a].setEmpty(),r&&(r[a]=-1),o&&(o[a]=0),t>n[a]&&s("query_points_along"),t=n[a]}const a=this.getPathSize(t);if(0===e||0===a)return 0;if(1===a){const e=this.getPathStart(t);return i&&this.getPointByVal(e,i[0]),o&&(o[0]=0),r&&(r[0]=e),1}const h=this.getPathStart(t),m=new q(0),l=this.querySegmentIteratorAtVertex(h);let u=0,c=0,g=n[u];for(;l.hasNextSegment();){const t=l.nextSegment(),s=t.calculateLength2D(),a=m.getResult();for(m.add(s);m.getResult()>=g;){let h=g-a;h>s&&(h=s);const m=t.lengthToT(h);if(i&&t.queryCoord(m,i[c]),o&&(o[c]=m),r&&(r[c]=l.getStartPointIndex()),c++,u++,g=n[u],u===e)return c}}if(this.isClosedPath(t)){const e=this.getPathStart(t),s=0;i&&this.getPointByVal(e,i[c]),o&&(o[c]=s),r&&(r[c]=e),c++}else if(this.getPathSize(t)>1){const e=this.getPathEnd(t)-2,s=1;i&&this.getPointByVal(e+1,i[c]),o&&(o[c]=s),r&&(r[c]=e),c++}return c}queryPointsAlong(t,e,n,i,r){{let o=0;for(let a=0;a<t;++a)n&&n[a].setEmpty(),i&&(i[a]=-1),r&&(r[a]=0),o>e[a]&&s("query_points_along"),o=e[a]}if(0===t)return 0;const o=new q(0),a=this.querySegmentIterator();let h=-1,m=0,l=0,u=e[m];for(;a.nextPath();)for(;a.hasNextSegment();){h=a.getPathIndex();const s=a.nextSegment(),c=s.calculateLength2D(),g=o.getResult();for(o.add(c);o.getResult()>=u;){let o=u-g;o>c&&(o=c);const h=s.lengthToT(o);if(n&&s.queryCoord(h,n[l]),r&&(r[l]=h),i&&(i[l]=a.getStartPointIndex()),l++,m++,u=e[m],m===t)return l}}if(h<0)return 0;if(this.isClosedPath(h)){const t=this.getPathStart(h),e=0;n&&this.getPointByVal(t,n[l]),r&&(r[l]=e),i&&(i[l]=t),l++}else if(this.getPathSize(h)>1){const t=this.getPathEnd(h)-2,e=1;n&&this.getPointByVal(t+1,n[l]),r&&(r[l]=e),i&&(i[l]=t),l++}return l}querySegmentIterator(){return new qn({parent:this})}querySegmentIteratorAtVertex(t){return new qn({parent:this,pointIndex:t})}queryPathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!0)}queryLoosePathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!1)}queryPathEnvelopeImpl(e,i,r){if(i instanceof Ne&&n(0,"not implemented for Envelope"),i instanceof ve&&n(0,"not implemented for Envelope3D"),(e>=this.getPathCount()||e<0)&&s(""),this.isEmpty())return void i.setEmpty();const o=this.getAttributeStreamRef(0),a=t.constructEmpty();a.setEmpty();for(let t=2*this.getPathStart(e),s=2*this.getPathEnd(e);t<s;){const e=s-t;n(!(1&e)),a.mergePointsInterleaved(o,t/2,e/2),t+=e}if(i.setCoords({env2D:a}),this.hasNonLinearSegmentsPath(e)){const s=this.querySegmentIterator();if(s.resetToPath(e),s.nextPath())for(;s.hasNextSegment();){const e=s.nextCurve();if(!e)break;{const s=t.constructEmpty();r?e.queryEnvelope(s):e.queryLooseEnvelope(s),i.mergeEnvelope2D(s)}}else n(0)}}checkCompactSegmentParams(){if(!this.m_curveData||null===this.m_curveData.m_segmentParams)return!1;if(this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const t=Rn(4)*this.m_curveData.m_arcCount+Rn(2)*this.m_curveData.m_bezierCount+Rn(8)*this.m_curveData.m_rbezier2Count+Rn(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*t>>1,10)?(this.forceCompactSegmentParams(),!0):(0===this.m_pointCount&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let t=0;for(let e=0,s=this.getPointCount();e<s;e++){const s=this.m_curveData.m_segmentFlags.read(e);zn.isNonLinearSegmentFlag(s)&&(t+=Rn(s))}const e=Re(t);let s=0;for(let t=0,n=this.getPointCount();t<n;t++){const n=this.m_curveData.m_segmentFlags.read(t);if(zn.isNonLinearSegmentFlag(n)){let i=this.m_curveData.m_segmentParamIndex.read(t);this.m_curveData.m_segmentParamIndex.write(t,s);const r=Rn(n);for(let t=0;t<r;t++)e.write(s,this.m_curveData.m_segmentParams.read(i)),s++,i++}}this.m_curveData.m_segmentParams=e,this.m_curveData.m_curveParamWritePoint=s}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(t){this.applyTransformationToPath(t,-1)}applyTransformation3D(t){n(0)}getImpl(){return this}reserve(t){this.reserveImpl(t),t>0&&!this.m_paths&&(this.m_paths=Xe(0),this.m_pathFlags=ke(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0))}reserveParts(t,e){this.reserveImpl(t),e>0&&(this.m_paths?(this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1)):(this.m_paths=Xe(0),this.m_pathFlags=ke(0),this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0)))}clone(){const t=this.createInstance();return this.copyTo(t),t}queryLimitedSegmentIterator(t){return new On(this,t)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(t){this.m_paths=t}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),null!=this.m_curveData?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(t){this.m_pathFlags=t}getSegmentIndexStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParams:null}setSegmentData(t,e,s,n){this.m_curveData||(this.m_curveData=new Un),this.m_curveData.m_segmentFlags=s,this.m_curveData.m_segmentParams=e,this.m_curveData.m_segmentParamIndex=t,this.m_curveData.m_curveParamWritePoint=n}static getPathIndexFromPointIndexImpl(t,e,s,n){if(n>=0&&n<e){if(s>=t.read(n)){if(s<t.read(n+1))return n;n++}else n--;if(n>=0&&n<e&&s>=t.read(n)&&s<t.read(n+1))return n}if(e<5){for(let n=0;n<e;n++)if(s<t.read(n+1))return n;Q("")}let i=0,r=e-1;for(;r>i;){const e=i+(r-i>>1);if(s<t.read(e))r=e-1;else{if(!(s>=t.read(e+1)))return e;i=e+1}}return i}getHighestPointIndex(t){n(t>=0&&t<this.getPathCount());const e=this.getAttributeStreamRef(0),s=this.getPathEnd(t),i=this.getPathStart(t);let r=-1;const o=new l;o.y=Number.NEGATIVE_INFINITY,o.x=Number.NEGATIVE_INFINITY;for(let t=i+0;t<s;t++){const s=e.readPoint2D(2*t);-1===o.compare(s)&&(r=t,o.setCoordsPoint2D(s))}return r}applyTransformationToPath(t,e){if(e>=this.getPathCount()&&s("apply_transformation"),this.isEmpty())return;if(t.isIdentity())return;const n=this.m_vertexAttributes.get(0);if(!(e<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(e))){let s,i;return e<0?(s=0,i=this.m_pointCount):(s=this.getPathStart(e),i=this.getPathEnd(e)),n.applyTransformation(t,2*s,i-s),void this.notifyModifiedFlags(2001)}const i=new this.m_segmentBufferCTor,r=this.getPathCount();let o=e<0?0:e;do{const s=this.getPathStart(o),r=this.getPathEnd(o),a=this.isClosedPath(o),h=n.readPoint2D(2*s);if(!this.hasNonLinearSegmentsPath(o)){n.applyTransformation(t,2*s,r-s);continue}const m=l.getNAN();for(let e=s;e<r;++e){if(1!=(31&this.m_curveData.m_segmentFlags.read(e))){const o=a&&e+1===r;o&&n.writePoint2D(2*s,h),this.getSegmentBuffer(e,i,!0),i.get().applyTransformation(t);const m=this.m_curveData.m_segmentParamIndex.read(e);i.get().writeInBufferStream(this.m_curveData.m_segmentParams,m),n.writePoint2D(2*e,i.get().getStartXY()),o&&n.writePoint2D(2*s,i.get().getEndXY());continue}const o=2*e;n.queryPoint2D(o,m),t.transformInPlace(m),n.writePoint2D(o,m)}if(o===e)break}while(++o<r);this.notifyModifiedFlags(2001)}calculateSubLength2D(t,e,s,n){const i=this.getPathStart(t)+e,r=this.getPathStart(s)+n;(r<i||i<0||r>this.getPointCount()-1)&&K("");const o=this.querySegmentIterator();let a=0;o.resetToVertex(i,t);do{for(;o.hasNextSegment();){const t=o.nextSegment();if(o.getStartPointIndex()===r)break;a+=t.calculateLength2D()}if(o.getStartPointIndex()===r)break}while(o.nextPath());return a}calculatePathSubLength2D(t,e,n){const i=this.getPathStart(t)+e,r=this.getPathStart(t)+n;(i<0||r>this.getPointCount()-1)&&K("");const o=this.querySegmentIterator();if(i>r&&(this.isClosedPath(t)||s("cannot iterate across an open path"),o.setCirculator(!0)),i===r)return 0;let a=0,h=0;o.resetToVertex(i,t);do{h+=a,a=o.nextSegment().calculateLength2D()}while(o.getStartPointIndex()!==r);return h}calculateEnvelope2D(t){return this.updateXYImpl(t)}updateXYImpl(e){const s=super.updateXYImpl(e);if(this.hasNonLinearSegments()){const n=t.constructEmpty(),i=this.querySegmentIterator();for(;i.nextPath();)for(;i.hasNextSegment();){const t=i.nextCurve();if(!t)break;e?t.queryEnvelope(n):t.queryLooseEnvelope(n),s.mergeEnvelope2D(n)}}return s}notifyModifiedAllImpl(){null!==this.m_paths&&this.m_paths.size()?this.m_pointCount=this.m_paths.read(this.m_paths.size()-1):this.m_pointCount=0}setDirtyOGCFlags(t){this.setDirtyFlagProtected(16,t)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(t){this.setDirtyFlagProtected(1024,t)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(t){return!(1&t)}addAndExplicitlyOpenAllPaths(t,e){this===t&&s("Multi_path_impl::add");let n=this.getPathCount();for(let s=0,i=t.getPathCount();s<i;s++)this.addPath(t,s,!e),this.openPathAndDuplicateStartVertex(n),n++}getSegmentFlags(t){return null!==this.m_curveData&&null!==this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.read(t):1}getSegmentBuffer(t,e,n){const i=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(i);r>=this.getSegmentCountPath(i)&&s("getSegmentBuffer"),this.getSegmentFromPath(i,r,e,n)}getSegmentTypeFromPath(t,e){const s=this.getPathStart(t)+e,n=this.getSegmentFlagsStreamRef();let i=1;switch(n&&(i=31&n.read(s)),i){case 1:return o.enumLine;case 2:return o.enumBezier;case 4:return o.enumEllipticArc;case 8:return o.enumRationalBezier2;case 16:return o.enumBezier2;default:P("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let t=!1;for(let e=0,s=this.getPathCount();e<s;e++){const s=this.getPathStart(e),n=this.getPathEnd(e),i=n-s;for(let e=s;e<n;e++){const n=31&this.m_curveData.m_segmentFlags.read(e);if(1===n)continue;2!==n&&f("ensure_xy_monotone_segments");const r=(e-s+1)%i+s,o=this.m_curveData.m_segmentParamIndex.read(e),a=T(l,4);a[0]=this.getXY(e),a[3]=this.getXY(r),a[1].x=this.m_curveData.m_segmentParams.read(o),a[1].y=this.m_curveData.m_segmentParams.read(o+1),a[2].x=this.m_curveData.m_segmentParams.read(o+2),a[2].y=this.m_curveData.m_segmentParams.read(o+3),Us(a)&&(t=!0,this.m_curveData.m_segmentParams.write(o,a[1].x),this.m_curveData.m_segmentParams.write(o+1,a[1].y),this.m_curveData.m_segmentParams.write(o+2,a[2].x),this.m_curveData.m_segmentParams.write(o+3,a[2].y))}}return t&&this.notifyModifiedFlags(2001),t}buildRasterizedGeometryAccelerator(t,e){return!1}buildQuadTreeAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new Fn),null!==this.m_accelerators.getQuadTree())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const e=Le(this);return this.m_accelerators.setQuadTree(e),!0}buildQuadTreeForPathsAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new Fn),null!==this.m_accelerators.getQuadTreeForPaths())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const e=He(this);return this.m_accelerators.setQuadTreeForPaths(e),!0}updateCurveCounter(t){this.modifyCurveCounter(t-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&(zn.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(t){t&&(this.m_curveData||(this.m_curveData=new Un),zn.st_totalCurveCount+=t,this.m_curveData.m_curveCount+=t)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(t,e){this.m_curveData||(this.m_curveData=new Un),2&t?this.m_curveData.m_bezierCount+=e:4&t?this.m_curveData.m_arcCount+=e:8&t?this.m_curveData.m_rbezier2Count+=e:16&t&&(this.m_curveData.m_bezier2Count+=e)}getCurveWritePoint(){return null!==this.m_curveData?this.m_curveData.m_curveParamWritePoint:0}initSegmentData(t){null===this.m_curveData&&(this.m_curveData=new Un);const e=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;null===this.m_curveData.m_segmentParamIndex&&(this.m_curveData.m_segmentFlags=ke(e,1),this.m_curveData.m_segmentParamIndex=Xe(e,-1));const s=this.m_curveData.m_curveParamWritePoint+t;null===this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams=Re(s):s!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(s,0),this.m_curveData.m_segmentFlags.size()<e&&(this.m_curveData.m_segmentFlags.resize(e,1),this.m_curveData.m_segmentParamIndex.resize(e,-1))}updateCurveWritePoint(t){null===this.m_curveData&&(this.m_curveData=new Un),this.m_curveData.m_curveParamWritePoint=t}updateOGCFlagsHelper(){const t=this.getPathCount();if(0===t)return;const e=this.m_pathFlags;let s=0;for(let n=0;n<t;n++){const t=this.m_cachedRingAreas2D.read(n);0===s&&(s=gt(t)),t*s>0||0===s?e.setBits(n,8):e.clearBits(n,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(t,e,i){(t<0||t>=this.getPointCount())&&s("Multi_path_impl.replace_segment"),n(e.isCurve());const r=this.getPathIndexFromPointIndex(t),o=this.getPathStart(r),a=(t-o+1)%this.getPathSize(r)+o;{const s=this.getXY(t),i=this.getXY(a),r=!s.isEqualPoint2D(e.getStartXY())||!i.isEqualPoint2D(e.getEndXY());n(!r)}this.replaceSegmentImpl(t,a,e,i)}replaceSegmentImpl(t,e,s,i){const r=s.getDescription();this.mergeVertexDescription(r);const o=h(32,Number.NaN),a=new qe({vd:r,attribBuffer:o,initDefaultValues:!1}),m=null===this.m_curveData?1:31&this.m_curveData.m_segmentFlags.read(t),l=Rn(m),u=kn(s);let c,g=!1;l>=u?(n(null!==this.m_curveData),g=!0,c=this.m_curveData.m_segmentParamIndex.read(t)):(this.initSegmentData(u),g=!1,c=this.m_curveData.m_curveParamWritePoint);const d=s.getGeometryType(),_=Un.toSegType(d);i||(s.queryStart(a),this.setPointByValNoCurves(t,a),s.queryEnd(a),this.setPointByValNoCurves(e,a)),this.m_curveData.m_segmentParamIndex.write(t,1!==_?c:-1),this.m_curveData.m_segmentFlags.write(t,_),1!==_&&s.writeInBufferStream(this.m_curveData.m_segmentParams,c),g||(this.m_curveData.m_curveParamWritePoint+=u),m!==_&&(this.incCurveType(m,-1),this.incCurveType(_,1),this.modifyCurveCounter(1===m?1:-1))}setAttributeImpl(t,e,n){if(this.addAttribute(t),!this.isEmpty())if(this.hasNonLinearSegments()&&0===t){(e<0||e>1)&&s("");const t=new Ps,i=0===e?n:0,r=0===e?0:1;t.setShiftCoords(i,r),0===e?t.xx=0:t.yy=0,this.applyTransformation(t)}else super.setAttributeImpl(t,e,n)}}zn.st_totalCurveCount=0;class On{constructor(e,s){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new t(s),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=e}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const t=this.m_parent.getAccelerators();t&&(this.m_quadTree=t.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const t=this.m_qtIter.next();if(-1===t)return null;const e=this.m_quadTree.getElement(t);return(e!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(e,this.m_segIter.getPathIndex()),this.m_prevIndex=e),this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const e=this.m_segIter.nextSegment(),s=t.constructEmpty();if(e.queryLooseEnvelope(s),!s.isIntersecting(this.m_extentOfInterest))continue;return e}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}}class Wn extends zn{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!1}),this.m_segmentBufferCTor=fm):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=fm,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=fm):t.start?(super({vd:t.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=fm,this.startPathPoint(t.start),this.lineToPoint(t.end)):t.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=fm,this.addPathPoint2D(t.path,t.pointCount,t.bForward)):P("bad constructor arg"):(super({bPolygon:!1}),this.m_segmentBufferCTor=fm)}getBoundary(){return Qn(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}assignMove(t){return t.copyTo(this),this}getGeometryType(){return Wn.type}getDimension(){return 1}createInstance(){return new Wn({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}Wn.type=o.enumPolyline;var jn=o;function Zn(t,e){if(t.isEmpty())return!1;const s=t.getGeometryType();if(s===jn.enumPolygon)return 0!==t.calculateArea2D();if(s===jn.enumPolyline)return Kn(t.getImpl(),0,!0).bNotEmpty;if(s===jn.enumEnvelope)return!0;if(F(s))return!!t.isClosed();if(V(s))return!1;if(s===jn.enumGeometryCollection){const s=t;for(let t=0,n=s.getGeometryCount();t<n;t++)if(Zn(s.getGeometry(t),e))return!0;return!1}f("")}function Qn(t,e){const s=t.getGeometryType();if(s===jn.enumPolygon){const e=new Wn({vd:t.getDescription()});return t.isEmpty()||t.copyToUnchecked(e),e}if(s===jn.enumPolyline)return Kn(t.getImpl(),0,!1).boundary;if(s===jn.enumEnvelope){const e=new Wn({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(F(s)){const e=new Fs({vd:t.getDescription()});if(!t.isEmpty()&&!t.isClosed()){const s=new qe;e.reserve(2),t.queryStart(s),e.add(s),t.queryEnd(s),e.add(s)}return e}if(s===jn.enumGeometryCollection){const s=t;let n=null;for(let i=0,r=s.getGeometryCount();i<r;i++){const r=Qn(s.getGeometry(i),e);if(null!==r){null===n&&(n=t.createInstance());const e=r;n.addGeometry(e)}}return n}if(V(s))return new qe({vd:t.getDescription()});f("")}function Kn(t,e,s){const n=!1,i=t;let r=null;if(s||(r=new Fs({vd:i.getDescription()})),!i.isEmpty()){const t=new Fe(0);for(let e=0,s=i.getPathCount();e<s;e++)if(i.getPathSize(e)>0&&!i.isClosedPathInXYPlane(e)){const s=i.getPathStart(e);t.add(s);const n=i.getPathEnd(e)-1;t.add(n)}if(t.size()>0){const e=new Ve,n=i.getAttributeStreamRef(0),o={userSort(t,e,s){const i=l.getNAN(),r=l.getNAN();s.sort(t,e,(t,e)=>(n.queryPoint2D(2*t,i),n.queryPoint2D(2*e,r),i.compare(r)))},getValue:t=>n.read(2*t+1)};e.sort(t,0,t.size(),o);let a=n.readPoint2D(2*t.read(0)),h=0,m=1;const u=new qe;for(let e=1,i=t.size();e<i;e++){const i=n.readPoint2D(2*t.read(e));if(i.isEqualPoint2D(a))t.read(h)>t.read(e)?(t.write(h,W()),h=e):t.write(e,W()),m++;else{if(1&m){if(s)return{bNotEmpty:!0,boundary:new Fs({})}}else t.write(h,W());a=i,h=e,m=1}}if(1&m){if(s)return{bNotEmpty:!0,boundary:new Fs({})}}else t.write(h,W());if(!s){t.sort(0,t.size());for(let e=0,s=t.size();e<s&&t.read(e)!==W();e++)i.getPointByVal(t.read(e),u),r.add(u)}}}return s?{bNotEmpty:n,boundary:new Fs({})}:{bNotEmpty:n,boundary:r}}function Jn(t,e,s,i){const o=4*G()*(Math.abs(e.vmin)+Math.abs(e.vmax)),a=G();if(1===t.getMaxDerivative()){n(s>0);const r=si(t,0,e,G(),o);return i[0]=r.root,r.cRoots}let h,m=[];const u=new r(e.vmin-o,e.vmax+o);m.push(new l(u.vmin,u.vmax));let c=0;for(let n=t.getMaxDerivative()-1;n>=0;n--){h=m,m=[];for(let u=0,g=h.length;u<g;u++){if(h[u][0]<h[u][1]){let g,d,_;if(n===t.getMaxDerivative()-1?({root:g,funcAtRoot:d,cRoots:_}=si(t,n,r.construct(h[u][0],h[u][1]),a,.5*o)):({root:g,funcAtRoot:d,cRoots:_}=ni(t,n,r.construct(h[u][0],h[u][1]),0,.5*o)),1===_){if(0===n)c<s&&(h[u][0]<=e.vmin&&h[u][1]>=e.vmin&&g!==e.vmin&&0===t.getValue(0,e.vmin)&&(g=e.vmin),h[u][0]<=e.vmax&&h[u][1]>=e.vmax&&g!==e.vmax&&0===t.getValue(0,e.vmax)&&(g=e.vmax),i[c]=e.snapClip(g),c>0?i[c]-i[c-1]>o&&c++:c++);else{const t=l.getNAN();t[0]=h[u][0],t[1]=g,m.push(t);const e=l.getNAN();e[0]=g,e[1]=h[u][1],m.push(e)}continue}}m.push(h[u])}}return c}function $n(t,e,s,n,i,r){const o=T(v,2),a=oi(new v(t),new v(e),new v(s),n,i,o);return r[0]=o[0].value(),r[1]=o[1].value(),a}function ti(t,e,s,n,i,r,o){const a=T(v,3),h=ai(new v(t),new v(e),new v(s),new v(n),i,r,a);return o[0]=a[0].value(),o[1]=a[1].value(),o[2]=a[2].value(),h}function ei(t,e,s,n,i,r,o,a){return function(t,e,s,n,i,r,o,a){const m=h(s*s,Number.NaN);m.fill(0),g(a,n,0,0,s);const l=h(s,Number.NaN),u=h(s,Number.NaN),c=h(s,Number.NaN);let d=t(a,s,e),_=0;for(_=0;_<100;_++){const n=d;for(let t=0;t<s;++t)u[t]=a[t];if(_%s===0){m.fill(0);for(let t=0;t<s;t++)m[t*s+t]=1}let o=0,h=0;for(let n=0;n<s;++n){for(let t=0;t<s;++t)l[t]=m[n*s+t];const u=d;d=ii(t,e,a,l,i,r,s);const c=u-d;c>o&&(h=n,o=c)}for(let t=0;t<s;t++)l[t]=a[t]-u[t],c[t]=a[t]+(a[t]-u[t]);const g=t(c,s,e);if(g<n&&2*(n-2*d+g)*ot(n-d-o)<ot(n-g)*o){d=ii(t,e,a,l,i,r,s);for(let t=0;t<s;++t)m[h*s+t]=m[(s-1)*s+t],m[(s-1)*s+t]=l[t]}if(n<=d)return t(a,s,e)}return d}(t,e,s,n,i,r,0,a)}function si(t,e,s,n,i){const r={root:0,funcAtRoot:0,cRoots:0};let o=s.vmin,a=s.vmax,h=0,m=Number.MAX_VALUE,l=t.getValue(e,o),u=t.getValue(e,a),c=0,g=0,d=0;if(l>=0&&u>=0||l<=0&&u<=0)return Math.abs(l)<Math.abs(u)?(r.funcAtRoot=l,r.root=o,r.cRoots=0===l?1:0,r):(r.funcAtRoot=u,r.root=a,r.cRoots=0===u?1:0,r);Math.abs(l)<Math.abs(u)&&(a=p(o,o=a),u=p(l,l=u)),h=o,c=l;let _=!0,f=0;for(;0!==u&&Math.abs(o-a)>n*Math.abs(a)+i;f++){let s=f>64;if(!s){g=l!==c&&u!==c?o*u*c/((l-u)*(l-c))+a*l*c/((u-l)*(u-c))+h*l*u/((c-l)*(c-u)):a-u*(a-o)/(u-l);const t=(3*o+a)/4;if(s=!(g>t&&g<a||g>a&&g<t),!s){const t=n*Math.abs(a)+i;if(_){const e=Math.abs(a-h);s=Math.abs(g-a)>=.5*e||e<t}else{const e=Math.abs(h-m);s=Math.abs(g-a)>=.5*e||e<t}}}if(s?(g=(o+a)/2,_=!0):_=!1,d=t.getValue(e,g),0===d)return r.root=g,r.funcAtRoot=d,r.cRoots=1,r;if(!s){const s=o-g,n=g-a;if(Math.abs(s)>10*Math.abs(n)){let s=a+3*n;for(let n=0;n<2;n++){const n=t.getValue(e,s);gt(l)*gt(n)>0?(o=s,l=n):s=C(o,a,.75)}}else if(Math.abs(n)>10*Math.abs(s)){let n=o-3*s;for(let s=0;s<2;++s){const s=t.getValue(e,n);gt(u)*gt(s)>0?(a=n,u=s):n=C(o,a,.25)}}}m=h,h=a,c=u,gt(l)*gt(d)<0?(a=g,u=d):(o=g,l=d),Math.abs(l)<Math.abs(u)&&(a=p(o,o=a),u=p(l,l=u)),128===f&&P("Root_finder iterations exceeded")}return r.root=a,r.funcAtRoot=u,r.cRoots=1,r}function ni(t,e,s,n,i){const r={root:0,funcAtRoot:0,cRoots:0};let o=s.vmin,a=t.getValue(e,o),h=s.vmax,m=t.getValue(e,h);if(a>=0&&m>=0||a<=0&&m<=0)return Math.abs(a)<Math.abs(m)?(r.funcAtRoot=a,r.root=o,r.cRoots=0===a?1:0,r):(r.funcAtRoot=m,r.root=h,r.cRoots=0===m?1:0,r);m<0&&(m=p(a,a=m),h=p(o,o=h));let l=.5*(o+h),u=Math.abs(h-o),c=u,g=t.getValue(e,l),d=t.getValue(e+1,l),_=4,f=1,x=0,y=0,C=1,E=0;for(;++E<100;){let s;E>32||0===d||2===C&&x>1||1===C&&_<4?(C=1,f>1&&f--):(C=2,y>1&&Math.abs(2*g)>Math.abs(u*d)&&f++),u=c;let n=!1;if(1===C)do{if(y>2){const t=16*Math.abs(u);if(.5*Math.abs(o-h)>t){const e=Math.min(o,h),n=Math.max(o,h);if(l===e){s=l,l=e+t,c=l-s;break}if(l===n){s=l,l=n-t,c=l-s;break}}}c=.5*(h-o),s=l,l=o+c,n=o===l||h===l}while(0);else for(;;){c=f*g/d,s=l,l-=c,n=l===s;const t=Math.min(o,h),e=Math.max(o,h);if(l<t){if(f>1){l=s,f--;continue}c=s-t,l=t}else if(l>e){if(f>1){l=s,f--;continue}c=s-e,l=e}break}if(n||Math.abs(c)<i){s!==l&&(g=t.getValue(e,l));break}g=t.getValue(e,l),d=t.getValue(e+1,l);const r=o,p=h;g<0?(a=g,o=l):(m=g,h=l),2===C&&(o===r&&h===p||y>1&&Math.abs(c)>=.5001*Math.abs(u))?x++:x=0,1===C?(_++,y=0):(_=0,y++)}return 100===E&&P("Root_finder iterations exceeded"),r.root=l,r.funcAtRoot=g,r.cRoots=1,r}function ii(t,e,s,n,i,r,o){const a=n.slice(0,o);let m=0;for(let t=0;t<o;t++)m+=n[t]*n[t];if(m=Math.sqrt(m),m>0)for(let t=0;t<o;t++)a[t]/=m;let l=Number.NEGATIVE_INFINITY,u=Number.POSITIVE_INFINITY;{const t=h(o,0);for(let e=0;e<o;e++)t[e]=e;t.sort((t,e)=>{const s=Math.abs(a[t]),n=Math.abs(a[e]);return s<n?-1:s>n?1:0});for(let e=0;e<o;e++){const n=t[e];if(0===a[n])continue;let o=(i[n]-s[n])/a[n],h=(r[n]-s[n])/a[n];h<o&&(h=p(o,o=h)),o>l&&(l=o),h<u&&(u=h)}}let c=0;const g=(Math.abs(l)+Math.abs(u))*G()*100,d=h(o,Number.NaN),_=a.slice();function f(n,i){for(let t=0,e=o;t<e;t++)d[t]=s[t]+n*_[t];return t(d,o,e)}g>0&&(c=function(t,e,s,n,i,r){return function(t,e,s,n,i,r){const o=qt();let a=0,h=t(a,e),m=s,l=i,u=t(m,e),c=t(l,e);h>u&&(h=u,a=m),h>c&&(h=c,a=l);let g=m,d=l,_=u,f=c;_>f&&(_=p(f,f=_),d=p(g,g=d));let x=a-g,y=g-d;const P=.5*Math.min(r,l-m),C=2*P;let E,S=0;for(E=0;E<100&&!(l-m<=C);++E){const s=m+.5*(l-m);let n=S>0;if(!n&&Math.abs(y)<=P&&(n=!0,S=3),!n){const t=a-g,e=a-d,s=t*(h-f);let i=e*(h-_),r=e*i-t*s;i=2*(i-s),i>0&&(r=-r),i=Math.abs(i),0===i||Math.abs(r)>=Math.abs(i*y/2)||r<=i*(m-a)||r>=i*(l-a)?(n=!0,S=3):(y=x,x=r/i)}n&&(y=a>=s?m-a:l-a,x=o*y,S--);let i=a+x;i<m+P?i=m+P:i>l-P&&(i=l-P);const r=t(i,e);r<h?(i>=a?(m=a,u=h):(l=a,c=h),d=g,g=a,a=i,f=_,_=h,h=r):(i<a?(m=i,u=r):(l=i,c=r),r<=_||g===a?(d=g,g=i,f=_,_=r):(r<=f||d===a||d===g)&&(d=i,f=r))}return a}(t,null,s,0,i,r)}(f,0,l,0,u,g));const x=f(c);for(let t=0,e=o;t<e;t++)s[t]=A(d[t],i[t],r[t]);return x}function ri(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setE(e.clone().negateThis().divThisE(t)),s.containsCoordinate(n.value())?1:0)}function oi(t,e,s,n,i,r){if(0===t.value())return i?(r[0].set(1),n.containsCoordinate(r[0].value())?1:0):ri(e,s,n,r[0]);if(i){let e=2;return r[0].set(1),r[1].setE(s).divThisE(t),r[1].eq(r[0])&&(r[1].set(1),e=1),n.containsCoordinate(r[1].value())||(e=1),n.containsCoordinate(r[0].value())||(e--,r[0].setE(r[1])),2===e&&r[0].value()>r[1].value()&&(r[1]=p(r[0],r[0]=r[1])),e}const o=e.clone().sqrThis().subThisE(t.clone().mulThisE(s).mulThisE(tt));if(o.lt(b))return 0;const a=new v(e.value()>=0?1:-1),h=o.clone().sqrtThis(),m=new v(-.5).mulThisE(e.clone().addThisE(a.clone().mulThisE(h)));let l=0;r[0].setE(m.divE(t));const u=new v(r[0].value()),c=new v(t.value()).mulE(u).addE(new v(e.value()).mulE(u).addE(new v(s.value())));return c.isZero()||di(r[0],t,e,s,r[0]),n.containsCoordinate(r[0].value())&&l++,0!==h.value()&&0!==m.value()?(r[l].assign(s.divE(m)),u.set(r[l].value()),c.assign(new v(t.value()).mulE(u).addE(new v(e.value()).mulE(u).addE(new v(s.value())))),c.isZero()||di(r[l],t,e,s,r[l]),n.containsCoordinate(r[l].value())&&l++,2===l&&r[0].value()>r[1].value()&&(r[1]=p(r[0],r[0]=r[1])),l):l}function ai(t,e,s,n,i,r,o){if(0===t.value())return oi(e,s,n,i,r,o);if(r){let s=1;o[0].set(1);const r=o.slice(s),a=oi(t,e.addE(t),n.negate(),i,!1,r);if(a>0){s+=a;for(let t=1;t<s;t++)o[t].eq(I)&&(o[s-1]=p(o[t],o[t]=o[s-1]),s--)}const h=o.slice(0,s);h.sort((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0);for(let t=0;t<s;++t)o[t]=h[t];return s}return function(t,e,s,n,i,r){const o=T(v,3);let a=0;const h=e.negate().divThisE(t.clone().mulThis(3));i.containsCoordinate(h.value())&&(o[0].setE(h),a=1);const m=T(v,2),l=oi(t.mul(3),e.mul(2),s,i,!1,m);if(l<0)return n.isZero()?-1:0;for(let t=0;t<l;t++)i.containsCoordinate(m[t].value())&&o[a++].setE(m[t]);_(o,0,a,(t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0);const u=T(v,5);u[0].set(i.vmin);for(let t=0;t<a;t++)u[1+t].setE(o[t]);u[1+a].set(i.vmax);const c=a+2;let g=1,d=0;{const i=u[0].clone();if(t.clone().mulThisE(i).addThisE(e).mulThisE(i).addThisE(s).mulThisE(i).addThisE(n).isZero()){const o=mi(t,e,s,n);i.setError(o.estimateError(i.value())),r[d]=i,d++,g++}}for(let o=g;o<c;o++){const a=u[o].clone(),h=t.clone().mulThisE(a).addThisE(e).mulThisE(a).addThisE(s).mulThisE(a).addThisE(n).isZero();if(h||!u[o].eq(u[o-1])){if(h||ci(u[o-1].value(),u[o].value(),u[o-1].clone().addThisE(u[o]).divThisByPower2(2),t,e,s,n,a)){if(d>0&&a.eq(r[d-1]))continue;if(d>=3&&P("cubic_polynomial_solver_too_many_roots"),h){const i=mi(t,e,s,n);a.setError(i.estimateError(a.value()))}r[d]=a,d++}if(u[o].value()===i.vmax)break;h&&o++}}return d}(t,e,s,n,i,o)}function hi(t,e,n,i,r,o){return(o<e||e<0)&&s("nth_degree_real_roots"),function(t,e,s,n,i){const r=new li(t,e,s,G());let o=0;if(2===r.truePower)o=oi(t[2],t[1],t[0],s,n,i);else if(1===r.truePower)o=ri(t[1],t[0],s,i[0]);else{if(0===r.truePower)return t[0].value()?0:-1;{const t=[];t.length=e,o=Jn(r,s,e,t);for(let e=0;e<o;e++)i[e].set(t[e])}}for(let t=0;t<o;t++)i[t].setError(r.getError(i[t].value()));return o}(t,e,n,i,r)}function mi(t,e,s,n){return{coef0:t.clone(),coef1:e.clone(),coef2:s.clone(),coef3:n.clone(),calcF(t){return this.coef0.clone().mulThis(t).addThisE(this.coef1).mulThis(t).addThisE(this.coef2).mulThis(t).addThisE(this.coef3)},calcDF(t){return this.coef0.clone().mulThis(3).mulThis(t).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t).addThisE(this.coef2)},estimateError(t){const e=Math.abs(t),s=((this.coef0.eps()*e+this.coef1.eps())*e+this.coef2.eps())*e+this.coef3.eps()+this.calcF(t).eps(),n=this.coef0.clone().mulThis(t).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t).addThisE(this.coef2);if(n.isZero()){const e=this.coef0.clone().mulThis(t).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(e.isZero()){const t=this.coef0.clone().mulThis(6);return Math.pow(6*s/Math.abs(t.value()),1/3)}return Math.sqrt(2*s/Math.abs(e.value()))}return s/Math.abs(n.value())}}}class li{updateCoefs(t){if(this.lastDeriv1===t)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===t)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let e;1===this.lastUsed?(e=this.derivCoefs2,this.lastDeriv2=t,this.lastUsed=2):(e=this.derivCoefs1,this.lastDeriv1=t,this.lastUsed=1),e.length=0;for(let s=0,n=this.truePower-t;s<=n;++s){e.push(this.coefs[s+t].clone());let n=s+t,i=n--;for(let e=1;e<t;e++)i*=n--;e[s].mulThis(i)}this.curCoefs=e}constructor(t,e,s,n){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=t,this.power=e,this.truePower=0;for(let t=e;t>=1;t--)if(0!==this.coefs[t].value()){this.truePower=t;break}}getMaxDerivative(){return this.truePower+1}getValue(t,e){let s=this.coefs;0===t?s=this.coefs:(this.updateCoefs(t),s=this.curCoefs);const n=new q(0);let i=1;for(let r=0,o=this.truePower-t;r<=o;++r)n.pe(i*s[r].value()),i*=e;return n.getResult()}getError(t){const e=Math.abs(t),s=new q(0),n=new v(1),i=new v(0);for(let t=0,r=this.power;t<=r;++t)i.addThisE(this.coefs[t].mulE(n)),s.pe(n.value()*this.coefs[t].eps()),n.mulThis(e);s.pe(i.eps());let r=1;for(let e=1;e<=this.truePower;++e){r*=e,this.updateCoefs(e);const n=new v(1),i=new v(0);for(let s=0,r=this.truePower-e;s<=r;++s)i.addThisE(this.curCoefs[s].mulE(n)),n.mulThis(t);if(!i.isZero())return Math.pow(r*s.getResult()/Math.abs(i.value()),1/e)}return 0}}function ui(t,e,s,n,i,r){let o=t,a=e,h=a-o;if(!r){let s=n.calcF(t).value(),i=n.calcF(e).value();if((s>0||s>i)&&(a=p(o,o=a),i=p(s,s=i)),s>=0||i<=0)return!1}let m,l=!1,u=s,c=0;for(;c<100;c++){const t=n.calcF(u);if(m=n.calcDF(u),m.isZero())return!1;if(!t.value()||c>3&&t.isZero()){l=!0;break}r||(t.value()<0?o=u:a=u);const e=t.value()/m.value(),s=u-e;r||(s>=o&&s<=a||s>=a&&s<=o)&&Math.abs(e)<=.5*h?(u=s,h=Math.abs(e)):(h=Math.abs(.5*(a-o)),u=.5*(o+a))}return!!l&&(i.set(u,n.estimateError(u)),!0)}function ci(t,e,s,n,i,r,o,a){return ui(t,e,s.value(),mi(n,i,r,o),a,!1)}class gi{constructor(t,e,s){this.coefs=T(v,3),this.coefs[0].setE(t),this.coefs[1].setE(e),this.coefs[2].setE(s)}calcF(t){const e=new v(t);return this.coefs[0].mulE(e).addE(this.coefs[1]).mulE(e).addE(this.coefs[2])}calcDF(t){const e=new v(t);return v.st_mulByPower2(this.coefs[0],2).mulE(e).addE(this.coefs[1])}estimateError(t){const e=Math.abs(t),s=(this.coefs[0].eps()*e+this.coefs[1].eps())*e+this.coefs[2].eps()+this.calcF(t).eps(),n=new v(2).mulE(this.coefs[0]).mul(t).addE(this.coefs[1]);if(n.isZero()){const t=this.coefs[0].value();return Math.sqrt(s/Math.abs(t))}return s/Math.abs(n.value())}}function di(t,e,s,n,i){return ui(0,0,t.value(),new gi(e,s,n),i,!0)}var _i=Ee;class pi extends fn{constructor(t){return void 0===t||X(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new l(0,0),void(this.m_weights=[1,0,1])):(t.fromPoint&&t.weight?t={fromPoint:t.fromPoint,controlPoint1:t.controlPoint1,toPoint:t.toPoint,weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weight?t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weights&&(t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:t.weights[0],weight1:t.weights[1],weight2:t.weights[2]}),t.fromPoint&&t.weight0?(super({start:t.fromPoint,end:t.toPoint}),(t.weight0<=0||t.weight1<0||t.weight2<=0)&&s("weights"),this.m_cp=t.controlPoint1.clone(),void(this.m_weights=[t.weight0,t.weight1,t.weight2])):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone(),void(this.m_weights=t.copy.m_weights.slice())):t.move?(super(t),this.m_cp=t.move.m_cp.clone(),void(this.m_weights=t.move.m_weights.slice())):void f("unexpected constructor param"))}getBoundary(){return Qn(this)}assignMove(t){return this}assignCopy(t){return t.copyTo(this),this}construct(t,e,s,n){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,1,n,1),ea(this)}constructWeights(t,e,s,n,i,r){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,n,i,r),ea(this)}constructArray(t,e){this.construct(t[0],t[1],t[2],e)}constructArrayWeights(t,e){this.dropAllAttributes(),this.setCpsAndWeightsArray(t,e),ea(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return o.enumRationalBezier2}queryEnvelope(e){if(e instanceof t){if(e.setCoords(this.getStartXY()),e.mergeNe(this.getEndXY()),e.contains(this.m_cp))return;const t=da(this);if(null!==t){const s=new l;for(const n of t.specialPoints)this.queryCoord2D(n,s),e.mergeNe(s)}else{const t=[],s=T(l,3);this.queryControlPoints(s),na(s,this.m_weights,t);const n=new l;for(const s of t)this.queryCoord2D(s,n),e.mergeNe(n)}}}applyTransformation(t){if(t instanceof Ps){const e=T(l,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}}createInstance(){return new pi({vd:this.m_description})}calculateLength2D(){return ia(this,1,!1)}calculateLowerLength2D(){return l.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return this.m_weights[1]>0?l.distance(this.getStartXY(),this.m_cp)+l.distance(this.getEndXY(),this.m_cp):l.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(t,e){return this.queryCoord2DExtension(t,e,!0)}queryCoord2DE(t,e){!function(t,e,s){const n=T(l,3);t.queryControlPoints(n);const i=[0,0,0];t.queryWeights(i),function(t,e,s,n){if(0===s.value())return void n.setE(t[0]);if(1===s.value())return void n.setE(t[2]);const i=[t[0].x.mulE(e[0]),t[1].x.mulE(e[1]),t[2].x.mulE(e[2])],r=[t[0].y.mulE(e[0]),t[1].y.mulE(e[1]),t[2].y.mulE(e[2])],o=[e[0].clone(),e[1].clone(),e[2].clone()],a=new v,h=new v,m=new v;if(s.value()<=.5){const t=xt(i[0],i[1],s),e=xt(i[1],i[2],s);a.setE(xt(t,e,s));const n=xt(r[0],r[1],s),l=xt(r[1],r[2],s);h.setE(xt(n,l,s));const u=xt(o[0],o[1],s),c=xt(o[1],o[2],s);m.setE(xt(u,c,s))}else{const t=yt(i[0],i[1],s),e=yt(i[1],i[2],s);a.setE(yt(t,e,s));const n=yt(r[0],r[1],s),l=yt(r[1],r[2],s);h.setE(yt(n,l,s));const u=yt(o[0],o[1],s),c=yt(o[1],o[2],s);m.setE(yt(u,c,s))}a.divThisE(m),h.divThisE(m);const u=new l(a.value(),h.value());Ua([t[0].value(),t[1].value(),t[2].value()],u),n.x.set(u.x,a.eps()),n.y.set(u.y,h.eps())}([Rs.constructPoint2D(n[0]),Rs.constructPoint2D(n[1]),Rs.constructPoint2D(n[2])],[new v(i[0]),new v(i[1]),new v(i[2])],e,s)}(this,t,e)}queryCoord2DExtension(t,e,s){if(s){if(t<0)return void yn(new pm({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),t,e);if(t>1)return void yn(new pm({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),t-1,e)}const n=T(l,3);this.queryControlPoints(n),Ya(n,this.m_weights,t,e)}getCoordX(t){const e=new l;return this.queryCoord2DExtension(t,e,!0),e.x}getCoordY(t){const e=new l;return this.queryCoord2DExtension(t,e,!0),e.y}cut(t,e,s){const n=new fm;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=_i.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=_i.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){!function(t,e,s){const i=T(l,3);t.queryControlPoints(i);const r=h(3,Number.NaN);t.queryWeights(r),function(t,e,s,i){s.value()<0&&s.set(0,s.eps()),s.value()>1&&s.set(1,s.eps());const r=T(Rs,4);(function(t,e,s,i,r){const o=[Rs.constructPoint2D(t[0]),Rs.constructPoint2D(t[1]),Rs.constructPoint2D(t[2])];o[2].subThisE(o[0]),o[1].subThisE(o[0]),o[0].setCoords(0,0),function(t,e,s,i,r){n(!0);const o=[t[0].clone(),t[1].clone(),t[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThisE(o[0]);o[0]=Rs.constructCoords(0,0)}const a=ha(o,e,0,i),h=function(t,e,s){if(s.toDouble()<=.5){const e=xt(t[0],t[1],s),n=xt(t[1],t[2],s);return xt(e,n,s)}{const e=yt(t[0],t[1],s),n=yt(t[1],t[2],s);return yt(e,n,s)}}(e,0,i),m=a.divE(h);r[0].setE(m);const l=[e[1].mulE(e[0]),e[2].mulE(e[0]).mul(.5),e[1].mulE(e[2])],u=ha([t[1].subE(t[0]),t[2].subE(t[0]),t[2].subE(t[1])],l,0,i).mul(2),c=h.sqr(),g=u.divE(c);r[1].setE(g)}(o,[new v(e[0]),new v(e[1]),new v(e[2])],0,i,r)})(t,e,0,s,r),i.setE(r[1])}(i,r,e,s)}(this,t,e)}cutBezierIgnoreAttributes(t,e,n){(t<0||e>1||t>e)&&s("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const i=T(l,3);this.queryControlPoints(i);const r=[0,0,0];va(i,this.m_weights,t,e,i,r),n.setControlPointsAndWeights(i,r)}splitBezierIgnoreAttributes(t,e,s){}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=_i.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return Y(r,o,a,i,_i.getDefaultValue(e))}getClosestCoordinate(t,e){return pa(this,t,r.unit(),e,-1)}getClosestCoordinateOnInterval(t,e,s=-1){return pa(this,t,0,!1,s)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&s("");const i=sa(this);let r=0;if(2===i.specialPointsCount())return 0;n(t.length>=i.specialPointsCount()-1);for(let s=1,n=i.specialPointsCount();s<n;++s)this.queryCut(i.specialPoints[s-1],i.specialPoints[s],t[r],e),r++;for(let e=0;e<r;++e)Ca(t[e].get());return r}intersectionWithAxis2D(t,e,s,n){s&&(s.length=9),n&&(n.length=9);const i=new Array(3),o=T(v,2),a=new r(0,1);let h=0;const m=T(l,3);if(this.queryControlPoints(m),t){if(i[0]=new v(m[0].y).sub(e).mul(this.m_weights[0]),i[1]=new v(m[1].y).sub(e).mul(this.m_weights[1]),i[2]=i[0].subE(i[1].mul(2)).addE(new v(m[2].y).sub(e).mul(this.m_weights[2])),i[1]=i[1].subE(i[0]).mulThisByPower2(2),h=oi(i[2],i[1],i[0],a,!1,o),s)for(let t=0;t<h;t++)s[t]=this.getCoordX(o[t].value())}else if(i[0]=new v(m[0].x).sub(e).mul(this.m_weights[0]),i[1]=new v(m[1].x).sub(e).mul(this.m_weights[1]),i[2]=i[0].subE(i[1].mul(2)).addE(new v(m[2].x).sub(e).mul(this.m_weights[2])),i[1]=i[1].subE(i[0]).mulThisByPower2(2),h=oi(i[2],i[1],i[0],a,!1,o),s)for(let t=0;t<h;t++)s[t]=this.getCoordY(o[t].value());if(n)for(let t=0;t<h;t++)n[t]=o[t].value();else s&&_(s,0,h,at);return h}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[Number.NaN,Number.NaN],i=this.intersectionWithAxis2D(!0,t,s,null);return n(2!==i),-1===i?e:s[0]}isCurve(){return!0}isDegenerate(t){return Os(this,t)}isDegenerate3D(t,e){return!1}queryLooseEnvelope(e){if(e instanceof t)return e.setCoords({pt:this.getStartXY()}),e.mergeNe(this.m_cp),void e.mergeNe(this.getEndXY())}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(e,s){if(0===e){const e=t.constructEmpty();this.queryEnvelope(e);const n=r.constructEmpty();return 0===s?e.queryIntervalX(n):e.queryIntervalY(n),n}return super.queryInterval(e,s)}queryLooseEnvelopeOnInterval(t,e){const s=T(l,3);this.queryControlPoints(s),va(s,this.m_weights,t.vmin,t.vmax,s,[0,0,0]),e.setFromPoints(s,3)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return ia(this,t,!0)}lengthToT(t){const e=function(t,e){const s=ia(t,1,!1);if(e<=0)return e;if(e>=s)return e-s+1;const n=[0];return 1!==Jn(new ua(t,e),r.unit(),1,n)&&P(""),n[0]}(this,t);return e}calculateWeightedAreaCentroid2D(t){const e=function(t){const e=T(l,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),function(t,e){const s=ka(e);if(1===s){const e=T(l,3);fr(t,e);const s=e[2].clone(),n=e[1].clone(),i=new l,r=s.y*n.x-s.x*n.y;return i.x=-(4*s.x+5*n.x)*r/60,i.y=-(4*s.y+5*n.y)*r/60,i}if(0===s)return new l(0,0);n(s>0);const i=t[1].sub(t[0]),r=t[2].sub(t[0]);if(s<1){const t=Math.sqrt(1-s),e=Math.sqrt(1+s),n=(i.y*r.x-i.x*r.y)*s/Math.pow(t*e,5)/12,o=Math.atan2(t,e),a=s*t*e,h=s*s,m=i.mul(2*(2+h)),l=r.mul(2*h-5),u=m.add(l).mul(a),c=r.sub(i.mul(2*h)).mul(6*o);return u.add(c).mul(n)}{const t=Math.sqrt(s-1),e=Math.sqrt(s+1),n=(i.y*r.x-i.x*r.y)*s/Math.pow(t*e,5)/12,o=Math.atanh(t/e),a=s*t*e,h=s*s,m=i.mul(4).sub(r.mul(5)),l=i.add(r).mul(2*h),u=m.add(l).mul(a),c=r.sub(i.mul(2*h)).mul(6*o);return u.add(c).mul(n)}}(e,s)}(this),s=ca(this);return e.x+=(this.getStartX()-t.x)*s,e.y+=(this.getStartY()-t.y)*s,e}calculateWeightedCentroid2D(){const t=new l;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){if(0===t.m_weights[1])return!0;const e=l.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,e,n){void 0===n&&(n=e,e=0);const i=new l;if(e<0||n>1)return i.setNAN(),i;if(e>n&&s("calculate_sub_weighted_centroid"),e===n||t.isDegenerate(0))return i.setCoords(0,0),i;const r=sa(t),o=ga(t),a=o/t.calculateUpperLength2D();let h=e,m=0;for(let t=1,s=r.specialPointsCount();t<s;t++)if(e<r.specialPoints[t]){m=t-1;break}i.setCoords(0,0);for(let e=m+1,s=r.specialPointsCount();e<s;e++){const s=Math.min(r.specialPoints[e],n),m=ta(t,h,s,a,o);if(i.addThis(m),h=s,n<=r.specialPoints[e])break}return i.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryWeights(t){for(let e=0;e<3;++e)t[e]=this.m_weights[e]}queryCoord2DMP(t,e){const s=T(l,3);return this.queryControlPoints(s),function(t,e,s,n){const i=s.lte(et)?y.lerpLo:y.lerpHi,[r,o,a]=[e.map((e,s)=>t[s].x.mul(e)),e.map((e,s)=>t[s].y.mul(e)),e].map(([t,e,n])=>i(i(t,e,s),i(e,n,s),s)),h=new l(r.divThis(a).value(),o.divThis(a).value());Ua(t.map(t=>t.asPoint2D()),h),n.x=y.constructDouble(h.x),n.y=y.constructDouble(h.y)}(s.map(t=>Hs.constructPoint2D(t)),this.m_weights.map(t=>y.constructDouble(t)),y.constructDouble(t),e)}setWeights(t){}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),3}setControlPointsAndWeights(t,e){this.setCpsAndWeightsArray(t,e),this.afterCompletedModification()}getTangent(t){const e=T(l,3);return this.queryControlPoints(e),la(e,this.m_weights,t)}getDerivative(t){const e=A(t,0,1),s=T(l,4);return ra(this,1,e,s),s[1]}getCurvature(t){const e=T(l,4);ra(this,2,t,e);const s=e[1].sqrLength();return 0===s?Number.NaN:(e[1].divThis(Math.sqrt(s)),e[1].crossProduct(e[2])/s)}isIntersecting(t,e,s){return!1}isIntersectingPoint(t,e,s){return!1}isIntersectingPoint3D(t,e,s,n,i=1){return!1}isMonotoneQuickAndDirty(){const t=T(l,3);return this.queryControlPoints(t),Pa(t)}getMonotonicPartParams(t,e){const n=sa(this),i=n.specialPointsCount();if(!e)return n.specialPointsCount();t<i&&s("");for(let t=0;t<i;t++)e[t]=n.specialPoints[t];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=p(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=p(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=p(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=p(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(t){const e=T(l,3);this.queryControlPoints(e);const s=e[2].sub(e[0]),n=s.length();if(l.distance(e[0],e[1])+l.distance(e[2],e[1])-n>t)return!1;const i=t,r=e[1].clone();return r.subThis(e[0]),!(Math.abs(r.crossProduct(s))/n>i)}copyIgnoreAttributes(t){const e=T(l,3);this.queryControlPoints(e);const s=[0,0,0];this.queryWeights(s),t.setControlPointsAndWeights(e,s)}calculateArea2DHelper(){return ca(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(t){return n(0),0}queryEnvelopeW(t,e){xa(this,t,e)}setSegmentFromCoordsForStitcher(t,e){const s=[0,0,0];this.queryWeights(s),this.constructWeights(t[0],this.getControlPoint1(),t[e-1],s[0],s[1],s[2])}writeInBufferStream(t,e){const s=new Float64Array(5);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,s[2]=this.m_weights[0],s[3]=this.m_weights[1],s[4]=this.m_weights[2],t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(5);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_weights[0]=s[2],this.m_weights[1]=s[3],this.m_weights[2]=s[4],this.m_cachedValues=null}snapControlPoints(t){const e=T(l,3);this.queryControlPoints(e);const s=l.sqrDistance(e[1],e[0]),n=l.sqrDistance(e[1],e[2]);let i=e[0].clone(),r=s;s>n&&(i=e[2].clone(),r=n);let o=!1;return r<=t&&0!==r&&(o=!0,this.setControlPoint1(i)),o}needsSnapControlPoints(t){if(!t)return!1;const e=T(l,3);this.queryControlPoints(e);const s=l.sqrDistance(e[1],e[0]),n=l.sqrDistance(e[1],e[2]);e[0].clone();let i=s;return s>n&&(e[2].clone(),i=n),i<=t&&0!==i}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return Ca(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new Ps,o=T(l,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new l;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=T(l,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformInPlace(t.m_cp):st(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),i&&Ca(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),e.m_weights[0]=this.m_weights[0],e.m_weights[1]=this.m_weights[1],e.m_weights[2]=this.m_weights[2],_a(e,da(this))}reverseImpl(){this.m_weights[2]=p(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(t){const e=t;if(!this.m_cp.equals(e.m_cp))return!1;for(let t=0;t<3;t++)if(this.m_weights[t]!==e.m_weights[t])return!1;return!0}equalsImplTol(t,e){const s=t;if(!this.m_cp.isEqualPoint2D(s.m_cp,e))return!1;const n=T(l,3);this.queryControlPoints(n);const i=T(l,3);s.queryControlPoints(i);const r=[s.m_weights[0],s.m_weights[1],s.m_weights[2]];for(let t=0;t<3;t++){const s=new Se;s.setCoordsPoint2DZ(n[t].mul(this.m_weights[t]),this.m_weights[t]);const o=new Se;if(o.setCoordsPoint2DZ(i[t].mul(r[t]),r[t]),!s.isEqual(o,e))return!1}return!0}swapImpl(t){const e=t;var s;e.m_cp=p(this.m_cp,this.m_cp=e.m_cp),e.m_weights=p(this.m_weights,this.m_weights=e.m_weights),(s=e).m_cachedValues=p(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){ea(this)}intersect(t,e,s,n,i){return lm(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,i){const o=new Vs;if(xa(t,r.unit(),o),o.inflate(i),!o.isIntersectingPoint2D(e))return 0;const a=sa(t);let h=0;const m=[];let l=a.specialPoints[0];for(let s=1,i=a.specialPoints.length;s<i;++s){const i=a.specialPoints[s],r=$o(t,e,l,i);if(0===m.length)m.push(r);else if(r.t===r.tmin)n(m.at(-1).d<=r.d),m.at(-1).tmax=r.tmax;else if(m.at(-1).t===m.at(-1).tmax){n(m.at(-1).d>=r.d);const t=m.at(-1).tmin;m[m.length-1]=r,m.at(-1).tmin=t}else m.push(r);l=i}for(const t of m)if(t.d<=i){const e=t.t;s?(s[h]=e,h++):h++}return h}(this,t,e,s)}endPointModified(){ea(this)}clearEndPointModified(){}setCpsAndWeights(t,e,n,i,r,o){(i<=0||o<=0||r<0)&&s("weights"),(t.isNAN()||e.isNAN()||n.isNAN())&&s("NAN control points in bezier are not supported"),this.setStartXY(t),this.m_cp.assign(e),this.m_weights[0]=i,this.m_weights[1]=r,this.m_weights[2]=o,this.setEndXY(n)}setCpsAndWeightsArray(t,e){this.setCpsAndWeights(t[0],t[1],t[2],e[0],e[1],e[2])}}pi.type=o.enumRationalBezier2;var fi=Ee;class xi extends fn{constructor(t){void 0===t||X(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new l(0,0)):t.from?(super({XStart:t.from.x,YStart:t.from.y,XEnd:t.to.x,YEnd:t.to.y,...t.vd}),this.m_cp=t.cp.clone()):t.points?(super({XStart:t.points[0].x,YStart:t.points[0].y,XEnd:t.points[2].x,YEnd:t.points[2].y,...t.vd}),this.m_cp=t.points[1].clone()):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone()):P("unexpected constructor args")}getBoundary(){return Qn(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}construct(t,e,s){this.setStartXY(t),this.m_cp.assign(e),this.setEndXY(s),zi(this)}constructPoints(t){this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),zi(this)}getGeometryType(){return o.enumBezier2}queryEnvelope(t){if(2===t.m_EnvelopeType){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=sr(this);if(null!==e){const s=new l;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[];Wi(this,e);const s=new l;for(const n of e)this.queryCoord2D(n,s),t.mergeNe(s)}return}f("env type not impl")}applyTransformation(t){if(1===t.m_TransformationType){const e=T(l,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}n(0)}createInstance(){return new xi({vd:this.m_description})}calculateLength2D(){return ji(this,1,!1)}calculateLowerLength2D(){return l.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return l.distance(this.getStartXY(),this.m_cp)+l.distance(this.getEndXY(),this.m_cp)}queryCoord2D(t,e){this.queryCoord2DExtended(t,e,!1)}queryCoord2DExtended(t,e,s){const n=T(l,3);this.queryControlPoints(n),yr(n,t,e,s)}queryCoord2DE(t,e){!function(t,e,s){const n=T(l,3);t.queryControlPoints(n),function(t,e,s){if(e.value()<=.5){const n=Rs.constructPoint2D(t[1]),i=new Rs;J(2,Rs.constructPoint2D(t[0]),n,e,i);const r=new Rs;J(2,n,Rs.constructPoint2D(t[2]),e,r);const o=new Rs;J(2,i,r,e,o),s.setE(o)}else{const n=Rs.constructPoint2D(t[1]),i=new Rs;$(2,Rs.constructPoint2D(t[0]),n,e,i);const r=new Rs;$(2,n,Rs.constructPoint2D(t[2]),e,r);const o=new Rs;$(2,i,r,e,o),s.setE(o)}}(n,e,s)}(this,t,e)}queryCoord2DMP(t,e){n(!1,"bernstein polynomials not ported")}getCoordX(t){if(t<0||t>1){const e=new l;return this.queryCoord2DExtended(t,e,!0),e.x}if(t<=.5){const e=k(this.getStartX(),this.m_cp.x,t),s=k(this.m_cp.x,this.getEndX(),t);return k(e,s,t)}{const e=R(this.getStartX(),this.m_cp.x,t),s=R(this.m_cp.x,this.getEndX(),t);return R(e,s,t)}}getCoordY(t){if(t<0||t>1){const e=new l;return this.queryCoord2DExtended(t,e,!0),e.y}if(t<=.5){const e=k(this.getStartX(),this.m_cp.x,t),s=k(this.m_cp.x,this.getEndX(),t);return k(e,s,t)}{const e=R(this.getStartY(),this.m_cp.y,t),s=R(this.m_cp.y,this.getEndY(),t);return R(e,s,t)}}cut(t,e,s){const n=new fm;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=fi.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=fi.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){!function(t,e,s){const n=T(l,4);t.queryControlPoints(n),function(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(function(t,e,s){{const e=Rs.constructPoint2D(t[1]).subE(Rs.constructPoint2D(t[0])),n=new v(1).subE(s),i=Rs.constructPoint2D(t[2]).subE(Rs.constructPoint2D(t[1])),r=e.mulE(n).addE(i.mulE(s));return r.mulThisE(new v(2)),r}}(t,0,e))}(n,e,s)}(this,t,e)}cutBezierIgnoreAttributes(t,e,n){if((t<0||e>1||t>e)&&s("Quadratic_bezier.cut_bezier_ignore_attributes"),0===t&&1===e)return n.setStartXY(this.getStartXY()),n.m_cp.assign(this.m_cp),void n.setEndXY(this.getEndXY());const i=T(l,3);this.queryControlPoints(i),ur(i,t,e,i),n.constructPoints(i)}splitBezierIgnoreAttributes(t,e,s){n(0)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=fi.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return Y(r,o,a,i,fi.getDefaultValue(e))}getClosestCoordinate(t,e){return ir(this,t,r.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return ir(this,t,e,!1)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&s("");const i=Oi(this);let r=0;if(2===i.specialPointsCount())return 0;n(t.length>=i.specialPointsCount()-1);for(let s=1,n=i.specialPointsCount();s<n;++s)this.queryCut(i.specialPoints[s-1],i.specialPoints[s],t[r],e),r++;for(let e=0;e<r;++e)hr(t[e].get());return r}intersectionWithAxis2D(t,e,s,n){const i=T(v,3),o=T(v,2),a=new r(0,1);let h=0;if(t){if(i[0]=new v(this.getStartY()).sub(e),i[1]=new v(this.m_cp.y).subE(new v(this.getStartY())).mulThisByPower2(2),i[2]=new v(this.getStartY()).add(this.getEndY()).subE(new v(this.m_cp.y).mulThisByPower2(2)),h=oi(i[2],i[1],i[0],a,!1,o),s)for(let t=0;t<h;t++)s[t]=this.getCoordX(o[t].value())}else if(i[0]=new v(this.getStartX()).sub(e),i[1]=new v(this.m_cp.x).subE(new v(this.getStartX())).mulThisByPower2(2),i[2]=new v(this.getStartX()).add(this.getEndX()).subE(new v(this.m_cp.x).mulThisByPower2(2)),h=oi(i[2],i[1],i[0],a,!1,o),s)for(let t=0;t<h;t++)s[t]=this.getCoordY(o[t].value());if(n)for(let t=0;t<h;t++)n[t]=o[t].value();else s&&L(s,h);return h}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0],i=this.intersectionWithAxis2D(!0,t,s,null);return n(2!==i),-1===i?e:s[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(t){return Os(this,t)}isDegenerate3D(t,e){return n(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords(this.getStartXY()),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY());n(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(e,s){if(0===e){const e=new t;this.queryEnvelope(e);const n=new r;return 0===s?e.queryIntervalX(n):e.queryIntervalY(n),n}return super.queryInterval(e,s)}queryLooseEnvelopeOnInterval(t,e){const s=T(l,4);this.queryControlPoints(s),ur(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return ji(this,t,!0)}lengthToT(t){const e=function(t,e){const s=ji(t,1,!1);if(e<=0)return e;if(e>=s)return e-s+1;const n=[0];return 1!==Jn(new Bi(t,e),r.unit(),1,n)&&P(""),n[0]}(this,t);return e}calculateWeightedAreaCentroid2D(t){const e=T(l,3);!function(t,e,s=!1){const n=T(l,3);t.queryControlPoints(n),fr(n,e,s)}(this,e);const s=e[2],n=e[1],i=new l,r=s.y*n.x-s.x*n.y;i.x=-(4*s.x+5*n.x)*r/60,i.y=-(4*s.y+5*n.y)*r/60;const o=tr(this);return i.x+=(e[0].x-t.x)*o,i.y+=(e[0].y-t.y)*o,i}calculateWeightedCentroid2D(){const t=new l;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){const e=l.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,e,n){void 0===n&&(n=e,e=0);const i=new l;if(e<0||n>1)return i.setNAN(),i;if(e>n&&s("calculate_sub_weighted_centroid"),e===n||t.isDegenerate(0))return i.setCoords(0,0),i;const r=Oi(t),o=hn(t),a=Math.min(o/t.calculateUpperLength2D(),1e-7);let h=e,m=0;for(let t=1,s=r.specialPointsCount();t<s;t++)if(e<r.specialPoints[t]){m=t-1;break}i.setCoords(0,0);for(let e=m+1,s=r.specialPointsCount();e<s;e++){const s=Math.min(r.specialPoints[e],n),m=Ui(t,h,s,a,o);if(i.addThis(m),h=s,n<=r.specialPoints[e])break}return i.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),3}setControlPoints(t){for(let e=0;e<3;e++)t[e].isNAN()&&s("NaN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp.setCoordsPoint2D(t[1]),this.m_XEnd=t[2].x,this.m_YEnd=t[2].y,this.afterCompletedModification()}getTangent(t){const e=A(t,0,1);let s=Ji(this,1,e);return s.isZero()&&(s=Ji(this,2,e),1===e&&s.negateThis()),s}getDerivative(t){return Ji(this,1,A(t,0,1))}getCurvature(t){const e=Ji(this,1,t),s=Ji(this,2,t),n=e.sqrLength();return 0===n?Number.NaN:(e.divThis(Math.sqrt(n)),e.crossProduct(s)/n)}isIntersecting(t,e,s){return 0!==om(!1,this,t,e,s)}isIntersectingPoint(e,s,n){if(n&&(e.isEqualPoint2D(this.getStartXY())||e.isEqualPoint2D(this.getEndXY())))return!1;const i=new t;if(this.queryLooseEnvelope(i),i.inflateCoords(s,s),!i.contains(e))return!1;const r=this.getClosestCoordinate(e,!1),o=new l;return this.queryCoord2D(r,o),l.distance(o,e)<=s}isIntersectingPoint3D(t,e,s,i,r=1){return n(0),!1}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(t,e){const n=Oi(this),i=n.specialPointsCount();if(!e)return n.specialPointsCount();t<i&&s("");for(let t=0;t<i;t++)e[t]=n.specialPoints[t];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){p(this.m_XStart,this.m_XStart=this.m_XEnd),p(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=p(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isDegenerateToLineHelper(t){const e=T(l,3);this.queryControlPoints(e);const s=e[2].sub(e[0]),n=s.length();if(l.distance(e[0],e[1])+l.distance(e[2],e[1])-n>t)return!1;const i=t,r=e[1].clone();return r.subThis(e[0]),!(Math.abs(r.crossProduct(s))/n>i)}copyIgnoreAttributes(t){const e=T(l,3);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return tr(this)}absNorm(){return(t=this).getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp.norm(1);var t}queryEnvelopeW(t,e){const s=T(l,3);this.queryControlPoints(s),or(s,t,e)}setSegmentFromCoordsForStitcher(t,e){this.construct(t[0],this.getControlPoint1(),t[e-1])}snapControlPoints(t){return function(t,e){const s=T(l,3);t.queryControlPoints(s);const n=l.sqrDistance(s[1],s[0]),i=l.sqrDistance(s[1],s[2]);let r=s[0].clone(),o=n;n>i&&(r=s[2].clone(),o=i);let a=!1;return o<=e&&0!==o&&(a=!0,t.setControlPoint1(r)),a}(this,t)}writeInBufferStream(t,e){const s=new Float64Array(2);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(2);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_cachedValues=null}needsSnapControlPoints(t){return function(t,e){if(!e)return!1;const s=T(l,3);t.queryControlPoints(s);const n=l.sqrDistance(s[1],s[0]),i=l.sqrDistance(s[1],s[2]);s[0].clone();let r=n;return n>i&&(s[2].clone(),r=i),r<=e&&0!==r}(this,t)}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return hr(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new Ps,o=T(l,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new l;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=T(l,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformInPlace(t.m_cp):st(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),i&&hr(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),nr(e,sr(this))}reverseImpl(){}equalsImplTol(t,e){const s=t;return!!this.m_cp.isEqualPoint2D(s.m_cp,e)}equalsImpl(t){const e=t;return!!this.m_cp.equals(e.m_cp)}swapImpl(t){const e=t;var s;e.m_cp=p(this.m_cp,this.m_cp=e.m_cp),(s=e).m_cachedValues=p(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){zi(this)}intersect(t,e,s,n,i){return lm(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,n,i){const o=new Vs;if(function(t,e,s){const n=T(l,3);t.queryControlPoints(n),or(n,e,s)}(t,r.unit(),o),o.inflate(i),!o.isIntersectingPoint2D(e))return 0;const a=new l,h=ir(t,e,r.unit(),!1);return t.queryCoord2D(h,a),l.distance(a,e)<=i?(n&&(n[0]=h),1):0}(this,t,e.length,e,s)}endPointModified(){zi(this)}clearEndPointModified(){}}xi.type=o.enumBezier2;class yi{constructor(t){return t.coefsT?(this.m_zeroCtor=t.zeroCtor,this.m_elements=t.coefsT.map(t=>t.clone()),n(this.m_elements.length===t.power+1),void this.updatePower()):t.coef0?(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[t.coef0.clone()])):t.copy?(this.m_zeroCtor=t.copy.m_zeroCtor,void(this.m_elements=t.copy.m_elements.map(t=>t.clone()))):(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(t,e){return this.m_elements=t.map(t=>t.clone()),this.updatePower(),this}construct0(t){return this.m_elements.length=0,this.m_elements.push(t.clone()),this.updatePower(),this}assignCopy(t){return this.m_elements=t.m_elements.map(t=>t.clone()),this.updatePower(),this}assignMove(t){return this.m_elements=t.m_elements,t.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(t){this.m_elements.push(t.clone())}scaleRangeToUnitInterval(t,e){const s=e;s.subThis(t);const n=this.power();for(let e=0;e<=n;e++){const i=new this.m_zeroCtor;for(let s=e;s<=n;s++){const n=this.m_elements[s];n.mulDoubleThis(At(s,e));const r=t.pow(s-e);n.mulThis(r),i.addThis(n)}const r=s.pow(e);i.mulThis(r),this.m_elements[e]=i}}fmSubThis(t,e){return n(0),this}addThis(t){const e=Math.min(this.power(),t.power());for(let s=0;s<=e;++s)this.m_elements[s].addThis(t.m_elements[s]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n];return this.updatePower(),this}add0(t){return this.m_elements[0].addThis(t),this.updatePower(),this}addNumber0(t){return n(0),this}sub(t){const e=Math.min(this.power(),t.power());for(let s=0;s<=e;++s)this.m_elements[s].subThis(t.m_elements[s]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0(t){return n(0),this}subNumber0(t){return n(0),this}subShifted(t,e){const s=this.power(),n=t.power()+e,i=Math.min(this.power(),n);let r=0;for(let s=e;s<=i;++s)this.m_elements[s].subThis(t.m_elements[r]),r++;if(n<=s)return this.updatePower(),this;this.m_elements.length=n+1;for(let t=s+1;t<this.m_elements.length;++t)this.m_elements[t]=new this.m_zeroCtor;for(let e=i+1;e<=n;++e)this.m_elements[e].subThis(t.m_elements[r++]);return this.updatePower(),this}subShiftedWithCoef(t,e,s){const n=this.power(),i=t.power()+s,r=Math.min(this.power(),i);let o=0;for(let n=s;n<=r;++n)this.m_elements[n].fmSubThis(t.m_elements[o],e),o++;if(i<=n)return this.updatePower(),this;this.m_elements.length=i+1;for(let t=n+1;t<this.m_elements.length;++t)this.m_elements[t]=new this.m_zeroCtor;for(let s=r+1;s<=i;++s)this.m_elements[s].fmSubThis(t.m_elements[o++],e);return this.updatePower(),this}mulThis(t){if(this.constructor===t.constructor){const e=t,s=[];for(let t=0,n=this.power();t<=n;t++)for(let n=0,i=e.power();n<=i;n++){const i=this.m_elements[t].clone();i.mulThis(e.m_elements[n]),t+n<s.length?s[t+n].addThis(i):s.push(i)}this.m_elements=s}else for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulElementThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulDoubleThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulDoubleThis(t);return this.updatePower(),this}mulNumber0(t){return n(0),this}mulBigint0(t){return n(0),this}mulBigIntThis(t){return n(0),this}mulInt320(t){return n(0),this}div0(t){return n(0),this}absThis(){return n(0),this}div(t,e,s){if(this.power()<t.power())return s.assignCopy(this),void e.setZero();s.setZero(),e.setZero();const n=t.getElement(t.power()),i=this.clone();let r=i.power();const o=i.power()-t.power();let a=o;for(e.m_elements=T(e.m_zeroCtor,o+1);;){if(r<t.power()){s.assignMove(i);break}if(r===i.power()){const s=i.getElement(i.power());s.divThis(n),i.subShiftedWithCoef(t,s,i.power()-t.power()),e.m_elements[a]=s.clone()}a--,r--}s.updatePower(),e.updatePower()}divThis(t){return n(0),this}subThis(t){const e=Math.min(this.power(),t.power());for(let s=0;s<=e;++s)this.m_elements[s].subThis(t.m_elements[s]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0This(t){return this.m_elements[0].subThis(t),this.updatePower(),this}subFrom(t,e){n(0)}isZero(){return 0===this.power()&&this.m_elements[0].isZero()}negateThis(){for(let t=this.m_elements.length-1;t>=0;t--)this.m_elements[t].negateThis();return this}getElement(t){return this.m_elements[t].clone()}setElement(t,e){return this.m_elements[t]=e.clone(),this}evaluate(t){const e=this.power(),s=this.m_elements[e].clone();for(let n=e-1;n>=0;--n)s.mulThis(t),s.addThis(this.m_elements[n]);return s}equals(t){if(this===t)return!0;if(this.power()!==t.power())return!1;for(let e=this.m_elements.length-1;e>=0;e--)if(!this.m_elements[e].equals(t.m_elements[e]))return!1;return!0}updatePower(){for(let t=this.m_elements.length-1;t>0&&this.m_elements[t].isZero();t--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(t){if(this.power()<t)return this.clone().setZero();if(0===t)return this.clone();const e=new this.constructor({coefsT:this.m_elements.slice(t),power:this.power()-t});for(let s=t,n=this.power();s<=n;s++){let n=BigInt(s);for(let e=s-1,i=s-t;e>i;--e)n*=BigInt(e);e.m_elements[s-t].mulBigIntThis(n)}return e.updatePower(),e}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let t=1,e=this.power();t<=e;t++)this.m_elements[t].mulThis(y.constructInt32(t+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(t){for(let e=this.power();e>=0;--e)this.m_elements[e].limitPrecisionThis(t);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce((t,e)=>{const s=e.hiBitIndex();return t<s?s:t},0)}shiftRight(t){return this.m_elements.splice(0,t),this.updatePower(),this}evaluateDerivative(t){const e=this.power(),s=this.m_elements[e];s.mulDoubleThis(e);for(let n=e-1;n>=1;--n){s.mulThis(t);const e=this.m_elements[n];e.mulDoubleThis(n),s.addThis(e)}return s}static evaluateCoefs(t,e,s){const n=t.power();s.construct0(t.getElement(0).evaluate(e));for(let i=1;i<=n;++i)s.addElement(t.getElement(i).evaluate(e));s.updatePower()}}class Pi extends yi{constructor(t){super(void 0===t?{zeroCtor:y}:{...t,zeroCtor:y})}clone(){return new Pi({copy:this})}absEvaluate(t){const e=this.power(),s=this.m_elements[e].clone();s.absThis();const n=t.clone();n.absThis();for(let t=e-1;t>=0;--t)s.mulThis(n),s.addThis(this.m_elements[t].abs());return s}}class Ci extends yi{constructor(t){super(void 0===t?{zeroCtor:Pi}:{...t,zeroCtor:Pi})}clone(){return new Ci({copy:this})}constructFromMPValues(t,e){this.m_elements.length=0;for(let s=0;s<=e;++s)this.m_elements.push(new Pi({coef0:t[s]}));return this.updatePower(),this}}function Ei(t,e,s,i,r,o,a,h,m,l,u,c,g,d,_,p,f,x,C,E=!1){const S={polypoly1:new Ci,polypoly2:new Ci,polyX2:new Pi,polyY2:new Pi,polyX2Deriv:new Pi,polyY2Deriv:new Pi,polypolyX1:new Ci,polypolyY1:new Ci,polypolyX1Deriv:new Ci,polypolyY1Deriv:new Ci,lazyPolypolyD1:new Ci,lazyPolypolyD1Deriv:new Ci,lazyPolyD2:new Pi,lazyPolyD2Deriv:null,polypoly11:new Ci,polypoly12:new Ci,tempPp:new Ci,tempPp1:new Ci,tempPp2:new Ci,tempP:new Pi,tempP1:new Pi,tempP2:new Pi};S.polyX2.construct(a,h),S.polyY2.construct(m,l),S.polypolyX1.constructFromMPValues(t,e),S.polypolyY1.constructFromMPValues(s,i),S.polypoly11.assignCopy(S.polypolyX1),S.polypoly12.assignCopy(S.polypolyY1),u&&(S.lazyPolyD2.construct(u,c),S.polypoly11.mulElementThis(S.lazyPolyD2),S.polypoly12.mulElementThis(S.lazyPolyD2)),r?(S.lazyPolypolyD1.constructFromMPValues(r,o),S.lazyPolypolyD1Deriv=new Ci({copy:S.lazyPolypolyD1}),S.lazyPolypolyD1Deriv.derivative1This(),S.tempPp.assignCopy(S.lazyPolypolyD1),S.tempPp.mulElementThis(S.polyX2),S.polypoly11.subThis(S.tempPp),S.tempPp.assignCopy(S.lazyPolypolyD1),S.tempPp.mulElementThis(S.polyY2),S.polypoly12.subThis(S.tempPp)):(S.polypoly11.sub0This(S.polyX2),S.polypoly12.sub0This(S.polyY2)),S.polypolyX1Deriv.assignCopy(S.polypolyX1),S.polypolyX1Deriv.derivative1This(),S.polypolyY1Deriv.assignCopy(S.polypolyY1),S.polypolyY1Deriv.derivative1This(),r&&(S.polypolyX1Deriv.mulThis(S.lazyPolypolyD1),S.tempPp2.assignCopy(S.lazyPolypolyD1Deriv),S.tempPp2.mulThis(S.polypolyX1),S.polypolyX1Deriv.subThis(S.tempPp2),S.polypolyY1Deriv.mulThis(S.lazyPolypolyD1),S.tempPp2.assignCopy(S.lazyPolypolyD1Deriv),S.tempPp2.mulThis(S.polypolyY1),S.polypolyY1Deriv.subThis(S.tempPp2)),S.polyX2Deriv.assignCopy(S.polyX2),S.polyX2Deriv.derivative1This(),S.polyY2Deriv.assignCopy(S.polyY2),S.polyY2Deriv.derivative1This(),u&&(n(null===S.lazyPolyD2Deriv),S.lazyPolyD2Deriv=new Pi({copy:S.lazyPolyD2}),S.lazyPolyD2Deriv.derivative1This(),S.polyX2Deriv.mulThis(S.lazyPolyD2),S.tempP1.assignCopy(S.lazyPolyD2Deriv),S.tempP1.mulThis(S.polyX2),S.polyX2Deriv.subThis(S.tempP1),S.polyY2Deriv.mulThis(S.lazyPolyD2),S.tempP1.assignCopy(S.lazyPolyD2Deriv),S.tempP1.mulThis(S.polyY2),S.polyY2Deriv.subThis(S.tempP1)),S.polypoly1.assignCopy(S.polypoly11),S.polypoly1.mulElementThis(S.polyX2Deriv),S.tempPp.assignCopy(S.polypoly12),S.tempPp.mulElementThis(S.polyY2Deriv),S.polypoly1.addThis(S.tempPp),S.polypoly2.assignCopy(S.polypolyX1Deriv),S.polypoly2.mulElementThis(S.polyY2Deriv),S.tempPp.assignCopy(S.polypolyY1Deriv),S.tempPp.mulElementThis(S.polyX2Deriv),S.polypoly2.subThis(S.tempPp);let v=[];const I=[];f||(f=[]),p||(p=[]),Ni(S.polypoly11,S.polypoly12,S.tempP);const b=vt.ldexp(-59).toDouble(),w=[];let D=Ai(S.tempP,0,_,b,64,w,x,x);if(D<0)return-1;for(let t=0;t<D;t++){const e=S.tempP1,s=S.tempP2;Pi.evaluateCoefs(S.polypoly11,w[t],e);const i=It(e.m_elements,e.power()+1);i.sort((t,e)=>t.compare(e)),Pi.evaluateCoefs(S.polypoly12,w[t],s);const r=It(s.m_elements,s.power()+1);r.sort((t,e)=>t.compare(e));const o=i[0],a=i.at(-1),h=r[0],m=r.at(-1);a.subThis(o),m.subThis(h);const l=a.subThis(m).GEZ(),u=58,c=[];let g;if(g=Ai(l?e:s,0,d,vt.ldexp(-59).toDouble(),u,c,x,x),g<0&&P("mp_curve_proximity"),g>0){const i=l?s:e;for(let e=0;e<g;e++){let s;if(l){const n=S.tempP;Pi.evaluateCoefs(S.polypoly12,w[t].addDouble(Number.EPSILON),n),s=n.evaluate(c[e])}else{const n=S.tempP;Pi.evaluateCoefs(S.polypoly11,w[t].addDouble(Number.EPSILON),n),s=n.evaluate(c[e])}const r=i.evaluateDerivative(c[e]).abs().mulDoubleThis(Number.EPSILON),o=i.evaluate(c[e]);r.addThis(s.sub(o).absThis()),r.ldexpThis(3),o.absThis(),o.lt(r)?I.push(ft(c[e].toDouble(),w[t].toDouble())):n(o.gte(r))}}}D=I.length,Ni(S.polypoly1,S.polypoly2,S.tempP);const T=[];let N=Ai(S.tempP,0,_,b,64,T);N<0&&(N=0);for(let t=0;t<N;t++){Pi.evaluateCoefs(S.polypoly1,T[t],S.tempP1);const e=[];let s=Ai(S.tempP1,0,d,b,64,e);if(0!==s)if(Pi.evaluateCoefs(S.polypoly2,T[t],S.tempP2),s<0){if(s=Ai(S.tempP2,0,d,b,64,e),s<0)continue;for(let n=0;n<s;n++)v.push(ft(e[n].toDouble(),T[t].toDouble()))}else{const n=S.tempP2.absEvaluate(vt);n.mulThis(y.constructDouble(1e-12));for(let i=0;i<s;i++){const s=S.tempP2.evaluate(e[i]);s.absThis(),s.lt(n)&&v.push(ft(e[i].toDouble(),T[t].toDouble()))}}}if(N=v.length,0===D&&0===N)return 0;v=v.concat(I),v.sort((t,e)=>E?at(t.second,e.second):at(t.first,e.first));const A=bt(v,(t,e)=>t.first===e.first&&t.second===e.second);v=v.slice(0,A),p.length=0,f.length=0;for(const t of v)p.push(t.first),f.push(t.second);return n(p.length===f.length),f.length}function Si(t,e,s,n,i,r,o,a,h,m,l,u,c){const d={polyIntersect:new Pi,polyX1:new Pi,polyY1:new Pi,polyX1Deriv:new Pi,polyY1Deriv:new Pi,lazyPolyD1:new Pi,lazyPolyD1Deriv:new Pi,tempP:new Pi,tempP1:new Pi,tempP2:new Pi,polypoly1Proximity:new Ci,polypoly2Proximity:new Ci};d.polyX1.construct(t,e),d.polyY1.construct(s,n),d.polyX1Deriv.assignCopy(d.polyX1),d.polyX1Deriv.derivative1This(),d.polyY1Deriv.assignCopy(d.polyY1),d.polyY1Deriv.derivative1This(),d.polyIntersect.assignCopy(d.polyX1),d.polyIntersect.mulThis(d.polyX1),d.polyIntersect.mulElementThis(o[0]),d.tempP.assignCopy(d.polyY1),d.tempP.mulThis(d.polyY1),d.tempP.mulElementThis(o[1]),d.polyIntersect.addThis(d.tempP),i?(d.lazyPolyD1.construct(i,r),d.tempP.assignCopy(d.lazyPolyD1),d.tempP.mulThis(d.lazyPolyD1),d.tempP.mulElementThis(o[2]),d.polyIntersect.addThis(d.tempP)):d.polyIntersect.add0(o[2]);{const i=o[0].clone(),r=i.clone();r.sqrThis();const a=o[1].clone(),h=a.clone();h.sqrThis();const m=o[2].clone(),l=i.clone();l.subThis(a),d.polyX1.construct(t,e),d.polyX1Deriv.assignCopy(d.polyX1),d.polyX1Deriv.derivative1This(),d.polyY1.construct(s,n),d.polyY1Deriv.assignCopy(d.polyY1),d.polyY1Deriv.derivative1This(),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(d.polyX1),d.tempP.mulElementThis(h),d.tempP.mulElementThis(m),d.polypoly1Proximity.construct0(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(a.mul(l).mul(m).ldexpThis(1)),d.polypoly1Proximity.addElement(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(d.polyX1),d.tempP.mulElementThis(i.mul(h)),d.tempP1.assignCopy(d.polyY1),d.tempP1.mulThis(d.polyY1),d.tempP1.mulElementThis(r.mul(a)),d.tempP.addThis(d.tempP1),d.tempP.add0(l.mul(l).mul(m)),d.polypoly1Proximity.addElement(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulElementThis(l.mul(i).mul(a).ldexpThis(1)),d.polypoly1Proximity.addElement(d.tempP),d.tempP.construct0(i.mul(l).mul(l)),d.polypoly1Proximity.addElement(d.tempP),d.polypoly1Proximity.updatePower(),d.tempP.construct0(St),d.polypoly2Proximity.construct0(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(d.polyX1Deriv),d.tempP1.assignCopy(d.polyY1),d.tempP1.mulThis(d.polyY1Deriv),d.tempP.addThis(d.tempP1),d.tempP.mulElementThis(i.mul(a)),d.polypoly2Proximity.addElement(d.tempP),d.tempP.assignCopy(d.polyX1Deriv),d.tempP.mulElementThis(l.mul(i)),d.polypoly2Proximity.addElement(d.tempP),d.polypoly2Proximity.updatePower()}const _=[],p=[];null===l&&(l=[]);let f=2*d.polyIntersect.power()+58;const x=.5*Number.EPSILON,y=[],P=Ai(d.polyIntersect,0,h,x,f,y,u,u);if(P<0)return-1;for(const t of y)p.push(t.toDouble());Ni(d.polypoly1Proximity,d.polypoly2Proximity,d.tempP),f=2*d.tempP.power()+58,y.length=0;let C=Ai(d.tempP,0,h,x,f,y);if(C<0&&(C=0),0===P&&0===C)return 0;for(const t of y)_.push(t.toDouble());const E=_.concat(p);l.length=E.length,g(l,E,0,0,E.length),lt(l);const S=bt(l,(t,e)=>0===at(t,e));return l.length=S,l.length}function vi(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setThis(e),n.negateThis(),n.divThis(t),s.isEmpty()||s.containsCoordinate(n.value())?1:0)}function Ii(t,e,s,n,i,r,o){if(t.isZero())return r?(o[0].setInt32(1),i.containsCoordinate(1)?1:0):vi(e,s,i,o[0]);if(r){let e=2;return o[0].setInt32(1),s.equals(t)?(o[1].setInt32(1),e=1):o[1].setThis(s.div(t)),i.containsCoordinate(o[1].value())||(e=1),i.containsCoordinate(o[0].value())||(e--,o[0].setThis(o[1])),2===e&&o[0].value()>o[1].value()&&(o[1]=p(o[0],o[0]=o[1])),e}const a=e.clone();a.sqrThis();const h=t.clone();if(h.mulThis(s).ldexpThis(2).negateThis().addThis(a),h.LZ())return 0;const m=n+2,l=y.sqrt(h,m),u=l.clone();e.LZ()&&u.negateThis(),u.addThis(e).limitPrecisionThis(m).ldexpThis(-1).negateThis();let c=0;return o[0].setThis(u).divThis(y.constructAssign(t,m)).limitPrecisionThis(n),(i.isEmpty()||i.containsCoordinate(o[0].value()))&&c++,l.isZero()||u.isZero()||(o[c].setThis(s).divThis(u).limitPrecisionThis(n),(i.isEmpty()||i.containsCoordinate(o[c].value()))&&c++,2===c&&o[0].gt(o[1])&&(o[1]=p(o[0],o[0]=o[1]))),c}function bi(t,e,s,i,r,o,a,h){if(t.isZero())return Ii(e,s,i,r,o,a,h);const m=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=p(h[t],h[t]=h[s-1]),s--);e=s}return _(h,0,e,(t,e)=>t.compare(e)),e};if(i.isZero()){let n=0;return o.containsCoordinate(0)&&(h[0].setInt32(0),n=1),m(Ii(t,e,s,r,o,a,h.slice(1)),n)}if(a){let s=0;o.containsCoordinate(1)&&(h[0].setInt32(1),s=1);const n=e.add(t),a=i.negate(),l=t.add(n).add(a).isZero();return m(Ii(t,n,a,r,o,l,h.slice(s)),s)}const l=new y,u=new y,c=new y,g=e.clone();if(g.isZero())u.setThis(s),u.divThis(t),c.setThis(i),c.divThis(t);else{g.divThis(t).divDoubleThis(3).negateThis();const n=e.clone();n.sqrThis();const r=t.clone();r.sqrThis(),u.setThis(t),u.mulThis(s).mulDoubleThis(3).subThis(n).divThis(r).divDoubleThis(3),c.setThis(n),c.mulThis(e),c.ldexpThis(1),l.setThis(t),l.mulThis(e).mulThis(s).mulDoubleThis(9),c.subThis(l),l.setThis(r),l.mulThis(i).mulDoubleThis(27),c.addThis(l),c.divThis(r).divThis(t).divDoubleThis(27)}if(u.isZero()){const t=c.clone();return t.negateThis(),t.isZero()?(h[0].setThis(g),Xi(o,r,h,1)):(h[0].setThis(y.cubicRoot(t,r).add(g)),Xi(o,r,h,1))}const d=c.clone();if(d.sqrThis().ldexpThis(-2),l.setThis(u.clone()),l.sqrThis().mulThis(u).divDoubleThis(27),d.addThis(l),d.isZero())return h[0].setThis(c),h[0].mulDoubleThis(3).divThis(u),h[1].setThis(h[0]),h[1].negateThis(),h[1].ldexpThis(-1),h[0].addThis(g),h[1].addThis(g),Xi(o,r,h,2);if(d.GZ())return d.setThis(y.sqrt(d,r+8)),l.setThis(c),l.ldexpThis(-1).negateThis(),l.addThis(d),h[0].setThis(y.cubicRoot(l,r+8)),l.setThis(c),l.ldexpThis(-1).negateThis(),l.subThis(d),h[0].addThis(y.cubicRoot(l,r+8)),h[0].addThis(g),Xi(o,r,h,1);l.setThis(u),l.divDoubleThis(3).negateThis(),n(l.GEZ());const f=y.sqrt(l,r+8),x=f.clone();x.negateThis(),x.addThis(g),f.addThis(g);const P=y.constructDouble(o.isEmpty()?-Number.MAX_VALUE:o.vmin),C=y.constructDouble(o.isEmpty()?Number.MAX_VALUE:o.vmax),E=new Pi({zeroCtor:y});E.construct0(i),E.addElement(s),E.addElement(e),E.addElement(t);const S=new Pi({copy:E});S.derivative1This();let v=0;const I=T(y,4);I[v++].setThis(P),x.gt(P)&&x.lt(C)&&I[v++].setThis(x),f.gt(P)&&f.lt(C)&&I[v++].setThis(f),I[v++].setThis(C);const b=3*r;let w=52,D=Number.EPSILON;for(;w<b;)2*w<=b?(D*=D,w*=2):(D*=Number.EPSILON,w+=52);w+=2;let N=0,A=!1;for(let t=1;t<v;t++)if(qi(E,S,I[t-1],I[t],D,w,h[0])){N=1,A=t+1<v;break}if(!N)return 0;if(A){const t=new Pi({zeroCtor:y,coef0:h[0]});t.negateThis(),t.addElement(vt);const e=new Pi({zeroCtor:y}),s=new Pi({zeroCtor:y});E.div(t,e,s),n(2===e.power()),n(0===s.power());const i=Ii(e.getElement(2),e.getElement(1),e.getElement(0),r,o,!1,h.slice(1));n(i>=0&&i<=2),N+=i}return Xi(o,r,h,N)}function wi(t,e,s,n,i,r,o,a,h){if(t.isZero())return bi(e,s,n,i,r,o,a,h);const m=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=p(h[t],h[t]=h[s-1]),s--);e=s}return _(h,0,e,(t,e)=>t.compare(e)),e};if(i.isZero()){let i=0;return o.containsCoordinate(0)&&(h[0].setInt32(0),i=1),m(bi(t,e,s,n,r,o,a,h.slice(i)),i)}const l=new Pi({zeroCtor:y,coef0:i});if(l.addElement(n),l.addElement(s),l.addElement(e),l.addElement(t),a){let t=0;o.containsCoordinate(1)&&(h[0].setInt32(1),t=1);const e=new Pi({zeroCtor:y,coef0:y.constructInt32(-1)});e.addElement(y.constructInt32(1));const s=new Pi({zeroCtor:y}),n=new Pi({zeroCtor:y});return l.div(e,s,n),m(bi(3===s.power()?s.getElement(3):St.clone(),s.power()>=2?s.getElement(2):St.clone(),s.power()>=1?s.getElement(1):St.clone(),s.getElement(0),r,o,s.evaluate(vt).isZero(),h.slice(t)),t)}if(l.getElement(0).isZero()){let t=0;for(o.containsCoordinate(0)&&(t=1,h[0].setDouble(0));l.getElement(0).isZero()&&l.power()>0;)l.shiftRight(1);const e=bi(3===l.power()?l.getElement(3):St.clone(),l.power()>=2?l.getElement(2):St.clone(),l.power()>=1?l.getElement(1):St.clone(),l.getElement(0),r,o,!1,h.slice(t));return e>0&&(t+=e),_(h,0,t,(t,e)=>t.compare(e)),t}let u=52,c=Number.EPSILON;for(;u<r;)2*u<=r?(c*=c,u*=2):(c*=Number.EPSILON,u+=52);u+=2;const g=Yi(l),d=y.constructDouble(Math.max(Math.abs(o.vmax),Math.abs(o.vmin)));return c=(g.lt(d)?g:d).mul(y.constructDouble(c)).toDouble(),Vi(l,o,c,u,a,0,h,4)}function Di(t,e){let s=t,n=e;n.power()>s.power()&&(n=p(s,s=n));const i=s.power()-n.power(),r=new Pi({copy:s.getElement(s.power())});s.mulThis(n.getElement(n.power()));for(let t=0,e=s.power();t<e;t++)if(t>=i){const e=new Pi({copy:n.getElement(t-i)});e.mulThis(r);const o=s.getElement(t).sub(e);s.setElement(t,o)}s.setElement(s.power(),s.getElement(s.power()).setZero()),s.updatePower(),Ti(s)}function Ti(t){let e=0;for(;e<t.power()&&t.getElement(e).isZero();)e++;return e>0&&(t.shiftRight(e),!0)}function Ni(t,e,s){const n=t.clone(),i=e.clone();for(Ti(n),Ti(i);0!==n.power()||0!==i.power();)Di(n,i);s.assignMove(n.getElement(0))}function Ai(t,e,s,n,i,o,a=!1,h=!1){o.length=0;const m=t.power(),l=T(y,2*m+4),u=function(t,e,s,n,i,r,o){if(0===t.power())return t.isZero()?-1:0;const a=t.evaluate(y.constructInt32(1)).isZero();if(1===t.power()){const s=vi(t.getElement(1),t.getElement(0),e,r.at(0));return r[0].limitPrecisionThis(n),1!==s?0:(r[0].limitPrecisionThis(n),1)}return 2===t.power()?Ii(t.getElement(2),t.getElement(1),t.getElement(0),n,e,a,r):3===t.power()?bi(t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),n,e,a,r):4===t.power()?wi(t.getElement(4),t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),n,e,a,r):Vi(t,e,s,n,a,0,r,o)}(t,s||r.unit(),n,i,0,l,l.length);if(u>0){o.length=0;for(let t=0;t<u;t++){const e=l[t];t>0&&e.lte(o.at(-1))||o.push(e.clone())}return o.length}return u}function Mi(t,e,s){if(n(s>=1),0===t.power())return t.isZero()?-1:0;const i=t.getElement(0);return i.negateThis(),i.divThis(t.getElement(1)),e[0].setThis(i),1}function Gi(t,e,s,i){if(t.power()<2)return Mi(t,s,i);n(i>=1);let r=t.getElement(1);r.mulThis(t.getElement(1));const o=t.getElement(0);if(o.mulThis(t.getElement(2)),o.ldexpThis(2),r.subThis(o),r.LZ())return 0;if(r.isZero()){const n=t.getElement(1);return n.negateThis(),n.divThis(t.getElement(2)),n.ldexpThis(-1),n.limitPrecisionThis(e),s[0].setThis(n),1}n(i>=2),r=y.sqrt(r,e+8);const a=t.getElement(1);a.negateThis();const h=a.clone();h.subThis(r),h.divThis(t.getElement(2)),h.ldexpThis(-1),h.limitPrecisionThis(e);const m=a.clone();return m.addThis(r),m.divThis(t.getElement(2)),m.ldexpThis(-1),m.limitPrecisionThis(e),h.lt(m)?(s[0].setThis(h),s[1].setThis(m)):(s[1].setThis(h),s[0].setThis(m)),2}function qi(t,e,s,n,i,r,o){let a=s.clone(),h=n.clone();a.limitPrecisionThis(r),h.limitPrecisionThis(r);let m=t.evaluate(a);m.limitPrecisionThis(r+2);let l=t.evaluate(h);if(l.limitPrecisionThis(r+2),m.GEZ()&&l.GEZ()||m.LEZ()&&l.LEZ())return m.absLessAbs(l)?(o=a,m.isZero()):(o=h,l.isZero());const u=l.LZ();u&&(l=p(m,m=l),h=p(a,a=h));const c=u?h:a,g=u?a:h,d=a.add(h).ldexpThis(-1);d.limitPrecisionThis(r);const _=h.sub(a);_.limitPrecisionThis(r),_.absThis();const f=_.clone();let x=t.evaluate(d),C=e.evaluate(d);const E=new Pi({copy:t}),S=new Pi({copy:e});{const s=Math.max(t.hiBitIndex(),e.hiBitIndex()),n=vt.clone();n.ldexpThis(-(r+2));for(let i=64;i<s;){E.limitPrecisionThis(i),S.limitPrecisionThis(i);const r=E.evaluate(d),o=S.evaluate(d),a=r.sub(x),h=o.sub(C);if(a.divThis(x).absThis().lt(n)&&(C.isZero()||h.divThis(C).absThis().lt(n)))break;E.assignCopy(t),S.assignCopy(e),i=Math.min(i+64,s)}x.limitPrecisionThis(r+2),C.limitPrecisionThis(r+2)}let v=4,I=1,b=0,w=0,D=1;const T=y.constructDouble(.25*i),N=y.constructDouble(.5001);let A=0;for(;++A<300;){if(A>32&&b>0||C.isZero()||2===D&&b>1||1===D&&v<4)D=1,I>1&&I--;else if(D=2,w>1){const t=_.mul(C);t.absThis(),t.ldexpThis(-3),t.absLessAbs(x)&&I++}_.setThis(f);const t=new y;let e=!1;if(1===D)do{if(w>2){const e=_.clone();if(e.absThis(),e.ldexpThis(4),g.sub(c).ldexpThis(-1).gt(e)){if(d.equals(c)){t.setThis(d),d.setThis(c.add(e)),d.limitPrecisionThis(r),f.setThis(d.sub(t));break}if(d.equals(g)){t.setThis(d),d.setThis(g.sub(e)),d.limitPrecisionThis(r),f.setThis(d.sub(t));break}}}f.setThis(h.sub(a)),f.ldexpThis(-1),f.limitPrecisionThis(r),t.setThis(d),d.setThis(a.add(f)),d.limitPrecisionThis(r),d.lt(c)?d.setThis(c):d.gt(g)&&d.setThis(g),e=a.equals(d)||h.equals(d)}while(0);else for(;;){if(f.setThis(x.div(C)),f.limitPrecisionThis(r),1!==I&&f.mulDoubleThis(I),t.setThis(d),d.subThis(f),d.limitPrecisionThis(r),e=d.equals(t),d.lt(c)){if(I>1){d.setThis(t),I--;continue}f.setThis(t.sub(c)),d.setThis(c)}else if(d.gt(g)){if(I>1){d.setThis(t),I--;continue}f.setThis(t.sub(g)),d.setThis(g)}break}if(e||f.absLessAbs(T)){t.equals(d)||(x=E.evaluate(d),x.limitPrecisionThis(r+2));break}x=E.evaluate(d),x.limitPrecisionThis(r+2),C=S.evaluate(d),C.limitPrecisionThis(r+2);const s=a.clone(),n=h.clone();x.LZ()?(m.setThis(x),a.setThis(d)):(l.setThis(x),h.setThis(d)),2===D&&(a.equals(s)&&h.equals(n)||w>1&&!f.absLessAbs(N.mul(_)))?b++:b=0,1===D?(v++,w=0):(v=0,w++)}return A>=300&&P("Root_finder iterations exceeded"),o.setThis(d),!0}function Fi(t,e,s,n,i){const r=t.evaluate(s);if(r.isZero())return!0;const o=y.constructDouble(.5*n),a=s.clone();a.subThis(o);const h=t.evaluate(a),m=s.clone();m.addThis(o);const l=t.evaluate(m);if(h.LZ()&&l.GZ()||h.GZ()&&l.LZ())return!0;if(r.GZ()?h.LEZ()||l.LEZ():h.GEZ()||l.GEZ())return!0;const u=h.LEZ()&&l.LEZ(),c=h.GEZ()&&l.GEZ();let g=!1;return u?r.gt(h)&&r.gt(l)&&(g=!0):c&&r.lt(h)&&r.lt(l)&&(g=!0),!!g&&r.absThis().lt(y.constructDouble(1e-17))}function Vi(t,e,s,i,r,o,a,h){n(s>0),n(h>=t.power());const m=a,l=[];let u=[];const c=new Pi({zeroCtor:t.m_zeroCtor}),g=new Pi({zeroCtor:t.m_zeroCtor}),d=new Pi({zeroCtor:t.m_zeroCtor}),p=y.constructDouble(s),f=y.constructDouble(e.vmin),x=y.constructDouble(e.vmax),P=f.sub(p),C=x.add(p),E=Yi(t),S=E.clone();if(S.negateThis(),P.lt(S))P.setThis(S.sub(p));else if(P.gt(E))return 0;if(C.gt(E))C.setThis(E.add(p));else if(C.lt(S))return 0;let v=t,I=null;if(r){const e=new Pi({coef0:y.constructInt32(-1)});e.addElement(vt),I=new Pi,v=I;const s=new Pi,n=new Pi;for(t.div(e,s,n),I.assignCopy(s);v.evaluate(vt).isZero();)v.div(e,s,n),I.assignCopy(s)}let b=!1;if(v.power()>0&&v.getElement(0).isZero())for(b=!0,I||(I=new Pi({copy:v}),v=I);v.getElement(0).isZero();)I.shiftRight(1);let w=i+2*v.power()+2,D=s/Math.pow(2,v.power()+2),T=w;if(St.gt(P)&&St.lt(C))for(let t=0,e=v.power();t<e;t++)if(v.getElement(t).isZero()){l.push(St.clone());break}for(let t=v.power()-1;t>0;t--)if(D*=2,w-=2,T-=2,v.power()-t!==1){if(v.power()-t===2){g.assignMove(v.derivative(t));const e=Gi(g,w,m,h);n(e>=0&&e<=2);for(let t=0;t<e;t++)m[t].gt(P)&&m[t].lt(C)&&!m[t].isZero()&&l.push(m[t].clone());if(l.length>1&&l.sort((t,e)=>t.compare(e)),l.length>0){let t=l[0].sub(p);t.limitPrecisionThis(T),u.push(ft(P.clone(),t));let e=1===l.length?C.clone():l[1].sub(p);t=l[0].add(p),t.limitPrecisionThis(T),e.limitPrecisionThis(T),u.push(ft(t,e)),l.length>1&&(e=2===l.length?C.clone():l[2].sub(p),e.limitPrecisionThis(T),t=l[1].add(p),t.limitPrecisionThis(T),u.push(ft(t,e)),l.length>2&&(t=l[2].add(p),t.limitPrecisionThis(T),u.push(ft(t,C.clone()))))}else u.push(ft(P.clone(),C.clone()));c.assignCopy(g),d.assignMove(v.derivative(t-1));continue}{g.assignMove(d),d.assignMove(v.derivative(t-1));let e=[];for(let t=0,s=u.length;t<s;++t)if(u[t].first.lte(u[t].second)){const s=new y;if(qi(g,c,u[t].first,u[t].second,D,w,s)){l.push(s);let n=s.sub(p);n.limitPrecisionThis(T),e.push(ft(u[t].first,n)),n=s.add(p),n.limitPrecisionThis(T),e.push(ft(n,u[t].second))}else e.push(u[t])}u=e,e=[],c.assignMove(g)}}else g.assignMove(v.derivative(t)),1===Mi(g,m,h)&&(m[0].gt(P)&&m[0].lt(C)&&!m[0].isZero()&&l.push(m[0].clone()),c.assignMove(g),d.assignMove(v.derivative(t-1)));l.sort((t,e)=>t.compare(e)),0===u.length&&(c.assignMove(v.derivative(v.power())),c.isZero()||u.push(ft(P.clone(),C.clone())));let N=0,A=0,M=0;const G=new y;for(;;){if(A<u.length){if(u[A].first.gt(u[A].second)){A++;continue}let t=!1;if(M<l.length&&l[M].lt(u[A].first)&&(t=!0),!t){qi(v,c,u[A].first,u[A].second,s,i,G)&&(G.lt(f)?m[N++].setThis(f):G.gt(x)?m[N++].setThis(x):m[N++].setThis(G)),A++;continue}}if(!(M<l.length))break;0!==M&&l[M-1].equals(l[M])||Fi(v,0,l[M],s)&&(G.setThis(l[M]),G.lt(f)?G.setThis(f):G.gt(x)&&G.setThis(x),0!==N&&m[N].equals(G)||m[N++].setThis(G)),M++}return b&&St.gt(P)&&St.lt(C)&&(m[N++].setThis(St),_(m,0,N,(t,e)=>t.compare(e))),r&&vt.gt(P)&&vt.lt(C)&&(m[N++].setThis(vt),_(m,0,N,(t,e)=>t.compare(e))),N}function Yi(t){const e=t.getElement(t.power());e.limitPrecisionThis(53),e.absThis();const s=St.clone();for(let e=0,n=t.power();e<n;e++){const n=t.getElement(e);n.limitPrecisionThis(53),n.gt(s)&&s.setThis(n)}return s.divThis(e),s.addThis(vt),s.mulThis(y.constructDouble(1+100*Number.EPSILON)),s}function Xi(t,e,s,n){let i=n;if(!t.isEmpty()){i=0;for(let e=0;e<n;++e)t.containsCoordinate(s[e].value())&&(i!==e&&s[i].setThis(s[e]),i++)}i>1&&(s[0].gt(s[1])&&(s[1]=p(s[0],s[0]=s[1])),i>2&&(s[0].gt(s[2])&&(s[2]=p(s[0],s[0]=s[2])),s[1].gt(s[2])&&(s[2]=p(s[1],s[1]=s[2]))));for(let t=0;t<i;++t)s[t].limitPrecisionThis(e);return i}function ki(t,e,n,i,r,o){return function(t,e,n,i,r,o){if(n<e&&s("xTo < xFrom"),n===e)return 0;const a=[0];let m=Number.MAX_VALUE;const l=[Number.MAX_VALUE];let u=0;const c=h(33,Number.NaN),g=h(33,Number.NaN),d=[0];c[0]=1;let _=0,p=0;for(let s=0;s<32;s++){if(u=Ri(e,n,i,0===s,u,d),g[s]=u,s+1>=t){Li(s+1-t,t,c,g,0,a,l)||P("polynomial_interpolation");const e=r*Math.abs(a[0])+o,n=Math.abs(m-a[0]);if(n<=e&&Math.abs(l[0])<=e){if(_++,_>1&&(n<=.1*p||0===p||_>2))return a[0]}else _=0;p=n,m=a[0]}g[s+1]=g[s],c[s+1]=.25*c[s]}return a[0]}(t,e,n,o,i,r)}function Ri(t,e,s,n,i,r){let o=i;if(n)return r[0]=1,o=.5*(e-t)*(s(t)+s(e)),o;const a=r[0],h=(e-t)/a,m=t,l=new q(0);for(let t=1;t<=r[0];++t){const e=(t-.5)*h;l.add(s(m+e))}return o=.5*(o+(e-t)*l.getResult()/a),r[0]*=2,o}function Li(t,e,s,n,i,r,o){let a=0,m=Math.abs(i-s[t]);const l=h(e,Number.NaN),u=h(e,Number.NaN);for(let r=0;r<e;++r){const e=Math.abs(i-s[t+r]);e<m&&(a=r,m=e),l[r]=n[t+r],u[r]=n[t+r]}let c=0,g=0,d=0;r[0]=n[t+a],a--;for(let n=1;n<e;n++){for(let r=0;r<e-n;r++){if(g=s[t+r]-i,d=s[t+r+n]-i,c=g-d,0===c)return!1;const e=(l[r+1]-u[r])/c;l[r]=g*e,u[r]=d*e}if(2*(a+1)<e-n){const t=a+1;o[0]=l[t]}else{const t=a;o[0]=u[t],a--}r[0]+=o[0]}return!0}class Hi{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}let Bi=class{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-ji(this.b,e,!1):0}getError(t){return n(0),0}};function Ui(t,e,s,n,i){let r=!0;const o=T(l,3);t.queryControlPoints(o);let a=r?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const u=ki(5,e,s,n,i,t=>{let e;if(t<=.5){const s=k(0,h,t),n=k(h,m,t);e=k(s,n,t)}else{const s=R(0,h,t),n=R(h,m,t);e=R(s,n,t)}return e*$i(o,1,t).length()});r=!1,a=r?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const c=ki(5,e,s,n,i,t=>{let e;if(t<=.5){const s=k(0,h,t),n=k(h,m,t);e=k(s,n,t)}else{const s=R(0,h,t),n=R(h,m,t);e=R(s,n,t)}return e*$i(o,1,t).length()});return new l(u,c)}function zi(t){t.m_cachedValues=null}function Oi(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new Hi;return Wi(t,e.specialPoints),nr(t,e),e}function Wi(t,e){const s=T(l,3);t.queryControlPoints(s);const n=T(v,8);n[0].set(0);let i=1;{const t=T(v,3);!function(t,e,s=!1){const n=new v(t[1][0]).subE(new v(t[0][0]));e[1]=n.mul(2),e[2]=new v(t[2][0]).subE(new v(t[1][0])).subE(n),s?e[0].set(0):e[0].set(t[0][0])}(s,t,!1);const e=T(v,2),o=new r(0,1);let a=ri(t[2].mul(2),t[1],o,e[0]);a<0&&(a=0);for(let t=0;t<a;t++)M(e[t].value(),0,1)||(n[i]=e[t],i++)}{const t=T(v,3);!function(t,e,s=!1){const n=new v(t[1][1]).subE(new v(t[0][1]));e[1]=n.mul(2),e[2]=new v(t[2][1]).subE(new v(t[1][1])).subE(n),s?e[0].set(0):e[0].set(t[0][1])}(s,t,!1);const e=T(v,2),o=new r(0,1);let a=ri(t[2].mul(2),t[1],o,e[0]);a<0&&(a=0);for(let t=0;t<a;t++)M(e[t].value(),0,1)||(n[i]=e[t],i++)}if(n[i].set(1),i++,i>2){_(n,0,i,(t,e)=>t.value()-e.value());let t=0,e=n[0].value(),s=1;for(let r=1;r<i;r++)n[r].eq(n[r-1])?(e+=n[r].value(),s++):(s>1&&(e/=s,n[t].set(e)),t++,n[t]=n[r],e=n[r].value(),s=1);t++,i=t}n[0].set(0),n[i-1].set(1),e.length=i;for(let t=0;t<i;t++)e[t]=n[t].value()}function ji(t,e,s){const n=T(l,3);return t.queryControlPoints(n),Zi(n,e,s)}function Zi(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+Zi(t,1,!1)}if(1===e)return Qi(t);const n=T(l,3);return lr(t,e,n,null),Qi(n)}function Qi(t){if(t[0].equals(t[1]))return l.distance(t[2],t[0]);if(t[1].equals(t[2]))return l.distance(t[0],t[2]);const e=l.distance(t[0],t[1])+l.distance(t[2],t[1]),s=l.distance(t[0],t[2]);if(e-s<=e*Number.EPSILON)return s;const n=T(l,3);fr(t,n,!0);const i=4*(ot(n[2].x)+ot(n[2].y)),r=2*(n[2].x*n[1].x+n[2].y*n[1].y),o=ot(n[1].x)+ot(n[1].y);if(1e-14*(Math.abs(r)+Math.abs(o))>=Math.abs(i))return 1e-14*Math.abs(o)>=Math.abs(r)?1*Math.sqrt(o):2/(3*r)*(Math.pow(1*r+o,1.5)-Math.pow(o,1.5));const a=r/i,h=o/i,m=h-a*a,u=1+a;if(0===m)return a>=0&&u>=0||a<=0&&u<=0?Math.abs(.5*Math.sqrt(i)*(u*u-a*a)):.5*Math.sqrt(i)*(u*u+a*a);const c=Math.sqrt(m+u*u),g=Math.sqrt(h);return.5*Math.sqrt(i)*(u*c-a*g+m*Math.log(Math.abs((u+c)/(a+g))))}function Ki(t,e){const s=A(e,0,1);let n=$i(t,1,s);return n.isZero()&&(n=$i(t,2,s)),n}function Ji(t,e,s){const n=T(l,3);return t.queryControlPoints(n),$i(n,e,s)}function $i(t,e,s){if(1===e){const e=t[1].sub(t[0]).mul(1-s).add(t[2].sub(t[1]).mul(s));return e.mulThis(2),e}return 2===e?t[2].sub(t[1]).sub(t[1].sub(t[0]).mul(2)):l.construct(0,0)}function tr(t){const e=T(l,3);return t.queryControlPoints(e),er(e)}function er(t){return-t[1].sub(t[0]).crossProduct(t[2].sub(t[0]))/3}function sr(t){return t.m_cachedValues}function nr(t,e){t.m_cachedValues=e}function ir(t,e,s,n,i){rt(r.unit().contains(s),"QuadraticBezierHelper::getClosestCoordinateSegment");const o=T(l,3);t.queryControlPoints(o);let a=Number.MAX_VALUE;const h=[0],m=rr(o,e,h);if(s.containsCoordinate(h[0]))a=l.distance(e,m);else{h[0]=s.vmin,yr(o,h[0],m),a=l.distance(m,e);const t=new l;yr(o,s.vmax,t);const n=l.distance(t,e);a>n&&(m.setCoordsPoint2D(t),h[0]=s.vmax,a=n)}if(!n)return h[0];if(s.vmin<=0){const n=new l;t.queryCoord2DExtended(-1,n,!0);const i=new l;t.queryCoord2D(s.vmin,i);const r=new pm({start:n,end:i}),o=r.getClosestCoordinate(e,!0);if(o<1){const t=r.getCoord2D(o),s=l.distance(t,e);s<a&&(a=s,h[0]=o-1,m.assign(t))}}if(s.vmin>=1){const n=new l;t.queryCoord2DExtended(2,n,!0);const i=new l;t.queryCoord2D(s.vmax,i);const r=new pm({start:i,end:n}),o=r.getClosestCoordinate(e,!0);if(o>0){const t=r.getCoord2D(o),s=l.distance(t,e);s<a&&(a=s,h[0]=1+o,m.assign(t))}}return h[0]}function rr(t,e,s){const n=t[2].sub(t[1]).sub(t[1].sub(t[0])),i=t[1].sub(t[0]),o=t[0].sub(e),a=o.dotProduct(i),m=o.dotProduct(n)+2*i.dotProduct(i),u=3*i.dotProduct(n),c=n.dotProduct(n),g=h(3,Number.NaN),d=ti(c,u,m,a,r.unit(),!1,g),_=t[0].clone();let p=0,f=l.sqrDistance(t[0],e),x=l.sqrDistance(t[2],e);x<f&&(p=1,_.assign(t[2]),f=x);for(let s=0;s<d;s++){const n=new l;yr(t,g[s],n),x=l.sqrDistance(n,e),x<f&&(f=x,_.assign(n),p=g[s])}return s&&(s[0]=p),_}function or(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,3);const n=T(l,3);ur(t,e.vmin,e.vmax,n),s.setFromPoints(n,3)}function ar(t,e,s){s.setEmpty();const n=[];n.push(new r(0,1));const i=.5*Math.max(e.width(),e.height());for(;n.length;){const o=n.at(-1);n.pop();const a=new Vs;if(or(t,o,a),a.isIntersectingW(e)){const t=Math.max(a.width(),a.height());if(e.containsW(a)||t<=i||o.width()<1e-12)s.merge(o);else{const t=o.getCenter();n.push(r.construct(o.vmin,t)),n.push(r.construct(t,o.vmax))}}}}function hr(t){const e=T(l,3);t.queryControlPoints(e);const s=mr(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function mr(t){let e=!1;for(let s=0;s<2;s++){const n=S(t[0][s],t[2][s]);n>0?(S(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),S(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):n<0?(S(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),S(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function lr(t,e,s,n){(new l).setCoordsPoint2D(t[0]),(new l).setCoordsPoint2D(t[1]),(new l).setCoordsPoint2D(t[2]);const i=new l,r=new l,o=new l;if(st(t[0],t[1],e,i),st(t[1],t[2],e,r),st(i,r,e,o),s&&(s[0].assign(t[0]),s[1].assign(i),s[2].assign(o)),n){const e=t[2];n[0].assign(o),n[1].assign(r),n[2].assign(e)}}function ur(t,e,s,n){if(e===s){const s=new l;return yr(t,e,s),n[0]=s,n[1]=s,void(n[2]=s)}const i=T(l,3);lr(t,s,i,null),lr(i,e/s,null,i),yr(t,e,i[0]),yr(t,s,i[2]),n[0].setCoordsPoint2D(i[0]),n[1].setCoordsPoint2D(i[1]),n[2].setCoordsPoint2D(i[2])}function cr(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==dr(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function gr(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==_r(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function dr(t,e,s,i,o,a,m,u,c,g){if(null!=o&&(o.length=0),null!==a&&(a.length=0),null!==i&&(i.length=0),s.isDegenerate(0)){const t=[0,0],n=e.intersectPoint(s.getStartXY(),t,m);if(n>0){if(null!==o)for(let e=0;e<n;e++)o.push(t[e]);if(null!==a)for(let t=0;t<n;t++)a.push(0);if(null!==i)for(let s=0;s<n;s++){const n=new l;e.queryCoord2D(t[s],n),i.push(n)}}return n}const d=mn(e,s);if(m=Math.max(m,d),e.isDegenerateToLineHelper(d)){const t=new pm({start:e.getStartXY(),end:e.getEndXY()}),n=wn(t,s,i,o,a,m,u,g);if(o)for(let s=0;s<n;++s){const n=t.getCoord2D(o[s]);o[s]=e.getClosestCoordinate(n,!1)}return n}if(ln(e,s,m))return 0;const _=Hs.constructPoint2D(s.getStartXY()),p=Hs.constructPoint2D(s.getEndXY()).sub(_),f=p.clone();f.leftPerpendicularThis();const x=Hs.constructPoint2D(e.m_cp).sub(Hs.constructPoint2D(e.getStartXY())),y=Hs.constructPoint2D(e.getEndXY()).sub(Hs.constructPoint2D(e.m_cp));let P=x.dotProduct(f).toDouble(),C=y.sub(x).dotProduct(f).toDouble();const E=h(12,Number.NaN),S=h(12,Number.NaN);let I=function(t,e,s,n){const i=new v,r=ri(new v(t),new v(e),s,i);return n[0]=i.value(),r}(C,P,r.unit(),E);I<0&&(E[0]=0,E[1]=1,I=2);let b,w=0;for(let t=0,n=w;t<I;++t){const i=e.getCoord2D(E[t+n]);S[w]=s.getClosestCoordinate(i,!1),l.distance(i,s.getCoord2D(S[w]))<=m&&(E[w]=E[t+n],w++)}const D=T(l,3);e.queryControlPoints(D);{const t=T(Hs,3);if(xr(D,t,!1),t[0]=t[0].sub(_),p.x.abs().gte(p.y.abs())){const e=p.y.div(p.x);C=t[2].y.sub(t[2].x.mul(e)).toDouble(),P=t[1].y.sub(t[1].x.mul(e)).toDouble(),b=t[0].y.sub(t[0].x.mul(e)).toDouble()}else{const e=p.x.div(p.y);C=t[2].x.sub(t[2].y.mul(e)).toDouble(),P=t[1].x.sub(t[1].y.mul(e)).toDouble(),b=t[0].x.sub(t[0].y.mul(e)).toDouble()}}const N=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),A=[0,0];I=$n(C,P,b,r.unit(),N,A);for(let t=0,n=w;t<I;++t){E[t+n]=A[t];const i=e.getCoord2D(E[t+n]);S[w]=s.getClosestCoordinate(i,!1),l.distance(i,s.getCoord2D(S[w]))<=m&&(E[w]=E[t+n],w++)}n(w<E.length+4),I=e.intersectPoint(s.getStartXY(),A,m);for(let t=0;t<I;t++)E[w]=A[t],S[w++]=0;I=e.intersectPoint(s.getEndXY(),A,m);for(let t=0;t<I;t++)E[w]=A[t],S[w++]=1;I=s.intersectPoint(e.getStartXY(),A,m);for(let t=0;t<I;t++)S[w]=A[t],E[w++]=0;I=s.intersectPoint(e.getEndXY(),A,m);for(let t=0;t<I;t++)S[w]=A[t],E[w++]=0;return 0===w?0:cm(t,e,s,E,S,w,i,o,a,m,u,0,g)}function _r(t,e,s,n,i,o,a,h,m,u){if(qh(s))return dr(t,e,new pm({start:s.getStartXY(),end:s.getEndXY()}),n,i,o,a,h,0,u);const c=mn(e,s);if(ln(e,s,a=Math.max(a,c)))return 0;const g=[],d=[],_=T(l,3);{e.queryControlPoints(_);const t=T(l,3),n=new Ps;s.canonicToWorldTransformation(n);const i=new Ps;i.setInvert(n),i.transformPoints2D(_,3,t);const o=T(Hs,3);xr(t,o);const m=[o[0].x,o[1].x,o[2].x],u=[o[0].y,o[1].y,o[2].y],c=T(y,3);c[0].setDouble(s.getSemiMinorAxis()),c[0].sqrThis(),c[1].setDouble(s.getSemiMajorAxis()),c[1].sqrThis(),c[2]=c[0],c[2].mul(c[1]),c[2].negate();const p=Si(m,2,u,2,null,0,c,0,r.unit(),r.unit(),g,h);if(p>0){let t=0;for(let n=0;n<p;n++){const i=new l;e.queryCoord2D(g[n],i);const r=s.getClosestCoordinate(i,!1),o=new l;s.queryCoord2D(r,o),l.distance(i,o)<=a&&(g[t]=g[n],d.push(r),t++)}g.length=t}}const p=[0,1];for(let t=0;t<2;t++){const e=0===t?s.getStartXY():s.getEndXY(),n=[0];rr(_,e,n);const i=new l;yr(_,n[0],i),l.distance(e,i)<=a&&(g.push(n[0]),d.push(p[t]))}for(let t=0;t<2;t++){const e=[0,2];{const n=s.getClosestCoordinate(_[e[t]],!1),i=new l;s.queryCoord2D(n,i),l.distance(_[e[t]],i)<=a&&(g.push(p[t]),d.push(n))}}return cm(t,e,s,g,d,g.length,n,i,o,a,h,0,u)}function pr(t,e,s,n,i,o,a,h,m,u){const c=T(l,3);e.queryControlPoints(c);const g=T(l,3);if(s.queryControlPoints(g),un(c,g,3)<0)return pr(t,s,e,n,o,i,a,h,m,!u);const d=mn(e,s);if(ln(e,s,a=Math.max(a,d)))return 0;if(function(t,e,s,n,i,r,o,a,h){const m=T(l,3);t.queryControlPoints(m);const u=T(l,3);if(e.queryControlPoints(u),m[0].equals(u[0])){if(m[1].equals(u[1])&&m[2].equals(u[2]))return s&&(s.length=0,s.push(m[0]),s.push(m[2])),n&&(n.length=0,n.push(0),n.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!m[0].equals(u[2]))return!1}return!!(m[0].equals(u[2])&&m[1].equals(u[1])&&m[2].equals(u[0]))&&(n&&(n.length=0,n.push(0),n.push(1),h&&(n[1]=p(n[0],n[0]=n[1]))),i&&(i.length=0,i.push(1),i.push(0),h&&(i[1]=p(i[0],i[0]=i[1]))),s&&(s.length=0,s.push(m[0]),s.push(m[2]),h&&(s[1]=p(s[0],s[0]=s[1]))),!0)}(e,s,n,i,o,0,0,0,u))return 2;const _=new r(0,1),f=new r(0,1);{const t=new Vs;or(c,r.unit(),t);const e=new Vs;or(g,r.unit(),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(ar(c,t,_),ar(g,t,f),_.isEmpty()||f.isEmpty())return 0;ur(c,_.vmin,_.vmax,c),ur(g,f.vmin,f.vmax,g)}}const x=dm(c,2,g,2,a);if(0===x)return 0;const y=[],P=[];if(-1===x){const t=T(Hs,3);xr(c,t);const e=[t[0].x,t[1].x,t[2].x],s=[t[0].y,t[1].y,t[2].y],n=T(Hs,3);xr(g,n);const i=Ei(e,2,s,2,null,0,[n[0].x,n[1].x,n[2].x],2,[n[0].y,n[1].y,n[2].y],2,null,0,0,r.unit(),r.unit(),y,P,u,0,u);if(i>0){let t=0;for(let e=0;e<i;e++){const s=new l,n=new l;yr(g,P[e],n),yr(c,y[e],s),l.distance(s,n)<=a&&(y[t]=y[e],P[t]=P[e],t++)}y.length=t,P.length=t}}for(let t=0;t<2;t++){const e=0===t?c:g,s=0===t?g:c;for(let n=0;n<2;n++){const i=0===n?0:2,r=[0];rr(s,e[i],r);const o=new l;yr(s,r[0],o),l.distance(e[i],o)<=a&&(0===t?(y.push(0===i?0:1),P.push(r[0])):(P.push(0===i?0:1),y.push(r[0])))}}if(0===y.length)return 0;if(!_.equalsRange(0,1))for(let t=0;t<y.length;++t)y[t]=xi.recalculateParentT(_.vmin,_.vmax,y[t]);if(!f.equalsRange(0,1))for(let t=0;t<P.length;++t)P[t]=xi.recalculateParentT(f.vmin,f.vmax,P[t]);return cm(t,e,s,y,P,y.length,n,i,o,a,h,0,u)}function fr(t,e,s=!1){const n=t[1].sub(t[0]);e[1].assign(n.mul(2)),e[2].assign(t[2].sub(t[1]).sub(n)),s?e[0].setCoords(0,0):e[0].assign(t[0])}function xr(t,e,s=!1){const n=Hs.constructPoint2D(t[1]),i=n.sub(Hs.constructPoint2D(t[0]));e[1]=i.mul(y.constructInt32(2)),e[2]=Hs.constructPoint2D(t[2]).sub(n).sub(i),e[0]=s?new Hs(St,St):Hs.constructPoint2D(t[0])}function yr(t,e,s,n){if(n){if(e<0)return void yn(new pm({start:t[0],end:t[0].add(Ki(t,0).getUnitVector())}),e,s);if(e>1)return void yn(new pm({start:t[2],end:t[2].add(Ki(t,1).getUnitVector())}),e-1,s)}if(e<=.5){const n=t[1].clone(),i=new l;nt(2,t[0],n,e,i);const r=new l;nt(2,n,t[2],e,r);const o=new l;nt(2,i,r,e,o),s.assign(o)}else{const n=t[1].clone(),i=new l;it(2,t[0],n,e,i);const r=new l;it(2,n,t[2],e,r);const o=new l;it(2,i,r,e,o),s.assign(o)}}function Pr(t,e){let s=1;t[1].isEqualPoint2D(t[0])&&(s=2,t[2].isEqualPoint2D(t[0])&&(s=3));let n=2;t[2].isEqualPoint2D(t[3])&&(n=1,t[1].isEqualPoint2D(t[3])&&(n=0)),e[0].assign(t[0]),e[2].assign(t[3]);const i=l.intersectLinesAtOnePoint(t[0],t[s],t[n],t[3]),r=new l;st(t[0],t[3],.5,r);const o=new l;Co(t,.5,o);const a=new l;e[1].assign(i),yr(e,.5,a);const h=new l;e[1].assign(r),yr(e,.5,h);const m=l.sqrDistance(o,a),u=l.sqrDistance(o,h);return m<u?(e[1].setCoordsPoint2D(i),Math.sqrt(m)):(e[1].setCoordsPoint2D(r),Math.sqrt(u))}function Cr(t,e,s){s[0].assign(t[0]),s[1].assign(t[1]),s[2].assign(t[2]);const n=new l;Ya(t,e,.5,n);const i=new l;yr(s,.5,i);const r=l.sqrDistance(n,i);return Math.sqrt(r)}const Er=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],Sr=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],vr=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],Ir=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],br=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],wr=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function Dr(t,e,s,n){const i=.5*(n-s),r=s+i,o=new q(0);for(let s=0,n=Math.trunc(t/2);s<n;++s){let n,a;switch(t){case 4:n=Er[s][0],a=Er[s][1];break;case 8:n=Sr[s][0],a=Sr[s][1];break;case 16:n=vr[s][0],a=vr[s][1];break;case 32:n=Ir[s][0],a=Ir[s][1];break;case 64:n=br[s][0],a=br[s][1];break;case 128:n=wr[s][0],a=wr[s][1];break;default:throw new Error("Quadrature_integral: invalid n")}const h=Tt(-.5,n,r),m=Tt(i,n,r);o.pe(e(h)*a),o.pe(e(m)*a)}return o.getResult()*i}class Tr extends zn{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!0}),this.m_segmentBufferCTor=fm):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=fm,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=fm):t.envelope?f("envelope constructor not impl"):P("bad arg to polygon constructor"):(super({bPolygon:!0}),this.m_segmentBufferCTor=fm)}assignMove(t){return t.copyTo(this),this}assignCopy(t){return t.copyTo(this),this}getBoundary(){return Qn(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return Tr.type}getDimension(){return 2}createInstance(){return new Tr({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}Tr.type=o.enumPolygon;var Nr=Ee;const Ar=-1,Mr=1;class Gr{constructor(t){this.m_shape=t}userSort(t,e,s){this.m_shape.sortVerticesSimpleByYHelper(s,t,e)}getValue(t){return this.m_shape.getY(t)}}class qr{constructor(t){!function(t){return void 0!==t.parent}(t)?(this.m_parent=t.copy.m_parent,this.m_geometry=t.copy.m_geometry,this.m_path=t.copy.m_path,this.m_vertex=t.copy.m_vertex,this.m_index=t.copy.m_index,this.m_bSkipMultiPoints=t.copy.m_bSkipMultiPoints,this.m_firstVertex=t.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=t.copy.m_selection,this.m_bOneGeom=t.copy.m_bOneGeom):(this.m_parent=t.parent,this.m_geometry=t.geometry,this.m_path=t.path,this.m_vertex=t.vertex,this.m_firstVertex=t.firstVertex,this.m_index=t.selection?0:t.index,this.m_bSkipMultiPoints=t.bSkipMultiPoints,this.m_selection=t.selection,this.m_bOneGeom=t.bOneGeom,this.m_bFirst=!0)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==Ar;){for(;this.m_path!==Ar;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==Ar)return this.m_vertex;if(this.m_bOneGeom)return Ar;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===Ar)break;this.m_bSkipMultiPoints&&!Z(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return Ar}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const t=this.m_parent.m_selectedVertices[this.m_index++];if(t!==Ar&&(this.m_path=this.m_parent.getPathFromVertex(t),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),t}return Ar}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==Ar?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==Ar&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):Ar}currentGeometry(){return this.m_geometry}currentPath(){return this.m_path}static create_(t,e,s,n,i,r,o,a,h){return new qr({parent:t,geometry:e,path:s,vertex:n,firstVertex:i,index:r,bSkipMultiPoints:o,selection:a,bOneGeom:h})}}class Fr{constructor(t){this.parentage=t}equals(t){return this.parentage===t.parentage}}class Vr{setPrevPath(t,e){this.m_pathIndexList.setField(t,1,e)}setNextPath(t,e){this.m_pathIndexList.setField(t,2,e)}setPathFlags(t,e){this.m_pathIndexList.setField(t,6,e)}getPathFlags(t){return this.m_pathIndexList.getField(t,6)}setPathGeometry(t,e){this.m_pathIndexList.setField(t,7,e)}getPathIndex(t){return this.m_pathIndexList.getField(t,0)}setNextGeometry(t,e){this.m_geometryIndexList.setField(t,1,e)}setPrevGeometry(t,e){this.m_geometryIndexList.setField(t,0,e)}getGeometryIndex(t){return this.m_geometryIndexList.getField(t,7)}setFirstPath(t,e){this.m_geometryIndexList.setField(t,3,e)}setLastPath(t,e){this.m_geometryIndexList.setField(t,4,e)}newGeometry(t){const e=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(e,2,t),this.m_geometryIndexList.setField(e,5,0),this.m_geometryIndexList.setField(e,6,0),this.m_geometryIndexList.setField(e,7,this.m_geometryIndexList.elementToIndex(e)),e}freeGeometry(t){this.m_geometryIndexList.deleteElement(t)}newPath(t){const e=this.m_pathIndexList.newElement(),s=this.m_pathIndexList.elementToIndex(e);if(this.m_pathIndexList.setField(e,0,s),this.m_pathIndexList.setField(e,3,0),this.m_pathIndexList.setField(e,6,0),this.setPathGeometry(e,t),s>=this.m_pathAreas.length){const t=Math.trunc(s<16?16:3*s/2);this.m_pathAreas.length=t,this.m_pathLengths.length=t}return this.m_pathAreas[s]=0,this.m_pathLengths[s]=0,this.m_pathCount++,e}freePath(t){this.m_pathIndexList.deleteElement(t),this.m_pathCount--}newVertex(t){const e=this.m_vertexIndexList.newElement(),s=t>=0?t:this.m_vertexIndexList.elementToIndex(e);if(this.m_vertexIndexList.setField(e,0,s),t<0){if(s>=this.m_vertices.getPointCount()){const t=Math.trunc(s<16?16:3*s/2);this.m_vertices.reserveRounded(t),this.m_vertices.resizeNoInit(t),null!==this.m_segments&&(this.m_segments.length=t),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[s]=null)}return this.m_pointCount++,e}freeVertex(t){this.unselect(t);const e=this.getVertexIndex(t);this.m_vertexIndexList.deleteElement(t),this.m_pointCount--;for(let t=0,s=this.m_indices.length;t<s;t++){if(t===this.m_selectionIndex)continue;const s=this.m_indices[t];null!==s&&s.size()>e&&s.write(e,-1)}this.m_weights&&this.m_weights.size()>e&&this.m_weights.write(e,1),this.m_ranks&&this.m_ranks.size()>e&&this.m_ranks.write(e,1),this.m_segmentWeights&&this.m_segmentWeights.size()>e&&this.m_segmentWeights.write(e,1),this.m_segmentRanks&&this.m_segmentRanks.size()>e&&this.m_segmentRanks.write(e,1),this.m_segments&&this.setSegmentToIndex(e,null)}insertVertex_(t,e,s,n){this.m_hasForceSetEnvelope=0;const i=e!==Ar?this.getPrevVertex(e):this.getLastVertex(t),r=i!==Ar?this.getNextVertex(i):Ar,o=this.newVertex(null===s?this.m_pointCount:-1),a=this.getVertexIndex(o);null!==s&&this.m_vertices.setPointByValNoCurves(a,s),this.setPathToVertex(o,t),this.setNextVertex(o,r),this.setPrevVertex(o,i),r!==Ar&&this.setPrevVertex(r,o),i!==Ar&&this.setNextVertex(i,o);const h=this.isClosedPath(t),m=this.getFirstVertex(t);e===Ar&&this.setLastVertex(t,o),e===m&&(h&&n&&m!==Ar||this.setFirstVertex(t,o)),h&&r===Ar&&(this.setNextVertex(o,o),this.setPrevVertex(o,o)),this.setPathSize(t,this.getPathSize(t)+1);const l=this.getGeometryFromPath(t);return this.setGeometryVertexCount(l,this.getPointCount(l)+1),o}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new qe({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPoint(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return this.appendMultiPoint(s,t,e),s}addPoint_(t,e){const s=this.createGeometry(o.enumMultiPoint,t.getDescription());return this.appendPoint(s,t,e),s}appendMultiPath_(t,e){if(e.isEmpty())return;const s=e.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+s.getPointCount()),this.m_verticesMp.addPoints(e,0,s.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const n=null!==this.m_segments||null!==s.getSegmentFlagsStreamRef();this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+s.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+s.getPathCount());for(let e=0,i=s.getPathCount();e<i;e++){if(0===s.getPathSize(e))continue;const i=this.insertPath(t,Ar);this.setClosedPath(i,s.isClosedPath(e));for(let t=s.getPathStart(e),r=s.getPathEnd(e);t<r;t++){const e=this.insertVertex_(i,Ar,null,!1);if(n){const n=this.getVertexIndex(e);if(1&s.getSegmentFlags(t))this.setSegmentToIndex(n,null);else{const e=new fm;s.querySegment(t,e,!0),this.setSegmentToIndex(n,e.releaseSegment())}}}s.isStrongPathStart(e)&&this.setStrongPathStart(i,!0),s.isStrongPathEnd(e)&&this.setStrongPathEnd(i,!0)}}addMultiPath(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return t.getGeometryType()===o.enumPolygon&&this.setFillRule(s,t.getFillRule()),this.appendMultiPath(s,t,e),s}appendMultiPathPolyline(e,s,n){const i=s.getImpl(),r=null!==this.m_segments||null!==i.getSegmentFlagsStreamRef(),o=new t;s.queryEnvelope(o);{const t=n.clone();let o=i.getPointCount();const a=i.getAccelerators();if(a&&a.getQuadTree()&&(o=a.getQuadTree().getIntersectionCount(t,0,i.getPointCount()+1)),o<s.getPointCount()){if(0===o)return;const n=i.queryLimitedSegmentIterator(t);let a=-1,h=-100,m=-1,l=0,u=-1,c=Ar,g=!1,d=n.nextSegment();if(null!==d)for(;;d=n.nextSegment()){let t=null===d;const o=null!==d?n.getPathIndex():a,_=null!==d?n.getStartPointIndex():h;if(t||(a===o&&h+1===_?l++:t=!0),t){if(-1!==u){let t=-1,e=-1;if(l===m){this.setClosedPath(c,g);const n=i.getPathEnd(a);this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+n-u),this.m_verticesMp.addPoints(s,u,n),e=i.getPathSize(a),t=n-1}else if(!g||h+1<i.getPathEnd(a))this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h+2-u),this.m_verticesMp.addPoints(s,u,h+2),e=h-u+2,t=h;else{this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h+2-u),this.m_verticesMp?.addPoints(s,u,h+1),t=h,e=h-u+1;const n=i.getPathStart(a);this.m_verticesMp.addPoints(s,n,n+1),e+=1}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);for(let s=0,n=u;s<e;s++,n++){const e=this.insertVertex_(c,Ar,null,!1);if(r){const s=this.getVertexIndex(e);if(1&i.getSegmentFlags(n)||n>t)this.setSegmentToIndex(s,null);else{const t=new fm;i.getSegmentBuffer(n,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(null===d)break;l=1,u=_,a!==o?(c=this.insertPath(e,Ar),this.setClosedPath(c,!1),m=i.getSegmentCountPath(o),g=i.isClosedPath(o),a=o):c=this.insertPath(e,Ar)}h=_}return}}this.appendMultiPath_(e,s)}appendMultiPathPolygon(e,s,i){const r=s.getImpl(),o=null!==this.m_segments||null!==r.getSegmentFlagsStreamRef(),a=t.constructEmpty();s.queryEnvelope(a),n(i.isIntersecting(a)&&!i.containsEnvelope(a));let h=t.construct(Number.NEGATIVE_INFINITY,i.ymin,Number.POSITIVE_INFINITY,i.ymax),m=t.construct(i.xmin,Number.NEGATIVE_INFINITY,i.xmax,Number.POSITIVE_INFINITY);const l=r.getAccelerators();if(l&&l.getQuadTree()){const t=l.getQuadTree(),e=t.getIntersectionCount(h,0,0);e>t.getIntersectionCount(m,0,e+1)&&(m=p(h,h=m))}else h.height()>m.width()&&(m=p(h,h=m));const u=[],c=r.queryLimitedSegmentIterator(h);let g=-1,d=-100,_=-1,f=0,x=-1,y=-1,P=Ar,C=!0,E=c.nextSegment();if(null!==E)for(;;E=c.nextSegment()){let i=null===E;const a=null!==E?c.getPathIndex():g,h=null!==E?c.getStartPointIndex():d;if(i||(a===g?d+1===h?f++:i=!0:(i=g>=0,g<0&&(g=a,_=r.getSegmentCountPath(g),x=h,P=Ar,f=1))),i){if(0!==u.length||_!==f){0!==u.length&&u[0].first===x||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(s,x,x+1),-1===y&&(y=x),P===Ar&&(P=this.insertPath(e,Ar),this.setClosedPath(P,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(P,Ar,null,!1));for(const{first:t,second:i}of u){-1===y&&(y=t);let a=-1,h=-1;const m=t+i-1;if(i===_){const e=m+1;h=e-t,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(s,t,e),a=m,n(1===u.length)}else if(m+1<r.getPathEnd(g)){const e=m+2;h=e-t,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(s,t,e),a=m}else{const e=r.getPathStart(g),n=e!==y?1:0,i=m+1;h=i-t+n,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(i-t)+n),this.m_verticesMp.addPoints(s,t,i),a=m,n>0&&this.m_verticesMp?.addPoints(s,e,e+1)}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),P===Ar&&(P=this.insertPath(e,Ar),this.setClosedPath(P,!0));for(let e=0,s=t;e<h;e++,s++){const t=this.insertVertex_(P,Ar,null,!1);if(o){const e=this.getVertexIndex(t);if(1&r.getSegmentFlags(s)||s>a)this.setSegmentToIndex(e,null);else{const t=new fm;r.getSegmentBuffer(s,t,!0),this.setSegmentToIndex(e,t.releaseSegment())}}}}if(0===u.length||u.at(-1).first+u.at(-1).second!==x+f){let t=x+f;t===s.getPathEnd(g)&&(t=s.getPathStart(g)),y!==t&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(s,t,t+1),this.insertVertex_(P,Ar,null,!1))}}u.length=0,C=!0,a!==g&&(g=a,_=r.getSegmentCountPath(g),P=Ar,y=-1),x=h,f=1}if(!E)break;{const e=t.constructEmpty();E.queryLooseEnvelope(e),m.isIntersecting(e)?(C?u.push(ft(h,1)):u.at(-1).second++,C=!1):C=!0}d=h}}appendMultiPath(e,s,n){if(void 0===n)return void this.appendMultiPath_(e,s);if(s.isEmpty())return;const i=s.getGeometryType()===o.enumPolygon,r=t.constructEmpty();s.queryEnvelope(r),n.isIntersecting(r)&&(!n.containsEnvelope(r)&&s.getPointCount()>10?i?this.appendMultiPathPolygon(e,s,n):this.appendMultiPathPolyline(e,s,n):this.appendMultiPath_(e,s))}appendPoint(t,e,s){if(e.isEmpty())return;if(void 0!==s&&!s.contains(e.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(e),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const n=this.insertPath(t,Ar);this.insertVertex_(n,Ar,null,!1)}appendMultiPoint_(t,e){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+e.getPointCount()),this.m_verticesMp.addPoints(e,0,e.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+e.getPointCount());const s=this.insertPath(t,Ar);for(let t=0,n=e.getPointCount();t<n;t++)this.insertVertex_(s,Ar,null,!1)}appendMultiPoint(t,e,s){if(void 0===s)return void this.appendMultiPoint_(t,e);const n=e.getAttributeStreamRef(0);let i=0;for(let t=0,r=e.getPointCount();t<r;t++){const e=n.readPoint2D(2*t);s.contains(e)&&i++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i);let r=-1,o=-1,a=0;for(let t=0,i=e.getPointCount();t<i;t++){const i=n.readPoint2D(2*t);s.contains(i)?(-1===r&&(r=t,o=t),o++):r>=0&&(this.m_verticesMp.addPoints(e,r,o-r),r=-1,a++)}if(r>0&&(this.m_verticesMp.addPoints(e,r,o-r),a++),!a)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+i);const h=this.insertPath(t,Ar);for(let t=0,i=e.getPointCount();t<i;t++){const e=n.readPoint2D(2*t);s.contains(e)&&this.insertVertex_(h,Ar,null,!1)}}splitSegmentForward(t,e,n,i,r){const a=this.getNextVertex(t);a===Ar&&s("Edit_shape.split_segment_forward_");const h=this.getHelperPoint(),m=this.getPathFromVertex(t);let l=t;const u=this.hasSegmentParentage();for(let t=0,s=e.getResultSegmentCount(n);t<s;t++){const i=this.getVertexIndex(l),c=this.getNextVertex(l),g=e.getResultSegment(n,t);let d=null;if(g.getGeometryType()!==o.enumLine&&(d=g.clone(),d.dropAllAttributes()),0===t&&(g.queryStart(h),this.setSegmentToIndex(i,null),this.setPointEx(l,h,e.getResultSegmentStartPointRank(n,t),e.getResultSegmentStartPointWeight(n,t),r)),this.setSegmentRank(l,e.getResultSegmentInteriorRank(n,t)),this.setSegmentWeight(l,e.getResultSegmentInteriorWeight(n,t)),u){const s=e.getResultSegmentSegmentParentage(n,t),i=e.getResultSegmentStartPointIsBreak(n,t);this.setSegmentParentageAndBreak(l,s,i)}if(g.queryEnd(h),t<s-1){this.setSegmentToIndex(i,d);const s=this.insertVertex(m,c,h);this.setWeight(s,e.getResultSegmentEndPointWeight(n,t)),this.setRank(s,e.getResultSegmentEndPointRank(n,t)),this.select(s),l=s}else{this.setPointEx(a,h,e.getResultSegmentEndPointRank(n,t),e.getResultSegmentEndPointWeight(n,t),r);const s=e.getResultSegmentEndPointIsBreak(n,t);this.setSegmentParentageBreakVertex(a,s),this.setSegmentToIndex(i,d)}}}splitSegmentBackward(t,e,n,i,r){const a=this.getNextVertex(t);a===Ar&&s("Edit_shape.split_segment_backward_");const h=this.getHelperPoint(),m=this.getPathFromVertex(t);let l=t;const u=this.hasSegmentParentage();for(let t=0,s=e.getResultSegmentCount(n);t<s;t++){const i=s-t-1,c=this.getVertexIndex(l),g=this.getNextVertex(l),d=e.getResultSegment(n,i);let _=null;if(d.getGeometryType()!==o.enumLine&&(_=d.clone(),_.reverse(),_.dropAllAttributes()),0===t&&(d.queryEnd(h),this.setSegmentToIndex(c,null),this.setPointEx(l,h,e.getResultSegmentEndPointRank(n,i),e.getResultSegmentEndPointWeight(n,i),r),this.setSegmentParentageAndBreak(l,e.getResultSegmentSegmentParentage(n,i),e.getResultSegmentEndPointIsBreak(n,i))),d.getGeometryType()===o.enumLine?this.setSegmentToIndex(c,null):this.setSegmentToIndex(c,_),this.setSegmentRank(l,e.getResultSegmentInteriorRank(n,i)),this.setSegmentWeight(l,e.getResultSegmentInteriorWeight(n,i)),d.queryStart(h),t<s-1){const t=this.insertVertex(m,g,h);this.setWeight(t,e.getResultSegmentStartPointWeight(n,i)),this.setRank(t,e.getResultSegmentStartPointRank(n,i)),this.select(t),l=t,u&&this.setSegmentParentageAndBreak(t,e.getResultSegmentSegmentParentage(n,i),e.getResultSegmentEndPointIsBreak(n,i))}else this.setPointEx(a,h,e.getResultSegmentStartPointRank(n,i),e.getResultSegmentStartPointWeight(n,i),r)}}selected_(t){return this.getUserIndex(t,this.m_selectionIndex)>=0}allocateIndex(t=!0){if(this.m_deletedIndices.length){const e=this.m_deletedIndices.pop();return t&&e.setRange(-1,0,e.size()),e}return t?Xe(0,-1):Xe(0)}recycleUserIndex(t){this.m_deletedIndices.push(t)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const t=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),t}return Xe(0)}recyclePathUserIndex(t){this.m_deletedPathIndices.push(t)}peelALoop_(t,e,s){const n=this.getNextVertex(t),i=this.getNextVertex(e),r=this.getVertexIndex(t),o=this.getVertexIndex(e);if(this.setNextVertex(t,i),this.setPrevVertex(i,t),this.setNextVertex(e,n),this.setPrevVertex(n,e),this.m_segments){const t=this.getSegmentFromIndex(r),e=this.getSegmentFromIndex(o);this.setSegmentToIndex(o,null),this.setSegmentToIndex(r,e),this.setSegmentToIndex(o,t)}if(this.hasSegmentParentage()){let s=this.getSegmentParentage(e),n=this.getSegmentParentage(t);-1===s&&-1===n||(n=p(s,s=n),this.setSegmentParentageAndBreak(t,n),this.setSegmentParentageAndBreak(e,s))}if(s){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e),r=[!1],o=this.insertClosedPath(s,Ar,n,this.getFirstVertex(e),r);r[0]&&this.setFirstVertex(e,i);let a=this.getPathSize(e);return a-=this.getPathSize(o),this.setPathSize(e,a),o}return Ar}sortVerticesSimpleByYHelper(t,e,s){t.sort(e,s,(t,e)=>{let s=this.compareVerticesSimpleY(t,e);if(0===s){const n=this.getPathInternalIndexFromVertex(t),i=this.getPathInternalIndexFromVertex(e);s=n<i?-1:n>i?1:0}return s})}sortVerticesSimpleByYHelper3D(t,e,s){n(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=ve.constructEmpty(),this.m_hasForceSetEnvelope=0,this.m_workPoint2D=l.getNAN(),this.m_workPoint2_2D=l.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=Ar,this.m_lastGeometry=Ar,this.m_vertexIndexList=new Ue(5),this.m_pathIndexList=new Ue(8),this.m_geometryIndexList=new Ue(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new Ve,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(e){if(0!==this.m_hasForceSetEnvelope)return new t(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const s=this.hasCurves(),n=t.constructEmpty(),i=this.queryVertexIterator();let r=!0;for(let e=i.next();e!==Ar;e=i.next()){if(r?n.merge(this.getXY(e)):n.mergeNe(this.getXY(e)),s){const s=this.getSegment(e);if(null!==s){const e=t.constructEmpty();s.queryLooseEnvelope(e),n.mergeEnvelope2D(e)}}r=!1}return n}getEnvelope3D(t){return n(0),ve.constructEmpty()}forceSetEnvelope2D(t){this.m_hasForceSetEnvelope=1,this.m_forceSetEnvelope.setCoords(t.xmin,t.ymin,0,t.xmax,t.ymax,0)}forceSetEnvelope3D(t){n(0)}forgetForceSetEnvelope(){this.m_hasForceSetEnvelope=0}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(t,e){const n=t.getGeometryType();if(Z(n))return this.addMultiPath(t,e);if(n===o.enumMultiPoint)return this.addMultiPoint(t,e);if(n===o.enumPoint)return this.addPoint_(t,e);if(n===o.enumEnvelope){const s=new Tr;return s.addEnvelope(t,!1),this.addMultiPath(s,e)}s("")}appendGeometry(t,e){this.mergeVertexDescription(e.getDescription());const n=e.getGeometryType();Z(n)?this.appendMultiPath(t,e):n!==o.enumMultiPoint?s(""):this.appendMultiPoint(t,e)}assignRankToGeometryVertices(t,e){e<1&&(e=1);const s=this.queryVertexIterator();for(let t=s.next();t!==Ar;t=s.next())this.setRank(t,e),this.setSegmentRank(t,e)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(o.enumUnknown)}collapseGeometriesToFirst(t){this.dbgVerifyVertexCounts();let e=Ar,s=-1,n=-1;for(let i=this.getFirstGeometry();i!==Ar;){if(t===o.enumUnknown||this.getGeometryType(i)===t){if(e===Ar){e=i,s=this.getPathCount(e),n=this.getPointCount(e),i=this.getNextGeometry(i);continue}for(let t=this.getFirstPath(i);t!==Ar;t=this.getNextPath(t))this.setPathGeometry(t,e);s+=this.getPathCount(i),n+=this.getPointCount(i);const t=this.getLastPath(e),r=this.getFirstPath(i);t!==Ar?this.setNextPath(t,r):this.setFirstPath(e,r),r!==Ar&&(this.setPrevPath(r,t),this.setLastPath(e,this.getLastPath(i))),this.setFirstPath(i,Ar),this.setLastPath(i,Ar);const o=i;i=this.getNextGeometry(i),this.setGeometryVertexCount(o,0),this.removeGeometry(o);continue}i=this.getNextGeometry(i)}return e!==Ar&&(this.setGeometryVertexCount(e,n),this.setGeometryPathCount(e,s),this.dbgVerifyVertexCounts()),e}setFillRule(t,e){let s=this.m_geometryIndexList.getField(t,2);s&=-134217729,s|=1===e?134217728:0,this.m_geometryIndexList.setField(t,2,s)}getFillRule(t){return 134217728&this.m_geometryIndexList.getField(t,2)?1:0}setGeometryModified(t,e){let s=this.m_geometryIndexList.getField(t,2);!!(67108864&s)!==e&&(s&=-67108865,s|=e?67108864:0,this.m_geometryIndexList.setField(t,2,s))}getGeometryModified(t){return!!(67108864&this.m_geometryIndexList.getField(t,2))}setGeometryModifiedWithVertex(t,e){const s=this.getPathFromVertex(t),n=this.getGeometryFromPath(s);this.setGeometryModified(n,e)}getGeometryModifiedWithVertex(t){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e);return this.getGeometryModified(s)}swapGeometry(t,e){const s=this.getFirstPath(t),n=this.getFirstPath(e),i=this.getLastPath(t),r=this.getLastPath(e);for(let s=this.getFirstPath(t);s!==Ar;s=this.getNextPath(s))this.setPathGeometry(s,e);for(let s=this.getFirstPath(e);s!==Ar;s=this.getNextPath(s))this.setPathGeometry(s,t);this.setFirstPath(t,n),this.setFirstPath(e,s),this.setLastPath(t,r),this.setLastPath(e,i);const o=this.getPointCount(t),a=this.getPathCount(t),h=this.getPointCount(e),m=this.getPathCount(e);this.setGeometryVertexCount(t,h),this.setGeometryVertexCount(e,o),this.setGeometryPathCount(t,m),this.setGeometryPathCount(e,a);const l=this.m_geometryIndexList.getField(t,2),u=this.m_geometryIndexList.getField(e,2);this.m_geometryIndexList.setField(t,2,u),this.m_geometryIndexList.setField(e,2,l)}addPathFromMultiPath(t,e,s){const n=this.createGeometry(s?o.enumPolygon:o.enumPolyline,t.getDescription()),i=t.getImpl();if(t.getPathSize(e)<2)return n;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+t.getPathSize(e)),this.m_verticesMp.addPoints(t,t.getPathStart(e),i.getPathEnd(e)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const r=this.insertPath(n,Ar);this.setClosedPath(r,i.isClosedPath(e)||s);const a=null!==this.m_segments||null!==i.getSegmentFlagsStreamRef();for(let t=i.getPathStart(e),s=i.getPathEnd(e);t<s;t++){const e=this.insertVertex_(r,Ar,null,!1);if(a){const s=this.getVertexIndex(e);if(1&i.getSegmentFlags(t))this.setSegmentToIndex(s,null);else{const e=new fm;i.querySegment(t,e,!0),this.setSegmentToIndex(s,e.releaseSegment())}}}return i.isStrongPathStart(e)&&this.setStrongPathStart(r,!0),i.isStrongPathEnd(e)&&this.setStrongPathEnd(r,!0),n}getGeometry(t){const e=this.getGeometryType(t),n=function(t,e){let n,i=e,r=null;switch(i||(r=dt(t)?Ge():fe(),i=r),t){case o.enumPoint:n=new qe({vd:i});break;case o.enumLine:n=new pm({vd:i});break;case o.enumBezier:n=new jo({vd:i});break;case o.enumEllipticArc:n=new eh({vd:i});break;case o.enumRationalBezier2:n=new pi({vd:i});break;case o.enumBezier2:n=new xi({vd:i});break;case o.enumEnvelope:n=new Ne({vd:i});break;case o.enumMultiPoint:n=new Fs({vd:i});break;case o.enumPolyline:n=new Wn({vd:i});break;case o.enumPolygon:n=new Tr({vd:i});break;case o.enumMultipatch:f("multipatch not impl");break;case o.enumGeometryCollection:n=new _n({vd:i});break;default:s("Geometry.create")}return n}(e,this.m_verticesMp.getDescription()),i=this.getPointCount(t);if(0===i)return n;if(Z(e)){const e=n.getImpl(),s=this.getPathCount(t),r=Xe(s+1),o=ke(s+1,0),a=n.getDescription(),h=this.hasCurves();for(let n=0,h=a.getAttributeCount();n<h;n++){const h=a.getSemantics(n),m=Nr.getComponentCount(h),l=Te(h,i),u=this.m_vertices.getAttributeStreamRef(h);let c=0,g=0,d=0;for(let e=this.getFirstPath(t);e!==Ar;e=this.getNextPath(e)){let t=0;this.isClosedPath(e)&&(t|=1),this.isExterior(e)&&(t|=8),this.isStrongPathStart(e)&&(t|=2),this.isStrongPathEnd(e)&&(t|=4),t&&o.setBits(g,t);const s=this.getPathSize(e);if(r.write(g++,d),d+=s,0===h){const t=u,s=l;let n;for(let i=this.getFirstVertex(e);c<d;i=this.getNextVertex(i),c++){const e=this.getVertexIndex(i);n=t.readPoint2D(2*e),s.writePoint2D(2*c,n)}}else for(let t=this.getFirstVertex(e);c<d;t=this.getNextVertex(t),c++){const e=this.getVertexIndex(t);for(let t=0;t<m;t++){const s=u.readAsDbl(e*m+t);l.writeAsDbl(c*m+t,s)}}}e.setAttributeStreamRef(h,l),r.write(s,i)}if(e.setPathFlagsStreamRef(o),e.setPathStreamRef(r),e.notifyModifiedFlags(65535),h){let s=0,n=0;for(let i=this.getFirstPath(t);i!==Ar;i=this.getNextPath(i)){s+=this.getPathSize(i);for(let t=this.getFirstVertex(i);n<s;t=this.getNextVertex(t)){const s=this.getSegment(t);null!==s&&s.isCurve()&&e.replaceSegment(n,s,!0),n++}}}}else if(e===o.enumMultiPoint){const e=n.getImpl(),s=n.getDescription();e.reserve(i),e.resizeNoInit(i);for(let n=0,i=s.getAttributeCount();n<i;n++){const i=s.getSemantics(n),r=Nr.getComponentCount(i),o=e.getAttributeStreamRef(i),a=this.m_vertices.getAttributeStreamRef(i);let h=0;const m=this.getFirstPath(t),l=this.getPathSize(m);for(let t=this.getFirstVertex(m);h<l;t=this.getNextVertex(t),h++){const e=this.getVertexIndex(t);for(let t=0;t<r;t++){const s=a.readAsDbl(e*r+t);o.writeAsDbl(h*r+t,s)}}e.setAttributeStreamRef(i,o)}e.notifyModifiedFlags(65535)}else P("getGeometry");return n}queryPointGeometryOnly(t,e){this.getGeometryType(t)!==o.enumMultiPoint&&s("get_point_geometry_only");const n=this.getPointCount(t);if(n>1&&s("get_point_geometry_only"),0===n)return e.assignVertexDescription(this.m_vertexDescription),void e.setEmpty();const i=this.getFirstPath(t),r=this.getFirstVertex(i);this.queryPoint(r,e)}removeGeometry(t){for(let e=this.getFirstPath(t);e!==Ar;e=this.removePath(e));const e=this.getPrevGeometry(t),s=this.getNextGeometry(t);return e!==Ar?this.setNextGeometry(e,s):this.m_firstGeometry=s,s!==Ar?this.setPrevGeometry(s,e):this.m_lastGeometry=e,this.freeGeometry(t),s}createGeometry(t,e){void 0===e&&(e=fe());const s=this.newGeometry(t);return this.m_vertices||(this.m_verticesMp=new Fs({vd:e}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(e),this.m_firstGeometry===Ar?(this.m_firstGeometry=s,this.m_lastGeometry=s):(this.setPrevGeometry(s,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,s),this.m_lastGeometry=s),s}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(t){return this.m_geometryIndexList.getField(t,1)}getPrevGeometry(t){return this.m_geometryIndexList.getField(t,0)}getGeometryType(t){return 16777215&this.m_geometryIndexList.getField(t,2)}setGeometryUserIndex(t,e,s){const n=this.m_geometryIndices[e],i=this.getGeometryIndex(t);i>=n.size()&&n.resize(Math.max(1.25*i,16),-1),n.write(i,s)}getGeometryUserIndex(t,e){const s=this.getGeometryIndex(t),n=this.m_geometryIndices[e];return s<n.size()?n.read(s):-1}createGeometryUserIndex(){for(let t=0;t<this.m_geometryIndices.length;t++)if(null===this.m_geometryIndices[t])return this.m_geometryIndices[t]=Xe(0),t;this.m_geometryIndices.push(Xe(0));const t=this.m_geometryIndices.length-1;return n(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}removeGeometryUserIndex(t){for(this.m_geometryIndices[t]=null;this.m_geometryIndices.length>0&&null===this.m_geometryIndices.at(-1);)this.m_geometryIndices.pop()}getFirstPath(t){return this.m_geometryIndexList.getField(t,3)}getLastPath(t){return this.m_geometryIndexList.getField(t,4)}hasPointFeatures(){for(let t=this.getFirstGeometry();t!==Ar;t=this.getNextGeometry(t))if(!Z(this.getGeometryType(t)))return!0;return!1}getPointCount(t){return this.m_geometryIndexList.getField(t,5)}getPathCount(t){return this.m_geometryIndexList.getField(t,6)}filterClosePoints(t,e,s,i,r){const a=t*t;let h=0;const m=this.hasCurves(),u=this.hasSegmentParentage(),c=!0;for(let t=r===Ar?this.getFirstGeometry():r;t!==Ar;t=r===Ar?this.getNextGeometry(t):Ar){const r=this.getGeometryType(t);if(!Z(r))continue;if(s&&r!==o.enumPolygon)continue;const g=this.getGeometryType(t)===o.enumPolygon;let d=this.getGeometryModified(t);for(let s=this.getFirstPath(t);s!==Ar;){let r=0;for(let e=this.getFirstVertex(s);r<Math.trunc(this.getPathSize(s)/2);){const o=this.getNextVertex(e);if(o===Ar)break;const g=this.getXY(e),_=this.getXY(o);let p=l.sqrDistance(g,_),f=!0;do{if(p<=a){if(m){const t=this.getSegment(e);if(null!==t){const e=t.calculateLength2D();if(p=e*e,p>a)break}}if(0===p?0===h&&(h=-1):h=1,o!==this.getLastVertex(s)){const s=u&&(this.getSegmentParentageBreakVertex(e)||this.getSegmentParentageBreakVertex(o));if(this.transferAllDataToTheVertex(o,e,c),this.removeVertex(o,!1),i&&!d&&(this.setGeometryModified(t,!0),d=!0),u&&e!==o){this.setSegmentParentageBreakVertex(e,s);const t=this.getNextVertex(e);n(t!==Ar),this.isDiscontinuousSegmentParentage(t)&&this.setSegmentParentageBreakVertex(t,!0)}}f=!1}}while(0);f&&(e=this.getNextVertex(e)),r++}let o=this.getFirstVertex(s);for(let e=this.isClosedPath(s)?o:this.getLastVertex(s);this.getPathSize(s)>0;){const r=this.getPrevVertex(e);if(r===Ar)break;{const g=this.getXY(r),_=this.getXY(e);let p=l.sqrDistance(g,_),f=!0;do{if(p<=a){if(m){const t=this.getSegment(r);if(null!==t){const e=t.calculateLength2D();if(p=e*e,p>a)break}}if(0===p?0===h&&(h=-1):h=1,u){n(this.m_segmentParentageIndex>=0);const t=this.getUserIndex(e,this.m_segmentParentageIndex);this.transferAllDataToTheVertex(r,e,c),this.setUserIndex(e,this.m_segmentParentageIndex,t)}else this.transferAllDataToTheVertex(r,e,c);const l=u&&(this.getSegmentParentageBreakVertex(e)||this.getSegmentParentageBreakVertex(r));this.removeVertex(r,!0),i&&!d&&(this.setGeometryModified(t,!0),d=!0),u&&r!==e&&(l||this.isDiscontinuousSegmentParentage(e))&&this.setSegmentParentageBreakVertex(e,!0),o===r&&(o=this.getFirstVertex(s)),f=!1}}while(0);if(f&&(e=this.getPrevVertex(e),e===o))break}}const _=this.getPathSize(s);let p=e&&_<(g?3:2);p&&g&&2===_&&m&&(p=!this.pathHasCurves(s)),p?(s=this.removePath(s),0===h&&(h=-1),i&&!d&&(this.setGeometryModified(t,!0),d=!0)):s=this.getNextPath(s)}}return h}filterClosePoints3D(t,e,s,i,r,o){return n(0),0}hasDegenerateSegments(t){for(let e=this.getFirstGeometry();e!==Ar;e=this.getNextGeometry(e))if(Z(this.getGeometryType(e)))for(let s=this.getFirstPath(e);s!==Ar;){const e=this.getPathSize(s);if(0===e)return!0;let n=this.getFirstVertex(s);for(let s=0;s<e;s++){const e=this.getNextVertex(n);if(e===Ar)break;const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);let r=0;if(null!==i){if(r=i.calculateLowerLength2D(),r<=t){if(r=i.calculateUpperLength2D(),r<=t)return!0;if(r=i.calculateLength2D(),r<=t)return!0}}else{const n=this.getVertexIndex(e);if(r=this.m_vertices.getShortestDistance(s,n),r<=t)return!0}n=e}s=this.getNextPath(s)}return!1}hasDegenerateSegments3D(t,e){return n(0),!1}transferAllDataToTheVertex(t,e,s=!1){const n=this.getVertexIndex(t),i=this.getVertexIndex(e);if(s){let t=1,e=1;if(this.m_ranks&&(t=this.getRankWithIndex(n),e=this.getRankWithIndex(i)),t>e&&this.setRankWithIndex(i,t),t>=e&&this.m_weights){const s=this.getWeightWithIndex(n),r=this.getWeightWithIndex(i);(t>e||s>r)&&this.setWeightWithIndex(i,s)}}else{if(this.m_weights){const t=this.getWeightWithIndex(n);this.setWeightWithIndex(i,t)}if(this.m_ranks){const t=this.getRankWithIndex(n);this.setRankWithIndex(i,t)}}if(this.m_segmentWeights){const t=this.getSegmentWeightWithIndex(n);this.setSegmentWeightWithIndex(i,t)}if(this.m_segmentRanks){const t=this.getSegmentRankWithIndex(n);this.setSegmentRankWithIndex(i,t)}for(let s=0,n=this.m_indices.length;s<n;s++)if(s!==this.m_selectionIndex&&null!==this.m_indices[s]){const n=this.getUserIndex(t,s);this.setUserIndex(e,s,n)}const r=this.selected(t);r!==this.selected(e)&&(r?this.select(e):this.unselect(e))}splitSegmentAxisAware(t,e,n,i,r){let o=0;const a=this.getNextVertex(t);a===Ar&&s("");const h=this.getVertexIndex(t),m=this.getVertexIndex(a),l=this.getSegmentFromIndex(h);let u=this.m_vertices.getShortestDistance(h,m);const c=this.getPathFromVertex(t),g=this.m_bHasAttributes;g&&l&&(u=l.calculateLength2D());const d=this.getSegmentParentage(t),_=this.getHelperPoint();if(l){let t=0,s=0,r=Ar;for(let p=0;p<n;p++){const n=e[p];if(t<n&&n<1){const e=l.cut(t,n);if(null!==i&&(p>0&&e.setStartXY(i[p-1]),e.setEndXY(i[p]),e.normalizeAfterEndpointChange(),s=p),g){const t=u>0?l.calculateSubLengthFromStart(n)/u:0;this.m_vertices.interpolateTwoVertices(h,m,t,_)}_.setXY(e.getEndXY()),r=this.insertVertex(c,a,_),o++;const f=this.getPrevVertex(r),x=this.getVertexIndex(f);this.setSegmentToIndex(x,e),-1!==d&&this.setSegmentParentageAndBreak(r,d,!1),t=n}}if(r!==Ar){const e=l.cut(t,1);null!==i&&(e.setStartXY(i[s]),e.normalizeAfterEndpointChange());const n=this.getVertexIndex(r);this.setSegmentToIndex(n,e)}}else{let t=0;for(let s=0;s<n;s++){const n=e[s];if(t<n&&n<1){this.m_vertices.interpolateTwoVertices(h,m,n,_);const t=this.insertVertex(c,a,_);o++,-1!==d&&this.setSegmentParentageAndBreak(t,d,!1)}t=n}}return o}splitSegment(t,e,s,n=null){return this.splitSegmentAxisAware(t,e,s,n,-1)}snapControlPoints(t,e,n){this.getNextVertex(t)===Ar&&s("");let i=t,r=!1;for(let t=0;t<e;++t){const t=this.getVertexIndex(i),e=this.getSegmentFromIndex(t);if(e){const t=e.snapControlPoints(n);r||=t}i=this.getNextVertex(i)}return r}snapControlPointsOnSelection(t){if(!this.hasCurves())return!1;let e=0;const s=this.queryVertexIteratorOnSelection();for(let n=s.next();n!==Ar;n=s.next()){const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);i&&(e|=i.snapControlPoints(t)?1:0)}return 0!==e}calculateSubLength2D(t,e,s){return n(0),0}setPoint(t,e,s){if(this.setPointOnly(t,e),null!==this.m_segments){const n=this.getVertexIndex(t),i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXY(e.getXY()),i.normalizeAfterEndpointChange(),s&&i.ensureXYMonotone());const r=this.getPrevVertex(t);if(r!==Ar){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!==n&&(n.setEndXY(e.getXY()),n.normalizeAfterEndpointChange(),s&&n.ensureXYMonotone())}}}setPointEx(t,e,s,n,i){this.setPoint(t,e,i);const r=this.getVertexIndex(t);this.setWeightWithIndex(r,n),this.setRankWithIndex(r,s)}setPointOnly(t,e){const s=this.getVertexIndex(t);this.m_vertices.setPointByValNoCurves(s,e)}setPointOnlyEx(t,e,s,i){n(0)}queryPoint(t,e){const s=this.getVertexIndex(t);this.m_vertices.getPointByVal(s,e)}setXY(t,e){this.setXYCoords(t,e.x,e.y)}setXYCoords(t,e,s){const n=this.getVertexIndex(t);if(this.m_vertices?.setXYCoordsNoCurves(n,e,s),null!==this.m_segments){const i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXYCoords(e,s),i.normalizeAfterEndpointChange());const r=this.getPrevVertex(t);if(r!==Ar){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!=n&&(n.setEndXYCoords(e,s),n.normalizeAfterEndpointChange())}}}setXYMonotonic(t,e,s){const n=this.getVertexIndex(t);if(this.m_vertices.setXYCoordsNoCurves(n,e,s),null!==this.m_segments){const i=this.getSegmentFromIndex(n);if(null!==i){const t=i.getEndXY();i.setCoordsForIntersector(new l(e,s),t,!1),i.ensureXYMonotone()}const r=this.getPrevVertex(t);if(r!==Ar){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);if(null!==n){const t=n.getStartXY();n.setCoordsForIntersector(t,new l(e,s),!1),n.ensureXYMonotone()}}}}setXYMonotonicPoint2D(t,e){this.setXYMonotonic(t,e.x,e.y)}queryXY(t,e){const s=this.getVertexIndex(t);return this.m_vertices.queryXY(s,e)}getXY(t){const e=this.getVertexIndex(t);return this.m_vertices.getXY(e)}getXYWithIndex(t){return this.m_xyStream.readPoint2D(2*t)}static setSegDefault(t,e,s){n(0)}setXYZ(t,e,s){n(0)}setXYZCoords(t,e,s,i){n(0)}queryXYZ(t,e){n(0)}getXYZ(t){return n(0),Se.getNAN()}getXYZWithIndex(t){return n(0),Se.getNAN()}mergeVertexDescription(t){this.m_verticesMp.mergeVertexDescription(t),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(t){n(0)}getAttributeAsDbl(t,e,s){return this.m_vertices.getAttributeAsDbl(t,this.getVertexIndex(e),s)}queryAttributeAsDbl(t,e,s,i){n(0)}setAttribute(t,e,s,i){n(0)}setAttributeInt(t,e,s,i){n(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(t){return n(0),0}getVertexIndex(t){return this.m_vertexIndexList.getField(t,0)}getY(t){const e=this.getVertexIndex(t);return this.m_vertices.queryXY(e,this.m_workPoint2D),this.m_workPoint2D.y}getX(t){return this.getXY(t).x}isEqualXY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(t,e){return this.queryXY(t,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(e)}isEqualXYZPoint3D(t,e){return n(0),!1}setWeight(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_weights){if(s)return;this.m_weights=Re(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_weights.size()){if(s)return;this.m_weights.resize(n+1,1)}this.m_weights.write(n,e)}setWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_weights){if(s)return;this.m_weights=Re(this.m_vertices.getPointCount(),1)}if(t>=this.m_weights.size()){if(s)return;this.m_weights.resize(t+1,1)}this.m_weights.write(t,e)}getWeight(t){if(null===this.m_weights)return 1;const e=this.getVertexIndex(t);return e>=this.m_weights.size()?1:this.m_weights.read(e)}getWeightWithIndex(t){return null===this.m_weights||t>=this.m_weights.size()?1:this.m_weights.read(t)}getRank(t){if(null===this.m_ranks)return 1;const e=this.getVertexIndex(t);return e>=this.m_ranks.size()?1:this.m_ranks.read(e)}getRankWithIndex(t){return null===this.m_ranks||t>=this.m_ranks.size()?1:this.m_ranks.read(t)}setRank(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_ranks){if(s)return;this.m_ranks=Xe(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(n+1,1)}this.m_ranks.write(n,e)}setRankWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_ranks){if(s)return;this.m_ranks=Xe(this.m_vertices.getPointCount(),1)}if(t>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(t+1,1)}this.m_ranks.write(t,e)}setSegmentWeight(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_segmentWeights){if(s)return;this.m_segmentWeights=Re(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(n+1,1)}this.m_segmentWeights.write(n,e)}setSegmentWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_segmentWeights){if(s)return;this.m_segmentWeights=Re(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(t+1,1)}this.m_segmentWeights.write(t,e)}getSegmentWeight(t){if(null===this.m_segmentWeights)return 1;const e=this.getVertexIndex(t);return e>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(e)}getSegmentWeightWithIndex(t){return null==this.m_segmentWeights||t>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(t)}getSegmentRank(t){if(null===this.m_segmentRanks)return Vr.st_defaultRank;const e=this.getVertexIndex(t);return e>=this.m_segmentRanks.size()?Vr.st_defaultRank:this.m_segmentRanks.read(e)}getSegmentRankWithIndex(t){return null===this.m_segmentRanks||t>=this.m_segmentRanks.size()?1:this.m_segmentRanks.read(t)}setSegmentRank(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=Xe(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(n+1,1)}this.m_segmentRanks.write(n,e)}setSegmentRankWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=Xe(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(t+1,1)}this.m_segmentRanks.write(t,e)}removeWeights(){this.m_weights=null,this.m_segmentWeights=null}removeRanks(){this.m_ranks=null,this.m_segmentRanks=null}setUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);if(n.size()<=i){if(-1===s)return;n.resize(this.m_vertices.getPointCount(),-1)}n.write(i,s)}getUserIndex(t,e){const s=this.getVertexIndex(t),n=this.m_indices[e];return s<n.size()?n.read(s):-1}addToUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);n.size()<=i&&n.resize(this.m_vertices.getPointCount(),-1);const r=n.read(i);n.write(i,r+s)}createUserIndex(){for(let t=0;t<this.m_indices.length;t++)if(null===this.m_indices[t])return this.m_indices[t]=this.allocateIndex(),t;this.m_indices.push(this.allocateIndex());const t=this.m_indices.length-1;return n(t>=0&&t<=c()),t}createUserIndexUninitialized(){for(let t=0;t<this.m_indices.length;t++)if(null===this.m_indices[t])return this.m_indices[t]=this.allocateIndex(!1),t;this.m_indices.push(this.allocateIndex(!1));const t=this.m_indices.length-1;return n(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillUserIndexForGeometry(t,e,s){const n=this.m_indices[e],i=n.size();for(let e=this.getFirstPath(t);e!==Ar;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let r=0,o=this.getPathSize(e);r<o;r++,t=this.getNextVertex(t)){const e=this.getVertexIndex(t);e<i&&n.write(e,s)}}}fillUserIndexForSelection(t,e){n(0)}removeUserIndex(t){for(this.recycleUserIndex(this.m_indices[t]),this.m_indices[t]=null;this.m_indices.length>0&&null===this.m_indices[this.m_indices.length-1];)this.m_indices.pop()}replaceCurveWithLine(t){if(null!==this.m_segments){const e=this.getVertexIndex(t);this.setSegmentToIndex(e,null)}}queryLineConnector(t,e,s=!1){const n=this.getNextVertex(t);if(n===Ar)return!1;if(!this.m_bHasAttributes||s){const s=this.getXY(t);e.setStartXY(s);const i=this.getXY(n);e.setEndXY(i)}else{const s=new qe({vd:this.getVertexDescription()});this.queryPoint(t,s),e.setStart(s),this.queryPoint(n,s),e.setEnd(s)}return!0}queryLineConnector3D(t,e,s=!1){return n(0),!1}hasCurves(){return null!==this.m_segments}geometryHasCurves(t){return n(0),!1}pathHasCurves(t){if(!this.hasCurves())return!1;const e=this.getFirstVertex(t);if(e===Ar)return!1;const s=this.getPathSize(t);let n=e;for(let t=0;t<s;t++,n=this.getNextVertex(n)){const t=this.getSegment(n);if(null!==t&&t.getGeometryType()!==o.enumLine)return!0}return!1}insertPath(t,e){let n=Ar;e!==Ar?(t!==this.getGeometryFromPath(e)&&s(""),n=this.getPrevPath(e)):n=this.getLastPath(t);const i=this.newPath(t);return e!==Ar&&this.setPrevPath(e,i),this.setNextPath(i,e),this.setPrevPath(i,n),n!==Ar?this.setNextPath(n,i):this.setFirstPath(t,i),e===Ar&&this.setLastPath(t,i),this.setGeometryPathCount(t,this.getPathCount(t)+1),i}removePath(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);return e!==Ar?this.setNextPath(e,s):this.setFirstPath(n,s),s!==Ar?this.setPrevPath(s,e):this.setLastPath(n,e),this.clearPath(t),this.setGeometryPathCount(n,this.getPathCount(n)-1),this.freePath(t),s}clearPath(t){const e=this.getFirstVertex(t);if(e!==Ar){let s=e;for(let e=0,n=this.getPathSize(t);e<n;e++){const t=s;s=this.getNextVertex(s),this.freeVertex(t)}const n=this.getGeometryFromPath(t);this.setGeometryVertexCount(n,this.getPointCount(n)-this.getPathSize(t))}this.setPathSize(t,0)}getNextPath(t){return this.m_pathIndexList.getField(t,2)}getPrevPath(t){return this.m_pathIndexList.getField(t,1)}getPathSize(t){return this.m_pathIndexList.getField(t,3)}isClosedPath(t){return!!(1&this.getPathFlags(t))}setClosedPath(t,e){if(this.isClosedPath(t)===e)return;if(this.getPathSize(t)>0){const s=this.getFirstVertex(t),n=this.getLastVertex(t);if(e){this.setNextVertex(n,s),this.setPrevVertex(s,n);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}else{this.setNextVertex(n,Ar),this.setPrevVertex(s,Ar);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}}const s=(1|this.getPathFlags(t))-1;this.setPathFlags(t,s|(e?1:0))}closeAllPaths(t){n(0)}isStrongPathStart(t){return!!(8&this.getPathFlags(t))}isStrongPathEnd(t){return!!(16&this.getPathFlags(t))}setStrongPathStart(t,e){const s=(8|this.getPathFlags(t))-8;this.setPathFlags(t,s|(e?8:0))}setStrongPathEnd(t,e){const s=(16|this.getPathFlags(t))-16;this.setPathFlags(t,s|(e?16:0))}getGeometryFromPath(t){return this.m_pathIndexList.getField(t,7)}isExterior(t){return!!(2&this.getPathFlags(t))}setExterior(t,e){const s=(2|this.getPathFlags(t))-2;this.setPathFlags(t,s|(e?2:0))}getRingArea(t){if(this.isRingAreaValid(t))return this.m_pathAreas[this.getPathIndex(t)];const e=this.getFirstVertex(t);if(e===Ar)return 0;const s=this.getXY(e),n=new q(0),i=this.getPathSize(t);if(i>2){const t=s.clone(),r=t.x,o=t.y;let a=this.getNextVertex(e);const h=this.getXY(a);a=this.getNextVertex(a);const m=l.getNAN();for(let e=2;e<i;e++,a=this.getNextVertex(a))this.queryXY(a,m),n.pe((m.x-t.x)*(h.y-o)),t.setCoordsPoint2D(h),h.setCoordsPoint2D(m);n.pe((r-t.x)*(h.y-o))}if(this.hasCurves()){let t=e;for(let e=0;e<i;e++,t=this.getNextVertex(t)){const e=this.getSegment(t);if(null===e||e.getGeometryType()===o.enumLine)continue;const s=2*e.calculateArea2DHelper();n.pe(s)}}this.setRingAreaValid(t,!0);const r=.5*n.getResult();return this.m_pathAreas[this.getPathIndex(t)]=r,r}getPathIndexInternal(t){return this.getPathIndex(t)}getPathInternalIndexFromVertex(t){return this.getPathIndex(this.getPathFromVertex(t))}setPathUserIndex(t,e,s){const n=this.m_pathindices[e],i=this.getPathIndex(t);n.size()<this.m_pathAreas.length&&n.resize(this.m_pathAreas.length,-1),n.write(i,s)}getPathUserIndex(t,e){const s=this.getPathIndex(t),n=this.m_pathindices[e];return s<n.size()?n.read(s):-1}createPathUserIndex(){for(let t=0;t<this.m_pathindices.length;t++)if(null===this.m_pathindices[t])return this.m_pathindices[t]=this.allocatePathIndex(),t;this.m_pathindices.push(this.allocatePathIndex());const t=this.m_pathindices.length-1;return n(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillPathUserIndexForGeometry(t,e,s){const n=this.m_pathindices[e],i=n.size();for(let e=this.getFirstPath(t);e!==Ar;e=this.getNextPath(e)){const t=this.getPathIndex(e);t<i&&n.write(t,s)}}removePathUserIndex(t){for(this.recyclePathUserIndex(this.m_pathindices[t]),this.m_pathindices[t]=null;this.m_pathindices.length>0&&null===this.m_pathindices.at(-1);)this.m_pathindices.pop()}movePath(t,e,n){if(n===Ar&&s(""),e===n)return;const i=this.getNextPath(n);let r=this.getPrevPath(n);const o=this.getGeometryFromPath(n);r===Ar?this.setFirstPath(o,i):this.setNextPath(r,i),i===Ar?this.setLastPath(o,r):this.setPrevPath(i,r),this.setGeometryVertexCount(o,this.getPointCount(o)-this.getPathSize(n)),this.setGeometryPathCount(o,this.getPathCount(o)-1),r=e===Ar?this.getLastPath(t):this.getPrevPath(e),this.setPrevPath(n,r),this.setNextPath(n,e),e===Ar?this.setLastPath(t,n):this.setPrevPath(e,n),r===Ar?this.setFirstPath(t,n):this.setNextPath(r,n),this.setGeometryVertexCount(t,this.getPointCount(t)+this.getPathSize(n)),this.setGeometryPathCount(t,this.getPathCount(t)+1),this.setPathGeometry(n,t)}addVertex(t,e){return this.m_vertices.getPointByVal(this.getVertexIndex(e),this.getHelperPoint()),this.insertVertex_(t,Ar,this.getHelperPoint(),!1)}insertVertex(t,e,s){return this.insertVertex_(t,e,s,!0)}removeVertex(t,e){const s=this.getPathFromVertex(t),n=this.getPrevVertex(t),i=this.getNextVertex(t);n!==Ar&&this.setNextVertex(n,i);const r=this.getPathSize(s);if(t===this.getFirstVertex(s)&&this.setFirstVertex(s,r>1?i:Ar),i!==Ar&&this.setPrevVertex(i,n),t===this.getLastVertex(s)&&this.setLastVertex(s,r>1?n:Ar),this.hasCurves()&&n!==Ar&&i!==Ar){const s=this.getVertexIndex(t),r=this.getVertexIndex(n),o=this.getVertexIndex(i);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(s,null)}else{const t=this.getSegmentFromIndex(s);if(this.setSegmentToIndex(s,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}this.setPathSize(s,r-1);const o=this.getGeometryFromPath(s);return this.setGeometryVertexCount(o,this.getPointCount(o)-1),this.freeVertex(t),i}removeVertices(t,e){n(t!==e);const s=this.getPathFromVertex(t),i=this.getPrevVertex(t),r=this.getPrevVertex(e);i!==Ar&&this.setNextVertex(i,e);let o=this.getPathSize(s);const a=this.getVertexIndex(t);this.setSegmentToIndex(a,null),this.setPrevVertex(e,i),this.setPrevVertex(t,Ar),this.setNextVertex(r,Ar);let h=0,m=t;const l=this.getFirstVertex(s);let u=!1;for(;;){const t=this.getNextVertex(m);if(u||=l===m,this.freeVertex(m),h++,m===r)break;m=t}o-=h,u&&this.setFirstVertex(s,o>0?e:Ar),this.setPathSize(s,o);const c=this.getGeometryFromPath(s);this.setGeometryVertexCount(c,this.getPointCount(c)-h)}getFirstVertex(t){return this.m_pathIndexList.getField(t,4)}getLastVertex(t){return this.m_pathIndexList.getField(t,5)}getNextVertex(t){return this.m_vertexIndexList.getField(t,2)}getPrevVertex(t){return this.m_vertexIndexList.getField(t,1)}getNextVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,2):this.m_vertexIndexList.getField(t,1)}getPrevVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,1):this.m_vertexIndexList.getField(t,2)}getPathFromVertex(t){return this.m_vertexIndexList.getField(t,3)}addPoint(t,e){return this.insertVertex_(t,Ar,e,!1)}getGeometryFromVertex(t){return this.getGeometryFromPath(this.getPathFromVertex(t))}replaceNaNs(t,e){this.m_vertexDescription.hasAttribute(t)||P(""),this.m_vertices.replaceNaNs(t,e)}removeNaNVertices(){for(let t=this.getFirstGeometry();t!==Ar;t=this.getNextGeometry(t))for(let e=this.getFirstPath(t);e!==Ar;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let s=0,n=this.getPathSize(e);s<n;s++)t=this.getXY(t).isFinite()?this.getNextVertex(t):this.removeVertex(t,!0)}}queryVertexIterator(t=-1){return this.queryVertexIteratorEx(!1,t)}queryVertexIteratorEx(t,e=-1){let s=Ar,n=Ar,i=Ar,r=Ar,o=0,a=!1;for(s=e!==Ar?e:this.getFirstGeometry();s!==Ar;s=this.getNextGeometry(s))if(!t||Z(this.getGeometryType(s))){for(n=this.getFirstPath(s);n!==Ar;n=this.getNextPath(n))if(i=this.getFirstVertex(n),r=i,o=0,i!==Ar){a=!0;break}if(a||e!==Ar)break}return a||(s=Ar),qr.create_(this,s,n,i,r,o,t,!1,e!==Ar)}queryVertexIteratorOnSelection(t=-1){return this.m_selection?qr.create_(this,t,Ar,Ar,Ar,-1,!1,!0,t!==Ar):this.queryVertexIteratorEx(!1,t)}hasSelection(){return this.m_selection}createEmptySelection(){n(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(t){return!!this.selected(t)||(this.setUserIndex(t,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(t),this.m_selectedCount++,!1)}unselect(t){if(!this.m_selection)return;const e=this.getUserIndex(t,this.m_selectionIndex);e>=0&&(this.m_selectedVertices[e]=Ar,this.setUserIndex(t,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(t){return!this.m_selection||this.selected_(t)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(t,e){return n(0),!1}peelALoop(t,e){this.peelALoop_(t,e,!1)}peelALoopIntoAPath(t,e){return this.peelALoop_(t,e,!0)}applyTransformation(t){if(this.m_verticesMp.applyTransformation(t),null!==this.m_segments)for(let e=0,s=this.m_segments.length;e<s;e++)this.m_segments[e]&&this.m_segments[e].applyTransformation(t)}setGeometryType(t,e){this.m_geometryIndexList.setField(t,2,e)}splitSegmentWithIntersector(t,e,s,n,i){n?this.splitSegmentForward(t,e,s,!0,i):this.splitSegmentBackward(t,e,s,!0,i)}setPrevVertex(t,e){this.m_vertexIndexList.setField(t,1,e)}setNextVertex(t,e){this.m_vertexIndexList.setField(t,2,e)}setPathToVertex(t,e){this.m_vertexIndexList.setField(t,3,e)}setPathSize(t,e){this.m_pathIndexList.setField(t,3,e)}setFirstVertex(t,e){this.m_pathIndexList.setField(t,4,e)}setLastVertex(t,e){this.m_pathIndexList.setField(t,5,e)}getSegment(t){if(null!=this.m_segments){const e=this.getVertexIndex(t);return this.getSegmentFromIndex(e)}return null}isCurve(t){if(null===this.m_segments)return!1;const e=this.getVertexIndex(t);return this.m_segments.length>e&&null!==this.m_segments[e]}querySegment(t,e,s=!0,n=!1){const i=this.getNextVertex(t);if(i===Ar)return!1;const r=this.getSegment(t);if(!r)return!s&&(this.queryLineConnector(t,e.createLine(),n),!0);if(e.copyFrom(r,!0),n)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const s=this.getHelperPoint();this.queryPoint(t,s),e.get().setStart(s),this.queryPoint(i,s),e.get().setEnd(s)}return!0}getSegmentFromIndex(t){return(null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null)||null}getAndClearSegmentFromIndex(t){return(null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null)||null}setSegmentToIndex(t,e){if(this.m_hasForceSetEnvelope=0,null===this.m_segments){if(!e)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}t>=this.m_segments.length&&(this.m_segments.length=t+1),this.m_segments[t]=e}setGeometryPathCount(t,e){this.m_geometryIndexList.setField(t,6,e)}setGeometryVertexCount(t,e){this.m_geometryIndexList.setField(t,5,e)}ringParentageCheckInternal(t,e){return n(0),!1}reverseRingInternal(t){const e=this.hasCurves(),s=this.hasSegmentParentage();let n=null,i=-1,r=t;if(e){const t=this.getVertexIndex(r);n=this.getAndClearSegmentFromIndex(t)}s&&(i=this.getSegmentParentage(r));do{const t=this.getPrevVertex(r),o=this.getNextVertex(r);if(this.setNextVertex(r,t),this.setPrevVertex(r,o),e){const t=this.getVertexIndex(o),e=this.getSegmentFromIndex(t);n&&n.reverse(),this.setSegmentToIndex(t,n),n=e}if(s){const t=this.getSegmentParentage(o);this.setSegmentParentagePreserveBreak(o,i),i=t}r=o}while(r!==t);this.dbgVerifyIntegrity(t)}setTotalPointCount(t){this.m_pointCount=t}removePathOnly(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);e!==Ar?this.setNextPath(e,s):this.setFirstPath(n,s),s!==Ar?this.setPrevPath(s,e):this.setLastPath(n,e),this.setFirstVertex(t,Ar),this.setLastVertex(t,Ar),this.freePath(t)}insertClosedPath(t,e,s,n,i){const r=this.insertPath(t,Ar);let o=0,a=s;for(i[0]=!1;;){a===n&&(i[0]=!0),this.setPathToVertex(a,r),o++;const t=this.getNextVertex(a);if(t===s)break;a=t}return this.setClosedPath(r,!0),this.setPathSize(r,o),i[0]&&(s=n),this.setFirstVertex(r,s),this.setLastVertex(r,this.getPrevVertex(s)),this.setRingAreaValid(r,!1),r}findVertex2D(t,e){return n(0),0}findVertex3D(t,e,s){return n(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(t){}dbgVerifyIntegrity(t,e=!0){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(t,e){}getNextNthVertex(t,e){if(0===e)return t;let s=t;for(let t=0;t<e;++t)if(s=e>0?this.getNextVertex(s):this.getPrevVertex(s),s===Ar)return Ar;return s}removeVertexInternal(t,e){const s=this.getPrevVertex(t),n=this.getNextVertex(t);if(s!==Ar&&this.setNextVertex(s,n),n!==Ar&&this.setPrevVertex(n,s),this.hasCurves()&&s!==Ar&&n!==Ar){const i=this.getVertexIndex(t),r=this.getVertexIndex(s),o=this.getVertexIndex(n);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(i,null)}else{const t=this.getSegmentFromIndex(i);if(this.setSegmentToIndex(i,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}return this.freeVertex(t),n}isRingAreaValid(t){return!!(4&this.getPathFlags(t))}setRingAreaValid(t,e){const s=(4|this.getPathFlags(t))-4;this.setPathFlags(t,s|(e?4:0))}compareVerticesSimpleY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(t,e){return this.getXYZ(t).compare(this.getXYZ(e))}compareVerticesSimpleX(t,e){return this.getXY(t).compareX(this.getXY(e))}sortVerticesSimpleByYHeapMerge(t,e){n(0)}sortVerticesSimpleByY(t,e,s){this.m_bucketSort.sort(t,e,s,new Gr(this))}sortVerticesSimpleByX(t,e,s){n(0)}sortVerticesSimpleByY3D(t,e,s){n(0)}snapVertexForPoleClipping(t,e){const s=this.getPrevVertex(t);s!==Ar&&this.replaceCurveWithLine(s),this.getNextVertex(t)!==Ar&&this.replaceCurveWithLine(t);const n=new l;this.queryXY(t,n),n.y=e,this.setXY(t,n)}setSegmentParentageAndBreak(t,e,s=!0){if(-1===this.m_segmentParentageIndex){if(-1===e)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&(n(e<=W()>>1),e<<=1,e|=s?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}setSegmentParentagePreserveBreak(t,e){if(n(e>=-1),-1===this.m_segmentParentageIndex){if(-1===e)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&(n(e<=W()>>1),e<<=1,e|=this.getSegmentParentageBreakVertex(t)?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0?e:e>>1}getOriginalSegmentInfo(t){if(-1!==this.m_segmentParentageIndex){const e=this.getSegmentParentage(t);return new Fr(e)}return new Fr(-1)}setSegmentParentageBreakVertex(t,e){if(-1===this.m_segmentParentageIndex)return;let s=this.getUserIndex(t,this.m_segmentParentageIndex);s<0||!!(1&s)!==e&&(e?s|=1:s&=W()>>1<<1,this.setUserIndex(t,this.m_segmentParentageIndex,s))}getSegmentParentageBreakVertex(t){if(-1===this.m_segmentParentageIndex)return!0;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0||!!(1&e)}isDiscontinuousSegmentParentage(t){const e=this.getPrevVertex(t);return e!==Ar&&this.getSegmentParentage(e)!==this.getSegmentParentage(t)}setCurveStitcherPointer(t){this.m_curveStitcher=t}hasSegmentParentage(){return-1!==this.m_segmentParentageIndex}deleteSegmentParentage(){-1!==this.m_segmentParentageIndex&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}}function Yr(t){if(t.isEmpty())return new Tr({vd:t.getDescription()});if(Z(t.getGeometryType())&&t.hasNonLinearSegments())return function(t){n(t.hasNonLinearSegments()&&!t.isEmpty());const e=new Hr;return e.addGeometry(t),e.getBoundingGeometry()}(t);const e=t.getImpl(),s=e.getPointCount();if(s<=2){if(1===s||e.getXY(0).equals(e.getXY(1))){const t=new qe({vd:e.getDescription()});return e.getPointByVal(0,t),t}{const t=new qe,s=new Wn({vd:e.getDescription()});return e.getPointByVal(0,t),s.startPathPoint(t),e.getPointByVal(1,t),s.lineToPoint(t),s}}const i=e.getAttributeStreamRef(0),r=new Hr({stream:i,n:s});let o=1;const a=i.readPoint2D(0),h=new l;for(;o<s&&i.queryPoint2D(o<<1,h).equals(a);)o++;if(r.m_treeHull.addElement(0),o<s){r.m_treeHull.addBiggestElement(o);const t=new l;for(let s=o+1;s<e.getPointCount();s++){i.queryPoint2D(s<<1,t);const e=r.treeHull(t);-1!==e&&r.m_treeHull.setElement(e,s)}}const m=e.getDescription(),u=m.getAttributeCount()>1,c=r.m_treeHull.size();let g=null;if(c>=2){g=c>=3?new Tr({vd:m}):new Wn({vd:m});const t=g.getImpl();t.reserve(r.m_treeHull.size()),t.addPathPoint2D(null,0,!0);const s=new l;for(let n=r.m_treeHull.getFirst();-1!==n;n=r.m_treeHull.getNext(n))if(u){const s=new qe;e.getPointByVal(r.m_treeHull.getElement(n),s),t.insertPoint(0,-1,s)}else i.queryPoint2D(r.m_treeHull.getElement(n)<<1,s),t.insertPoint2D(0,-1,s)}else if(u){const t=new qe({vd:m});e.getPointByVal(r.m_treeHull.getElement(r.m_treeHull.getFirst()),t),g=t}else{const t=i.readPoint2D(r.m_treeHull.getElement(r.m_treeHull.getFirst())<<1);g=new qe(t)}return g}function Xr(t,e,s,n=!1){if(e<=262144)return function(t,e,s,n){const i=new Fe(0);for(let t=0;t<e;t++)i.add(t);const r={userSort(e,s,n){n.sort(e,s,(e,s)=>t[e].compareX(t[s]))},getValue:e=>t[e].x};n||Ve.sortEx(i,0,e,r);let o=0;t:for(let n=0;n<e;++n){const e=i.read(n);for(;o>=2;){const r=s[o-2],a=s[o-1];if(t[a].equals(t[e])){i.write(n,-1);continue t}if(!(Br(t[r],t[a],t[e])>=0)){a===i.read(n-1)&&i.write(n-1,-1);break}o--}s[o++]=e,2===o&&t[e].equals(t[s[0]])&&(i.write(1,-1),o--)}const a=o+1;t:for(let n=e-2;n>=0;--n){const e=i.read(n);if(!(e<0)){for(;o>=a;){const n=s[o-2],i=s[o-1];if(t[i].equals(t[e]))continue t;if(!(Ur(t[n],t[i],t[e])>=0))break;o--}if(0!==n){const n=s[o-1];s[o++]=e,t[e].equals(t[n])&&o--}}}return o>1&&t[s[0]].equals(t[s[o-1]])&&o--,o}(t,e,s,n);const i=new Hr({points:t,n:e});let r=1;const o=t[0];for(;r<e&&t[r].equals(o);)r++;if(i.m_treeHull.addElement(0),r<e){i.m_treeHull.addBiggestElement(r);for(let s=r+1;s<e;s++){const e=t[s],n=i.treeHull(e);-1!==n&&i.m_treeHull.setElement(n,s)}}let a=0;for(let t=i.m_treeHull.getFirst();-1!==t;t=i.m_treeHull.getNext(t))s[a++]=i.m_treeHull.getElement(t);return a}function kr(t,e,n){if((e<0||e>=t.getPathCount())&&s("path index"),t.hasNonLinearSegmentsPath(e))return!1;const i=t.getImpl(),r=i.getPathStart(e),o=i.getPathEnd(e),a=!i.isClosedPath(e)&&i.isClosedPathInXYPlane(e),h=i.getAttributeStreamRef(0),m=2*r;let u=2*o;if(a&&(u-=2),u-m<6)return!0;const c=h.readPoint2D(m),g=h.readPoint2D(m+2),d=h.readPoint2D(m+4);if(!zr(l.orientationRobust(g,d,c)))return!1;const _=g.clone(),p=new l;for(let t=m+6;t<u;t+=2){if(p.assign(g),g.assign(d),h.queryPoint2D(t,d),!zr(l.orientationRobust(g,d,c)))return!1;if(!zr(l.orientationRobust(_,d,c)))return!1;if(!zr(l.orientationRobust(g,d,p)))return!1}return!0}function Rr(t,e,s,n,i){if(function(t,e,s){t.setNAN(),e.setCoords(1,0),s.setCoords(0,0)}(s,n,i),t.isEmpty())return;if(t.getGeometryType()===o.enumPoint)return void s.assign(t.getXY());const r=t,a=r.getPointCount();0!==a&&(1!==a?function(t,e,s,n,i,r){if(2===e){const e=t.getXY(0),s=t.getXY(1);n.assign(e.add(s).mul(.5));const o=s.sub(e);i=jr(o),r.setCoords(.5*o.length(),0)}else{let o=Number.MAX_VALUE;const a=[0,1,0,0],h=new Mt(4,2);for(h.set(0,0,0),h.set(0,1,1),h.set(1,0,1),h.set(1,1,2);a[0]<e;++a[0],Zr(h,0,e)){a[1]===a[0]&&(++a[1],Zr(h,1,e));for(let s=1;;++s){for(;;){const n=Qr(t.getXY(h.get(0,0)),t.getXY(h.get(0,1)),t.getXY(h.get(s,0)),t.getXY(h.get(s,1)),2^s);if(n>0)break;if(++a[s],Zr(h,s,e),0===n)break}if(3===s)break;a[s+1]<a[s]&&(a[s+1]=a[s],h.set(s+1,0,h.get(s,0)),h.set(s+1,1,h.get(s,1)))}const m=t.getXY(h.get(0,0)).add(t.getXY(h.get(2,0))).mul(.5),u=jr(t.getXY(h.get(0,1)).sub(t.getXY(h.get(0,0)))),c=new l;let g,d;if(c.x=Math.max(0,u.dotProduct(t.getXY(h.get(1,0)).sub(t.getXY(h.get(3,0))))),c.y=Math.max(0,u.crossProduct(t.getXY(h.get(0,0)).sub(t.getXY(h.get(2,0))))),s?(g=c.x*c.y,d=g<o):(g=c.y,d=g<o),d){o=g;const e=t.getXY(h.get(1,0)),s=t.getXY(h.get(3,0)),a=e.add(s).mul(.5).sub(m);n.assign(m.add(u.mul(u.dotProduct(a)))),i.assign(u),r.assign(c)}}r.mulThis(.5),r.x<r.y&&(r.y=p(r.x,r.x=r.y),i.leftPerpendicularThis())}i.y<0?i.negateThis():0===i.y&&(i.x=1)}(r,a,e,s,n,i):s.assign(r.getXY(0)))}Vr.st_defaultRank=1;class Lr{constructor(t){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,n(0),this.m_convexHull=t,this.m_function=this.done_}next(){return n(0),!1}get_vertex_handle_p(){return n(0),0}get_vertex_handle_q(){return n(0),0}get_current_support(){return n(0),0}getNext(t){return n(0),0}getPrev(t){return n(0),0}intialize_(){return n(0),!1}increment_(){return n(0),!1}increment_q_(){return n(0),!1}increment_p_(){return n(0),!1}parallel_edge_with_q_support_(){return n(0),!1}parallel_edge_with_p_support_(){return n(0),!1}done_(){return n(0),!1}}class Hr{nullGetXY(t){return P("m_getXY is null"),{}}nullDeleteNode(t){P("m_deleteNode is null")}constructor(t){return this.m_treeHull=new ze,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,t?t.stream?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_stream=t.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=Ar,void(this.m_pathHandle=Ar)):t.points?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_points=t.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=Ar,void(this.m_pathHandle=Ar)):void K("unrecognized constructor parameter"):(this.m_treeHull.setCapacity(20),this.m_shape=new Vr,this.m_geometryHandle=this.m_shape.createGeometry(o.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,Ar),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(t){return this.m_shape.getXY(t)}getXYStream(t){return this.m_stream.readPoint2D(t<<1)}getXYPoints(t){return n(0),new l}deleteNodeShape(t){const e=this.m_treeHull.getElement(t);this.m_treeHull.deleteNode(t),this.m_shape.removeVertex(e,!1)}deleteNodeStream(t){this.m_treeHull.deleteNode(t)}deleteNodePoints(t){n(0)}addGeometry(t){if(t.isEmpty())return;const n=t.getGeometryType();if(n===o.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else e(n)?this.addMultiVertexGeometry(t):F(n)?this.addSegment(t,!1):n===o.enumEnvelope?this.addEnvelope(t):n===o.enumPoint?this.addPoint(t):s("Convex_hull: geometry not supported")}getBoundingGeometry(){const t=new qe,e=this.m_treeHull.getFirst(),s=new Tr({vd:this.m_shape.getVertexDescription()});if(0===this.m_treeHull.size())return s;s.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(e),t),s.startPathPoint(t);for(let n=this.m_treeHull.getNext(e);-1!==n;n=this.m_treeHull.getNext(n))this.m_shape.queryPoint(this.m_treeHull.getElement(n),t),s.lineToPoint(t);return s}getAntipodalPairsIterator(){return n(0),new Lr(this)}getXY(t){return n(0),new l}getXYWithIndex(t){return n(0),new l}getFirst(){return n(0),0}getLast(){return n(0),0}getNext(t){return n(0),0}getPrev(t){return n(0),0}getVertexIndex(t){return n(0),0}getPointCount(){return n(0),0}addMultiVertexGeometry(t){const e=new qe,s=t.getImpl(),n=new l;for(let i=0;i<t.getPointCount();i++){s.queryXY(i,n);const r=this.addPoint2D(n);if(-1!==r){t.getPointByVal(i,e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}if(Z(t.getGeometryType())){const e=t;if(e.hasNonLinearSegments()){const t=e.querySegmentIterator();for(;t.nextPath();)for(;t.hasNextSegment();){const e=t.nextCurve();null!==e&&this.addSegment(e,!0)}}}}addEnvelope(t){const e=new qe;for(let s=0;s<4;s++){const n=new l;t.queryCorner(s,n);const i=this.addPoint2D(n);if(-1!==i){t.queryCornerByVal(s,e);const n=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(i,n)}}}static querySegmentControlPoints(t,e,i){const r=t.getGeometryType();if(n(r!==o.enumLine),r===o.enumEllipticArc){const s=t,n=60*Math.PI/180,i=Math.abs(s.getSweepAngle());if(i>n){const t=Math.min(6,Math.ceil(i/n)),r=1/t,o=new fm;s.queryStart(e[0]);let a=1;for(let n=0;n<t;n++){s.queryCut(n*r,(n+1)*r,o);const i=T(l,3);jh(o.get(),i);const h=l.calculateLength(i,3),m=l.calculateLength(i,2),u=h>0?m/h:.5;n<t-1?o.get().queryEnd(e[a+1]):s.queryEnd(e[a+1]),qe.lerp(e[a-1],e[a+1],u,e[a]),e[a].setXY(i[1]),a+=2}return a}{const s=T(l,3);jh(t,s);const n=l.calculateLength(s,3);t.queryStart(e[0]),t.queryEnd(e[2]);const i=l.calculateLength(s,2),r=n>0?i/n:.5;return qe.lerp(e[0],e[2],r,e[1]),e[1].setXY(s[1]),3}}if(r===o.enumBezier){const s=t,n=T(l,4);s.queryControlPoints(n);const i=l.calculateLength(n,4),r=l.calculateLength(n,2),o=l.calculateLength(n,3);t.queryStart(e[0]),t.queryEnd(e[3]);const a=i>0?r/i:.5;qe.lerp(e[0],e[3],a,e[1]),e[1].setXY(n[1]);const h=i>0?o/i:.5;return qe.lerp(e[0],e[3],h,e[2]),e[2].setXY(n[2]),4}if(r===o.enumBezier2){const s=t,n=T(l,3);s.queryControlPoints(n);const i=l.calculateLength(n,3);t.queryStart(e[0]),t.queryEnd(e[2]);const r=l.calculateLength(n,2),o=i>0?r/i:.5;return qe.lerp(e[0],e[2],o,e[1]),e[1].setXY(n[1]),3}if(r===o.enumRationalBezier2){const s=t,n=T(l,3);s.queryControlPoints(n);const i=l.calculateLength(n,3);t.queryStart(e[0]),t.queryEnd(e[2]);const r=l.calculateLength(n,2),o=i>0?r/i:.5;return qe.lerp(e[0],e[2],o,e[1]),e[1].setXY(n[1]),3}s("Convex_hull: segment type not supported")}addSegment(t,e){if(!e){const e=new qe,s=t.getStartXY(),n=this.addPoint2D(s);if(-1!==n){t.queryStart(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(n,s)}const i=t.getEndXY(),r=this.addPoint2D(i);if(-1!==r){t.queryEnd(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}if(t.isCurve()){const e=T(qe,13);for(let s=1,n=Hr.querySegmentControlPoints(t,e,e.length)-1;s<n;++s){const t=e[s].getXY(),n=this.addPoint2D(t);if(-1!==n){const t=this.m_shape.addPoint(this.m_pathHandle,e[s]);this.m_treeHull.setElement(n,t)}}}}addPoint(t){const e=t.getXY(),s=this.addPoint2D(e);if(-1!==s){const e=this.m_shape.addPoint(this.m_pathHandle,t);this.m_treeHull.setElement(s,e)}}addPoint2D(t){let e=-1;if(0===this.m_treeHull.size())return e=this.m_treeHull.addElement(-4),e;if(1===this.m_treeHull.size()){const s=this.m_treeHull.getElement(this.m_treeHull.getFirst()),n=this.m_shape.getXY(s);return t.equals(n)||(e=this.m_treeHull.addBiggestElement(-5)),e}return e=this.treeHull(t),e}treeHull(t){let e=-1;do{const s=this.m_treeHull.getFirst(),n=this.m_treeHull.getLast(),i=this.m_treeHull.getElement(s),r=this.m_treeHull.getElement(n),o=this.m_getXY(i),a=this.m_getXY(r),h=l.orientationRobust(a,t,o);if(zr(h)){e=this.m_treeHull.addBiggestElement(-1);const i=this.treeHullWalkBackward(t,n,s);i!==s&&this.treeHullWalkForward(t,s,this.m_treeHull.getPrev(i));break}if(Or(h)){let i=this.m_treeHull.getRoot(),r=this.m_treeHull.getFirst(),a=this.m_treeHull.getLast(),h=-1,m=-1,u=-1;for(;r!==this.m_treeHull.getPrev(a);){m=this.m_treeHull.getElement(i);const e=this.m_getXY(m);Or(l.orientationRobust(e,t,o))?(a=i,i=this.m_treeHull.getLeft(i)):(r=i,i=this.m_treeHull.getRight(i))}i=a,h=r,m=this.m_treeHull.getElement(i),u=this.m_treeHull.getElement(h);const c=this.m_getXY(m),g=this.m_getXY(u);if(h!==s&&!zr(l.orientationRobust(g,t,c)))break;e=this.m_treeHull.addElementAtPosition(h,i,-2,!0,!1),this.treeHullWalkForward(t,i,n),this.treeHullWalkBackward(t,h,s);break}{const i=Wr(t,a,o);if(-1===i){const i=this.m_treeHull.getPrev(n);this.m_treeHull.deleteNode(n),e=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(t,i,s)}else if(1===i){const i=this.m_treeHull.getNext(s);this.m_treeHull.deleteNode(s),e=this.m_treeHull.addElementAtPosition(-1,i,-3,!0,!1),this.treeHullWalkForward(t,i,n)}break}}while(0);return e}treeHullWalkForward(t,e,s){if(e===s)return s;let n=e,i=this.m_treeHull.getElement(n),r=this.m_treeHull.getNext(n);const o=this.m_getXY(i);for(;n!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(zr(l.orientationRobust(s,t,o)))break;const a=n;n=r,i=e,o.assign(s),r=this.m_treeHull.getNext(n),this.m_deleteNode(a)}return n}treeHullWalkBackward(t,e,s){if(e===s)return s;let n=e,i=this.m_treeHull.getElement(n),r=this.m_treeHull.getPrev(n);const o=this.m_getXY(i);for(;n!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(zr(l.orientationRobust(o,t,s)))break;const a=n;n=r,i=e,o.assign(s),r=this.m_treeHull.getPrev(n),this.m_deleteNode(a)}return n}}function Br(t,e,s){const n=e.sub(t),i=s.sub(e);if(0===n.x)return i.x>0?-1:0;if(0===n.y)return i.y>0?1:i.y<0?-1:0;const r=n.crossProduct(i),o=4*Number.EPSILON*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>o?1:r<-o?-1:l.orientationRobust(t,e,s)}function Ur(t,e,s){const n=e.sub(t),i=s.sub(e);if(0===n.x)return i.x<0?-1:0;if(0===n.y)return i.y>0?-1:i.y<0?1:0;const r=n.crossProduct(i),o=4*Number.EPSILON*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>o?1:r<-o?-1:l.orientationRobust(t,e,s)}function zr(t){return t<0}function Or(t){return t>0}function Wr(t,e,s){let n=-1;n=e.y===s.y?0:e.x===s.x?1:Math.abs(e.x-s.x)>=Math.abs(e.y-s.y)?0:1;let i=-1;return i=e[n]<s[n]?t[n]<e[n]?-1:s[n]<t[n]?1:0:e[n]<t[n]?-1:t[n]<s[n]?1:0,i}function jr(t){return(t=t.clone()).divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t}function Zr(t,e,s){t.inc(e,0)===s&&t.set(e,0,0),t.inc(e,1)===s&&t.set(e,1,0)}function Qr(t,e,n,i,r){switch(r){case 0:break;case 1:e.rightPerpendicularThis(),t.rightPerpendicularThis();break;case 2:e.negateThis(),t.negateThis();break;case 3:e.leftPerpendicularThis(),t.leftPerpendicularThis();break;default:s("")}return l.orientationRobustEx(t,e,n,i)}class Kr{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}}function Jr(t){var e;return e=t.calculateUpperLength2D(),256*G()*e}function $r(t,e,s=!1){e[1].setCoords(t.m_cp[0].x-t.getStartX(),t.m_cp[0].y-t.getStartY()),e[1].mulThis(3),e[2].setCoords(t.m_cp[1].x-t.m_cp[0].x,t.m_cp[1].y-t.m_cp[0].y),e[2].mulThis(3),e[3]=t.getEndXY().sub(t.getStartXY()),e[3].subThis(e[2]),e[2].subThis(e[1]),s?e[0].setCoords(0,0):e[0]=t.getStartXY()}function to(t,e,s){const n=T(l,4);t.queryControlPoints(n),so(n,e,s)}function eo(t,e,s){const n=T(l,4);t.queryControlPoints(n),no(n,e,s)}function so(t,e,s){let n=t[1].x;n-=t[0].x,n*=3;let i=t[2].x;i-=t[1].x,i*=3;let r=t[3].x;r-=t[0].x,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].x)}function no(t,e,s){let n=t[1].y;n-=t[0].y,n*=3;let i=t[2].y;i-=t[1].y,i*=3;let r=t[3].y;r-=t[0].y,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].y)}function io(t,e,s=!1){const n=T(Hs,4);n[0].assignPoint2D(t[0]),n[1].assignPoint2D(t[1]),n[2].assignPoint2D(t[2]),n[3].assignPoint2D(t[3]),e[1].setCoords(n[1].x.sub(n[0].x),n[1].y.sub(n[0].y)),e[1].mulThis(y.constructInt32(3)),e[2].setCoords(n[2].x.sub(n[1].x),n[2].y.sub(n[1].y)),e[2].mulThis(y.constructInt32(3)),e[3]=n[3].sub(n[0]),e[3]=e[3].sub(e[2]),e[2]=e[2].sub(e[1]),s?e[0].setCoords(St,St):e[0]=n[0].clone()}function ro(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+ro(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=oo(t);if(n&&!Number.isNaN(i.length)&&!Number.isNaN(i.length))return i.length;const r=Jr(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let s=1,n=i.specialPointsCount();s<n;s++){const n=i.specialPoints[s];if(a+=Uo(t,h,Math.min(e,n),o,r),e<=n)break;h=n}return n&&(i.length=a),a}function oo(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new Kr,s=T(v,8),n=T(l,4);t.queryControlPoints(n);const i=ko(n,s);e.specialPoints=[];for(let t=0;t<i;t++)e.specialPoints.push(s[t].value());return ho(t,e),e}function ao(t){let e=null;return e=t.m_cachedValues,e}function ho(t,e){t.m_cachedValues=e}function mo(t){t.m_cachedValues=null}function lo(t,e,s,n){const i=T(l,4);t.queryControlPoints(i);const o=h(18,NaN),a=Jn(new Fo(i,e,NaN),r.construct(s,n),18,o),m=new l;t.queryCoord2D(s,m);let u=s,c=l.distance(m,e);const g=new l;t.queryCoord2D(n,g);const d=l.distance(g,e);d<c&&(c=d,u=n,m.assign(g));for(let s=0;s<a;s++){t.queryCoord2D(o[s],g);const n=l.distance(g,e);n<c&&(c=n,u=o[s],m.assign(g))}return function(t,e,s,n,i){return{tmin:t,tmax:e,t:s,d:n,pt:i.clone()}}(s,n,u,c,m)}function uo(t,e){const s=T(v,4);to(t,s,!0);const i=T(v,4);eo(t,i,!0);const o=s[3].clone(),a=s[2].clone(),h=s[1].clone(),m=i[3].clone(),l=i[2].clone(),u=i[1].clone(),c=a.mulE(h).addE(l.mulE(u)).mul(4),g=a.mulE(a).mul(8).addE(o.mulE(h).mul(12)).addE(l.mulE(l).mul(8).addE(m.mulE(u).mul(12))),d=o.mulE(a).addE(m.mulE(l)).mul(36),_=o.mulE(o).addE(m.mulE(m)).mul(36),p=T(v,3),f=ai(_,d,g,c,new r(0,1),!1,p);if(n(f<=3),f>0){const s=go(t,1,0).sqrLength(),n=go(t,1,1).sqrLength();let i=s;e.set(0),i<n&&(i=n,e.set(1));for(let s=0;s<f;s++){const n=go(t,1,p[s].value()).sqrLength();n<i&&(i=n,e=p[s])}}}function co(t,e,s){const n=new l;return function(t,e,s,n){if(1===e){const e=1-s,i=e*e,r=s*s,o=t[1].sub(t[0]),a=t[2].sub(t[1]),h=t[3].sub(t[2]),m=o.mul(i).add(a.mul(2*e*s)).add(h.mul(r));n.assign(m.mul(3))}else if(2===e){const e=1-s,i=t[2].sub(t[1]).sub(t[1].sub(t[0])),r=t[3].sub(t[2]).sub(t[2].sub(t[1])),o=i.mul(e).add(r.mul(s));n.assign(o.mul(6))}else if(3===e){const e=t[2].sub(t[1]),s=t[3].sub(e.mul(3)).sub(t[0]);n.assign(s.mul(6))}else n.setCoords(0,0)}(t,e,s,n),n}function go(t,e,s){const n=T(l,4);return t.queryControlPoints(n),co(n,e,s)}function _o(t){const e=t.m_cp[0].sub(t.getStartXY()),s=t.m_cp[1].sub(t.m_cp[0]),n=t.getEndXY().sub(t.getStartXY());return e.mulThis(3),s.mulThis(3),n.subThis(s),s.subThis(e),(3*n.x*(2*s.y+5*e.y)-3*n.y*(2*s.x+5*e.x)+10*(s.x*e.y-s.y*e.x))/60}function po(t){const e=T(l,4);t.queryControlPoints(e);const s=fo(e);return s&&(t.m_cp[0].setCoordsPoint2D(e[1]),t.m_cp[1].setCoordsPoint2D(e[2]),t.afterCompletedModification()),s}function fo(t){return Us(t)}function xo(t,e,s){const n=new l,i=new l,r=new l,o=new l,a=new l;e<=.5?(nt(2,t[0],t[1],e,n),nt(2,t[1],t[2],e,i),nt(2,t[2],t[3],e,r),nt(2,n,i,e,o),nt(2,i,r,e,a),nt(2,o,a,e,s)):(it(2,t[0],t[1],e,n),it(2,t[1],t[2],e,i),it(2,t[2],t[3],e,r),it(2,n,i,e,o),it(2,i,r,e,a),it(2,o,a,e,s))}function yo(t,e,s,i){n(e>=0&&e<=1);const r=new l,o=new l,a=new l,h=new l,m=new l,u=new l;e<=.5?(nt(2,t[0],t[1],e,r),nt(2,t[1],t[2],e,o),nt(2,t[2],t[3],e,a),nt(2,r,o,e,h),nt(2,o,a,e,m),nt(2,h,m,e,u)):(it(2,t[0],t[1],e,r),it(2,t[1],t[2],e,o),it(2,t[2],t[3],e,a),it(2,r,o,e,h),it(2,o,a,e,m),it(2,h,m,e,u));const c=t[3].clone();s&&(s[0].assign(t[0]),s[1].assign(r),s[2].assign(h),s[3].assign(u)),i&&(i[0].assign(u),i[1].assign(m),i[2].assign(a),i[3].assign(c))}function Po(t,e,s,i){if(n(e>=0&&s<=1&&e<=s),e===s){const s=new l;return Co(t,e,s),i[0].assign(s),i[1].assign(s),i[2].assign(s),void i[3].assign(s)}if(0===e&&1===s){for(let e=0;e<4;++e)i[e].assign(t[e]);return}const r=T(l,4);yo(t,s,r,null),yo(r,s>0?e/s:0,null,r),Co(t,e,r[0]),Co(t,s,r[3]),i[0].setCoordsPoint2D(r[0]),i[1].setCoordsPoint2D(r[1]),i[2].setCoordsPoint2D(r[2]),i[3].setCoordsPoint2D(r[3])}function Co(t,e,s,n){if(n){if(e<0)return void yn(new pm({start:t[0],end:t[0].add(Eo(t,0).getUnitVector())}),e,s);if(e>1)return void yn(new pm({start:t[3],end:t[3].add(Eo(t,1).getUnitVector())}),e-1,s)}if(e<=.5){const n=new l;nt(2,t[0],t[1],e,n);const i=new l;nt(2,t[1],t[2],e,i);const r=new l;nt(2,t[2],t[3],e,r);const o=new l;nt(2,n,i,e,o);const a=new l;nt(2,i,r,e,a),nt(2,o,a,e,s)}else{const n=new l;it(2,t[0],t[1],e,n);const i=new l;it(2,t[1],t[2],e,i);const r=new l;it(2,t[2],t[3],e,r);const o=new l;it(2,n,i,e,o);const a=new l;it(2,i,r,e,a),it(2,o,a,e,s)}}function Eo(t,e){const s=A(e,0,1);let n=co(t,1,s);return n.isZero()&&(n=co(t,2,s),n.isZero()?n=co(t,3,s):1===s&&n.negateThis()),n}function So(t,e,s){const n=T(l,4);t.queryControlPoints(n),function(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(function(t,e,s){const n=[Rs.constructPoint2D(t[0]),Rs.constructPoint2D(t[1]),Rs.constructPoint2D(t[2]),Rs.constructPoint2D(t[3])],i=new Rs;return function(t,e,s,n){{const e=I.subE(s),i=e.sqr(),r=s.sqr(),o=t[1].subE(t[0]).mulE(i).addE(t[2].subE(t[1]).mulE(new v(2).mulE(e).mulE(s))).addE(t[3].subE(t[2]).mulE(r));n.setE(o.mulE(new v(3)))}}(n,0,s,i),i}(t,0,e))}(n,e,s)}function vo(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==Do(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function Io(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==To(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function bo(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==Ao(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function wo(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==Mo(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Do(t,e,s,n,i,o,a,m,u,c){if(null!==i&&(i.length=0),null!=o&&(o.length=0),null!==n&&(n.length=0),s.isDegenerate(0)){const t=[0,0,0],r=e.intersectPoint(s.getStartXY(),t,a);if(r>0){if(null!==i)for(let e=0;e<r;e++)i.push(t[e]);if(null!==o)for(let t=0;t<r;t++)o.push(0);if(null!=n)for(let s=0;s<r;s++){const i=new l;e.queryCoord2D(t[s],i),n.push(i)}}return r}const g=mn(e,s);if(ln(e,s,a=Math.max(a,g)))return 0;const d=T(l,4);$r(e,d);const _=s.getEndXY();_.subThis(s.getStartXY());const p=_.clone();p.leftPerpendicularThis();let f=3*d[3].dotProduct(p),x=2*d[2].dotProduct(p),y=d[1].dotProduct(p);const P=h(15,Number.NaN),C=h(15,Number.NaN);let E=$n(f,x,y,r.unit(),!1,P);E<0&&(P[0]=0,P[1]=1,E=2);let S,v=0;for(let t=0,n=v;t<E;++t){const i=e.getCoord2D(P[t+n]);C[v]=s.getClosestCoordinate(i,!1),l.distance(i,s.getCoord2D(C[v]))<=a&&(P[v]=P[t+n],v++)}if(d[0].subThis(s.getStartXY()),Math.abs(_.x)>=Math.abs(_.y)){const t=_.y/_.x;f=d[3].y-d[3].x*t,x=d[2].y-d[2].x*t,y=d[1].y-d[1].x*t,S=d[0].y-d[0].x*t}else{const t=_.x/_.y;f=d[3].x-d[3].y*t,x=d[2].x-d[2].y*t,y=d[1].x-d[1].y*t,S=d[0].x-d[0].y*t}const I=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),b=[0,0,0];E=ti(f,x,y,S,r.unit(),I,b);for(let t=0,n=v;t<E;++t){P[t+n]=b[t];const i=e.getCoord2D(P[t+n]);C[v]=s.getClosestCoordinate(i,!1),l.distance(i,s.getCoord2D(C[v]))<=a&&(P[v]=P[t+n],v++)}E=e.intersectPoint(s.getStartXY(),b,a);for(let t=0;t<E;t++)P[v]=b[t],C[v++]=0;E=e.intersectPoint(s.getEndXY(),b,a);for(let t=0;t<E;t++)P[v]=b[t],C[v++]=1;return 0!==s.intersectPoint(e.getStartXY(),b,a)&&(C[v]=b[0],P[v++]=0),0!==s.intersectPoint(e.getEndXY(),b,a)&&(C[v]=b[0],P[v++]=1),0===v?0:cm(t,e,s,P,C,v,n,i,o,a,m,0,c)}function To(t,e,s,n,i,o,a,h,m,u){if(qh(s))return Do(t,e,new pm({start:s.getStartXY(),end:s.getEndXY()}),n,i,o,a,h,0,u);const c=mn(e,s);if(ln(e,s,a=Math.max(a,c)))return 0;const g=[],d=[],_=[],p=T(l,4);{e.queryControlPoints(p);const t=T(l,4),n=new Ps;s.canonicToWorldTransformation(n);const i=new Ps;i.setInvert(n),i.transformPoints2D(p,4,t);const o=T(Hs,4);io(t,o);const m=[o[0].x,o[1].x,o[2].x,o[3].x],u=[o[0].y,o[1].y,o[2].y,o[3].y],c=T(y,3);c[0].setDouble(s.getSemiMinorAxis()),c[0].sqrThis(),c[1].setDouble(s.getSemiMajorAxis()),c[1].sqrThis(),c[2].setThis(c[0]),c[2].mulThis(c[1]),c[2].negateThis();const f=Si(m,3,u,3,null,0,c,0,r.unit(),r.unit(),d,h);if(f>0){let t=0;for(let n=0;n<f;n++){const i=new l;e.queryCoord2D(d[n],i);const r=s.getClosestCoordinate(i,!1),o=new l;s.queryCoord2D(r,o),l.distance(i,o)<=a&&(g.push(i.clone()),d[t]=d[n],_.push(r),t++)}d.length=t,g.length=t}}const f=[0,1];for(let t=0;t<2;t++){const e=0===t?s.getStartXY():s.getEndXY(),n=[0];Vo(p,e,r.unit(),!1,-1,1,n);const i=new l;Co(p,n[0],i),l.distance(e,i)<=a&&(d.push(n[0]),_.push(f[t]),g.push(i.clone()))}for(let t=0;t<2;t++){const e=[0,3];{const n=s.getClosestCoordinate(p[e[t]],!1),i=new l;s.queryCoord2D(n,i),l.distance(p[e[t]],i)<=a&&(d.push(f[t]),_.push(n),g.push(i.clone()))}}return cm(t,e,s,d,_,d.length,n,i,o,a,h,0,u)}function No(t,e,s,i,o,a,h,m,u,c){const g=T(l,4);e.queryControlPoints(g);const d=T(l,4);if(s.queryControlPoints(d),un(g,d,4)<0)return No(t,s,e,i,a,o,h,m,u,!c);const _=mn(e,s);if(ln(e,s,h=Math.max(h,_)))return 0;if(function(t,e,s,n,i,r,o,a,h){const m=T(l,4);t.queryControlPoints(m);const u=T(l,4);if(e.queryControlPoints(u),m[0].equals(u[0])){if(m[1].equals(u[1])&&m[2].equals(u[2])&&m[3].equals(u[3]))return s&&(s.length=0,s.push(m[0]),s.push(m[3])),n&&(n.length=0,n.push(0),n.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!m[0].equals(u[3]))return!1}return!!(m[0].equals(u[3])&&m[1].equals(u[2])&&m[2].equals(u[1])&&m[3].equals(u[0]))&&(n&&(n.length=0,n.push(0),n.push(1),h&&(n[1]=p(n[0],n[0]=n[1]))),i&&(i.length=0,i.push(1),i.push(0),h&&(i[1]=p(i[0],i[0]=i[1]))),s&&(s.length=0,s.push(m[0]),s.push(m[3]),h&&(s[1]=p(s[0],s[0]=s[1]))),!0)}(e,s,i,o,a,0,0,0,c))return 2;const f=new r(0,1),x=new r(0,1);{const t=new Vs;qo(g,new r(0,1),t);const e=new Vs;qo(d,new r(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*h),e.inflate(3*h),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Lo(g,t,f),f.isEmpty())return 0;if(Lo(d,t,x),x.isEmpty())return 0;Po(g,f.vmin,f.vmax,g),Po(d,x.vmin,x.vmax,d)}}const y=dm(g,3,d,3,h);if(0===y)return 0;const P=[],C=[],E=[];let S=!1;if(-1===y){const t=T(Hs,4);io(g,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],n=T(Hs,4);io(d,n);const i=[],o=[],a=Ei(e,3,s,3,null,0,[n[0].x,n[1].x,n[2].x,n[3].x],3,[n[0].y,n[1].y,n[2].y,n[3].y],3,null,0,0,r.unit(),r.unit(),i,o,u);if(a>0)for(let t=0;t<a;t++){const e=new l;Co(d,o[t],e);const s=new l;Co(g,i[t],s),l.distance(s,e)<=h&&(P.push(s.clone()),E.push(o[t]),C.push(i[t]))}else-1===a&&(S=!0)}for(let t=0;t<2;t++){const e=0===t?g:d,s=0===t?d:g;for(let n=0;n<2;n++){const i=0===n?0:3,o=[0];Vo(s,e[i],r.unit(),!1,-1,1,o);const a=new l;Co(s,o[0],a),l.distance(e[i],a)<=h&&(0===t?(C.push(0===i?0:1),E.push(o[0])):(E.push(0===i?0:1),C.push(o[0])),P.push(a.clone()))}}if(0===C.length&&S){const t=e.calculateUpperLength2D()>s.calculateUpperLength2D();{const i=[0,0];if(2===Xo(t?e:s,i,!0)&&(n(r.unit().containsCoordinate(i[0])),!r.unit().containsCoordinate(i[1]))){const e=new l;Co(t?g:d,i[0],e);const s=[0,0];1===Vo(t?d:g,e,r.unit(),!1,-1,2,s)&&(P.push(e.clone()),C.push(t?i[0]:s[0]),E.push(t?s[0]:i[0]))}}}if(0===C.length)return 0;if(!f.equalsRange(0,1))for(let t=0;t<C.length;++t)C[t]=jo.recalculateParentT(f.vmin,f.vmax,C[t]);if(!x.equalsRange(0,1))for(let t=0;t<E.length;++t)E[t]=jo.recalculateParentT(x.vmin,x.vmax,E[t]);return cm(t,e,s,C,E,C.length,i,o,a,h,m,0,c)}function Ao(t,e,s,i,o,a,h,m,u,c){const g=mn(e,s);if(s.isDegenerateToLineHelper(g)){const n=new pm({start:s.getStartXY(),end:s.getEndXY()}),r=Do(t,e,n,i,o,a,h,m,0,c);if(a)for(let t=0;t<r;++t){const e=n.getCoord2D(a[t]);a[t]=s.getClosestCoordinate(e,!1)}return r}if(ln(e,s,h=Math.max(h,g)))return 0;const d=T(l,4);e.queryControlPoints(d);const _=T(l,3);s.queryControlPoints(_);const p=new r(0,1),f=new r(0,1),x=[0,0,0];s.queryWeights(x);const P=[1,ka(x),1];{const t=new Vs;qo(d,new r(0,1),t);const e=new Vs;ya(_,P,new r(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*h),e.inflate(3*h),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Lo(d,t,p),p.isEmpty())return 0;if(Xa(_,P,t,f),f.isEmpty())return 0;Po(d,p.vmin,p.vmax,d),va(_,P,f.vmin,f.vmax,_,P)}}const C=dm(d,3,_,2,h);if(0===C)return 0;const E=[],S=[],v=[];if(-1===C){const t=T(Hs,4);io(d,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],n=T(y,3),i=T(y,3),o=T(y,3);Ga(_,P,n,i,o);const a=[],m=[],c=Ei(n,2,i,2,o,2,e,3,s,3,null,0,0,r.unit(),r.unit(),m,a,u);if(c>0)for(let t=0;t<c;t++){const e=new l;Co(d,a[t],e);const s=new l;Ya(_,P,m[t],s),l.distance(e,s)<=h&&(E.push(e.clone()),S.push(a[t]),v.push(m[t]))}}for(let t=0;t<2;t++){let e,s;0===t?(e=d,s=_):(s=d,e=_);for(let i=0;i<2;i++){const o=0===i?0:e.length-1,a=[0],m=new l;if(0===t){const t=fa(s,P,e[o],r.unit(),!1,-1,1,a);n(1===t),Ya(s,P,a[0],m)}else{const t=Vo(s,e[o],r.unit(),!1,-1,1,a);n(1===t),Co(s,a[0],m)}l.distance(e[o],m)<=h&&(0===t?(S.push(0===o?0:1),v.push(a[0])):(v.push(0===o?0:1),S.push(a[0])),E.push(m.clone()))}}if(0===S.length)return 0;if(!p.equalsRange(0,1))for(let t=0;t<S.length;++t)S[t]=jo.recalculateParentT(p.vmin,p.vmax,S[t]);if(!f.equalsRange(0,1))for(let t=0;t<v.length;++t)v[t]=pi.recalculateParentT(f.vmin,f.vmax,v[t]);for(let t=0;t<v.length;++t)v[t]=Ra(x,v[t]);return cm(t,e,s,S,v,S.length,i,o,a,h,m,0,c)}function Mo(t,e,s,i,o,a,h,m,u,c){const g=mn(e,s);if(ln(e,s,h=Math.max(h,g)))return 0;const d=T(l,4);e.queryControlPoints(d);const _=T(l,3);s.queryControlPoints(_);const p=dm(d,3,_,2,h);if(0===p)return 0;const f=[],x=[],y=[];if(-1===p){const t=T(Hs,4);io(d,t);const n=[t[0].x,t[1].x,t[2].x,t[3].x],i=[t[0].y,t[1].y,t[2].y,t[3].y],o=T(Hs,3);xr(_,o);const a=Ei([o[0].x,o[1].x,o[2].x],2,[o[0].y,o[1].y,o[2].y],2,null,0,n,3,i,3,null,0,0,r.unit(),r.unit(),y,x,m);if(a>0){let t=0;for(let n=0;n<a;n++){const i=new l;e.queryCoord2D(x[n],i);const r=new l;s.queryCoord2D(y[n],r),l.distance(i,r)<=h&&(f.push(i.clone()),x[t]=x[n],y[t]=y[n],t++)}x.length=t,f.length=t}}for(let t=0;t<2;t++){let e,s;0===t?(e=d,s=_):(s=d,e=_);for(let i=0;i<2;i++){const o=0===i?0:e.length-1,a=[0],m=new l;if(0===t)rr(s,e[o],a),yr(s,a[0],m);else{const t=Vo(s,e[o],r.unit(),!1,-1,1,a);n(1===t),Co(s,a[0],m)}l.distance(e[o],m)<=h&&(0===t?(x.push(0===o?0:1),y.push(a[0])):(y.push(0===o?0:1),x.push(a[0])),f.push(m.clone()))}}return cm(t,e,s,x,y,x.length,i,o,a,h,m,0,c)}function Go(t,e,s){const n=T(l,4);t.queryControlPoints(n),qo(n,e,s)}function qo(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,4);const n=T(l,4);Po(t,e.vmin,e.vmax,n),s.setFromPoints(n,4)}let Fo=class{constructor(t,e,s){this.dbgCounter=0,this.controlPoints=t,this.point=e.clone(),this.maxDistance=s}getMaxDerivative(){return 6}getValue(t,e){switch(t){case 0:{const t=new l;Co(this.controlPoints,e,t);const s=co(this.controlPoints,1,e);return 2*t.sub(this.point).dotProduct(s)}case 1:{const t=new l;Co(this.controlPoints,e,t);const s=co(this.controlPoints,1,e),n=co(this.controlPoints,2,e);return 2*(t.sub(this.point).dotProduct(n)+s.dotProduct(s))}case 2:{const t=new l;Co(this.controlPoints,e,t);const s=co(this.controlPoints,1,e),n=co(this.controlPoints,2,e),i=co(this.controlPoints,3,e);return 2*(t.sub(this.point).dotProduct(i)+3*s.dotProduct(n))}case 3:{const t=co(this.controlPoints,1,e),s=co(this.controlPoints,2,e),n=co(this.controlPoints,3,e);return 2*(4*t.dotProduct(n)+3*s.sqrLength())}case 4:{const t=co(this.controlPoints,2,e),s=co(this.controlPoints,3,e);return 10*t.dotProduct(s)*2}case 5:{const t=co(this.controlPoints,3,e);return 10*t.dotProduct(t)*2}default:return 0}}getError(t){return 0}isInterestingInterval(t,e){if(t>=0&&e<=1){const s=T(l,4);Po(this.controlPoints,t,e,s);const n=new Vs;if(n.setFromPoints(s,4),Math.sqrt(n.sqrMinDistance(this.point))>this.maxDistance)return!1}return!0}};function Vo(t,e,s,i,o,a,m){rt(r.unit().contains(s)&&a>0,"getClosestCoordinate"),(o<0||Number.isNaN(o))&&(o=Number.MAX_VALUE);const u=[],c=new l;Co(t,s.vmin,c);let g=l.distance(c,e);if(g<=o&&u.push(new l(s.vmin,g)),s.vmin!==s.vmax&&(Co(t,s.vmax,c),g=l.distance(c,e),g<=o&&u.push(new l(s.vmax,g))),s.width()>0){const n=h(18,Number.NaN),i=Jn(new Fo(t,e,o),s,18,n);for(let s=0;s<i;s++)Co(t,n[s],c),g=l.distance(c,e),g>o||u.push(new l(n[s],g))}if(i){n(s.equals(r.unit()));{Co(t,-1,c,!0);const s=new l;Co(t,0,s);const n=new pm({start:c,end:s}),i=n.getClosestCoordinate(e,!0);i<1&&(c.assign(n.getCoord2D(i)),g=l.distance(c,e),g<=o&&u.push(new l(i-1,g)))}{Co(t,2,c,!0);const n=new l;Co(t,s.vmax,n);const i=new pm({start:n,end:c}),r=i.getClosestCoordinate(e,!0);r>0&&(c.assign(i.getCoord2D(r)),g=l.distance(c,e),g<=o&&u.push(new l(1+r,g)))}}if(!u.length)return 0;u.sort((t,e)=>t.compare(e));let d=0;const _=u[0].x;if(m[d++]=_,d<a){const e=Be(t,4,!1).total(),s=u[0].y;for(let t=1,n=u.length;t<n;t++)if(u[t].y>s+e){u.length=t;break}u.sort((t,e)=>at(t.x,e.x)),d=0,m[d++]=u[0].x;for(let t=1,e=u.length;t<e;t++)u[t].x!==m[d-1]&&d<a&&(m[d++]=u[t].x)}return d}function Yo(t,e,s,n,i,r,o){const a=T(l,4);return t.queryControlPoints(a),Vo(a,e,s,n,i,r,o)}function Xo(t,e,s=!1){const n=T(l,4);t.queryControlPoints(n);const i=T(Hs,4);let o,a,h;io(n,i,!0);const m=i[3].x.isZero(),u=i[3].y.isZero();if(m||u)if(m&&!u){if(i[2].x.isZero())return 0;o=i[1].x.div(i[2].x).negate(),a=i[2].y.div(i[3].y),h=i[1].y.div(i[3].y)}else{if(m||!u)return 0;if(i[2].y.isZero())return 0;o=i[1].y.div(i[2].y).negate(),a=i[2].x.div(i[3].x),h=i[1].x.div(i[3].x)}else{i[2].x.divThis(i[3].x),i[1].x.divThis(i[3].x),i[2].y.divThis(i[3].y),i[1].y.divThis(i[3].y);const t=i[2].x.sub(i[2].y);if(t.isZero())return 0;o=i[1].x.sub(i[1].y).div(t).negate(),a=i[2].x.clone(),h=i[1].x.clone()}if(!s&&o.abs().value()>2)return 0;const c=[0,0],g=t.getStartXY().equals(t.getEndXY()),d=$n(1,-o.toDouble(),o.add(a).mul(o).add(h).toDouble(),r.unit(),g,c);if(0===d)return 0;if(c[0]>=0&&c[0]<=1){const t=o.toDouble()-c[0];if(s||t>=0&&t<=1)return e[0]=c[0],e[1]=t,e[0]>e[1]&&(e[1]=p(e[0],e[0]=e[1])),2}if(2===d&&c[1]>=0&&c[1]<=1){const t=o.toDouble()-c[1];if(s||t>=0&&t<=1)return e[0]=c[1],e[1]=t,e[0]>e[1]&&(e[1]=p(e[0],e[0]=e[1])),2}return 0}function ko(t,e){e[0].set(0);let s=1;const i=T(v,4);so(t,i,!0);const o=T(v,4);no(t,o,!0);{const t=i[3].mul(3),n=i[2].mul(2),o=i[1].clone(),a=T(v,2);let h=oi(t,n,o,new r(0,1),!1,a);h<0&&(h=0);for(let t=0;t<h;t++)M(a[t].value(),0,1)||(e[s]=a[t],s++)}{const t=o[3].mul(3),n=o[2].mul(2),i=o[1].clone(),a=T(v,2);let h=oi(t,n,i,new r(0,1),!1,a);h<0&&(h=0);for(let t=0;t<h;t++)M(a[t].value(),0,1)||(e[s]=a[t],s++)}const a=function(t,e,s){const n=t[1].mulE(e[2]).subThisE(t[2].mulE(e[1])),i=t[1].mulE(e[3]).subThisE(t[3].mulE(e[1])).mulThis(3),o=t[2].mulE(e[3]).subThisE(t[3].mulE(e[2])).mulThis(3),a=T(v,2);let h=oi(o,i,n,new r(0,1),!1,a);h<0&&(h=0);let m=0;for(let t=0;t<h;t++)M(a[t].value(),0,1)||(s[m].setE(a[t]),m++);return m}(i,o,e.slice(s));if(s+=a,e[s].set(1),s++,s>2){_(e,0,s,(t,e)=>{const s=t.value(),n=e.value();return s<n?-1:s>n?1:0});let n=0;const i=e[0].clone();let r=0;const o=((h=t)[0].norm(1)+h[1].norm(1)+h[2].norm(1)+h[3].norm(1))*G(),a=new l;xo(t,e[0].value(),a);for(let h=1;h<s;h++){const s=new l;if(xo(t,e[h].value(),s),e[h].eq(i)||s.isEqualPoint2D(a,o)){if(0!==n){if(0===e[h].eps())i.setE(e[h]),r=0;else if(0!==r){const t=ot(1/e[h].eps()),s=1/r,n=t+s;i.set((e[h].value()*t+i.value()*s)/n),r=1/n,i.setError(Math.sqrt(r))}e[n].setE(i),xo(t,i.value(),a)}}else n++,e[n].setE(e[h]),i.setE(e[h]),xo(t,i.value(),a),r=ot(e[h].eps())}n++,s=n}var h;return 1===s&&(s=2,e[1].set(1)),n(0===e[0].value()),n(1===e[s-1].value()),s}function Ro(t,e,s,n){const i=T(l,s);for(let t=0;t<s;++t)i[t]=new l(t/(s-1),0);const o=(t,e,s,n)=>{const i=new v(e.x).subE(new v(t.x)).divE(new v(e.y).subE(new v(t.y))).mulE(new v(s).subE(new v(t.y))).addE(new v(t.x));if(i.eps()>.1){const n=(e.x-t.x)/(e.y-t.y)*(s-t.y)+t.x;i.set(n,G())}if(i.lt(new v(0))||i.gt(new v(1)))return!1;let r=i.value()-i.eps();r=A(r,0,1);let o=i.value()+i.eps();return o=A(o,0,1),n.mergeCoordinate(r),n.mergeCoordinate(o),!0},a=[];{const e=(t,e)=>{a.length=s;const n=Xr(i,s,a,!0),h=new r;h.setEmpty();const m=s=>s.y<t?-1:s.y>e?1:0;let l=i[a[0]],u=m(l);0===u&&h.mergeCoordinate(l.x);for(let s=1;s<=n;++s){const r=i[a[s%n]],c=m(r);0===c&&h.mergeCoordinate(r.x);let g=0;c!==u&&(g=c*u===0?1===c||1===u?2:1:3,1&g&&o(l,r,t,h),2&g&&o(l,r,e,h)),l=r,u=c}return h};for(let e=0;e<s;++e)i[e].y=t[e].x;const h=e(n.xmin,n.xmax);if(h.isEmpty())return new r(h);for(let e=0;e<s;++e)i[e].y=t[e].y;const m=e(n.ymin,n.ymax);return h.intersect(new r(m)),new r(h)}}function Lo(t,e,s){s.setEmpty(),s.merge(function(t,e,s,n){const i=Ro(t,0,4,n.getEnvelope2D());if(i.isEmpty())return new r(i);const o=T(l,4);for(let e=0;e<4;++e)n.xyRot(t[e],o[e]);const a=Ro(o,0,4,n.getRotatedEnvelope2D());return i.intersect(new r(a)),new r(i)}(t,0,0,e))}class Ho{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-ro(this.b,e,!1):0}getError(t){return 0}}function Bo(t,e,s,i,r,o,a){for(;;){const h=l.distance(e[0],e[3]),m=l.distance(e[0],e[1])+l.distance(e[1],e[2])+l.distance(e[2],e[3]);if(m-h<=i+s*m)return t+C(h,m,.5);const u=t=>co(e,1,t).length();{n(a<12);let h=u(0),c=u(1);r[0]+=2,h>c&&(c=p(h,h=c),e[3]=p(e[0],e[0]=e[3]),e[2]=p(e[1],e[1]=e[2]));let g=h/(h+c),d=1,_=m;for(;g<1/32&&_>=32*(i+s*_);){d/=4;const t=u(d);r[0]++,g=h/(t+h);const s=new l;if(Co(e,.5*d,s),_=l.distance(s,e[0]),_<=i){const t=new l;Co(e,d,t),_+=l.distance(t,s)}}if(1!==d){const n=T(l,4);yo(e,d,e,n),t=Bo(t,n,s,i,r,0,a+1),o++,a++;continue}}const c=8;r[0]+=c;const g=Dr(c,u,0,1),d=16;r[0]+=d;const _=Dr(d,u,0,1);let f=Math.abs(g-_)>i+s*m;if(!f)return t+_;if(o<3){const n=T(l,4);yo(e,.5,e,n),t=Bo(t,n,s,i,r,o+1,a+1),o++,a++;continue}const x=32;r[0]+=x;const y=Dr(x,u,0,1);if(f=Math.abs(_-y)>i+s*m,!f)return t+y;const P=64;r[0]+=P;const E=Dr(P,u,0,1);if(f=Math.abs(y-E)>i+s*m,!f)return t+E;const S=128;r[0]+=S;const v=Dr(S,u,0,1);return f=Math.abs(E-v)>i+s*m,t+v}}function Uo(t,e,s,n,i){if(s===e)return 0;const r=T(l,4);t.queryControlPoints(r);const o=T(l,4);return Po(r,e,s,o),Bo(0,o,n,i,[0],0,0)}function zo(t,e,s,n,i){let r=!0;const o=ki(5,e,s,n,i,e=>{const s=go(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()});r=!1;const a=ki(5,e,s,n,i,e=>{const s=go(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()});return new l(o,a)}function Oo(t,e,s,i,r,o,a,h,m,l,u,c){n(l+2===c);let g=0,d=0,_=0,p=0,f=0,x=0,y=0;const P=(t,e)=>{const n=1-e,a=s.mul(Nt(n)),h=i.mul(3*e*n*n),m=r.mul(3*e*e*n),l=o.mul(Nt(e));return a.add(h).add(m).add(l).sub(u[t]).sqrLength()};for(let e=1,n=c-1;e<n;e++){let n=m[e-1];if(t){e>2?(n=A(2*m[e-2]-m[e-3],0,1),m[e-1]=n):2===e&&(n=A(2*m[e-2],0,1),m[e-1]=n);const t=(t,e,n)=>{let a=-1;for(let h=0;!(Math.abs(e-a)<1e-12)&&10!==h;h++){const h=e*e,m=1-e,l=m*m,c=l*m,g=s.x-2*i.x+r.x,d=s.x-3*i.x+3*r.x-o.x,_=s.y-2*i.y+r.y,p=s.y-3*i.y+3*r.y-o.y,f=s.x-i.x-2*g*e+d*h,x=-u[t].x+s.x*c+e*(3*i.x*l+e*(3*r.x*m+o.x*e)),y=s.y-i.y-2*_*e+p*h,P=-u[t].y+s.y*c+e*(3*i.y*l+e*(3*r.y*m+o.y*e)),C=-6*(f*x+y*P),E=6*(3*ot(f)-(-2*g+2*d*e)*x)+6*(3*ot(y)-(-2*_+2*p*e)*P);if(a=e,0===E)break;e=A(e-C/E,n,1)}return a};{const s=P(e,m[e-1]);let n=t(e,m[e-1],0),i=P(e,n);if(1.01*s<i){const s=e>1?m[e-2]:0,r=t(e,.3*(m[e-1]-s)+s,0),o=P(e,r);o<i&&(i=o,n=r)}s>i&&(m[e-1]=n)}}const a=m[e-1],h=a*a,l=h*a,c=1-a,C=c*c,E=C*c;g+=3*h*C*C,d+=3*l*E,_+=3*h*h*C;const S=-(E*s.x+l*o.x-u[e].x);p+=S*a*C,f+=S*h*c;const v=-(E*s.y+l*o.y-u[e].y);x+=v*a*C,y+=v*h*c}if(e){const t=g*_-d*d;Math.abs(t)>=1e-12*(Math.abs(g*_)+Math.abs(d*d))+1e-10?(a||(i.x=(p*_-f*d)/t,i.y=(x*_-y*d)/t),h||(r.x=(g*f-d*p)/t,r.y=(g*y-d*x)/t)):(st(s,o,.3,i),st(s,o,.6,r))}let C=0;for(let t=1,e=c-1;t<e;t++)C+=P(t,m[t-1]);return C}var Wo=Ee;class jo extends fn{constructor(t){t&&t.cp?(super({start:t.cp[0],end:t.cp[3],vd:t.vd}),this.m_cp=T(l,2),this.m_cp[0].assign(t.cp[1]),this.m_cp[1].assign(t.cp[2])):void 0===t||X(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=T(l,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):t.from?(super({start:t.from,end:t.to,vd:t.vd}),this.m_cp=T(l,2),this.m_cp[0].assign(t.cp1),this.m_cp[1].assign(t.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:t.vd}),P("unrecognized constructor params"),this.m_cp=T(l,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return Qn(this)}construct(t,e,s,n){this.m_XStart=t.x,this.m_YStart=t.y,this.m_XEnd=n.x,this.m_YEnd=n.y,this.m_cp[0].assign(e),this.m_cp[1].assign(s),this.afterCompletedModification()}constructPoints(t){this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.afterCompletedModification()}constructFromQuadratic(t){const e=T(l,4);var s,n;s=t,(n=e)[0].assign(s[0]),n[3].assign(s[2]),st(s[0],s[1],2/3,n[1]),st(s[1],s[2],1/3,n[2]),this.constructPoints(e)}constructFromQuadraticSegment(t){this.dropAllAttributes(),this.assignVertexDescription(t.getDescription()),this.m_XStart=t.getStartX(),this.m_YStart=t.getStartY(),this.m_XEnd=t.getEndX(),this.m_YEnd=t.getEndY(),H(2,t.getStartXY(),t.getControlPoint1(),2/3,this.m_cp[0]),H(2,t.getControlPoint1(),t.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),an(this,t)}getGeometryType(){return o.enumBezier}queryEnvelope(t){if(2!==t.m_EnvelopeType)return void n(0);if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp[0])&&t.contains(this.m_cp[1]))return;const e=ao(this);if(null!==e){const s=new l;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s);return}const s=T(v,8),i=T(l,4);this.queryControlPoints(i);const r=ko(i,s),o=new l;for(let e=1;e<r-1;e++)this.queryCoord2D(s[e].value(),o),t.mergeNe(o)}applyTransformation(t){if(1===t.m_TransformationType){const e=T(l,4);return this.queryControlPoints(e),t.transformPoints2D(e,4,e),this.setStartXY(e[0]),this.m_cp[0].assign(e[1]),this.m_cp[1].assign(e[2]),this.setEndXY(e[3]),void mo(this)}n(0)}createInstance(){return new jo({vd:this.m_description})}calculateLength2D(){return ro(this,1,!1)}calculateLowerLength2D(){return l.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return l.distance(this.getStartXY(),this.m_cp[0])+l.distance(this.m_cp[0],this.m_cp[1])+l.distance(this.getEndXY(),this.m_cp[1])}queryCoord2D(t,e){return this.queryCoord2DExtends(t,e,!0)}queryCoord2DMP(t,e){n(0)}queryCoord2DExtends(t,e,s){const n=T(l,4);this.queryControlPoints(n),Co(n,t,e,s)}queryCoord2DE(t,e){!function(t,e,s){const n=T(l,4);t.queryControlPoints(n),function(t,e,s){if(e.value()<=.5){const n=new Rs;J(2,Rs.constructPoint2D(t[0]),Rs.constructPoint2D(t[1]),e,n);const i=new Rs;J(2,Rs.constructPoint2D(t[1]),Rs.constructPoint2D(t[2]),e,i);const r=new Rs;J(2,Rs.constructPoint2D(t[2]),Rs.constructPoint2D(t[3]),e,r);const o=new Rs;J(2,n,i,e,o);const a=new Rs;J(2,i,r,e,a),J(2,o,a,e,s)}else{const n=new Rs;$(2,Rs.constructPoint2D(t[0]),Rs.constructPoint2D(t[1]),e,n);const i=new Rs;$(2,Rs.constructPoint2D(t[1]),Rs.constructPoint2D(t[2]),e,i);const r=new Rs;$(2,Rs.constructPoint2D(t[2]),Rs.constructPoint2D(t[3]),e,r);const o=new Rs;$(2,n,i,e,o);const a=new Rs;$(2,i,r,e,a),$(2,o,a,e,s)}}(n,e,s)}(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new l;return this.queryCoord2DExtends(t,e,!0),e.x}const e=C(this.getStartX(),this.m_cp[0].x,t),s=C(this.m_cp[0].x,this.m_cp[1].x,t),n=C(this.m_cp[1].x,this.getEndX(),t),i=C(e,s,t),r=C(s,n,t);return C(i,r,t)}getCoordY(t){if(t<0||t>1){const e=new l;return this.queryCoord2DExtends(t,e,!0),e.y}const e=C(this.getStartY(),this.m_cp[0].y,t),s=C(this.m_cp[0].y,this.m_cp[1].y,t),n=C(this.m_cp[1].y,this.getEndY(),t),i=C(e,s,t),r=C(s,n,t);return C(i,r,t)}cut(t,e,s){const n=new fm;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createCubicBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=Wo.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=Wo.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){So(this,t,e)}cutBezierIgnoreAttributes(t,e,n){(t<0||e>1||t>e)&&s("Cubic_bezier.cut_bezier_ignore_attributes");const i=T(l,4);this.queryControlPoints(i);const r=T(l,4);Po(i,t,e,r),n.setControlPoints(r)}splitBezierIgnoreAttributes(t,e,n){this===e&&this===n&&s("Cubic_bezier.split_bezier_ignore_attributes");const i=T(l,4);this.queryControlPoints(i);const r=T(l,4),o=T(l,4);yo(i,t,r,o),e&&e.setControlPoints(r),n&&n.setControlPoints(o)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const n=this.getStartAttributeAsDbl(e,s),i=this.getEndAttributeAsDbl(e,s),r=this.calculateLength2D(),o=r>0?this.tToLength(t)/r:0,a=Wo.getInterpolation(e);return Y(a,n,i,o,Wo.getDefaultValue(e))}getClosestCoordinate(t,e){const s=[Number.NaN];return Yo(this,t,r.unit(),e,-1,1,s),s[0]}getClosestCoordinateOnInterval(t,e,s=-1){const n=[Number.NaN];return 0===Yo(this,t,e,!1,s,1,n)?Number.NaN:n[0]}getYMonotonicParts(t,e=!1){return this.getMonotonicParts(t,e)}getMonotonicParts(t,e){t.length<2&&s("");const i=oo(this);if(2===i.specialPointsCount()&&this.isMonotoneQuickAndDirty())return 0;let r=0;n(t.length>=i.specialPointsCount()-1);for(let s=1,n=i.specialPointsCount();s<n;++s)this.queryCut(i.specialPoints[s-1],i.specialPoints[s],t[r],e),r++;for(let e=0;e<r;++e)po(t[e].get());return r}intersectionWithAxis2D(t,e,s,n){const i=T(l,4);return this.queryControlPoints(i),function(t,e,s,n,i){const o=T(v,4),a=T(v,3),h=new r(0,1);let m=0;if(e){if(no(t,o,!1),m=ai(o[3],o[2],o[1],o[0].sub(s),h,!1,a),n)for(let e=0;e<m;e++){const s=new l;Co(t,a[e].value(),s),n[e]=s.x}}else if(so(t,o,!1),m=ai(o[3],o[2],o[1],o[0].sub(s),h,!1,a),n)for(let e=0;e<m;e++){const s=new l;Co(t,a[e].value(),s),n[e]=s.y}if(i)for(let t=0;t<m;t++)i[t]=a[t].value();else n&&_(n,0,m,at);return m}(i,t,e,s,n)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0],i=this.intersectionWithAxis2D(!0,t,s,null);return n(2!==i),-1===i?e:s[0]}isCurve(){return!0}isDegenerate(t){return Os(this,t)}isDegenerate3D(t,e){return n(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp[0]),t.mergeNe(this.m_cp[1]),void t.mergeNe(this.getEndXY());n(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(e,s){if(0===e){const e=t.constructEmpty();this.queryEnvelope(e);const n=r.constructEmpty();return 0===s?e.queryIntervalX(n):e.queryIntervalY(n),n}return super.queryInterval(e,s)}queryLooseEnvelopeOnInterval(t,e){const s=T(l,4);this.queryControlPoints(s),Po(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),n=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),i=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),r=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp[0].setCoordsPoint2D(t):n&&this.m_cp[0].setCoordsPoint2D(e),r?this.m_cp[1].setCoordsPoint2D(e):i&&this.m_cp[1].setCoordsPoint2D(t),this.normalizeAfterEndpointChange()}tToLength(t){return ro(this,t,!0)}lengthToT(t){const e=function(t,e){const s=ro(t,1,!1);if(e<=0)return e;if(e>=s)return e-s+1;const n=[0];return 1!==Jn(new Ho(t,e),r.unit(),1,n)&&P(""),n[0]}(this,t);return e}calculateWeightedAreaCentroid2D(t){const e=T(l,4);$r(this,e);const s=e[3],n=e[2],i=e[1],r=new l;r.x=(5*s.x*s.x*(7*n.y+16*i.y)+s.x*(-35*s.y*n.x+40*n.x*n.y-80*s.y*i.x+140*n.x*i.y+112*i.x*i.y)-2*(s.y*(20*n.x*n.x+70*n.x*i.x+56*i.x*i.x)-7*(4*n.x+5*i.x)*(-n.y*i.x+n.x*i.y)))/840,r.y=(-5*s.y*s.y*(7*n.x+16*i.x)+s.y*(5*s.x*(7*n.y+16*i.y)-4*(10*n.x*n.y+35*n.y*i.x+28*i.x*i.y))+2*(-7*(4*n.y+5*i.y)*(n.y*i.x-n.x*i.y)+s.x*(20*n.y*n.y+70*n.y*i.y+56*i.y*i.y)))/840;const o=_o(this);return r.x+=(e[0].x-t.x)*o,r.y+=(e[0].y-t.y)*o,r}calculateWeightedCentroid2D(){const t=new l;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){const e=l.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,e,n){void 0===n&&(n=e,e=0);const i=new l;if(e<0||n>1)return i.setNAN(),i;if(e>n&&s("calculate_sub_weightedCentroid"),e===n||t.isDegenerate(0))return i.setCoords(0,0),i;const r=oo(t),o=Jr(t),a=o/t.calculateUpperLength2D();let h=e,m=0;for(let t=1,s=r.specialPointsCount();t<s;t++)if(e<r.specialPoints[t]){m=t-1;break}i.setCoords(0,0);for(let e=m+1,s=r.specialPointsCount();e<s;e++){const s=Math.min(r.specialPoints[e],n),m=zo(t,h,s,a,o);if(i.addThis(m),h=s,n<=r.specialPoints[e])break}return i.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(t){this.m_cp[0].setCoordsPoint2D(t),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(t){this.m_cp[1].setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp[0]),t[2].assign(this.m_cp[1]),t[3].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),4}setControlPoints(t){for(let e=0;e<4;e++)t[e].isNAN()&&s("NAN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp[0].setCoordsPoint2D(t[1]),this.m_cp[1].setCoordsPoint2D(t[2]),this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.afterCompletedModification()}getTangent(t){const e=T(l,4);return this.queryControlPoints(e),Eo(e,t)}getDerivative(t){const e=T(l,4);return this.queryControlPoints(e),co(e,1,t)}getCurvature(t){const e=go(this,1,t),s=go(this,2,t),n=e.sqrLength();return 0===n?Number.NaN:(e.divThis(Math.sqrt(n)),e.crossProduct(s)/n)}isIntersectingPoint(e,s,n){if(n&&(e.equals(this.getStartXY())||e.equals(this.getEndXY())))return!1;const i=new t;if(this.queryLooseEnvelope(i),i.inflateCoords(s,s),!i.contains(e))return!1;const r=this.getClosestCoordinate(e,!1),o=new l;return this.queryCoord2D(r,o),l.distance(o,e)<=s}isIntersectingPoint3D(t,e,s,i,r=1){return n(0),!1}isMonotoneQuickAndDirty(){const t=T(l,4);return this.queryControlPoints(t),function(t){return function(t){const e=S(t[0].y,t[1].y),s=S(t[1].y,t[2].y),n=S(t[2].y,t[3].y);if(e>=0&&s>=0&&n>=0||e<=0&&s<=0&&n<=0){const e=S(t[0].x,t[1].x),s=S(t[1].x,t[2].x),n=S(t[2].x,t[3].x);if(e>=0&&s>=0&&n>=0||e<=0&&s<=0&&n<=0)return!0}return!1}(t)}(t)}getMonotonicPartParams(t,e){const i=oo(this),r=i.specialPointsCount();if(n(gn.s_maxMonotonicPartParams>=r),!e)return i.specialPointsCount();t<r&&s("");for(let t=0;t<r;t++)e[t]=i.specialPoints[t];return r}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=p(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=p(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=p(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cp[1]=p(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const t=new v;return uo(this,t),t.value()}isLine(){return!1}isDegenerateToLineHelper(t){const e=T(l,4);this.queryControlPoints(e);const s=e[3].sub(e[0]),n=s.length();if(l.distance(e[0],e[1])+l.distance(e[2],e[1])+l.distance(e[2],e[3])-n>t)return!1;const i=t;let r=e[1].clone();r.subThis(e[0]);let o=Math.abs(r.crossProduct(s))/n;return!(o>i||(r=e[2].clone(),r.subThis(e[1]),o=Math.abs(r.crossProduct(s))/n,o>i))}copyIgnoreAttributes(t){const e=T(l,4);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return _o(this)}absNorm(){return(t=this).getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp[0].norm(1)+t.m_cp[1].norm(1);var t}queryEnvelopeW(t,e){Go(this,t,e)}setSegmentFromCoordsForStitcher(t,e){!function(t,e,s){if(n(s>=2),2===s){const n=new l;st(e[0],e[s-1],1/3,n);const i=new l;return st(e[0],e[s-1],2/3,i),void t.construct(e[0],n,i,e[s-1])}const i=e[0],o=e[s-1],a=[0,0],m=Yo(t,i,r.unit(),!1,Number.NaN,2,a),u=[0,0],c=Yo(t,o,r.unit(),!1,Number.NaN,2,u),g=[];for(let n=0;n<m;n++)for(let r=0;r<c;r++){const m=a[n],c=u[r],d=m>c,_=(n,r)=>{const a=h(s-2,Number.NaN),u=()=>{let t=0;for(let n=1,i=s-1;n<i;n++){t+=l.distance(e[n-1],e[n]);const s=t;a[n-1]=s}t+=l.distance(e[s-2],e[s-1]),d&&a.reverse();for(let e=1,n=s-1;e<n;e++)a[e-1]/=t,d&&(a[e-1]=1-a[e-1])};let g=!1,_=!1;{const e=new fm;d?(t.queryCut(c,m,e,!0),n.assign(e.get().getControlPoint2()),r.assign(e.get().getControlPoint1())):(t.queryCut(m,c,e,!0),n.assign(e.get().getControlPoint1()),r.assign(e.get().getControlPoint2())),i.equals(n)&&(g=!0),o.equals(r)&&(_=!0)}u();let p=Number.MAX_VALUE;const f=n.clone(),x=r.clone();for(let t=0;t<5;t++)p=Oo(!0,!1,i,f,x,o,g,_,a,s-2,e,s);for(let t=0;t<30;t++){const t=f.clone();x.clone();const n=Oo(!0,!0,i,f,x,o,g,_,a,s-2,e,s);if(p<=n&&t.equals(f)&&t.equals(x))break;p=n}u();let y=!1,P=Number.MAX_VALUE;const C=n.clone(),E=r.clone();for(let t=0;t<30;t++){const t=C.clone();E.clone();const n=Oo(y,!0,i,C,E,o,g,_,a,s-2,e,s);if(P<=n&&t.equals(C)&&t.equals(E))break;y=!0,P=n}return P<p?(n.assign(C),r.assign(E)):(n.assign(f),r.assign(x),P=p),P},p=new l,f=new l,x=[_(p,f),l.distance(i,p)+l.distance(p,f)+l.distance(f,o),p.x,p.y,f.x,f.y];g.splice(g.length,0,...x)}let d=g[0],_=g[1],p=0;for(let t=6;t<g.length;t+=6)g[t]<d&&(d=g[t],_=g[t+1],p=t);let f=p;for(let t=0;t<g.length;t+=6)t!==p&&g[t+1]<_&&Math.abs(d-g[t])<10*d&&(_=g[t+1],f=t);t.construct(i,new l(g[f+2],g[f+3]),new l(g[f+4],g[f+5]),o)}(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(4);return this.writeInBuffer_(s),t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}writeInBuffer_(t){return t[0]=this.m_cp[0].x,t[1]=this.m_cp[0].y,t[2]=this.m_cp[1].x,t[3]=this.m_cp[1].y,4}readFromBufferStream(t,e){const s=new Float64Array(4);t.queryRange(e,s.length,s,!0,1),this.readFromBuffer_(s)}readFromBuffer_(t){this.m_cp=T(l,2),this.m_cp[0].x=t[0],this.m_cp[0].y=t[1],this.m_cp[1].x=t[2],this.m_cp[1].y=t[3],this.m_cachedValues=null}snapControlPoints(t){const e=T(l,4);this.queryControlPoints(e);const s=(e,s,n)=>{let i=!1;return l.sqrDistance(e,n)<=t&&(i=!e.equals(n),e.setCoordsPoint2D(n),l.sqrDistance(s,n)<=t&&(i||=!s.equals(n),s.setCoordsPoint2D(n))),i},n=s(e[1],e[2],e[0]),i=s(e[2],e[1],e[3]);return(n||i)&&this.setControlPoints(e),n||i}needsSnapControlPoints(t){if(!t)return!1;const e=T(l,4);this.queryControlPoints(e);const s=(e,s,n)=>{let i=!1;return l.sqrDistance(e,n)<=t&&(i=!e.equals(n),e.setCoordsPoint2D(n),l.sqrDistance(s,n)<=t&&(i||=!s.equals(n),s.setCoordsPoint2D(n))),i},n=s(e[1],e[2],e[0]),i=s(e[2],e[1],e[3]);return n||i}calculateSpecialPointsForCracking(t,e){return function(t,e,s){s.length=0;{const e=new v;uo(t,e);const n=new Rs;if(So(t,e,n),n.isZero())return e.isZero()||e.eq(new v(1))?0:(s.push(e.value()),1)}const n=T(v,4);to(t,n,!0);const i=T(v,4);eo(t,i,!0);const o=T(v,6),a=n[3].negate().mulE(i[1]).addE(n[2].mulE(i[2]).mul(2)).addE(n[1].mulE(i[3])),h=n[3].negate().mulE(i[1]).subE(n[2].mulE(i[2]).mul(2)).addE(n[1].mulE(i[3])),m=n[2].mulE(n[2]).subE(i[2].mulE(i[2]));o[0]=i[1].mulE(i[1]).mulE(a).addE(n[1].mulE(n[1]).mulE(h)).addE(n[1].mulE(i[1]).mulE(m).mul(2)).mul(6),o[1]=n[2].mulE(i[1]).subE(n[1].mulE(i[2])).mulE(n[2].mulE(n[2]).addE(n[1].mulE(n[3]).mul(2)).addE(i[2].mulE(i[2])).addE(i[1].mulE(i[3]).mul(2))).mul(24);const l=n[1].mulE(i[2]).mulE(i[2]).mulE(i[3]),u=n[2].mulE(n[2]).mulE(n[3]).mulE(i[1]).subE(l).mul(156),c=n[3].mulE(i[1]).subE(n[1].mulE(i[3])),g=n[3].mulE(i[1]).subE(n[1].mulE(i[3])),d=n[1].mulE(n[3]).mulE(g).addE(i[1].mulE(i[3]).mulE(c)).mul(72),_=i[1].mulE(i[3]).subE(n[1].mulE(n[3])),p=n[2].mulE(i[2]).mulE(_).mul(120),f=n[1].mulE(n[2]).mulE(n[2]).mulE(i[3]),x=n[3].mulE(i[1]).mulE(i[2]).mulE(i[2]).subE(f).mul(36);o[2]=u.addE(d).addE(p).addE(x);const y=n[2].mulE(n[3]).mulE(n[3]).mulE(i[1]).subE(n[1].mulE(i[2]).mulE(i[3]).mulE(i[3])).mul(360),P=n[2].mulE(i[2]).mulE(n[2].mulE(n[3]).subE(i[2].mulE(i[3]))).addE(n[3].mulE(i[2]).mulE(i[2]).mulE(i[2])).subE(n[2].mulE(n[2]).mulE(n[2]).mulE(i[3])).mul(24),C=n[2].mulE(i[1]).mulE(i[3]).mulE(i[3]).subE(n[1].mulE(n[3]).mulE(n[3]).mulE(i[2])).mul(72),E=n[3].mulE(i[3]).mulE(i[1].mulE(i[2]).subE(n[1].mulE(n[2]))).mul(288);o[3]=y.addE(P).addE(C).addE(E),o[4]=i[3].mulE(i[3]).addE(n[3].mulE(n[3])).mulE(n[3].mulE(i[1]).subE(n[1].mulE(i[3]))).mul(270).addE(n[3].mulE(i[2]).subE(n[2].mulE(i[3]))).mulE(n[2].mulE(n[3]).addE(i[2].mulE(i[3]))).mul(180),o[5]=n[3].mulE(i[2]).subE(n[2].mulE(i[3])).mulE(n[3].mulE(n[3]).addE(i[3].mulE(i[3]))).mul(216);const S=T(v,5),I=hi(o,5,new r(0,1),!1,S,5);if(I>0){let n=Math.abs(t.getCurvature(0)),i=0;const r=Math.abs(t.getCurvature(1));(r>n||!Number.isFinite(r))&&(i=1);for(let e=0;e<I;e++){const s=Math.abs(t.getCurvature(S[e].value()));t.getCoord2D(S[e].value()),(s>n||!Number.isFinite(s))&&(n=s,i=S[e].value())}if((!Number.isFinite(n)||1/n<e)&&!M(i,0,1)){const e=t.getCoord2D(i);if(!e.equals(t.getStartXY())&&!e.equals(t.getEndXY()))return s.push(i),1}}if(!t.isClosed()){const e=[0,0],n=Xo(t,e,!1);for(let t=0;t<n;t++)e[t]>0&&e[t]<1&&s.push(e[t]);return s.length}return 0}(this,t,e)}ensureXYMonotone(){return po(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new Ps,o=T(l,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new l;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=T(l,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformPoints2D(t.m_cp,2,t.m_cp):(st(e,s,1/3,t.m_cp[0]),st(e,s,2/3,t.m_cp[1])),t.changeEndPoints2D(e,s),i&&po(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp[0].assign(this.m_cp[0]),e.m_cp[1].assign(this.m_cp[1]),ho(e,ao(this))}reverseImpl(){this.m_cp[1]=p(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(t){const e=t;return!!this.m_cp[0].equals(e.m_cp[0])&&!!this.m_cp[1].equals(e.m_cp[1])}equalsImplTol(t,e){const s=t;return!!this.m_cp[0].isEqualPoint2D(s.m_cp[0],e)&&!!this.m_cp[1].isEqualPoint2D(s.m_cp[1],e)}swapImpl(t){const e=t;var s;e.m_cp[0]=p(this.m_cp[0],this.m_cp[0]=e.m_cp[0]),e.m_cp[1]=p(this.m_cp[1],this.m_cp[1]=e.m_cp[1]),(s=e).m_cachedValues=p(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){mo(this)}isIntersecting(t,e,s){return 0!==om(!1,this,t,e,s)}intersect(t,e,s,n,i){return lm(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,o){const a=new Vs;if(Go(t,r.unit(),a),a.inflate(o),!a.isIntersectingPoint2D(e))return 0;const h=oo(t);let m=0,l=h.specialPoints[0];const u=[];for(let s=1,i=h.specialPoints.length;s<i;++s){const i=h.specialPoints[s],r=lo(t,e,l,i);if(0===u.length)u.push(r);else if(r.t===r.tmin)n(u.at(-1).d<=r.d),u.at(-1).tmax=r.tmax;else if(u.at(-1).t===u.at(-1).tmax){n(u.at(-1).d>=r.d);const t=u.at(-1).tmin;u[u.length-1]=r,u.at(-1).tmin=t}else u.push(r);l=i}for(const t of u)if(t.d<=o){const e=t.t;s?(m>=s.length&&i(""),s[m]=e,m++):m++}return m}(this,t,e,s)}endPointModified(){mo(this)}clearEndPointModified(){}}jo.type=o.enumBezier;class Zo{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}function Qo(t,e,s,i,r,o,a,h){for(;;){const m=l.distance(e[0],e[2]),u=l.distance(e[0],e[1])+l.distance(e[1],e[2]);if(u-m<=r+i*u)return t+C(m,u,.5);const c=T(l,4),g=t=>(oa(e,s,1,t,c),c[1].length());if(0===a&&h<8){n(h<8);let m=g(0),c=g(1);o[0]+=2,m>c&&(c=p(m,m=c),e[2]=p(e[0],e[0]=e[2]),s[2]=p(s[0],s[0]=s[2]));let d=m/(m+c),_=1,f=u;for(;d<1/32&&f>=r+i*f;){_/=4;const t=g(_);o[0]++,d=m/(t+m);const n=new l;if(Ya(e,s,.5*_,n),f=l.distance(n,e[0]),f<=r){const t=new l;Ya(e,s,_,t),f+=l.distance(t,n)}}if(1!==_){const n=T(l,3),m=[0,0,0];Sa(e,s,_,e,s,n,m),t=Qo(t,n,m,i,r,o,0,h+1),a++,h++;continue}}let d=!1;const _=8;o[0]+=_;const f=Dr(_,g,0,1),x=16;o[0]+=x;const y=Dr(x,g,0,1);if(d=Math.abs(f-y)>r+i*u,!d)return t+y;if(a<8&&h<9){const n=T(l,3),m=[0,0,0];Sa(e,s,.5,e,s,n,m),t=Qo(t,n,m,i,r,o,a+1,h+1),a++,h++;continue}const P=32;o[0]+=P;const E=Dr(P,g,0,1);if(d=Math.abs(y-E)>r+i*u,!d)return t+E;const S=64;o[0]+=S;const v=Dr(S,g,0,1);if(d=Math.abs(E-v)>r+i*u,!d)return t+v;const I=128;o[0]+=I;const b=Dr(I,g,0,1);return d=Math.abs(v-b)>r+i*u,t+b}}function Ko(t,e,s,n,i){if(s===e)return 0;const r=T(l,3),o=[0,0,0];t.queryControlPoints(r),t.queryWeights(o);const a=[0,0,0],h=T(l,3);return va(r,o,e,s,h,a),Qo(0,h,a,n,i,[0],0,0)}class Jo{constructor(t,e,s){this.controlPoints=D(t,3),this.weights=[0,0,0],g(this.weights,e,0,0,3),this.point=s.clone()}getMaxDerivative(){return 3}getValue(t,e){if(0===t){const t=new l;Ya(this.controlPoints,this.weights,e,t);const s=T(l,4);return oa(this.controlPoints,this.weights,1,e,s),2*t.sub(this.point).dotProduct(s[1])}if(1===t){const t=new l;Ya(this.controlPoints,this.weights,e,t);const s=T(l,4);return oa(this.controlPoints,this.weights,2,e,s),2*(t.sub(this.point).dotProduct(s[2])+s[1].dotProduct(s[1]))}if(2===t){const t=new l;Ya(this.controlPoints,this.weights,e,t);const s=T(l,4);return oa(this.controlPoints,this.weights,3,e,s),2*(t.sub(this.point).dotProduct(s[3])+3*s[1].dotProduct(s[2]))}return 0}getError(t){return n(0),0}}function $o(t,e,s,n){const i={tmin:0,tmax:0,t:0,d:0,pt:l.getNAN().clone()},o=h(18,Number.NaN),a=T(l,3);t.queryControlPoints(a),a[2].subThis(e),a[1].subThis(e),a[0].subThis(e);const m=[0,0,0];t.queryWeights(m);const u=[1,ka(m),1],c=La(m,s),g=La(m,n),d=Jn(new Jo(a,u,new l(0,0)),r.construct(c,g),18,o);Ya(a,u,c,i.pt),i.t=c,i.d=l.distance(i.pt,new l(0,0));const _=new l;Ya(a,u,g,_);const p=l.distance(_,new l(0,0));p<i.d&&(i.d=p,i.t=g,i.pt.assign(_));for(let t=0;t<d;t++){Ya(a,u,o[t],_);const e=l.distance(_,new l(0,0));e<i.d&&(i.d=e,i.t=Ra(m,o[t]),i.pt.assign(_))}return i}function ta(t,e,s,n,i){let r=!0;const o=T(l,4),a=ki(5,e,s,n,i,e=>(ra(t,1,e,o),(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*o[1].length()));r=!1;const h=ki(5,e,s,n,i,e=>(ra(t,1,e,o),(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*o[1].length()));return new l(a,h)}function ea(t){t.m_cachedValues=null}function sa(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new Zo,s=T(l,3);t.queryControlPoints(s);const n=[0,0,0];return t.queryWeights(n),na(s,n,e.specialPoints),_a(t,e),e}function na(t,e,s){if(0===e[1])return s.length=0,s.push(0),void s.push(1);const n=T(v,8);n[0].set(0);let i=1;{const s=new v(t[1].x).subThis(t[0].x).mulThis(e[1]).mulThis(e[0]),o=new v(t[2].x).subThis(t[0].x).mulThis(e[2]).mulThis(e[0]),a=s.subE(o).addThisE(new v(t[2].x).subThis(t[1].x).mulThis(e[2]).mulThis(e[1]));o.subThisE(s.mul(2));const h=T(v,2);let m=oi(a,o,s,new r(0,1),!1,h);m<0&&(m=0);for(let t=0;t<m;t++)M(h[t].value(),0,1)||(n[i]=h[t],i++)}{const s=new v(t[1].y).subThis(t[0].y).mulThis(e[1]).mulThis(e[0]),o=new v(t[2].y).subThis(t[0].y).mulThis(e[2]).mulThis(e[0]),a=s.subE(o).addThisE(new v(t[2].y).subThis(t[1].y).mulThis(e[2]).mulThis(e[1]));o.subThisE(s.mul(2));const h=T(v,2);let m=oi(a,o,s,new r(0,1),!1,h);m<0&&(m=0);for(let t=0;t<m;t++)M(h[t].value(),0,1)||(n[i]=h[t],i++)}if(n[i].set(1),i++,i>2){_(n,0,i,(t,e)=>at(t.value(),e.value()));let t=0,e=n[0].value(),s=1;for(let r=1;r<i;r++)n[r].eq(n[r-1])?(e+=n[r].value(),s++):(s>1&&(e/=s,n[t].set(e)),t++,n[t]=n[r],e=n[r].value(),s=1);t++,i=t}n[0].set(0),n[i-1].set(1),s.length=i;for(let t=0;t<i;t++)s[t]=n[t].value()}function ia(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+ia(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=sa(t);if(n&&!Number.isNaN(i.length))return i.length;const r=ga(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let s=1,n=i.specialPointsCount();s<n;s++){const n=i.specialPoints[s];if(a+=Ko(t,h,Math.min(e,n),o,r),e<=n)break;h=n}return n&&(i.length=a),a}function ra(t,e,s,n){const i=T(l,3);t.queryControlPoints(i);const r=[0,0,0];t.queryWeights(r),oa(i,r,e,s,n)}function oa(t,e,s,i,r){const o=[t[0],t[1],t[2]],a=[e[0],e[1],e[2]],h=T(l,4);!function(t,e,s,i,r){n(s>0);const o=[t[0].clone(),t[1].clone(),t[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThis(o[0]);o[0].setCoords(0,0)}const a=aa(o,e,0,i),h=ma(e,0,i),m=a.divide(h);if(r[0].assign(m),0===s)return;const l=[e[1]*e[0],e[2]*e[0]*.5,e[1]*e[2]],u=[t[1].sub(t[0]),t[2].sub(t[0]),t[2].sub(t[1])],c=h*h,g=aa(u,l,0,i).mul(2).divide(c);if(r[1].assign(g),1===s)return;const d=ma(e,1,i),_=2*h*d,p=aa(u,l,1,i).mul(2).sub(g.mul(_)).divide(c);if(r[2].assign(p),2===s)return;const f=aa(u,l,2,i).mul(2),x=2*(d*d+h*ma(e,2,i)),y=f.sub(p.mul(_).mul(2)).sub(g.mul(x)).divide(c);r[3].assign(y),3!==s&&P("")}(o,a,s,i,h);for(let t=0;t<=s;t++)r[t].setCoords(h[t].x,h[t].y)}function aa(t,e,s,n){if(0===s){if(n<=.5){const s=new l;nt(2,t[0].mul(e[0]),t[1].mul(e[1]),n,s);const i=new l;nt(2,t[1].mul(e[1]),t[2].mul(e[2]),n,i);const r=new l;return nt(2,s,i,n,r),r}{const s=new l;it(2,t[0].mul(e[0]),t[1].mul(e[1]),n,s);const i=new l;it(2,t[1].mul(e[1]),t[2].mul(e[2]),n,i);const r=new l;return it(2,s,i,n,r),r}}if(1===s){const s=t[1].mul(e[1]),i=s.sub(t[0].mul(e[0])).mul(1-n).add(t[2].mul(e[2]).sub(s).mul(n));return i.mulThis(2),i}if(2===s){const s=t[1].mul(e[1]),n=t[2].mul(e[2]).sub(s).sub(s.sub(t[0].mul(e[0])));return n.mulThis(2),n}P("")}function ha(t,e,s,n){if(n.toDouble()<=.5){const s=new Rs;J(2,t[0].mulE(e[0]),t[1].mulE(e[1]),n,s);const i=new Rs;J(2,t[1].mulE(e[1]),t[2].mulE(e[2]),n,i);const r=new Rs;return J(2,s,i,n,r),r}{const s=new Rs;$(2,t[0].mulE(e[0]),t[1].mulE(e[1]),n,s);const i=new Rs;$(2,t[1].mulE(e[1]),t[2].mulE(e[2]),n,i);const r=new Rs;return $(2,s,i,n,r),r}}function ma(t,e,s){if(0===e){const e=C(t[0],t[1],s),n=C(t[1],t[2],s);return C(e,n,s)}return 1===e?2*((1-s)*(t[1]-t[0])+(t[2]-t[1])*s):2===e?2*(t[2]-t[1]-(t[1]-t[0])):void P("")}function la(t,e,s){const n=A(s,0,1),i=T(l,4);if(oa(t,e,3,n,i),i[1].isZero()){if(i[2].isZero())return i[3];{const t=i[2].clone();return 1===n&&t.negateThis(),t}}return i[1]}class ua{constructor(t,e){this.len=0,this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-ia(this.b,e,!1):0}getError(t){return n(0),0}}function ca(t){const e=T(l,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),function(t,e){const s=ka(e);if(1===s)return er(t);if(0===s)return 0;const i=[new l(0,0),t[1].sub(t[0]),t[2].sub(t[0])],r=i[1].crossProduct(i[2]);if(s<1){n(s>0);const t=1-s;let e;if(t<.01)e=-1/3+t*(2/15+t*(3/35+t*(16/315+t*(20/693+t*(16/1001+t*(56/6435))))));else{const n=t*(1+s),i=Math.atan2(Math.sqrt(t),Math.sqrt(1+s));e=s*(.5*s-Gt(n)*i)/n}return r*e}{const t=(s-1)*(s+1);return.25*s/Math.pow(t,1.5)*(-2*s*Math.sqrt(t)*r-4*i[1].y*i[2].x*Math.atanh(Math.sqrt((s-1)/(s+1)))-i[1].x*i[2].y*Math.log(2*s*(s-Math.sqrt(t))-1))}}(e,s)}function ga(t){var e;return e=t.calculateUpperLength2D(),256*G()*e}function da(t){return t.m_cachedValues}function _a(t,e){t.m_cachedValues=e}function pa(t,e,s,n,i){const o=T(l,3);t.queryControlPoints(o);const a=[0,0,0];t.queryWeights(a);const h=[0];return 1===fa(o,a,e,r.unit(),n,i,1,h)?h[0]:Number.NaN}function fa(t,e,s,i,o,a,h,m){rt(r.unit().contains(i)&&h>0,""),(a<0||Number.isNaN(a))&&(a=Number.MAX_VALUE);const u=new Array(3);for(let e=0;e<3;++e)u[e]=t[e].sub(s);const c=ka(e),g=Hs.constructPoint2D(u[0]),d=Hs.constructPoint2D(u[1]),_=Hs.constructPoint2D(u[2]),p=y.constructDouble(c),f=p.clone();f.ldexpThis(1);const x=g.dotProduct(d.sub(g)).mul(p),P=p.mul(p.addDouble(2)),C=_.sub(d.mul(P.ldexp(1))),E=d.sqrLength().mul(p.mul(p).ldexp(1)).add(g.sqrLength().mul(p.ldexp(2).subDouble(1))).add(g.dotProduct(C)),S=_.sub(d.mul(f)).add(g.mul(f.subDouble(1))),v=d.mul(p).sub(g).dotProduct(S).mulDouble(3),I=d.dotProduct(_).mul(p.subDouble(3).mul(p)).ldexp(1),b=d.sqrLength().mul(p.mul(p).ldexp(2)),w=g.sqrLength().mul(p.ldexp(2).subDouble(3)),D=g.dotProduct(_.sub(d.mul(p.mulDouble(3).subDouble(1)).mul(p))).ldexp(1),N=_.sqrLength().addThis(I).addThis(b).addThis(w).addThis(D),A=g.add(_).sub(d.mul(f)),M=p.subDouble(1),G=_.sub(g).dotProduct(A).mul(M),q=new l(0,0),F=[];let V=new l;Ya(u,e,i.vmin,V);let Y=l.distance(V,q);if(Y<=a&&F.push(new l(i.vmin,Y)),i.vmin!==i.vmax&&(Ya(u,e,i.vmax,V),Y=l.distance(V,q),Y<=a&&F.push(new l(i.vmax,Y))),i.width()>0){const t=u[2].isZero(),s=T(y,4),n=wi(G,N,v,E,x,58,i,t,s);for(let t=0;t<n;t++){if(!i.containsExclusiveCoordinate(s[t].toDouble()))continue;let n=s[t].toDouble();n=Ra(e,n);const r=new l;Ya(u,e,n,r),Y=l.distance(r,q),Y<=a&&F.push(new l(n,Y))}}if(o){n(i.equals(r.unit()));{Ya(u,e,-1,V,!0);const t=new l;Ya(u,e,0,t);const s=new pm({start:V,end:t}),n=s.getClosestCoordinate(q,!0);n<1&&(V=s.getCoord2D(n),Y=l.distance(V,q),Y<=a&&F.push(new l(n-1,Y)))}{Ya(u,e,2,V,!0);const t=new l;Ya(u,e,i.vmax,t);const s=new pm({start:t,end:V}),n=s.getClosestCoordinate(q,!0);n>0&&(V=s.getCoord2D(n),Y=l.distance(V,q),Y<=a&&F.push(new l(1+n,Y)))}}if(!F.length)return 0;F.sort((t,e)=>t.compare(e));let X=0;const k=F[0].x;if(m[X++]=k,X<h){const t=Be(u,4,!1).total(),e=F[0].y;for(let s=1,n=F.length;s<n;s++)if(F[s].y>e+t){F.length=s;break}F.sort((t,e)=>at(t.x,e.x)),X=0,m[X++]=F[0].x;for(let t=1,e=F.length;t<e;t++)F[t].x!==m[X-1]&&X<h&&(m[X++]=F[t].x)}return X}function xa(t,e,s){const n=T(l,3);t.queryControlPoints(n);const i=[0,0,0];t.queryWeights(i),ya(n,i,e,s)}function ya(t,e,s,n){if(s.equalsRange(0,1))return void n.setFromPoints(t,3);const i=T(l,3);va(t,e,s.vmin,s.vmax,i,[0,0,0]),n.setFromPoints(i,3)}function Pa(t){const e=S(t[0].y,t[1].y),s=S(t[1].y,t[2].y);if(e>=0&&s>=0||e<=0&&s<=0){const e=S(t[0].x,t[1].x),s=S(t[1].x,t[2].x);if(e>=0&&s>=0||e<=0&&s<=0)return!0}return!1}function Ca(t){const e=T(l,3);t.queryControlPoints(e);const s=Ea(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function Ea(t){let e=!1;for(let s=0;s<2;s++){const n=S(t[0][s],t[2][s]);n>0?(S(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),S(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):n<0?(S(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),S(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function Sa(t,e,s,i,r,o,a){n(s>=0&&s<=1&&i!==o&&r!==a),n(e[0]>0&&e[2]>0&&e[1]>=0);const h=[1,ka(e),1],m=La(e,s),l=D(t,3),u=T(Se,3);qa(l,h,u);const c=T(Se,3),g=T(Se,3);Ha(u,m,i?c:null,o?g:null),Ba(e,s,r,a);const d=Pa(l);if(i){for(let t=0;t<3;++t)Va(c[t],i[t]);za(l,i),d&&Ea(i)}if(o){for(let t=0;t<3;++t)Va(g[t],o[t]);za(l,o),d&&Ea(o)}}function va(t,e,s,i,r,o){if(n(s>=0&&i<=1&&s<=i),s===i){const n=new l,i=Fa(t,e,s,n);return Ua(t,n),r[0].assign(n),r[1].assign(n),r[2].assign(n),o[0]=i,o[1]=i,void(o[2]=i)}if(0===s&&1===i)return r[0].assign(t[0]),r[1].assign(t[1]),r[2].assign(t[2]),o[0]=e[0],o[1]=e[1],void(o[2]=e[2]);const a=T(Se,3);{const n=[1,ka(e),1],r=La(e,s),o=La(e,i);qa(t,n,a),Ha(a,o,a,null),Ha(a,r>=o?1:r/o,null,a)}const h=[0,0,0];Ba(e,i,h,null),Ba(h,s/i,null,h);const m=Pa(t),u=T(l,3);Va(a[1],u[1]),Ya(t,e,s,u[0]),Ya(t,e,i,u[2]),za(t,u);for(let t=0;t<3;++t)r[t].assign(u[t]),o[t]=h[t];m&&Ea(r)}function Ia(t,e,s){const n=ka(e),i=[1,n,1],o=4*n/(3*(1+n));s[0].assign(t[0]),s[3].assign(t[2]),st(t[0],t[1],o,s[1]),st(t[2],t[1],o,s[2]),new jo({cp:s}),new pi({points:t,weight:n});let a=0,h=.1,m=0;for(let e=0;e<9;e++,h+=.1){const e=new l;Ya(t,i,h,e);const n=new l;Co(s,h,n);const r=l.sqrDistance(e,n);r>a&&(a=r,m=h)}{const e=new l;Ya(t,i,m,e);const n=[0];Vo(s,e,r.unit(),!1,-1,1,n);const o=new l;return Co(s,n[0],o),a=l.sqrDistance(e,o),Math.sqrt(a)}}function ba(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==Ta(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function wa(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==Na(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Da(t,e,s,n,i){if(i){if(0!==hm(e,s))return t?4:2}else if(zs(e,s))return 1;return 0!==Ma(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Ta(t,e,s,i,o,a,m,u,c,g){if(null!==o&&(o.length=0),null!==a&&(a.length=0),null!==i&&(i.length=0),s.isDegenerate(0)){const t=[0,0],n=e.intersectPoint(s.getStartXY(),t,m);if(n>0){if(null!==o)for(let e=0;e<n;e++)o.push(t[e]);if(null!=a)for(let t=0;t<n;t++)a.push(0);if(null!=i)for(let s=0;s<n;s++){const n=new l;e.queryCoord2D(t[s],n),i.push(n)}}return n}const d=mn(e,s);if(m=Math.max(m,d),e.isDegenerateToLineHelper(d)){const t=new pm({start:e.getStartXY(),end:e.getEndXY()}),n=wn(t,s,i,o,a,m,u,g);if(o)for(let s=0;s<n;++s){const n=t.getCoord2D(o[s]);o[s]=e.getClosestCoordinate(n,!1)}return n}if(ln(e,s,m))return 0;const _=T(l,3);e.queryControlPoints(_);const p=[0,0,0];e.queryWeights(p);const f=[1,ka(p),1],x=s.getEndXY().sub(s.getStartXY()),y=x.clone();y.leftPerpendicularThis();const P=_[0].clone(),C=_[1].clone(),E=_[2].clone(),S=C.sub(P),v=E.sub(P),I=E.sub(C),b=f[0],w=f[1],D=f[2],N=b*w,A=b*D,M=w*D,G=S.dotProduct(y)*N,q=v.dotProduct(y)*A;let F=G,V=q-2*G,Y=I.dotProduct(y)*M+q-q;const X=h(13,Number.NaN),k=h(13,Number.NaN);let R=$n(Y,V,F,r.unit(),!1,X);R<0&&(X[0]=0,X[1]=1,R=2);let L=0;for(let t=0,e=L;t<R;++t){const n=new l;Ya(_,f,X[t+e],n),k[L]=s.getClosestCoordinate(n,!1),l.distance(n,s.getCoord2D(k[L]))<=m&&(X[L]=X[t+e],L++)}const H=T(l,3),B=T(l,3);if(e.queryControlPoints(B),B[0].subThis(s.getStartXY()),B[1].subThis(s.getStartXY()),B[2].subThis(s.getStartXY()),function(t,e,s,n=!1){const i=T(l,3);n?(i[0].setCoordsPoint2D(t[0]),i[1].setCoordsPoint2D(t[1]),i[1].subThis(i[0]),i[2].setCoordsPoint2D(t[2]),i[2].subThis(i[0]),i[0].setCoords(0,0)):(i[0].setCoordsPoint2D(t[0]),i[1].setCoordsPoint2D(t[1]),i[2].setCoordsPoint2D(t[2])),i[0].mulThis(e[0]),i[1].mulThis(e[1]),i[2].mulThis(e[2]),s[1].setCoords(i[1].x-i[0].x,i[1].y-i[0].y),s[2].setCoordsPoint2D(i[2].sub(i[1])),s[2].subThis(s[1]),s[1].x*=2,s[1].y*=2,s[0].setCoordsPoint2D(i[0])}(B,f,H,!1),Math.abs(x.x)>=Math.abs(x.y)){const t=x.y/x.x;Y=H[2].y-H[2].x*t,V=H[1].y-H[1].x*t,F=H[0].y-H[0].x*t}else{const t=x.x/x.y;Y=H[2].x-H[2].y*t,V=H[1].x-H[1].y*t,F=H[0].x-H[0].y*t}const U=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),z=[0,0];R=$n(Y,V,F,r.unit(),U,z);for(let t=0,e=L;t<R;++t){X[t+e]=z[t];const n=new l;Ya(_,f,X[t+e],n),k[L]=s.getClosestCoordinate(n,!1),l.distance(n,s.getCoord2D(k[L]))<=m&&(X[L]=X[t+e],L++)}n(L<X.length+4);for(let t=0;t<L;t++)X[t]=Ra(p,X[t]);R=e.intersectPoint(s.getStartXY(),z,m);for(let t=0;t<R;t++)X[L]=z[t],k[L++]=0;R=e.intersectPoint(s.getEndXY(),z,m);for(let t=0;t<R;t++)X[L]=z[t],k[L++]=1;R=s.intersectPoint(e.getStartXY(),z,m);for(let t=0;t<R;t++)k[L]=z[t],X[L++]=0;R=s.intersectPoint(e.getEndXY(),z,m);for(let t=0;t<R;t++)k[L]=z[t],X[L++]=1;return 0===L?0:cm(t,e,s,X,k,L,i,o,a,m,u,0,g)}function Na(t,e,s,n,i,o,a,h,m,u){if(qh(s))return Ta(t,e,new pm({start:s.getStartXY(),end:s.getEndXY()}),n,i,o,a,h,0,u);const c=mn(e,s);if(ln(e,s,a=Math.max(a,c)))return 0;const g=[],d=[],_=T(l,4);{e.queryControlPoints(_);const t=T(l,4),n=new Ps;s.canonicToWorldTransformation(n);const i=new Ps;i.setInvert(n),i.transformPoints2D(_,4,t);const o=T(y,3),m=T(y,3),u=T(y,3),c=[0,0,0];e.queryWeights(c),Ga(t,c,o,m,u);const p=T(y,3);p[0].setDouble(s.getSemiMinorAxis()),p[0].sqrThis(),p[1].setDouble(s.getSemiMajorAxis()),p[1].sqrThis(),p[2].setThis(p[0]),p[2].mulThis(p[1]),p[2].negateThis();const f=Si(o,2,m,2,u,2,p,0,r.unit(),r.unit(),g,h);if(f>0){let t=0;for(let n=0;n<f;n++){const i=new l;e.queryCoord2D(g[n],i);const r=s.getClosestCoordinate(i,!1),o=new l;s.queryCoord2D(r,o),l.distance(i,o)<=a&&(g[t]=g[n],d.push(r),t++)}g.length=t}}const p=[0,1];for(let t=0;t<2;t++){const n=0===t?s.getStartXY():s.getEndXY(),i=pa(e,n,r.unit(),!1,-1),o=new l;e.queryCoord2D(i,o),l.distance(n,o)<=a&&(g.push(i),d.push(p[t]))}for(let t=0;t<2;t++){const e=[0,3];{const n=s.getClosestCoordinate(_[e[t]],!1),i=new l;s.queryCoord2D(n,i),l.distance(_[e[t]],i)<=a&&(g.push(p[t]),d.push(n))}}return cm(t,e,s,g,d,g.length,n,i,o,a,h,0,u)}function Aa(t,e,s,i,o,a,m,u,c,g){const d=T(l,3);e.queryControlPoints(d);const _=T(l,3);if(s.queryControlPoints(_),un(d,_,3)<0)return Aa(t,s,e,i,a,o,m,u,c,!g);const p=mn(e,s);if(e.isDegenerateToLineHelper(p)){const n=new pm({start:e.getStartXY(),end:e.getEndXY()}),r=Ta(t,s,n,i,a,o,m,u,0,!g);if(o)for(let t=0;t<r;++t){const s=n.getCoord2D(o[t]);o[t]=e.getClosestCoordinate(s,!1)}return r}if(s.isDegenerateToLineHelper(p)){const n=new pm({start:s.getStartXY(),end:s.getEndXY()}),r=Ta(t,e,n,i,o,a,m,u,0,g);if(a)for(let t=0;t<r;++t){const e=n.getCoord2D(a[t]);a[t]=s.getClosestCoordinate(e,!1)}return r}if(ln(e,s,m=Math.max(m,p)))return 0;const f=h(3,Number.NaN);e.queryWeights(f);const x=h(3,Number.NaN);s.queryWeights(x);const P=[1,ka(f),1],C=[1,ka(x),1],E=new r(0,1),S=new r(0,1);{const t=Vs.constructEmpty();ya(d,P,new r(0,1),t);const e=Vs.constructEmpty();ya(_,C,new r(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*m),e.inflate(3*m),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Xa(d,P,t,E),Xa(_,C,t,S),E.isEmpty()||S.isEmpty())return 0;va(d,P,E.vmin,E.vmax,d,P),va(_,C,S.vmin,S.vmax,_,C)}}const v=dm(d,2,_,2,m);if(0===v)return 0;const I=[],b=[];if(-1===v){const t=T(y,3),e=T(y,3),s=T(y,3);Ga(d,P,t,e,s);const n=T(y,3),i=T(y,3),o=T(y,3);Ga(_,C,n,i,o);const a=[],h=[],c=Ei(t,2,e,2,s,2,n,2,i,2,o,2,0,r.unit(),r.unit(),a,h,u,0,g);if(c>0)for(let t=0;t<c;t++){const e=new l;Ya(_,C,h[t],e);const s=new l;Ya(d,P,a[t],s),l.distance(s,e)<=m&&(I.push(a[t]),b.push(h[t]))}}for(let t=0;t<2;t++){let e,s,i;0===t?(e=d,s=_,i=C):(e=_,s=d,i=P);for(let o=0;o<2;o++){const a=0===o?0:e.length-1,h=new l,u=[0],c=fa(s,i,e[a],r.unit(),!1,-1,1,u);n(1===c),Ya(s,i,u[0],h),l.distance(e[a],h)<=m&&(0===t?(I.push(0===a?0:1),b.push(u[0])):(b.push(0===a?0:1),I.push(u[0])))}}if(0===I.length)return 0;if(!E.equalsRange(0,1))for(let t=0;t<I.length;++t)I[t]=pi.recalculateParentT(E.vmin,E.vmax,I[t]);if(!S.equalsRange(0,1))for(let t=0;t<b.length;++t)b[t]=pi.recalculateParentT(S.vmin,S.vmax,b[t]);for(let t=0;t<I.length;++t)I[t]=Ra(f,I[t]);for(let t=0;t<b.length;++t)b[t]=Ra(x,b[t]);return cm(t,e,s,I,b,I.length,i,o,a,m,u,0,g)}function Ma(t,e,s,n,i,o,a,h,m,u){if(e.isLine())return dr(t,s,new pm({start:e.getStartXY(),end:e.getEndXY()}),n,o,i,a,h,0,!u);if(s.isLine())return Ta(t,e,new pm({start:s.getStartXY(),end:s.getEndXY()}),n,i,o,a,h,0,u);const c=mn(e,s);if(ln(e,s,a=Math.max(a,c)))return 0;const g=T(l,3);e.queryControlPoints(g);const d=T(l,3);s.queryControlPoints(d);const _=dm(g,2,d,2,a);if(0===_)return 0;const p=[],f=[];if(-1===_){const t=T(y,3),n=T(y,3),i=T(y,3),o=[0,0,0];e.queryWeights(o),Ga(g,o,t,n,i);const m=T(Hs,3);xr(d,m);const c=Ei(t,2,n,2,i,2,[m[0].x,m[1].x,m[2].x],2,[m[0].y,m[1].y,m[2].y],2,null,0,0,r.unit(),r.unit(),p,f,h,0,u);if(c>0){let t=0;for(let n=0;n<c;n++){const i=new l;s.queryCoord2D(f[n],i);const r=new l;e.queryCoord2D(p[n],r),l.distance(r,i)<=a&&(p[t]=p[n],f[t]=f[n],t++)}p.length=t,f.length=t}}for(let t=0;t<2;t++){let n;n=0===t?g:d;for(let i=0;i<2;i++){const o=0===i?0:n.length-1;let h;const m=new l;0===t?(h=ir(s,n[o],r.unit(),!1),s.queryCoord2D(h,m)):(h=pa(e,n[o],r.unit(),!1,-1),e.queryCoord2D(h,m)),l.distance(n[o],m)<=a&&(0===t?(p.push(0===o?0:1),f.push(h)):(f.push(0===o?0:1),p.push(h)))}}return cm(t,e,s,p,f,p.length,n,i,o,a,h,0,u)}function Ga(t,e,s,n,i){const r=y.constructDouble(e[0]),o=y.constructDouble(e[1]),a=y.constructDouble(e[2]);s[0].setDouble(t[0].x),s[0].mulThis(r),s[1].setDouble(t[1].x),s[1].mulThis(o),s[2].setDouble(t[2].x),s[2].mulThis(a),s[2].subThis(s[1]),s[1].subThis(s[0]),s[2].subThis(s[1]),s[1].ldexpThis(1),n[0].setDouble(t[0].y),n[0].mulThis(r),n[1].setDouble(t[1].y),n[1].mulThis(o),n[2].setDouble(t[2].y),n[2].mulThis(a),n[2].subThis(n[1]),n[1].subThis(n[0]),n[2].subThis(n[1]),n[1].ldexpThis(1),i[0].setDouble(e[0]),i[1].setDouble(e[1]),i[2].setThis(i[1]),i[2].ldexpThis(1),i[2].negateThis(),i[2].addThis(i[0]),i[2].addDoubleThis(e[2]),i[1].subThis(i[0]),i[1].ldexpThis(1)}function qa(t,e,s){for(let n=0;n<3;++n)s[n].setCoordsPoint2DZ(t[n].mul(e[n]),e[n])}function Fa(t,e,s,n){if(0===s)return n.assign(t[0]),e[0];if(1===s)return n.assign(t[2]),e[2];const i=[t[0].x*e[0],t[1].x*e[1],t[2].x*e[2]],r=[t[0].y*e[0],t[1].y*e[1],t[2].y*e[2]],o=[e[0],e[1],e[2]],a=s;let h,m,l;if(s<=.5){const t=k(i[0],i[1],a),e=k(i[1],i[2],a);h=C(t,e,a);const s=k(r[0],r[1],a),n=k(r[1],r[2],a);m=C(s,n,a);const u=k(o[0],o[1],a),c=k(o[1],o[2],a);l=k(u,c,a)}else{const t=R(i[0],i[1],a),e=R(i[1],i[2],a);h=R(t,e,a);const s=R(r[0],r[1],a),n=R(r[1],r[2],a);m=R(s,n,a);const u=R(o[0],o[1],a),c=R(o[1],o[2],a);l=R(u,c,a)}return h/=l,m/=l,n.setCoords(h,m),Ua(t,n),l}function Va(t,e){return e.setCoords(t.x/t.z,t.y/t.z),t.z}function Ya(t,e,s,n,i){if(i){if(s<0)return void yn(new pm({start:t[0],end:t[0].add(la(t,e,0).getUnitVector())}),s,n);if(s>1)return void yn(new pm({start:t[2],end:t[2].add(la(t,e,1).getUnitVector())}),s-1,n)}Fa(t,e,s,n)}function Xa(t,e,s,n){n.setEmpty();const i=[];i.push(new r(0,1));const o=.5*Math.max(s.width(),s.height());for(;i.length;){const a=i.at(-1);i.pop();const h=new Vs;if(ya(t,e,a,h),h.isIntersectingW(s)){const t=Math.max(h.width(),h.height());if(s.containsW(h)||t<=o||a.width()<1e-12)n.merge(a);else{const t=a.getCenter();i.push(r.construct(a.vmin,t)),i.push(r.construct(t,a.vmax))}}}}function ka(t){return t[1]/Math.sqrt(t[0]*t[2])}function Ra(t,e){const s=Math.sqrt(t[2]/t[0]);return e/C(s,1,e)}function La(t,e){const s=Math.sqrt(t[0]/t[2]);return e/C(s,1,e)}function Ha(t,e,s,i){n(e>=0&&e<=1),(new Se).setCoordsPoint3D(t[0]),(new Se).setCoordsPoint3D(t[1]),(new Se).setCoordsPoint3D(t[2]);const r=new Se,o=new Se,a=new Se;H(3,t[0],t[1],e,r),H(3,t[1],t[2],e,o),H(3,r,o,e,a);const h=t[2].clone();s&&(s[0].assign(t[0]),s[1].assign(r),s[2].assign(a)),i&&(i[0].assign(a),i[1].assign(o),i[2].assign(h))}function Ba(t,e,s,i){const r=[t[0],t[1],t[2]];n(e>=0&&e<=1&&s!==i);const o=C(r[0],r[1],e),a=C(r[1],r[2],e),h=C(o,a,e);s&&(s[0]=r[0],s[1]=o,s[2]=h),i&&(i[0]=h,i[1]=a,i[2]=r[2])}function Ua(t,e){const s=r.constructEmpty();s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e.x=A(e.x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e.y=A(e.y,s.vmin,s.vmax)}function za(t,e){const s=new r;s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e[0].x=A(e[0].x,s.vmin,s.vmax),e[1].x=A(e[1].x,s.vmin,s.vmax),e[2].x=A(e[2].x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e[0].y=A(e[0].y,s.vmin,s.vmax),e[1].y=A(e[1].y,s.vmin,s.vmax),e[2].y=A(e[2].y,s.vmin,s.vmax)}const Oa=Et/180,Wa=180/Et;function ja(t){let e=t;return e=function(t){let e=t;return e>=-360&&e<720?(e<0?e+=360:e>=360&&(e-=360),e):(e=Pt(e,360),e<0&&(e+=360),e)}(e),e>180&&(e-=360),e}function Za(t){return t*Oa}function Qa(t){return t*Wa}function Ka(t){const e=ht();let s=t;return s>=-e&&s<2*e?(s<0&&(s+=e),s>=e&&(s-=e),s):(s=Pt(s,e),s<0&&(s+=e),s)}function Ja(t){const e=B();let s=t;return s>-e&&s<=e||(s=Ka(s),s>e&&(s-=ht())),s}function $a(t,e){return ja(e-t)}var th=Ee;class eh extends fn{constructor(t){if(void 0===t||X(t,"vd"))return super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new l(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new l(0,0),void(this.m_bits=0);if(t.copy)return super(t),void(this!==t.copy&&(this.m_center=new l(0,0),this.m_interior=new l(0,0),t.copy.copyToImpl(this)));if(t.move)super(t),this.m_semiMajorAxis=t.move.m_semiMajorAxis,this.m_minorMajorRatio=t.move.m_minorMajorRatio,this.m_rotation=t.move.m_rotation,this.m_cosr=t.move.m_cosr,this.m_sinr=t.move.m_sinr,this.m_center=t.move.m_center.clone(),this.m_sweepAngle=t.move.m_sweepAngle,this.m_startAngle=t.move.m_startAngle,this.m_interior=t.move.m_interior.clone(),this.m_bits=t.move.m_bits,this.m_cachedValues=t.move.m_cachedValues,t.move.m_cachedValues=null;else{if(t.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new l(0,0),this.m_interior=new l(0,0),void this.constructCircularArcThreePoint(t.fromPoint,t.toPoint,t.interiorPoint);if(t.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new l(0,0),this.m_interior=new l(0,0),void this.constructCircleRadius(t.radius,t.center,t.bIsCounterClockwise);if(t.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(t.fromPoint,t.toPoint,t.semiMajorAxis,t.minorMajorRatio,t.axisXRotationRad,t.bBigArc,t.bIsCounterClockwise)}}getBoundary(){return Qn(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}constructCircleRadius(t,e,s=!1){return this.constructEllipse(t,1,e,0,s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(t,e,s=!1){const n=l.distance(t,e);return this.constructEllipticArcEndPointsCenter(e,e,n,1,0,!0,s,t),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(t,e,s=!1){const n=l.lerp(t,e,.5);return this.constructCircleCenterAndPoint(n,t,s),this}constructLineEllipticArc(t,e){return Gh(this,t,e,1),this}constructLineCircularArc(t,e){return Gh(this,t,e,0),this}constructEllipse(t,e,s,n,i=!1){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const r=new l(0,this.m_minorMajorRatio*this.m_semiMajorAxis),o=Math.cos(n),a=Math.sin(n);return r.rotateDirect(o,a),r.addThis(s),this.constructEllipticArcEndPointsCenter(r,r,this.m_semiMajorAxis,this.m_minorMajorRatio,n,!0,i,s),this}inflate(t){if(this.isDegenerateToLine())return;let e=this.getSemiMinorAxis()+t;if(e=e<=0?0:(this.getSemiMajorAxis()+t)/this.getSemiMajorAxis(),this.isCircular()){const t=new Ps;t.setShiftCoords(-this.m_center.x,-this.m_center.y),t.scale(e,e),t.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(t)}else{const t=new Ps;this.canonicToWorldTransformation(t);const s=t.clone();s.invertPreciseThis(),s.scale(e,e),s.multiply(t),this.applyTransformation(s)}}constructEnclosingCircle(t,e,n=!1){return function(t,e,n,i){0===n&&s("construct_enclosing_circle");const r=[0,0,0],o=nh(e,n,r);if(1===o)t.constructCircleRadius(0,e[r[0]],i);else if(2===o){const s=l.lerp(e[r[0]],e[r[1]],.5),n=l.distance(e[r[0]],s),o=l.distance(e[r[1]],s);t.constructCircleRadius(Math.max(n,o),s,i)}else if(3===o){const s=l.calculateCircleCenterFromThreePoints(e[r[0]],e[r[1]],e[r[2]]),n=l.distance(e[r[0]],s),o=l.distance(e[r[1]],s),a=l.distance(e[r[2]],s);t.constructCircleRadius(Math.max(n,o,a),s,i)}else P("unexpected")}(this,t,e,n),this}constructThreePointCircle(t,e,s,n=!1){if(t.equals(e)||e.equals(s)||t.equals(s)){const i=t.clone(),r=e.clone(),o=s.clone();return i.equals(r)&&r.assign(o),this.constructTwoPointCircle(i,r,n)}{const i=l.calculateCircleCenterFromThreePoints(t,e,s);if(!i.isFinite()||!Number.isFinite(l.distance(t,i))){const n=l.distance(t,e),i=l.distance(t,s);this.constructLineCircularArc(t,n>=i?e:s)}return this.constructCircleCenterAndPoint(i,t,n)}}constructCircularArcThreePoint(t,e,s){const n=new v(t.x),i=new v(e.x),r=new v(s.x),o=new v(t.y),a=new v(e.y),h=new v(s.y),m=new v(.5),u=i.subE(n),c=a.subE(o),g=r.subE(n),d=h.subE(o),_=u.mulE(d).subThisE(c.mulE(g));if(_.scaleError(10),_.isZero()){if(!u.isZero()||!c.isZero())return Gh(this,t,e,0),this;{const n=t.clone().addThis(e).mulThis(.5).addThis(s).mulThis(.5),i=s.sub(n).length();this.constructEllipticArcEndPointsCenter(t,e,i,1,0,!0,!1,n),this.m_interior.assign(s)}return this.setProjectionBehavior(0),this}const p=u.sqr().addThisE(c.sqr()).mulThisE(m),f=g.sqr().addThisE(d.sqr()).mulThisE(m),x=p.mulE(d).subThisE(f.mulE(c)),y=u.mulE(f).subThisE(g.mulE(p));x.divThisE(_),y.divThisE(_);const P=x.sqr().addThisE(y.sqr());P.sqrtThis();const C=x.addE(n),E=y.addE(o);let S=t.x-C.value(),I=t.y-E.value();const b=Math.atan2(I,S);S=e.x-C.value(),I=e.y-E.value();const w=Math.atan2(I,S);S=s.x-C.value(),I=s.y-E.value();const D=Math.atan2(I,S);let T=D-2*B();for(;T<b;)T+=2*B();let N=w-2*B();for(;N<T;)N+=2*B();let A=D+2*B();for(;A>b;)A-=2*B();let M,G=w+2*B();for(;G>A;)G-=2*B();M=N-b<b-G?N-b:G-b;const q=new l(C.value(),E.value());return this.constructEllipticArcEndPointsCenter(t,e,P.value(),1,0,Math.abs(M)>B(),M>0,q),this.m_interior.assign(s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(t,e,s,n){return this.constructEllipticArcGeneral(t,1,e,s,n,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(t,e,s,n,i,r,o){return Mh(this,t,e,s,n,i,r,o)}constructEllipticArcEndPointsCenter(t,e,s,n,i,r,o,a){return Mh(this,t,e,s,n,i,r,o,a)}constructEllipticArcGeneral(t,e,s,n,i,r){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const o=Ja(r),a=Math.cos(o),h=Math.sin(o),m=new l(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),u=l.getNAN(),c=Ja(n);u.x=m.x*Math.cos(c),u.y=m.y*Math.sin(c),u.rotateDirect(a,h),u.addThis(s);const g=U(i,ht());let d=g;Math.abs(d)===ht()&&(d=0);const _=l.getNAN();return _.x=m.x*Math.cos(c+d),_.y=m.y*Math.sin(c+d),_.rotateDirect(a,h),_.addThis(s),this.constructEllipticArcEndPointsCenter(u,_,this.m_semiMajorAxis,this.m_minorMajorRatio,o,Math.abs(g)>B(),g>0,s)}constructEllipticArcAsNURB(t,e,n,i){return(i>=1||i<0)&&s("construct_elliptic_arc_as_NURB: weight"),e.isFinite()||s("construct_elliptic_arc_as_NURB: control_point"),Zh([t,e,n],i*i,null,!1,this),this}constructCanonic(t){return this.assignCopy(t),t.isDegenerateToLine()||t.m_center.isEqual(0,0)&&0===this.m_rotation||(this.m_XStart=t.getSemiMajorAxis()*Math.cos(t.m_startAngle),this.m_YStart=t.getSemiMinorAxis()*Math.sin(t.m_startAngle),this.m_XEnd=t.getSemiMajorAxis()*Math.cos(t.getEndAngle()),this.m_YEnd=t.getSemiMinorAxis()*Math.sin(t.getEndAngle()),this.m_center.setCoords(0,0),this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,Jh(this),this.afterCompletedModification(),t!==this&&an(this,t)),this}isCircular(){return 1===this.m_minorMajorRatio&&0===this.m_rotation&&!this.isDegenerateToLine()}isDegenerateToLineHelper(t){if(this.isLine())return!0;if(this.isMajor())return!1;const e=this.getEndXY().sub(this.getStartXY()).length();return!(this.calculateLength2D()-e>t)}isDegenerateToLine(){return qh(this)}getCenter(){return this.m_center.clone()}setCenter(t){if(!this.m_center.isNAN()){const e=t.sub(this.m_center);this.m_XStart+=e.x,this.m_YStart+=e.y,this.m_XEnd+=e.x,this.m_YEnd+=e.y,this.m_interior.addThis(e),this.m_center.assign(t),this.endPointModified(),this.normalizeAfterEndpointChange()}}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return l.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!Hh(this)}isMajor(){return Uh(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return o.enumEllipticArc}queryEnvelope(e){if(4===e.m_EnvelopeType){e.setEmpty(),e.assignVertexDescription(this.m_description);const s=t.constructEmpty();this.queryEnvelope(s),e.setEnvelope(s);for(let t=1,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t);for(let n=0,i=th.getComponentCount(s);t<i;t++){const t=this.queryInterval(s,n);e.setIntervalEnvelope(s,n,t)}}}else 2===e.m_EnvelopeType?sm(this,r.unit(),e):f("3d not impl")}applyTransformation(t){Yh(this,t,!1,null,null)}createInstance(){return new eh}calculateLength2D(){return function(t){if(qh(t))return 1*l.distance(t.getStartXY(),t.getEndXY());if(1===t.m_minorMajorRatio)return Math.abs(-1*t.getSweepAngle())*t.m_semiMajorAxis;const e=Fh(t,0);return Fh(t,1)-e}(this)}queryControlPointsHelper(t){P("")}queryCoord2D(t,e){if(qh(this))Pn(t,this.getStartXY(),this.getEndXY(),e);else if(0===t)e.assign(l.construct(this.m_XStart,this.m_YStart));else if(1===t)e.assign(l.construct(this.m_XEnd,this.m_YEnd));else{const s=wh(this,t),n=new l(this.m_semiMajorAxis*Math.cos(s),this.getSemiMinorAxis()*Math.sin(s));n.rotateDirect(this.m_cosr,this.m_sinr),n.addThis(this.m_center),e.assign(n)}}queryCoord2DE(t,e){!function(t,e,s){if(qh(t))Sn(new pm({start:t.getStartXY(),end:t.getEndXY()}),e,s);else if(0===e.value())s.set(t.getStartXY());else if(1===e.value())s.set(t.getEndXY());else{const n=new v;Dh(t,e,n);const i=new v,r=new v;v.st_cosAndSin(n,i,r);const o=Rs.constructCoordsE(new v(t.m_semiMajorAxis).mulThisE(i),new v(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio).mulThisE(r)),a=new v(t.m_rotation);v.st_cosAndSin(a,i,r),o.rotateDirect(i,r),o.addThisE(Rs.constructPoint2D(t.m_center)),s.setE(o)}}(this,t,e)}queryCoord2DMP(t,e){f("")}getCoordX(t){const e=new l;return this.queryCoord2D(t,e),e.x}getCoordY(t){const e=new l;return this.queryCoord2D(t,e),e.y}cut(t,e,s){const n=new fm;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createEllipticArc();n&&i.dropAllAttributes();let r=0===t&&1===e;if(r&&!n)return void this.copyTo(i);const o=l.getNAN();this.queryCoord2D(t,o);const a=l.getNAN();if(this.queryCoord2D(e,a),!r)if(o.equals(a))e-t>.5&&this.isMajor()&&this.isClosed()?(r=!0,t=0,e=1):1===e?t=e:e=t;else if(t>0&&o.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&a.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),r=0===t&&1===e,r&&!n)return void this.copyTo(i);if(i.m_center.assign(this.m_center),i.m_semiMajorAxis=this.m_semiMajorAxis,i.m_minorMajorRatio=this.m_minorMajorRatio,i.m_interior.assign(this.m_interior),i.m_rotation=this.m_rotation,i.m_cosr=this.m_cosr,i.m_sinr=this.m_sinr,i.m_sweepAngle=this.m_sweepAngle,i.m_startAngle=this.m_startAngle,i.m_bits=this.m_bits,Ks(i,o.x,o.y),$s(i,a.x,a.y),r)return void kh(i,Th(this));i.m_startAngle=wh(this,t),i.m_sweepAngle=wh(this,e)-i.m_startAngle,i.m_startAngle=Eh(i.m_startAngle),Bh(i,Math.abs(i.m_sweepAngle)>B()),n&&i.assignVertexDescription(this.m_description),Jh(i),Ih(i);const h=this.m_description.getAttributeCount();if(h>1&&!n){for(let e=1;e<h;e++){const s=this.m_description.getSemantics(e),n=th.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<h;t++){const s=this.m_description.getSemantics(t),n=th.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}i.afterCompletedModification()}queryDerivative(t,e){!function(t,e,s){if(qh(t))s.setE(Rs.constructPoint2D(t.getEndXY()).subE(Rs.constructPoint2D(t.getStartXY())));else{const n=new v;Dh(t,e,n);const i=new Rs;if(i.setCoordsE(new v(t.m_semiMajorAxis).negate().mulE((new v).setSin(n)),new v(t.getSemiMinorAxis()).mulE((new v).setCos(n))),t.m_rotation){const e=new v(t.m_rotation);i.rotateDirect((new v).setCos(e),(new v).setSin(e))}i.scaleThis(new v(t.getSweepAngle())),s.setE(i)}}(this,t,e)}cutArcIgnoreAttributes(t,e,s){let n=0===t&&1===e;const i=new l;this.queryCoord2D(t,i);const r=new l;this.queryCoord2D(e,r),n||(i.equals(r)?e-t>.5&&this.isMajor()&&this.isClosed()?(n=!0,t=0,e=1):1===e?t=e:e=t:(t>0&&i.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&r.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),n=0===t&&1===e)),s.m_center.assign(this.m_center),s.m_semiMajorAxis=this.m_semiMajorAxis,s.m_minorMajorRatio=this.m_minorMajorRatio,s.m_interior.assign(this.m_interior),s.m_rotation=this.m_rotation,s.m_cosr=this.m_cosr,s.m_sinr=this.m_sinr,s.m_sweepAngle=this.m_sweepAngle,s.m_startAngle=this.m_startAngle,s.m_bits=this.m_bits,Ks(s,i.x,i.y),$s(s,r.x,r.y),n?kh(s,Th(this)):(s.m_startAngle=wh(this,t),s.m_sweepAngle=wh(this,e)-s.m_startAngle,s.m_startAngle=Eh(s.m_startAngle),Bh(s,Math.abs(s.m_sweepAngle)>Math.PI),Jh(s),s.afterCompletedModification())}changeEndPoints2D(t,e){Ah(this,t,e,!1)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=th.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return Y(r,o,a,i,th.getDefaultValue(e))}getClosestCoordinate(t,e){return nm(this,t,r.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return nm(this,t,e,!1)}getYMonotonicParts(t,e=!1){t.length<2&&s("");const i=this.getSemiAxes(),r=Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr),o=r+B(),a=h(3,Number.NaN);let m=0;if(a[0]=bh(this,r),a[0]>0&&a[0]<1&&m++,a[1]=bh(this,o),a[1]>0&&a[1]<1&&(a[m]=a[1],m++),0===m)return 0;a[m]=1,m++,n(t.length>=m);let l=0;for(let s=0;s<m;s++){const n=a[s];this.queryCut(l,n,t[s],e),l=n}return m}getMonotonicParts(t,e){if(t.length<4&&s(""),this.isDegenerateToLine())return t[0].createEllipticArc().assignCopy(this),e&&t[0].get().dropAllAttributes(),1;const i=this.getSemiAxes(),r=h(4,Number.NaN);r[0]=Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr),r[1]=r[0]+B(),r[2]=Math.atan2(-i.y*this.m_sinr,i.x*this.m_cosr),r[3]=r[2]+B();const o=h(5,Number.NaN);let a=0;for(let t=0;t<4;t++)o[a]=bh(this,r[t]),o[a]>0&&o[a]<1&&a++;if(0===a)return 0;L(o,a),o[a-1]<1&&(o[a]=1,a++),n(t.length>=a);let m=0;for(let s=0;s<a;s++){const n=o[s];this.queryCut(m,n,t[s],e),m=n}return a}intersectionWithAxis2D(t,e,s,n){if(qh(this))return new pm({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(t,e,s,n);let i,o;const a=new v(e),h=this.getSemiAxes();if(t){if(e>this.m_center.y+h.x||e<this.m_center.y-h.x)return 0;i=new v(h.x).mulThis(this.m_sinr),o=new v(h.y).mulThis(this.m_cosr),a.subThis(this.m_center.y)}else{if(e>this.m_center.x+h.x||e<this.m_center.x-h.x)return 0;i=new v(h.x).mulThis(this.m_cosr),o=new v(h.y).mulThis(-this.m_sinr),a.subThis(this.m_center.x)}const m=i.sqr(),l=o.sqr(),u=m.addE(l),c=o.mulE(a).mulThis(-2),d=a.sqr().subThisE(m),_=c.sqr().subThisE(u.mulE(d).mulThis(4)),f=i.mulE(a).mulThis(-2),x=a.sqr().subThisE(l),y=f.sqr().subThisE(u.mulE(x).mulThis(4));let P=_.eps()*Math.abs(y.value())<=y.eps()*Math.abs(_.value());P?i.isZero()&&(P=!1):o.isZero()&&(P=!0),P||(c.setE(f),d.setE(x));const C=T(v,2);let E=oi(u,c,d,r.construct(-1,1),!1,C);if(0===E)return 0;const S=[0,0];let I=0;for(let t=0;t<E;t++){const e=new v,s=new v;P?(e.setE(C[t]),s.setE(a.subE(o.mulE(C[t])).divThisE(i))):(s.setE(C[t]),e.setE(a.subE(i.mulE(C[t])).divThisE(o)));const n=bh(this,Math.atan2(e.value(),s.value()));n>=0&&n<=1&&(S[I]=n,I++)}return E=I,0===E?0:(2===E&&S[0]>S[1]&&(S[1]=p(S[0],S[0]=S[1])),n&&g(n,S,0,0,E),s&&(s[0]=t?this.getCoordX(S[0]):this.getCoordY(S[0]),E>1&&(s[1]=t?this.getCoordX(S[1]):this.getCoordY(S[1]),!n&&s[0]>s[1]&&(s[1]=p(s[0],s[0]=s[1])))),E)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0];return-1===this.intersectionWithAxis2D(!0,t,s,null)?e:s[0]}isCurve(){return!0}isDegenerate(t){return Os(this,t)}isDegenerate3D(t,e){return n(0),!1}queryLooseEnvelope(t){3!==t.m_EnvelopeType?this.queryLooseEnvelopeOnInterval(new r(0,1),t):f("3d not impl")}clone(t){const e=new eh;return this.copyTo(e),e}queryInterval(t,e){if(0===t){if(qh(this))return 0===e?r.construct(this.getStartX(),this.getEndX()):r.construct(this.getStartY(),this.getEndY());let t;const s=this.getSemiAxes();t=0===e?Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr):Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr);const n=t+Math.PI,i=[0,0];i[0]=bh(this,t),i[1]=bh(this,n);const o=0===e?r.construct(this.getStartX(),this.getEndX()):r.construct(this.getStartY(),this.getEndY()),a=new l;for(let t=0;t<2;t++){const s=i[t];s>0&&s<1&&(this.queryCoord2D(s,a),o.mergeNeCoordinate(0===e?a.x:a.y))}return o}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=new r(0,1);if(s.intersect(t),s.isEmpty())return void e.setEmpty();if(qh(this))return e.setCoords(this.getCoord2D(s.vmin)),void e.mergeNe(this.getCoord2D(s.vmax));const n=this.getCoord2D(s.vmin),i=this.getCoord2D(s.vmax);if(1===this.m_minorMajorRatio&&Math.abs(this.m_sweepAngle)*s.width()<=z){let t=l.lerp(n,i,.5);const s=t.sub(this.m_center);return s.normalize(),t=t.add(s.mul(.5*l.distance(n,i))),e.setCoords(n),e.mergeNe(i),void e.mergeNe(t)}sm(this,s,e)}tToLength(t){return qh(this)?t*l.distance(this.getStartXY(),this.getEndXY()):1===this.m_minorMajorRatio?Math.abs(this.getSweepAngle()*t)*this.m_semiMajorAxis:Fh(this,t)}parametricAngleToT(t){return bh(this,t)}tToParametricAngle(t){return wh(this,t)}lengthToT(t){if(qh(this)){const e=l.distance(this.getStartXY(),this.getEndXY());return 0===e?0:t/e}if(1===this.m_minorMajorRatio){const e=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return 0===e?0:t/e}{const e=function(t,e){if(qh(t)){const s=l.distance(t.getStartXY(),t.getEndXY());return 0===s?0:e/s}if(1===t.m_minorMajorRatio){const s=Math.abs(t.getSweepAngle()*t.m_semiMajorAxis);return 0===s?0:e/s}if(0===e)return 0;const s=t.getSweepAngle();if(0===s)return.5;const n=Nh(t),i=mt(),r=Vh(t);s<0&&(e=-e);const o=e/t.m_semiMajorAxis+r;let a=ct(o,n.e2,n.completeE);return a-=i,a-=t.getStartAngle(),a/s}(this,t);return e}}calculateWeightedAreaCentroid2D(t){if(qh(this)){const t=new l;return t.setCoords(0,0),t}const e=Kh(this),s=this.getStartXY().sub(this.m_center),n=this.getEndXY().sub(this.m_center),i=this.m_semiMajorAxis,r=this.getSemiMinorAxis(),o=this.m_startAngle+this.m_sweepAngle,a=new l;a.x=i*r*(i*this.m_cosr*(-Math.sin(o)+Math.sin(this.m_startAngle))+r*(-Math.cos(o)+Math.cos(this.m_startAngle))*this.m_sinr)/3,a.y=i*r*(r*(Math.cos(o)-Math.cos(this.m_startAngle))*this.m_cosr+i*(-Math.sin(o)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const h=n.add(s).mul(n.crossProduct(s)/6);return a.x-=h.x,a.y-=h.y,a.add(this.m_center.sub(t).mul(e))}calculateWeightedCentroid2D(){const t=new l;if(this.isDegenerate(0))return t.setCoords(0,0),t;if(qh(this))return t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t;let e=this.m_startAngle,s=this.m_startAngle+this.m_sweepAngle;if(s<e){const t=e;e=s,s=t}const n=Math.sin(e),i=Math.sin(s),r=Math.cos(e),o=Math.cos(s);if(1===this.m_minorMajorRatio){const e=this.getSemiMajorAxis(),s=e*e,a=s*(i-n),h=s*(r-o);t.setCoords(a,h)}else{const e=this.getSemiMajorAxis(),s=this.getSemiMinorAxis(),a=e*e,h=s*s,m=e*s,l=a-h,u=l/h,c=l/a,g=Math.sqrt(u),d=Math.sqrt(c),_=.5*m*(Math.asinh(g*i)/g+i*Math.sqrt(1+u*i*i))-.5*m*(Math.asinh(g*n)/g+n*Math.sqrt(1+u*n*n)),p=-.5*m*(Math.asin(d*o)/d+o*Math.sqrt(1-c*o*o))- -.5*m*(Math.asin(d*r)/d+r*Math.sqrt(1-c*r*r));t.setCoords(_,p)}return t.rotateDirect(this.m_cosr,this.m_sinr),t.assign(t.add(this.m_center.mul(this.calculateLength2D()))),t}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;if(!qh(this)){const s=l.distance(t,this.m_center),n=this.getSemiAxes();if(s<n.x-e||s>n.y+e)return!1}const n=this.getClosestCoordinate(t,!1),i=new l;return this.queryCoord2D(n,i),l.distance(i,t)<=e}isIntersectingPoint3D(t,e,s,i,r=1){return n(0),!1}getTangent(t){if(qh(this))return this.getEndXY().sub(this.getStartXY());{const e=wh(this,t),s=new l;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}getDerivative(t){if(qh(this))return this.getEndXY().sub(this.getStartXY());{const e=wh(this,t),s=new l;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}normalizeAfterEndpointChange(){return!!zh(this)&&(qh(this)?(Oh(this),!1):Wh(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(t){this.m_bits=-5&this.m_bits|t<<2}convertToCanonic(t){const e=new l(t.x,t.y);return e.subThis(this.m_center),e.rotateReverse(this.m_cosr,this.m_sinr),e}convertFromCanonic(t){const e=new l(t.x,t.y);return e.rotateDirect(this.m_cosr,this.m_sinr),e.addThis(this.m_center),e}canonicToWorldTransformation(t){t.setRotate(this.m_cosr,this.m_sinr),t.shiftCoords(this.m_center.x,this.m_center.y)}getCurvature(t){const e=wh(this,t),s=new l,n=this.getSemiMinorAxis();s.setCoords(-this.m_semiMajorAxis*Math.sin(e),n*Math.cos(e));const i=new l;i.setCoords(-this.m_semiMajorAxis*Math.cos(e),-n*Math.sin(e)),this.m_rotation&&(s.rotateDirect(this.m_cosr,this.m_sinr),i.rotateDirect(this.m_cosr,this.m_sinr));const r=s.sqrLength();if(0===r)return Number.NaN;const o=Math.sqrt(r);return s.divThis(o),s.crossProduct(i)/r}getMonotonicPartParams(t,e){const n=h(6,Number.NaN);n[0]=0;let i=1;if(this.isDegenerateToLine())n[1]=1,i=2;else{const t=this.getSemiAxes(),e=h(4,Number.NaN);this.m_rotation?(e[0]=Math.atan2(t.y*this.m_cosr,t.x*this.m_sinr),e[1]=e[0]+Math.PI,e[2]=Math.atan2(-t.y*this.m_sinr,t.x*this.m_cosr),e[3]=e[2]+Math.PI):(e[0]=0,e[1]=Math.PI,e[2]=.5*Math.PI,e[3]=O());for(let t=0;t<4;t++){const s=bh(this,e[t]);s>0&&s<1&&(n[i]=s,i++)}i>2&&L(n,i),n[i]=1,i++}if(e){t<i&&s("");for(let t=0;t<i;t++)e[t]=n[t]}return i}calculateLowerLength2D(){const t=l.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(e,t)}calculateUpperLength2D(){const t=l.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(e,t)}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=p(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=p(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=p(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_startAngle=this.m_startAngle+this.m_sweepAngle,this.m_sweepAngle=-this.m_sweepAngle}}isLine(){return qh(this)}copyIgnoreAttributes(t){t.m_XStart=this.m_XStart,t.m_YStart=this.m_YStart,t.m_XEnd=this.m_XEnd,t.m_YEnd=this.m_YEnd,t.m_center.assign(this.m_center),t.m_semiMajorAxis=this.m_semiMajorAxis,t.m_minorMajorRatio=this.m_minorMajorRatio,t.m_interior.assign(this.m_interior),t.m_rotation=this.m_rotation,t.m_cosr=this.m_cosr,t.m_sinr=this.m_sinr,t.m_sweepAngle=this.m_sweepAngle,t.m_startAngle=this.m_startAngle,t.m_bits=this.m_bits,Rh(t)}calculateArea2DHelper(){return Kh(this)}absNorm(){let t=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(t+=this.m_center.norm(1),t+=this.m_semiMajorAxis),t}queryEnvelopeW(t,e){if(e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax)),qh(this))return;const s=this.getSemiAxes(),n=h(8,Number.NaN);{const t=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),e=t+Math.PI,i=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),r=i+Math.PI;n[0]=bh(this,t),n[1]=bh(this,e),n[2]=bh(this,i),n[3]=bh(this,r)}{const t=this.m_cosr+this.m_sinr,e=this.m_cosr-this.m_sinr,i=Math.atan2(-s.y*t,s.x*e),r=i+Math.PI,o=Math.atan2(s.y*e,s.x*t),a=o+Math.PI;n[4]=bh(this,i),n[5]=bh(this,r),n[6]=bh(this,o),n[7]=bh(this,a)}const i=l.getNAN();for(let s=0;s<8;s++){const r=n[s];t.containsExclusiveCoordinate(r)&&(this.queryCoord2D(r,i),e.mergeNe(i))}}setSegmentFromCoordsForStitcher(t,e){!function(t,e,s){const n=0===t.projectionBehavior();if(s<=2)return void Gh(t,e[0],e[s-1],n?0:1);if(n){t.constructCircularArcThreePoint(e[0],e[s-1],e[Math.trunc(s/2)]);const n=new l;return t.queryCoord2D(.5,n),void t.m_interior.setCoordsPoint2D(n)}const i=t.getSemiMajorAxis(),r=t.getMinorMajorRatio(),o=t.getAxisXRotation(),a=t.getCenter(),m=new Array(4);m[0]=t.isMajor(),m[1]=!m[0],m[2]=m[0],m[3]=!m[0];const u=new Array(4);u[0]=t.isClockwise(),u[1]=u[0],u[2]=!u[0],u[3]=!u[0];const c=Math.trunc(s<5?1:(s+4)/5),g=T(eh,4),d=h(4,Number.NaN);let _=0;for(let t=0;t<4;t++){g[t].constructEllipticArcEndPointsCenter(e[0],e[s-1],i,r,o,m[t],u[t],a),d[t]=0;let n=0;for(let i=c;i<s-1;i+=c){const s=g[t].getClosestCoordinate(e[i],!1);d[t]+=l.sqrDistance(g[t].getCoord2D(s),e[i]),n++}d[t]/=n,d[t]<d[_]&&(_=t)}t.assignCopy(g[_])}(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(10);return s[0]=this.m_bits,s[1]=this.m_semiMajorAxis,s[2]=this.m_minorMajorRatio,s[3]=this.m_rotation,s[4]=this.m_center.x,s[5]=this.m_center.y,s[6]=this.m_sweepAngle,s[7]=this.m_startAngle,s[8]=this.m_interior.x,s[9]=this.m_interior.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(10);t.queryRange(e,s.length,s,!0,1),this.m_bits=s[0],this.m_semiMajorAxis=s[1],this.m_minorMajorRatio=s[2],this.m_rotation=s[3],this.m_center.x=s[4],this.m_center.y=s[5],this.m_sweepAngle=s[6],this.m_startAngle=s[7],this.m_interior.x=s[8],this.m_interior.y=s[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return P("should not1; be called"),0}ensureXYMonotone(){if(qh(this))return!1;if(this.getStartXY().equals(this.getEndXY()))return Gh(this,this.getStartXY(),this.getEndXY(),this.projectionBehavior()),!0;const e=T(l,3);let s=jh(this,e);if(Ea(e)){let n=!1;if(0===this.projectionBehavior()){const i=new t;i.setCoords({pt:e[0]}),i.mergeNe(e[2]);const r=new l;r.setSub(e[2],e[0]),r.leftPerpendicularThis(),r.normalize(),r.scale(l.distance(e[2],e[0]));const o=l.lerp(e[2],e[0],.5),a=o.sub(r),h=o.add(r);i.clipLine(a,h);const m=l.getClosestCoordinate(a,h,e[1],!1);e[1]=l.lerp(a,h,m);const u=e[2].sub(e[1]),c=e[0].sub(e[1]),g=u.crossProduct(c),d=u.dotProduct(c);s=mt()-Math.abs(.5*Math.atan2(g,d)),n=!0}return Zh(e,s*s,null,n,this),!0}return!1}setCoordsForIntersector(t,e,s){Ah(this,t,e,s)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(t){const e=t;e.m_center.assign(this.m_center),e.m_semiMajorAxis=this.m_semiMajorAxis,e.m_minorMajorRatio=this.m_minorMajorRatio,e.m_interior.assign(this.m_interior),e.m_rotation=this.m_rotation,e.m_cosr=this.m_cosr,e.m_sinr=this.m_sinr,e.m_sweepAngle=this.m_sweepAngle,e.m_startAngle=this.m_startAngle,e.m_bits=this.m_bits,kh(e,Th(this))}reverseImpl(){Lh(this,!Hh(this)),Ih(this),(0!==this.projectionBehavior()||this.getStartXY().equals(this.getEndXY()))&&Jh(this)}equalsImpl(t){const e=t;if(this.m_bits!==e.m_bits)return!1;if(this.m_semiMajorAxis!==e.m_semiMajorAxis)return!1;if(this.m_minorMajorRatio!==e.m_minorMajorRatio)return!1;if(!(this.m_center.isEqualPoint2D(e.m_center)||this.m_center.isNAN()&&e.m_center.isNAN()))return!1;if(this.m_rotation!==e.m_rotation)return!1;if(!this.m_interior.equals(e.m_interior))return!1;const s=e.m_sweepAngle;if(this.m_sweepAngle!==s)return!1;const n=e.m_startAngle;return this.m_startAngle===n}equalsImplTol(t,e){const s=t;if(this.m_bits!==s.m_bits)return!1;if(this.m_center.isNAN()&&s.m_center.isNAN())return!0;if(this.m_center.isNAN()!==s.m_center.isNAN())return!1;if(!this.getSemiAxes().isEqualPoint2D(s.getSemiAxes(),e))return!1;if(!this.m_center.isEqualPoint2D(s.m_center,e))return!1;const n=Math.abs(Za(ja(Qa(this.m_rotation-s.m_rotation)))),i=Math.abs(B()-n),r=Math.min(n,i);if(this.m_semiMajorAxis*Math.abs(r)>e)return!1;const o=this.getCoord2D(.5),a=s.getCoord2D(.5);return!!o.isEqualPoint2D(a,e)}swapImpl(t){const e=t;var s;this.m_center=p(e.m_center,e.m_center=this.m_center),this.m_semiMajorAxis=p(e.m_semiMajorAxis,e.m_semiMajorAxis=this.m_semiMajorAxis),this.m_minorMajorRatio=p(e.m_minorMajorRatio,e.m_minorMajorRatio=this.m_minorMajorRatio),this.m_interior=p(e.m_interior,e.m_interior=this.m_interior),this.m_rotation=p(e.m_rotation,e.m_rotation=this.m_rotation),this.m_cosr=p(e.m_cosr,e.m_cosr=this.m_cosr),this.m_sinr=p(e.m_sinr,e.m_sinr=this.m_sinr),this.m_sweepAngle=p(e.m_sweepAngle,e.m_sweepAngle=this.m_sweepAngle),this.m_startAngle=p(e.m_startAngle,e.m_startAngle=this.m_startAngle),this.m_bits=p(e.m_bits,e.m_bits=this.m_bits),(s=e).m_cachedValues=p(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){Oh(this),Rh(this)}intersect(t,e,s,n,i){return lm(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){if(e.length<2&&i(""),qh(this))return new pm({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(t,e,s);{const e=l.distance(t,this.m_center);if(e>this.m_semiMajorAxis+s||e<this.getSemiMinorAxis()-s)return 0}const n=this.getClosestCoordinate(t,!1),r=l.getNAN();return this.queryCoord2D(n,r),l.distance(r,t)<=s?M(n,0,1)&&(this.queryCoord2D(0===n?1:0,r),l.distance(r,t)<=s)?(e&&(e[0]=0,e[1]=1),2):(e&&(e[0]=n),1):0}isIntersecting(t,e,s){return 0!==om(!1,this,t,e,s)}endPointModified(){this.m_bits|=8,Rh(this)}clearEndPointModified(){Oh(this)}}function sh(t,e,s){t.isEmpty()&&u(""),Ft(t);const n=t.getImpl(),i=[];return ih(n.getPointCount(),i),rh((r=n,{at:t=>r.getXY(t)}),i,n.getPointCount(),e);var r}function nh(t,e,s,n){const i=[];return ih(e,i),rh(t,i,e,s)}function ih(t,e){e.length=t;for(let t=0;t<e.length;++t)e[t]=t;t>3&&ws(t,e)}function rh(t,e,s,n,i){let r=0;const o=[0,0,0];let a=0,h=0;for(let i=0;i<3;++i){let m=!1;for(;h<s;){const s=t.at(e[h]);let u=1;if(3===r?u=l.inCircleRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]),s):2===r?u=l.inCircleRobust3Point(t.at(n[0]),t.at(n[1]),s):1===r&&s.equals(t.at(n[0]))&&(u=0),u<=0){if(u<0&&i+1<3){e[a]=p(e[h],e[h]=e[a]);for(let t=0;t<r;t++)if(n[t]===e[h]){o[t]=h;break}a++}h++;continue}m=!0;let c=0;for(let t=0;t<r;t++)o[t]>h&&(n[c]=n[t],o[c]=o[t],c++);r=c,n[r]=e[h],o[r]=h,r++,r<3?h=a:(1===l.orientationRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]))&&(n[2]=p(n[0],n[0]=n[2]),o[2]=p(o[0],o[0]=o[2])),h++)}if(!m)break;if(i+1<3){a=0;let s=!1;for(let t=0;t<r;t++)for(let e=t+1;e<r;e++)o[t]>o[e]&&(o[e]=p(o[t],o[t]=o[e]),n[e]=p(n[t],n[t]=n[e]),s=!0);for(let t=0;t<r;t++)e[o[t]]=p(e[t],e[t]=e[o[t]]),o[t]=t;s&&3===r&&1===l.orientationRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]))&&(n[2]=p(n[0],n[0]=n[2]),o[2]=p(o[0],o[0]=o[2]))}h=r}return r}function oh(t,e,s,n,i,r){return new lh(0,0,0,null,!1,c()).densifyEx(t,e,s,n,!1,r)}function ah(t,e,i,r){return Number.isFinite(e)||s("replace_all_curves_with_beziers: maxDeviation"),function(t,e,s,i){n(t===o.enumBezier||t===o.enumEllipticArc||t===o.enumBezier2);const r=e.createInstance();r.getGeometryType()===o.enumPolygon&&r.setFillRule(e.getFillRule());const a=e.querySegmentIterator();for(let h=0,m=e.getPathCount();h<m;++h){if(!e.hasNonLinearSegmentsPath(h)){r.addPath(e,h,!0);continue}const m=e.getPathStart(h);let l=!0,u=0;for(a.resetToPath(h),n(a.nextPath());a.hasNextSegment();){const n=a.nextCurve();if(!n)break;{const c=a.getStartPointIndex()-m,g=c-u;g>0&&(r.addSegmentsFromPath(e,h,u,g,l),l=!1),u=c+1,t===o.enumBezier?ch(r,n,s,i,l):t===o.enumBezier2?gh(r,n,s,i,l):P(""),l=!1}}const c=e.getSegmentCountPath(h);c-u!==0&&r.addSegmentsFromPath(e,h,u,c-u,l)}return r}(o.enumBezier,t,e,i)}function hh(t,e,s,i,r,a,m,u){a&&(a.length=0),m&&(m.length=0);const c=t.getGeometryType();if(c===o.enumLine)return a&&(a.push(t.getStartXY()),a.push(l.getNAN()),a.push(l.getNAN()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(c===o.enumBezier){if(!i)return a&&(a.push(t.getStartXY()),a.push(t.getControlPoint1()),a.push(t.getControlPoint2()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;const e=h(9,Number.NaN);let n=t.getMonotonicPartParams(e.length,e);if(e.length=n,n=uh(t,s,e),2===n&&r&&(e[1]=.5,e.push(1),n=3),m&&m.splice(0,0,...e.slice(0,n)),a){const s=new fm;for(let i=1;i<n;i++){const n=e[i-1],r=e[i];t.queryCut(n,r,s,!0);const o=s.get();po(o),1===i&&a.push(o.getStartXY()),a.push(o.getControlPoint1()),a.push(o.getControlPoint2()),a.push(o.getEndXY())}}return n-1}if(c===o.enumEllipticArc){const o=t;if(o.isDegenerateToLine()||o.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(l.getNAN()),a.push(l.getNAN()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(i&&(r||!o.isMonotoneQuickAndDirty())){const l=h(6,Number.NaN);let u=o.getMonotonicPartParams(l.length,l);l.length=u,u=uh(t,s,l),2===u&&r&&(l[1]=.5,l.push(1),u=3);let c=0;if(u>2){const t=new fm,r=m||[];let h=0;for(let g=1;g<u;g++){const d=l[h],_=l[g];if(o.queryCut(d,_,t,!0),t.get().isDegenerate(0))continue;const p=r.length,f=dh(1===g,t.get(),e,s,i,a,m);n(f>0),c+=f;const x=g===u-1,y=l[h],P=t.get().getSweepAngle()/o.getSweepAngle();for(let t=p,e=r.length;t<e;t++)if(r[t]=!x||t+1<e?y+r[t]*P:1,a){const e=3*t,s=o.getCoord2D(r[t]);a[e].setCoordsPoint2D(s),e>0&&fo(a.slice(e-3))}h=g}return c}}return dh(!0,o,e,s,i,a,m)}if(c===o.enumRationalBezier2){const n=t;if(i&&(r||!n.isMonotoneQuickAndDirty())){const i=h(6,Number.NaN);let o=n.getMonotonicPartParams(i.length,i);i.length=o,o=uh(t,s,i),2===o&&r&&(i[1]=.5,i.push(1),o=3);let l=0;if(o>2){const t=new fm,r=m||[];for(let h=1;h<o;h++){const u=i[h-1],c=i[h];n.queryCut(u,c,t,!0);const g=r.length;l+=ph(1===h,t.get(),e,s,!1,a,m);const d=h===o-1,_=i[h-1];for(let t=g,e=r.length;t<e;t++)if(r[t]=!d||t+1<e?_+r[t]:1,a){const e=3*t,s=n.getCoord2D(r[t]);a[e].setCoordsPoint2D(s),e>0&&mr(a.slice(e-3))}}return l}}return ph(!0,n,e,s,i,a,m)}if(c===o.enumBezier2){const n=t,o=T(l,3);n.queryControlPoints(o);const h=new jo;h.constructFromQuadratic(o);const u=hh(h,e,s,i,r,a,m);if(null!=a&&null!=m){const t=3;for(let e=1,s=0;e<u;++e,s+=t){const r=new l;n.queryCoord2D(m[e],r);const o=a[s+t];!r.equals(o)&&(a[s+t].setCoordsPoint2D(r),i)&&fo(a.slice(s,s+4))}}return u}f("")}function mh(t,e,s,i,r,a,m,u,c){const d=t.getGeometryType();if(a&&(a.length=0,m.length=0),u&&(u.length=0),d===o.enumEllipticArc){const e=t;if(e.isDegenerateToLine()||e.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(l.getNAN()),a.push(t.getEndXY()),m.push(Number.NaN),m.push(Number.NaN),m.push(Number.NaN)),u&&(u.push(0),u.push(1)),1}const _=h(9,Number.NaN);let p;if(r)p=t.getMonotonicPartParams(_.length,_),_.length=p,p=uh(t,s,_);else{if(p=2,_[0]=0,_[1]=1,d===eh.type){const e=t.getSweepAngle();if(e>.9*Math.PI){const t=2*Math.PI/3;Math.min(3,Math.trunc(e/t+.5))>2?(_[0]=0,_[1]=1/3,_[2]=2/3,_[3]=1,p=4):(_[0]=0,_[1]=.5,_[2]=1,p=3)}}else n(d===pi.type);_.length=p}if(2===p&&i&&(_[1]=.5,_.push(1),p=3),a){const e=new fm;let s=1;for(;s<p;){const n=_[s-1],i=_[s];t.queryCut(n,i,e,!0);const h=T(l,3),u=[1,1,1];if(d===o.enumEllipticArc){const t=e.get();if(Math.abs(t.getSweepAngle())>.9*Math.PI){const t=(i-n)/3;_.splice(s,0,n+t),_.splice(s+1,0,n+2*t),p+=2;continue}u[1]=jh(t,h)}else{const t=e.get();t.queryControlPoints(h),t.queryWeights(u)}r&&Ea(h),1===s&&(a.push(h[0].clone()),m.push(u[0])),a.push(h[1].clone()),a.push(h[2].clone()),m.push(u[1]),m.push(u[2]),s++}}return u&&(u.length=p,g(u,_,0,0,p)),p-1}eh.type=o.enumEllipticArc;let lh=class e{static constructDefault(t){return new e(0,0,0,t,!1,c())}constructor(t,e,s,n,i,r){this.m_segmentBuffer=null,this.m_dummyPoint=new qe,this.m_progressCounter=0,this.m_progressTracker=n,this.m_bSetDensifyFlag=i,this.m_maxLength=t,this.m_maxDeviation=e,this.m_maxAngle=s>mt()?mt():s,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=r,rt(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(t){return this.densifyGeom(t)}densifySegment(t,e){this.densifySegmentEx(t,null,!0,!1,e)}densifyEx(t,e,s,n,i,r){return this.m_maxLength=e,this.m_maxDeviation=s,this.m_maxAngle=n>mt()?mt():n,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=i,this.m_maxSegmentsPerCurve=r,rt(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(t)}densifyGeom(t){if(t.isEmpty()||t.getDimension()<1)return t;const e=t.getGeometryType();return dt(e)?t:Z(e)?this.densifyMultiPath(t):F(e)?this.densifySegmentImpl(t):e===o.enumEnvelope?this.densifyEnvelope(t):void P("")}densifySegmentEx(t,e,s,n,i){const r=t.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&r!==o.enumLine)&&(!n||s))return void(e?r===o.enumLine?e.addSegment(t,s):(s&&(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)),t.queryEnd(this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint)):(s&&i.push(0),i.push(1)));if(r===o.enumBezier)return void this.densifyCubicBezier(t,e,s,n,i);if(r===o.enumRationalBezier2)return void this.densifyRationalBezier2(t,e,s,n,i);if(r===o.enumBezier2)return void this.densifyBezier2(t,e,s,n,i);if(r===o.enumEllipticArc&&!t.isLine()&&t.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(t,e,s,n,i);let a=1;this.m_maxLength>0&&(a=this.calculateLengthSubdivisionStep(t,this.m_maxLength)),this.m_maxDeviation>0&&(a=Math.min(a,this.calculateDeviationSubdivisionStep(t,this.m_maxDeviation))),this.m_maxAngle>0&&(a=Math.min(a,this.calculateAngularSubdivisionStep(t,this.m_maxAngle))),this.densifySegmentByLength(t,a,e,s,n,i)}densifyMultiPath(t){if(!t.hasNonLinearSegments()){if(1===t.getDescription().getAttributeCount())return this.densifyMultiPathLinear(t);if(!(this.m_maxLength>0))return t}const e=t.createInstance();e.getGeometryType()===o.enumPolygon&&e.setFillRule(t.getFillRule()),e.reserve(t.getPointCount());const s=t.getImpl().querySegmentIterator();for(;s.nextPath();){let t=!0;for(;s.hasNextSegment();){const n=s.nextSegment(),i=s.isClosingSegment();this.densifySegmentEx(n,e,t,i,null),i&&e.closePathWithLine(),t=!1}}return e}densifySegmentImpl(t){const e=new Wn({vd:t.getDescription()});return this.densifySegmentEx(t,e,!0,!1,[0]),e}densifyEnvelope(e){const s=new Tr({vd:e.getDescription()});s.addEnvelope(e,!1);const n=t.constructEmpty();e.queryEnvelope(n);const i=n.width(),r=n.height();return!(this.m_maxLength>0)||i<=this.m_maxLength&&r<=this.m_maxLength?s:this.densifyMultiPath(s)}densifyMultiPathLinear(t){if(!(this.m_maxLength>0))return t;const e=t.createInstance();e.getGeometryType()===o.enumPolygon&&e.setFillRule(t.getFillRule()),e.reserve(t.getPointCount());const s=e.getImpl(),n=t.getImpl(),i=n.getAttributeStreamRef(0),r=new pm;for(let t=0,o=n.getPathCount();t<o;t++){const o=n.isClosedPath(t);if(0===n.getPathSize(t))continue;const a=n.getPathStart(t),h=i.readPoint2D(2*a),m=h.clone();s.startPath(h);for(let o=a+1,h=n.getPathEnd(t);o<h;o++){const t=i.readPoint2D(2*o),n=l.distance(m,t);if(n>this.m_maxLength){let e=Math.ceil(n/this.m_maxLength);e>c()&&(e=c());const i=1/e;let o,a,h;m.compare(t)<0?(r.setStartXY(m),r.setEndXY(t),o=0,a=1):(r.setStartXY(t),r.setEndXY(m),o=e-2,a=-1);for(let t=0,n=e-1;t<n;t++,o+=a){this.progress_(),h=i*(o+1);const t=new l;r.queryCoord2D(h,t),s.lineTo(t),this.m_bSetDensifyFlag&&s.setAttributeNoCurves(10,s.getPointCount()-1,0,1)}}else this.progress_();e.lineTo(t),m.assign(t)}if(o){const t=l.distance(m,h);if(t>this.m_maxLength){const e=h;let n=Math.ceil(t/this.m_maxLength);n>c()&&(n=c());const i=1/n;let o,a;m.compare(e)<0?(r.setStartXY(m),r.setEndXY(e),o=0,a=1):(r.setStartXY(e),r.setEndXY(m),o=n-2,a=-1);const u=new l(0,0);let g;for(let t=0,e=n-1;t<e;t++,o+=a)this.progress_(),g=i*(o+1),r.queryCoord2D(g,u),s.lineTo(u),this.m_bSetDensifyFlag&&s.setAttributeNoCurves(10,s.getPointCount()-1,0,1)}s.closePathWithLine()}}return e}densifySegmentByLength(t,e,s,i,r,a){n(t.getGeometryType()!==o.enumBezier);let h=t.getStartXY().compare(t.getEndXY());0===h&&e<1&&(t.getGeometryType()===o.enumEllipticArc?h=t.getSweepAngle()<0?1:-1:f("densify segment by length"));let m=0;if(i&&(s?(t.queryStart(this.m_dummyPoint),s.startPathPoint(this.m_dummyPoint)):a.push(0),++m),e*this.m_maxSegmentsPerCurve<1&&(e=1/this.m_maxSegmentsPerCurve),e<1){this.m_segmentBuffer||(this.m_segmentBuffer=new fm);let n=Math.ceil(1/e);n>c()&&(n=c()),e=1/n,this.m_segmentBuffer.create(t.getGeometryType());let i,r,o,l=t;h<0?(i=0,r=1):(t.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),i=n-2,r=-1,l=this.m_segmentBuffer.get());const u=n-1;for(let t=0;t<u;t++,i+=r)o=e*(i+1),s?(l.queryCoord(o,this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==o&&0!==o&&s.setAttribute(10,s.getPointCount()-1,0,1)):a.push(h>0?1-o:o),this.progress_();o=1,m+=u}(!r||r&&i&&m<2)&&(s?(t.queryEnd(this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint)):a.push(1))}densifyCubicBezier(t,e,s,n,i){const r=new jo;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());if(0===h&&a>0){const e=T(l,4);t.queryControlPoints(e),h=e[1].compare(e[2]),0===h&&(h=e[1].compare(e[0]))}h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++m);const u=[],c=[],g=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let d=!0,_=0;if(h>0)for(u.push([o.getStartXY(),o.getControlPoint1(),o.getControlPoint2(),o.getEndXY(),new l(0,1)]),c.push(0);u.length;){this.progress_();const t=u.at(-1),r=c.at(-1),a=t[4].x,h=t[4].y;if(r<g&&this.bezierNeedsSplit(t)){d&&(_=o.findMinDeriv(),d=!1);let e=.5*(a+h);Math.abs(_-e)<.4*(h-a)&&(e=_);const s=(e-a)/(h-a),n=t[0].mul(1-s).add(t[1].mul(s)),i=t[1].mul(1-s).add(t[2].mul(s)),m=t[2].mul(1-s).add(t[3].mul(s)),g=n.mul(1-s).add(i.mul(s)),p=i.mul(1-s).add(m.mul(s)),f=g.mul(1-s).add(p.mul(s)),x=t[3];t[1]=n,t[2]=g,t[3]=f,t[4].setCoords(a,e);const y=[f,p,m,x,new l(e,h)];u.push(y),c[c.length-1]=r+1,c.push(r+1);continue}u.pop(),c.pop(),(u.length>0||!n||n&&s&&m<2)&&(e?(o.queryCoord(a,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==a&&0!==a&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(1-a),++m)}else for(u.push([o.getStartXY(),o.getControlPoint1(),o.getControlPoint2(),o.getEndXY(),new l(0,1)]),c.push(0);u.length;){this.progress_();const t=u.at(-1),r=c.at(-1),a=t[4].x,h=t[4].y;if(r<g&&this.bezierNeedsSplit(t)){d&&(_=o.findMinDeriv(),d=!1);let e=.5*(a+h);Math.abs(_-e)<.4*(h-a)&&(e=_);const s=(e-a)/(h-a),n=t[0].mul(1-s).add(t[1].mul(s)),i=t[1].mul(1-s).add(t[2].mul(s)),m=t[2].mul(1-s).add(t[3].mul(s)),g=n.mul(1-s).add(i.mul(s)),p=i.mul(1-s).add(m.mul(s)),f=g.mul(1-s).add(p.mul(s)),x=t[0];t[0]=f,t[1]=p,t[2]=m,t[4].setCoords(e,h);const y=[x,n,g,f,new l(a,e)];u.push(y),c[c.length-1]=r+1,c.push(r+1);continue}u.pop(),c.pop(),(u.length>0||!n||n&&s&&m<2)&&(e?(o.queryCoord(h,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==h&&0!==h&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(h),++m)}}densifyRationalBezier2(t,e,s,n,i){const o=new pi;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());0===m&&h>0&&(m=0),m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new pi,g=[],d=[];for(g.push(new r(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),o=d.at(-1);if(o<u&&this.rationalBezier2NeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();m>0?(g.at(-1).vmax=e,g.push(new r(e,t.vmax))):(g.at(-1).vmin=e,g.push(new r(t.vmin,e))),d[d.length-1]=o+1,d.push(o+1);continue}if(g.pop(),d.pop(),g.length>0||!n||n&&s&&l<2){const s=m>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m>0?1-s:s),++l}}}densifyBezier2(t,e,s,n,i){const o=new xi;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());0===m&&h>0&&(m=0),m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),c=new xi,g=[],d=[];for(g.push(new r(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),o=d.at(-1);if(o<u&&this.bezier2NeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();m>0?(g.at(-1).vmax=e,g.push(new r(e,t.vmax))):(g.at(-1).vmin=e,g.push(new r(t.vmin,e))),d[d.length-1]=o+1,d.push(o+1);continue}if(g.pop(),d.pop(),g.length>0||!n||n&&s&&l<2){const s=m>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m>0?1-s:s),++l}}}densifyEllipticArc(t,e,s,n,i){const o=new eh;let a=t;const h=t.calculateUpperLength2D();let m=t.getStartXY().compare(t.getEndXY());0===m&&h>0&&(m=t.isClockwise()?0:1),m>0&&(t.copyTo(o),o.reverse(),a=o);let l=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++l);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new eh,g=[],d=[];for(g.push(new r(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),o=d.at(-1);if(o<u&&this.ellipticArcNeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();m>0?(g.at(-1).vmax=e,g.push(new r(e,t.vmax))):(g.at(-1).vmin=e,g.push(new r(t.vmin,e))),d[d.length-1]=o+1,d.push(o+1);continue}if(g.pop(),d.pop(),g.length>0||!n||n&&s&&l<2){const s=m>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(m>0?1-s:s),++l}}}calculateLengthSubdivisionStep(t,e){const s=t.calculateUpperLength2D();if(!t.isCurve())return s?e/s:1;if(t.getGeometryType()===o.enumEllipticArc){const n=t;if(n.isCircular()||n.isDegenerate(0)||n.isDegenerateToLine()){let t=e/s;return t<this.m_minStep&&(t=this.m_minStep),t}return e/s*n.getSemiAxes().y/n.getSemiAxes().x}t.getGeometryType()===o.enumBezier&&f(""),f("")}calculateDeviationSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===o.enumEllipticArc){const s=t;if(s.isDegenerate(0)||s.isDegenerateToLine())return 1;{const n=s.getSemiMajorAxis(),i=1-e/n;let r=Math.PI/2;if(i>0){const t=4*Math.sqrt(e/n*.5);r=Math.min(Math.PI/2,Math.abs(t))}r=Math.max(r,2*Math.PI/this.m_maxSegmentsPerCurve);const o=r*n;return this.calculateLengthSubdivisionStep(t,o)}}f("")}calculateAngularSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===o.enumEllipticArc){const s=t;return s.isDegenerate(0)||s.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(t,e*s.getSemiMinorAxis())}f("")}rationalBezier2NeedsSplit(t,s,n,i){t.cutBezierIgnoreAttributes(n,i,s);let r=!1;if(this.m_maxLength>0&&s.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0;const o=T(l,3);s.queryControlPoints(o);const a=[0,0,0];return s.queryWeights(a),!r&&this.m_maxDeviation>0&&(r=!e.checkRationalBezier2MaxDeviation(o,a,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!e.checkRationalBezier2MaxAngle(o,a,this.m_cosMaxAngle)),r}bezier2NeedsSplit(t,s,n,i){t.cutBezierIgnoreAttributes(n,i,s);let r=!1;if(this.m_maxLength>0&&s.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0;const o=T(l,3);return s.queryControlPoints(o),!r&&this.m_maxDeviation>0&&(r=!e.checkBezier2MaxDeviation(o,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!e.checkBezier2MaxAngle(o,this.m_cosMaxAngle)),r}ellipticArcNeedsSplit(t,s,n,i){t.cutArcIgnoreAttributes(n,i,s);let r=!1;return this.m_maxLength>0&&s.calculateUpperLength2D()>this.m_maxLength?(r=!0,!0):(!r&&this.m_maxDeviation>0&&(r=!e.checkEllipticArcMaxDeviation(s,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!e.checkEllipticArcMaxAngle(s,this.m_cosMaxAngle)),r)}bezierNeedsSplit(t){let s=!1;return this.m_maxLength>0&&l.distance(t[0],t[1])+l.distance(t[1],t[2])+l.distance(t[2],t[3])>this.m_maxLength?(s=!0,!0):(!s&&this.m_maxDeviation>0&&(s=!e.checkBezierMaxDeviation(t,this.m_maxDeviation)),!s&&this.m_maxAngle>0&&(s=!e.checkBezierMaxAngle(t,this.m_cosMaxAngle)),s)}progress_(){}static checkBezierMaxDeviation(t,e){const s=t[3].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1])),r=n.dotProduct(t[0].sub(t[2]));if(Math.max(Math.abs(i),Math.abs(r))<=e){const e=new l;Co(t,.5,e,!1);const n=e.sub(t[0]).dotProduct(s);return n>=0&&n<=s.sqrLength()}return!1}return Math.max(t[0].sub(t[1]).sqrLength(),t[0].sub(t[2]).sqrLength())<=e*e}static checkBezierMaxAngle(t,e){if(t[0].equals(t[3]))return!(!t[0].equals(t[1])||!t[1].equals(t[2]));const s=t[3].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[1]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkRationalBezier2MaxDeviation(t,e,s){if(0===e[1])return!1;const n=t[2].sub(t[0]);if(n.sqrLength()>0){const e=n.clone();e.leftPerpendicularThis(),e.normalize();const i=e.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=s){const e=t[1].sub(t[0]).dotProduct(n);return e>=0&&e<=n.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=s*s}static checkRationalBezier2MaxAngle(t,e,s){if(0===e[1])return!1;if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const n=t[2].sub(t[0]);n.normalize();{const e=t[1].sub(t[0]),i=e.dotProduct(n);if(i<0)return!1;if(e.length()*s>i)return!1}return!0}static checkBezier2MaxDeviation(t,e){const s=t[2].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=e){const e=t[1].sub(t[0]).dotProduct(s);return e>=0&&e<=s.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=e*e}static checkBezier2MaxAngle(t,e){if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const s=t[2].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkEllipticArcMaxDeviation(t,e){if(Math.abs(t.getSweepAngle())<Math.PI){const s=t.getEndXY().sub(t.getStartXY()),i=[0,0],r=function(t,e,s){n(!qh(t));const i=new Ps;i.setRotateAngle(-t.getAxisXRotation());const r=new l;i.queryTransform(e,r);const o=Math.atan2(-r.x*t.getMinorMajorRatio(),r.y),a=o+B();let h=bh(t,o),m=bh(t,a);m<h&&(m=p(h,h=m));let u=0;return h>=0&&h<=1&&(s[u++]=h),m>=0&&m<=1&&(s[u++]=m),u}(t,s,i);if(1===r){const s=t.getCoord2D(i[0]),n=l.getClosestCoordinate(t.getStartXY(),t.getEndXY(),s),r=new l;return st(t.getStartXY(),t.getEndXY(),n,r),l.distance(s,r)<=e}}const s=t.getCoord2D(.5),i=new l;return st(t.getEndXY(),t.getStartXY(),.5,i),l.distance(s,i)<=e}static checkEllipticArcMaxAngle(t,e){const s=t.getTangent(0),n=t.getTangent(1),i=s.dotProduct(n);return!(i<0||s.length()*n.length()*e>i)}static checkTypeForReplace(t,e){return t.getGeometryType()===e&&(e!==o.enumEllipticArc||t.isCircular())}};function uh(t,e,s){const n=s.length;if(e<=0||n<=2)return n;let i=0;const r=h(n-1,Number.NaN);for(let e=1,o=n;e<o;e++){const n=t.tToLength(s[e]);r[e-1]=n-i,i=n}for(;r.length>1;){const t=r.findIndex(t=>t<=2*e);if(-1===t)break;let n=t+1,i=t+1;if(t>0){const e=t-1;(i===r.length||r[e]>r[i])&&(i=e,n--)}r[i]+=r[t],r.splice(t,1),s.splice(n,1)}return s.length}function ch(t,e,s,n,i){const r=[],o=[],a=hh(e,s,0,n,!1,r,o),h=new jo;let m=i;const l=e.getDescription();h.assignVertexDescription(l);const u=l.getAttributeCount()>1,c=new qe,g=new pm;for(let s=0,n=0;s<a;s++){if(r[n+1].isNAN()){if(u){let t=o[s];e.queryCoord(t,c),g.setStart(c),t=o[s+1],e.queryCoord(t,c),g.setEnd(c)}g.setStartXY(r[n]),g.setEndXY(r[n+3]),t.addSegment(g,m)}else{if(u){let t=o[s];e.queryCoord(t,c),h.setStart(c),t=o[s+1],e.queryCoord(t,c),h.setEnd(c)}h.setStartXY(r[n]),h.setControlPoint1(r[n+1]),h.setControlPoint2(r[n+2]),h.setEndXY(r[n+3]),t.addSegment(h,m)}n+=3,m=!1}}function gh(t,e,s,n,i){const r=[],a=[],m=function(t,e,s,n,i,r,a){r&&(r.length=0),a&&(a.length=0);const m=t.getGeometryType();if(m===o.enumLine)return r&&(r.push(t.getStartXY()),r.push(l.getNAN()),r.push(t.getEndXY())),a&&(a.push(0),a.push(1)),1;if(m===o.enumBezier2){const e=h(9,Number.NaN);let s=t.getMonotonicPartParams(e.length,e);if(e.length=s,s=uh(t,0,e),a&&a.splice(0,0,...e.slice(0,s)),r){const n=new fm;for(let i=1;i<s;i++){const s=e[i-1],o=e[i];t.queryCut(s,o,n,!0);const a=n.get();hr(a),1===i&&r.push(a.getStartXY()),r.push(a.getControlPoint1()),r.push(a.getEndXY())}}return s-1}if(m===o.enumEllipticArc){const s=t;if(s.isDegenerateToLine()||s.isDegenerate(0))return r&&(r.push(t.getStartXY()),r.push(l.getNAN()),r.push(t.getEndXY())),a&&(a.push(0),a.push(1)),1;if(!s.isMonotoneQuickAndDirty()){const n=h(6,Number.NaN);let i=s.getMonotonicPartParams(n.length,n);n.length=i,i=uh(t,0,n);let o=0;if(i>2){const t=new fm,h=a||[];for(let m=1;m<i;m++){const l=n[m-1],u=n[m];s.queryCut(l,u,t,!0);const c=h.length;o+=fh(1===m,t.get(),e,0,0,r,a);const g=m===i-1,d=n[m-1],_=t.get().getSweepAngle()/s.getSweepAngle();for(let t=c,e=h.length;t<e;t++)if(h[t]=!g||t+1<e?d+h[t]*_:1,r){const e=2*t,n=s.getCoord2D(h[t]);r[e].setCoordsPoint2D(n),e>0&&mr(r.slice(e-2))}}return o}}return dh(!0,s,e,0,n,r,a)}if(m===o.enumBezier){const s=t;if(!s.isMonotoneQuickAndDirty()){const n=h(6,Number.NaN);let i=s.getMonotonicPartParams(n.length,n);n.length=i,i=uh(t,0,n);let o=0;if(i>2){const t=new fm,h=a||[];for(let m=1;m<i;m++){const l=n[m-1],u=n[m];s.queryCut(l,u,t,!0);const c=h.length;o+=xh(1===m,t.get(),e,0,0,r,a);const g=m===i-1,d=n[m-1];for(let t=c,e=h.length;t<e;t++)if(h[t]=!g||t+1<e?d+h[t]:1,r){const e=2*t,n=s.getCoord2D(h[t]);r[e].setCoordsPoint2D(n),e>0&&mr(r.slice(e-2))}}return o}}return xh(!0,s,e,0,0,r,a)}if(m===o.enumRationalBezier2){const s=t;if(!s.isMonotoneQuickAndDirty()){const n=h(6,Number.NaN);let i=s.getMonotonicPartParams(n.length,n);n.length=i,i=uh(t,0,n);let o=0;if(i>2){const t=new fm,h=a||[];for(let m=1;m<i;m++){const l=n[m-1],u=n[m];s.queryCut(l,u,t,!0);const c=h.length;o+=_h(1===m,t.get(),e,0,0,r,a);const g=m===i-1,d=n[m-1];for(let t=c,e=h.length;t<e;t++)if(h[t]=!g||t+1<e?d+h[t]:1,r){const e=2*t,n=s.getCoord2D(h[t]);r[e].setCoordsPoint2D(n),e>0&&mr(r.slice(e-2))}}return o}}return _h(!0,s,e,0,0,r,a)}f("")}(e,s,0,n,0,r,a),u=new xi;let c=i;const g=e.getDescription();u.assignVertexDescription(g);const d=g.getAttributeCount()>1,_=new qe,p=new pm;for(let s=0,n=0;s<m;s++){if(r[n+1].isNAN()){if(d){let t=a[s];e.queryCoord(t,_),p.setStart(_),t=a[s+1],e.queryCoord(t,_),p.setEnd(_)}p.setStartXY(r[n]),p.setEndXY(r[n+2]),t.addSegment(p,c)}else{if(d){let t=a[s];e.queryCoord(t,_),u.setStart(_),t=a[s+1],e.queryCoord(t,_),u.setEnd(_)}u.setStartXY(r[n]),u.setControlPoint1(r[n+1]),u.setEndXY(r[n+2]),t.addSegment(u,c)}n+=2,c=!1}}function dh(e,s,n,i,r,o,a,h){const m=s.clone();m.dropAllAttributes();const u=(t,e,s,n)=>(e&&(t&&e.push(n.getStartXY()),e.push(l.getNAN()),e.push(l.getNAN()),e.push(n.getEndXY())),s&&(t&&s.push(0),s.push(1)),1);if(m.isDegenerateToLine()||m.isDegenerate(0))return u(e,o,a,s);const c=m.getStartXY(),g=m.getEndXY(),d=m.getSemiAxes(),_=new Ps;if(m.isCircular())_.setIdentity();else{const t=m.getAxisXRotation();_.setScaleCoords(1,m.getMinorMajorRatio()),_.rotateAngle(t)}const p=m.getCenter();_.shift(p);const f=_.clone();f.invertThis(),m.applyTransformation(f);const x=m.getSweepAngle();if(0===x)return u(e,o,a,s);const y=t.constructEmpty();y.setCoords({center:p,width:2*d.x,height:2*d.x});const P=.05*y.calculateToleranceFromEnvelope(),C=Math.max(n/d.x,P/d.x);let E=4*Math.pow(C/.0741,1/6);E=Math.min(E,Math.PI/2);const S=Ka(m.getStartAngle());let v=x>0?Math.floor(S/E):Math.ceil(S/E);v*=E;const I=x>0?E:-E;v+I===S&&(v+=I);let b=4/3*Math.tan(Math.abs(E)/4);x>0&&(b=-b),a&&e&&a.push(0);const w=E/Math.abs(x);let D=(v-S)/x;const N=c.clone(),A=new l;m.queryCoord2D(0,A);const M=A.clone(),G=1-.01*w;let q=0,F=0;for(;D<1;){let t;if(D+=w,F>0&&D<G)t=b;else{D>=G&&(D=1);const e=(D-F)*x;t=4/3*Math.tan(Math.abs(e)/4),x>0&&(t=-t)}m.queryCoord2D(D,A);const n=new l;_.queryTransform(A,n);const h=s.getClosestCoordinate(n,!1);if(s.queryCoord2D(h,n),1!==D&&(l.distance(N,n)<=2*i||l.distance(n,g)<=2*i))continue;N.setCoordsPoint2D(n);const u=T(l,4);u[0].assign(M),u[3].assign(A),u[1].rightPerpendicularOther(M),u[1].scaleAddThis(t,M),u[2].leftPerpendicularOther(A),u[2].scaleAddThis(t,A),_.transformPoints2D(u,3,u),u[3].assign(n),0===F&&u[0].setCoordsPoint2D(c),1===D&&u[3].setCoordsPoint2D(g),r&&fo(u);let d=!0;for(let t=1;t<4;t++)if(!u[t].isEqualPoint2D(u[0])){d=!1;break}d||(a&&a.push(h),o&&(0===F&&e&&o.push(u[0].clone()),o.push(u[1].clone()),o.push(u[2].clone()),o.push(u[3].clone())),q++),F=D,M.setCoordsPoint2D(A)}return q}function _h(e,s,n,i,r,o,a,m){s.clone().dropAllAttributes();const u=new t;s.queryLooseEnvelope(u);const c=.05*u.calculateToleranceFromEnvelope(),g=Math.max(n,c);a&&e&&a.push(0);let d=0;const _=T(l,3);s.queryControlPoints(_);const p=[0,0,0];s.queryWeights(p);const f=[],x=h(9,Number.NaN);let y=s.getMonotonicPartParams(x.length,x);x.length=y,y=uh(s,i,x);let P=0,C=e;for(let t=1;t<y;t++){const e=x[t];for(f.push(P),f.push(e);f.length>1;){const t=f.at(-1);f.pop();const e=f.at(-1),s=T(l,3);va(_,p,t,e,s,[0,0,0]);const n=T(l,3),i=Cr(s,p,n),r=16,h=f.length>r;g>=i||h?(a.push(e),o&&(C&&(o.push(n[0]),C=!1),o.push(n[1]),o.push(n[2])),d++):(f.push(.5*(t+e)),f.push(t))}P=e}return d}function ph(e,s,n,i,r,o,a,m){s.clone().dropAllAttributes();const u=new t;s.queryLooseEnvelope(u);const c=.05*u.calculateToleranceFromEnvelope(),g=Math.max(n,c);a&&e&&a.push(0);let d=0;const _=T(l,3);s.queryControlPoints(_);const p=[0,0,0];s.queryWeights(p);const f=[],x=h(9,Number.NaN);let y=0;r?(y=s.getMonotonicPartParams(x.length,x),x.length=y,y=uh(s,i,x)):(x.length=2,y=2,x[0]=0,x[1]=1);let P=0,C=e;for(let t=1;t<y;t++){const e=x[t];for(f.length=0,f.push(e),f.push(P);f.length>1;){const t=f.at(-1);f.pop();const e=f.at(-1),s=T(l,3),n=[0,0,0];va(_,p,t,e,s,n);const i=T(l,4),r=Ia(s,n,i),h=16,m=f.length>h;g>=r||m?(a.push(e),o&&(C&&(o.push(i[0]),C=!1),o.push(i[1]),o.push(i[2]),o.push(i[3])),d++):(f.push(.5*(t+e)),f.push(t))}P=e}return d}function fh(e,s,n,i,r,o,a,h){const m=s.clone();if(m.dropAllAttributes(),m.isDegenerateToLine()||0===m.getSweepAngle())return o&&(e&&o.push(s.getStartXY()),o.push(l.getNAN()),o.push(s.getEndXY())),a&&(e&&a.push(0),a.push(1)),1;const u=m.getStartXY(),c=m.getEndXY(),g=m.getSemiAxes(),d=new Ps;if(m.isCircular())d.setIdentity();else{const t=m.getAxisXRotation();d.setScaleCoords(1,m.getMinorMajorRatio()),d.rotateAngle(t)}const _=m.getCenter();d.shift(_);const p=d.clone();p.invertThis(),m.applyTransformation(p);const f=t.constructEmpty();f.setCoords({center:_,width:2*g.x,height:2*g.x});const x=.05*f.calculateToleranceFromEnvelope(),y=Math.max(n/g.x,x/g.x),P=Math.sqrt(2*y+y*y);let C=2*Math.sqrt(2*P*(1+y-P));C=Math.min(C,Math.PI/2);const E=m.getSweepAngle(),S=Math.ceil(Math.abs(E)/C),v=Math.max(S,1);C=E/v;const I=1/v;let b=Math.tan(Math.abs(C)/2);E>0&&(b=-b),a&&e&&a.push(0);const w=new l;m.queryCoord2D(0,w);for(let t=0;t<v;t++){const s=w.clone(),n=(t+1)*I;if(a&&a.push(n),!o)continue;m.queryCoord2D(n,w);const i=T(l,3);i[0].assign(s),i[2].assign(w),i[1].rightPerpendicularOther(i[0]),i[1].mulThis(b),i[1].addThis(i[0]),d.transformPoints2D(i,3,i),0===t&&i[0].setCoordsPoint2D(u),t===v-1&&i[2].setCoordsPoint2D(c),0===t&&e&&o.push(i[0]),o.push(i[1]),o.push(i[2])}return v}function xh(e,s,n,i,r,o,a,m){s.clone().dropAllAttributes();const u=new t;s.queryLooseEnvelope(u);const c=.05*u.calculateToleranceFromEnvelope(),g=Math.max(n,c);a&&e&&a.push(0);let d=0;const _=T(l,4);s.queryControlPoints(_);const p=[],f=h(9,Number.NaN);let x=s.getMonotonicPartParams(f.length,f);f.length=x,x=uh(s,i,f);let y=0,P=e;for(let t=1;t<x;t++){const e=f[t];for(p.push(y),p.push(e);p.length>1;){const t=p.at(-1);p.pop();const e=p.at(-1),s=T(l,4);Po(_,t,e,s);const n=T(l,3),i=Pr(s,n),r=16,h=p.length>r;g>=i||h?(a.push(e),o&&(P&&(o.push(n[0]),P=!1),o.push(n[1]),o.push(n[2])),d++):(p.push(.5*(t+e)),p.push(t))}y=e}return d}class yh{constructor(t,e){this.m_arc=t,this.m_sqrChordLength=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?l.sqrDistance(this.m_arc.getCoord2D(e),this.m_arc.getCoord2D(1-e))-this.m_sqrChordLength:0}getError(t){return 0}}function Ph(t,e){return t.convertToCanonic(e)}function Ch(t,e,s,n){let i=t.m_startAngle,r=t.m_sweepAngle;const o=1e-12;for(;i>B();)i-=2*B();for(;i<=-B();)i+=2*B();if(!Number.isNaN(e)){for(;e>B();)e-=2*B();for(;e<=-B();)e+=2*B();!s&&e>i&&(e-=2*B()),s&&e<i&&(e+=2*B()),r=e-i,Math.abs(r)<o&&!n&&(r=s?2*B():-2*B()),Math.abs(r)>2*B()-o&&n&&(r=0)}Math.abs(r)>2*B()-o&&(r=r>=0?2*B():-2*B(),t.setEndXY(t.getStartXY())),Math.abs(r)<o&&(r=0,t.setEndXY(t.getStartXY())),n=Math.abs(r)<=B(),r&&(s=r>0),t.m_startAngle=Eh(i),t.m_sweepAngle=r,Bh(t,!n),Lh(t,s)}function Eh(t){let e=t,s=!1;return e<=-B()?(e+=ht(),s=!0):e>B()&&(e-=ht(),s=!0),e<=-B()?(e=Pt(e,ht()),e<=-B()&&(e+=ht()),s=!0):e>B()&&(e=Pt(e,ht()),e>B()&&(e-=ht()),s=!0),s&&(e>B()||e<=-B())&&(e=B()),e}function Sh(t,e,s){const n=s,i=n.getSemiAxes();let r=new l(i.x*Math.cos(t[0]),i.y*Math.sin(t[0]));return r=n.convertFromCanonic(r),l.sqrDistance(r,n.getStartXY())}function vh(t,e,s){const n=s,i=n.getSemiAxes(),r=t[0]+n.getStartAngle();let o=new l(i.x*Math.cos(r),i.y*Math.sin(r));return o=n.convertFromCanonic(o),l.sqrDistance(o,n.getEndXY())}function Ih(t){if(t.m_center.isNAN())return t.m_startAngle=0,void(t.m_sweepAngle=0);const e=t.getStartXY(),s=t.getEndXY(),n=e.equals(s),i=Uh(t),r=Hh(t),o=t.projectionBehavior();if(n){const s=t.convertToCanonic(e),n=new l(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);s.x/=n.x,s.y/=n.y,t.m_startAngle=Eh(Math.atan2(s.y,s.x)),t.m_sweepAngle=i?r?ht():-ht():0}else{const n=t.convertToCanonic(e),a=new l(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);n.x/=a.x,n.y/=a.y;const h=t.convertToCanonic(s);h.x/=a.x,h.y/=a.y,t.m_startAngle=Math.atan2(n.y,n.x),t.m_sweepAngle=l.calculateAngle(n,h),r?t.m_sweepAngle<0&&(t.m_sweepAngle+=ht()):t.m_sweepAngle>0&&(t.m_sweepAngle-=ht()),t.m_startAngle=Eh(t.m_startAngle);let m=Sh([t.m_startAngle],0,t);if(m=Math.sqrt(m),m>.25*hn(t)){const e=t.m_startAngle-1e-4,s=t.m_startAngle+1e-4,n=[0];ei(Sh,t,1,[t.m_startAngle],[e],[s],0,n),t.m_startAngle=Eh(n[0])}if(m=vh([t.m_sweepAngle],0,t),m=Math.sqrt(m),m>.25*hn(t)){const e=t.m_sweepAngle-1e-4,s=t.m_sweepAngle+1e-4,n=[0];ei(vh,t,1,[t.m_sweepAngle],[e],[s],0,n),t.m_sweepAngle=n[0]}const u=Math.abs(t.m_sweepAngle)>B();if(Bh(t,u),i!==u&&!i&&Math.abs(t.m_sweepAngle)>1.5*B())return void Gh(t,e,s,o);if(0===t.m_sweepAngle||r!==t.m_sweepAngle>0)return void Gh(t,e,s,o)}}function bh(t,e){const s=function(t,e){const s=new r(t.getStartAngle(),t.getEndAngle());s.normalize();const n=ht(),i=Pt(e,n);if(i<s.vmin){let t=i+n;for(;t<s.vmin;)t+=n;return s.containsCoordinate(t)?t:s.vmin-i<t-s.vmax?i:t}if(i>s.vmax){let t=i-n;for(;t>s.vmax;)t-=n;return s.containsCoordinate(t)||s.vmin-t<i-s.vmax?t:i}return i}(t,e);return(s-t.getStartAngle())/t.getSweepAngle()}function wh(t,e){return t.m_startAngle+e*t.m_sweepAngle}function Dh(t,e,s){s.assign(new v(t.m_startAngle).addE(e.mulE(new v(t.m_sweepAngle))))}function Th(t){return t.m_cachedValues}function Nh(t){if(t.m_cachedValues)return t.m_cachedValues;const e={e2:0,completeE:0};return e.e2=function(t){return 1-ot(t.m_minorMajorRatio)}(t),e.completeE=Ct(e.e2),t.m_cachedValues=e,e}function Ah(t,e,s,n){if(!e.isEqual(t.m_XStart,t.m_YStart)||!s.isEqual(t.m_XEnd,t.m_YEnd)){if(qh(t))return t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,Jh(t),void t.afterCompletedModification();if(n&&Math.abs(t.getSweepAngle())<=1.01*mt()){const n=T(l,3),i=jh(t,n);if(Pa(n)){if(n[0].assign(e),n[2].assign(s),Ea(n),0===t.projectionBehavior()){let e=0,s=2;l.sqrDistance(n[1],n[0])<l.sqrDistance(n[1],n[2])&&(s=p(e,e=s));const i=n[s].sub(n[e]),r=i.length();i.divThis(r);const o=n[1].sub(n[e]),a=o.length(),h=o.dotProduct(i)/a,m=o.crossProduct(i)/a,u=new l;st(n[e],n[s],.5,u);const c=.5*r/m*A(1-h,0,1),g=n[1].side(n[e],n[s]),d=i.clone();g?d.leftPerpendicularThis():d.rightPerpendicularThis();const _=u.sub(d.mul(c));t.constructCircularArcThreePoint(n[0],n[2],_)}else Zh(n,i*i,null,!1,t);return}}0===t.projectionBehavior()?function(t,e,s){const n=t.getStartXY(),i=t.getEndXY(),r=n.equals(i),o=e.equals(s);if(!r&&!o){const r=new Ps;r.setShiftCoords(-t.m_XStart,-t.m_YStart);const o=l.distance(e,s),a=l.distance(n,i),h=o/a;r.scale(h,h);const m=i.sub(n);m.divThis(a);const u=s.sub(e);u.divThis(o);const c=m.crossProduct(u),g=u.dotProduct(m);return r.rotate(g,c),r.shiftCoords(e.x,e.y),void Yh(t,r,!0,e,s)}const a=new l;if(t.queryCoord2D(.5,a),o){if(r){const i=t.m_center.add(e.sub(n));t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),1,0,!0,!t.isClockwise(),i),t.setProjectionBehavior(0)}else if(t.isMajor()){const n=a.sub(e).getUnitVector().mul(2*t.getSemiMajorAxis()).add(e);t.constructCircularArcThreePoint(e,s,n)}else t.constructCircularArcThreePoint(e,s,e);return}const h=e.add(s).mul(.5),m=s.sub(e);m.rightPerpendicularThis();const u=h.add(m),c=l.getClosestCoordinate(h,u,t.getCenter(),!0),g=new l;st(h,u,c,g);const d=l.distance(e,g);t.constructEllipticArcEndPointsCenter(e,s,d,1,0,!0,!t.isClockwise(),g),t.setProjectionBehavior(0)}(t,e,s):rm(t,e,s)}}function Mh(t,e,s,n,i,r,o,a,h){return t.m_bits=0,t.m_rotation=r,Qs(t,e),Js(t,s),t.m_cosr=Math.cos(r),t.m_sinr=Math.sin(r),Bh(t,o),Lh(t,a),void 0!==h?t.m_center.assign(h):t.m_center.setNAN(),t.setProjectionBehavior(1),t.m_semiMajorAxis=n,t.m_minorMajorRatio=i,Wh(t,void 0===h)}function Gh(t,e,s,n){t.m_bits=0,t.m_rotation=0,Qs(t,e),Js(t,s),t.m_interior.assign(e.add(s).mul(.5)),t.m_startAngle=0,t.m_sweepAngle=0,t.m_cosr=1,t.m_sinr=0,Bh(t,!1),Lh(t,!1),t.m_center.setNAN(),t.m_semiMajorAxis=1,t.m_minorMajorRatio=0,t.setProjectionBehavior(n),t.afterCompletedModification()}function qh(t){return t.m_center.isNAN()}function Fh(t,e){if(0===e)return 0;const s=Nh(t),n=wh(t,e),i=mt(),r=Vh(t),o=ut(n+i,s.e2,s.completeE),a=t.m_semiMajorAxis*(o-r);return Math.abs(a)}function Vh(t){const e=Nh(t);return ut(t.getStartAngle()+mt(),e.e2,e.completeE)}function Yh(t,e,s,i,r){if(2===e.m_TransformationType)return void n(0);if(n(!zh(t)),e.isIdentity()&&(!i||i.equals(t.getStartXY())&&r.equals(t.getEndXY())))return;Rh(t);let o=l.getNAN(),a=l.getNAN();if(null===i?(o.x=t.m_XStart,o.y=t.m_YStart,e.transformInPlace(o),a.x=t.m_XEnd,a.y=t.m_YEnd,e.transformInPlace(a)):(o=i,a=r),qh(t))return t.m_XStart=o.x,t.m_YStart=o.y,t.m_XEnd=a.x,void(t.m_YEnd=a.y);const h=t.m_center.clone();if(e.transformInPlace(h),s||e.isUniformNoRotation()){let s=Hh(t);if(e.isReflective()&&(s=!s),0===t.projectionBehavior()){if(!o.equals(a)){const s=t.m_interior.clone();return e.transformInPlace(s),void t.constructCircularArcThreePoint(o,a,s)}return void Xh(t,o,a,h,s,!1)}const n=new l(t.m_cosr,t.m_sinr);e.transformWithoutTranslateInPlace(n);const i=Math.atan2(n.y,n.x),r=t.getSemiAxes();e.transformWithoutTranslateInPlace(r);const m=t.m_center.clone();return e.transformInPlace(m),void t.constructEllipticArcEndPointsCenter(o,a,r.x,r.y/r.x,i,t.isMajor(),s,m)}{{const s=new Array(4);!function(t,e){const s=new v(t.m_cosr).sqrThis(),n=new v(t.m_sinr).sqrThis(),i=new v(t.m_minorMajorRatio),r=new v(1/t.m_minorMajorRatio),o=i.mulE(s).addThisE(r.mulE(n)),a=i.subE(r).mulThis(2*t.m_cosr*t.m_sinr),h=i.mulE(n).addThisE(r.mulE(s));e[0]=o,e[1]=a,e[2]=h,e[3]=new v(-t.m_semiMajorAxis).mulThis(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio)}(t,s);const n=new Ls;if(n.a11.setE(s[0]),n.a12.setE(s[1]),n.a12.mulThisByPower2(.5),n.a21.setE(n.a12),n.a22.setE(s[2]),!n.det().isZero()){const i=new Ls;if(i.a11.set(e.xx),i.a12.set(e.xy),i.a21.set(e.yx),i.a22.set(e.yy),i.invertThis()){const r=i.clone();r.transposeThis();const m=n.clone();if(m.mulThis(i),m.mulLeftThis(r),!m.det().isZero()){const n=T(v,4);n[0].setE(m.a11),n[1].setE(m.a12),n[1].mulThisByPower2(2),n[2].setE(m.a22),n[3].setE(s[3]);const i=l.getNAN(),r=function(t,e){const s=new Ls;s.a11.setE(t[0]),s.a12=v.st_mulByPower2(t[1],.5),s.a21.setE(s.a12),s.a22.setE(t[2]);const n=[l.getNAN(),l.getNAN()],i=[new v,new v];s.eigenSymmetric(i,n);const r=t[3].clone();return r.negateThis(),r.invThis(),i[0].mulThisE(r),i[1].mulThisE(r),i[0].sqrtThis().invThis(),i[1].sqrtThis().invThis(),e.x=i[0].toDouble(),e.y=i[1].toDouble(),Math.atan2(n[0].y,n[0].x)}(n,i);let u=Hh(t);return e.isReflective()&&(u=!u),void t.constructEllipticArcEndPointsCenter(o,a,i.x,i.y/i.x,r,t.isMajor(),u,h)}}}}const s=[l.getNAN(),l.getNAN(),l.getNAN()];s[0].setCoords(t.getSemiMajorAxis(),0),s[0].rotateDirect(t.m_cosr,t.m_sinr),s[1].setCoords(t.getSemiMajorAxis(),t.getSemiMinorAxis()),s[1].rotateDirect(t.m_cosr,t.m_sinr),s[2].setCoords(0,t.getSemiMinorAxis()),s[2].rotateDirect(t.m_cosr,t.m_sinr);let n=t.isClockwise();n&&(s[2]=p(s[0],s[0]=s[2]));const i=.5;e.transformWithoutTranslateArray(s,3,s),e.isReflective()&&(n=!n);const r=new l(0,0),m=t.createInstance();Zh(s,i,r,!1,m),t.constructEllipticArcEndPointsCenter(o,a,m.getSemiMajorAxis(),m.getMinorMajorRatio(),m.getAxisXRotation(),t.isMajor(),!n,h)}}function Xh(t,e,s,n,i,r){const o=.5*(n.sub(e).length()+n.sub(s).length());t.m_center.assign(n),t.m_startAngle=Math.atan2(e.y-t.m_center.y,e.x-t.m_center.x),Ch(t,Math.atan2(s.y-t.m_center.y,s.x-t.m_center.x),i,r);const a=t.constructEllipticArcEndPointsCenter(e,s,o,1,0,Math.abs(t.m_sweepAngle)>Math.PI,t.m_sweepAngle>0,n);return t.setProjectionBehavior(0),a}function kh(t,e){t.m_cachedValues=e}function Rh(t){t.m_cachedValues=null}function Lh(t,e){const s=e?1:0;t.m_bits=-2&t.m_bits|s}function Hh(t){return!!(1&t.m_bits)}function Bh(t,e){const s=e?1:0;t.m_bits=-3&t.m_bits|s<<1}function Uh(t){return!!(2&t.m_bits)}function zh(t){return!!(8&t.m_bits)}function Oh(t){t.m_bits&=-9}function Wh(t,e){Oh(t);const s=t.getStartXY(),i=t.getEndXY();let r=!1;const o=Uh(t),a=Hh(t),h=t.projectionBehavior(),m=s.equals(i);let u=0===t.m_minorMajorRatio||0===t.m_semiMajorAxis;if(Number.isNaN(t.m_minorMajorRatio)&&(0===t.m_semiMajorAxis?t.m_minorMajorRatio=1:Q("NAN minor major ratio and non-zero major axis")),u||=e?m:t.m_center.isNAN(),u)return Gh(t,s,i,h),!0;t.m_semiMajorAxis=Math.abs(t.m_semiMajorAxis),t.m_minorMajorRatio=Math.abs(t.m_minorMajorRatio),t.m_minorMajorRatio>1&&(t.m_semiMajorAxis*=t.m_minorMajorRatio,t.m_minorMajorRatio=1/t.m_minorMajorRatio);const c=new l(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);if(n(c.y>0&&c.x>=c.y),m){const e=t.convertToCanonic(s);n(!c.isZero()),e.x/=c.x,e.y/=c.y;const i=Math.sqrt(ot(e.x)+ot(e.y));if(r=1!==i,t.m_semiMajorAxis*=i,c.mulThis(i),t.m_startAngle=Eh(Math.atan2(e.y,e.x)),!o)return t.m_interior.assign(s),t.m_sweepAngle=0,t.afterCompletedModification(),r;t.m_sweepAngle=a?ht():-ht()}else{let e=t.m_center.isNAN()||function(t){if(t.m_center.isNAN())return!1;const e=new Rs;e.setWithEps(t.getStartXY(),8),e.subThisE((new Rs).setWithEps(t.m_center,8));const s=new v;s.setWithEps(t.m_rotation,8);const n=new v,i=new v;v.st_cosAndSin(s,n,i),e.rotateReverse(n,i);const r=new Rs;r.setWithEps(t.getEndXY()),r.subThisE(Rs.constructPoint2D(t.m_center)),r.rotateReverse(n,i);const o=new v;o.setWithEps(t.m_semiMajorAxis,8);const a=o.clone(),h=new v;h.setWithEps(t.m_minorMajorRatio),a.mulThisE(h),e.x.divThisE(o),e.y.divThisE(a),r.x.divThisE(o),r.y.divThisE(a);const m=e.x.sqr().addThisE(e.y.sqr()).subThisE(I),l=r.x.sqr().addThisE(r.y.sqr()).subThisE(I);return!m.isZero()||!l.isZero()}(t);if(!e){const n=t.convertToCanonic(s);n.x/=c.x,n.y/=c.y;const r=new l(1,0);t.m_startAngle=l.calculateAngle(r,n);const o=t.convertToCanonic(i);o.x/=c.x,o.y/=c.y,t.m_sweepAngle=l.calculateAngle(n,o),e=!Qh(t)}if(e){r=!0;const e=s.sub(i).mulThis(.5);e.rotateReverse(t.m_cosr,t.m_sinr);let n=ot(e.x/c.x)+ot(e.y/c.y);n>1&&(n=Math.sqrt(n),t.m_semiMajorAxis*=n,c.mulThis(n));const h=new l(0,0);{const t=c.x*c.x,s=c.y*c.y,n=t*e.y*e.y+s*e.x*e.x,i=t*s-n;if(i>0){const t=Math.sqrt(i/n);h.setCoords(c.x*e.y/c.y,-c.y*e.x/c.x),h.mulThis(t),o===a&&h.negateThis()}}{const e=new l(h.x,h.y);e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(s.add(i).mulThis(.5)),t.m_center.assign(e)}}if(Ih(t),!Qh(t))return Gh(t,s,i,h),!0}return Jh(t),t.afterCompletedModification(),r}function jh(t,e){n(Math.abs(t.getSweepAngle())<15*Math.PI/16);const s=t.getSemiMajorAxis(),i=t.getSemiMinorAxis();let r;if(0===s)return e[0].setCoordsPoint2D(t.getStartXY()),e[1].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getStartXY()),r=1,r;if(0===i)return e[0].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getEndXY()),e[1]=l.lerp(e[0],e[2],.5),r=1,r;const o=t.getSweepAngle(),a=t.getStartAngle(),h=a+o,m=new l(-s*Math.sin(a),i*Math.cos(a)),u=new l(-s*Math.sin(h),i*Math.cos(h));m.normalize(),u.normalize(),m.rotateDirect(t.m_cosr,t.m_sinr),u.rotateDirect(t.m_cosr,t.m_sinr),e[0].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getEndXY()),e[1].setSub(e[2],e[0]);const c=m.crossProduct(u);return e[1].assign(m.mul(e[1].crossProduct(u)/c)),e[1].addThis(e[0]),r=Math.cos(.5*o),r}function Zh(t,e,s,i,o){if(i){const s=.5,n=Math.sqrt(e),i=ot(1-s)+2*n*s*(1-s)+ot(s),r=t[0].mul(ot(1-s)).add(t[1].mul(2*n*s*(1-s))).add(t[2].mul(ot(s))).divThis(i);return o.constructCircularArcThreePoint(t[0],t[2],r),!0}const a=t[0].sub(t[1]),h=t[2].sub(t[1]),m=a.crossProduct(h),l=a.dotProduct(h),u=e;n(u<=1),n(u>0);const c=.5/(1-u),g=a.sqrLength(),d=l,_=h.sqrLength(),p=ot(m),f=a.sub(h).sqrLength();if(0===p)return Gh(o,t[0],t[2],1),!1;if(l<=-Math.sqrt(g)*Math.sqrt(_))return Gh(o,t[0],t[2],1),!1;const x=[0,0],y=new r;y.setInfinite();const P=$n(2*p,-(f/u+4*d),2*(1-u)/u,y,!1,x);if(0===P)return Gh(o,t[0],t[2],1),!1;1===P&&(x[1]=x[0]);const C=Math.sqrt(c/x[0]),E=Math.sqrt(c/x[1]),S=.5/u;let v=S-_*x[0],I=S-g*x[0];Math.abs(v)>Math.abs(I)?I=d*x[0]-S+1:v=d*x[0]-S+1;const b=a.mul(v).add(h.mul(I)),w=b.norm(1)<1e-15*C?0:Math.atan2(b.y,b.x)+Math.PI,D=a.add(h),T=s?s.clone():t[1].add(D.mul(c)),N=t[0].sub(T),A=t[2].sub(T),M=N.crossProduct(A)<0;return new eh,o.constructEllipticArcEndPointsCenter(t[0],t[2],C,E/C,w,!1,!M,T)}function Qh(t){const e=hn(t);let s=!1;{const n=new l(t.m_semiMajorAxis*Math.cos(t.m_startAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle));n.rotateDirect(t.m_cosr,t.m_sinr),n.addThis(t.m_center),s=l.distance(t.getStartXY(),n)>e}let n=!1;if(!s){const s=new l(t.m_semiMajorAxis*Math.cos(t.m_startAngle+t.m_sweepAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle+t.m_sweepAngle));s.rotateDirect(t.m_cosr,t.m_sinr),s.addThis(t.m_center),n=l.distance(t.getEndXY(),s)>e}return!s&&!n}function Kh(t){if(qh(t))return 0;if(t.isDegenerate(0))return 0;const e=t.m_semiMajorAxis,s=t.getSemiMinorAxis(),n=e*e+s*s,i=t.getStartAngle(),r=t.getEndAngle(),o=t.m_center.y-t.m_YStart,a=t.m_cosr,h=t.m_sinr;let m=1,l=0;t.m_rotation&&(m=(a-h)*(a+h),l=2*a*h);const u=((-.5*(r-i)+.25*m*(2*Math.cos(r+i)*Math.sin(r-i)))*s+-2*Math.sin(.5*(r+i))*Math.sin(.5*(r-i))*a*o)*e/n;let c=0;return t.m_rotation&&(c=-2*Math.sin(r+i)*Math.sin(r-i)*.125*l-s*o/n*(2*Math.cos(.5*(r+i))*Math.sin(.5*(r-i)))*h),n*(u+c)+-.5*(t.m_XEnd-t.m_XStart)*(t.m_YEnd-t.m_YStart)}function Jh(t){t.queryCoord2D(.5,t.m_interior)}function $h(t,e,s,n,i){if(i){if(0!==hm(e,s))return 2}else if(zs(e,s))return 1;return 0!==tm(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function tm(t,e,s,i,o,a,m,u,c,g){if(qh(e))return wn(new pm({start:e.getStartXY(),end:e.getEndXY()}),s,i,o,a,m,u,g);null!==o&&(o.length=0),null!==a&&(a.length=0),null!==i&&(i.length=0);const d=mn(e,s);if(ln(e,s,m=Math.max(d,m)))return 0;const _=s.getStartXY();_.subThis(e.m_center);const p=s.getEndXY();p.subThis(e.m_center),_.rotateReverse(e.m_cosr,e.m_sinr),p.rotateReverse(e.m_cosr,e.m_sinr);const f=p.clone();f.subThis(_);const x=e.m_semiMajorAxis,y=1/x,P=e.getSemiMinorAxis(),C=1/P,E=f.clone();E.leftPerpendicularThis();const S=Math.atan2(P*E.y,x*E.x),v=h(16,Number.NaN),I=h(16,Number.NaN);let b=0;const w=[S,S+Math.PI];for(let t=0;t<2;++t){const n=bh(e,w[t]);if(n>=0&&n<=1){v[b]=n;const t=e.getCoord2D(v[b]);I[b]=s.getClosestCoordinate(t,!1),l.distance(t,s.getCoord2D(I[b]))<=m&&b++}}const D=_.x*y,T=_.y*C,N=f.x*y,A=f.y*C;let M=$n(N*N+A*A,2*(D*N+T*A),D*D+T*T-1,r.unit(),!1,I);n(M>=0);for(let t=0;t<M;t++){const n=f.mul(I[t]).add(_);n.x*=y,n.y*=C;const i=bh(e,Math.atan2(n.y,n.x));if(i>=0&&i<=1){v[b]=i;const t=e.getCoord2D(i);I[b]=s.getClosestCoordinate(t,!1),l.distance(t,s.getCoord2D(I[b]))<=m&&b++}}n(b<v.length+4);const G=h(16,Number.NaN);M=e.intersectPoint(s.getStartXY(),G,m);for(let t=0;t<M;t++,b++)v[b]=G[t],I[b]=0;M=e.intersectPoint(s.getEndXY(),G,m);for(let t=0;t<M;t++,b++)v[b]=G[t],I[b]=1;M=s.intersectPoint(e.getStartXY(),G,m);for(let t=0;t<M;t++,b++)v[b]=0,I[b]=G[t];M=s.intersectPoint(e.getEndXY(),G,m);for(let t=0;t<M;t++,b++)v[b]=1,I[b]=G[t];return 0===b?0:cm(t,e,s,v,I,b,i,o,a,m,u,0,g)}function em(t,e,s,i,r,o,a,h,m,u){if(qh(e)){const n=new pm({start:e.getStartXY(),end:e.getEndXY()});return tm(t,s,n,i,o,r,a,h,0,!0)}if(qh(s)){const n=new pm({start:s.getStartXY(),end:s.getEndXY()});return tm(t,e,n,i,r,o,a,h,0,u)}const c=mn(e,s);a=Math.max(a,c);let g=!1;{const t=e.getSemiAxes(),i=e.getCenter(),u=s.getSemiAxes(),c=s.getCenter(),d=l.distance(c,i),_=t.x+u.x;if(d>_+a)return 0;if(t.y>u.x){if(d+u.x+a<t.y)return 0}else if(u.y>t.x&&d+t.x+a<u.y)return 0;if(m&&!h){const i=1===e.m_minorMajorRatio&&e.isClosed()&&e.isMajor(),a=1===s.m_minorMajorRatio&&s.isClosed()&&s.isMajor();if(i&&a&&(g=!0,d<=_)&&Math.max(t.x,u.x)<=Math.min(t.x,u.x)+d)return n(!r&&!o),1}}if(!g&&ln(e,s,a))return 0;const d=[],_=[],p=!1,f=!1,x=mh(e,0,0,p,f,d,_,null),y=[],P=[],C=mh(s,0,0,p,f,y,P,null);if(1===x&&1===C){const t=new pi({points:d,weights:_}),n=new pi({points:y,weights:P}),l=[],c=[],g=Aa(!1,t,n,i,null===r?null:l,null===o?null:c,a,h,m,u);if(g>0&&null!==r||null!==o){r&&(r.length=0),o&&(o.length=0);for(let i=0;i<g;++i){if(r)if(M(l[i],0,1))r.push(l[i]);else{const s=t.tToLength(l[i]),n=e.lengthToT(s);r.push(n)}if(o)if(M(c[i],0,1))o.push(c[i]);else{const t=n.tToLength(c[i]),e=s.lengthToT(t);o.push(e)}}}return g}let E=[];const S=[];let v=0;const I=m&&!h;for(let t=0;t<x;t++){const n=new pi({points:d.slice(2*t,2*t+3),weights:_.slice(2*t,2*t+3)});let i=0;for(let r=0;r<C;r++){S.length<=r&&S.push(new pi({points:y.slice(2*r,2*r+3),weights:P.slice(2*r,2*r+3)}));const o=[],h=[],m=I?null:o,l=I?null:h,u=Aa(!1,n,S[r],null,m,l,a,!1,I,!1);if(u>0&&I)return 1;for(let a=0;a<u;++a){if(0===o[a]&&0===t)o[a]=0;else if(1===o[a]&&t===x-1)o[a]=1;else{const t=n.tToLength(o[a])+v,s=e.lengthToT(t);o[a]=s}if(0===h[a]&&0===r)h[a]=0;else if(1===h[a]&&r===C-1)h[a]=1;else{const t=S[r].tToLength(h[a])+i,e=s.lengthToT(t);h[a]=e}E.push(ft(o[a],h[a]))}i+=S[r].calculateLength2D()}v+=n.calculateLength2D()}if(0===E.length)return 0;if(h&&(E=E.filter(t=>!M(t.first,0,1)||!M(t.second,0,1)||!e.getCoord2D(t.first).equals(s.getCoord2D(t.second)))),m)return E.length;const b=[],w=[];for(const t of E)b.push(t.first),w.push(t.second);return cm(t,e,s,b,w,b.length,i,r,o,a,h,0,u)}function sm(t,e,s){if(s.setCoords(t.getCoord2D(e.vmin)),s.mergeNe(t.getCoord2D(e.vmax)),qh(t))return;const n=t.getSemiAxes(),i=[0,0,0,0];{const e=Math.atan2(-n.y*t.m_sinr,n.x*t.m_cosr),s=e+Math.PI,r=Math.atan2(n.y*t.m_cosr,n.x*t.m_sinr),o=r+Math.PI;i[0]=bh(t,e),i[1]=bh(t,s),i[2]=bh(t,r),i[3]=bh(t,o)}const r=new l;for(let n=0;n<4;n++){const o=i[n];e.containsExclusiveCoordinate(o)&&(t.queryCoord2D(o,r),s.mergeNe(r))}}function nm(t,e,s,i,o){if(0===t.m_semiMajorAxis)return s.vmin;let a=l.getNAN();t.queryCoord2D(s.vmin,a);let m=l.getNAN();if(t.queryCoord2D(s.vmax,m),qh(t))return new pm({start:a,end:m}).getClosestCoordinate(e,i);const u=Ph(t,e);if(a=Ph(t,a),m=Ph(t,m),1===t.m_minorMajorRatio){if(u.isEqual(0,0))return s.vmin;const e=bh(t,Math.atan2(u.y,u.x));return i||s.containsCoordinate(e)?e:l.distance(u,a)<=l.distance(u,m)?s.vmin:s.vmax}const c=t.getSemiMajorAxis(),g=t.getSemiMinorAxis(),d=(c-g)*(c+g),_=ot(d),p=u.x,f=u.y,x=ot(g*f),y=g*d*f*2,P=[new v(x),new v(y),new v(_-ot(c*p)-x),new v(-y),new v(-_)],C=T(v,4),E=hi(P,4,new r(-1,1),!1,C,4);let S=s.vmin,I=l.sqrDistance(u,a);{const t=l.sqrDistance(u,m);t<I&&(S=s.vmax,I=t)}n(!i);let b=h(8,Number.NaN);for(let e=0;e<E;++e){const s=C[e].value(),n=Math.sqrt(1-s*s),i=Math.atan2(s,n),r=Math.atan2(s,-n);b[2*e]=bh(t,i),b[2*e+1]=bh(t,r)}b=b.slice(0,2*E),lt(b);for(let n=0,i=2*E;n<i;++n)if(b[n]>s.vmin&&b[n]<s.vmax){const s=l.sqrDistance(e,t.getCoord2D(b[n]));I>s&&(I=s,S=b[n])}return S}function im(t,e,s){return t.m_semiMajorAxis===e.m_semiMajorAxis&&t.isMajor()!==e.isMajor()&&!!t.m_center.equals(e.m_center)&&t.m_sinr===e.m_sinr&&t.m_cosr===e.m_cosr&&t.m_minorMajorRatio===e.m_minorMajorRatio&&(s?t.isClockwise()!==e.isClockwise():t.isClockwise()===e.isClockwise())}function rm(t,e,s,i){const o=t.getStartXY(),a=t.getEndXY(),h=o.equals(a),m=e.equals(s);if(!h&&!m){const n=new Ps;return n.initializeFromTwoPoints(o,a,e,s),Yh(t,n,!0,e,s),t.endPointModified(),void t.normalizeAfterEndpointChange()}if(!t.isMajor())return void Gh(t,e,s,1);if(h&&m){const n=t.m_center.add(e.sub(o));return void t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),n)}if(!h){const n=.5*(ht()-Math.abs(t.getSweepAngle())),i=(t.getSweepAngle()+n*gt(t.getSweepAngle()))/t.getSweepAngle(),r=new l;t.queryCoord2D(i,r),t.constructEllipticArcEndPointsCenter(r,r,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.getCenter());const o=t.getCenter().add(e.sub(r));return void t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),o)}const u=l.sqrDistance(e,s);let c=.25,g=.75;if(u<l.sqrDistance(t.getCoord2D(.25),t.getCoord2D(.75))){const e=[0],s=Jn(new yh(t,u),r.construct(0,.25),1,e);s>0&&(n(1===s),c=e[0],g=1-e[0])}const d=t.getCoord2D(c),_=t.getCoord2D(g);n(!d.equals(_)),t.constructEllipticArcEndPointsCenter(d,_,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.m_center),rm(t,e,s)}function om(t,e,s,n,i){return am(t,!1,e,s,n,i)}function am(t,e,s,i,r,a){const h=s.getGeometryType(),m=i.getGeometryType(),l=Math.max(r,mn(s,i));if(h===o.enumLine&&m===o.enumLine)return bn(s,i,l,a);let u=s,c=i,g=s.getStartXY(),d=s.getEndXY();if(g.compare(d)>0&&(u=s.clone().reverse()),g=i.getStartXY(),d=i.getEndXY(),g.compare(d)>0&&(c=i.clone().reverse()),e){if(s.equals(i))return 2;if(function(t,e,s){return n(t.isCurve()||e.isCurve()),!!(t.getStartXY().equals(e.getStartXY())&&Zs(t,e,0,0,s,2,[0,0],[0,0])||t.getEndXY().equals(e.getEndXY())&&Zs(t,e,1,1,s,2,[0,0],[0,0])||t.getStartXY().equals(e.getEndXY())&&Zs(t,e,0,1,s,2,[0,0],[0,0])||t.getEndXY().equals(e.getStartXY())&&Zs(t,e,1,0,s,2,[0,0],[0,0]))}(s,i,l))return 4}switch(h){case o.enumLine:switch(m){case o.enumEllipticArc:return $h(t,c,u,l,a);case o.enumBezier:return vo(t,c,u,l,a);case o.enumRationalBezier2:return ba(t,c,u,l,a);case o.enumBezier2:return cr(t,c,u,l,a);default:P("")}break;case o.enumEllipticArc:switch(m){case o.enumLine:return $h(t,u,c,l,a);case o.enumEllipticArc:return function(t,e,s,n,i){if(i){if(0!==hm(e,s))return 2}else if(zs(e,s))return 1;return 0!==em(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,u,c,l,a);case o.enumBezier:return Io(t,c,u,l,a);case o.enumRationalBezier2:return wa(t,c,u,l,a);case o.enumBezier2:return gr(t,c,u,l,a);default:P("")}break;case o.enumBezier:switch(m){case o.enumLine:return vo(t,u,c,l,a);case o.enumEllipticArc:return Io(t,u,c,l,a);case o.enumBezier:return function(t,e,s,n,i){if(i){if(0!==hm(e,s))return 2}else if(zs(e,s))return 1;return 0!==No(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,u,c,l,a);case o.enumRationalBezier2:return bo(t,u,c,l,a);case o.enumBezier2:return wo(t,u,c,l,a);default:P("")}break;case o.enumRationalBezier2:switch(m){case o.enumLine:return ba(t,u,c,l,a);case o.enumEllipticArc:return wa(t,u,c,l,a);case o.enumBezier:return bo(t,c,u,l,a);case o.enumRationalBezier2:return function(t,e,s,n,i){if(i){const n=hm(e,s);if(0!==n){if(t){if(1===n){if(e.m_weights[0]===s.m_weights[0]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[2])return 2}else if(e.m_weights[0]===s.m_weights[2]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[0])return 2;return 4}return 2}}else if(zs(e,s))return 1;return 0!==Aa(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,u,c,l,a);case o.enumBezier2:return Da(t,u,c,l,a);default:P("")}break;case o.enumBezier2:switch(m){case o.enumLine:return cr(t,u,c,l,a);case o.enumEllipticArc:return gr(t,u,c,l,a);case o.enumBezier:return wo(t,c,u,l,a);case o.enumRationalBezier2:return Da(t,c,u,l,a);case o.enumBezier2:return function(t,e,s,n,i){if(i){if(0!==hm(e,s))return 2}else if(zs(e,s))return 1;return 0!==pr(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}(t,u,c,l,a);default:P("")}break;default:P("")}}function hm(t,e,s=!0){if(!s&&!mm(t,e))return 0;const n=t.isLine()&&e.isLine();if(t.getStartXY().equals(e.getStartXY())&&t.getEndXY().equals(e.getEndXY())){const s=1;if(n)return s;const i=t.getGeometryType();if(i!==e.getGeometryType())return 0;if(i===o.enumBezier){const n=t,i=e;return n.getControlPoint1().equals(i.getControlPoint1())&&n.getControlPoint2().equals(i.getControlPoint2())?s:0}if(i===o.enumEllipticArc)return im(t,e,!1)?s:0;if(i===o.enumRationalBezier2){const n=t,i=e;if(n.getControlPoint1().equals(i.getControlPoint1())&&n.getStandardFormWeight()===i.getStandardFormWeight())return s}else if(i===o.enumBezier2){const n=e;if(t.getControlPoint1().equals(n.getControlPoint1()))return s}return 0}if(t.getStartXY().equals(e.getEndXY())&&t.getEndXY().equals(e.getStartXY())){const s=-1;if(n)return s;const i=t.getGeometryType();if(i!==e.getGeometryType())return 0;if(i===o.enumBezier){const n=t,i=e;return n.getControlPoint1().equals(i.getControlPoint2())&&n.getControlPoint2().equals(i.getControlPoint1())?s:0}if(i===o.enumEllipticArc)return im(t,e,!0)?s:-1;if(i===o.enumRationalBezier2){const n=t,i=e;if(n.getControlPoint1().equals(i.getControlPoint1())&&n.getStandardFormWeight()===i.getStandardFormWeight())return s}else if(i===o.enumBezier2){const n=e;if(t.getControlPoint1().equals(n.getControlPoint1()))return s}return 0}return 0}function mm(t,e){const s=t.getGeometryType();return s===e.getGeometryType()&&(s!==o.enumEllipticArc||t.projectionBehavior()===e.projectionBehavior())}function lm(t,e,n,i,r,a,h){!r&&a&&s("");const m=e.getGeometryType(),l=n.getGeometryType(),u=Math.max(h,mn(e,n));if(i&&(i.length=0),r&&(r.length=0),a&&(a.length=0),m===o.enumLine&&l===o.enumLine)return wn(e,n,i,r,a,u,!1,!1);let c=e,g=n,d=e.getStartXY(),_=e.getEndXY(),p=!1,f=!1;d.compare(_)>0&&(c=e.clone(!0).reverse(),p=!0),d=n.getStartXY(),_=n.getEndXY(),d.compare(_)>0&&(g=n.clone(!0).reverse(),f=!0);let x=0;switch(m){case o.enumLine:switch(l){case o.enumEllipticArc:x=tm(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumBezier:x=Do(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumRationalBezier2:x=Ta(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumBezier2:x=dr(t,g,c,i,a,r,u,!1,0,!0);break;default:P("")}break;case o.enumEllipticArc:switch(l){case o.enumLine:x=tm(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumEllipticArc:x=em(t,c,g,i,r,a,u,!1,!1,!1);break;case o.enumBezier:x=To(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumRationalBezier2:x=Na(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumBezier2:x=_r(t,g,c,i,a,r,u,!1,0,!0);break;default:P("")}break;case o.enumRationalBezier2:switch(l){case o.enumLine:x=Ta(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumEllipticArc:x=Na(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumBezier:x=Ao(t,g,c,i,a,r,u,!1,!1,!0);break;case o.enumRationalBezier2:x=Aa(t,c,g,i,r,a,u,!1,!1,!1);break;case o.enumBezier2:x=Ma(t,c,g,i,r,a,u,!1,0,!1);break;default:P("")}break;case o.enumBezier2:switch(l){case o.enumLine:x=dr(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumEllipticArc:x=_r(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumBezier:x=Mo(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumRationalBezier2:x=Ma(t,g,c,i,a,r,u,!1,0,!0);break;case o.enumBezier2:x=pr(t,c,g,i,r,a,u,!1,!1,!1);break;default:P("")}break;case o.enumBezier:switch(l){case o.enumLine:x=Do(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumEllipticArc:x=To(t,c,g,i,r,a,u,!1,0,!1);break;case o.enumBezier:x=No(t,c,g,i,r,a,u,!1,!1,!1);break;case o.enumRationalBezier2:x=Ao(t,c,g,i,r,a,u,!1,!1,!1);break;case o.enumBezier2:x=Mo(t,c,g,i,r,a,u,!1,0,!1);break;default:P("")}break;default:P("")}if(p){if(r){for(let t=0;t<x;t++)r[t]=1-r[t];r.reverse()}i&&i.reverse(),a&&a.reverse()}if(f&&a)for(let t=0;t<x;t++)a[t]=1-a[t];return x}function um(t,e,s){return e===s?0:(e>s&&(s=p(e,e=s)),t.cut(e,s,!0).calculateUpperLength2D())}function cm(t,e,s,n,i,o,a,h,m,u,c,g,d){if(!o)return 0;const _=(t,e)=>{for(let s=0;s<o;++s){let n=e[s];if(M(n,0,1)){n=wt(n);continue}const i=t.getCoord2D(n);n<.5?i.equals(t.getStartXY())&&um(t,0,n)<=hn(t)&&(e[s]=0):i.equals(t.getEndXY())&&um(t,n,1)<=hn(t)&&(e[s]=1)}};_(e,n),_(s,i),function(t,e,s,n,i){const o=[],a=[],h=[];for(let r=0,m=i;r<m;r++)o.push(t.calculateSubLengthFromStart(s[r])),a.push(e.calculateSubLengthFromStart(n[r])),M(s[r],0,1)&&M(n[r],0,1)&&t.getCoord2D(s[r]).equals(e.getCoord2D(n[r]))&&h.push(r);if(0===h.length||h.length===i)return;h.sort((t,e)=>s[t]<s[e]?-1:s[t]>s[e]?1:n[t]<n[e]?-1:n[t]>n[e]?1:0);let m=-1;for(const u of h){if(m>=0&&s[u]===s[m]&&s[u]===s[m]){m=u;continue}m=u;const h=[];h.length=i;for(let t=0;t<h.length;++t)h[t]=t;h.sort((t,e)=>{const s=o[u],n=a[u],i=o[t]-s,r=a[t]-n,h=i*i+r*r,m=o[e]-s,l=a[e]-n,c=m*m+l*l;return h<c?-1:h>c?1:0});for(let o=0;o<i;o++){const i=h[o];if(i===u||s[i]===s[u]&&n[i]===n[u]||M(s[i],0,1)&&M(n[i],0,1))continue;const a=(s,n,i,r)=>{const o=new Rs,a=new v;a.setWithEps(1);const h=new v;h.set(n,a.eps()),t.queryCoord2DE(h,o);const m=new Rs;t.queryCoord2DE(new v(s),m);let l=!1;return o.eq(m)&&(h.set(r,a.eps()),e.queryCoord2DE(h,o),e.queryCoord2DE(new v(i),m),l=o.eq(m)),!l},m=l.getNAN();t.queryCoord2D(s[i],m);const c=l.getNAN();if(e.queryCoord2D(n[i],c),0===l.distance(m,c)&&a(s[u],s[i],n[u],n[i]))break;const g=new r(n[i],n[u]);g.normalizeNoNAN();const d=new r(s[i],s[u]);d.normalizeNoNAN();let _=-1,p=Number.POSITIVE_INFINITY,f=Number.POSITIVE_INFINITY,x=s[i];m.assign(t.getCoord2D(x));for(let r=0;r<5;r++){const r=e.getClosestCoordinateOnInterval(m,g,-1);c.assign(e.getCoord2D(r));const o=l.distance(m,c);if(x=t.getClosestCoordinateOnInterval(c,d,-1),x===s[u]&&r===n[u]){_=1;break}m.assign(t.getCoord2D(x));const h=l.distance(c,m);if(!(h<f&&o<p)){_=0;break}if(0===h&&0===o){a(s[u],s[i],n[u],n[i])?(s[i]=x,n[i]=r,_=0):_=1;break}f=h,p=o}if(-1===_&&(_=M(s[i],0,1)||M(n[i],0,1)?0:1),1!==_)break;s[i]=s[u],n[i]=n[u]}}}(e,s,n,i,o);const p=[];for(let t=0,e=o;t<e;t++)p.push(t);const f=(t,e)=>d?Dt(i[t],n[t],i[e],n[e]):Dt(n[t],i[t],n[e],i[e]);if(p.length>1){p.sort(f);const t=Math.max(hn(e),hn(s));let o=0;for(let r=1,a=p.length;r<a;r++){const a=n[p[o]],h=n[p[r]],m=i[p[o]],u=i[p[r]];if(a!==h||m!==u){if(um(e,a,h)<=t&&um(s,m,u)<=t&&!(M(a,0,1)&&M(m,0,1)||M(h,0,1)&&M(u,0,1))){const t=l.distance(e.getCoord2D(a),s.getCoord2D(m)),n=l.distance(e.getCoord2D(h),s.getCoord2D(u));if(t<=n)continue;if(n<t){p[o]=p[r];continue}continue}o++,p[o]=p[r]}}if(p.length=o+1,1===p.length&&0!==p[0]&&(n[0]=n[p[0]],i[0]=i[p[0]],p[0]=0),p.length>2){const t=r.constructEmpty(),o=r.constructEmpty();t.setCoords(n[p[0]],n[p.at(-1)]),o.setCoords(i[p[0]],i[p.at(-1)]);let a=!0;for(let e=1,s=p.length-1;e<s;e++)if(!t.containsCoordinate(n[p[e]])||!o.containsCoordinate(i[p[e]])){a=!1;break}if(a){const n=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let i=0;i<n.length;i++){let r=C(t.vmin,t.vmax,n[i]);const h=e.getCoord2D(r);if(!s.isCloserThanDistance(h,o,u)){a=!1;break}r=C(o.vmin,o.vmax,n[i]);const m=s.getCoord2D(r);if(!e.isCloserThanDistance(m,t,u)){a=!1;break}}}a&&(p[1]=p.at(-1),p.length=2)}}if(1===p.length&&t){const t=0,r=0;Zs(e,s,n[0],i[0],u,1,[t],[r])&&(p.push(1),n[1]=t,i[1]=r,p.sort(f))}if(c&&1===p.length){let t=!0;for(let r=0,o=p.length;r<o;r++)if(!M(n[p[r]],0,1)||!M(i[p[r]],0,1)||0!==l.distance(e.getCoord2D(n[p[r]]),s.getCoord2D(i[p[r]]))){t=!1;break}if(t)return 0}let x=0;for(let t=0,s=p.length;t<s;t++){if(h&&h.push(n[p[t]]),m&&m.push(i[p[t]]),a){const s=l.getNAN();e.queryCoord2D(n[p[t]],s),a.push(s)}x++}return x}function gm(t,e,s,n,i,r,o,a,h){if(M(s,0,1)&&M(n,0,1)&&0===l.distance(t.getCoord2D(s),e.getCoord2D(n))){const m=1e-12,l=new Rs,u=Number.EPSILON;if(t.queryDerivative(new v(s,u),l),l.isTrueZero()){const e=1===s?-1e-12:m;t.queryDerivative(new v(s,u).add(e),l)}1===s&&l.negateThis();const c=new Rs;if(e.queryDerivative(new v(n,u),c),c.isTrueZero()){const t=1===s?-1e-12:m;e.queryDerivative(new v(n,u).add(t),c)}1===n&&c.negateThis(),l.isZero()||l.normalize(),c.isZero()||c.normalize();const g=l.dotProduct(c),d=l.crossProduct(c);d.scaleError(3);const _=()=>{if(h)return.001;{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*i/Math.min(s,n),1e-10)}};if(g.ge(b)&&(d.isZero()||Math.abs(d.value())<_()))return js(t,e,s,n,i,r,o,a)}return 0}function dm(t,e,s,i,r){let o=-1,a=-1,m=-1,u=-1;{const n=[0,e],r=[e,0],h=[0,i],l=[i,0];for(let e=0;e<2&&-1===o;++e)for(let i=0;i<2;++i)if(t[n[e]].equals(s[h[i]])){o=n[e],a=r[e],m=h[i],u=l[i];break}}if(-1===o){const n=new Vs;n.setFromPoints(t,e+1);const o=new Vs;return o.setFromPoints(s,i+1),o.inflate(r),n.isIntersectingW(o)?-1:0}{const c=h(e+1,Number.NaN),g=Xr(t,e+1,c);n(g>1);let d=0,_=0;for(let t=0;t<g;++t)o===c[t]&&(_=t,d++),a===c[t]&&d++;if(2!==d)return-1;const p=h(i+1,Number.NaN),f=Xr(s,i+1,p);n(f>1),d=0;let x=0;for(let t=0;t<f;++t)m===p[t]&&(x=t,d++),u===p[t]&&d++;if(2!==d)return-1;const y=t[c[(_+g-1)%g]],P=t[c[(_+1)%g]],C=s[p[(x+f-1)%f]],E=s[p[(x+1)%f]],S=t[o],v=[y,P,C,E],I=[0,1,2,3];I.sort((t,e)=>l.compareVectorsOrigin(S,v[t],v[e]));let b=I[0];for(let t=1;t<4;t++){if(I[t]!==(b+1)%4)return-1;b=I[t]}{const t=y.sub(S),e=E.sub(S),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),o=i*t.length(),a=i*e.length();if(o<=r||a<=r)return-1}}{const t=P.sub(S),e=C.sub(S),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),o=i*t.length(),a=i*e.length();if(o<=r||a<=r)return-1}}return 1}}var _m=Ee;class pm extends xn{constructor(t){super(t||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(t){return this!==t&&(this.m_description=t.m_description,t.m_description=null,this.m_attributes=t.m_attributes,t.m_attributes=null,this.m_XStart=t.m_XStart,t.m_XStart=Number.NaN,this.m_YStart=t.m_YStart,this.m_XEnd=t.m_XEnd,t.m_XEnd=Number.NaN,this.m_YEnd=t.m_YEnd),this}assignCopy(t){return this!==t&&t.copyTo(this),this}calculateLowerLength3D(){return n(0),0}calculateUpperLength3D(){return n(0),0}changeEndPoints3D(t,e){n(0)}getClosestCoordinate3D(t,e,s){return n(0),0}getBoundary(){return Qn(this)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?Cn(this,t):En(this,t);const n=_m.getInterpolation(e),i=this.getStartAttributeAsDbl(e,s),r=this.getEndAttributeAsDbl(e,s);return Y(n,i,r,t,_m.getDefaultValue(e))}constructFromCoords(t,e,s,n){this.dropAllAttributes(),this.setStartXYCoords(t,e),this.setEndXYCoords(s,n)}construct(t,e){this.dropAllAttributes(),this.setStartXY(t),this.setEndXY(e)}construct3D(t,e){n(0)}constructPoint(t,e){this.assignVertexDescription(t.getDescription()),this.mergeVertexDescription(e.getDescription()),this.setStart(t),this.setEnd(e)}getGeometryType(){return pm.type}queryEnvelope(e){if(4===e.m_EnvelopeType){e.setEmpty(),e.assignVertexDescription(this.m_description);const s=t.constructEmpty();this.queryEnvelope(s),e.setEnvelope(s);for(let t=1,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t);for(let n=0,i=_m.getComponentCount(s);t<i;t++){const t=this.queryInterval(s,n);e.setIntervalEnvelope(s,n,t)}}}else 2===e.m_EnvelopeType?e.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):3===e.m_EnvelopeType?(e.setEmpty(),e.mergeCoords(this.m_XStart,this.m_YStart,rn(this,0,1,0)),e.mergeCoords(this.m_XEnd,this.m_YEnd,rn(this,1,1,0))):f("env type not impl")}applyTransformation(t){n(t instanceof Ps);const e=new l;e.x=this.m_XStart,e.y=this.m_YStart,t.transformInPlace(e),this.m_XStart=e.x,this.m_YStart=e.y,e.x=this.m_XEnd,e.y=this.m_YEnd,t.transformInPlace(e),this.m_XEnd=e.x,this.m_YEnd=e.y}createInstance(){return new pm({vd:this.m_description})}calculateLength2D(){return Math.sqrt(Gn(this))}calculateLength3D(t){return n(0),0}changeEndPoints2D(t,e){this.setStartXY(t),this.setEndXY(e),this.normalizeAfterEndpointChange()}queryControlPointsHelper(t){return n(t.length>=2),t[0]=this.getStartXY(),t[1]=this.getEndXY(),2}queryCoord2D(t,e){return yn(this,t,e)}queryCoord3D(t,e){n(0)}getCoordZ(t){return function(t,e){const s=t.getStartZ(),n=t.getEndZ();return C(s,n,e)}(this,t)}queryCoord2DE(t,e){Sn(this,t,e)}queryCoord2DMP(t,e){e.assignPoint2D(this.getStartXY());const s=Hs.constructPoint2D(this.getEndXY());s.subThis(e),s.mulThis(y.constructDouble(t)),e.addThis(s)}getCoordX(t){return Cn(this,t)}getCoordY(t){return En(this,t)}cut(t,e,s){const n=new fm;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createLine();n&&i.assignVertexDescription(this.m_description);const r=l.getNAN();if(yn(this,t,r),i.setStartXYCoords(r.x,r.y),yn(this,e,r),i.setEndXYCoords(r.x,r.y),!n)for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),r=_m.getComponentCount(n);for(let s=0;s<r;s++){const r=this.getAttributeAsDbl(t,n,s);i.setStartAttribute(n,s,r);const o=this.getAttributeAsDbl(e,n,s);i.setEndAttribute(n,s,o)}}}queryDerivative(t,e){!function(t,e,s){const n=Rs.constructPoint2D(t.getStartXY()),i=Rs.constructPoint2D(t.getEndXY());s.setCoordsE(i.x.subE(n.x),i.y.subE(n.y))}(this,0,e)}getClosestCoordinate(t,e){return l.getClosestCoordinate(this.getStartXY(),this.getEndXY(),t,e)}getClosestCoordinateOnInterval(t,e,s=-1){const n=new l;this.queryCoord2D(e.vmin,n);const i=new l;this.queryCoord2D(e.vmax,i);const r=l.getClosestCoordinate(n,i,t,!1);return gn.recalculateParentT(e.vmin,e.vmax,r)}intersectionOfYMonotonicWithAxisX(t,e){const s=this.m_YEnd-this.m_YStart;if(!s)return t===this.m_YEnd?e:Number.NaN;const n=(t-this.m_YStart)/s;let i=Cn(this,n);return 1===n&&(i=this.m_XEnd),i}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(t){const e=this.m_XStart-this.m_XEnd,s=this.m_YStart-this.m_YEnd;return Math.sqrt(e*e+s*s)<=t}isDegenerate3D(t,e){return n(0),!1}queryLooseEnvelope(t){this.queryEnvelope(t)}clone(t){const e=new pm;return this.copyTo(e),e}tToLength(t){return t*this.calculateLength2D()}lengthToT(t){const e=this.calculateLength2D();return 0!==e?t/e:0}calculateWeightedAreaCentroid2D(t){const e=new l;return e.setCoords(0,0),e}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}getTangent(t){const e=l.getNAN();return e.setSub(this.getEndXY(),this.getStartXY()),e}getDerivative(t){const e=new l;return e.setSub(this.getEndXY(),this.getStartXY()),e}getCurvature(t){return 0}isIntersectingPoint(t,e,s){return Tn(this,t,e,s)>=0}isIntersectingPoint3D(t,e,s,i,r=1){return n(0),!1}getYMonotonicParts(t,e){return 0}getMonotonicParts(t,e){return 0}getMonotonicPartParams(t,e){return e&&(t<2&&s(""),e[0]=0,e[1]=1),2}intersectionWithAxis2D(t,e,s,n){if(t){const t=this.m_YEnd-this.m_YStart;if(!t)return e===this.m_YEnd?-1:0;const i=(e-this.m_YStart)/t;return i<0||i>1?0:(s&&(s[0]=Cn(this,i)),n&&(n[0]=i),1)}{const t=this.m_XEnd-this.m_XStart;if(!t)return e===this.m_XEnd?-1:0;const i=(e-this.m_XStart)/t;return i<0||i>1?0:(s&&(s[0]=En(this,i)),n&&(n[0]=i),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(t,e){if(2===e.m_EnvelopeType){let s=A(t.vmin,0,1);const n=new l;return this.queryCoord2D(s,n),e.setCoords({pt:n}),s=A(t.vmax,0,1),this.queryCoord2D(s,n),void e.mergeNe(n)}f("3d dst not impl")}orientBottomUp(){In(this)}isLine(){return!0}isDegenerateToLineHelper(t){return!0}copyIgnoreAttributes(t){t.setStartXY(this.getStartXY()),t.setEndXY(this.getEndXY()),t.normalizeAfterEndpointChange()}calculateArea2DHelper(){return 0}absNormXYZ(t){return function(t,e){const s=t.getStartXYZ();s.z*=e;const n=t.getEndXYZ();return n.z*=e,s.norm(1)+n.norm(1)}(this,t)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(t,e){e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax))}setSegmentFromCoordsForStitcher(t,e){vn(this,t[0],t[e-1])}writeInBufferStream(t,e){return n(0),0}readFromBufferStream(t,e){n(0)}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return!1}setCoordsForIntersector(t,e,s){vn(this,t,e)}static isIntersectingLineLine(t,e,s,n){return bn(t,e,s,n)}static isIntersectingLineLine_(t,e,s,n){return bn(t,e,s,n)}copyToImpl(t){}reverseImpl(){}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}swapImpl(t){}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(t,e,s,n,i){return lm(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){e.length<1&&i("");const n=Tn(this,t,s,!1);return n>=0?(e&&(e[0]=n),1):0}isIntersecting(t,e,s){return 0!==om(!1,this,t,e,s)}}pm.type=o.enumLine;class fm{constructor(t){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new pm,this.m_mask=0,this.m_active=0,void 0!==t&&(t.copy?t.copy.copyTo(this,!1):t.move?this.assignMove(t.move):t.segment?this.copyFrom(t.segment,!!t.bIgnoreAttributes):P("bad constructor params"))}assignCopy(t){return t instanceof fm?this!==t&&t.copyTo(this,!1):this.copyFrom(t,!1),this}assignMove(t){if(t instanceof fm){if(this===t)return this;this.reset(),1&t.m_mask&&(this.m_lineBuffer=t.m_lineBuffer,t.m_lineBuffer=null,this.m_mask=1),this.m_curves=t.m_curves,this.m_mask=t.m_mask,this.m_active=t.m_active,t.reset(),this.m_seg=this.activeSegment(),t.m_seg=null}else{if(this.m_seg===t)return this;this.create(t.getGeometryType()),this.m_seg.swap(t)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:P("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return null===this.m_seg}copyTo(t,e){this!==t&&(this.empty()?t.m_seg=null:t.copyFrom(this.m_seg,e))}copyToWithZ(t,e){n(0)}createImpl(t){switch(t){case o.enumLine:1&this.m_mask||(this.m_lineBuffer=new pm,this.m_mask|=1,this.m_active=1);break;case o.enumEllipticArc:2&this.m_mask||(this.m_curves=new eh,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case o.enumBezier:4&this.m_mask||(this.m_curves=new jo,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case o.enumBezier2:8&this.m_mask||(this.m_curves=new xi,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case o.enumRationalBezier2:16&this.m_mask||(this.m_curves=new pi,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:s("")}}create(t){t===o.enumLine?this.createLine():t===o.enumEllipticArc?this.createEllipticArc():t===o.enumBezier?this.createCubicBezier():t===o.enumRationalBezier2?this.createQuadraticRationalBezier():t===o.enumBezier2?this.createQuadraticBezier():s("Segment_buffer.create")}copyFrom(t,e){this.m_seg!==t&&(this.create(t.getGeometryType()),e?t.copyIgnoreAttributes(this.m_seg):t.copyTo(this.m_seg))}copyFromWithZ(t,e){n(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(o.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(o.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(o.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(o.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(o.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,0===this.m_active&&P("releaseSegment"),1&this.m_active){const t=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,t}let t;return 2&this.m_active?t=this.arc():4&this.m_active?t=this.bezier3():8&this.m_active?t=this.bezier2():16&this.m_active?t=this.rbezier2():P("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,t}equals(t){return t instanceof fm?this===t||(this.empty()?t.empty():!t.empty()&&this.get().equals(t.get())):(f("seg comparison not yet impl"),!1)}}class xm{constructor(t){if(this.m_geom=this.m_sr=null,t){if(t.move)return this.m_geom=t.move.m_geom,t.move.m_geom=null,this.m_sr=t.move.m_sr,void(t.move.m_sr=null);if(t.copy)return this.m_geom=t.copy.m_geom?t.copy.m_geom.clone():null,void(this.m_sr=t.copy.m_sr);t.geom&&(this.m_geom=t.geom),t.sr&&(this.m_sr=t.sr)}}getGeometry(){return this.m_geom}getSpatialReference(){return this.m_sr}setGeometry(t){this.m_geom=t}setSpatialReference(t){this.m_sr=t}equals(t,e){const s=t;return!(!this.m_sr&&s.m_sr||this.m_sr&&!s.m_sr||!this.m_geom&&s.m_geom||this.m_geom&&!s.m_geom||this.m_sr&&s.m_sr&&!this.m_sr.equals(s.m_sr)||this.m_geom&&s.m_geom&&!this.m_geom.equals(s.m_geom,e))}clone(){let t=null;return this.m_geom&&(t=this.m_geom.clone()),new xm({geom:t,sr:this.m_sr})}hasGeom(){return!!this.m_geom}}class ym{constructor(t){this.m_factor=1,this.m_wkid=0,this.m_peUnit=null,t&&(this.m_peUnit=t,this.m_factor=t.getUnitFactor(),this.m_wkid=t.getCode(),this.m_wkid<0&&(this.m_wkid=0))}getName(){return this.m_peUnit?this.m_peUnit.getName():""}getID(){return this.m_wkid}getConversionFactor(t){return this.getUnitType()!==t.getUnitType()&&s("unit type mismatch"),this.getUnitToBaseFactor()/t.getUnitToBaseFactor()}getUnitToBaseFactor(){return this.m_factor}getHashCode(){return Vt(Yt(this.getUnitType()),Yt(this.getUnitToBaseFactor()))}equals(t){return!!t&&this.getUnitType()===t.getUnitType()&&this.getUnitToBaseFactor()===t.getUnitToBaseFactor()&&this.getID()===t.getID()&&this.getName()===t.getName()}static isValidWkid(t){return!1}}function Pm(t,e,s,n,i){return Cm(t,e,null,s,n,i)}function Cm(i,r,a,h,m,l){const u=i.getGeometryType();if(u===o.enumPoint){const t=i.getXY();return r.contains(t)?i:i.createInstance()}if(u===o.enumEnvelope){const e=t.constructEmpty();if(i.queryEnvelope(e),e.intersect(r)){const t=i.clone();return t.setEnvelope(e),t}return i.createInstance()}if(i.isEmpty())return i;if(r.isEmpty())return i.createInstance();const c=r.clone();{const e=new t;if(i.queryLooseEnvelope(e),c.containsEnvelope(e))return i;if(!c.isIntersecting(e))return i.createInstance();0===m&&(e.intersect(c),e.inflate(Math.max(.1*e.maxDimension(),1)),e.intersect(c),c.assign(e))}let g=h;if((null!==a||Number.isNaN(g))&&(g=Oe(a,c,!1).total()),u===o.enumGeometryCollection){const t=i,e=i.createInstance();for(let s=0,n=t.getGeometryCount();s<n;s++){const n=t.getGeometry(s);if(n.isEmpty())continue;const i=Pm(n,c,g,m,l);i.isEmpty()||(i===n?e.addGeometry(i.clone()):e.addGeometry(i))}return e}e(u)||s("Clip: geometry not supported");const d=i.getImpl().getAccelerators();if(null!==d){const t=d.getRasterizedGeometry();n(null===t)}switch(u){case o.enumMultiPoint:{const t=i;let e;const s=t.getPointCount(),r=t.getImpl().getAttributeStreamRef(0);let o=0;for(let n=0;n<s;n++){const s=r.readPoint2D(2*n);c.contains(s)||(0===o&&(e=t.createInstance()),o<n&&e.addPoints(t,o,n),o=n+1)}return o>0&&e.addPoints(t,o,s),0===o?t:(n(null!==e),e)}case o.enumPolygon:case o.enumPolyline:return function(t,e,s,n,i){return new Em(e,i).clipMultiPath2(t,s,n)}(i,c,g,m,l);default:P("")}}class Em{constructor(e,s){this.m_shape=new Vr,this.m_geometry=Ar,this.m_verticesOnExtentIndex=-1,this.m_verticesOnExtent=[],this.m_progressCounter=0,this.m_extent=new t(e),this.m_progressTracker=s}progress_(){}clipMultiPath2(t,e,s){return t.getGeometryType()===o.enumPolygon?this.clipPolygonOrProjectedPolyline2(t,s):this.clipPolyline(t,e)}clipPolygonOrProjectedPolyline2(e,s){const i=e.getGeometryType()===o.enumPolyline;if(0===this.m_extent.width()||0===this.m_extent.height())return e.createInstance();const r=t.constructEmpty();e.queryLooseEnvelope(r),this.m_geometry=i?this.m_shape.addGeometry(e):this.m_shape.addGeometry(e,this.m_extent);const a=t.constructEmpty(),m=t.constructEmpty(),u=new l,c=new l,g=h(9,Number.NaN),d=h(9,Number.NaN),_=T(l,9);let p=null;const f=new pm,x=[];let y=!1;for(let t=0;!y&&t<4;t++){let e=!1;const s=!!(1&t);let o=0;switch(t){case 0:o=this.m_extent.xmin,e=r.xmin<=o&&r.xmax>=o;break;case 1:o=this.m_extent.ymin,e=r.ymin<=o&&r.ymax>=o;break;case 2:o=this.m_extent.xmax,e=r.xmin<=o&&r.xmax>=o;break;case 3:o=this.m_extent.ymax,e=r.ymin<=o&&r.ymax>=o}if(e){y=!0;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Ar;){let r=!0,h=-1,l=-1;const P=this.m_shape.getFirstVertex(e);let C=P;do{this.progress_(),p=this.m_shape.getSegment(C);let e=p;if(null===e){const t=this.m_shape.getNextVertex(C);if(t===Ar){n(i),0===h&&x.push(C);break}this.m_shape.queryXY(C,u),f.setStartXY(u),this.m_shape.queryXY(t,c),f.setEndXY(c),e=f}e.queryLooseEnvelope(a);let P=Em.checkSegmentIntersection(a,t,o);e.isCurve()&&0===P&&e.isCurve()&&(f.setStartXY(e.getStartXY()),f.setEndXY(e.getEndXY()),this.m_shape.replaceCurveWithLine(C),e=f,f.queryEnvelope(a),P=Em.checkSegmentIntersection(a,t,o));let E=0,S=Ar;if(-1===P){const i=e.intersectionWithAxis2D(s,o,g,d);if(i>0){let t=null;if(e.isCurve()){t=_,n(i<=9);for(let t=0;t<i;t++)s?_[t].setCoords(g[t],o):_[t].setCoords(o,g[t]);E=this.m_shape.splitSegmentAxisAware(C,d,i,t,s?1:0)}else E=this.m_shape.splitSegmentAxisAware(C,d,i,null,-1)}else E=0;E+=1;let a=C,P=this.m_shape.getNextVertex(a);e=null;for(let e=0;e<E;e++){this.m_shape.queryXY(a,u),this.m_shape.queryXY(P,c),p=this.m_shape.getSegment(a);let e=p;null===e&&(f.setStartXY(u),f.setEndXY(c),e=f),e.queryEnvelope(m);let n=Em.checkSegmentIntersection(m,t,o);e.isCurve()&&0===n&&(this.m_shape.replaceCurveWithLine(a),f.setStartXY(u),f.setEndXY(c),e=f,e.queryEnvelope(m),n=Em.checkSegmentIntersection(m,t,o)),-1===n&&(s?Math.abs(u.y-o)<Math.abs(c.y-o)?(u.y=o,this.m_shape.setXY(a,u)):(c.y=o,this.m_shape.setXY(P,c)):Math.abs(u.x-o)<Math.abs(c.x-o)?(u.x=o,this.m_shape.setXY(a,u)):(c.x=o,this.m_shape.setXY(P,c)),p=this.m_shape.getSegment(a),e=p,null===e&&(f.setStartXY(u),f.setEndXY(c),e=f),e.queryEnvelope(m),n=Em.checkSegmentIntersection(m,t,o),-1===n&&(n=Em.checkSegmentIntersectionLoose(m,t,o)));const i=h;h=n,-1===l&&(l=h),0===i&&1===h||1===i&&0===h||0===i&&0===h&&x.push(a),1===h&&(y=!1,r=!1),a=P,S=a,P=this.m_shape.getNextVertex(P)}}if(0===E){const t=h;h=P,-1===l&&(l=h),0===t&&h>=1||t>=1&&0===h||0===t&&0===h&&x.push(C),1===h&&(y=!1,r=!1),S=this.m_shape.getNextVertex(C)}if(C=S,x.length>=256){for(let t=1,e=x.length-1;t<e;t++){const e=x[t];i?this.m_shape.snapVertexForPoleClipping(e,o):this.m_shape.removeVertex(e,!1)}x[1]=x.at(-1),x.length=2}}while(C!==P);if(!r){0!==l||!i&&0!==h&&2!==h||x.push(P);for(let t=0,e=x.length;t<e;t++){const e=x[t];i?this.m_shape.snapVertexForPoleClipping(e,o):this.m_shape.removeVertex(e,!1)}}x.length=0,e=r||0===this.m_shape.getPathSize(e)?this.m_shape.removePath(e):this.m_shape.getNextPath(e)}}}if(y)return e.createInstance();p=null,i?this.removeSpikesAlongPoles():this.resolveBoundaryOverlaps(),s>0&&this.densifyAlongClipExtent(s);const P=this.m_shape.getGeometry(this.m_geometry);return P.getGeometryType()===o.enumPolygon&&P.setFillRule(e.getFillRule()),P}clipPolyline(e,s){const n=t.constructEmpty(),i=t.constructEmpty(),r=h(9,Number.NaN),o=h(9,Number.NaN),a=new fm;let m=e;const u=t.constructEmpty();e.queryLooseEnvelope(u);for(let t=0;t<4;t++){let s=!1;const h=!!(1&t);let c=0;switch(t){case 0:c=this.m_extent.xmin,s=u.xmin<=c&&u.xmax>=c;break;case 1:c=this.m_extent.ymin,s=u.ymin<=c&&u.ymax>=c;break;case 2:c=this.m_extent.xmax,s=u.xmin<=c&&u.xmax>=c;break;case 3:c=this.m_extent.ymax,s=u.ymin<=c&&u.ymax>=c}if(!s)continue;const g=m;m=e.createInstance();const d=g.getImpl().querySegmentIterator();d.resetToFirstPath();const _=new l,p=new l;for(;d.nextPath();){let e=-1,s=!0;for(;d.hasNextSegment();){this.progress_();const l=d.nextSegment(),u=l.isDegenerate(0);l.queryLooseEnvelope(n);const g=Em.checkSegmentIntersection(n,t,c);if(-1===g){const n=l.intersectionWithAxis2D(h,c,r,o);let g=0;_.assign(l.getStartXY());for(let d=0;d<=n;d++){const f=d<n?o[d]:1;if(g===f)continue;l.queryCut(g,f,a,!1);const x=a.get();let y=!1;if(x.getStartXY().equals(_)||(x.setStartXY(_),y=!0),d<n&&(h?(p.x=r[d],p.y=c):(p.x=c,p.y=r[d]),x.getEndXY().equals(p)||(x.setEndXY(p),y=!0)),y&&x.normalizeAfterEndpointChange(),!u&&x.isDegenerate(0))continue;x.queryEnvelope(i);let P=Em.checkSegmentIntersection(i,t,c);if(-1===P){const e=x.getStartXY(),s=x.getEndXY();y=!1,h?Math.abs(e.y-c)<Math.abs(s.y-c)?(e.y=c,x.setStartXY(e),e.equals(x.getStartXY())||(x.setStartXY(e),y=!0)):(s.y=c,s.equals(x.getEndXY())||(x.setEndXY(s),y=!0)):Math.abs(e.x-c)<Math.abs(s.x-c)?(e.x=c,e.equals(x.getStartXY())||(x.setStartXY(e),y=!0)):(s.x=c,s.equals(x.getEndXY())||(x.setEndXY(s),y=!0)),y&&x.normalizeAfterEndpointChange(),x.queryEnvelope(i),P=Em.checkSegmentIntersection(i,t,c),-1===P&&(P=Em.checkSegmentIntersectionLoose(i,t,c))}_.assign(x.getEndXY()),g=f,e=P,e>=1?(m.addSegment(x,s),s=!1):s=!0}}else e=g,e>=1?(m.addSegment(l,s),s=!1):s=!0}}}return m}static checkSegmentIntersection(t,e,s){switch(e){case 0:return t.xmin<s&&t.xmax<=s?0:t.xmin>=s?t.xmax===s?2:1:-1;case 1:return t.ymin<s&&t.ymax<=s?0:t.ymin>=s?t.ymax===s?2:1:-1;case 2:return t.xmin>=s&&t.xmax>s?0:t.xmax<=s?t.xmin===s?2:1:-1;case 3:return t.ymin>=s&&t.ymax>s?0:t.ymax<=s?t.ymin===s?2:1:-1}return P(""),0}static checkSegmentIntersectionLoose(t,e,s){switch(e){case 0:{const e=Math.abs(t.xmin-s),n=Math.abs(t.xmax-s);return t.xmin<s?e>n?0:1:(P(""),1)}case 1:{const e=Math.abs(t.ymin-s),n=Math.abs(t.ymax-s);return t.ymin<s?e>n?0:1:(P(""),1)}case 2:{const e=Math.abs(t.xmin-s),n=Math.abs(t.xmax-s);return t.xmax>s?e<n?0:1:(P(""),1)}case 3:{const e=Math.abs(t.ymin-s),n=Math.abs(t.ymax-s);return t.ymax>s?e<n?0:1:(P(""),1)}}return P(""),0}resolveBoundaryOverlaps(){this.m_verticesOnExtentIndex=-1,this.splitSegments(!1,this.m_extent.xmin),this.splitSegments(!1,this.m_extent.xmax),this.splitSegments(!0,this.m_extent.ymin),this.splitSegments(!0,this.m_extent.ymax),this.m_verticesOnExtent.length=0,this.m_verticesOnExtentIndex=this.m_shape.createUserIndex();const t=new l;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Ar;e=this.m_shape.getNextPath(e)){let s=this.m_shape.getFirstVertex(e);for(let n=0,i=this.m_shape.getPathSize(e);n<i;n++,s=this.m_shape.getNextVertex(s))this.progress_(),this.m_shape.queryXY(s,t),this.m_extent.xmin!==t.x&&this.m_extent.xmax!==t.x&&this.m_extent.ymin!==t.y&&this.m_extent.ymax!==t.y||(this.m_shape.setUserIndex(s,this.m_verticesOnExtentIndex,this.m_verticesOnExtent.length),this.m_verticesOnExtent.push(s))}this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmin),this.dbgCheckPathFirst(),this.resolveOverlaps(!1,this.m_extent.xmax),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymin),this.dbgCheckPathFirst(),this.resolveOverlaps(!0,this.m_extent.ymax),this.fixPaths()}densifyAlongClipExtent(t){const e=new l(0,0),s=new l(0,0),i=h(2048,Number.NaN);for(let r=this.m_shape.getFirstPath(this.m_geometry);r!==Ar;r=this.m_shape.getNextPath(r)){const o=this.m_shape.getFirstVertex(r);let a=o;do{const r=this.m_shape.getNextVertex(a);this.m_shape.queryXY(a,e);let o=-1;if(e.x===this.m_extent.xmin?(this.m_shape.queryXY(r,s),s.x===this.m_extent.xmin&&(o=1)):e.x===this.m_extent.xmax&&(this.m_shape.queryXY(r,s),s.x===this.m_extent.xmax&&(o=1)),e.y===this.m_extent.ymin?(this.m_shape.queryXY(r,s),s.y===this.m_extent.ymin&&(o=0)):e.y===this.m_extent.ymax&&(this.m_shape.queryXY(r,s),s.y===this.m_extent.ymax&&(o=0)),-1===o){a=r;continue}if(this.isCurve(a)){a=r;continue}const h=e.clone(),m=new l(0,0);if(o){const n=e.y-this.m_extent.ymin;m.y=gt(s.y-e.y),h.y=t*kt(Math.floor(Math.abs(n)/t),n)+this.m_extent.ymin,m.y<0&&(h.y+=t)}else{const n=e.x-this.m_extent.xmin;m.x=gt(s.x-e.x),h.x=t*kt(Math.floor(Math.abs(n)/t),n)+this.m_extent.xmin,m.x<0&&(h.x+=t)}const u=o?s.y-e.y:s.x-e.x,c=Math.abs(u);if(c/t>65536&&P(""),c>0){const s=Math.trunc(c/t)+2;i.length<s&&(i.length=s);let r=0;for(let s=0;;s++){const a=h.add(m.mul(s*t)),l=(o?a.y-e.y:a.x-e.x)/u;if(l>=1)break;l<=0||(n(r<=i.length),i[r]=l,r++)}0!==r&&this.m_shape.splitSegment(a,i,r)}a=r}while(a!==o)}}splitSegments(t,e){let s=-1;const n=new l,i=[];for(let r=this.m_shape.getFirstPath(this.m_geometry);r!==Ar;r=this.m_shape.getNextPath(r)){let o=this.m_shape.getFirstVertex(r),a=Ar;for(let h=0,m=this.m_shape.getPathSize(r);h<m;h++,o=a)if(this.progress_(),a=this.m_shape.getNextVertex(o),this.m_shape.queryXY(o,n),(t?n.y===e:n.x===e)&&(this.m_shape.queryXY(a,n),t?n.y===e:n.x===e)){if(this.isCurve(o))continue;-1===s&&(s=this.m_shape.createUserIndex()),1!==this.m_shape.getUserIndex(o,s)&&(i.push(o),this.m_shape.setUserIndex(o,s,1)),1!==this.m_shape.getUserIndex(a,s)&&(i.push(a),this.m_shape.setUserIndex(a,s,1))}}if(-1!==s&&this.m_shape.removeUserIndex(s),i.length<3)return;i.sort((t,e)=>this.compareVertices(t,e));const r=new l,o=new l,a=new l;o.setNAN();let h=-1,m=[],u=[];const c=this.m_shape.createUserIndex(),g=this.m_shape.createUserIndex();for(let s=0,d=i.length;s<d;s++){const d=i[s];if(this.m_shape.queryXY(d,n),!n.isEqualPoint2D(o)){if(-1===h){h=s,o.setCoordsPoint2D(n);continue}for(let n=h;n<s;n++){const s=i[n],a=this.m_shape.getNextVertex(s),h=this.m_shape.getPrevVertex(s);let l=!1;this.m_shape.queryXY(a,r),o.compare(r)<0&&(t?r.y===e:r.x===e)&&(this.isCurve(s)||(m.push(s),l=!0,this.m_shape.setUserIndex(s,g,1))),this.m_shape.queryXY(h,r),o.compare(r)<0&&(t?r.y===e:r.x===e)&&(this.isCurve(h)||(l||m.push(s),this.m_shape.setUserIndex(s,c,1)))}for(let t=0,e=m.length;t<e;t++){const e=m[t],s=this.m_shape.getUserIndex(e,c),i=this.m_shape.getUserIndex(e,g);if(1===s){const t=this.m_shape.getPrevVertex(e);this.m_shape.queryXY(t,a);let s=0;if(!a.isEqualPoint2D(n)){const i=l.distance(o,a);s=l.distance(a,n)/i,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(t,[s],1);const r=this.m_shape.getPrevVertex(e);this.m_shape.setXY(r,n),u.push(r),this.m_shape.setUserIndex(r,c,1),this.m_shape.setUserIndex(r,g,-1)}}if(1===i){const t=this.m_shape.getNextVertex(e);this.m_shape.queryXY(t,a);let s=0;if(!a.isEqualPoint2D(n)){const t=l.distance(o,a);s=l.distance(o,n)/t,0===s?s=Number.EPSILON:1===s&&(s=1-Number.EPSILON),this.m_shape.splitSegment(e,[s],1);const i=this.m_shape.getNextVertex(e);this.m_shape.setXY(i,n),u.push(i),this.m_shape.setUserIndex(i,c,-1),this.m_shape.setUserIndex(i,g,1)}}}const d=m;m=u,u=d,u.length=0,h=s,o.setCoordsPoint2D(n)}}this.m_shape.removeUserIndex(c),this.m_shape.removeUserIndex(g)}resolveOverlaps(t,e){const s=new l,i=[];let r=-1;for(let n=0,o=this.m_verticesOnExtent.length;n<o;n++){this.progress_();const o=this.m_verticesOnExtent[n];if(o===Ar)continue;const a=this.m_shape.getNextVertex(o);if(this.m_shape.queryXY(o,s),(t?s.y===e:s.x===e)&&(this.m_shape.queryXY(a,s),t?s.y===e:s.x===e)){if(this.isCurve(o))continue;-1===r&&(r=this.m_shape.createUserIndex()),-2!==this.m_shape.getUserIndex(o,r)&&(i.push(o),this.m_shape.setUserIndex(o,r,-2)),-2!==this.m_shape.getUserIndex(a,r)&&(i.push(a),this.m_shape.setUserIndex(a,r,-2))}}if(0===i.length)return void(-1!==r&&this.m_shape.removeUserIndex(r));n(-1!==r),i.sort((t,e)=>this.compareVertices(t,e));for(let t=0,e=i.length;t<e;t++){const e=i[t];this.m_shape.setUserIndex(e,r,t)}const o=new l,a=new l;a.setNAN();let h=-1;for(let n=0,m=i.length;n<m;n++){this.progress_();const m=i[n];if(m!==Ar&&(this.m_shape.queryXY(m,s),!s.isEqualPoint2D(a))){if(-1!==h)for(;;){let s=!1;const m=n;for(let l=h;l<m;l++){const h=i[l];if(h===Ar)continue;let m=Ar;const u=this.m_shape.getNextVertex(h);this.m_shape.queryXY(u,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(h)||(m=u));let c=Ar;const g=this.m_shape.getPrevVertex(h);if(this.m_shape.queryXY(g,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(g)||(c=g)),m===Ar||c===Ar){if(m!==Ar||c!==Ar){for(let u=l+1;u<n;u++){const n=i[u];if(n===Ar)continue;const l=this.m_shape.getNextVertex(n);let g=Ar;this.m_shape.queryXY(l,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(n)||(g=l));const d=this.m_shape.getPrevVertex(n);let _=Ar;if(this.m_shape.queryXY(d,o),a.compare(o)<0&&(t?o.y===e:o.x===e)&&(this.isCurve(d)||(_=d)),g!==Ar&&_!==Ar){this.beforeRemoveVertex(n,i,r),this.m_shape.removeVertex(n,!1),this.beforeRemoveVertex(g,i,r),this.m_shape.removeVertex(g,!1),s=!0;break}if(m!==Ar&&_!==Ar){this.removeOverlap(i,h,m,n,_,r),s=!0;break}if(c!==Ar&&g!==Ar){this.removeOverlap(i,n,g,h,c,r),s=!0;break}}if(s)break}}else this.beforeRemoveVertex(h,i,r),this.m_shape.removeVertex(h,!1),this.beforeRemoveVertex(m,i,r),this.m_shape.removeVertex(m,!1),s=!0}if(!s)break}h=n,a.setCoordsPoint2D(s)}}this.m_shape.removeUserIndex(r)}beforeRemoveVertex(t,e,s){let i=this.m_shape.getUserIndex(t,s);n(i>=0),e[i]=Ar,i=this.m_shape.getUserIndex(t,this.m_verticesOnExtentIndex),n(i>=0),this.m_verticesOnExtent[i]=Ar;const r=this.m_shape.getPathFromVertex(t);r!==Ar&&this.m_shape.getFirstVertex(r)===t&&(this.m_shape.setFirstVertex(r,Ar),this.m_shape.setLastVertex(r,Ar))}removeOverlap(t,e,s,n,i,r){this.m_shape.setNextVertex(e,n),this.m_shape.setPrevVertex(n,e),this.m_shape.setPrevVertex(s,i),this.m_shape.setNextVertex(i,s),this.beforeRemoveVertex(n,t,r),this.m_shape.removeVertexInternal(n,!1),this.beforeRemoveVertex(i,t,r),this.m_shape.removeVertexInternal(i,!0)}removeSpikesAlongPoles(){this.removeSpikesOnPole(this.m_extent.ymin),this.removeSpikesOnPole(this.m_extent.ymax)}removeSpikesOnPole(t){for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Ar;e=this.m_shape.getNextPath(e)){const s=this.m_shape.getPathSize(e);if(s<3)continue;let n=this.m_shape.getFirstVertex(e);const i=new l;this.m_shape.queryXY(n,i);let r=i.y===t&&!this.isCurve(n);n=this.m_shape.getNextVertex(n);const o=new l;this.m_shape.queryXY(n,o);let a=o.y===t&&!this.isCurve(n);n=this.m_shape.getNextVertex(n);const h=new l;for(let e=0,m=s-2;e<m;e++,n=this.m_shape.getNextVertex(n)){this.progress_(),this.m_shape.queryXY(n,h);const e=h.y===t;a&&r&&e&&(o.x-i.x)*(h.x-o.x)<=0?(this.m_shape.removeVertex(this.m_shape.getPrevVertex(n),!1),o.setCoordsPoint2D(h),a=e&&!this.isCurve(n)):(i.setCoordsPoint2D(o),r=a,o.setCoordsPoint2D(h),a=e&&!this.isCurve(n))}}}fixPaths(){for(let t=0,e=this.m_verticesOnExtent.length;t<e;t++){const e=this.m_verticesOnExtent[t];e!==Ar&&this.m_shape.setPathToVertex(e,Ar)}const t=this.m_shape.hasCurves();let e=0,s=0;for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==Ar;){const n=this.m_shape.getFirstVertex(t);if(n===Ar||t!==this.m_shape.getPathFromVertex(n)){const e=t;t=this.m_shape.getNextPath(t),this.m_shape.setFirstVertex(e,Ar),this.m_shape.removePathOnly(e);continue}let i=n,r=0;do{this.m_shape.setPathToVertex(i,t),r++,i=this.m_shape.getNextVertex(i)}while(i!==n);this.m_shape.setRingAreaValid(t,!1),this.m_shape.setLastVertex(t,this.m_shape.getPrevVertex(n)),this.m_shape.setPathSize(t,r),s+=r,e++,t=this.m_shape.getNextPath(t)}for(let i=0,r=this.m_verticesOnExtent.length;i<r;i++){let r=this.m_verticesOnExtent[i];if(r===Ar)continue;let o=this.m_shape.getPathFromVertex(r);if(o!==Ar)continue;o=this.m_shape.insertPath(this.m_geometry,Ar);let a=!1,h=0;const m=r;do{this.m_shape.setPathToVertex(r,o),h++,t&&h<=2&&(a||=this.isCurve(r)),r=this.m_shape.getNextVertex(r)}while(r!==m);if(a?0===h:h<=2){let t=this.m_shape.getUserIndex(m,this.m_verticesOnExtentIndex);n(t>=0),this.m_verticesOnExtent[t]=Ar;const e=this.m_shape.removeVertex(m,!1);2===h&&(t=this.m_shape.getUserIndex(e,this.m_verticesOnExtentIndex),t>=0&&(this.m_verticesOnExtent[t]=Ar),this.m_shape.removeVertex(e,!1));const s=o;o=this.m_shape.getNextPath(o),this.m_shape.setFirstVertex(s,Ar),this.m_shape.removePathOnly(s);continue}this.m_shape.setClosedPath(o,!0),this.m_shape.setPathSize(o,h),this.m_shape.setFirstVertex(o,m),this.m_shape.setLastVertex(o,this.m_shape.getPrevVertex(m)),this.m_shape.setRingAreaValid(o,!1),s+=h,e++}this.m_shape.setGeometryPathCount(this.m_geometry,e),this.m_shape.setGeometryVertexCount(this.m_geometry,s);let i=0;for(let t=this.m_shape.getFirstGeometry();t!==Ar;t=this.m_shape.getNextGeometry(t))i+=this.m_shape.getPointCount(t);this.m_shape.setTotalPointCount(i)}dbgCheckPathFirst(){}isCurve(t){return null!==this.m_shape.getSegment(t)}compareVertices(t,e){const s=new l;this.m_shape.queryXY(t,s);const n=new l;return this.m_shape.queryXY(e,n),s.compare(n)}clipPolesOut(t,e){return this.clipPolygonOrProjectedPolyline2(t,e)}}class Sm{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,n){return new vm(t,e,s,n)}execute(t,e,s,n){return function(t,e,s,n){return Cm(t,e,s,Number.NaN,0,n)}(t,e,s,n)}}class vm extends Cs{constructor(t,e,n,i){super(),this.m_progressTracker=i,this.m_index=-1,t||s(""),this.m_envelope=e,this.m_inputGeometryCursor=t,this.m_spatialRefImpl=n,this.m_tolerance=Oe(n,e,!1).total()}next(){let t;return(t=this.m_inputGeometryCursor.next())?(Xt(t),this.m_index=this.m_inputGeometryCursor.getGeometryID(),Pm(t,this.m_envelope,this.m_tolerance,0,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}var Im=lh;class bm extends Cs{constructor(t,e,s,n,i,r){super(),this.m_densificator=new Im(e,s,n,r,!1,i),this.m_index=-1,this.m_inputGeoms=t}tock(){return!0}getRank(){return 1}next(){let t=null;for(;t=this.m_inputGeoms.next();)return Xt(t),this.m_index=this.m_inputGeoms.getGeometryID(),this.densify(t);return null}getGeometryID(){return this.m_index}densify(t){return this.m_densificator.densify(t)}}class wm{getOperatorType(){return 10202}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s,n,i,r=12e3){return new bm(t,e,s,n,r,i)}execute(t,e,s,n,i,r=12e3){return oh(t,e,s,n,0,r)}}const Dm={330:104878,500:104879,1300:104899,1450:104986,2230:104988,3800:104978,5e3:104919,6200:104906,8200:104909,9500:104927,9600:104977,1e4:[104911,104936],11e3:104941,11080:104872,11100:104907,12e3:104920,12400:104995,13e3:104948,14e3:[104923,104989],15e3:[104913,104954],15100:104976,16e3:[104926,104931],18e3:[104922,104982],21e3:104947,21500:104877,27e3:[104950,104957],29e3:104964,3e4:104921,31e3:104949,33e3:104946,4e4:[104914,104967],40600:104897,41900:104937,42e3:104951,43100:104993,49300:104924,50100:104939,54e3:104955,58200:104981,59500:104930,74e3:104961,77e3:104956,79e3:104962,83500:104910,85e3:104917,88800:104934,89200:104985,96e3:104997,104e3:104963,106500:104898,11e4:104938,133e3:104932,135e3:104983,17e4:104965,198200:104987,198630:104935,208e3:104966,235800:104952,249400:104929,252100:104980,255e3:104973,47e4:104972,529800:104942,531e3:104996,56e4:104928,561400:104979,578900:104945,584700:104959,593e3:104970,606e3:104999,718e3:104933,745700:104984,761400:104953,763500:104994,764e3:104940,788900:104958,1188300:104998,1195e3:104969,1352600:104968,1560800:104874,1562090:104915,1737400:104903,1821460:104918,1821490:104876,2409300:104912,2410300:104873,2439400:104974,2439700:104900,2575e3:104943,2631200:104875,2632345:104916,3393400:104904,3396190:[104905,104971],6051e3:104901,6051800:104902,637e4:104128,6370997:[4052,37008],6371e3:4035,6371007:4047,6371228:[4053,10346],6376045:[8042,8043],6376523:[4027,4901,4902],6376896:37007,6378135:[4122,4322,4324,4720,4985,4987],6378136:[4740,4923,7678,7680,9474,9475,104017,104018],6378137:[3823,3824,3888,3889,4017,4019,4023,4031,4040,4046,4055,4074,4075,4080,4081,4121,4126,4130,4133,4140,4141,4148,4151,4152,4163,4166,4167,4170,4171,4172,4173,4176,4180,4189,4190,4258,4269,4283,4318,4319,4326,4463,4466,4469,4470,4480,4482,4483,4490,4557,4558,4612,4617,4619,4624,4627,4659,4661,4667,4669,4670,4674,4686,4687,4693,4694,4702,4737,4742,4747,4749,4750,4755,4756,4757,4758,4759,4761,4762,4763,4764,4765,4883,4885,4887,4889,4893,4895,4898,4907,4909,4921,4925,4927,4929,4931,4933,4935,4937,4939,4941,4943,4945,4947,4949,4951,4953,4955,4957,4959,4961,4963,4965,4967,4971,4975,4977,4979,4981,4983,4989,4997,4999,5012,5013,5245,5246,5251,5252,5263,5264,5323,5324,5340,5342,5353,5354,5359,5360,5364,5365,5370,5371,5372,5373,5380,5381,5392,5393,5488,5489,5545,5546,5592,5593,5885,5886,6134,6135,6310,6311,6318,6319,6321,6322,6324,6325,6364,6365,6667,6668,6705,6706,6782,6783,6980,6982,6983,6987,6989,6990,7034,7035,7036,7037,7038,7039,7040,7041,7042,7072,7073,7084,7085,7086,7087,7133,7135,7136,7138,7139,7372,7373,7657,7659,7661,7663,7665,7685,7686,7797,7798,7816,7843,7844,7880,7881,7885,7886,7900,7901,7902,7903,7904,7905,7906,7907,7908,7909,7910,7911,7912,7915,7917,7919,7921,7923,7925,7927,7929,7931,8085,8086,8231,8232,8235,8237,8239,8240,8244,8246,8248,8249,8251,8252,8254,8255,8399,8403,8426,8427,8449,8542,8544,8545,8684,8685,8698,8699,8817,8818,8860,8888,8899,8900,8901,8902,8906,8907,8916,8918,8920,8922,8924,8926,8928,8930,8932,8934,8936,8938,8940,8942,8944,8946,8948,8949,8972,8973,8974,8975,8976,8977,8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,8993,8994,8995,8996,8997,8998,8999,9e3,9002,9003,9005,9006,9008,9009,9011,9012,9013,9014,9016,9017,9018,9019,9053,9054,9055,9056,9057,9059,9060,9061,9062,9063,9064,9065,9066,9067,9068,9069,9071,9072,9074,9075,9139,9140,9147,9148,9152,9153,9183,9184,9293,9294,9299,9308,9309,9332,9333,9364,9372,9379,9380,9384,9453,9469,9470,9546,9547,9695,9696,9701,9702,9739,9754,9755,9758,9763,9776,9777,9778,9779,9781,9782,9783,9784,9866,9871,9939,9964,9969,9974,9989,9990,10175,10177,10178,10185,10191,10196,10204,10209,10214,10219,10224,10229,10237,10272,10277,10283,10284,10298,10299,10300,10304,10305,10307,10309,10310,10311,10312,10327,10328,10413,10414,10468,10474,10475,10570,10571,10605,10606,10623,10628,10638,10639,10670,10671,10672,10673,10689,10690,10724,10725,10738,10739,10761,10762,10780,10781,10784,10785,10799,10800,20033,20040,20041,20045,20046,104009,104010,104011,104012,104013,104014,104015,104016,104019,104020,104021,104022,104024,104027,104028,104050,104100,104107,104108,104110,104111,104114,104115,104116,104117,104118,104119,104120,104121,104122,104123,104124,104129,104133,104134,104137,104141,104142,104143,104144,104145,104179,104180,104181,104182,104183,104184,104185,104186,104199,104223,104257,104258,104259,104260,104286,104287,104602,104613,104644,104645,104646,104647,104653,104804,104896,104991],6378140:4610,6378145:[4025,4276,4760,4891,37001],6378150:37003,6378155:[37004,37207],6378160:[3821,4003,4021,4036,4202,4203,4237,4238,4291,4618,4708,5527,37231,104023,104136],6378166:37002,6378200:[4020,4229,4286,4303,4706],6378245:[4024,4147,4164,4178,4179,4191,4200,4205,4214,4284,4317,4555,4676,4677,4678,4991,4993,5560,5561,37257,104135],6378270:[4732,37005,37229],6378273:[4054,10345],6378300:[4029,4168,4174],6378388:[4022,4123,4153,4154,4158,4159,4160,4161,4165,4181,4182,4183,4184,4185,4192,4194,4195,4196,4199,4204,4207,4208,4215,4218,4221,4224,4225,4230,4231,4233,4235,4236,4247,4248,4249,4254,4255,4259,4264,4265,4271,4272,4274,4285,4287,4288,4292,4297,4309,4311,4313,4316,4472,4475,4611,4614,4615,4616,4621,4622,4623,4625,4626,4628,4629,4630,4631,4632,4633,4636,4637,4639,4641,4642,4643,4644,4645,4646,4658,4660,4662,4663,4664,4665,4668,4672,4673,4684,4688,4689,4690,4691,4692,4698,4704,4705,4707,4709,4710,4711,4712,4714,4715,4716,4718,4719,4721,4722,4724,4725,4727,4728,4729,4730,4733,4734,4735,4739,4741,4753,4754,4802,4803,4806,4809,4810,4823,4824,4900,5524,6883,8428,8430,8431,9248,9251,9253,9403,9893,10158,10249,10252,10635,10636,10735,10736,10758,37201,37204,37205,37212,37213,37214,37215,37216,37217,37218,37219,37221,37222,37224,37226,37227,37230,37232,37233,37234,37235,37237,37238,37241,37242,37245,37246,37247,37249,37250,37251,37253,37259,104104,104106,104125,104126,104127,104130,104138,104248],6378523:104786,24764e3:104960,25559e3:104944,60268e3:104925,71492e3:104908,6957e5:104975,6377397.155:[3819,3906,4004,4120,4124,4125,4149,4150,4156,4162,4211,4219,4257,4262,4280,4289,4294,4295,4301,4306,4308,4312,4314,4613,4666,4745,4746,4801,4804,4805,4808,4813,4814,4815,4818,4820,4904,5132,5228,5229,5681,5830,8351,9267,10268,37255,104101,104102,104105,104131,104648,104696,104697,104990,104992],6377563.396:[4001,4188,4277,4278,4279],6377340.189:[4002,4299,4300],6377492.018:[4005,4273,4817],6377483.865280418:[4006,4293],6378293.645208759:[4007,4157,4302,4738,5464],6378206.4:[4008,4127,4128,4129,4135,4136,4137,4138,4139,4169,4216,4242,4253,4267,4608,4609,4638,4675,4683,4695,4717,4723,4726,4995,5451,5467,37220,37239,37243,37252,37260,104e3,104109,104112,104113,104132],6378450.047:[4009,4268],6378300.789:[4010,4281],6378249.2:[4011,4014,4155,4193,4206,4213,4223,4226,4227,4228,4252,4261,4266,4275,4282,4296,4304,4310,4315,4671,4807,4811,4816,4821,37223,37225,104139,104140,104261,104304],6378249.145:[4012,4013,4132,4134,4142,4143,4175,4197,4198,4201,4209,4210,4212,4220,4222,4232,4234,4246,4250,4251,4256,4260,4263,4270,4305,4307,4600,4601,4602,4603,4604,4605,4606,4607,4620,4679,4680,4696,4697,4699,4700,4701,4703,4713,4731,4736,4743,4744,4812,4819,6881,6882,6892,6894,8694,37206,37208,37211,37228,37240,37254,104025,104026,104103,104305],6377276.345:[4015,4131,4144,4239,4240,4244,4682,5233,6207,37202,104256,104664,104693],6377298.556:[4016,4298],6377304.063:[4018,4245],6378298.3:[4028,4903],6378136.2:4032,6378136.3:4033,6378249.144808011:[4034,4241],20922931.8:[4042,4243],6377301.243:[4044,4145,37203],6377299.151:[4045,4146],6377019.27:[4657,10256,10260,10265],6378306.3696:[4748,4752],6377295.664:[4751,37006],6378136.5:[7682,7683],6371008.7714:104047,6378418.941:[104700,104726,104760],6378586.581:[104701,104743],6378505.809:104702,6378544.823:104703,6378490.569:104704,6378470.757:[104705,104776],6378403.701:[104706,104750],6378434.181:[104707,104724,104739,104764],6378454.907:104708,6378400.653:104709,6378567.378:104710,6378546.957:[104711,104717,104780],6378476.853:[104712,104736],6378411.321:[104713,104728],6378647.541:[104714,104715],6378514.953:[104716,104782],6378421.989:[104718,104770],6378481.425:[104719,104753,104774,104781],6378518.001:[104720,104725],6378521.049:[104721,104723,104731,104745,104748],6378464.661:104722,6378436.619:104727,6378574.389:[104729,104730],6378472.281:[104732,104756],6378498.189:[104733,104746],6378449.421:[104734,104766],6378525.621:[104735,104754],6378466.185:104737,6378496.665:104738,6378643.579:104740,6378559.758:104741,6378414.369:[104742,104763,104772],6378441.801:104744,6378502.761:[104747,104759,104773,104775],6378617.061:104749,6378624.681:[104751,104765],6378468.623:104752,6378445.763:[104755,104758,104761],6378670.401:104757,6378438.753:104762,6378543.909:104767,6378605.783:104768,6378540.861:104769,6378443.325:[104771,104784],6378548.481:104777,6378463.746:104778,6378426.561:104779,6378453.688:104783,6378530.193:104785,6378376.271:[104800,104828],6378471.92:104801,6378472.931:104802,6378411.351:104803,6378380.991:104805,6378414.96:104806,6378345.09:[104807,104819,104844,104870],6378412.542:104808,6378470.401:104809,6378376.331:104810,6378379.031:104811,6378407.621:104812,6378376.811:[104813,104827],6378313.92:104814,6378414.93:104815,6378413.021:104816,6378380.381:104817,6378530.851:104818,6378591.521:104820,6378378.881:104821,6378408.481:[104822,104832],6378375.601:[104823,104838],6378408.041:104824,6378655.071:104825,6378409.151:104826,6378315.7:[104829,104840,104845,104851],6378285.86:[104830,104835,104859],6378379.301:104831,6378560.121:104833,6378531.821:104834,6378500.6:104836,6378376.041:104837,6378406.601:104839,6378438.991:104841,6378345.42:104842,6378593.86:104843,6378381.271:[104846,104847],6378413.671:104848,6378344.377:104849,6378563.891:104850,6378408.091:104852,6378377.671:104853,6378472.751:104854,6378412.511:104855,6378407.281:104856,6378534.451:104857,6378406.051:104858,6378532.921:104860,6378380.091:104861,6378408.941:104862,6378624.171:104863,6378377.411:104864,6378474.591:104865,6378407.141:104866,6378376.871:104867,6378375.251:104868,6378405.971:104869,6378437.651:104871};class Tm extends ym{constructor(t){if("number"==typeof t)return super(),this.m_factor=t,void(this.m_wkid=0);super(t)}getUnitType(){return 1}convertFromRadians(t){return t/this.getUnitToBaseFactor()}convertToRadians(t){return t*this.getUnitToBaseFactor()}}function Nm(t){return new K_}class Am{constructor(t,e,n){void 0===t?(this.x=new v,this.y=new v,this.z=new v):t instanceof Se?(this.x=new v(t.x),this.y=new v(t.y),this.z=new v(t.z)):t instanceof v?(this.x=t.clone(),this.y=e.clone(),this.z=n.clone()):s("EPoint3D constructor")}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y)).addE(this.z.mulE(t.z))}crossProduct(t){return new Am(this.y.mulE(t.z).subE(this.z.mulE(t.y)),this.z.mulE(t.x).subE(this.x.mulE(t.z)),this.x.mulE(t.y).subE(this.y.mulE(t.x)))}crossProductVector(t){const e=this.y.mulE(t.z).subE(t.y.mulE(this.z)),s=t.x.mulE(this.z).subE(this.x.mulE(t.z)),n=this.x.mulE(t.y).subE(t.x.mulE(this.y));return new Am(e,s,n)}sqrLength(){return this.x.mulE(this.x).addE(this.y.mulE(this.y)).addE(this.z.mulE(this.z))}length(){return this.sqrLength().sqrt()}static distance(t,e){return t.sub(e).length()}negate(){return new Am(this.x.negate(),this.y.negate(),this.z.negate())}add(t){return new Am(this.x.addE(t.x),this.y.addE(t.y),this.z.addE(t.z))}sub(t){return new Am(this.x.subE(t.x),this.y.subE(t.y),this.z.subE(t.z))}subThis(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this.z.subThisE(t.z),this}addThis(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this.z.addThisE(t.z),this}mul(t){return new Am(this.x.mulE(t),this.y.mulE(t),this.z.mulE(t))}div(t){return new Am(this.x.divE(t),this.y.divE(t),this.z.divE(t))}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)&&this.z.eq(t.z)}isZero(){return this.x.isZero()&&this.y.isZero()&&this.z.isZero()}value(){return Se.construct(this.x.value(),this.y.value(),this.z.value())}}class Mm{constructor(t){if(this.m_origin=new Se,this.m_normal=new Se,this.m_axisX=new Se,this.m_axisY=new Se,!t)return this.m_origin=new Se,this.m_normal=new Se(0,0,1),this.m_axisX=new Se(1,0,0),void(this.m_axisY=new Se(0,1,0));t.pt0&&t.pt1&&t.pt2?this.setFromPoints(t.pt0,t.pt1,t.pt2):n(0,`unimplemented constructor options ${JSON.stringify(t)}`)}assign(t){return n(0),this}set(t,e,s,i){n(0)}setFromPoints(t,e,s){let n=e.sub(t);const i=s.sub(t);this.m_normal=n.crossProductVector(i);let r=!0;if(this.m_normal.isZero()){if(r=!1,n.isZero()&&(n=i),n.isZero()){const e=0,s=1;return this.m_normal.setCoords(e,e,s),this.m_axisX.setCoords(s,e,e),this.m_axisY.setCoords(e,s,e),this.m_origin=t,!1}this.m_axisX=n.getUnitVector(),this.m_normal=this.m_axisX.createAPerpendicular()}else this.m_normal.normalizeThis(),this.m_axisX=n.getUnitVector();return this.m_axisY=this.m_normal.crossProductVector(this.m_axisX),this.m_origin=t,r}getCoord(t,e){return n(0),{}}getCoord2D(t){return n(0),{}}getCoordX(t,e){return n(0),0}getCoordY(t,e){return n(0),0}getCoordZ(t,e){return n(0),0}setPreferredAxisX(t){n(0)}getOrigin(){return n(0),{}}getNormal(){return n(0),{}}getAxisX(){return this.m_axisX.clone()}getAxisY(){return this.m_axisY.clone()}setAxisX(t,e=!1){n(0)}setAxisY(t,e=!1){n(0)}recalculateAxisY(){n(0)}setOrigin(t){n(0)}setNormal(t,e){n(0)}intersect(t,e){return n(0),!1}intersectLine(t){return n(0),0}intersectLineEx(t,e){return n(0),0}closestCoordinate(t){const e=t.sub(this.m_origin),s=new l;return s.x=e.dotProduct(this.m_axisX),s.y=e.dotProduct(this.m_axisY),s}projectVector(t){return n(0),{}}signedDistance(t){return n(0),0}distance(t){return n(0),0}}function Gm(t,e){return!1}function qm(t,e,s,i,r=100,o=Gm){let a,h,m,l,u,c,g,d,_;n(i>0);let f,x,y,P=0,C=0;const E=qt();e>s&&(s=p(e,e=s));const S=t(e),v=t(s);S<v?(a=h=m=e,l=u=c=S):(a=h=m=s,l=u=c=v);let I=0;for(;I<r&&(y=.5*(s-e),_=e+y,f=i*(Math.abs(a)+.25),x=2*f,!(o(a,l)||Math.abs(a-_)<=x-y));++I){if(Math.abs(C)>f){const t=(a-h)*(l-c);let n=(a-m)*(l-u),i=(a-m)*n-(a-h)*t;n=2*(n-t),n>0&&(i=-i),n=Math.abs(n);const r=C;C=P,Math.abs(i)>=Math.abs(n*r*.5)||i<=n*(e-a)||i>=n*(s-a)?(C=a>=_?e-a:s-a,P=qt()*C):(P=i/n,d=a+P,(d-e<x||s-d<x)&&(P=_-a<0?-Math.abs(f):Math.abs(f)))}else C=a>=_?e-a:s-a,P=C*E;d=a+P,g=t(d),g<l?(d>=a?e=a:s=a,m=h,h=a,a=d,c=u,u=l,l=g):(d<a?e=d:s=d,g<=u||h===a?(m=h,h=d,c=u,u=g):(g<=c||m===a||m===h)&&(m=d,c=g))}return ft(a,l)}function Fm(t,e,s){return t>s?t-=Math.ceil((t-s)/pe)*pe:t<e&&(t+=Math.ceil((e-t)/pe)*pe),t}function Vm(t,e,s){return function(t,e,s){const n=s.x,i=s.y;return Ym(t,e,Math.cos(n),Math.sin(n),Math.cos(i),Math.sin(i),0)}(t,e,s)}function Ym(t,e,s,n,i,r,o){const a=t/Math.sqrt(1-e*r*r),h=a+o,m=h*i*s,l=h*i*n,u=(a*(1-e)+o)*r;return Se.construct(m,l,u)}function Xm(t,e,s){const n=new v,i=new v,r=new v,o=new v;n.setCos(s.x),i.setSin(s.x),r.setCos(s.y),o.setSin(s.y);const a=o.negate().mulE(o.mul(e)).add(1).sqrt(),h=new v(t).divE(a),m=h.mulE(r).mulE(n),l=h.mulE(r).mulE(i),u=h.mul(1-e).mulE(o);return new Am(m,l,u)}function km(t,e,s){const n=s.x,i=s.y,r=s.z,o=Math.atan2(i,n),a=Math.sqrt(n*n+i*i),h=Math.atan2(r,(1-e)*a);return l.construct(o,h)}function Rm(t,e,s){const n=1-e,i=t/Math.sqrt(ot(s.x)+ot(s.y)+ot(s.z)/n);return s.mul(i)}function Lm(t,e,s,n,i){const r=Vm(t,e,s),o=Vm(t,e,n);return km(0,e,Se.lerp(r,o,i))}function Hm(t,e,s){const n=new Se;return n.setCrossProductVector(e,s),Math.abs(Math.atan2(n.length(),e.dotProduct(s)))*t}function Bm(t,e,s,n,i){const r=s.getUnitVector(),o=n.getUnitVector(),a=e.getUnitVector(),h=new Se;if(h.setCrossProductVector(r,o),!h.isZero()){h.normalizeThis();const e=a.sub(h.mul(h.dotProduct(a)));if(!e.isZero()){e.normalizeThis();const s=r.add(o).mul(.5);if(s.dotProduct(e)>s.dotProduct(r)){const s=Math.abs(h.dotProduct(a)),n=Math.asin(s);return i.assign(e.getUnitVector().mul(t)),n*t}}}const m=Hm(1,r,a),l=Hm(1,o,a);return m<=l?(i.assign(s),m*t):(i.assign(n),l*t)}function Um(t,e,s,i,r,o=0,a){if(2===o||3===o)return function(t,e,s,n,i,r=!1,o){const a=Rm(t,e,s);if(r){const r=new Mm({pt0:new Se(0,0,0),pt1:n,pt2:i}),h=r.closestCoordinate(s),m=r.closestCoordinate(n),u=r.closestCoordinate(i),c=l.getClosestCoordinate(m,u,h),g=Rm(t,e,Se.lerp(n,i,c)),d=Se.distance(g,a);return o&&o.assign(g),ft(c,d)}const h=s=>{const r=Rm(t,e,Se.lerp(n,i,s));return Se.distance(r,a)},m=Se.distance(n,i);if(m>0){const s=Km(t,m),{first:r,second:a}=qm(h,0,1,s);return o&&o.assign(Rm(t,e,Se.lerp(n,i,r))),ft(r,a)}{const t=Se.distance(s,n);return o&&o.assign(s),ft(.5,t)}}(t,e,s,i,r,3===o,a);const h=km(0,e,s),m=s=>{const a=km(0,e,Se.lerp(i,r,s));return function(t,e,s,i,r){switch(n(s.isFinite()&&i.isFinite()),r){case 0:return function(t,e,s,n){const i={stack:[],error:void 0,hasError:!1};try{const r=Ss(i,new Lp,!1);return Zp.geodeticDistance(t,e,s.x,s.y,n.x,n.y,r,null,null,Bp.PE_LINETYPE_GEODESIC),r.val}catch(t){i.error=t,i.hasError=!0}finally{vs(i)}}(t,e,s,i);case 1:return function(t,e,s){const n={stack:[],error:void 0,hasError:!1};try{const i=Ss(n,new Lp,!1);return Zp.greatEllipticDistance(t,e,s.x,s.y,s.x,s.y,i,null,null),i.val}catch(t){n.error=t,n.hasError=!0}finally{vs(n)}}(t,e,s);case 2:case 3:{const n=Vm(t,e,s),r=Vm(t,e,i);return Se.distance(n,r)}default:f("")}}(t,e,h,a,o)},u=Se.distance(i,r);if(u>0){const s=Km(t,u),{first:n,second:o}=qm(m,0,1,s);return a&&a.assign(Rm(t,e,Se.lerp(i,r,n))),ft(n,o)}{const t=m(0);return a&&a.assign(i),ft(.5,t)}}function zm(t,e,s,n,i,o){if(o[0]=Number.NaN,o[1]=Number.NaN,Math.abs(s.x-n.x)>Math.PI)return 0;if(Math.abs(s.y)>z||Math.abs(n.y)>z)return 0;if((Math.abs(s.y)===z||Math.abs(n.y)===z)&&s.x!==n.x)return 0;if(Math.abs(i)>=z)return 0;if(s.y>0&&n.y>0&&s.y>i&&n.y>i||s.y<0&&n.y<0&&s.y<i&&n.y<i)return 0;const a=Rs.constructPoint2D(s),h=Rs.constructPoint2D(n),m=Xm(1,e,a),l=Xm(1,e,h),u=m.crossProductVector(l);if(u.z.isZero())return r.construct(s.y,n.y).containsCoordinate(i)?(o[0]=s.x,1):0;const c=u.x.divE(u.z.negate()),g=u.y.divE(u.z.negate()),d=c.mulE(c).addE(g.mulE(g)).sqrt();if(d.isZero()||c.isZero()&&g.isZero())return 0===i?(o[0]=s.x,o[1]=n.x,2):0;const _=(1-e)*Math.tan(i)/d.value();if(Math.abs(_)>1)return 0;const p=Math.acos(_),f=Math.atan2(g.value(),c.value()),x=f-p;let y=f+p;const P=Math.min(s.x,n.x),C=Math.max(s.x,n.x);Fm(x,P,C),0!==i?Fm(y,P,C):y=x;let E=0;return P<=x&&x<=C&&(o[E]=x,E++),y!==x&&P<=y&&y<=C&&(o[E]=y,E++),E}function Om(t,e){e[0]>.5*Math.PI?(t[0]+=Math.PI,e[0]=Math.PI-e[0]):e[0]<.5*-Math.PI&&(t[0]-=Math.PI,e[0]=-Math.PI-e[0]),n(e[0]>=.5*-Math.PI&&e[0]<=.5*Math.PI)}function Wm(t,e,s,n,i){n=A(n,-z,z),i=A(i,-z,z);const r=z-.03;let o;o=n>r&&i>r||n<-r&&i<-r?function(t,e,s){let n=1;if(e<0&&(n=-1,e=-e,s=-s),0!==t){const i=t*t,r=i*t,o=[1,(1+11*t)/12,(1+118*t+241*i)/360,(1+1089*t+10419*i+8651*r)/20160,(1+9836*t+318246*i+1027436*r+r*t*458881)/1814400],a=e=>{let s=0;const n=ot(e)/(t-1);for(let t=o.length-1;t>=0;--t)s=o[t]+s*n;return s*=-ot(e/(1-t)),s},h=a(z-e);return(a(z-s)-h)*n}{const t=z-e,i=z-s,r=-4*ot(Math.sin(t/2));return(-4*ot(Math.sin(i/2))-r)*n}}(t,n,i):jm(t,i)-jm(t,n);const a=function(t){return 1-t}(t);return.5*(s-e)*o*a}function jm(t,e){if(0===e)return 0;const s=Math.sin(e);let n=s,i=s;if(0!==t){n/=1-t*s*s;const e=Math.sqrt(t);i=s*de(e*s)}return n+i}function Zm(t,e){return t/Math.sqrt(1-e)}function Qm(t,e){return(1-e)*t}function Km(t,e){if(0!==e){const s=t*me()/e;return Math.min(s,1e-10)}return 0}class Jm{constructor(t){this.m_currentShift=63n,this.m_currentElt=0n,this.m_iCurrentElt=-1,this.m_parent=t,this.m_aiSetElts=t.m_bits.flatMap((t,e)=>e)}next(){if(this.m_currentShift++,64n===this.m_currentShift){if(this.m_iCurrentElt++,this.m_iCurrentElt===this.m_aiSetElts.length)return Jm.npos();this.m_currentShift=0n,this.m_currentElt=this.m_parent.m_bits[this.m_aiSetElts[this.m_iCurrentElt]]}for(;this.m_currentShift<63n&&!(this.m_currentElt&1n<<this.m_currentShift);)this.m_currentShift++;return this.m_currentElt&1n<<this.m_currentShift?64*this.m_aiSetElts[this.m_iCurrentElt]+Number(this.m_currentShift):this.next()}static npos(){return Number.MAX_SAFE_INTEGER}}function $m(t){return 1n<<(0x3fn&BigInt(t))}function tl(t){return t>>6}class el{constructor(t){this.m_bits=[],void 0!==t&&t.copy&&(this.m_bits=t.copy.m_bits.slice())}assignMove(){return this}assignCopy(){return this}hasBit(t){const e=$m(t),s=tl(t);return void 0!==this.m_bits[s]&&!!(this.m_bits[s]&e)}setBit(t){const e=$m(t),s=tl(t);void 0===this.m_bits[s]&&(this.m_bits[s]=0n),this.m_bits[s]|=e}clearBit(t){}flipBit(t){const e=$m(t),s=tl(t);return void 0===this.m_bits[s]&&(this.m_bits[s]=0n),this.m_bits[s]^=e,0n!==(this.m_bits[s]&e)}clear(){this.m_bits.length=0}isZero(){let t=0;return this.m_bits.forEach(e=>{t|=e?2:1}),!(2&t)}equals(t){if(this===t)return!0;if(this.m_bits.length!==t.m_bits.length)return!1;let e=0;return this.m_bits.forEach((s,n)=>{e|=s===t.m_bits[n]?2:1}),!(1&e||(t.m_bits.forEach((t,s)=>{e|=t===this.m_bits[s]?2:1}),1&e))}notEquals(t){return!this.equals(t)}assignOr(t){return t.m_bits.forEach((t,e)=>{void 0===this.m_bits[e]?this.m_bits[e]=t:this.m_bits[e]|=t}),this}assignSubtract(t){return t.m_bits.forEach((t,e)=>{void 0!==this.m_bits[e]&&(this.m_bits[e]&=~t)}),this}assignAnd(t){return t.m_bits.forEach((t,e)=>{void 0!==this.m_bits[e]&&(this.m_bits[e]&=t)}),this}assignXor(t){return t.m_bits.forEach((t,e)=>{void 0===this.m_bits[e]?this.m_bits[e]=t:this.m_bits[e]^=t}),this}getHashCode(){return this.m_bits.reduce((t,e)=>oe(t,e),Yt(0))}getUnorderedBitIterator(){return new Jm(this)}}class sl{constructor(t,e){this.m_map=new Map,this.m_hf=t,this.m_ef=e}add(t){const e=this.m_hf(t);if(!this.m_map.has(e))return this.m_map.set(e,t),this;const s=this.m_map.get(e);return s instanceof Array?s.find(e=>this.m_ef(e,t))||s.push(t):this.m_ef(s,t)||this.m_map.set(e,[s,t]),this}clear(){this.m_map.clear()}delete(t){return!1}has(t){const e=this.m_hf(t);if(!this.m_map.has(e))return!1;const s=this.m_map.get(e);return s instanceof Array?void 0!==s.find(e=>this.m_ef(e,t)):this.m_ef(s,t)}get(t){const e=this.m_hf(t),s=this.m_map.get(e);if(void 0!==s)return s instanceof Array?s.find(e=>this.m_ef(e,t)):s}get size(){let t=0;for(const e of this.m_map.values())t+=e instanceof Array?e.length:1;return t}forEach(t,e){}[Symbol.iterator](){return(new Set)[Symbol.iterator]()}entries(){return(new Set).entries()}keys(){return(new Set).keys()}values(){return(new Set).values()}get[Symbol.toStringTag](){return"ValueSet"}}class nl extends hs{constructor(t){super(),this.m_bufferLeft=new fm,this.m_bufferRight=new fm,this.m_intervalLeft=r.constructEmpty(),this.m_intervalRight=r.constructEmpty(),this.m_yScanline=Number.NaN,this.m_helper=t}compare(t,e,s){const n=e,i=t.getElement(s);this.m_helper.querySegmentXY(n,this.m_bufferLeft),this.m_helper.querySegmentXY(i,this.m_bufferRight);const r=this.m_bufferLeft.get(),o=this.m_bufferRight.get();if(this.m_intervalLeft.setCoords(r.getStartX(),r.getEndX()),this.m_intervalRight.setCoords(o.getStartX(),o.getEndX()),this.m_intervalLeft.vmax<this.m_intervalRight.vmin)return-1;if(this.m_intervalLeft.vmin>this.m_intervalRight.vmax)return 1;const a=r.getStartY()===r.getEndY(),h=o.getStartY()===o.getEndY();if(a||h){if(a&&h)return 0;if(r.getStartY()===o.getStartY()&&r.getStartX()===o.getStartX())return a?1:-1;if(r.getEndY()===o.getEndY()&&r.getEndX()===o.getEndX())return a?-1:1}let m=r.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalLeft.vmin),l=o.intersectionOfYMonotonicWithAxisX(this.m_yScanline,this.m_intervalRight.vmin);if(m===l){const t=r.getEndY(),e=o.getEndY(),s=Math.min(t,e);let n=.5*(s+this.m_yScanline);n===this.m_yScanline&&(n=s),m=r.intersectionOfYMonotonicWithAxisX(n,this.m_intervalLeft.vmin),l=o.intersectionOfYMonotonicWithAxisX(n,this.m_intervalRight.vmin)}return m<l?-1:m>l?1:0}setY(t){this.m_yScanline=t}}class il{constructor(t){this.m_segmentBuffer=new fm,this.m_point=l.getNAN(),this.m_parent=t}setPointXY(t){this.m_point.assign(t)}compare(t,e){const s=t.getElement(e);this.m_parent.querySegmentXY(s,this.m_segmentBuffer);const n=this.m_segmentBuffer.get(),i=new r;if(i.setCoords(n.getStartX(),n.getEndX()),this.m_point.x<i.vmin)return-1;if(this.m_point.x>i.vmax)return 1;const o=n.intersectionOfYMonotonicWithAxisX(this.m_point.y,this.m_point.x);return this.m_point.x<o?-1:this.m_point.x>o?1:0}}var rl,ol;function al(t,e){return{parentage:t,rank:e}}function hl(t,e){const s=t.length;if(s!==e.length)return!1;const n=t[0].parentage;if(n!==e[0].parentage)return!1;if(-1===n)return!0;for(let n=1;n<s;++n)if(t[n].parentage!==e[n].parentage)return!1;return!0}function ml(t,e,s){s.length=0;let n=!1;{let i=t.getHalfEdgeVertexIterator(e);for(;i!==Ar;){const e=t.getVertexFromVertexIterator(i),r=t.getShape().getSegmentRank(e),o=t.getShape().getSegmentParentage(e);n||=o>=0,s.push(al(o,r)),i=t.incrementVertexIterator(i)}}{let i=t.getHalfEdgeVertexIterator(t.getHalfEdgeTwin(e));for(;i!==Ar;){const e=t.getVertexFromVertexIterator(i),r=t.getShape().getSegmentRank(e),o=t.getShape().getSegmentParentage(e);n||=o>=0,s.push(al(o,r)),i=t.incrementVertexIterator(i)}}n&&s.sort((t,e)=>t.rank>e.rank?-1:t.rank<e.rank?1:t.parentage<e.parentage?-1:t.parentage>e.parentage?1:0),-1===s[0].parentage&&(s.length=1)}!function(t){t[t.enumInputModeBuildGraph=0]="enumInputModeBuildGraph",t[t.enumInputModeSimplifyAlternate=1]="enumInputModeSimplifyAlternate",t[t.enumInputModeSimplifyWinding=2]="enumInputModeSimplifyWinding"}(rl||(rl={})),function(t){t[t.enumSegmentParentageBreakNode=1]="enumSegmentParentageBreakNode",t[t.enumPathBreakNode=2]="enumPathBreakNode"}(ol||(ol={}));class ll{constructor(){this.m_shape=null,this.m_clusterData=new Ue(8),this.m_clusterVertices=new Ue(2),this.m_firstCluster=Ar,this.m_lastCluster=Ar,this.m_halfEdgeData=new Ue(8),this.m_chainData=new Ue(8),this.m_chainAreas=null,this.m_chainPerimeters=null,this.m_universeChain=-1,this.m_simplifiedGeometry=-1,this.m_edgeIndices=[],this.m_clusterIndices=[],this.m_chainIndices=[],this.m_bBuildGeometryParentageSets=!1,this.m_chainBitSetIndex=-1,this.m_edgeBitSetIndex=-1,this.m_edgeBitSetIndexLeft=-1,this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_uniqueBitSets=null,this.m_chainBitSets=[],this.m_edgeBitSets=[],this.m_checkDirtyPlanesweepTolerance=Number.NaN,this.m_geometryIDIndex=-1,this.m_clusterIndex=-1,this.m_halfEdgeIndex=-1,this.m_tmpHalfEdgeParentageIndex=-1,this.m_tmpHalfEdgeParentageIndexLeft=-1,this.m_tmpHalfEdgeWindingNumberIndex=-1,this.m_tmpHalfEdgeOddEvenNumberIndex=-1,this.m_segmentParentageIndex=-1,this.m_segmentIndexHe=-1,this.m_clusterBreakNodeIndex=-1,this.m_universeGeomID=-1,this.m_pointCount=0,this.m_progressCounter=0,this.m_bBuildChains=!0,this.m_bDirtyCheckFailed=!1}setCheckDirtyPlanesweepTolerance(t){this.m_checkDirtyPlanesweepTolerance=t}dirtyCheckFailed(){return this.m_bDirtyCheckFailed}getShape(){return this.m_shape}setEditShape(t,e,s=!0,n=!1){n?this.setEditShapeImpl3D_(t,rl.enumInputModeBuildGraph,null,e,!1):this.setEditShapeImpl_(t,rl.enumInputModeBuildGraph,null,e,s)}setAndSimplifyEditShapeAlternate(t,e,s=null,n=!1){const i=[];i.push(e),this.m_simplifiedGeometry=e,n?this.setEditShapeImpl3D_(t,rl.enumInputModeSimplifyAlternate,i,s,!1):this.setEditShapeImpl_(t,rl.enumInputModeSimplifyAlternate,i,s,t.getGeometryType(e)===o.enumPolygon)}setAndSimplifyEditShapeWinding(t,e,s=null){const n=[];n.push(e),this.m_simplifiedGeometry=e,this.setEditShapeImpl_(t,rl.enumInputModeSimplifyWinding,n,s,!0)}removeShape(){null!==this.m_shape&&(-1!==this.m_geometryIDIndex&&(this.m_shape.removeGeometryUserIndex(this.m_geometryIDIndex),this.m_geometryIDIndex=-1),-1!==this.m_clusterIndex&&(this.m_shape.removeUserIndex(this.m_clusterIndex),this.m_clusterIndex=-1),-1!==this.m_halfEdgeIndex&&(this.m_shape.removeUserIndex(this.m_halfEdgeIndex),this.m_halfEdgeIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1),-1!==this.m_segmentParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),-1!==this.m_segmentIndexHe&&(this.deleteUserIndexForHalfEdges(this.m_segmentIndexHe),this.m_segmentIndexHe=-1),-1!==this.m_clusterBreakNodeIndex&&(this.deleteUserIndexForClusters(this.m_clusterBreakNodeIndex),this.m_clusterBreakNodeIndex=-1),this.deleteEdgeBitSets_(),this.deleteChainBitSets_(),this.m_emptyBitSet=null,this.m_geometryMapID=null,this.m_shape=null,this.m_clusterData.deleteAll(!0),this.m_clusterVertices.deleteAll(!0),this.m_firstCluster=Ar,this.m_lastCluster=Ar,this.m_halfEdgeData.deleteAll(!0),this.m_edgeIndices.length=0,this.m_clusterIndices.length=0,this.m_chainIndices.length=0,this.m_chainData.deleteAll(!0),this.m_universeChain=Ar,this.m_chainAreas=null)}getClusterHalfEdge(t){return this.m_clusterData.getField(t,2)}queryXY(t,e){const s=this.getClusterVertexIndex_(t);e.assign(this.m_shape.getXYWithIndex(s))}queryXYZ(t,e){n(0)}getClusterParentage(t){return this.m_clusterData.getField(t,1)}getFirstCluster(){return this.m_firstCluster}getPrevCluster(t){return this.m_clusterData.getField(t,3)}getNextCluster(t){return this.m_clusterData.getField(t,4)}getClusterChain(t){return this.m_clusterData.getField(t,6)}getClusterVertexIterator(t){return this.m_clusterData.getField(t,7)}incrementVertexIterator(t){return this.m_clusterVertices.getField(t,1)}getVertexFromVertexIterator(t){return this.m_clusterVertices.getField(t,0)}getClusterUserIndex(t,e){const s=this.getClusterIndex_(t),n=this.m_clusterIndices[e];return n.size()<=s?-1:n.read(s)}setClusterUserIndex(t,e,s){const n=this.getClusterIndex_(t),i=this.m_clusterIndices[e];i.size()<=n&&i.resize(this.m_clusterData.size(),-1),i.write(n,s)}hasClusterUserIndexFlags(t,e,s){if(-1===e)return!1;const n=this.getClusterUserIndex(t,e);return-1!==n&&0!==(s&n)}setClusterUserIndexFlags(t,e,s){const n=this.getClusterIndex_(t),i=this.m_clusterIndices[e];i.size()<=n&&i.resize(this.m_clusterData.size(),-1);let r=i.read(n);-1===r&&(r=0),i.write(n,s|r)}clearClusterUserIndexFlags(t,e,s){const n=this.getClusterIndex_(t),i=this.m_clusterIndices[e];i.size()<=n&&i.resize(this.m_clusterData.size(),-1);let r=i.read(n);-1===r&&(r=0),i.write(n,~s&r)}createUserIndexForClusters(t=-1){const e=new Fe(this.m_clusterData.capacity(),t);for(let t=0,s=this.m_clusterIndices.length;t<s;t++)if(null===this.m_clusterIndices[t])return this.m_clusterIndices[t]=e,t;return this.m_clusterIndices.push(e),this.m_clusterIndices.length-1}deleteUserIndexForClusters(t){this.m_clusterIndices[t]=null}getHalfEdgeOrigin(t){return this.m_halfEdgeData.getField(t,1)}getHalfEdgeTo(t){return this.getHalfEdgeOrigin(this.getHalfEdgeTwin(t))}getHalfEdgeTwin(t){return this.m_halfEdgeData.getField(t,4)}getHalfEdgePrev(t){return this.m_halfEdgeData.getField(t,5)}getHalfEdgeNext(t){return this.m_halfEdgeData.getField(t,6)}getHalfEdgeChain(t){return this.m_halfEdgeData.getField(t,2)}getHalfEdgeFaceParentage(t){return this.getChainParentage(this.getHalfEdgeChain(t))}getHalfEdgeVertexIterator(t){return this.m_halfEdgeData.getField(t,7)}getHalfEdgeFromXY(t,e){this.queryXY(this.getHalfEdgeOrigin(t),e)}getHalfEdgeToXY(t,e){this.queryXY(this.getHalfEdgeTo(t),e)}isHalfEdgeCurve(t){return-1!==this.m_segmentIndexHe&&-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}getHalfEdgeFromXYZ(t,e){n(0)}getHalfEdgeToXYZ(t,e){n(0)}getHalfEdgeParentage(t){return this.m_halfEdgeData.getField(t,3)&ll.c_EdgeParentageMask}getHalfEdgeUserIndex(t,e){const s=this.getHalfEdgeIndex_(t),n=this.m_edgeIndices[e];return n.size()<=s?-1:n.read(s)}setHalfEdgeUserIndex(t,e,s){const n=this.getHalfEdgeIndex_(t),i=this.m_edgeIndices[e];i.size()<=n&&i.resize(this.m_halfEdgeData.size(),-1),i.write(n,s)}createUserIndexForHalfEdges(t){void 0===t&&(t=-1);const e=new Fe(this.m_halfEdgeData.capacity(),t);for(let t=0,s=this.m_edgeIndices.length;t<s;t++)if(null===this.m_edgeIndices[t])return this.m_edgeIndices[t]=e,t;this.m_edgeIndices.push(e);const s=this.m_edgeIndices.length-1;return n(s>=0&&s<=Number.MAX_SAFE_INTEGER),s}deleteUserIndexForHalfEdges(t){this.m_edgeIndices[t]=null}deleteEdgesBreakFaces_(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],n=this.getHalfEdgeChain(s),i=this.getHalfEdgeTwin(s),r=this.getHalfEdgeChain(i);this.setChainHalfEdge_(n,Ar),this.setChainHalfEdge_(r,Ar),this.updateVertexToHalfEdgeConnection_(s,!0),this.deleteEdgeImpl_(s)}}doesHalfEdgeBelongToAPolygonInterior(t,e){return n(0),!1}doesHalfEdgeBelongToAPolygonExterior(t,e){return n(0),!1}doesHalfEdgeBelongToAPolygonBoundary(t,e){return n(0),!1}doesHalfEdgeBelongToAPolylineInterior(t,e){return n(0),!1}doesHalfEdgeBelongToAPolylineExterior(t,e){return n(0),!1}doesClusterBelongToAPolygonInterior(t,e){return n(0),!1}doesClusterBelongToAPolygonExterior(t,e){return n(0),!1}doesClusterBelongToAPolygonBoundary(t,e){return n(0),!1}getFirstChain(){return this.m_universeChain}getChainHalfEdge(t){return this.m_chainData.getField(t,1)}getChainParentage(t){return this.m_chainData.getField(t,2)}getChainParent(t){return this.m_chainData.getField(t,3)}getChainFirstIsland(t){return this.m_chainData.getField(t,4)}getChainNextInParent(t){return this.m_chainData.getField(t,5)}getChainNext(t){return this.m_chainData.getField(t,7)}getChainArea(t){const e=this.getChainIndex_(t);let s=this.m_chainAreas.read(e);return Number.isNaN(s)&&(this.updateChainAreaAndPerimeter_(t),s=this.m_chainAreas.read(e)),s}getChainPerimeter(t){return n(0),0}getChainUserIndex(t,e){const s=this.getChainIndex_(t),n=this.m_chainIndices[e];return n.size()<=s?-1:n.read(s)}setChainUserIndex(t,e,s){const n=this.getChainIndex_(t),i=this.m_chainIndices[e];i.size()<=n&&i.resize(this.m_chainData.size(),-1),i.write(n,s)}createUserIndexForChains(){const t=new Fe(this.m_chainData.capacity(),-1);for(let e=0,s=this.m_chainIndices.length;e<s;e++)if(null===this.m_chainIndices[e])return this.m_chainIndices[e]=t,e;return this.m_chainIndices.push(t),this.m_chainIndices.length-1}deleteUserIndexForChains(t){this.m_chainIndices[t]=null}extractPolygonFromChainAndIslands(t,e,s,n){const i=e===Ar?t.createGeometry(o.enumPolygon):e,r=new fm;this.extractPolygonPathFromChain_(t,i,s,n,r);for(let e=this.getChainFirstIsland(s);e!==Ar;e=this.getChainNextInParent(e))this.extractPolygonPathFromChain_(t,i,e,n,r);return i}getGeometryID(t){const e=this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex);return n(e>=0),1<<Math.min(e,31)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_clusterIndex)}getHalfEdgeFromVertex(t){return this.m_shape.getUserIndex(t,this.m_halfEdgeIndex)}buildGeometryParentageSets(){this.m_bBuildGeometryParentageSets=!0}getChainBitSet(t){if(n(this.m_bBuildGeometryParentageSets),-1===this.m_chainBitSetIndex)return this.getEmptySet();const e=this.getChainUserIndex(t,this.m_chainBitSetIndex);n(e>=0);let s=this.m_chainBitSets.at(e);return s||(s=this.getEmptySet()),s}getChainBoundaryBitSet(t){n(this.m_bBuildGeometryParentageSets);const e=new el,s=t=>{const s=this.getChainHalfEdge(t);let n=s;do{const t=this.getEdgeBitSet_(n);null!==t&&e.assignOr(t);const s=this.getEdgeBitSet_(this.getHalfEdgeTwin(n));null!==s&&e.assignOr(s),n=this.getHalfEdgeNext(n)}while(n!==s)};s(t);for(let e=this.getChainFirstIsland(t);e!==Ar;e=this.getChainNextInParent(e))s(t);return e}getChainPolygons(t){return n(0),[]}getGeometriesFromBits(t){if(!this.m_bBuildGeometryParentageSets||null===t)return[];if(null===this.m_geometryMapID){this.m_geometryMapID=new Map;for(let t=this.m_shape.getFirstGeometry();t!==Ar;t=this.m_shape.getNextGeometry(t))this.m_geometryMapID.set(this.m_shape.getGeometryUserIndex(t,this.m_geometryIDIndex),t)}const e=[],s=t.getUnorderedBitIterator();for(let t=s.next();t!==Jm.npos();t=s.next())n(this.m_geometryMapID.has(t)),e.push(this.m_geometryMapID.get(t));return e}getVertexDominant(t,e){if(e===Ar)return t;const s=this.getClusterFromVertex(t);return this.getVertexDominantFromCluster(s,e)}getVertexDominantFromCluster(t,e){if(e!==Ar){let s=Ar;for(let n=this.getClusterVertexIterator(t);n!==Ar;n=this.incrementVertexIterator(n)){const t=this.getVertexFromVertexIterator(n);s===Ar&&(s=t);const i=this.m_shape.getPathFromVertex(t);if(this.m_shape.getGeometryFromPath(i)===e){s=t;break}}return s}{const e=this.getClusterVertexIterator(t);return e!==Ar?this.getVertexFromVertexIterator(e):Ar}}isBreakNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,ol.enumSegmentParentageBreakNode)}setBreakNode(t,e){n(-1!==this.m_clusterBreakNodeIndex),e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,ol.enumSegmentParentageBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,ol.enumSegmentParentageBreakNode)}isStrongPathNode(t){return this.hasClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,ol.enumPathBreakNode)}setStrongPathNode(t,e){if(-1===this.m_clusterBreakNodeIndex){if(!e)return;this.m_clusterBreakNodeIndex=this.createUserIndexForClusters()}e?this.setClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,ol.enumPathBreakNode):this.clearClusterUserIndexFlags(t,this.m_clusterBreakNodeIndex,ol.enumPathBreakNode)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getHalfEdgeUserIndex(t,this.m_segmentParentageIndex);return e>=0?e:-1}isCrossroadAhead(t){const e=this.getHalfEdgeNext(t);if(this.isStrongPathNode(this.getHalfEdgeOrigin(e)))return!0;const s=this.getHalfEdgeTwin(e),n=this.getHalfEdgeNext(s);return t!==this.getHalfEdgeTwin(n)}isCrossroadBehind(t){return n(0),!1}getHalfEdgeConnector(t,e){const s=this.getClusterHalfEdge(t);if(s===Ar)return Ar;let n=s,i=Ar,r=Ar;do{if(this.getHalfEdgeTo(n)===e)return n;if(i===Ar){if(i=this.getClusterHalfEdge(e),i===Ar)return Ar;r=i}if(this.getHalfEdgeTo(r)===t)return n=this.getHalfEdgeTwin(r),n;n=this.getHalfEdgeNext(this.getHalfEdgeTwin(n)),r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(n!==s&&r!==i);return Ar}querySegmentXY(t,e){if(-1!==this.m_segmentIndexHe){let s=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==s){if(-2!==s){const t=this.m_shape.getSegmentFromIndex(s);e.copyFrom(t,!0)}else{s=this.getHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe);const n=this.m_shape.getSegmentFromIndex(s);e.copyFrom(n,!0),e.get().reverse()}return}}e.createLine();const s=e.get(),n=l.getNAN();this.getHalfEdgeFromXY(t,n),s.setStartXY(n),this.getHalfEdgeToXY(t,n),s.setEndXY(n)}isCurveEdge(t){return-1!==this.m_segmentIndexHe&&-1!==this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe)}compareEdgeAnglesCurveHelper_(t,e,s){const i=new fm,r=new fm;this.querySegmentXY(t,i),this.querySegmentXY(e,r);const o=i.get(),a=r.get();if(o.equals(a))return 0;const h=new l;this.getHalfEdgeFromXY(t,h);const m=new l;this.getHalfEdgeToXY(t,m);const u=new l;return this.getHalfEdgeToXY(e,u),n(!m.isEqualPoint2D(u)),Ws(o,a)}compareEdgeAnglesHelper_(t,e,s){if(t===e)return 0;if(this.isHalfEdgeCurve(t)||this.isHalfEdgeCurve(e))return this.compareEdgeAnglesCurveHelper_(t,e,s);const n=l.getNAN();this.getHalfEdgeToXY(t,n);const i=l.getNAN();if(this.getHalfEdgeToXY(e,i),n.isEqualPoint2D(i))return 0;const r=l.getNAN();this.getHalfEdgeFromXY(t,r);const o=l.getNAN();o.setSub(n,r);const a=l.getNAN();return a.setSub(i,r),!s||a.y>=0&&o.y>0?l.compareVectors(o,a):0}compareEdgeAngles_(t,e){return this.compareEdgeAnglesHelper_(t,e,!1)}compareEdgeAnglesForPair_(t,e){return this.compareEdgeAnglesHelper_(t,e,!0)}compareEdgeAngles3D_(t,e){return n(0),0}compareEdgeAnglesForPair3D_(t,e){return n(0),0}dbgDumpChains_(){}dbgDumpChainToPolygon_(t,e){}deleteEdgeInternal_(t){const e=this.getHalfEdgeChain(t),s=this.getHalfEdgeTwin(t),i=this.getHalfEdgeChain(s);n(i===e),n(t===this.getHalfEdgeNext(s)||s===this.getHalfEdgeNext(t));let r=this.getHalfEdgeNext(t);r===s&&(r=this.getHalfEdgeNext(r),r===t&&(r=Ar));const o=this.getChainIndex_(e),a=this.m_chainAreas.read(o);Number.isNaN(a)||(this.setChainArea_(e,Number.NaN),this.setChainPerimeter_(e,Number.NaN));const h=this.getChainHalfEdge(e);h!==t&&h!==s||this.setChainHalfEdge_(e,r),this.updateVertexToHalfEdgeConnection_(t,!0),this.deleteEdgeImpl_(t)}getFirstUnvisitedHalfEdgeOnCluster_(t,e,s){let n=e!==Ar?e:this.getClusterHalfEdge(t);if(n===Ar)return Ar;const i=n;for(;;){if(1!==this.getHalfEdgeUserIndex(n,s))return n;const t=this.getHalfEdgeNext(this.getHalfEdgeTwin(n));if(t===i)return Ar;n=t}}removeSpikes_(){let t=!1;const e=this.createUserIndexForHalfEdges();for(let s=this.getFirstCluster();s!==Ar;s=this.getNextCluster(s)){let n=Ar;for(;;){let i=this.getFirstUnvisitedHalfEdgeOnCluster_(s,n,e);if(i===Ar)break;n=this.getHalfEdgeNext(this.getHalfEdgeTwin(i));let r=i;for(;;){const s=this.getHalfEdgeNext(r),o=this.getHalfEdgePrev(r),a=this.getHalfEdgeTwin(r);if(o===a){if(this.deleteEdgeInternal_(r),t=!0,n!==r&&n!==a||(n=Ar),r===i||o===i){if(i=s,r===i||o===i)break;r=s;continue}}else this.setHalfEdgeUserIndex(r,e,1);if(r=s,r===i)break}}}return this.deleteUserIndexForHalfEdges(e),t}progress_(t,e=!1){}newCluster_(){const t=this.m_clusterData.newElement();return this.m_clusterData.setField(t,1,0),t}newHalfEdgePair_(){const t=this.m_halfEdgeData.newElement();this.m_halfEdgeData.setField(t,2,0),this.m_halfEdgeData.setField(t,3,0);const e=this.m_halfEdgeData.newElement();return this.m_halfEdgeData.setField(e,2,0),this.m_halfEdgeData.setField(e,3,0),this.setHalfEdgeTwin_(t,e),this.setHalfEdgeTwin_(e,t),t}newChain_(){const t=this.m_chainData.newElement();return this.m_chainData.setField(t,2,0),t}deleteChain_(t){return n(0),0}getClusterIndex_(t){return this.m_clusterData.elementToIndex(t)}setClusterVertexIterator_(t,e){this.m_clusterData.setField(t,7,e)}setClusterHalfEdge_(t,e){this.m_clusterData.setField(t,2,e)}setClusterParentage_(t,e){this.m_clusterData.setField(t,1,e)}setPrevCluster_(t,e){this.m_clusterData.setField(t,3,e)}setNextCluster_(t,e){this.m_clusterData.setField(t,4,e)}setClusterVertexIndex_(t,e){this.m_clusterData.setField(t,5,e)}getClusterVertexIndex_(t){return this.m_clusterData.getField(t,5)}setClusterChain_(t,e){this.m_clusterData.setField(t,6,e)}addClusterToExteriorChain_(t,e){this.setClusterChain_(e,t)}getHalfEdgeIndex_(t){return this.m_halfEdgeData.elementToIndex(t)}setHalfEdgeOrigin_(t,e){this.m_halfEdgeData.setField(t,1,e)}setHalfEdgeTwin_(t,e){this.m_halfEdgeData.setField(t,4,e)}setHalfEdgePrev_(t,e){this.m_halfEdgeData.setField(t,5,e)}setHalfEdgeNext_(t,e){this.m_halfEdgeData.setField(t,6,e)}setHalfEdgeChain_(t,e){this.m_halfEdgeData.setField(t,2,e)}setHalfEdgeParentage_(t,e){this.m_halfEdgeData.setField(t,3,e)}getHalfEdgeParentageMask_(t){return this.m_halfEdgeData.getField(t,3)}setHalfEdgeVertexIterator_(t,e){this.m_halfEdgeData.setField(t,7,e)}updateVertexToHalfEdgeConnectionHelper_(t,e){const s=e?Ar:t;for(let e=this.getHalfEdgeVertexIterator(t);e!==Ar;e=this.incrementVertexIterator(e)){const t=this.getVertexFromVertexIterator(e);this.m_shape.setUserIndex(t,this.m_halfEdgeIndex,s)}}updateVertexToHalfEdgeConnection_(t,e){t!==Ar&&(this.updateVertexToHalfEdgeConnectionHelper_(t,e),this.updateVertexToHalfEdgeConnectionHelper_(this.getHalfEdgeTwin(t),e))}getChainIndex_(t){return this.m_chainData.elementToIndex(t)}setChainHalfEdge_(t,e){this.m_chainData.setField(t,1,e)}setChainParentage_(t,e){this.m_chainData.setField(t,2,e)}setChainParent_(t,e){this.m_chainData.setField(t,3,e);const s=this.getChainFirstIsland(e);this.setChainNextInParent_(t,s),this.setChainFirstIsland_(e,t)}setChainFirstIsland_(t,e){this.m_chainData.setField(t,4,e)}setChainNextInParent_(t,e){this.m_chainData.setField(t,5,e)}setChainPrev_(t,e){this.m_chainData.setField(t,6,e)}setChainNext_(t,e){this.m_chainData.setField(t,7,e)}setChainArea_(t,e){const s=this.getChainIndex_(t);this.m_chainAreas.write(s,e)}setChainPerimeter_(t,e){const s=this.getChainIndex_(t);this.m_chainPerimeters.write(s,e)}updateChainAreaAndPerimeter_(t){const e=this.m_shape.hasCurves(),s=new q(0),n=new q(0),i=this.getChainHalfEdge(t),r=l.getNAN(),o=l.getNAN(),a=l.getNAN();this.getHalfEdgeFromXY(i,r),o.setCoordsPoint2D(r);let h=i;do{this.getHalfEdgeToXY(h,a),e&&this.isCurveEdge(h)||n.pe(l.distance(o,a)),this.getHalfEdgeChain(this.getHalfEdgeTwin(h))!==t&&s.pe((a.x-r.x-(o.x-r.x))*(a.y-r.y+(o.y-r.y))*.5),o.setCoordsPoint2D(a),h=this.getHalfEdgeNext(h)}while(h!==i);if(e){const e=new fm;h=i;do{this.getHalfEdgeToXY(h,a);const i=this.isCurveEdge(h);if(i&&(this.querySegmentXY(h,e),n.pe(e.get().calculateLength2D())),this.getHalfEdgeChain(this.getHalfEdgeTwin(h))!==t&&i){const t=e.get().calculateArea2DHelper();s.pe(t)}h=this.getHalfEdgeNext(h)}while(h!==i)}const m=this.getChainIndex_(t);this.m_chainAreas.write(m,s.getResult()),this.m_chainPerimeters.write(m,n.getResult())}getChainTopmostEdge_(t){return n(0),0}planeSweepParentage_(t,e){const s=new nl(this),n=new ze;n.setCapacity(Math.trunc(this.m_pointCount/2)),n.setComparator(s);const i=[],r=this.createUserIndexForHalfEdges();let o=null;const a=l.getNAN();for(let h=this.getFirstCluster();h!==Ar;h=this.getNextCluster(h)){this.progress_(e);const m=this.getClusterHalfEdge(h);if(m!==Ar){if(i.length=0,!this.tryOptimizedInsertion_(n,r,i,h,m)){this.queryXY(h,a),s.setY(a.y);let t=m;do{const e=this.getHalfEdgeUserIndex(t,r);-1!==e&&(n.deleteNode(e),this.setHalfEdgeUserIndex(t,r,Ue.impossibleIndex2())),t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(m!==t);t=m;do{if(-1===this.getHalfEdgeUserIndex(t,r)){const e=n.addElement(t);i.push(e)}t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(m!==t)}for(let e=i.length-1;e>=0;e--){const s=i[e],o=n.getElement(s),a=this.getHalfEdgeTwin(o);this.setHalfEdgeUserIndex(a,r,s),this.planeSweepParentagePropagateParentage_(n,s,t)}}else if(this.getClusterChain(h)===Ar){null===o&&(o=new il(this)),this.queryXY(h,a),o.setPointXY(a);const t=n.searchLowerBound(o);let e=this.m_universeChain;if(-1!==t){let s=n.getElement(t);this.getHalfEdgeChain(s)===this.getHalfEdgeChain(this.getHalfEdgeTwin(s))&&(s=this.getLeftSkipPolylines_(n,t)),s!==Ar&&(e=this.getHalfEdgeChain(s))}this.addClusterToExteriorChain_(e,h)}}this.deleteUserIndexForHalfEdges(r)}planeSweepParentagePropagateParentage_(t,e,s){const i=t.getElement(e),r=this.getHalfEdgeChain(i);if(this.getChainParent(r)!==Ar)return;const o=this.getLeftSkipPolylines_(t,e),a=this.getHalfEdgeTwin(i),h=this.getHalfEdgeChain(a);let m=this.getChainParent(r),l=this.getChainParent(h);if(o===Ar)m===Ar&&(h===r?(this.setChainParent_(h,this.m_universeChain),l=this.m_universeChain,m=l):(l===Ar&&(this.setChainParent_(h,this.m_universeChain),l=this.m_universeChain),this.setChainParent_(r,h),m=h));else{const t=this.getHalfEdgeChain(o);if(l===Ar){if(this.getChainArea(t)<=0){const e=this.getChainParent(t);this.setChainParent_(h,e),l=e}else this.setChainParent_(h,t),l=t;h===r&&(m=l)}}m===Ar&&(this.trySetChainParentFromTwin_(r,h),m=this.getChainParent(r)),n(m!==Ar),s===rl.enumInputModeBuildGraph?this.propagateParentageBuildGraph_(t,e,i,o):s===rl.enumInputModeSimplifyWinding?this.propagateParentageWinding_(t,e,i,o,a,r,h):s===rl.enumInputModeSimplifyAlternate&&this.propagateParentageAlternate_(t,e,i,o,a,r,h)}propagateParentageBuildGraph_(t,e,s,n){let i,r=e;n===Ar?(r=t.getNext(r),i=this.getHalfEdgeChain(s)):i=this.getHalfEdgeChain(n);let o=null,a=this.getChainParentage(i);for(this.m_bBuildGeometryParentageSets&&(o=this.getChainBitSet(i));-1!==r;r=t.getNext(r)){const e=t.getElement(r),s=this.getHalfEdgeTwin(e);i=this.getHalfEdgeChain(e);const n=this.getHalfEdgeChain(s);if(this.m_bBuildGeometryParentageSets){let t=this.getChainBitSet(n);t=new el({copy:t}),t.assignOr(o),this.setChainBitSet_(n,t);let s=this.getChainBitSet(i);const r=this.getLeftEdgeBitSet_(e),a=new el({copy:o});if(a.assignSubtract(r),a.isZero())break;s=new el({copy:s}),s.assignOr(a),this.setChainBitSet_(i,s),o=s}const h=this.getChainParentage(n),m=h|a;m!==h&&this.setChainParentage_(n,m);let l=this.getChainParentage(i);const u=a&~this.getHalfEdgeUserIndex(e,this.m_tmpHalfEdgeParentageIndexLeft);if(u&&(l|=u,this.setChainParentage_(i,l)),0===u)break;a=l}}propagateParentageWinding_(t,e,s,i,r,o,a){if(o===a)return;let h=this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeWindingNumberIndex);h+=this.getHalfEdgeUserIndex(r,this.m_tmpHalfEdgeWindingNumberIndex);let m=0;const l=[],u=[];u.push(0);for(let s=t.getFirst();s!==e;s=t.getNext(s)){const e=t.getElement(s),i=this.getHalfEdgeTwin(e),r=this.getHalfEdgeChain(e),o=this.getHalfEdgeChain(i);if(r!==o){let t=this.getHalfEdgeUserIndex(e,this.m_tmpHalfEdgeWindingNumberIndex);t+=this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex),m+=t;let s=!1;0!==l.length&&l.at(-1)===o&&(u.pop(),l.pop(),s=!0),n(this.getChainParent(o)!==Ar),s&&this.getChainParent(o)===r||(u.push(m),l.push(r))}}if(m+=h,0!==l.length&&l.at(-1)===a&&(u.pop(),l.pop()),0!==m){if(0===u.at(-1)){const t=this.m_simplifiedGeometry,e=this.getGeometryID(t);this.setChainParentage_(o,e)}}else if(0!==u.at(-1)){const t=this.m_simplifiedGeometry,e=this.getGeometryID(t);this.setChainParentage_(o,e)}}propagateParentageAlternate_(t,e,s,n,i,r,o){const a=this.m_simplifiedGeometry,h=this.getGeometryID(a);if(n===Ar)this.setChainParentage_(o,this.m_universeGeomID),1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,h):this.setChainParentage_(r,this.m_universeGeomID);else{const t=this.getChainParentage(o);if(0===t){const t=this.getHalfEdgeChain(n),e=this.getChainParentage(t);this.setChainParentage_(o,e),1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,e===h?this.m_universeGeomID:h):this.setChainParentage_(r,e)}else 1&this.getHalfEdgeUserIndex(s,this.m_tmpHalfEdgeOddEvenNumberIndex)?this.setChainParentage_(r,t===h?this.m_universeGeomID:h):this.setChainParentage_(r,t)}}tryOptimizedInsertion_(t,e,s,n,i){let r=i,o=-1,a=Ar,h=0;do{if(2===h)return!1;const t=this.getHalfEdgeUserIndex(r,e);if(-1!==t){if(-1!==o)return!1;o=t}else{if(a!==Ar)return!1;a=r}h++,r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(i!==r);return a!==Ar&&-1!==o&&(this.setHalfEdgeUserIndex(t.getElement(o),e,Ue.impossibleIndex2()),t.setElement(o,a),s.push(o),!0)}trySetChainParentFromTwin_(t,e){const s=this.getChainArea(t);if(0===s)return!1;const n=this.getChainArea(e);if(s>0&&n<0||s<0&&n>0)return this.setChainParent_(t,e),!0;{const s=this.getChainParent(e);if(s!==Ar)return this.setChainParent_(t,s),!0}return!1}createHalfEdges_(t,e){this.m_halfEdgeIndex=this.m_shape.createUserIndex();for(let s=0,n=e.size();s<n;s++){const n=e.read(s),i=this.m_shape.getUserIndex(n,this.m_clusterIndex),r=this.m_shape.getPathFromVertex(n),a=this.m_shape.getGeometryFromPath(r),h=this.m_shape.getGeometryType(a);if(Z(h)){const e=this.m_shape.getNextVertex(n);if(e===Ar)continue;const s=this.m_shape.getUserIndex(e,this.m_clusterIndex);if(i===s)continue;const r=this.newHalfEdgePair_(),m=this.getHalfEdgeTwin(r),l=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(l,0,n),this.m_clusterVertices.setField(l,1,-1),this.setHalfEdgeVertexIterator_(r,l),this.m_shape.setUserIndex(n,this.m_halfEdgeIndex,r),this.setHalfEdgeOrigin_(r,i);const u=this.getClusterHalfEdge(i);if(u===Ar)this.setClusterHalfEdge_(i,r),this.setHalfEdgePrev_(r,m),this.setHalfEdgeNext_(m,r);else{const t=this.getHalfEdgePrev(u);this.setHalfEdgePrev_(u,m),this.setHalfEdgeNext_(m,u),this.setHalfEdgeNext_(t,r),this.setHalfEdgePrev_(r,t)}this.setHalfEdgeOrigin_(m,s);const c=this.getClusterHalfEdge(s);if(c===Ar)this.setClusterHalfEdge_(s,m),this.setHalfEdgeNext_(r,m),this.setHalfEdgePrev_(m,r);else{const t=this.getHalfEdgePrev(c);this.setHalfEdgePrev_(c,r),this.setHalfEdgeNext_(r,c),this.setHalfEdgeNext_(t,m),this.setHalfEdgePrev_(m,t)}const g=this.getGeometryID(a);if(t===rl.enumInputModeBuildGraph){const t=h===o.enumPolygon?g:0;if(this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeParentageIndex,0),this.setHalfEdgeUserIndex(r,this.m_tmpHalfEdgeParentageIndex,t),this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeParentageIndexLeft,t),this.setHalfEdgeUserIndex(r,this.m_tmpHalfEdgeParentageIndexLeft,0),this.m_bBuildGeometryParentageSets){const t=new el,e=this.m_shape.getGeometryUserIndex(a,this.m_geometryIDIndex);t.setBit(e),this.setEdgeBitSet_(r,t),this.setEdgeBitSet_(m,null),this.setLeftEdgeBitSet_(m,t),this.setLeftEdgeBitSet_(r,null)}}else if(t===rl.enumInputModeSimplifyWinding){const t=this.m_shape.getXY(n),s=this.m_shape.getXY(e);let i=0,o=0;t.compare(s)<0?i=1:o=-1,this.setHalfEdgeUserIndex(r,this.m_tmpHalfEdgeWindingNumberIndex,i),this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeWindingNumberIndex,o)}else t===rl.enumInputModeSimplifyAlternate&&(this.setHalfEdgeUserIndex(r,this.m_tmpHalfEdgeOddEvenNumberIndex,1),this.setHalfEdgeUserIndex(m,this.m_tmpHalfEdgeOddEvenNumberIndex,1));const d=h===o.enumPolygon?ll.c_EdgeBitMask:0;this.setHalfEdgeParentage_(r,g|d),this.setHalfEdgeParentage_(m,g|d)}}if(this.m_shape.hasCurves()){this.m_segmentIndexHe=this.createUserIndexForHalfEdges();for(let t=0,s=e.size();t<s;t++){const s=e.read(t);if(this.m_shape.getSegment(s)){const t=this.m_shape.getUserIndex(s,this.m_halfEdgeIndex);t!==Ar&&(this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,this.m_shape.getVertexIndex(s)),this.setHalfEdgeUserIndex(this.getHalfEdgeTwin(t),this.m_segmentIndexHe,-2))}}}}mergeVertexListsOfEdges_(t,e){{const s=this.getHalfEdgeVertexIterator(e);if(s!==Ar){const n=this.getHalfEdgeVertexIterator(t);this.m_clusterVertices.setField(s,1,n),this.setHalfEdgeVertexIterator_(t,s),this.setHalfEdgeVertexIterator_(e,Ar)}}const s=this.getHalfEdgeTwin(t),n=this.getHalfEdgeTwin(e);{const t=this.getHalfEdgeVertexIterator(n);if(t!==Ar){const e=this.getHalfEdgeVertexIterator(s);this.m_clusterVertices.setField(t,1,e),this.setHalfEdgeVertexIterator_(s,t),this.setHalfEdgeVertexIterator_(n,Ar)}}if(-1!==this.m_segmentIndexHe){let i=this.getHalfEdgeUserIndex(t,this.m_segmentIndexHe);if(-1!==i){if(-2===i){const s=this.getHalfEdgeUserIndex(e,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(t,this.m_segmentIndexHe,s)}if(i=this.getHalfEdgeUserIndex(s,this.m_segmentIndexHe),-2===i){const t=this.getHalfEdgeUserIndex(n,this.m_segmentIndexHe);this.setHalfEdgeUserIndex(s,this.m_segmentIndexHe,t)}}}}sortHalfEdgesByAngle_(t){const e=[];for(let s=this.getFirstCluster();s!==Ar;s=this.getNextCluster(s)){e.length=0;const n=this.getClusterHalfEdge(s);if(n!==Ar){let i=n;do{e.push(i),i=this.getHalfEdgeNext(this.getHalfEdgeTwin(i))}while(i!==n);if(e.length>1){let i=!0;e.length>2?(e.sort((t,e)=>this.compareEdgeAngles_(t,e)),e.push(e[0])):this.compareEdgeAnglesForPair_(e[0],e[1])>0?e[1]=p(e[0],e[0]=e[1]):i=!1;let r=e[0],o=r,a=this.getHalfEdgeTo(o),h=this.getHalfEdgeTwin(o),m=Ar;for(let s=1,n=e.length;s<n;s++){const n=e[s],i=this.getHalfEdgeTwin(n),l=this.getHalfEdgeOrigin(i);if(l!==a||n===o)this.updateVertexToHalfEdgeConnection_(m,!1),m=Ar,o=n,a=l,h=i;else{if(t===rl.enumInputModeBuildGraph){const t=this.getHalfEdgeParentageMask_(o)|this.getHalfEdgeParentageMask_(n);if(this.setHalfEdgeParentage_(o,t),this.setHalfEdgeParentage_(h,t),this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndex,this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndex)|this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeParentageIndex)),this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeParentageIndexLeft)),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndexLeft,this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeParentageIndexLeft)|this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeParentageIndexLeft)),this.m_bBuildGeometryParentageSets){let t,e,s;t=this.getEdgeBitSet_(o),e=this.getEdgeBitSet_(n),s=new el({copy:t}),s.assignOr(e),this.setEdgeBitSet_(o,s),t=this.getEdgeBitSet_(h),e=this.getEdgeBitSet_(i),s=new el({copy:t}),s.assignOr(e),this.setEdgeBitSet_(h,s),t=this.getLeftEdgeBitSet_(o),e=this.getLeftEdgeBitSet_(n),s=new el({copy:t}),s.assignOr(e),this.setLeftEdgeBitSet_(o,s),t=this.getLeftEdgeBitSet_(h),e=this.getLeftEdgeBitSet_(i),s=new el({copy:t}),s.assignOr(e),this.setLeftEdgeBitSet_(h,s)}}else if(-1!==this.m_tmpHalfEdgeWindingNumberIndex){const t=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeWindingNumberIndex),e=this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeWindingNumberIndex)+this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeWindingNumberIndex);this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeWindingNumberIndex,t),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeWindingNumberIndex,e)}else if(-1!==this.m_tmpHalfEdgeOddEvenNumberIndex){const t=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(n,this.m_tmpHalfEdgeOddEvenNumberIndex),e=this.getHalfEdgeUserIndex(h,this.m_tmpHalfEdgeOddEvenNumberIndex)+this.getHalfEdgeUserIndex(i,this.m_tmpHalfEdgeOddEvenNumberIndex);this.setHalfEdgeUserIndex(o,this.m_tmpHalfEdgeOddEvenNumberIndex,t),this.setHalfEdgeUserIndex(h,this.m_tmpHalfEdgeOddEvenNumberIndex,e)}this.mergeVertexListsOfEdges_(o,n),this.deleteEdgeImpl_(n),m=o,e[s]=Ar,n===r&&(e[0]=Ar,r=Ar)}}if(this.updateVertexToHalfEdgeConnection_(m,!1),m=Ar,!i){r=Ar;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s!==Ar){r=s;break}}n!==r&&this.setClusterHalfEdge_(s,r);continue}r=Ar;for(let t=0,s=e.length;t<s;t++){const s=e[t];if(s===Ar)continue;if(r===Ar){r=s,o=r,a=this.getHalfEdgeTo(o),h=this.getHalfEdgeTwin(o);continue}if(s===o)continue;const n=this.getHalfEdgeTwin(s),i=this.getHalfEdgeOrigin(n);this.setHalfEdgeNext_(h,s),this.setHalfEdgePrev_(s,h),o=s,a=i,h=n}this.setClusterHalfEdge_(s,r)}}}}sortHalfEdgesByAngle3D_(t){n(0)}buildChains_(t){this.m_universeChain=this.newChain_(),this.setChainHalfEdge_(this.m_universeChain,Ar);let e=this.m_universeChain;const s=this.createUserIndexForHalfEdges();for(let t=this.getFirstCluster();t!==Ar;t=this.getNextCluster(t)){const n=this.getClusterHalfEdge(t);if(n!==Ar){let t=n;do{if(1!==this.getHalfEdgeUserIndex(t,s)){const n=this.newChain_();this.setChainHalfEdge_(n,t),this.setChainPrev_(n,e),this.setChainNext_(e,n);let i=null;this.m_bBuildGeometryParentageSets&&(i=new el),e=n;let r=0,o=t;do{-1!==this.m_tmpHalfEdgeParentageIndex&&(r|=this.getHalfEdgeUserIndex(o,this.m_tmpHalfEdgeParentageIndex)),this.m_bBuildGeometryParentageSets&&i.assignOr(this.getEdgeBitSet_(o)),this.setHalfEdgeChain_(o,n),this.setHalfEdgeUserIndex(o,s,1),o=this.getHalfEdgeNext(o)}while(o!==t);this.m_bBuildGeometryParentageSets&&this.setChainBitSet_(n,i),this.setChainParentage_(n,r)}t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(t!==n)}}this.m_chainAreas=new Ye(this.m_chainData.size(),Number.NaN),this.m_chainPerimeters=new Ye(this.m_chainData.size(),Number.NaN),this.setChainArea_(this.m_universeChain,Number.POSITIVE_INFINITY),this.setChainPerimeter_(this.m_universeChain,Number.POSITIVE_INFINITY),this.deleteUserIndexForHalfEdges(s)}simplify_(t){n(0)}simplifyAlternate_(){n(0)}simplifyWinding_(){n(0)}setEditShapeImpl_(t,e,s,n,i){this.removeShape(),this.m_bBuildChains=i,this.m_shape=t,this.m_geometryIDIndex=this.m_shape.createGeometryUserIndex();let r=this.m_shape.getTotalPointCount();if(s){r=0;for(let t=0,e=s.length;t<e;t++)r+=this.m_shape.getPointCount(s[t])}const o=new Fe(0);let a=0,h=0;{let t=null!=s?s[0]:this.m_shape.getFirstGeometry(),e=1;for(;t!==Ar;){this.m_shape.setGeometryUserIndex(t,this.m_geometryIDIndex,h++);for(let e=this.m_shape.getFirstPath(t);e!==Ar;e=this.m_shape.getNextPath(e)){let t=this.m_shape.getFirstVertex(e);for(let s=0,n=this.m_shape.getPathSize(e);s<n;s++)o.add(t),t=this.m_shape.getNextVertex(t)}V(this.m_shape.getGeometryType(t))||(a+=this.m_shape.getPathCount(t)),null!=s?(t=e<s.length?s[e]:Ar,e++):t=this.m_shape.getNextGeometry(t)}}this.m_universeGeomID=1<<Math.min(h,31),this.m_pointCount=o.size(),this.m_shape.sortVerticesSimpleByY(o,0,this.m_pointCount),this.m_clusterVertices.setCapacity(this.m_pointCount),this.progress_(n,!0),this.m_clusterData.setCapacity(this.m_pointCount+10),this.m_halfEdgeData.setCapacity(2*this.m_pointCount+32),this.m_chainData.setCapacity(Math.max(32,a)),this.m_clusterIndex=this.m_shape.createUserIndex();const m=l.getNAN();let u=0;const c=l.getNAN();for(let t=0;t<=this.m_pointCount;t++){if(t<this.m_pointCount){const e=o.read(t);this.m_shape.queryXY(e,c)}else c.setNAN();if(!m.isEqualPoint2D(c)){if(u<t){const e=this.newCluster_();let s=Ar,n=-1;for(let i=u;i<t;i++){n=o.read(i),this.m_shape.setUserIndex(n,this.m_clusterIndex,e);const t=this.m_clusterVertices.newElement();this.m_clusterVertices.setField(t,0,n),this.m_clusterVertices.setField(t,1,s),s=t;const r=this.m_shape.getPathFromVertex(n),a=this.m_shape.getGeometryFromPath(r),h=this.getGeometryID(a);this.setClusterParentage_(e,this.getClusterParentage(e)|h)}this.setClusterVertexIterator_(e,s),this.setClusterVertexIndex_(e,this.m_shape.getVertexIndex(n)),this.m_lastCluster!==Ar&&this.setNextCluster_(this.m_lastCluster,e),this.setPrevCluster_(e,this.m_lastCluster),this.m_lastCluster=e,this.m_firstCluster===Ar&&(this.m_firstCluster=e)}u=t,m.setCoordsPoint2D(c)}}if(this.m_shape.hasSegmentParentage()){-1===this.m_clusterBreakNodeIndex&&(this.m_clusterBreakNodeIndex=this.createUserIndexForClusters());for(let t=0;t<this.m_pointCount;t++){const e=o.read(t);if(this.m_shape.getSegmentParentageBreakVertex(e)){const t=this.getClusterFromVertex(e);this.setBreakNode(t,!0)}}}this.progress_(n,!0);{let t=null!=s?s[0]:this.m_shape.getFirstGeometry(),e=1;for(;t!==Ar;){for(let e=this.m_shape.getFirstPath(t);e!==Ar;e=this.m_shape.getNextPath(e)){if(this.m_shape.isStrongPathStart(e)){const t=this.m_shape.getFirstVertex(e),s=this.getClusterFromVertex(t);this.setStrongPathNode(s,!0)}if(this.m_shape.isStrongPathEnd(e)){const t=this.m_shape.isClosedPath(e)?this.m_shape.getFirstVertex(e):this.m_shape.getLastVertex(e),s=this.getClusterFromVertex(t);this.setStrongPathNode(s,!0)}}null!=s?(t=e<s.length?s[e]:Ar,e++):t=this.m_shape.getNextGeometry(t)}}if(e===rl.enumInputModeBuildGraph&&(this.m_tmpHalfEdgeParentageIndex=this.createUserIndexForHalfEdges(),this.m_tmpHalfEdgeParentageIndexLeft=this.createUserIndexForHalfEdges()),e===rl.enumInputModeSimplifyWinding&&(this.m_tmpHalfEdgeWindingNumberIndex=this.createUserIndexForHalfEdges()),e===rl.enumInputModeSimplifyAlternate&&(this.m_tmpHalfEdgeOddEvenNumberIndex=this.createUserIndexForHalfEdges()),this.createHalfEdges_(e,o),this.dbgNavigate_(),this.sortHalfEdgesByAngle_(e),!Number.isNaN(this.m_checkDirtyPlanesweepTolerance)&&!this.checkStructureAfterDirtySweep_())return this.m_bDirtyCheckFailed=!0,void this.cleanSetEditShapeImpl_();this.buildChains_(e),-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),this.m_bBuildChains&&this.planeSweepParentage_(e,n),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),this.dbgChkChainParents_(),this.dbgDumpChains_(),this.mergeSegmentParentage_(),this.dbgNavigate_(),this.dbgDumpChains_(),this.cleanSetEditShapeImpl_()}setEditShapeImpl3D_(t,e,s,i,r){n(0)}cleanSetEditShapeImpl_(){-1!==this.m_tmpHalfEdgeParentageIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndex),this.m_tmpHalfEdgeParentageIndex=-1),-1!==this.m_tmpHalfEdgeParentageIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeParentageIndexLeft),this.m_tmpHalfEdgeParentageIndexLeft=-1),-1!==this.m_tmpHalfEdgeWindingNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeWindingNumberIndex),this.m_tmpHalfEdgeWindingNumberIndex=-1),-1!==this.m_tmpHalfEdgeOddEvenNumberIndex&&(this.deleteUserIndexForHalfEdges(this.m_tmpHalfEdgeOddEvenNumberIndex),this.m_tmpHalfEdgeOddEvenNumberIndex=-1)}cleanSetEditShapeImpl3D_(){n(0)}dbgNavigate_(){}dbgChkChainParents_(){}deleteEdgeImpl_(t){const e=this.getHalfEdgeNext(t),s=this.getHalfEdgePrev(t),n=this.getHalfEdgeTwin(t),i=this.getHalfEdgeNext(n),r=this.getHalfEdgePrev(n);e!==n&&(this.setHalfEdgeNext_(r,e),this.setHalfEdgePrev_(e,r)),s!==n&&(this.setHalfEdgeNext_(s,i),this.setHalfEdgePrev_(i,s));const o=this.getHalfEdgeOrigin(t);this.getClusterHalfEdge(o)===t&&(i!==t?this.setClusterHalfEdge_(o,i):this.setClusterHalfEdge_(o,Ar));const a=this.getHalfEdgeOrigin(n);this.getClusterHalfEdge(a)===n&&(e!==n?this.setClusterHalfEdge_(a,e):this.setClusterHalfEdge_(a,Ar)),this.m_halfEdgeData.deleteElement(t),this.m_halfEdgeData.deleteElement(n)}getLeftSkipPolylines_(t,e){let s=e;for(;;){if(s=t.getPrev(s),-1===s)return Ar;{const e=t.getElement(s);if(this.getHalfEdgeChain(e)!==this.getHalfEdgeChain(this.getHalfEdgeTwin(e)))return e}}}checkStructureAfterDirtySweep_(){const t=ot(this.m_checkDirtyPlanesweepTolerance),e=new l,s=new l,n=new l,i=new l,r=new l;for(let o=this.getFirstCluster();o!==Ar;o=this.getNextCluster(o)){const a=this.getClusterHalfEdge(o);if(a!==Ar){let o=a;this.getHalfEdgeFromXY(o,e),this.getHalfEdgeToXY(o,s),n.setSub(s,e);let h=n.sqrLength();do{const a=o;if(o=this.getHalfEdgeNext(this.getHalfEdgeTwin(o)),o!==a){this.getHalfEdgeToXY(o,i),r.setSub(i,e);const a=r.sqrLength(),m=r.crossProduct(n),l=m*m/(a*h);if(Math.min(a,h)*l<=t&&r.dotProduct(n)>=0)return!1;n.assign(r),h=a,s.assign(i)}}while(o!==a)}}return!0}extractPolygonPathFromChain_(t,e,s,n,i){const r=this.m_shape.hasSegmentParentage(),o=this.getChainHalfEdge(s);let a=o,h=Ar;const m=new qe;do{const o=this.getHalfEdgeTwin(a);if(this.getHalfEdgeChain(o)!==s){let s=Ar;const o=this.getHalfEdgeOrigin(a);if(n===Ar){const t=this.getClusterVertexIterator(o);s=this.getVertexFromVertexIterator(t)}else for(let t=this.getClusterVertexIterator(o);t!==Ar;t=this.incrementVertexIterator(t)){const e=this.getVertexFromVertexIterator(t);s===Ar&&(s=e);const i=this.m_shape.getPathFromVertex(e);if(this.m_shape.getGeometryFromPath(i)===n){s=e;break}}let l;if(h===Ar&&(h=t.insertPath(e,Ar),t.setClosedPath(h,!0)),this.m_shape===t?l=t.addVertex(h,s):(this.m_shape.queryPoint(s,m),l=t.addPoint(h,m)),this.isHalfEdgeCurve(a)&&(this.querySegmentXY(a,i),t.setSegmentToIndex(t.getVertexIndex(l),i.get().clone())),r){const e=this.getSegmentParentage(a);t.setSegmentParentageAndBreak(l,e,this.isBreakNode(o))}}a=this.getHalfEdgeNext(a)}while(a!==o)}mergeSegmentParentage_(){if(!this.m_shape.hasSegmentParentage())return;n(-1!==this.m_clusterBreakNodeIndex),n(-1===this.m_segmentParentageIndex);for(let t=this.getFirstCluster();t!==Ar;t=this.getNextCluster(t)){let e=0;const s=this.getClusterHalfEdge(t);if(s!==Ar){let t=s;do{e++,t=this.getHalfEdgeNext(this.getHalfEdgeTwin(t))}while(t!==s&&e<3)}2!==e&&this.setBreakNode(t,!0)}let t=[],e=[];this.m_segmentParentageIndex=this.createUserIndexForHalfEdges();const s=this.createUserIndexForHalfEdges();for(let n=this.getFirstCluster();n!==Ar;n=this.getNextCluster(n)){const i=this.getClusterHalfEdge(n);if(i!==Ar){let n=!1,r=i;do{let i=r;for(;-1===this.getHalfEdgeUserIndex(i,s);){const r=this.getHalfEdgeNext(i),o=this.getHalfEdgeTwin(i);ml(this,i,e);const a=e.at(-1).parentage;if(!n){const e=this.getHalfEdgeOrigin(i);if(!this.isBreakNode(e)){const e=this.getHalfEdgePrev(i);i!==e&&(ml(this,e,t),n=!0)}}if(n&&!hl(e,t)){const t=this.getHalfEdgeOrigin(i);this.setBreakNode(t,!0)}t=p(e,e=t),n=!0;const h=this.getHalfEdgeOrigin(r);this.isBreakNode(h)&&(n=!1),this.setHalfEdgeUserIndex(i,this.m_segmentParentageIndex,a),this.setHalfEdgeUserIndex(o,this.m_segmentParentageIndex,a),this.setHalfEdgeUserIndex(i,s,1),this.setHalfEdgeUserIndex(o,s,1),i=r}r=this.getHalfEdgeNext(this.getHalfEdgeTwin(r))}while(r!==i)}}this.deleteUserIndexForHalfEdges(s)}registerNewBitSet(t){return null===this.m_uniqueBitSets&&(this.m_uniqueBitSets=new sl(t=>t.getHashCode(),(t,e)=>t.equals(e)),this.m_uniqueBitSets.add(this.getEmptySet())),null===t?this.getEmptySet():this.m_uniqueBitSets.has(t)?this.m_uniqueBitSets.get(t):(this.m_uniqueBitSets.add(t),t)}getLeftEdgeBitSet_(t){const e=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);return n(e>=0),n(this.m_edgeBitSets.at(e)),this.m_edgeBitSets.at(e)}getEdgeBitSet_(t){const e=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);return n(e>=0),this.m_edgeBitSets.at(e)}setEdgeBitSet_(t,e){n(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),-1===this.m_edgeBitSetIndex&&(this.m_edgeBitSetIndex=this.createUserIndexForHalfEdges());const s=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndex);-1!==s?this.m_edgeBitSets[s]=e:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndex,this.m_edgeBitSets.length),this.m_edgeBitSets.push(e))}setLeftEdgeBitSet_(t,e){n(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),-1===this.m_edgeBitSetIndexLeft&&(this.m_edgeBitSetIndexLeft=this.createUserIndexForHalfEdges());const s=this.getHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft);-1!==s?this.m_edgeBitSets[s]=e:(this.setHalfEdgeUserIndex(t,this.m_edgeBitSetIndexLeft,this.m_edgeBitSets.length),this.m_edgeBitSets.push(e))}setChainBitSet_(t,e){n(this.m_bBuildGeometryParentageSets),e=this.registerNewBitSet(e),-1===this.m_chainBitSetIndex&&(this.m_chainBitSetIndex=this.createUserIndexForChains());const s=this.getChainUserIndex(t,this.m_chainBitSetIndex);-1!==s?this.m_chainBitSets[s]=e:(this.setChainUserIndex(t,this.m_chainBitSetIndex,this.m_chainBitSets.length),this.m_chainBitSets.push(e))}getEmptySet(){return this.m_emptyBitSet||(this.m_emptyBitSet=new el),this.m_emptyBitSet}deleteEdgeBitSets_(){-1!==this.m_edgeBitSetIndex&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndex),this.m_edgeBitSetIndex=-1),-1!==this.m_edgeBitSetIndexLeft&&(this.deleteUserIndexForHalfEdges(this.m_edgeBitSetIndexLeft),this.m_edgeBitSetIndexLeft=-1),this.m_edgeBitSets.length=0,this.m_uniqueBitSets=null}deleteChainBitSets_(){-1!==this.m_chainBitSetIndex&&(this.deleteUserIndexForChains(this.m_chainBitSetIndex),this.m_chainBitSetIndex=-1,this.m_chainBitSets.length=0)}dbgPrintEdge_(t){}dbgVerifyEdgeSegment(t){}}ll.c_EdgeParentageMask=~(1<<31),ll.c_EdgeBitMask=1<<31;class ul{freeNode_(t){this.m_listNodes.deleteElement(t)}newNode_(){return this.m_listNodes.newElement()}freeList_(t){this.m_lists.deleteElement(t)}newList_(){return this.m_lists.newElement()}Init_(t){n(0)}constructor(t){this.m_listNodes=new Ue(2),this.m_listOfLists=ul.st_nullNode(),this.m_bAllowNavigationBetweenLists=!0,void 0===t&&(t=!0),this.m_bAllowNavigationBetweenLists=t,this.m_lists=new Ue(this.m_bAllowNavigationBetweenLists?4:2)}createList(){const t=this.newList_();return this.m_bAllowNavigationBetweenLists&&(this.m_lists.setField(t,3,this.m_listOfLists),this.m_listOfLists!==ul.st_nullNode()&&this.m_lists.setField(this.m_listOfLists,2,t),this.m_listOfLists=t),t}deleteList(t){let e=this.getFirst(t);for(;e!==ul.st_nullNode();){const t=e;e=this.getNext(e),this.freeNode_(t)}if(this.m_bAllowNavigationBetweenLists){const e=this.m_lists.getField(t,2),s=this.m_lists.getField(t,3);e!==ul.st_nullNode()?this.m_lists.setField(e,3,s):this.m_listOfLists=s,s!==ul.st_nullNode()&&this.m_lists.setField(s,2,e)}this.freeList_(t)}reserveLists(t){this.m_lists.setCapacity(t)}addElement(t,e){this.m_lists.getField(t,0);const s=this.m_lists.getField(t,1),n=this.newNode_();return s!==ul.st_nullNode()?(this.m_listNodes.setField(s,1,n),this.m_lists.setField(t,1,n)):(this.m_lists.setField(t,0,n),this.m_lists.setField(t,1,n)),this.m_listNodes.setField(n,0,e),n}reserveNodes(t){this.m_listNodes.setCapacity(t)}deleteElementDirect(t,e,s){e!==ul.st_nullNode()?(this.m_listNodes.setField(e,1,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,e)):(this.m_lists.setField(t,0,this.m_listNodes.getField(s,1)),this.m_lists.getField(t,1)===s&&this.m_lists.setField(t,1,ul.st_nullNode())),this.freeNode_(s)}deleteElementSearch(t,e){let s=-1,n=this.getFirst(t);for(;n!==e;)s=n,n=this.getNext(n);this.deleteElementDirect(t,s,e)}concatenateLists(t,e){const s=this.m_lists.getField(t,1),n=this.m_lists.getField(e,0);if(n!==ul.st_nullNode()&&(s!==ul.st_nullNode()?(this.m_listNodes.setField(s,1,n),this.m_lists.setField(t,1,this.m_lists.getField(e,1))):(this.m_lists.setField(t,0,n),this.m_lists.setField(t,1,this.m_lists.getField(e,1)))),this.m_bAllowNavigationBetweenLists){const t=this.m_lists.getField(e,2),s=this.m_lists.getField(e,3);t!==ul.st_nullNode()?this.m_lists.setField(t,3,s):this.m_listOfLists=s,s!==ul.st_nullNode()&&this.m_lists.setField(s,2,t)}return this.freeList_(e),t}getElement(t){return this.m_listNodes.getField(t,0)}getData(t){return this.getElement(t)}setElement(t,e){n(0)}getNext(t){return this.m_listNodes.getField(t,1)}getFirst(t){return this.m_lists.getField(t,0)}getFirstElement(t){const e=this.getFirst(t);return this.getElement(e)}static st_nullNode(){return-1}clear(){this.m_listNodes.deleteAll(!0),this.m_lists.deleteAll(!0),this.m_listOfLists=ul.st_nullNode()}isEmpty(t){return n(0),!1}getNodeCount(){return this.m_listNodes.size()}getListCount(){return this.m_lists.size()}getFirstList(){return this.m_listOfLists}getNextList(t){return this.m_lists.getField(t,3)}}function cl(t=-1){return{m_value:t,m_line:new pm,m_segment:null,m_segmentInfo:new Fr(-1),m_env:new r(0,0),m_dxdy:55555555,m_bHorizontal:!1,m_bCurve:!1}}class gl extends hs{constructor(t,e,s){super(!0),this.m_bIntersectionDetected=!1,this.m_nonSimpleResult=new Is,this.m_tempSimpleEdge1=cl(),this.m_tempSimpleEdge2=cl(),this.m_prev1=Ar,this.m_prev2=Ar,this.m_vertex1=Ar,this.m_vertex2=Ar,this.m_currentNode=-1,this.m_prevX1=Number.NaN,this.m_prevX2=Number.NaN,this.m_prevY=Number.NaN,this.m_prevX=0,this.m_sweepY=Number.NaN,this.m_sweepX=0,this.m_ptSweep=new l,this.m_simpleEdgesCache=[],this.m_simpleEdgesRecycle=[],this.m_cOutstandingConstructedEdges=0,this.m_shape=t,this.m_bShapeHasSegments=this.m_shape.hasCurves(),this.m_tolerance=e,this.m_tolerance10=10*e,this.m_bIsSimple=s;const n=Math.trunc(Math.min(3*t.getTotalPointCount()/2,67)),i=Math.min(7,n);this.m_simpleEdgesCache.length=i}tryGetCachedEdge_(t){const e=this.m_simpleEdgesCache[(t&W())%this.m_simpleEdgesCache.length];return e&&e.m_value===t?e:null}tryDeleteCachedEdge_(t){const e=(t&W())%this.m_simpleEdgesCache.length,s=this.m_simpleEdgesCache[e];s&&s.m_value===t&&(this.m_simpleEdgesRecycle.push(s),this.m_simpleEdgesCache[e]=null)}tryCreateCachedEdge_(t){const e=(t&W())%this.m_simpleEdgesCache.length;let s=this.m_simpleEdgesCache[e];return s?null:(0===this.m_simpleEdgesRecycle.length?(s=cl(),this.m_cOutstandingConstructedEdges++):s=this.m_simpleEdgesRecycle.pop(),s.m_value=t,this.m_simpleEdgesCache[e]=s,s)}initSimpleEdge_(t,e){this.m_bShapeHasSegments&&this.initSimpleEdgeHelper_(t,e)||t.m_bCurve||(this.m_shape.queryLineConnector(e,t.m_line,!0),t.m_segment=t.m_line,t.m_env.setCoordsNoNAN(t.m_line.getStartX(),t.m_line.getEndX()),t.m_env.vmax+=this.m_tolerance,t.m_line.orientBottomUp(),t.m_bHorizontal=t.m_line.getEndY()===t.m_line.getStartY(),t.m_bHorizontal||(t.m_dxdy=(t.m_line.getEndX()-t.m_line.getStartX())/(t.m_line.getEndY()-t.m_line.getStartY())))}initSimpleEdgeHelper_(t,e){if(t.m_segment=this.m_shape.getSegment(e),t.m_segmentInfo=this.m_shape.getOriginalSegmentInfo(e),t.m_bCurve=null!==t.m_segment,t.m_bCurve){const e=t.m_segment.clone();return e.orientBottomUp(),t.m_segment=e,t.m_env=t.m_segment.queryInterval(0,0),t.m_env.vmax+=this.m_tolerance,!0}return!1}compareTwoSegments_(t,e){const s=t.getStartXY(),n=t.getEndXY(),i=e.getStartXY(),r=e.getEndXY();if(this.m_ptSweep.setCoords(this.m_sweepX,this.m_sweepY),s.isEqualPoint2D(i)&&this.m_sweepY===s.y){this.m_ptSweep.assign(n.compare(r)<0?n:r);const s=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),i=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x);if(Math.abs(s-i)>this.m_tolerance)return s<i?-1:1}const o=s.compare(i)<0?i:s,a=n.compare(r)<0?n:r;let h=0,m=0;for(let s=1;s<5;s++){st(o,a,s/5,this.m_ptSweep);const n=t.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),i=e.intersectionOfYMonotonicWithAxisX(this.m_ptSweep.y,this.m_ptSweep.x),r=Math.abs(n-i);r>h&&(h=r,m=n<i?-1:1)}return 0===m?this.errorCracking():m}compareNonHorizontal_(t,e){if(t.m_line.getStartY()===e.m_line.getStartY()&&t.m_line.getStartX()===e.m_line.getStartX())return t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX()?this.m_bIsSimple?this.errorCoincident():0:this.compareNonHorizontalUpperEnd_(t,e);if(t.m_line.getEndY()===e.m_line.getEndY()&&t.m_line.getEndX()===e.m_line.getEndX())return this.compareNonHorizontalLowerEnd_(t,e);const s=this.compareNonHorizontalLowerEnd_(t,e),n=this.compareNonHorizontalUpperEnd_(t,e);return s<0&&n<0?-1:s>0&&n>0?1:this.errorCracking()}compareHorizontal1Case1_(t,e){if(t.getEndX()>e.getEndX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getEndX()-t.getStartX())<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return 1}compareHorizontal1Case2_(t,e){if(t.getStartX()<e.getStartX()){if(e.getEndX()>e.getStartX()&&e.getEndY()-e.getStartY()<2*this.m_tolerance&&t.isIntersectingPoint(e.getEndXY(),this.m_tolerance,!0))return this.errorCracking()}else if((e.getEndY()-e.getStartY())/(e.getEndX()-e.getStartX())*(t.getStartX()-t.getEndX())<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking();return-1}compareHorizontal1Case3_(t,e){const s=l.getNAN();s.setSub(e.getEndXY(),e.getStartXY()),s.rightPerpendicularThis(),s.normalize();const n=l.getNAN();n.setSub(t.getStartXY(),e.getStartXY());const i=l.getNAN();i.setSub(t.getEndXY(),e.getStartXY());const r=n.dotProduct(s),o=i.dotProduct(s),a=Math.abs(r),h=Math.abs(o);if(a<h){if(a<this.m_tolerance10&&e.isIntersectingPoint(t.getStartXY(),this.m_tolerance,!0))return this.errorCracking()}else if(h<this.m_tolerance10&&e.isIntersectingPoint(t.getEndXY(),this.m_tolerance,!0))return this.errorCracking();return r<0&&o<0?-1:r>0&&o>0?1:this.errorCracking()}compareHorizontal1_(t,e){return t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.compareHorizontal1Case1_(t,e):t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()?this.compareHorizontal1Case2_(t,e):this.compareHorizontal1Case3_(t,e)}compareHorizontal2_(t,e){return t.getEndY()===e.getEndY()&&t.getEndX()===e.getEndX()&&t.getStartY()===e.getStartY()&&t.getStartX()===e.getStartX()?this.m_bIsSimple?this.errorCoincident():0:this.errorCracking()}compareNonHorizontalLowerEnd_(t,e){let s=1;if(t.m_line.getStartY()<e.m_line.getStartY()){s=-1;const n=t;t=e,e=n}const n=t.m_line,i=e.m_line,r=n.getStartX()-i.getStartX(),o=e.m_dxdy*(n.getStartY()-i.getStartY()),a=this.m_tolerance10;return r<o-a?-s:r>o+a?s:i.isIntersectingPoint(n.getStartXY(),this.m_tolerance,!0)?this.errorCracking():r<o?-s:s}compareNonHorizontalUpperEnd_(t,e){let s=1;if(e.m_line.getEndY()<t.m_line.getEndY()){s=-1;const n=t;t=e,e=n}const n=t.m_line,i=e.m_line,r=n.getEndX()-i.getStartX(),o=e.m_dxdy*(n.getEndY()-i.getStartY()),a=this.m_tolerance10;return r<o-a?-s:r>o+a?s:i.isIntersectingPoint(n.getEndXY(),this.m_tolerance,!0)?this.errorCracking():r<o?-s:s}errorCoincident(){return this.m_bIntersectionDetected=!0,this.m_nonSimpleResult=new Is(7,this.m_vertex1,this.m_vertex2),-1}errorCracking(){if(this.m_bIntersectionDetected=!0,this.m_bIsSimple){const t=6;this.m_nonSimpleResult=new Is(t,this.m_vertex1,this.m_vertex2)}else this.m_prev1=Ar,this.m_prev2=Ar,this.m_vertex1=Ar,this.m_vertex2=Ar;return-1}compareSegments_(t,e,s,n){if(s.m_env.vmax<n.m_env.vmin)return-1;if(n.m_env.vmax<s.m_env.vmin)return 1;if(!s.m_bCurve&&!n.m_bCurve){let t=s.m_bHorizontal?1:0;return t|=n.m_bHorizontal?2:0,0===t?this.compareNonHorizontal_(s,n):1===t?this.compareHorizontal1_(s.m_line,n.m_line):2===t?-1*this.compareHorizontal1_(n.m_line,s.m_line):this.compareHorizontal2_(s.m_line,n.m_line)}if(this.m_bIntersectionDetected)return-1;const i=this.m_prevY===this.m_sweepY&&this.m_prevX===this.m_sweepX;let r,o;if(i&&t===this.m_prev1?r=this.m_prevX1:(r=Number.NaN,this.m_prev1=Ar),i&&e===this.m_prev2?o=this.m_prevX2:(o=Number.NaN,this.m_prev2=Ar),this.m_prevY=this.m_sweepY,this.m_prevX=this.m_sweepX,Number.isNaN(r)){this.m_prev1=t;const e=s.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);r=e,this.m_prevX1=e}if(Number.isNaN(o)){this.m_prev2=e;const t=n.m_segment.intersectionOfYMonotonicWithAxisX(this.m_sweepY,this.m_sweepX);o=t,this.m_prevX2=t}const a=am(!0,!0,s.m_segment,n.m_segment,this.m_tolerance,!0);return 0!==a?2===a?this.m_bIsSimple?this.errorCoincident():s.m_segmentInfo.equals(n.m_segmentInfo)?0:this.errorCracking():this.errorCracking():Math.abs(r-o)<=this.m_tolerance?this.compareTwoSegments_(s.m_segment,n.m_segment):r<o?-1:r>o?1:0}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1}intersectionDetected(){return this.m_bIntersectionDetected}getLastComparedNode(){return this.m_currentNode}getResult(){return this.m_nonSimpleResult}setSweepY(t,e){this.m_sweepY=t,this.m_sweepX=e,this.m_prev1=Ar,this.m_prev2=Ar,this.m_vertex1=Ar,this.m_vertex2=Ar}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const n=t.getElement(s),i=e;return this.m_currentNode=s,this.compareSegments(i,i,n,n)}compareSegments(t,e,s,n){let i=this.tryGetCachedEdge_(t);null===i?this.m_vertex1===e?i=this.m_tempSimpleEdge1:(this.m_vertex1=e,i=this.tryCreateCachedEdge_(t),null===i&&(i=this.m_tempSimpleEdge1,this.m_tempSimpleEdge1.m_value=t),this.initSimpleEdge_(i,e)):this.m_vertex1=e;let r=this.tryGetCachedEdge_(s);return null===r?this.m_vertex2===n?r=this.m_tempSimpleEdge2:(this.m_vertex2=n,r=this.tryCreateCachedEdge_(s),null===r&&(r=this.m_tempSimpleEdge2,this.m_tempSimpleEdge2.m_value=s),this.initSimpleEdge_(r,n)):this.m_vertex2=n,this.compareSegments_(e,n,i,r)}onDelete(t){this.tryDeleteCachedEdge_(t)}onSet(t){this.tryDeleteCachedEdge_(t)}onEndSearch(t){this.tryDeleteCachedEdge_(t)}onAddUniqueElementFailed(t){this.tryDeleteCachedEdge_(t)}}class dl{constructor(t,e){this.m_bIntersectionDetected=!1,this.m_pointOfInterest=l.getNAN(),this.m_line1=new pm,this.m_seg1=null,this.m_env=r.constructEmpty(),this.m_vertex1=-1,this.m_currentNode=-1,this.m_minDist=Number.MAX_VALUE,this.m_shape=t,this.m_tolerance=e}getCurrentNode(){return this.m_currentNode}clearIntersectionDetectedFlag(){this.m_bIntersectionDetected=!1,this.m_minDist=Number.MAX_VALUE}intersectionDetected(){return this.m_bIntersectionDetected}setPoint(t){this.m_pointOfInterest.assign(t)}compare(t,e){const s=t.getElement(e);return this.compareVertex(t,e,s)}compareVertex(e,s,n){let i,r=this.m_shape.getSegment(n),o=!0;if(null==r)this.m_shape.queryLineConnector(n,this.m_line1,!0),this.m_env.setCoordsNoNAN(this.m_line1.getStartX(),this.m_line1.getEndX()),r=this.m_line1,i=this.m_line1.getStartY()===this.m_line1.getEndY();else{const e=t.constructEmpty();r.queryLooseEnvelope(e),e.queryIntervalX(this.m_env),i=0===e.height(),o=!1}if(this.m_pointOfInterest.x+this.m_tolerance<this.m_env.vmin)return-1;if(this.m_pointOfInterest.x-this.m_tolerance>this.m_env.vmax)return 1;if(i)return this.m_currentNode=s,this.m_bIntersectionDetected=!0,0;let a=0;if(o){In(this.m_line1);const t=this.m_line1.getStartXY(),e=new l;e.setSub(this.m_line1.getEndXY(),t),e.rightPerpendicularThis();const s=new l;s.setSub(this.m_pointOfInterest,t),a=e.dotProduct(s),a/=e.length()}else a=r.intersectionOfYMonotonicWithAxisX(this.m_pointOfInterest.y,this.m_pointOfInterest.x)-this.m_pointOfInterest.x;return a<10*-this.m_tolerance?-1:a>10*this.m_tolerance?1:(r.isIntersectingPoint(this.m_pointOfInterest,this.m_tolerance)&&(Math.abs(a)<this.m_minDist&&(this.m_currentNode=s,this.m_minDist=a),this.m_bIntersectionDetected=!0),a<0?-1:a>0?1:0)}}class _l{constructor(t,e){this.m_lists=new ul(!1),this.m_hash=e,this.m_hashBuckets=new Int32Array(t),this.m_hashBuckets.fill(_l.st_nullNode()),this.m_bitFilter=new Int32Array(10*t+31>>5)}reserveElements(t){this.m_lists.reserveLists(Math.min(this.m_hashBuckets.length,t)),this.m_lists.reserveNodes(t)}addElement(t,e){void 0===e&&(e=this.m_hash.getHash(t));const s=e%(this.m_bitFilter.length<<5);this.m_bitFilter[s>>5]|=1<<(31&s);const n=e%this.m_hashBuckets.length;let i=this.m_hashBuckets[n];return i===ul.st_nullNode()&&(i=this.m_lists.createList(),this.m_hashBuckets[n]=i),this.m_lists.addElement(i,t)}deleteElement(t,e){void 0===e&&(e=this.m_hash.getHash(t));const n=e%this.m_hashBuckets.length,i=this.m_hashBuckets[n];i===ul.st_nullNode()&&s("");let r=this.m_lists.getFirst(i),o=ul.st_nullNode();for(;r!==ul.st_nullNode();){const e=this.m_lists.getData(r),s=this.m_lists.getNext(r);e===t?(this.m_lists.deleteElementDirect(i,o,r),this.m_lists.getFirst(i)===ul.st_nullNode()&&(this.m_lists.deleteList(i),this.m_hashBuckets[n]=ul.st_nullNode())):o=r,r=s}}getFirstInBucket(t){const e=t%(this.m_bitFilter.length<<5);if(!(this.m_bitFilter[e>>5]&1<<(31&e)))return ul.st_nullNode();const s=t%this.m_hashBuckets.length,n=this.m_hashBuckets[s];return n===ul.st_nullNode()?ul.st_nullNode():this.m_lists.getFirst(n)}getNextInBucket(t){return this.m_lists.getNext(t)}findNode(t){const e=this.m_hash.getHash(t);let s=this.getFirstInBucket(e);for(;s!==ul.st_nullNode();){const e=this.m_lists.getData(s);if(this.m_hash.equal(e,t))return s;s=this.m_lists.getNext(s)}return ul.st_nullNode()}deleteNode(t){const e=this.getElement(t),n=this.m_hash.getHash(e)%this.m_hashBuckets.length,i=this.m_hashBuckets[n];i===ul.st_nullNode()&&s(""),this.m_lists.deleteElementSearch(i,t),this.m_lists.getFirst(i)===ul.st_nullNode()&&(this.m_lists.deleteList(i),this.m_hashBuckets[n]=ul.st_nullNode())}getElement(t){return this.m_lists.getData(t)}static st_nullNode(){return ul.st_nullNode()}clear(){n(0)}size(){return this.m_lists.getNodeCount()}dbgPrintBucketHistogram(){}}function pl(t,e,s,n,i){const r=new Cl(i);return r.m_shape=t,r.m_sqrTolerance=e*e,r.m_cellSize=2*e,r.m_invCellSize=1/r.m_cellSize,r.m_geometry=s,r.m_bTrackChanges=n,r.m_bHasSegmentParentage=t.hasSegmentParentage(),r.clusterNonReciprocal()}function fl(t,e,s,n,i){const r=t-s,o=e-n;return r*r+o*o<=i}function xl(t,e,s,n,i,r){const o={pt:new l,weight:0,rank:0,bMerged:!1},a=s+i;let h=!1,m=t.x;t.x!==e.x&&(n===r&&(m=(t.x*s+e.x*i)/a),h=!0);let u=t.y;return t.y!==e.y&&(n===r&&(u=(t.y*s+e.y*i)/a),h=!0),n!==r?n>r?(o.rank=n,o.weight=s,o.pt=t):(o.rank=r,o.weight=i,o.pt=e):(o.pt.setCoords(m,u),o.weight=a,o.rank=n),o.bMerged=h,o}function yl(t,e){const s=_e(t);return he(s,e)}class Pl{constructor(t,e,s,n,i){this.m_workPt=new l,this.m_shape=t,this.m_sqrTolerance=s,this.m_invCellSize=n,this.m_origin=e.clone(),this.m_hashValues=i}getHash(t){return this.m_shape.getUserIndex(t,this.m_hashValues)}calculateHashFromVertex(t){this.m_shape.queryXY(t,this.m_workPt);const e=this.m_workPt.x-this.m_origin.x,s=Math.trunc(e*this.m_invCellSize+.5),n=this.m_workPt.y-this.m_origin.y;return yl(s,Math.trunc(n*this.m_invCellSize+.5))}equal(t,e){return n(0),!1}}class Cl{constructor(t){this.m_origin=l.getNAN(),this.m_sqrTolerance=0,this.m_cellSize=0,this.m_invCellSize=0,this.m_geometry=Ar,this.m_bucketArray=h(4,Number.NaN),this.m_bucketHash=h(4,Number.NaN),this.m_dbgCandidateCheckCount=0,this.m_nsr=new Is,this.m_hashValues=-1,this.m_newClusters=-1,this.m_bTrackChanges=!1,this.m_bHasSegmentParentage=!1,this.m_shape=null,this.m_clusters=new ul,this.m_hashFunction=null,this.m_hashTable=null,this.m_progressCounter=0,this.m_progressTracker=t}progress_(){}collectClusterCandidates(t,e){const s=l.getNAN();this.m_shape.queryXY(t,s);const n=(s.x-this.m_origin.x)*this.m_invCellSize,i=(s.y-this.m_origin.y)*this.m_invCellSize,r=Math.trunc(n),o=Math.trunc(i);let a=0;for(let t=0;t<=1;t+=1)for(let e=0;e<=1;e+=1){const s=yl(r+t,o+e),n=this.m_hashTable.getFirstInBucket(s);n!==_l.st_nullNode()&&(this.m_bucketArray[a]=n,this.m_bucketHash[a]=s,a++)}for(let t=a-1;t>=1;t--){const e=this.m_bucketArray[t];for(let s=t-1;s>=0;s--)if(e===this.m_bucketArray[s]){this.m_bucketHash[s]=-1,a--,t!==a&&(this.m_bucketHash[t]=this.m_bucketHash[a],this.m_bucketArray[t]=this.m_bucketArray[a]);break}}for(let n=0;n<a;n++)this.collectNearestNeighbourCandidates(t,this.m_bucketHash[n],s,this.m_bucketArray[n],e)}collectNearestNeighbourCandidates(t,e,s,n,i){const r=l.getNAN();for(let o=n;o!==_l.st_nullNode();o=this.m_hashTable.getNextInBucket(o)){const n=this.m_hashTable.getElement(o);t===n||-1!==e&&this.m_shape.getUserIndex(n,this.m_hashValues)!==e||(this.m_shape.queryXY(n,r),fl(s.x,s.y,r.x,r.y,this.m_sqrTolerance)&&i.push(o))}}mergeClusters(t,e,s){let n=this.m_shape.getUserIndex(t,this.m_newClusters);const i=this.m_shape.getUserIndex(e,this.m_newClusters);-1===n&&(n=this.m_clusters.createList(),this.m_clusters.addElement(n,t),this.m_shape.setUserIndex(t,this.m_newClusters,n)),-1===i?this.m_clusters.addElement(n,e):this.m_clusters.concatenateLists(n,i),this.m_shape.setUserIndex(e,this.m_newClusters,Ue.impossibleIndex2());const r=this.mergeVertices(t,e);if(s){const e=this.m_hashFunction.calculateHashFromVertex(t);this.m_shape.setUserIndex(t,this.m_hashValues,e)}return r}mergeVertices(t,e){const s=l.getNAN();this.m_shape.queryXY(t,s);const n=l.getNAN();this.m_shape.queryXY(e,n);const i=this.m_shape.getRank(t),r=this.m_shape.getRank(e),o=this.m_shape.getWeight(t),a=this.m_shape.getWeight(e);let h,m,u,c,g=!1;if(i===r?(h=i,m=o+a,u=s.x,s.x!==n.x&&(u=(s.x*o+n.x*a)/m,g=!0),c=s.y,s.y!==n.y&&(c=(s.y*o+n.y*a)/m,g=!0)):(i>r?(u=s.x,c=s.y,m=o,h=i):(u=n.x,c=n.y,m=a,h=r),g=!s.equals(n)),g&&(this.m_shape.setXYMonotonic(t,u,c),this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(t,!0),this.m_bHasSegmentParentage)){const s=this.m_shape.getSegmentParentageBreakVertex(t)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(t,s),this.m_shape.setSegmentParentageBreakVertex(e,s)}return this.m_shape.setWeight(t,m),this.m_shape.setRank(t,h),g}needsClustering(){const t={stack:[],error:void 0,hasError:!1};try{Ss(t,ae(()=>{this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters)}),!1);const e=this.m_shape.getSelectedCount(),s=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin.assign(s.getLowerLeft());const n=Math.max(s.height(),s.width())/(c()-1);this.m_cellSize<n&&(this.m_cellSize=n,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(this.m_shape.getSelectedCount()/3+1),this.m_clusters.reserveNodes(this.m_shape.getSelectedCount()/3+1),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new Pl(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new _l(4*e/3,this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let i=!1;for(let t=0;t<2;t++){const e=[],s=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let n=s.next();n!==Ar;n=s.next()){if(this.progress_(),t>0&&this.m_shape.getUserIndex(n,this.m_newClusters)===Ue.impossibleIndex2())continue;let s;if(0===t?(s=this.m_hashFunction.calculateHashFromVertex(n),this.m_shape.setUserIndex(n,this.m_hashValues,s)):s=this.m_shape.getUserIndex(n,this.m_hashValues),this.collectClusterCandidates(n,e),0!==e.length){for(let t=0,s=e.length;t<s;t++){this.progress_();const s=e[t],r=this.m_hashTable.getElement(s);if(this.m_hashTable.deleteNode(s),!this.m_shape.isEqualXY(n,r))return this.m_nsr=new Is(5,this.m_shape.getVertexIndex(n),this.m_shape.getVertexIndex(r)),i=!0,i;this.mergeClusters(n,r,!1)}e.length=0}0===t&&this.m_hashTable.addElement(n,s)}}return i}catch(e){t.error=e,t.hasError=!0}finally{vs(t)}}clusterNonReciprocal(){const t=this.m_shape.getSelectedCount(),e=this.m_shape.getEnvelope2D(this.m_progressTracker);this.m_origin=e.getLowerLeft();const s=Math.max(e.height(),e.width())/(c()-1);this.m_cellSize<s&&(this.m_cellSize=s,this.m_invCellSize=1/this.m_cellSize),this.m_clusters.clear(),this.m_clusters.reserveLists(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_clusters.reserveNodes(Math.trunc(this.m_shape.getSelectedCount()/3+1)),this.m_hashValues=this.m_shape.createUserIndex(),this.m_newClusters=this.m_shape.createUserIndex(),this.m_hashFunction=new Pl(this.m_shape,this.m_origin,this.m_sqrTolerance,this.m_invCellSize,this.m_hashValues),this.m_hashTable=new _l(Math.trunc(4*t/3),this.m_hashFunction),this.m_hashTable.reserveElements(this.m_shape.getSelectedCount());let n=!1;{const t=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let e=t.next();e!==Ar;e=t.next()){this.progress_();const t=this.m_hashFunction.calculateHashFromVertex(e);this.m_shape.setUserIndex(e,this.m_hashValues,t),this.m_hashTable.addElement(e,t)}}{const t=[],e=this.m_shape.queryVertexIteratorOnSelection(this.m_geometry);for(let s=e.next();s!==Ar;s=e.next()){if(this.m_shape.getUserIndex(s,this.m_newClusters)===Ue.impossibleIndex2())continue;let e=this.m_shape.getUserIndex(s,this.m_hashValues);this.m_hashTable.deleteElement(s,e);let i=!1;for(;this.collectClusterCandidates(s,t),0!==t.length;){let e=0;for(let n=0,i=t.length;n<i;n++){this.progress_();const r=t[n],o=this.m_hashTable.getElement(r);this.m_hashTable.deleteNode(r);const a=n+1===i;e|=this.mergeClusters(s,o,a)?1:0}if(i||=0!==e,n||=0!==e,t.length=0,!e)break}i&&(e=this.m_shape.getUserIndex(s,this.m_hashValues)),this.m_hashTable.addElement(s,e)}t.length=0}return n&&this.applyClusterPositions_(),this.m_hashTable=null,this.m_hashFunction=null,this.m_shape.removeUserIndex(this.m_hashValues),this.m_shape.removeUserIndex(this.m_newClusters),n}applyClusterPositions_(){const t=l.getNAN();for(let e=this.m_clusters.getFirstList();e!==ul.st_nullNode();e=this.m_clusters.getNextList(e)){let s=this.m_clusters.getFirst(e);const n=this.m_clusters.getElement(s);this.m_shape.queryXY(n,t);const i=this.m_shape.getRank(n),r=this.m_shape.getWeight(n);for(s=this.m_clusters.getNext(s);s!==ul.st_nullNode();s=this.m_clusters.getNext(s)){const e=this.m_clusters.getElement(s);if(this.m_bTrackChanges?this.m_shape.isEqualXYPoint2D(e,t)||(this.m_shape.setXYMonotonicPoint2D(e,t),this.m_shape.setGeometryModifiedWithVertex(e,!0)):this.m_shape.setXYMonotonicPoint2D(e,t),this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentageBreakVertex(n)||this.m_shape.getSegmentParentageBreakVertex(e);this.m_shape.setSegmentParentageBreakVertex(n,t),this.m_shape.setSegmentParentageBreakVertex(e,t)}this.m_shape.setWeight(e,r),this.m_shape.setRank(e,i)}}}}class El{constructor(){this.m_inputParts=[],this.m_resultParts1=[],this.m_resultParts2=[],this.m_resultSegments=[],this.m_freeSegments=[],this.m_inputSegments=[],this.m_param1=[],this.m_param2=[],this.m_tolerance=0,this.m_toleranceZ=0,this.m_point=new qe,this.m_pointWeight=1,this.m_maxDensifyLimit=0,this.m_pointRank=0,this.m_changed1=!1,this.m_changed2=!1,this.m_adaptiveDensify=!1}clear(){this.freeAllResultSegments(),this.m_inputSegments.length=0,this.m_inputParts.length=0,this.m_resultParts1.length=0,this.m_resultParts2.length=0,this.m_param1.length=0,this.m_param2.length=0,this.m_adaptiveDensify=!1,this.m_changed1=!1,this.m_changed2=!1}newIntersectionPart_(t,e,s,n,i,r,o,a,h,m){return function(t,e,s,n,i,r,o,a,h,m){return{segmentIndex:t,weightStart:e,rankStart:s,weightEnd:n,rankEnd:i,weightInterior:r,rankInterior:o,segmentParentage:m,u:Sl(a,h)}}(t,e,s,n,i,r,o,a,h,m)}pushSegment(t,e,s,n,i,r,o,a,h,m){return this.m_inputParts.push(this.newIntersectionPart_(this.m_inputSegments.length,e,s,n,i,r,o,a,h,m)),this.m_inputSegments.push(t),this.m_inputParts.length-1}getResultSegmentCount(t){return this.m_adaptiveDensify?0===t?this.m_param1.length-1:this.m_param2.length-1:0===t?this.m_resultParts1.length:this.m_resultParts2.length}getResultPart_(t,e){return 0===t?this.m_resultParts1[e]:this.m_resultParts2[e]}getResultSegment(t,e){return this.m_resultSegments[this.getResultPart_(t,e).segmentIndex].get()}getSegmentChanged(t){return 0===t?this.m_changed1:this.m_changed2}getResultSegmentStartPointWeight(t,e){return this.getResultPart_(t,e).weightStart}getResultSegmentStartPointRank(t,e){return this.getResultPart_(t,e).rankStart}getResultSegmentSegmentParentage(t,e){return this.getResultPart_(t,e).segmentParentage}getResultSegmentStartPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakStart}getResultSegmentEndPointWeight(t,e){return this.getResultPart_(t,e).weightEnd}getResultSegmentEndPointRank(t,e){return this.getResultPart_(t,e).rankEnd}getResultSegmentEndPointIsBreak(t,e){return this.getResultPart_(t,e).u.bBreakEnd}getResultSegmentInteriorRank(t,e){return this.getResultPart_(t,e).rankInterior}getResultSegmentInteriorWeight(t,e){return this.getResultPart_(t,e).weightInterior}getResultPoint(){return this.m_point}getResultPointWeight(){return this.m_pointWeight}getResultPointRank(){return this.m_pointRank}getResultPointChanged(){return this.m_changed2}intersectLines(t,e){2!==this.m_inputSegments.length&&P(""),this.m_changed1=!1,this.m_changed2=!1,this.m_tolerance=t;const s=ot(t*El.c_smallToleranceFactor);let n=!1;const i=this.m_inputParts[0],r=this.m_inputParts[1],o=this.m_inputSegments[i.segmentIndex],a=this.m_inputSegments[r.segmentIndex];if(e||5&om(!0,o,a,t,!0)){const e=lm(!0,o,a,null,this.m_param1,this.m_param2,t);0===e&&P("");const m=new Array(e);for(let t=0;t<e;++t)m[t]=l.getNAN();const u=new Float64Array(e),c=new Int32Array(e),g=new Array(e),d=new Array(e);for(let t=0;t<e;++t)g[t]=vl(),d[t]=vl();for(let t=0;t<e;t++){const e=this.m_param1[t],h=this.m_param2[t];let _,p=i.rankInterior,f=i.weightInterior;0===e?(p=i.rankStart,f=i.weightStart,_=i.u.bBreakStart):1===e?(p=i.rankEnd,f=i.weightEnd,_=i.u.bBreakEnd):(this.m_changed1=!0,_=!1);let x,y=r.rankInterior,P=r.weightInterior;0===h?(y=r.rankStart,P=r.weightStart,x=r.u.bBreakStart):1===h?(y=r.rankEnd,P=r.weightEnd,x=r.u.bBreakEnd):(this.m_changed2=!0,x=!1);const C=p,E=y;let S=1,v=0,I=l.getNAN();if(C===E){const n=o.getCoord2D(e),i=a.getCoord2D(h);S=f+P,v=p,st(n,i,P/S,I);const r=l.sqrDistance(I,n),m=l.sqrDistance(I,i);g[t].bBigMove=r>s,d[t].bBigMove=m>s,this.m_changed1||n.equals(I)||(this.m_changed1=!0),this.m_changed2||i.equals(I)||(this.m_changed2=!0)}else if(C>E){I=o.getCoord2D(e);const n=a.getCoord2D(h);S=f,v=p;const i=l.sqrDistance(I,n);g[t].bBigMove=!1,d[t].bBigMove=i>s,this.m_changed2||n.equals(I)||(this.m_changed2=!0)}else{I=a.getCoord2D(h),S=P,v=y;const n=o.getCoord2D(e),i=l.sqrDistance(I,n);g[t].bBigMove=i>s,d[t].bBigMove=!1,this.m_changed1||n.equals(I)||(this.m_changed1=!0)}m[t].assign(I),u[t]=S,c[t]=v,g[t].bIsBreak=_||x,d[t].bIsBreak=_||x,n||=g[t].bBigMove||d[t].bBigMove}const _=i.rankInterior,f=i.weightInterior;let x=0,y=-1;for(let s=0;s<=e;s++){const n=s<e?this.m_param1[s]:1;if(n!==x){const r=this.allocResultSegment(),a=this.m_resultSegments[r];let h,d,p,P;o.queryCut(x,n,a,!1),a.get().snapControlPoints(t*t);let C=!1,E=!1,S=!1,v=!1,I=!1,b=l.getNAN(),w=l.getNAN();-1!==y?(d=c[y],h=u[y],C=g[y].bBigMove,b.assign(m[y]),S=g[y].bIsBreak,I=!0):(h=i.weightStart,d=i.rankStart,b=a.get().getStartXY(),S=i.u.bBreakStart),s<e?(P=c[s],p=u[s],E=g[s].bBigMove,w.assign(m[s]),v=g[s].bIsBreak,I=!0):(p=i.weightEnd,P=i.rankEnd,w=a.get().getEndXY(),v=i.u.bBreakEnd),I&&a.get().setCoordsForIntersector(b,w,!0),this.m_resultParts1.push(this.newIntersectionPart_(r,h,d,p,P,f,_,S,v,i.segmentParentage));const D=this.m_resultParts1.at(-1);D.u.bBigMoveStart=C,D.u.bBigMoveEnd=E,x=n,y=s}else-1===y&&(y=s)}const C=h(e,0);for(let t=0;t<e;t++)C[t]=t;e>2?(C.sort((t,e)=>this.m_param2[t]<this.m_param2[e]?-1:this.m_param2[t]>this.m_param2[e]?1:0),lt(this.m_param2)):2===e&&this.m_param2[0]>this.m_param2[1]&&(this.m_param2[1]=p(this.m_param2[0],this.m_param2[0]=this.m_param2[1]),C[1]=p(C[0],C[0]=C[1]));const E=r.rankInterior,S=r.weightInterior;x=0,y=-1;for(let s=0;s<=e;s++){const n=s<e?this.m_param2[s]:1;if(n!==x){const i=this.allocResultSegment(),o=this.m_resultSegments[i];let h,g,_,p;a.queryCut(x,n,o,!1),o.get().snapControlPoints(t*t);let f=l.getNAN(),P=l.getNAN(),v=!1,I=!1,b=!1,w=!1,D=!1;if(-1!==y){const t=C[y];h=u[t],g=c[t],f.assign(m[t]),b=d[t].bBigMove,v=d[t].bIsBreak,D=!0}else h=r.weightStart,g=r.rankStart,f=o.get().getStartXY(),v=r.u.bBreakStart;if(s!==e){const t=C[s];_=u[t],p=c[t],P.assign(m[t]),w=d[t].bBigMove,I=d[t].bIsBreak,D=!0}else _=r.weightEnd,p=r.rankEnd,P=o.get().getEndXY(),I=r.u.bBreakEnd;D&&o.get().setCoordsForIntersector(f,P,!0),this.m_resultParts2.push(this.newIntersectionPart_(i,h,g,_,p,S,E,v,I,r.segmentParentage));const T=this.m_resultParts2.at(-1);T.u.bBigMoveStart=b,T.u.bBigMoveEnd=w,x=n,y=s}else-1===y&&(y=s)}return n?3:2}return 0}intersectLines3D(t,e,s,i){return n(0),1}intersect2D(t,e){const s=this.m_inputParts[0],n=this.m_inputParts[1],i=this.m_inputSegments[s.segmentIndex].getGeometryType(),r=this.m_inputSegments[n.segmentIndex].getGeometryType();return i!==o.enumLine||r!==o.enumLine?new Dl(this).intersectCurves(t,e):this.intersectLines(t,e)}intersect2DEx(t,e,s,n,i){this.m_point.assignCopy(e),1!==this.m_inputSegments.length&&P(""),this.m_tolerance=t,this.m_changed1=!1,this.m_changed2=!1;const r=ot(t*El.c_smallToleranceFactor);let o=!1;const a=this.m_inputParts[0],m=this.m_inputSegments[a.segmentIndex];if(i||m.isIntersectingPoint(e.getXY(),t,!0)){this.m_param1=h(16,Number.NaN);const i=m.getClosestCoordinate(e.getXY(),!1);this.m_param1[0]=i;let u=a.rankInterior,c=a.weightInterior;0===i?(u=a.rankStart,c=a.weightStart):1===i?(u=a.rankEnd,c=a.weightEnd):this.m_changed1=!0;let g=u;const d=s,_=n;g===d&&m.isCurve()&&(g=d+1);let p=1,f=0;const x=new l;if(g===d){const t=m.getCoord2D(i),s=e.getXY();p=c+_,f=u,st(t,s,_/p,x),this.m_changed1||t.equals(x)||(this.m_changed1=!0),this.m_changed2||s.equals(x)||(this.m_changed2=!0),o=l.sqrDistance(x,t)>r}else g>d?(x.assign(m.getCoord2D(i)),p=c,f=u,this.m_changed2||x.equals(e.getXY())||(this.m_changed2=!0)):(x.assign(m.getCoord2D(i)),p=_,f=d,this.m_changed1||x.equals(e.getXY())||(this.m_changed1=!0),o=l.sqrDistance(x,e.getXY())>r);let y=0,P=-1;const C=1;for(let e=0;e<=C;e++){const s=e<C?this.m_param1[0]:1;if(s!==y){const n=this.allocResultSegment(),i=this.m_resultSegments[n];m.queryCut(y,s,i),i.get().snapControlPoints(t*t);let r=a.weightStart,o=a.weightEnd,h=a.rankStart,l=a.rankEnd;const u=a.rankInterior,c=a.weightInterior;let g=a.u.bBreakStart,d=a.u.bBreakEnd;-1!==P&&(r=p,h=f,g=!0,i.get().setCoordsForIntersector(x,i.get().getEndXY(),!0)),e!==C&&(o=p,l=f,d=!0,i.get().setCoordsForIntersector(i.get().getStartXY(),x,!0)),y=s,this.m_resultParts1.push(this.newIntersectionPart_(n,r,h,o,l,c,u,g,d,a.segmentParentage))}P=e}return this.m_point.setXY(x),this.m_pointWeight=p,this.m_pointRank=f,o?3:2}return 0}intersect3D(t,e,s,i){return n(0),1}intersect3DEx(t,e,s,i,r,o,a){return n(0),1}getTolerance(){return this.m_tolerance}freeAllResultSegments(){this.m_resultSegments.length=0,this.m_freeSegments.length=0}freeResultSegment(t){this.m_freeSegments.push(t)}allocResultSegment(){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const t=new fm,e=this.m_resultSegments.length;return this.m_resultSegments.push(t),e}allocResultSegmentFromBuffer(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const e=new fm({copy:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}allocResultSegmentFromSegment(t){if(this.m_freeSegments.length)return this.m_freeSegments.pop();const e=new fm({segment:t}),s=this.m_resultSegments.length;return this.m_resultSegments.push(e),s}}function Sl(t,e){return{bBigMoveStart:!1,bBigMoveEnd:!1,bBreakStart:t,bBreakEnd:e}}function vl(){return{bBigMove:!1,bIsBreak:!1}}El.maxWeight=.1*Number.MAX_VALUE,El.c_smallToleranceFactor=.01,El.c_maxGeometryTypeToRankDelta=8;let Il=class{constructor(){this.start=null,this.end=null,this.equalEdge=null,this.segmentIndex=-1,this.segmentParentage=-1,this.weight=0,this.rank=0}hasSegment(){return this.segmentIndex>=0}transferAttributes(t,e,s){if(1===e.getDescription().getAttributeCount())return;const n=t.parent.m_resultSegments[this.segmentIndex].get().getStartXY(),i=t.parent.m_resultSegments[this.segmentIndex].get().getEndXY(),r=new qe;e.queryStart(r),s?(r.setXY(n),t.parent.m_resultSegments[this.segmentIndex].get().setStart(r)):(r.setXY(i),t.parent.m_resultSegments[this.segmentIndex].get().setEnd(r)),e.queryEnd(r),s?(r.setXY(i),t.parent.m_resultSegments[this.segmentIndex].get().setEnd(r)):(r.setXY(n),t.parent.m_resultSegments[this.segmentIndex].get().setStart(r))}copyFromWhenOverlap(t,e,s){this.equalEdge=e,e.equalEdge=this,this.segmentIndex=t.parent.allocResultSegmentFromBuffer(t.parent.m_resultSegments[e.segmentIndex]),this.segmentParentage=e.segmentParentage,this.weight=e.weight,this.rank=e.rank,s?(this.start.copyFrom(e.start),this.end.copyFrom(e.end)):(this.start.copyFrom(e.end),this.end.copyFrom(e.start),t.parent.m_resultSegments[this.segmentIndex].get().reverse())}getEnd(){return this.end}getNextInChain(){return this.end.nextInChain}getPrevInChain(){return this.start.prevInChain}};class bl{constructor(){this.hash=0,this.pt=new l,this.prevInChain=null,this.nextInChain=null,this.prevInHash=null,this.nextInHash=null,this.prevEqual=null,this.nextEqual=null,this.weight=0,this.rank=0,this.bBigMove=!1,this.bIsBreak=!1}copyFrom(t){this.pt.assign(t.pt),this.weight=t.weight,this.rank=t.rank,this.bBigMove=t.bBigMove,this.bIsBreak=t.bIsBreak}nextNode(){return this.nextInChain?this.nextInChain.end:null}prevNode(){return this.prevInChain?this.prevInChain.start:null}equalListHead(){let t=this;for(;null!==t.prevEqual;t=t.prevEqual);return t}}function wl(t,e,s,n){return{edge1:t,edge2:e,recursion:s,bIsIntersecting:n}}class Dl{constructor(t){this.m_pairs=[],this.m_chainOrigin1=null,this.m_chainOrigin2=null,this.m_newNodes=[],this.m_hashTableOfEquals=[],this.m_hashTableOfEqualsSize=0,this.m_origin=new l,this.m_cell=new l,this.parent=t}addSegment(t,e,s,i,r,o,a,h,m,l,u){const c=this.newNode(this.parent.m_resultSegments[t].get().getStartXY(),s,i,m),g=this.newNode(this.parent.m_resultSegments[t].get().getEndXY(),r,o,l);this.newEdge(c,g,t,a,h,u),null===this.m_chainOrigin1?this.m_chainOrigin1=c:null===this.m_chainOrigin2?this.m_chainOrigin2=c:n(0)}intersectCurvesHelper(t,e,s,i,r){const a=this.getSegment(t).get(),m=this.getSegment(e).get();if(a.isDegenerate(0)||m.isDegenerate(0))return 0;const u=this.tryOverlapIntersectCurves(t,e,s,i);if(0!==u)return u;const c=ot(.01*s);let g=!1,d=this.processSharpCorners(a,m,s,r>4);const _=d>0;if(!_){if(!(i||5&am(!0,!1,a,m,s,!0)))return 0;d=lm(!0,a,m,null,this.parent.m_param1,this.parent.m_param2,s)}0===d&&P("");const f=a.getGeometryType(),x=m.getGeometryType(),y=T(l,d),C=T(l,d),E=h(d,Number.NaN),S=h(d,Number.NaN),v=h(d,Number.NaN),I=h(d,Number.NaN),b=ie(vl,d),w=ie(vl,d);let D=!1,N=!1;for(let n=0;n<d;n++){const i=this.parent.m_param1[n],r=this.parent.m_param2[n];let o=t.rank,h=t.weight,u=!0,d=!1;0===i?(o=t.start.rank,h=t.start.weight,d=t.start.bIsBreak):1===i?(o=t.end.rank,h=t.end.weight,d=t.end.bIsBreak):(D=!0,u=!1);let p=e.rank,P=e.weight,T=!1,A=!0;0===r?(p=e.start.rank,P=e.start.weight,T=e.start.bIsBreak):1===r?(p=e.end.rank,P=e.end.weight,T=e.end.bIsBreak):(N=!0,A=!1);let M=o,G=p;if(M===G&&(M*=El.c_maxGeometryTypeToRankDelta,G*=El.c_maxGeometryTypeToRankDelta,M+=Tl(f,a,!1),G+=Tl(x,m,!1)),u&&A&&G===M){const t=a.getCoord2D(i),e=m.getCoord2D(r);t.equals(e)&&(G=M-1)}let q=1,F=0,V=1,Y=0;const X=new l,k=new l,R=a.getCoord2D(i),L=m.getCoord2D(r);if(_&&l.distance(R,L)>s)X.setCoordsPoint2D(R),k.setCoordsPoint2D(L),q=h,V=P,F=o,Y=p,b[n].bBigMove=!1,w[n].bBigMove=!1,d=!0,T=!0;else if(M===G){V=q=h+P,Y=F=o,st(R,L,P/q,X),k.setCoordsPoint2D(X);const t=l.sqrDistance(X,R),e=l.sqrDistance(X,L);b[n].bBigMove=t>c,w[n].bBigMove=e>c,D||R.equals(X)||(D=!0),N||L.equals(k)||(N=!0)}else if(M>G){X.setCoordsPoint2D(R),k.setCoordsPoint2D(X),V=q=h,Y=F=o;const t=l.sqrDistance(X,L);b[n].bBigMove=!1,w[n].bBigMove=t>c,N||L.equals(k)||(N=!0)}else{k.setCoordsPoint2D(L),X.setCoordsPoint2D(k),V=q=P,Y=F=p;const t=l.sqrDistance(X,R);b[n].bBigMove=t>c,w[n].bBigMove=!1,D||R.equals(X)||(D=!0)}y[n].assign(X),C[n].assign(k),E[n]=q,S[n]=V,v[n]=F,I[n]=Y,b[n].bIsBreak=d||T,w[n].bIsBreak=d||T,g||=b[n].bBigMove||w[n].bBigMove,n>0&&(i!==this.parent.m_param1[n-1]&&r!==this.parent.m_param2[n-1]||(v[n]<=v[n-1]?(y[n].assign(C[n-1]),E[n]=S[n-1],v[n]=I[n-1],C[n].assign(C[n-1]),S[n]=S[n-1],I[n]=I[n-1],b[n].bBigMove||=b[n-1].bBigMove,w[n].bBigMove||=w[n-1].bBigMove,b[n].bIsBreak||=b[n-1].bIsBreak,w[n].bIsBreak||=w[n-1].bIsBreak):(y[n-1].assign(y[n]),E[n-1]=E[n],v[n-1]=v[n],C[n-1].assign(C[n]),S[n-1]=S[n],I[n-1]=I[n],b[n-1].bBigMove||=b[n].bBigMove,w[n-1].bBigMove||=w[n].bBigMove,b[n-1].bIsBreak||=b[n].bIsBreak,w[n-1].bIsBreak||=w[n].bIsBreak)))}if(!(D||N||2!==d||f===o.enumLine&&x===o.enumLine)){if(this.processDoublyConnectedEdges(t,e,r+1,s))return this.parent.m_changed1=!0,this.parent.m_changed2=!0,2;n(0)}this.parent.m_changed1||=D,this.parent.m_changed2||=N;let A=t,M=t.end.weight,G=t.end.rank,q=t.end.bBigMove,F=t.end.bIsBreak,V=0,Y=-1;for(let e=0;e<=d;e++){const n=e<d?this.parent.m_param1[e]:1;if(n!==V){const i=this.parent.allocResultSegment(),r=this.parent.m_resultSegments[i];let o,h,m,u;a.queryCut(V,n,r,!1),r.get().snapControlPoints(s*s);let c=!1,g=!1,_=!1,p=!1;const f=new l,x=new l;-1!==Y?(h=v[Y],o=E[Y],_=b[Y].bBigMove,c=b[Y].bIsBreak,f.assign(y[Y])):(o=t.start.weight,h=t.start.rank,_=t.start.bBigMove,c=t.start.bIsBreak,f.assign(r.get().getStartXY())),e<d?(u=v[e],m=E[e],p=b[e].bBigMove,g=b[e].bIsBreak,x.assign(y[e])):(m=M,u=G,p=q,g=F,x.assign(r.get().getEndXY()));let P=A;n<1&&(this.splitEdgeInPlace(A),P=A.getNextInChain()),this.updateSegmentOnly(A,i),0===A.start.hash||A.start.pt.equals(f)||(this.m_newNodes.push(A.start),this.removeNodeFromHash(A.start),A.start.hash=0),0===A.end.hash||A.end.pt.equals(x)||(this.m_newNodes.push(A.end),this.removeNodeFromHash(A.end),A.end.hash=0),A.start.pt.assign(f),A.end.pt.assign(x),A.start.bBigMove||=_,A.end.bBigMove||=p,A.start.bIsBreak||=c,A.end.bIsBreak||=g,A.start.weight=o,A.start.rank=h,A.end.weight=m,A.end.rank=u,A=P,V=n,Y=e}else-1===Y&&(Y=e)}const X=A.getNextInChain(),k=[];k.length=d;for(let t=0;t<d;t++)k[t]=t;d>2?(k.sort((t,e)=>at(this.parent.m_param2[t],this.parent.m_param2[e])),this.parent.m_param2.sort(at)):2===d&&this.parent.m_param2[0]>this.parent.m_param2[1]&&(this.parent.m_param2[1]=p(this.parent.m_param2[0],this.parent.m_param2[0]=this.parent.m_param2[1]),k[1]=p(k[0],k[0]=k[1])),A=e,M=e.end.weight,G=e.end.rank,q=e.end.bBigMove,F=e.end.bIsBreak,V=0,Y=-1;for(let t=0;t<=d;t++){const n=t<d?this.parent.m_param2[t]:1;if(n!==V){const i=this.parent.allocResultSegment(),r=this.parent.m_resultSegments[i];let o,a,h,u;m.queryCut(V,n,r,!1),r.get().snapControlPoints(s*s);const c=new l,g=new l;let _=!1,p=!1,f=!1,x=!1;if(-1!==Y){const t=k[Y];o=S[t],a=I[t],c.assign(C[t]),f=w[t].bBigMove,_=w[t].bIsBreak}else o=e.start.weight,a=e.start.rank,f=e.start.bBigMove,_=e.start.bIsBreak,c.assign(r.get().getStartXY());if(t!==d){const e=k[t];h=S[e],u=I[e],g.assign(C[e]),x=w[e].bBigMove,p=w[e].bIsBreak}else h=M,u=G,x=q,p=F,g.assign(r.get().getEndXY());let y=A;n<1&&(this.splitEdgeInPlace(A),y=A.getNextInChain()),this.updateSegmentOnly(A,i),0===A.start.hash||A.start.pt.equals(c)||(this.m_newNodes.push(A.start),this.removeNodeFromHash(A.start),A.start.hash=0),0===A.end.hash||A.end.pt.equals(g)||(this.m_newNodes.push(A.end),this.removeNodeFromHash(A.end),A.end.hash=0),A.start.pt.assign(c),A.end.pt.assign(g),A.start.bBigMove||=f,A.end.bBigMove||=x,A.start.bIsBreak||=_,A.end.bIsBreak||=p,A.start.weight=o,A.start.rank=a,A.end.weight=h,A.end.rank=u,A=y,V=n,Y=t}else-1===Y&&(Y=t)}const R=A.getNextInChain();return this.postProcessResultPartsForCurves(t,X,e,R,r+1),g?3:2}intersectCurves(e,s){2!==this.parent.m_inputSegments.length&&P(""),this.parent.m_changed1=!1,this.parent.m_changed2=!1,this.parent.m_tolerance=e,this.m_hashTableOfEqualsSize=0,this.m_hashTableOfEquals=Kt(16);const i=t.constructEmpty();for(let e=0;e<2;e++){const s=this.parent.allocResultSegmentFromSegment(this.parent.m_inputSegments[this.parent.m_inputParts[e].segmentIndex]),n=t.constructEmpty();this.parent.m_inputSegments[this.parent.m_inputParts[e].segmentIndex].queryLooseEnvelope(n),i.mergeEnvelope2D(n);const r=this.parent.m_inputParts[e];this.addSegment(s,0,r.weightStart,r.rankStart,r.weightEnd,r.rankEnd,r.weightInterior,r.rankInterior,r.u.bBreakStart,r.u.bBreakEnd,r.segmentParentage)}i.inflateCoords(100*e,100*e),this.m_origin.assign(i.getLowerLeft()),this.m_cell.setCoords(2*e,2*e),this.m_pairs.push(wl(this.m_chainOrigin1.nextInChain,this.m_chainOrigin2.nextInChain,0,s));let r=0,o=!0;for(;this.m_pairs.length;){const t=this.m_pairs.at(-1);this.m_pairs.pop(),n(t.recursion>=0),n(t.recursion<=256),this.clusterNodes(e);const s=this.intersectCurvesHelper(t.edge1,t.edge2,e,t.bIsIntersecting,t.recursion);o&&(o=!1,r=s)}for(let t=0;t<2;t++){const e=0===t?this.parent.m_resultParts1:this.parent.m_resultParts2;for(let s=(0===t?this.m_chainOrigin1:this.m_chainOrigin2).nextInChain;null!=s;s=s.getNextInChain())e.push(this.parent.newIntersectionPart_(s.segmentIndex,s.start.weight,s.start.rank,s.end.weight,s.end.rank,s.weight,s.rank,s.start.bIsBreak,s.end.bIsBreak,s.segmentParentage)),e.at(-1).u.bBigMoveStart=s.start.bBigMove,e.at(-1).u.bBigMoveEnd=s.end.bBigMove}return r}tryOverlapIntersectCurves(t,e,s,i){const r=this.parent.m_resultSegments[t.segmentIndex].get(),o=this.parent.m_resultSegments[e.segmentIndex].get(),a=r.getStartXY().equals(o.getStartXY())&&r.getEndXY().equals(o.getEndXY()),h=r.getStartXY().equals(o.getEndXY())&&r.getEndXY().equals(o.getStartXY());if(!a&&!h)return 0;const m=hm(r,o,!0);if(0!==m&&mm(r,o)&&t.segmentParentage===e.segmentParentage){let t=!1;if(m>0)t=r.equals(o);else{n(-1===m);const e=new fm({segment:o});e.get().reverse(),t=r.equals(e.get())}if(t)return 1}const u=s*El.c_smallToleranceFactor;let c=!1;if(0===m){const t=[.5,.25,.75,.125,.375,.625,.875,.5625,.3125];for(let e=0,n=t.length;e<n;++e){const n=t[e],i=new l;r.queryCoord2D(n,i);const a=o.getClosestCoordinate(i,!1),h=new l;o.queryCoord2D(a,h);const m=l.distance(i,h);if(m>s)return 0;c||=m>u}for(let e=0,n=t.length;e<n;++e){const n=t[e],i=new l;o.queryCoord2D(n,i);const a=r.getClosestCoordinate(i,!1),h=new l;r.queryCoord2D(a,h);const m=l.distance(i,h);if(m>s)return 0;c||=m>u}}let g=t.rank,d=e.rank;return g===d&&(g*=El.c_maxGeometryTypeToRankDelta,d*=El.c_maxGeometryTypeToRankDelta,g+=Tl(r.getGeometryType(),r,!0),d+=Tl(o.getGeometryType(),o,!0)),g>d?(e.copyFromWhenOverlap(this,t,a),e.transferAttributes(this,r,a)):d>g?(t.copyFromWhenOverlap(this,e,a),t.transferAttributes(this,o,a)):t.segmentParentage<=e.segmentParentage?(t.weight=t.weight+e.weight,e.copyFromWhenOverlap(this,t,a),e.transferAttributes(this,r,a)):(e.weight=t.weight+e.weight,t.copyFromWhenOverlap(this,e,a),t.transferAttributes(this,o,a)),c?3:2}postProcessResultPartsForCurves(t,e,s,n,i){i===re()&&P("curve_helper");for(let s=t;s!==e;s=s.getNextInChain())this.updateSegmentToNodes(s);for(let t=s;t!==n;t=t.getNextInChain())this.updateSegmentToNodes(t);for(let r=t;r!==e;r=r.getNextInChain()){const t=r.end.pt.sub(r.start.pt);for(let e=s;e!==n;e=e.getNextInChain()){let s=0;if(r.start.pt.equals(e.start.pt)&&r.end.pt.equals(e.end.pt)?s=1:r.start.pt.equals(e.end.pt)&&r.end.pt.equals(e.start.pt)&&(s=-1),!s){let s=r.start.pt.equals(e.start.pt)?1:0;if(s||(s=r.end.pt.equals(e.end.pt)?2:0,s||(s=r.end.pt.equals(e.start.pt)?3:0,s||(s=r.start.pt.equals(e.end.pt)?4:0))),s){const n=e.end.pt.sub(e.start.pt),o=t.dotProduct(n);let a;switch(s){case 1:case 2:a=o>0;break;case 3:case 4:a=o<0;break;default:P("post_process_result_parts_for_curves_")}a&&this.m_pairs.push(wl(r,e,i,!1))}continue}const n=this.parent.m_resultSegments[r.segmentIndex],o=this.parent.m_resultSegments[e.segmentIndex],a=[.5,.25,.75];for(let t=0,e=a.length;t<e;++t){const e=a[t],i=new l;n.get().queryCoord2D(e,i);const r=o.get().getClosestCoordinate(i,!1),h=new l;if(o.get().queryCoord2D(r,h),l.distance(i,h)>this.parent.m_tolerance){s=0;break}}if(!s){this.m_pairs.push(wl(r,e,i,!1));continue}for(let t=0,e=a.length;t<e;++t){const e=a[t],i=new l;o.get().queryCoord2D(e,i);const r=n.get().getClosestCoordinate(i,!1),h=new l;if(n.get().queryCoord2D(r,h),l.distance(i,h)>this.parent.m_tolerance){s=0;break}}if(!s){this.m_pairs.push(wl(r,e,i,!1));continue}r.equalEdge=e,e.equalEdge=r;let h=r.rank,m=e.rank;h===m&&(h*=El.c_maxGeometryTypeToRankDelta,m*=El.c_maxGeometryTypeToRankDelta,h+=Tl(n.get().getGeometryType(),n.get(),!0),m+=Tl(o.get().getGeometryType(),o.get(),!0)),h>m||h===m&&r.segmentParentage<=e.segmentParentage?(n.copyTo(o,!1),e.segmentParentage=r.segmentParentage,-1===s&&o.get().reverse()):(o.copyTo(n,!1),r.segmentParentage=e.segmentParentage,-1===s&&n.get().reverse());break}}this.updateAttachedEdgesAfterNodeChange(t.start),e&&this.updateAttachedEdgesAfterNodeChange(e.start),this.updateAttachedEdgesAfterNodeChange(s.start),n&&this.updateAttachedEdgesAfterNodeChange(n.start)}processDoublyConnectedEdges(t,e,s,n){s===re()&&P("curve_helper");const i=this.getSegment(t).get(),r=this.getSegment(e).get(),o=i.getStartXY().equals(r.getStartXY())&&i.getEndXY().equals(r.getEndXY())?1:i.getEndXY().equals(r.getStartXY())&&i.getStartXY().equals(r.getEndXY())?-1:0;if(0!==o){const a=new fm;i.queryCut(0,.5,a),a.get().snapControlPoints(n*n);const h=new fm;i.queryCut(.5,1,h),h.get().snapControlPoints(n*n),this.splitEdgeInPlace(t),t.end.pt=a.get().getEndXY(),t.segmentIndex=this.parent.allocResultSegmentFromBuffer(a),t.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(h);let m=r.getClosestCoordinate(t.end.pt,!1);return Math.abs(m-.5)>.2&&(m=.5),r.queryCut(0,m,a),a.get().snapControlPoints(n*n),r.queryCut(m,1,h),h.get().snapControlPoints(n*n),this.splitEdgeInPlace(e),e.end.pt=a.get().getEndXY(),e.segmentIndex=this.parent.allocResultSegmentFromBuffer(a),e.getNextInChain().segmentIndex=this.parent.allocResultSegmentFromBuffer(h),o>0?(this.m_pairs.push(wl(t,e,s,!1)),this.m_pairs.push(wl(t.getNextInChain(),e.getNextInChain(),s,!1))):(this.m_pairs.push(wl(t,e.getNextInChain(),s,!1)),this.m_pairs.push(wl(t.getNextInChain(),e,s,!1))),!0}return!1}newNode(t,e,s,n){const i=new bl;return this.m_newNodes.push(i),i.pt=t,i.rank=s,i.weight=e,i.bIsBreak=n,i}newEdge(t,e,s,n,i,r){const o=new Il;return o.start=t,o.end=e,t.nextInChain=o,e.prevInChain=o,o.segmentIndex=s,o.segmentParentage=r,o.rank=i,o.weight=n,o}splitEdgeInPlace(t){t.segmentIndex=-1;const e=new Il,s=new bl;this.m_newNodes.push(s),s.pt.setNAN(),s.nextInChain=e,s.prevInChain=t,s.prevInHash=null,s.nextInHash=null,s.prevEqual=null,s.nextEqual=null,s.weight=t.weight,s.rank=t.rank,s.bIsBreak=!1,s.bBigMove=!1,e.start=s,e.segmentIndex=-1,e.end=t.end,e.end.prevInChain=e,e.rank=t.rank,e.weight=t.weight,e.segmentParentage=t.segmentParentage,t.end=s,t.equalEdge&&(t.equalEdge.equalEdge=null),t.equalEdge=null}updateSegmentOnly(t,e){t.segmentIndex=e}updateAttachedEdgesAfterNodeChange(t){for(let e=t.equalListHead();null!==e;e=e.nextEqual)this.updateAttachedEdgesAfterNodeChangeImpl(e)}updateAttachedEdgesAfterNodeChangeImpl(t){const e=t.prevInChain;if(e&&e.hasSegment()){const s=this.getSegment(e).get();t.pt.equals(s.getEndXY())||(s.setCoordsForIntersector(e.start.pt,e.end.pt,!1),s.ensureXYMonotone())}const s=t.nextInChain;if(s&&s.hasSegment()){const e=this.getSegment(s).get();t.pt.equals(e.getStartXY())||(e.setCoordsForIntersector(s.start.pt,s.end.pt,!1),e.ensureXYMonotone())}}updateSegmentToNodes(t){const e=this.getSegment(t).get();t.start.pt.equals(e.getStartXY())&&t.end.pt.equals(e.getEndXY())||(e.setCoordsForIntersector(t.start.pt,t.end.pt,!1),e.ensureXYMonotone()),this.updateAttachedEdgesAfterNodeChange(t.start),this.updateAttachedEdgesAfterNodeChange(t.end)}getSegment(t){return this.parent.m_resultSegments[t.segmentIndex]}clusterNodes(t){let e=!1;const s=[],n=[],i=[];for(let t=0,e=this.m_newNodes.length;t<e;t++){const s=this.m_newNodes[t];if(null===s)continue;let n=s;for(let i=t+1;i<e;i++){const t=this.m_newNodes[i];null!==t&&s.pt.equals(t.pt)&&(n.nextInHash=t,t.prevInHash=n,n=t,this.m_newNodes[i]=null)}}for(let r=0,o=this.m_newNodes.length;r<o;r++){const o=this.m_newNodes[r];if(null==o)continue;for(o.hash=this.calculateHash(o.pt);;){const r=Kt(4),a=this.hashTableBinsToCheck(o,r);for(let e=0;e<a;e++)if(null!==r[e])for(let a=r[e];null!==a;){const e=a.nextInHash;l.distance(o.pt,a.pt)<=t&&(s.push(a),this.removeNodeFromHash(a),a.hash=0,i.push(a),n.push(a)),a=e}let h=!1;for(const t of s)if(!o.pt.equals(t.pt)){const s=xl(o.pt,t.pt,o.weight,o.rank,t.weight,t.rank);o.pt.assign(s.pt),o.weight=s.weight,o.rank=s.rank,h=!0,e=!0}if(s.length=0,!h)break;o.hash=this.calculateHash(o.pt)}i.push(o),n.push(o);for(let t=o.nextInHash;null!==t;){t.prevInHash=null;const e=t.nextInHash;t.nextInHash=null,i.push(t),n.push(t),t=e}const a=o.hash;let h=null,m=null;for(const t of n)o!==t&&(t.hash=a,t.pt.assign(o.pt),t.rank=o.rank,t.weight=o.weight),t.prevInHash=h,h&&(h.nextInHash=t),t.prevEqual=m,t.nextEqual=null,m&&(m.nextEqual=t),m=t,h=t;const u=a%this.m_hashTableOfEquals.length;h.nextInHash=this.m_hashTableOfEquals[u],null!==this.m_hashTableOfEquals[u]&&(this.m_hashTableOfEquals[u].prevInHash=h),this.m_hashTableOfEquals[u]=n[0],this.m_hashTableOfEqualsSize+=n.length,n.length=0,this.rehashIfNeeded()}if(this.m_newNodes.length=0,e)for(const t of i)this.updateAttachedEdgesAfterNodeChange(t)}rehashIfNeeded(){if(2*this.m_hashTableOfEqualsSize>this.m_hashTableOfEquals.length){const t=this.m_hashTableOfEquals;this.m_hashTableOfEquals=Kt(2*t.length),this.m_hashTableOfEqualsSize=0;for(const e of t){let t=e;for(;t;){const e=t.nextInHash;t.nextInHash=null,t.prevInHash=null,this.addNodeToHashImpl(t),t=e}}}}addNodeToHashImpl(t){const e=t.hash%this.m_hashTableOfEquals.length,s=this.m_hashTableOfEquals[e];t.nextInHash=s,null!==s&&(s.prevInHash=t),this.m_hashTableOfEquals[e]=t,this.m_hashTableOfEqualsSize++}removeNodeFromHash(t){const e=t.hash%this.m_hashTableOfEquals.length,s=t.prevInHash,n=t.nextInHash;s?s.nextInHash=n:this.m_hashTableOfEquals[e]=n,n&&(n.prevInHash=s),this.m_hashTableOfEqualsSize--,t.prevInHash=null,t.nextInHash=null}hashTableBinsToCheck(t,e){const s=(t.pt.x-this.m_origin.x)/this.m_cell.x,n=(t.pt.y-this.m_origin.y)/this.m_cell.y,i=c()-1,r=Math.round(A(s,-2147483646,i)),o=Math.round(A(n,-2147483646,i));let a=r|o<<32;a=Yt(a),e[0]=this.m_hashTableOfEquals[a%this.m_hashTableOfEquals.length];let h=r+1|o<<32;h=Yt(h);let m=1;e[1]=this.m_hashTableOfEquals[h%this.m_hashTableOfEquals.length],e[1]!==e[0]&&(m=2);let l=r+1|o+1<<32;l=Yt(l),e[m]=this.m_hashTableOfEquals[l%this.m_hashTableOfEquals.length];for(let t=0;t<m;t++)if(e[m]===e[t]){m--;break}m++;let u=r|o+1<<32;u=Yt(u),e[m]=this.m_hashTableOfEquals[u%this.m_hashTableOfEquals.length];for(let t=0;t<m;t++)if(e[m]===e[t]){m--;break}return m++,m}calculateHash(t){const e=(t.x-this.m_origin.x)/this.m_cell.x,s=(t.y-this.m_origin.y)/this.m_cell.y,n=c()-1;let i=Math.round(A(e,-2147483646,n))|Math.round(A(s,-2147483646,n))<<32;return i=Yt(i),0===i&&(i=1),i}processSharpCorners(t,e,s,n){if(this.parent.m_param1.length=0,this.parent.m_param2.length=0,t.getStartXY().equals(e.getStartXY())){const i=[0,0],r=[0,0],o=gm(t,e,0,0,s,2,i,r,n);if(o){this.parent.m_param1.push(0),this.parent.m_param2.push(0);for(let t=0;t<o;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return o+1}}if(t.getEndXY().equals(e.getEndXY())){const i=[0,0],r=[0,0],o=gm(t,e,1,1,s,2,i,r,n);if(o){for(let t=0;t<o;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return this.parent.m_param1.push(1),this.parent.m_param2.push(1),o+1}}if(t.getStartXY().equals(e.getEndXY())){const i=[0,0],r=[0,0],o=gm(t,e,0,1,s,2,i,r,n);if(o){this.parent.m_param1.push(0),this.parent.m_param2.push(1);for(let t=0;t<o;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return o+1}}if(t.getEndXY().equals(e.getStartXY())){const i=[0,0],r=[0,0],o=gm(t,e,1,0,s,2,i,r,n);if(o){for(let t=0;t<o;t++)this.parent.m_param1.push(i[t]),this.parent.m_param2.push(r[t]);return this.parent.m_param1.push(1),this.parent.m_param2.push(0),o+1}}return 0}}function Tl(t,e,s){let n=0;switch(t){case o.enumLine:n=0;break;case o.enumBezier:n=2;break;case o.enumRationalBezier2:n=3;break;case o.enumBezier2:n=1;break;case o.enumEllipticArc:n=0===e.projectionBehavior()?5:4;break;default:P("")}return s?5-n:n}class Nl extends gl{constructor(t){super(t.m_shape,t.m_tolerance,!1),this.m_parent=t}compare(t,e,s){if(this.m_bIntersectionDetected)return-1;const n=t.getElement(s),i=this.m_parent.getEdgeOriginVertices(e),r=this.m_parent.m_edgeVertices.getFirstElement(i),o=this.m_parent.getEdgeOriginVertices(n),a=this.m_parent.m_edgeVertices.getFirstElement(o);return this.m_currentNode=s,this.compareSegments(e,r,n,a)}}class Al extends dl{constructor(t){super(t.m_shape,t.m_tolerance),this.m_parent=t}compare(t,e){if(this.m_bIntersectionDetected)return-1;const s=t.getElement(e),n=this.m_parent.getEdgeOriginVertices(s),i=this.m_parent.m_edgeVertices.getFirstElement(n);return this.m_currentNode=e,this.compareVertex(t,e,i)}}class Ml extends hs{constructor(t){super(),this.pt1=l.getNAN(),this.pt2=l.getNAN(),this.m_shape=t}compare(t,e,s){this.m_shape.queryXY(e,this.pt1);const n=t.getElement(s);return this.m_shape.queryXY(n,this.pt2),this.pt1.compare(this.pt2)}}class Gl{constructor(t){this.m_point=l.getNAN(),this.m_pt=l.getNAN(),this.m_shape=t}setPoint(t){this.m_point.setCoordsPoint2D(t)}compare(t,e){const s=t.getElement(e);return this.m_shape.queryXY(s,this.m_pt),this.m_point.compare(this.m_pt)}}class ql{constructor(t,e){this.m_shape=null,this.m_progressTracker=null,this.m_edges=new Ue(8),this.m_clusters=new Ue(5),this.m_clusterVertices=new ul(!1),this.m_edgeVertices=new ul(!1),this.m_helperPoint=new qe,this.m_eventQ=new ze,this.m_sweepStructure=new ze,this.m_bComplications=!1,this.m_sweepComparator=null,this.m_tempEdgeBuffer=[],this.m_modifiedClusters=[],this.m_edgesToInsertInSweepStructure=[],this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1,this.m_progressCounter=0,this.m_segmentIntersector=new El,this.m_segBuf1=new fm,this.m_segBuf2=new fm,this.m_sweepPoint=new l(0,0),this.m_tolerance=0,this.m_toleranceSqr=0,this.m_sweepPointCluster=-1,this.m_vertexClusterIndex=-1,this.m_bCracked=!1,this.m_bSweepPointClusterWasModified=!1,this.m_progressTracker=t,this.m_bTrackChanges=e}hadComplications(){return this.m_bComplications}sweep(t,e){const s=new Ps;s.setSwapCoordinates(),t.applyTransformation(s),this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e;let n=this.sweepImpl_();return t.applyTransformation(s),n||(this.fillEventQueuePass2(),n=this.sweepImpl_()||n),this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_shape=null,this.m_bCracked}sweepVertical(t,e){this.setEditShape_(t),this.m_bCracked=!1,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bComplications=!1;let s=this.sweepImpl_();if(!this.m_bComplications){const n=t.filterClosePoints(e,!0,!1,this.m_bTrackChanges,Ar);this.m_bComplications=1===n,s||=1===n}return-1!==this.m_vertexClusterIndex&&(this.m_shape.removeUserIndex(this.m_vertexClusterIndex),this.m_vertexClusterIndex=-1),this.m_shape=null,s}getEdgeCluster(t,e){return this.m_edges.getField(t,0+e)}setEdgeCluster_(t,e,s){this.m_edges.setField(t,0+e,s)}getEdgeOriginVertices(t){return this.m_edges.getField(t,2)}setEdgeOriginVertices_(t,e){this.m_edges.setField(t,2,e)}getNextEdgeEx(t,e){return this.m_edges.getField(t,3+e)}setNextEdgeEx_(t,e,s){this.m_edges.setField(t,3+e,s)}getEdgeSweepNode(t){return this.m_edges.getField(t,7)}setEdgeSweepNode_(t,e){this.m_edges.setField(t,7,e)}getNextEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,3+s)}setNextEdge_(t,e,s){const n=this.getEdgeEnd(t,e);this.m_edges.setField(t,3+n,s)}getPrevEdge(t,e){const s=this.getEdgeEnd(t,e);return this.m_edges.getField(t,5+s)}setPrevEdge_(t,e,s){const n=this.getEdgeEnd(t,e);this.m_edges.setField(t,5+n,s)}getClusterVertices(t){return this.m_clusters.getField(t,0)}setClusterVertices_(t,e){this.m_clusters.setField(t,0,e)}getClusterSweepEdgeList(t){return this.m_clusters.getField(t,2)}setClusterSweepEdgeList_(t,e){this.m_clusters.setField(t,2,e)}getClusterFirstEdge(t){return this.m_clusters.getField(t,1)}setClusterFirstEdge_(t,e){this.m_clusters.setField(t,1,e)}getClusterEventQNode(t){return this.m_clusters.getField(t,3)}setClusterEventQNode_(t,e){this.m_clusters.setField(t,3,e)}newCluster_(t){const e=this.m_clusters.newElement(),s=this.m_clusterVertices.createList();return this.setClusterVertices_(e,s),t!==Ar&&(this.m_clusterVertices.addElement(s,t),this.m_shape.setUserIndex(t,this.m_vertexClusterIndex,e)),e}deleteCluster_(t){this.m_clusters.deleteElement(t)}addVertexToCluster_(t,e){const s=this.getClusterVertices(t);this.m_clusterVertices.addElement(s,e),this.m_shape.setUserIndex(e,this.m_vertexClusterIndex,t)}newEdge_(t){const e=this.m_edges.newElement(),s=this.m_edgeVertices.createList();return this.setEdgeOriginVertices_(e,s),-1!==t&&this.m_edgeVertices.addElement(s,t),e}addVertexToEdge_(t,e){const s=this.getEdgeOriginVertices(t);this.m_edgeVertices.addElement(s,e)}deleteEdge_(t){this.m_edges.deleteElement(t);const e=this.m_edgesToInsertInSweepStructure.findIndex(e=>e===t);e>=0&&ee(this.m_edgesToInsertInSweepStructure,e)}addEdgeToCluster(t,e){-1===this.getEdgeCluster(t,0)?this.setEdgeCluster_(t,0,e):-1===this.getEdgeCluster(t,1)?this.setEdgeCluster_(t,1,e):P(""),this.addEdgeToClusterImpl_(t,e)}addEdgeToClusterImpl_(t,e){const s=this.getClusterFirstEdge(e);if(-1!==s){const n=this.getNextEdge(s,e);this.setPrevEdge_(n,e,t),this.setNextEdge_(t,e,n),this.setNextEdge_(s,e,t),this.setPrevEdge_(t,e,s)}else this.setPrevEdge_(t,e,t),this.setNextEdge_(t,e,t),this.setClusterFirstEdge_(e,t)}getEdgeEnd(t,e){return this.getEdgeCluster(t,0)===e?0:1}mergeClusters_(t,e){this.dbgCheckCluster_(t),this.dbgCheckCluster_(e);const s=this.getClusterEventQNode(e);-1!==s&&(this.m_eventQ.deleteNode(s),this.setClusterEventQNode_(e,-1));let n=this.getClusterFirstEdge(t),i=this.getClusterFirstEdge(e);if(-1!==i){let s=i,r=i,o=!1;do{this.dbgCheckEdge_(s),o=!1;const n=this.getEdgeEnd(s,e),a=this.getNextEdgeEx(s,n);if(this.getEdgeCluster(s,n+1&1)===t){this.disconnectEdge_(s);const t=this.getEdgeOriginVertices(s);if(this.m_edgeVertices.deleteList(t),this.deleteEdge_(s),s===a){i=-1;break}i===s&&(i=this.getClusterFirstEdge(e),r=a,o=!0)}s=a}while(s!==r||o);if(-1!==i){do{const n=this.getEdgeEnd(s,e),i=this.getNextEdgeEx(s,n);this.setEdgeCluster_(s,n,t),s=i}while(s!==r);if(n=this.getClusterFirstEdge(t),-1!==n){const e=this.getNextEdge(n,t),s=this.getNextEdge(i,t);e===n?(this.setClusterFirstEdge_(t,i),this.addEdgeToClusterImpl_(n,t),this.setClusterFirstEdge_(t,n)):s===i&&this.addEdgeToClusterImpl_(i,t),this.setNextEdge_(i,t,e),this.setPrevEdge_(e,t,i),this.setNextEdge_(n,t,s),this.setPrevEdge_(s,t,n)}else this.setClusterFirstEdge_(t,i)}}const r=this.getClusterVertices(t),o=this.getClusterVertices(e);for(let e=this.m_clusterVertices.getFirst(o);-1!==e;e=this.m_clusterVertices.getNext(e)){const s=this.m_clusterVertices.getElement(e);this.m_shape.setUserIndex(s,this.m_vertexClusterIndex,t)}this.m_clusterVertices.concatenateLists(r,o),this.deleteCluster_(e),this.dbgCheckCluster_(t)}mergeEdges_(t,e){this.dbgCheckEdge_(t),this.dbgCheckEdge_(e);const s=this.getEdgeCluster(t,0),n=this.getEdgeCluster(t,1),i=this.getEdgeCluster(e,0),r=this.getEdgeCluster(e,1),o=this.getEdgeOriginVertices(t),a=this.getEdgeOriginVertices(e);if(this.m_edgeVertices.concatenateLists(o,a),e===this.getClusterFirstEdge(s)&&this.setClusterFirstEdge_(s,t),e===this.getClusterFirstEdge(n)&&this.setClusterFirstEdge_(n,t),this.disconnectEdge_(e),this.deleteEdge_(e),!(s===i&&n===r||n===i&&s===r)){const t=this.getClusterXY(s),e=this.getClusterXY(i);t.isEqualPoint2D(e)?(s!==i&&this.mergeClusters_(s,i),n!==r&&this.mergeClusters_(n,r)):(n!==i&&this.mergeClusters_(n,i),s!==r&&this.mergeClusters_(s,r))}this.dbgCheckEdge_(t)}disconnectEdge_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1);this.disconnectEdgeFromCluster_(t,e),this.disconnectEdgeFromCluster_(t,s)}disconnectEdgeFromCluster_(t,e){const s=this.getNextEdge(t,e),n=this.getPrevEdge(t,e),i=this.getClusterFirstEdge(e);s!==t?(this.setNextEdge_(n,e,s),this.setPrevEdge_(s,e,n),i===t&&this.setClusterFirstEdge_(e,s)):this.setClusterFirstEdge_(e,-1)}applyIntersectorToEditShape_(t,e,s){let n=this.m_edgeVertices.getFirst(t);const i=this.m_edgeVertices.getElement(n),r=this.getClusterFromVertex(i),o=this.m_shape.getNextVertex(i),a=this.getClusterFromVertex(o),h=this.m_shape.getXY(i),m=this.m_shape.getXY(o);let l=!1,u=!1;const c=e.getResultSegment(s,0).getStartXY(),g=e.getResultSegment(s,e.getResultSegmentCount(s)-1).getEndXY();h.equals(c)||(l=!0),m.equals(g)||(u=!0),this.m_shape.splitSegmentWithIntersector(i,e,s,!0,!0);const d=this.m_bTrackChanges&&e.getSegmentChanged(s);for(d&&this.m_shape.setGeometryModifiedWithVertex(i,!0),n=this.m_edgeVertices.getNext(n);-1!==n;n=this.m_edgeVertices.getNext(n)){const t=this.m_edgeVertices.getElement(n),i=this.getClusterFromVertex(t)===r;this.m_shape.splitSegmentWithIntersector(t,e,s,i,!0),d&&this.m_shape.setGeometryModifiedWithVertex(t,!0)}if(l&&this.updateClusterXY(!0,r,c,e.getResultSegmentStartPointWeight(s,0),e.getResultSegmentStartPointRank(s,0)),u){const t=e.getResultSegmentCount(s)-1;this.updateClusterXY(!0,a,g,e.getResultSegmentEndPointWeight(s,t),e.getResultSegmentEndPointRank(s,t))}}createEdgesAndClustersFromSplitEdge_(t,e,s){this.dbgCheckNewEdgesArray_();const n=this.getEdgeOriginVertices(t),i=this.getEdgeCluster(t,0),r=this.getEdgeCluster(t,1);let o=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(o);const a=Ue.impossibleIndex3();this.setEdgeSweepNode_(o,a),this.m_tempEdgeBuffer.push(o),this.addEdgeToCluster(o,i);const h=e.getResultSegmentCount(s);for(let t=1;t<h;t++){const t=this.newCluster_(-1);this.m_modifiedClusters.push(t),this.m_tempEdgeBuffer.push(t),this.addEdgeToCluster(o,t);const e=this.newEdge_(-1);this.m_edgesToInsertInSweepStructure.push(e),this.setEdgeSweepNode_(e,a),this.m_tempEdgeBuffer.push(e),this.addEdgeToCluster(e,t),o=e}this.addEdgeToCluster(o,r);for(let t=this.m_edgeVertices.getFirst(n);-1!==t;t=this.m_edgeVertices.getNext(t)){let e=this.m_edgeVertices.getElement(t);if(this.getClusterFromVertex(e)===i){let t=0;const s=this.m_tempEdgeBuffer.length;do{if(t>0){const s=this.m_tempEdgeBuffer[t-1];this.addVertexToCluster_(s,e)}const s=this.m_tempEdgeBuffer[t];t+=2,this.addVertexToEdge_(s,e),e=this.m_shape.getNextVertex(e)}while(t<s)}else{let t=this.m_tempEdgeBuffer.length-1;do{if(t<this.m_tempEdgeBuffer.length-2){const s=this.m_tempEdgeBuffer[t+1];this.addVertexToCluster_(s,e)}const s=this.m_tempEdgeBuffer[t];t-=2,this.addVertexToEdge_(s,e),e=this.m_shape.getNextVertex(e)}while(t>=0)}}this.m_tempEdgeBuffer.length=0,this.dbgCheckNewEdgesArray_()}getVertexFromClusterIndex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}getClusterFromVertex(t){return this.m_shape.getUserIndex(t,this.m_vertexClusterIndex)}processSplitHelper1_(t,e,s){const n=this.getEdgeCluster(e,0),i=this.getClusterXY(n),r=this.getEdgeCluster(e,1),o=this.getClusterXY(r),a=s.getResultSegmentCount(t);let h=s.getResultSegment(t,0);const m=h.getStartXY();if(i.isEqualPoint2D(m)||(this.m_bComplications||i.compare(this.m_sweepPoint)*m.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(n,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(n)),!this.m_bComplications&&a>1){const t=i.compare(o),e=h.getEndXY();(i.compare(e)!==t||e.compare(o)!==t||e.compare(this.m_sweepPoint)<0)&&(this.m_bComplications=!0)}h=s.getResultSegment(t,a-1);const l=h.getEndXY();o.isEqualPoint2D(l)||(this.m_bComplications||o.compare(this.m_sweepPoint)*l.compare(this.m_sweepPoint)<0&&(this.m_bComplications=!0),this.getAffectedEdges(r,this.m_tempEdgeBuffer),this.m_modifiedClusters.push(r)),this.m_tempEdgeBuffer.push(e);for(let t=0,s=this.m_tempEdgeBuffer.length;t<s;t++){const s=this.m_tempEdgeBuffer[t],n=this.getEdgeSweepNode(s);Ue.isValidElement(n)&&(this.m_sweepStructure.deleteNode(n),this.setEdgeSweepNode_(s,-1));const i=Ue.impossibleIndex3();s!==e&&this.getEdgeSweepNode(s)!==i&&(this.m_edgesToInsertInSweepStructure.push(s),this.setEdgeSweepNode_(s,i))}this.m_tempEdgeBuffer.length=0}checkAndFixIntersection_(t,e){const s=this.m_sweepStructure.getElement(t);return this.m_sweepComparator.compare(this.m_sweepStructure,s,e),!!this.m_sweepComparator.intersectionDetected()&&(this.m_sweepComparator.clearIntersectionDetectedFlag(),this.fixIntersection_(t,e),!0)}fixIntersection_(t,e){this.m_bCracked=!0;const s=this.m_sweepStructure.getElement(t),n=this.m_sweepStructure.getElement(e);let i=null,r=null;const o=this.getEdgeOriginVertices(s),a=this.m_edgeVertices.getFirstElement(o),h=this.getEdgeOriginVertices(n),m=this.m_edgeVertices.getFirstElement(h);this.m_shape.querySegment(a,this.m_segBuf1,!1,!1),i=this.m_segBuf1.get();const l=this.m_shape.getNextVertex(a),u=this.m_shape.getWeight(a),c=this.m_shape.getSegmentParentageBreakVertex(a),g=this.m_shape.getWeight(l),d=this.m_shape.getSegmentParentageBreakVertex(l),_=this.m_shape.getSegmentWeight(a),p=this.m_shape.getRank(a),f=this.m_shape.getRank(l),x=this.m_shape.getSegmentRank(a),y=this.m_shape.getSegmentParentage(a);this.m_shape.querySegment(m,this.m_segBuf2,!1,!1),r=this.m_segBuf2.get();const P=this.m_shape.getNextVertex(m),C=this.m_shape.getWeight(m),E=this.m_shape.getSegmentParentageBreakVertex(m),S=this.m_shape.getWeight(P),v=this.m_shape.getSegmentParentageBreakVertex(P),I=this.m_shape.getSegmentWeight(m),b=this.m_shape.getRank(m),w=this.m_shape.getRank(P),D=this.m_shape.getSegmentRank(m),T=this.m_shape.getSegmentParentage(m);this.m_segmentIntersector.pushSegment(i,u,p,g,f,_,x,c,d,y),this.m_segmentIntersector.pushSegment(r,C,b,S,w,I,D,E,v,T),3===this.m_segmentIntersector.intersect2D(this.m_tolerance,!0)&&(this.m_bComplications=!0),this.splitEdge_(s,n,-1,this.m_segmentIntersector),this.m_segmentIntersector.clear()}fixIntersectionPointSegment_(t,e){this.m_bCracked=!0;const s=this.m_sweepStructure.getElement(e);let n=null;const i=this.getEdgeOriginVertices(s),r=this.m_edgeVertices.getFirstElement(i);this.m_shape.querySegment(r,this.m_segBuf1,!1,!1),n=this.m_segBuf1.get();const o=this.m_shape.getNextVertex(r),a=this.m_shape.getWeight(r),h=this.m_shape.getSegmentParentageBreakVertex(r),m=this.m_shape.getWeight(o),l=this.m_shape.getSegmentParentageBreakVertex(o),u=this.m_shape.getSegmentWeight(r),c=this.m_shape.getRank(r),g=this.m_shape.getRank(o),d=this.m_shape.getSegmentRank(r),_=this.m_shape.getSegmentParentage(r),p=this.getClusterFirstVertex(t);this.m_segmentIntersector.pushSegment(n,a,c,m,g,u,d,h,l,_),this.m_shape.queryPoint(p,this.m_helperPoint);const f=this.m_shape.getWeight(p),x=this.m_shape.getRank(p);this.m_segmentIntersector.intersect2DEx(this.m_tolerance,this.m_helperPoint,x,f,!0),this.splitEdge_(s,-1,t,this.m_segmentIntersector),this.m_segmentIntersector.clear()}insertNewEdges_(){if(0===this.m_edgesToInsertInSweepStructure.length)return!0;this.dbgCheckNewEdgesArray_();let t=!0,e=0;const s=this.m_edgesToInsertInSweepStructure.length,n=Math.max(2*s+200,this.m_sweepStructure.size()+200);for(;this.m_edgesToInsertInSweepStructure.length;){if(this.m_edgesToInsertInSweepStructure.length>Math.max(100,this.m_shape.getTotalPointCount())||e>n){this.m_edgesToInsertInSweepStructure.length=0,this.m_bComplications=!0,t=!1;break}const s=this.m_edgesToInsertInSweepStructure.at(-1);this.m_edgesToInsertInSweepStructure.pop(),this.setEdgeSweepNode_(s,-1);const i=this.isEdgeOnSweepLine_(s);Ue.isValidElement(i)?(this.insertNewEdgeToSweepStructure_(s,i),e++):i!==Ue.impossibleIndex2()&&(t=!1),this.m_bContinuingSegmentChainOptimization=!1}return t}insertNewEdgeToSweepStructure_(t,e){let s;if(this.m_bContinuingSegmentChainOptimization?(s=this.m_sweepStructure.addElementAtPosition(this.m_prevNeighbour,this.m_nextNeighbour,t,!0,!0),this.m_bContinuingSegmentChainOptimization=!1):s=this.m_sweepStructure.addUniqueElement(t),-1===s){const e=this.m_sweepStructure.getDuplicateElement(),s=this.m_sweepStructure.getElement(e);return this.mergeEdges_(s,t),!1}if(this.setEdgeSweepNode_(t,s),this.m_sweepComparator.intersectionDetected()){this.m_sweepComparator.clearIntersectionDetectedFlag();const t=this.m_sweepComparator.getLastComparedNode();return this.m_prevNeighbour===t&&(this.m_prevNeighbour=-1),this.m_nextNeighbour===t&&(this.m_nextNeighbour=-1),this.fixIntersection_(t,s),!0}return!1}isEdgeOnSweepLine_(t){const e=this.getEdgeCluster(t,0),s=this.getEdgeCluster(t,1),n=this.getClusterXY(e),i=this.getClusterXY(s);if(l.sqrDistance(n,i)<=this.m_toleranceSqr)return this.m_bComplications=!0,-1;const r=n.compare(this.m_sweepPoint),o=i.compare(this.m_sweepPoint);return r<=0&&o>0?s:o<=0&&r>0?e:r>0&&o>0?Ue.impossibleIndex2():-1}fillEventQueue(){const t=new Fe(0),e=this.m_shape.queryVertexIteratorOnSelection();for(let s=e.next();s!==Ar;s=e.next())-1!==this.m_shape.getUserIndex(s,this.m_vertexClusterIndex)&&t.add(s);this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0),this.m_eventQ.clear(),this.m_eventQ.setCapacity(t.size()),this.m_eventQ.setComparator(new Ml(this.m_shape));const s=l.getNAN();s.setNAN();let n=-1;for(let e=0,i=t.size();e<i;e++){const i=t.read(e);if(this.m_shape.getXY(i).isEqualPoint2D(s)){const t=this.m_shape.getUserIndex(i,this.m_vertexClusterIndex);this.mergeClusters_(n,t);continue}n=this.getClusterFromVertex(i),this.m_shape.queryXY(i,s);const r=this.m_eventQ.addBiggestElement(i);this.setClusterEventQNode_(n,r)}}fillEventQueuePass2(){const t=new Fe(0);for(let e=this.m_eventQ.getFirst();-1!==e;e=this.m_eventQ.getNext(e)){const s=this.m_eventQ.getElement(e);t.add(s)}this.m_eventQ.clear(),this.m_shape.sortVerticesSimpleByY(t,0,t.size()),this.progress_(!0);for(let e=0,s=t.size();e<s;e++){const s=t.read(e),n=this.getClusterFromVertex(s),i=this.m_eventQ.addBiggestElement(s);this.setClusterEventQNode_(n,i)}}getAffectedEdges(t,e){const s=this.getClusterFirstEdge(t);if(-1===s)return;let n=s;do{const s=this.getEdgeSweepNode(n);Ue.isValidElement(s)&&e.push(n),n=this.getNextEdge(n,t)}while(n!==s)}updateClusterXY(t,e,s,n,i){const r=this.getClusterVertices(e);for(let e=this.m_clusterVertices.getFirst(r);-1!==e;e=this.m_clusterVertices.getNext(e)){const r=this.m_clusterVertices.getElement(e);this.m_shape.setXYMonotonicPoint2D(r,s),this.m_shape.setWeight(r,n),this.m_shape.setRank(r,i),t&&this.m_bTrackChanges&&this.m_shape.setGeometryModifiedWithVertex(r,!0),this.m_shape.setSegmentParentageBreakVertex(r,!0)}}splitEdge_(t,e,s,n){this.dbgCheckEdge_(t),-1!==e&&this.dbgCheckEdge_(e),this.disconnectEdge_(t),-1!==e&&this.disconnectEdge_(e),this.processSplitHelper1_(0,t,n),-1!==e&&this.processSplitHelper1_(1,e,n),-1!==s&&n.getResultPointChanged()&&this.m_modifiedClusters.push(s);for(let t=0,e=this.m_modifiedClusters.length;t<e;t++){const e=this.m_modifiedClusters[t],s=this.getClusterEventQNode(e);-1!==s&&(this.m_eventQ.deleteNode(s),this.setClusterEventQNode_(e,-1))}const i=this.getEdgeOriginVertices(t),r=-1!==e?this.getEdgeOriginVertices(e):-1;if(this.applyIntersectorToEditShape_(i,n,0),-1!==r)this.applyIntersectorToEditShape_(r,n,1);else{const t=n.getResultPoint().getXY();this.updateClusterXY(n.getResultPointChanged(),s,t,n.getResultPointWeight(),n.getResultPointRank())}this.createEdgesAndClustersFromSplitEdge_(t,n,0),-1!==e&&this.createEdgesAndClustersFromSplitEdge_(e,n,1),this.m_edgeVertices.deleteList(i),this.deleteEdge_(t),-1!==e&&(this.m_edgeVertices.deleteList(r),this.deleteEdge_(e));for(let t=0,e=this.m_modifiedClusters.length;t<e;t++){const e=this.m_modifiedClusters[t];e===this.m_sweepPointCluster&&(this.m_bSweepPointClusterWasModified=!0);let s=this.getClusterEventQNode(e);if(-1===s){const t=this.getClusterFirstVertex(e);if(s=this.m_eventQ.addUniqueElement(t),-1===s){const t=this.m_eventQ.getDuplicateElement(),s=this.m_eventQ.getElement(t),n=this.getClusterFromVertex(s);this.mergeClusters_(n,e)}else this.setClusterEventQNode_(e,s)}}this.m_modifiedClusters.length=0}getClusterXY(t){const e=this.getClusterFirstVertex(t);return this.m_shape.getXY(e)}getClusterFirstVertex(t){const e=this.getClusterVertices(t);return this.m_clusterVertices.getFirstElement(e)}dbgCheckEdge_(t){}dbgCheckCluster_(t){}dbgCheckNewEdgesArray_(){}dbgSaveSweepStructure_(t){}sweepImpl_(){this.progress_(!0),this.m_bSweepPointClusterWasModified=!1,this.m_sweepPointCluster=-1,null===this.m_sweepComparator&&(this.m_sweepStructure.disableBalancing(),this.m_sweepComparator=new Nl(this),this.m_sweepStructure.setComparator(this.m_sweepComparator));const t=[];let e=null,s=null;this.m_prevNeighbour=-1,this.m_nextNeighbour=-1,this.m_bContinuingSegmentChainOptimization=!1;const n=Ue.impossibleIndex2(),i=Ue.impossibleIndex3();for(let r=this.m_eventQ.getFirst();-1!==r;){this.progress_(),this.dbgCheckSweepStructure_(),this.m_bContinuingSegmentChainOptimization=!1,this.m_prevNeighbour=-1,this.m_nextNeighbour=-1;const o=this.m_eventQ.getElement(r);this.m_sweepPointCluster=this.getClusterFromVertex(o),this.m_shape.queryXY(o,this.m_sweepPoint),this.m_sweepComparator.setSweepY(this.m_sweepPoint.y,this.m_sweepPoint.x);let a=!1;{const e=this.getClusterFirstEdge(this.m_sweepPointCluster);if(a=-1===e,!a){let s=e;do{const e=this.getEdgeSweepNode(s);-1===e?(this.m_edgesToInsertInSweepStructure.push(s),this.setEdgeSweepNode_(s,i)):e!==i&&t.push(e),s=this.getNextEdge(s,this.m_sweepPointCluster)}while(s!==e)}}if(!this.m_sweepStructure.isAutoBalancing()&&(this.m_sweepStructure.getMaxDepthEver()>4||this.m_edgesToInsertInSweepStructure.length>10)&&this.m_sweepStructure.enableBalancing(),t.length>0){this.m_bContinuingSegmentChainOptimization=1===t.length&&1===this.m_edgesToInsertInSweepStructure.length;for(let e=0,s=t.length;e<s;e++){const s=this.m_sweepStructure.getElement(t[e]);this.setEdgeSweepNode_(s,n)}let e=n,s=n;for(let i=0,r=t.length;i<r;i++){const r=t[i];if(e===n){const t=this.m_sweepStructure.getPrev(r);if(-1!==t){const s=this.m_sweepStructure.getElement(t);this.getEdgeSweepNode(s)!==n&&(e=t)}else e=-1}if(s===n){const t=this.m_sweepStructure.getNext(r);if(-1!==t){const e=this.m_sweepStructure.getElement(t);this.getEdgeSweepNode(e)!==n&&(s=t)}else s=-1}if(e!==n&&s!==n)break}for(let e=0,s=t.length;e<s;e++){const s=t[e],n=this.m_sweepStructure.getElement(s);this.m_sweepStructure.deleteNode(s),this.setEdgeSweepNode_(n,-1)}t.length=0,this.m_prevNeighbour=e,this.m_nextNeighbour=s,-1!==e&&-1!==s?this.m_bContinuingSegmentChainOptimization||this.checkAndFixIntersection_(e,s):-1===e&&-1===s&&(this.m_bContinuingSegmentChainOptimization=!1)}else a&&(null===e&&(e=new Al(this)),e.setPoint(this.m_sweepPoint),this.m_sweepStructure.searchUpperBound(e),e.intersectionDetected()&&(e.clearIntersectionDetectedFlag(),this.fixIntersectionPointSegment_(this.m_sweepPointCluster,e.getCurrentNode())));const h=this.m_bContinuingSegmentChainOptimization;!this.insertNewEdges_()&&h&&-1!==this.m_prevNeighbour&&-1!==this.m_nextNeighbour&&this.checkAndFixIntersection_(this.m_prevNeighbour,this.m_nextNeighbour),this.m_bSweepPointClusterWasModified?(this.m_bSweepPointClusterWasModified=!1,null===s&&(s=new Gl(this.m_shape)),s.setPoint(this.m_sweepPoint),r=this.m_eventQ.searchUpperBound(s)):r=this.m_eventQ.getNext(r)}return this.m_bCracked}setEditShape_(t){this.m_shape=t,this.m_vertexClusterIndex=this.m_shape.createUserIndex(),this.m_edges.setCapacity(t.getSelectedCount()+32),this.m_clusters.setCapacity(t.getSelectedCount()),this.m_clusterVertices.reserveLists(t.getSelectedCount()),this.m_clusterVertices.reserveNodes(t.getSelectedCount()),this.m_edgeVertices.reserveLists(t.getSelectedCount()+32),this.m_edgeVertices.reserveNodes(t.getSelectedCount()+32);for(let e=this.m_shape.getFirstGeometry();e!==Ar;e=this.m_shape.getNextGeometry(e))if(Z(this.m_shape.getGeometryType(e)))for(let s=this.m_shape.getFirstPath(e);s!==Ar;s=this.m_shape.getNextPath(s)){const e=this.m_shape.getPathSize(s),n=this.m_shape.getFirstVertex(s);if(n===Ar)continue;let i=this.m_shape.getNextVertex(n);if(i===Ar||i===n)continue;let r=-1;t.selected(n)&&(r=this.newCluster_(n));let o=-1;-1!==r&&t.selected(i)&&(o=this.newEdge_(n),this.addEdgeToCluster(o,r));let a=o;for(let t=0,s=e-2;t<s;t++){const t=this.m_shape.getNextVertex(i);let e=-1;if(this.m_shape.selected(i)){const s=this.newCluster_(i);-1!==a&&this.addEdgeToCluster(a,s),this.m_shape.selected(t)&&(e=this.newEdge_(i),this.addEdgeToCluster(e,s))}a=e,i=t}if(this.m_shape.isClosedPath(s)){const t=this.m_shape.getNextVertex(i);if(this.m_shape.selected(i)){const e=this.newCluster_(i);if(-1!==a&&this.addEdgeToCluster(a,e),this.m_shape.selected(t)){const t=this.newEdge_(i);this.addEdgeToCluster(t,e),this.addEdgeToCluster(t,r)}}}else{let t=-1;this.m_shape.selected(i)&&(t=this.newCluster_(i),-1!==a&&this.addEdgeToCluster(a,t))}}else for(let t=this.m_shape.getFirstPath(e);t!==Ar;t=this.m_shape.getNextPath(t)){let e=this.m_shape.getFirstVertex(t);for(let s=0,n=this.m_shape.getPathSize(t);s<n;s++)this.m_shape.selected(e)&&this.newCluster_(e),e=this.m_shape.getNextVertex(e)}this.fillEventQueue()}progress_(t=!1){}dbgCheckSweepStructure_(){}}function Fl(t,e,s){return{vertex0:t,vertex1:e,dir:s}}class Vl{constructor(t){this.m_shape=null,this.m_spikes=[],this.m_points=new Fe(0),this.m_pointsIndex=-1,this.m_dissolvedEdges=0,this.m_progressTracker=t}executeImpl_(t,e){if(this.m_shape=t,t.getPathCount(e)<2&&t.getPointCount(e)<6)return;this.m_points.resize(0);for(let s=t.getFirstPath(e);s!==Ar;s=t.getNextPath(s)){let e=t.getFirstVertex(s);for(let n=0,i=t.getPathSize(s);n<i;n++,e=t.getNextVertex(e))this.m_points.add(e)}this.m_pointsIndex=t.createUserIndex();for(let e=0,s=this.m_points.size();e<s;++e)t.setUserIndex(this.m_points.read(e),this.m_pointsIndex,e);t.sortVerticesSimpleByY(this.m_points,0,this.m_points.size());let s=this.m_points.read(0);const i=t.getXY(s);let r=1,o=0;const a=[];for(let e=1;e<this.m_points.size();e++){const n=this.m_points.read(e);if(n===Ar)continue;if(-1===t.getUserIndex(n,this.m_pointsIndex))continue;const h=t.getXY(n);if(h.isEqualPoint2D(i))r++;else{if(r>1){for(let s=o;s<e;s++){const e=this.m_points.read(s);if(-1===t.getUserIndex(e,this.m_pointsIndex))continue;const n=t.getNextVertex(e),r=t.getPrevVertex(e);if(e!==n&&!t.isEqualXYPoint2D(n,i)){const t=Fl(e,n,1);a.push(t)}if(e!==r&&r!==n&&!t.isEqualXYPoint2D(r,i)){const t=Fl(e,r,-1);a.push(t)}}a.length>0&&this.processBunch_(a,i)}s=n,i.assign(h),r=1,o=e}}if(0===this.m_dissolvedEdges)return t.removeUserIndex(this.m_pointsIndex),void(this.m_pointsIndex=-1);let h=t.getPointCount(e);for(let e=0;e<this.m_points.size();e++){const s=this.m_points.read(e);if(s===Ar)continue;if(-1!==t.getUserIndex(s,this.m_pointsIndex)){t.setUserIndex(s,this.m_pointsIndex,-1);continue}const n=t.getPathFromVertex(s);t.getFirstVertex(n)===s&&t.setFirstVertex(n,Ar),t.freeVertex(s),this.m_points.write(e,Ar),h--}const m=t.createPathUserIndex();let l=t.getPathCount(e);for(let s=0,i=this.m_points.size();s<i;++s){if(this.m_points.read(s)===Ar)continue;let i=this.m_points.read(s);if(-1!==t.getUserIndex(i,this.m_pointsIndex))continue;let r=t.getPathFromVertex(i),o=-1;if(2===t.getPathUserIndex(r,m)){r=Ar;for(let e=t.getNextVertex(i);e!==i;e=t.getNextVertex(e)){const s=t.getPathFromVertex(e);if(2!==t.getPathUserIndex(s,m)){r=s,i=e;break}}r===Ar&&(r=t.insertPath(e,Ar),t.setClosedPath(r,!0),l++),n(r!==Ar)}t.setPathUserIndex(r,m,2),o=t.getFirstVertex(r);let a=0,h=!1,u=i;do{o===u&&(h=!0),t.setUserIndex(u,this.m_pointsIndex,1);const e=t.getPathFromVertex(u);e!==r&&(2!==t.getPathUserIndex(e,m)&&(t.setPathUserIndex(e,m,1),t.setFirstVertex(e,Ar)),t.setPathToVertex(u,r)),a++,u=t.getNextVertex(u)}while(u!==i);h||t.setFirstVertex(r,i),t.setPathSize(r,a)}for(let s=t.getFirstPath(e);s!==Ar;){const e=t.getNextPath(s);1!==t.getPathUserIndex(s,m)&&t.getFirstVertex(s)!==Ar||(t.removePathOnly(s),l--),s=e}t.setGeometryVertexCount(e,h),t.setGeometryPathCount(e,l),t.removePathUserIndex(m),t.removeUserIndex(this.m_pointsIndex),this.m_pointsIndex=-1,t.dbgVerifyVertexCounts(),t.filterClosePoints(0,!0,!1,!1,e)}processBunch_(t,e){t.sort((t,s)=>{const n=this.m_shape.getXY(t.vertex1).sub(e),i=this.m_shape.getXY(s.vertex1).sub(e),r=l.compareVectors(n,i);return 0===r?t.dir<s.dir?-1:1:r});let s=0;const n=this.m_shape.getXY(t[0].vertex1);let i=1;const r=this.m_shape.hasCurves();for(let e=1,o=t.length;e<o;e++){const a=this.m_shape.getXY(t[e].vertex1);if(!(a.isEqualPoint2D(n)&&(i++,e+1<o))){if(2===i){const e=t[s],n=t[s+1],i=e.dir;if(i!==n.dir){let t=!0;if(r&&(t=!this.m_shape.isCurve(1===e.dir?e.vertex0:e.vertex1)&&!this.m_shape.isCurve(1===n.dir?n.vertex0:n.vertex1)),t){if(1===i){const t=e.vertex0,s=n.vertex0;this.m_shape.setNextVertex(t,s),this.m_shape.setPrevVertex(s,t),this.m_shape.getPrevVertex(t)===s&&(this.m_shape.setUserIndex(t,this.m_pointsIndex,-1),this.m_shape.setUserIndex(s,this.m_pointsIndex,-1));const i=e.vertex1,r=n.vertex1;this.m_shape.setPrevVertex(i,r),this.m_shape.setNextVertex(r,i),this.m_shape.getNextVertex(i)===r&&(this.m_shape.setUserIndex(i,this.m_pointsIndex,-1),this.m_shape.setUserIndex(r,this.m_pointsIndex,-1))}else{const t=e.vertex0,s=n.vertex0;this.m_shape.setPrevVertex(t,s),this.m_shape.setNextVertex(s,t),this.m_shape.getNextVertex(t)===s&&(this.m_shape.setUserIndex(t,this.m_pointsIndex,-1),this.m_shape.setUserIndex(s,this.m_pointsIndex,-1));const i=e.vertex1,r=n.vertex1;this.m_shape.setNextVertex(i,r),this.m_shape.setPrevVertex(r,i),this.m_shape.getPrevVertex(i)===r&&(this.m_shape.setUserIndex(i,this.m_pointsIndex,-1),this.m_shape.setUserIndex(r,this.m_pointsIndex,-1))}this.m_dissolvedEdges+=2}}}n.assign(a),s=e,i=1}}t.length=0}}function Yl(t){for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e))if(Z(t.getGeometryType(e)))return!0;return!1}function Xl(t,e,s,n,i){if(!Yl(e))return!1;let r=new Rl(i);if(r.m_shape=e,r.m_tolerance=s,r.m_bAllowCoincident=t,r.m_bNeedsNonSimpleResult=null!==n,r.needsCrackingImpl_())return n&&n.assign(r.m_nonSimpleResult),!0;const o=new Ps;o.setSwapCoordinates(),e.applyTransformation(o),r=new Rl(i),r.m_shape=e,r.m_tolerance=s,r.m_bAllowCoincident=t,r.m_bNeedsNonSimpleResult=null!==n;const a=r.needsCrackingImpl_();return e.applyTransformation(o),!!a&&(n&&n.assign(r.m_nonSimpleResult),!0)}function kl(t,e){return{t,index:e}}class Rl{crackBruteForce_(){let t=this.crackBruteForceImpl_();if(!t&&this.m_shape.hasCurves()){const e=new Ps;e.setSwapCoordinates(),this.m_shape.applyTransformation(e),t=this.crackBruteForceImpl_(),this.m_shape.applyTransformation(e)}return t}crackBruteForceImpl_(){let e=!1;const s=new fm,i=new fm,r=t.constructEmpty(),o=t.constructEmpty(),a=!1,h=new qe,m=new El,l=this.m_shape.getTotalPointCount(),u=l*l*2,c=this.m_shape.queryVertexIteratorOnSelection();for(let t=c.next();t!==Ar;t=c.next()){const l=this.m_shape.getGeometryType(c.currentGeometry());let g=1,d=1,_=1,p=0,f=0,x=0;const y=this.m_shape.getSegmentParentage(t);let P=!1,C=!1,E=null,S=!1;if(V(l))g=this.m_shape.getWeight(t),p=this.m_shape.getRank(t);else{if(E=this.getSegment_(t,s),null===E)continue;const e=this.m_shape.getVertexIndex(t);g=this.m_shape.getWeightWithIndex(e),p=this.m_shape.getRankWithIndex(e),_=this.m_shape.getSegmentWeightWithIndex(e),x=this.m_shape.getSegmentRankWithIndex(e),P=this.m_shape.getSegmentParentageBreakVertex(t);{const e=this.m_shape.getNextVertex(t);d=this.m_shape.getWeight(e),f=this.m_shape.getRank(e),C=this.m_shape.getSegmentParentageBreakVertex(e)}if(E.queryLooseEnvelope(r),r.inflateCoords(this.m_tolerance,this.m_tolerance),E.isDegenerate(this.m_tolerance)){if(!E.isDegenerate(0))continue;S=!0,E=null}}const v=new qr({copy:c});let I=v.next();I!==Ar&&(I=v.next());let b=0;for(;I!==Ar;I=v.next()){if(0!==b){b--;continue}if(this.m_shape.getTotalPointCount()>u)return e;this.progress_();const l=this.m_shape.getGeometryType(v.currentGeometry());let w=null,D=!1,T=0,N=0,A=0,M=0,G=0,q=0,F=!1,Y=!1;const X=this.m_shape.getSegmentParentage(I);if(V(l))T=this.m_shape.getWeight(I),M=this.m_shape.getRank(I);else{if(w=this.getSegment_(I,i),null===w)continue;const t=this.m_shape.getVertexIndex(I);T=this.m_shape.getWeightWithIndex(t),M=this.m_shape.getRankWithIndex(t),A=this.m_shape.getSegmentWeightWithIndex(t),q=this.m_shape.getSegmentRankWithIndex(t),F=this.m_shape.getSegmentParentageBreakVertex(I);{const t=this.m_shape.getNextVertex(I);N=this.m_shape.getWeight(t),G=this.m_shape.getRank(t),Y=this.m_shape.getSegmentParentageBreakVertex(t)}if(w.queryLooseEnvelope(o),w.isDegenerate(this.m_tolerance)){if(!w.isDegenerate(0))continue;D=!0,w=null}}let k=0,R=0;if(null!==E&&null!==w)r.isIntersectingNe(o)&&0!==am(!0,!0,E,w,this.m_tolerance,!0)&&(m.pushSegment(E,g,p,d,f,_,x,P,C,y),m.pushSegment(w,T,M,N,G,A,q,F,Y,X),m.intersect2D(this.m_tolerance,!0),e||=m.getSegmentChanged(0)||m.getSegmentChanged(1),k=m.getResultSegmentCount(0),R=m.getResultSegmentCount(1),k+R>0&&(this.m_shape.splitSegmentWithIntersector(t,m,0,!0,!0),this.m_shape.splitSegmentWithIntersector(I,m,1,!0,!0),this.m_bTrackChanges&&(m.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(t,!0),m.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(I,!0))),R>1&&(b+=R-1),m.clear());else if(null!==E){const s=this.m_shape.getXY(I);if(r.contains(s)){if(m.pushSegment(E,g,p,d,f,_,x,P,C,y),this.m_shape.queryPoint(I,h),m.intersect2DEx(this.m_tolerance,h,M,T,a),e||=m.getSegmentChanged(0)||m.getResultPointChanged(),k=m.getResultSegmentCount(0),k>0)if(this.m_bTrackChanges&&(m.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(t,!0),m.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(I,!0)),this.m_shape.splitSegmentWithIntersector(t,m,0,!0,!0),D){let t=Ar;for(let e=this.m_shape.getNextVertex(I);e!==Ar&&e!==I&&(w=this.getSegment_(e,i),t=e,null!=w&&w.isDegenerate(0));e=this.m_shape.getNextVertex(e));for(let e=I;e!==Ar&&(this.m_shape.setPoint(e,m.getResultPoint(),!0),e!==t);e=this.m_shape.getNextVertex(e));}else this.m_shape.setPoint(I,m.getResultPoint(),!0);m.clear()}}else{if(null===w)continue;{const s=this.m_shape.getXY(t);if(o.inflateCoords(this.m_tolerance,this.m_tolerance),o.contains(s)){if(m.pushSegment(w,T,M,N,G,A,q,F,Y,X),this.m_shape.queryPoint(t,h),m.intersect2DEx(this.m_tolerance,h,p,g,a),e||=m.getSegmentChanged(0)||m.getResultPointChanged(),R=m.getResultSegmentCount(0),R>0)if(this.m_bTrackChanges&&(m.getSegmentChanged(0)&&this.m_shape.setGeometryModifiedWithVertex(I,!0),m.getSegmentChanged(1)&&this.m_shape.setGeometryModifiedWithVertex(t,!0)),this.m_shape.splitSegmentWithIntersector(I,m,0,!0,!0),b+=R-1,S){let e=Ar;for(let s=this.m_shape.getNextVertex(t);s!==Ar&&s!==t&&(w=this.getSegment_(s,i),e=s,null!=w&&w.isDegenerate(0));s=this.m_shape.getNextVertex(s));for(let s=t;s!==Ar&&(this.m_shape.setPoint(s,m.getResultPoint(),!0),s!==e);s=this.m_shape.getNextVertex(s));}else this.m_shape.setPoint(t,m.getResultPoint(),!0);m.clear()}}}if(k+R!==0&&0!==k){let e=!1;for(;E=this.getSegment_(t,s),null!=E&&(E.queryEnvelope(r),E.isDegenerate(this.m_tolerance));){if(!(k>1)){e=!0;break}t=c.next(),k--,n(t!==Ar)}if(e)break}}}return e}crackerPlaneSweep_(){return this.planesweep_()}planesweep_(){return new ql(this.m_progressTracker,this.m_bTrackChanges).sweep(this.m_shape,this.m_tolerance)}needsCrackingImpl_(){let t=!1;const e=new Fe(0);e.resize(this.m_shape.getSelectedCount());const s=this.m_shape.queryVertexIteratorOnSelection();for(let t=0,n=s.next();n!==Ar;++t,n=s.next())e.write(t,n);this.m_shape.sortVerticesSimpleByY(e,0,e.size()),e.add(Ar);const n=this.m_shape.createUserIndex(),i=this.m_shape.createUserIndex();this.m_sweepComparator=new gl(this.m_shape,this.m_tolerance,!this.m_bAllowCoincident),this.m_sweepStructure.setComparator(this.m_sweepComparator);let r=null;const o=[],a=[];let h=0;const m=new l;for(let s=e.read(h++);s!==Ar;){this.m_shape.queryXY(s,m);let l=!1;do{let t=this.m_shape.getNextVertex(s),r=this.m_shape.getPrevVertex(s);l||=t!==Ar||r!==Ar,t===Ar||this.m_shape.selected(t)||(t=Ar),r===Ar||this.m_shape.selected(r)||(r=Ar),t!==Ar&&this.m_shape.compareVerticesSimpleY(s,t)<0&&(a.push(s),a.push(t)),r!==Ar&&this.m_shape.compareVerticesSimpleY(s,r)<0&&(a.push(r),a.push(r));const m=this.m_shape.getUserIndex(s,n);-1!==m&&(o.push(m),this.m_shape.setUserIndex(s,n,-1));const u=this.m_shape.getUserIndex(s,i);-1!==u&&(o.push(u),this.m_shape.setUserIndex(s,i,-1)),s=e.read(h++)}while(s!==Ar&&this.m_shape.isEqualXYPoint2D(s,m));if(!l&&(null===r&&(r=new dl(this.m_shape,this.m_tolerance)),r.setPoint(m),this.m_sweepStructure.searchUpperBound(r),r.intersectionDetected())){t=!0,this.m_bNeedsNonSimpleResult&&(P("needsCrackingIMpl_"),this.m_nonSimpleResult=new Is(6,-1,-1));break}let u=1===o.length&&2===a.length;const c=32;o.length>c&&lt(o);let g=-1,d=-1;if(!u)for(let e=0,s=o.length;e<s;e++){const s=o[e],n=this.m_sweepStructure.getPrev(s);if(-1!==n&&-1===o.indexOf(n))if(-1===g)g=n;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new Is(6,-1,-1)}const i=this.m_sweepStructure.getNext(s);if(-1!==i&&-1===o.indexOf(i))if(-1===d)d=i;else{if(t=!0,!this.m_bNeedsNonSimpleResult)break;this.m_nonSimpleResult=new Is(6,-1,-1)}if(-1!==g&&-1!==d)break}if(t&&!this.m_bNeedsNonSimpleResult)break;if(this.m_sweepComparator.setSweepY(m.y,m.x),!u){for(let t=0,e=o.length;t<e;t++){const e=o[t];this.m_sweepStructure.deleteNode(e)}o.length=0}if(!u&&-1!==g&&-1!==d&&this.checkForIntersections_(g,d)){t=!0,this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult());break}for(let e=0,s=a.length;e<s;e+=2){const s=a[e],r=a[e+1];let h;if(u?(h=this.m_sweepStructure.replaceElementAtPosition(o[0],s,!0,!0),o.length=0,u=!1):h=this.m_sweepStructure.addElement(s),this.m_sweepComparator.intersectionDetected()){this.m_bNeedsNonSimpleResult&&(this.m_nonSimpleResult=this.m_sweepComparator.getResult()),t=!0;break}-1===this.m_shape.getUserIndex(r,n)?this.m_shape.setUserIndex(r,n,h):this.m_shape.setUserIndex(r,i,h)}if(t)break;a.length=0}return this.m_shape.removeUserIndex(n),this.m_shape.removeUserIndex(i),t}checkForIntersections_(t,e){const s=this.m_sweepStructure.getElement(t);this.m_sweepComparator.compare(this.m_sweepStructure,s,e);const n=this.m_sweepComparator.intersectionDetected();return this.m_sweepComparator.clearIntersectionDetectedFlag(),n}getSegment_(t,e){return Rl.st_getSegment(this.m_shape,t,e)}static st_getSegment(t,e,s){return t.querySegment(e,s,!1,!1)?s.get():null}dbgPrintSweepEdge(t){}dbgPrintSweepStructure(){}dbgSaveSweepStructure(t=null){}dbgCheckSweepStructure(){}progress_(t=!1){this.m_progressCounter++}crackAWithBMultiPath_(e,s,i){const r=t.constructEmpty();e.queryLooseEnvelope(r);const a=t.constructEmpty();if(s.queryLooseEnvelope(a),a.inflateCoords(i,i),!a.isIntersecting(r))return e;const m=e.getImpl(),l=m.getAccelerators();let u=null,c=null;l&&(c=l.getQuadTree()),function(t,e){const s=t.getPointCount();return!(s<16)&&2*s+Math.log(s)/Math.log(2)*1*e<1*s*e}(e,Qt(s))&&(u=Le(m,a),c=u);const g=c?c.getIteratorForQT():null,d=s.querySegmentIterator(),_=e.querySegmentIterator(),p=h(15,Number.NaN),f=[];for(;d.nextPath();)for(;d.hasNextSegment();){const e=d.nextSegment();if(c){g.resetIterator(e,i);for(let t=g.next();-1!==t;t=g.next()){this.progress_();const s=c.getElement(t);if(_.resetToVertex(s,-1),_.hasNextSegment()){const t=_.nextSegment().intersect(e,null,p,null,i);for(let e=0;e<t;e++){const t=p[e];if(0===t||1===t)continue;const s=kl(t,_.getStartPointIndex());f.push(s)}}}}else{const s=t.constructEmpty();if(e.queryLooseEnvelope(s),s.inflateCoords(i,i),!r.isIntersecting(s))continue;for(_.resetToFirstPath();_.nextPath();)for(;_.hasNextSegment();){const n=_.nextSegment(),r=t.constructEmpty();if(n.queryLooseEnvelope(r),!r.isIntersecting(s))continue;const o=n.intersect(e,null,p,null,i);for(let t=0;t<o;t++){const e=p[t];if(0===e||1===e)continue;const s=kl(e,_.getStartPointIndex());f.push(s)}}}}if(0===f.length)return e;f.sort((t,e)=>t.index<e.index?-1:t.index>e.index?1:t.t<e.t?-1:t.t>e.t?1:0);const x=e.createInstance();for(x.getGeometryType()===o.enumPolygon&&x.setFillRule(e.getFillRule()),_.resetToFirstPath();_.nextPath()&&!_.hasNextSegment(););n(_.hasNextSegment());let y=_.nextSegment();const P=new fm;let C=-1;for(let t=0,e=f.length;t<e;){const s=f[t].index;let i=t+1;for(;i<e&&f[i].index===s;)++i;for(;_.getStartPointIndex()<s;){this.progress_();const t=_.hasNextSegment(),e=_.getPathIndex();if((t||!_.isClosingSegment()||_.isCurve())&&(n(null!==y),x.addSegment(y,C!==e)),C=e,!t){for(_.isPathClosed();_.nextPath()&&!_.hasNextSegment(););n(_.hasNextSegment())}y=_.nextSegment()}let r=0;for(let e=t;e<i;e++){const t=f[e].t;if(t===r)continue;n(null!==y),y.queryCut(r,t,P),r=t;const s=_.getPathIndex();x.addSegment(P.get(),C!==s),C=s}const o=_.hasNextSegment();if((o||!_.isClosingSegment()||_.isCurve())&&(n(null!=y),y.queryCut(r,1,P),x.addSegment(P.get(),!1)),o)y=_.nextSegment();else{for(;_.nextPath()&&!_.hasNextSegment(););y=_.hasNextSegment()?_.nextSegment():null}t=i}if(null!==y){const t=_.getPathIndex();(_.hasNextSegment()||!_.isClosingSegment()||_.isCurve())&&x.addSegment(y,C!==t),C=t}let E=_.hasNextSegment();for(;;){if(!E){for(;_.nextPath()&&(E=_.hasNextSegment(),!E););if(!E)break}y=_.nextSegment();const t=_.getPathIndex();E=_.hasNextSegment(),(E||!_.isClosingSegment()||_.isCurve())&&x.addSegment(y,C!==t),C=t}return x}constructor(t){this.m_shape=null,this.m_progressTracker=null,this.m_nonSimpleResult=new Is,this.m_tolerance=0,this.m_sweepComparator=null,this.m_progressCounter=0,this.m_bTrackChanges=!1,this.m_bNeedsNonSimpleResult=!1,this.m_bAllowCoincident=!0,this.m_sweepStructure=new ze,this.m_progressTracker=t}}Rl.s_bForceBruteForce=!0;class Ll{constructor(t,e){this.m_monotoneParts=T(fm,16),this.m_xOrds=h(16,Number.NaN),this.m_inputPoint=l.getNAN(),this.m_miny=0,this.m_maxy=0,this.m_windnum=0,this.m_bAlternate=t,this.m_tolerance=e,this.m_toleranceSqr=e*e,this.m_bTestBorder=!!e,this.m_bBreak=!1}_DoOne(t){if(!this.m_bTestBorder&&(this.m_bAlternate&&this.m_inputPoint.equals(t.getStartXY())||this.m_inputPoint.equals(t.getEndXY())))return void(this.m_bBreak=!0);if(t.getStartY()===this.m_inputPoint.y&&t.getStartY()===t.getEndY()){if(this.m_bAlternate&&!this.m_bTestBorder){const e=Math.min(t.getStartX(),t.getEndX()),s=Math.max(t.getStartX(),t.getEndX());this.m_inputPoint.x>e&&this.m_inputPoint.x<s&&(this.m_bBreak=!0)}return}let e=!1;const s=Math.max(t.getStartX(),t.getEndX());if(this.m_inputPoint.x>s)e=!0;else if(this.m_inputPoint.x>=Math.min(t.getStartX(),t.getEndX())){const n=t.intersectionOfYMonotonicWithAxisX(this.m_inputPoint.y,s);e=!Number.isNaN(n)&&n<=this.m_inputPoint.x}if(e){if(this.m_inputPoint.y===t.getStartY()){if(this.m_inputPoint.y<t.getEndY())return}else if(this.m_inputPoint.y===t.getEndY()&&this.m_inputPoint.y<t.getStartY())return;this.m_bAlternate?this.m_windnum^=1:this.m_windnum+=t.getStartY()>t.getEndY()?1:-1}}_Result(){return!!this.m_windnum}testBorder(t){const e=t.getClosestCoordinate(this.m_inputPoint,!1),s=t.getCoord2D(e);return l.sqrDistance(s,this.m_inputPoint)<=this.m_toleranceSqr}setInputPoint(t){this.m_inputPoint.setCoordsPoint2D(t),this.m_miny=t.y-this.m_tolerance,this.m_maxy=t.y+this.m_tolerance}processSegment(t){const e=t.queryInterval(0,1);if(e.vmin>this.m_maxy||e.vmax<this.m_miny)return!1;if(this.m_bTestBorder&&this.testBorder(t))return!0;if(e.vmin>this.m_inputPoint.y||e.vmax<this.m_inputPoint.y)return!1;let s=0;if(t.isCurve()&&(0===this.m_monotoneParts.length&&(this.m_monotoneParts.length=128),s=t.getMonotonicParts(this.m_monotoneParts,!0),n(this.m_monotoneParts.length>=s)),s>0)for(let t=0;t<s;t++){const e=this.m_monotoneParts[t].get(),s=r.construct(e.getStartY(),e.getEndY());if(!(s.vmin>this.m_inputPoint.y||s.vmax<this.m_inputPoint.y)&&(this._DoOne(e),this.m_bBreak))return!0}else if(this._DoOne(t),this.m_bBreak)return!0;return!1}result(){return n(0),2}}function Hl(e,s,i){if(e.isEmpty())return 0;const r=t.constructEmpty();if(e.queryLooseEnvelope(r),r.inflateCoords(i,i),!r.contains(s))return 0;const o=e.getImpl().getAccelerators();if(o){o.getRasterizedGeometry()&&n(0);const r=o.getQuadTree();if(r)return function(e,s,n,i){const r=new t;e.queryLooseEnvelope(r),r.inflateCoords(i,i);const o=0===e.getFillRule(),a=new Ll(o,i);a.setInputPoint(n);const h=r.clone();h.xmax=n.x+i,h.ymin=n.y-i,h.ymax=n.y+i;const m=e.getImpl().querySegmentIterator(),l=s.getIterator(h,i);for(let t=l.next();-1!==t;t=l.next())if(m.resetToVertex(s.getElement(t),-1),m.hasNextSegment()){const t=m.nextSegment();if(a.processSegment(t))return-1}return a._Result()?1:0}(e,r,s,i)}return function(t,e,s){const n=0===t.getFillRule(),i=new Ll(n,s);i.setInputPoint(e);const r=t.getImpl().querySegmentIterator();for(;r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment();if(i.processSegment(t))return-1}return i._Result()?1:0}(e,s,i)}function Bl(t,e){const s=t.getPointCount();return!(s<16)&&2*s+Math.log(s)/Math.log(2)*1*e<1*s*e}function Ul(t,e,s){const n=new jl(s);return n.m_shape=t,n.m_geometry=e,n.m_sortedVertices=null,n.m_bFixSelfTangency=!1,n.fixRingOrientationForMp2sp_()}class zl{getDirection_(t){return this.m_shape.getNextVertex(this.getEnd1(t))===this.getEnd2(t)}getEnd_(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?s:e}constructor(t){this.m_end1Nodes=[],this.m_end2Nodes=[],this.m_directions=[],this.m_shape=t,this.m_firstFree=-1}getSegment(t){return this.m_shape.getSegment(this.getStart(t))}isBottomUp(t){let e=this.getEnd1(t),s=this.getEnd2(t);this.m_shape.getPrevVertex(e)===s&&(s=p(e,e=s));const i=l.getNAN(),r=l.getNAN();return this.m_shape.queryXY(e,i),this.m_shape.queryXY(s,r),n(!i.equals(r)),i.y<r.y}getStart(t){const e=this.getEnd1(t),s=this.getEnd2(t);return this.m_shape.getNextVertex(e)===s?e:s}getEnd1(t){return this.m_end1Nodes[t]}getEnd2(t){return this.m_end2Nodes[t]}freeEdge(t){this.m_end1Nodes[t]=this.m_firstFree,this.m_firstFree=t}newEdge(t){if(-1!==this.m_firstFree){const e=this.m_firstFree;return this.m_firstFree=this.m_end1Nodes[e],this.m_end1Nodes[e]=t,this.m_end2Nodes[e]=this.m_shape.getNextVertex(t),e}const e=this.m_end1Nodes.length;return this.m_end1Nodes.push(t),this.m_end2Nodes.push(this.m_shape.getNextVertex(t)),e}getShape(){return this.m_shape}getPath(t){return this.m_shape.getPathFromVertex(this.getEnd1(t))}}let Ol=class extends hs{constructor(t){super(),this.m_line1=new pm,this.m_line2=new pm,this.m_leftElm=-1,this.m_leftx=0,this.m_seg1=null,this.m_helper=t}compare(t,e,s){const n=t.getElement(s),i=this.m_helper.m_edges;let r;this.m_leftElm===e?r=this.m_leftx:(this.m_seg1=i.getSegment(e),this.m_seg1?r=this.m_seg1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(i.getShape().queryLineConnector(i.getStart(e),this.m_line1,!0),this.m_seg1=this.m_line1,r=this.m_line1.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),this.m_leftx=r,this.m_leftElm=e);let o,a=i.getSegment(n);if(a?o=a.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0):(i.getShape().queryLineConnector(i.getStart(n),this.m_line2,!0),a=this.m_line2,o=this.m_line2.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0)),r===o){const t=i.isBottomUp(e),s=i.isBottomUp(n),h=t?this.m_seg1.getEndY():this.m_seg1.getStartY(),m=s?a.getEndY():a.getStartY(),l=Math.min(h,m);let u=.5*(l+this.m_helper.m_yScanline);u===this.m_helper.m_yScanline&&(u=l),r=this.m_seg1.intersectionOfYMonotonicWithAxisX(u,0),o=a.intersectionOfYMonotonicWithAxisX(u,0),r===o&&N("")}return r<o?-1:r>o?1:0}reset(){this.m_leftElm=-1}};class Wl{constructor(t){this.m_node=-1,this.m_index=0,this.m_sortedVertices=t.m_sortedVertices,this.m_sortedVerticesArray=t.m_sortedVerticesArray,this.m_sortedVertices&&(this.m_node=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList()))}next(){if(this.m_sortedVertices){const t=this.m_node;if(-1===t)return Ar;const e=this.m_sortedVertices.getData(t);return this.m_node=this.m_sortedVertices.getNext(t),e}if(this.m_index<this.m_sortedVerticesArray.size()){const t=this.m_sortedVerticesArray.read(this.m_index);return this.m_index++,t}return Ar}}class jl{constructor(t){this.m_edges=null,this.m_shape=null,this.m_AET=new ze,this.m_yScanline=0,this.m_geometry=Ar,this.m_unknownRingOrientationCount=-1,this.m_sortedVertices=null,this.m_sortedVerticesArray=null,this.m_unknownNodes=[],this.m_node1UserIndex=-1,this.m_node2UserIndex=-1,this.m_pathOrientationIndex=-1,this.m_pathParentageIndex=-1,this.m_pathParentsIndex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_progressTracker=t,this.m_AET.disableBalancing(),this.m_sweepComparator=new Ol(this),this.m_AET.setComparator(this.m_sweepComparator)}fixRingOrientation_(){const t=this.fixRingOrientationImplMain_();return-1===this.m_pathOrientationIndex||this.fixRingOrientationImplSimplify_(),t}fixRingOrientationForMp2sp_(){return this.fixRingOrientationImplMain_(),-1===this.m_pathOrientationIndex?-1:this.fixRingOrientationImplMp2sp_()}processBunchForRingOrientationTest_(t){return this.processBunchForRingOrientationTestOddEven_(t)}processBunchForRingOrientationTestOddEven_(t){let e=!1;if(this.m_edges||(this.m_edges=new zl(this.m_shape)),this.m_unknownNodes.length=0,this.processBunchForRingOrientationRemoveEdges_(t),!this.m_AET.isAutoBalancing()){let e=0;for(let s=0,n=t.length;s<n;s++)-1!==t[s]&&e++;(e>10||this.m_AET.getMaxDepthEver()>4)&&this.m_AET.enableBalancing()}for(let e=0,s=t.length;e<s;e++){const s=t[e];s!==Ar&&this.insertEdge_(s,-1)}for(let t=0;t<this.m_unknownNodes.length&&this.m_unknownRingOrientationCount>0;t++){const s=this.m_unknownNodes[t],i=this.m_AET.getElement(s),r=this.m_edges.getPath(i),o=this.m_shape.getPathUserIndex(r,this.m_pathOrientationIndex);let a=Ar;if(0===o){let t=this.m_AET.getPrev(s),i=s,r=!1;for(;t!==ze.st_nullNode();){const e=this.m_AET.getElement(t),s=this.m_edges.getPath(e);if(0!==this.m_shape.getPathUserIndex(s,this.m_pathOrientationIndex)){a=s;break}i=t,t=this.m_AET.getPrev(t)}if(t===ze.st_nullNode())r=!0,t=i;else{const e=this.m_AET.getElement(t);r=this.m_edges.isBottomUp(e),t=this.m_AET.getNext(t),r=!r}do{const s=this.m_AET.getElement(t),o=this.m_edges.getPath(s);if(0===this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex)){if(r!==this.m_edges.isBottomUp(s)){const t=this.m_shape.getFirstVertex(o);this.m_shape.reverseRingInternal(t),this.m_shape.setLastVertex(o,this.m_shape.getPrevVertex(t)),e=!0}if(this.m_shape.setPathUserIndex(o,this.m_pathOrientationIndex,r?3:2),!r){let t=this.m_shape.getPathUserIndex(a,this.m_pathOrientationIndex);2===t?(a=this.m_shape.getPathUserIndex(a,this.m_pathParentsIndex),t=this.m_shape.getPathUserIndex(a,this.m_pathOrientationIndex),n(3===t)):n(3===t);const e=this.m_shape.getPathUserIndex(a,this.m_pathParentageIndex);this.m_shape.setPathUserIndex(a,this.m_pathParentageIndex,o),this.m_shape.setPathUserIndex(o,this.m_pathParentageIndex,e),this.m_shape.setPathUserIndex(o,this.m_pathParentsIndex,a)}if(this.m_unknownRingOrientationCount--,!this.m_unknownRingOrientationCount)return e}a=o,i=t,t=this.m_AET.getNext(t),r=!r}while(i!==s)}}return e}processBunchForRingOrientationRemoveEdges_(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],n=this.m_shape.getUserIndex(s,this.m_node1UserIndex),i=this.m_shape.getUserIndex(s,this.m_node2UserIndex);if(-1!==n){const t=this.m_AET.getElement(n);this.m_edges.freeEdge(t),this.m_shape.setUserIndex(s,this.m_node1UserIndex,-1)}if(-1!==i){const t=this.m_AET.getElement(i);this.m_edges.freeEdge(t),this.m_shape.setUserIndex(s,this.m_node2UserIndex,-1)}let r=-1;-1!==n&&-1!==i?(this.m_AET.deleteNode(n),this.m_AET.deleteNode(i),t[e]=Ar):r=-1!==n?n:i,-1!==r&&(this.insertEdge_(s,r)||this.m_AET.deleteNode(r),t[e]=Ar)}}dbgVerifyRingOrientation_(){}insertEdge_(t,e){const s=l.getNAN(),n=l.getNAN();this.m_shape.queryXY(t,s);const i=this.m_shape.getNextVertex(t);this.m_shape.queryXY(i,n);let r=!1;if(s.y<n.y){r=!0;const s=this.m_edges.newEdge(t);let n;-1===e?n=this.m_AET.addElement(s):(n=e,this.m_AET.setElement(n,s)),-1===this.m_shape.getUserIndex(i,this.m_node1UserIndex)?this.m_shape.setUserIndex(i,this.m_node1UserIndex,n):this.m_shape.setUserIndex(i,this.m_node2UserIndex,n);const o=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(o,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(n)}const o=this.m_shape.getPrevVertex(t);if(this.m_shape.queryXY(o,n),s.y<n.y){r=!0;const s=this.m_edges.newEdge(o);let n;-1===e?n=this.m_AET.addElement(s):(n=e,this.m_AET.setElement(n,s)),-1===this.m_shape.getUserIndex(o,this.m_node1UserIndex)?this.m_shape.setUserIndex(o,this.m_node1UserIndex,n):this.m_shape.setUserIndex(o,this.m_node2UserIndex,n);const i=this.m_shape.getPathFromVertex(t);0===this.m_shape.getPathUserIndex(i,this.m_pathOrientationIndex)&&this.m_unknownNodes.push(n)}return r}fixRingSelfTangency_(){const t=[],e=[];let s=-1,i=-1;const r=new l;let o=Ar,a=Ar,h=-1;const m=new Wl(this);for(let n=m.next();n!==Ar;n=m.next()){const m=new l;this.m_shape.queryXY(n,m);const u=this.m_shape.getPathFromVertex(n);r.equals(m)&&a===u?(-1===i&&(s=this.m_shape.createPathUserIndex(),this.m_shape.fillPathUserIndexForGeometry(this.m_geometry,s,-1),i=this.m_shape.createUserIndex(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,i,-1)),-1===h&&(h=e.length,this.m_shape.setUserIndex(o,i,h),e.push(1),-1===this.m_shape.getPathUserIndex(u,s)&&(this.m_shape.setPathUserIndex(u,s,o),t.push(u))),this.m_shape.setUserIndex(n,i,h),e[e.length-1]++):(h=-1,r.assign(m)),o=n,a=u}if(0===t.length)return!1;n(-1!==s);for(let n=0,r=t.length;n<r;n++){const r=t[n];let o=this.m_shape.getPathUserIndex(r,s);const a=this.m_shape.getUserIndex(o,i),h=[],m=[];h.push(o),m.push(a);for(let t=this.m_shape.getNextVertex(o);t!==o;t=this.m_shape.getNextVertex(t)){const s=t,n=this.m_shape.getUserIndex(s,i);if(-1!==n){if(0===m.length){m.push(n),h.push(s);continue}if(m.at(-1)===n){const r=h.at(-1);this.m_shape.peelALoopIntoAPath(r,s),this.m_shape.setUserIndex(t,i,-1),e[n]--,1===e[n]&&(e[n]=0,m.pop(),h.pop()),o=r,t=r}else h.push(t),m.push(n)}}}return this.m_shape.removePathUserIndex(s),this.m_shape.removeUserIndex(i),this.m_shape.dbgVerifyVertexCounts(),!0}progress_(t=!1){}fixRingOrientationImplMain_(){const t={stack:[],error:void 0,hasError:!1};try{let e,s=!1;const n=Ss(t,ae(()=>{this.m_sortedVerticesArray=null}),!1);if(null===this.m_sortedVertices){const t=this.m_shape.getPointCount(this.m_geometry);e=new Fe(0);for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==Ar;t=this.m_shape.getNextPath(t)){let s=this.m_shape.getFirstVertex(t);for(let n=0,i=this.m_shape.getPathSize(t);n<i;n++)e.add(s),s=this.m_shape.getNextVertex(s)}this.m_shape.sortVerticesSimpleByY(e,0,t),this.progress_(!0),this.m_sortedVerticesArray=e}else n.bForget=!0;if(this.m_bFixSelfTangency&&(s=this.fixRingSelfTangency_()),1===this.m_shape.getPathCount(this.m_geometry)){const t=this.m_shape.getFirstPath(this.m_geometry),e=this.m_shape.getRingArea(t);if(this.m_shape.setExterior(t,!0),e<0){const e=this.m_shape.getFirstVertex(t);return this.m_shape.reverseRingInternal(e),this.m_shape.setLastVertex(t,this.m_shape.getPrevVertex(e)),!0}return!1}this.m_shape.dbgVerifyCurves(),this.m_pathOrientationIndex=this.m_shape.createPathUserIndex(),this.m_pathParentageIndex=this.m_shape.createPathUserIndex(),this.m_pathParentsIndex=this.m_shape.createPathUserIndex();for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==Ar;t=this.m_shape.getNextPath(t))this.m_shape.setPathUserIndex(t,this.m_pathOrientationIndex,0),this.m_shape.setPathUserIndex(t,this.m_pathParentageIndex,-1),this.m_shape.setPathUserIndex(t,this.m_pathParentsIndex,-1);const i=[];this.m_yScanline=Number.NaN;const r=l.getNAN();this.m_unknownRingOrientationCount=this.m_shape.getPathCount(this.m_geometry),this.m_node1UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node1UserIndex,-1),this.m_node2UserIndex=this.m_shape.createUserIndexUninitialized(),this.m_shape.fillUserIndexForGeometry(this.m_geometry,this.m_node2UserIndex,-1);const o=new Wl(this);for(let t=o.next();t!==Ar&&(this.progress_(),this.m_shape.queryXY(t,r),r.y!==this.m_yScanline&&i.length&&(s=this.processBunchForRingOrientationTest_(i)||s,this.m_sweepComparator.reset(),i.length=0),i.push(t),this.m_yScanline=r.y,0!==this.m_unknownRingOrientationCount);t=o.next());return this.m_unknownRingOrientationCount>0&&(s=this.processBunchForRingOrientationTest_(i)||s,i.length=0),this.m_shape.removeUserIndex(this.m_node1UserIndex),this.m_shape.removeUserIndex(this.m_node2UserIndex),this.dbgVerifyRingOrientation_(),s}catch(e){t.error=e,t.hasError=!0}finally{vs(t)}}fixRingOrientationImplSimplify_(){const t=[];for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Ar;)if(this.progress_(),3===this.m_shape.getPathUserIndex(e,this.m_pathOrientationIndex)){this.m_shape.setExterior(e,!0);for(let s=this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex);s!==Ar;){const n=this.m_shape.getPathUserIndex(s,this.m_pathParentageIndex);t.push(s),this.m_shape.setExterior(s,!1),this.m_shape.setPathUserIndex(s,this.m_pathParentageIndex,e),s=n}let s=e,n=t.length;for(let t=this.m_shape.getNextPath(e);n>0&&t!==Ar;t=this.m_shape.getNextPath(t),--n){if(this.m_shape.getPathUserIndex(t,this.m_pathParentageIndex)!==e){s=Ar;break}s=t}if(0!==n){s=e;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.m_shape.setPathUserIndex(n,this.m_pathParentageIndex,gs),this.m_shape.movePath(this.m_geometry,this.m_shape.getNextPath(s),n),s=n}}t.length=0,e=this.m_shape.getNextPath(s)}else e=this.m_shape.getNextPath(e);this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex)}fixRingOrientationImplMp2sp_(){const t=this.m_shape.createPathUserIndex();let e=0;const s=[];for(let n=this.m_shape.getFirstPath(this.m_geometry);n!==Ar;)if(this.progress_(),3===this.m_shape.getPathUserIndex(n,this.m_pathOrientationIndex)){this.m_shape.setExterior(n,!0),this.m_shape.setPathUserIndex(n,t,e),e++;for(let t=this.m_shape.getPathUserIndex(n,this.m_pathParentageIndex);t!==Ar;){const e=this.m_shape.getPathUserIndex(t,this.m_pathParentageIndex);s.push(t),this.m_shape.setExterior(t,!1),this.m_shape.setPathUserIndex(t,this.m_pathParentageIndex,n),t=e}let i=n,r=s.length,o=e;for(let e=this.m_shape.getNextPath(n);r>0&&e!==Ar;e=this.m_shape.getNextPath(e),--r){if(this.m_shape.getPathUserIndex(e,this.m_pathParentageIndex)!==n){i=Ar;break}i=e,this.m_shape.setPathUserIndex(e,t,-o),o++}if(0!==r){i=n,o=e;for(let e=0,n=s.length;e<n;e++){const n=s[e];this.m_shape.setPathUserIndex(n,t,-o),o++,this.m_shape.setPathUserIndex(n,this.m_pathParentageIndex,gs)}i=n}e=o,s.length=0,n=this.m_shape.getNextPath(i)}else n=this.m_shape.getNextPath(n);return this.m_shape.removePathUserIndex(this.m_pathOrientationIndex),this.m_shape.removePathUserIndex(this.m_pathParentageIndex),this.m_shape.removePathUserIndex(this.m_pathParentsIndex),t}}function Zl(t,e,s,n,i,r){const o=new Ql(r);return o.m_shape=t,o.m_geometry=e,o.m_knownSimpleResult=s,o.m_bFixSelfTangency=n,o.m_polylineDegeneracies=i,o.m_bHasSegmentParentage=t.hasSegmentParentage(),o.m_bHasSegments=t.hasCurves(),o.simplify_()}class Ql{constructor(t){this.m_shape=null,this.m_geometry=Ar,this.m_sortedVertices=new Ke,this.m_bunchEdgeEndPoints=[],this.m_bunchEdgeCenterPoints=[],this.m_bunchEdgeIndices=[],this.m_sorterSegmentBuffer1=null,this.m_sorterSegmentBuffer2=null,this.m_knownSimpleResult=-1,this.m_sortedVerticesListIndex=-1,this.m_polylineDegeneracies=Ar,this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=-1,this.m_progressCounter=0,this.m_bFixSelfTangency=!1,this.m_bHasSegmentParentage=!1,this.m_bHasSegments=!1,this.m_progressTracker=t}compareAngles_(t,e){return this.m_bHasSegments?this.compareAnglesCurves_(t,e):this.compareAnglesLines_(t,e)}compareAnglesLines_(t,e){const s=this.m_bunchEdgeEndPoints[t],n=new l;this.m_shape.queryXY(s,n);const i=new l,r=this.m_bunchEdgeEndPoints[e];if(this.m_shape.queryXY(r,i),n.equals(i))return 0;const o=this.m_bunchEdgeCenterPoints[t],a=new l;this.m_shape.queryXY(o,a);const h=this.m_bunchEdgeCenterPoints[e],m=new l;this.m_shape.queryXY(h,m);const u=new l;u.setSub(n,a);const c=new l;return c.setSub(i,m),(u.isZero()||c.isZero())&&N(""),l.compareVectors(u,c)}compareAnglesCurves_(t,e){const s=this.m_bunchEdgeEndPoints[t],n=this.m_bunchEdgeEndPoints[e],i=this.m_bunchEdgeCenterPoints[t],r=this.m_bunchEdgeCenterPoints[e],o=this.m_shape.getNextVertex(i)===s,a=this.m_shape.getNextVertex(r)===n,h=o?this.m_shape.isCurve(i):this.m_shape.isCurve(s),m=a?this.m_shape.isCurve(r):this.m_shape.isCurve(n);return h||m?(this.m_sorterSegmentBuffer1||(this.m_sorterSegmentBuffer1=new fm),this.m_sorterSegmentBuffer2||(this.m_sorterSegmentBuffer2=new fm),o?this.m_shape.querySegment(i,this.m_sorterSegmentBuffer1,!1,!0):(this.m_shape.querySegment(s,this.m_sorterSegmentBuffer1,!1,!0),this.m_sorterSegmentBuffer1.get().reverse()),a?this.m_shape.querySegment(r,this.m_sorterSegmentBuffer2,!1,!0):(this.m_shape.querySegment(n,this.m_sorterSegmentBuffer2,!1,!0),this.m_sorterSegmentBuffer2.get().reverse()),Ws(this.m_sorterSegmentBuffer1.get(),this.m_sorterSegmentBuffer2.get())):this.compareAnglesLines_(t,e)}beforeRemoveVertex_(t,e){const s=this.m_shape.getUserIndex(t,this.m_userIndexSortedIndexToVertex);if(this.m_nextVertexToProcess===s&&(this.m_nextVertexToProcess=this.m_sortedVertices.getNext(this.m_nextVertexToProcess)),this.m_firstCoincidentVertex===s&&(this.m_firstCoincidentVertex=this.m_sortedVertices.getNext(this.m_firstCoincidentVertex)),this.m_sortedVertices.deleteElement(this.m_sortedVerticesListIndex,s),this.removeAngleSortInfo_(t),e){const e=this.m_shape.getPathFromVertex(t);if(e!==Ar&&this.m_shape.getFirstVertex(e)===t){const s=this.m_shape.getNextVertex(t);if(s!==t){if(this.m_shape.getPathFromVertex(s)===e)return void this.m_shape.setFirstVertex(e,s);{const s=this.m_shape.getPrevVertex(t);if(s!==t&&this.m_shape.getPathFromVertex(s)===e)return void this.m_shape.setFirstVertex(e,s)}}this.m_shape.setFirstVertex(e,Ar),this.m_shape.setLastVertex(e,Ar)}}}processBunch_(){let t=!1;const e=new l(0,0);for(;;){this.m_bunchEdgeEndPoints.length=0,this.m_bunchEdgeCenterPoints.length=0,this.m_bunchEdgeIndices.length=0;let s=this.m_firstCoincidentVertex,n=0,i=!0;for(;s!==this.m_nextVertexToProcess;){const t=this.m_sortedVertices.getData(s);i&&(this.m_shape.queryXY(t,e),i=!1);const r=this.m_shape.getPrevVertex(t),o=this.m_shape.getNextVertex(t);this.m_shape.getUserIndex(r,this.m_userIndexSortedAngleIndexToVertex)!==gs&&(this.m_bunchEdgeEndPoints.push(r),this.m_shape.setUserIndex(r,this.m_userIndexSortedAngleIndexToVertex,gs),this.m_bunchEdgeCenterPoints.push(t),this.m_bunchEdgeIndices.push(n++)),this.m_shape.getUserIndex(o,this.m_userIndexSortedAngleIndexToVertex)!==gs&&(this.m_bunchEdgeEndPoints.push(o),this.m_shape.setUserIndex(o,this.m_userIndexSortedAngleIndexToVertex,gs),this.m_bunchEdgeCenterPoints.push(t),this.m_bunchEdgeIndices.push(n++)),s=this.m_sortedVertices.getNext(s)}if(this.m_bunchEdgeEndPoints.length<2){1===this.m_bunchEdgeEndPoints.length&&this.m_shape.setUserIndex(this.m_bunchEdgeEndPoints[0],this.m_userIndexSortedAngleIndexToVertex,-1);break}this.m_bunchEdgeIndices.sort((t,e)=>this.compareAngles_(t,e));for(let t=0,e=this.m_bunchEdgeIndices.length;t<e;t++){const e=this.m_bunchEdgeIndices[t],s=this.m_bunchEdgeEndPoints[e];this.m_shape.setUserIndex(s,this.m_userIndexSortedAngleIndexToVertex,t)}const r=this.processCrossOvers_(e);for(let t=0,e=this.m_bunchEdgeIndices.length;t<e;t++){const e=this.m_bunchEdgeIndices[t];if(-1===e)continue;const s=this.m_bunchEdgeEndPoints[e];this.m_shape.setUserIndex(s,this.m_userIndexSortedAngleIndexToVertex,-1)}if(!r)break;t=!0}return t}processCrossOvers_(t){let e=!1,s=!0;for(;s;){s=!1;let n=0;-1===this.m_bunchEdgeIndices[n]&&(n=this.getNextEdgeIndex_(n));let i=this.getNextEdgeIndex_(n);for(let r=0,o=this.m_bunchEdgeIndices.length;r<o&&-1!==n&&-1!==i&&n!==i;r++){const r=this.m_bunchEdgeIndices[n],o=this.m_bunchEdgeIndices[i],a=this.m_bunchEdgeEndPoints[r],h=this.m_bunchEdgeEndPoints[o];let m=this.m_shape.getNextVertex(a),l=!1;this.m_shape.isEqualXYPoint2D(m,t)||(m=this.m_shape.getPrevVertex(a),l=!0);let u=this.m_shape.getNextVertex(h),c=!1;this.m_shape.isEqualXYPoint2D(u,t)||(u=this.m_shape.getPrevVertex(h),c=!0);const g=l?this.m_shape.getPrevVertex(m):this.m_shape.getNextVertex(m),d=c?this.m_shape.getPrevVertex(u):this.m_shape.getNextVertex(u);let _=!1;(this.removeSpike_(m)||this.removeSpike_(u)||this.removeSpike_(a)||this.removeSpike_(h)||this.removeSpike_(g)||this.removeSpike_(d))&&(_=!0),m!==u&&(!_&&this.m_shape.isEqualXY(a,h)&&(_=this.resolveOverlap_(l,c,m,a,u,h)),!_&&this.m_shape.isEqualXY(g,d)&&(_=this.resolveOverlap_(!l,!c,m,g,u,d)),!_&&this.m_shape.isEqualXY(a,d)&&(_=this.resolveOverlap_(l,!c,m,a,u,d)),!_&&this.m_shape.isEqualXY(g,h)&&(_=this.resolveOverlap_(!l,c,m,g,u,h))),_&&(e=!0),s||=_,n=_?this.getNextEdgeIndex_(n):i,i=this.getNextEdgeIndex_(n)}}if(!e){let s=0;-1===this.m_bunchEdgeIndices[s]&&(s=this.getNextEdgeIndex_(s));let n=this.getNextEdgeIndex_(s);for(let i=0,r=this.m_bunchEdgeIndices.length;i<r&&-1!==s&&-1!==n&&s!==n;i++){const i=this.m_bunchEdgeIndices[s],r=this.m_bunchEdgeIndices[n],o=this.m_bunchEdgeEndPoints[i],a=this.m_bunchEdgeEndPoints[r];let h=this.m_shape.getNextVertex(o);this.m_shape.isEqualXYPoint2D(h,t)||(h=this.m_shape.getPrevVertex(o));let m=this.m_shape.getNextVertex(a);this.m_shape.isEqualXYPoint2D(m,t)||(m=this.m_shape.getPrevVertex(a));const l=this.getDirection_(h,o),u=this.getDirection_(m,a),c=l?this.m_shape.getPrevVertex(h):this.m_shape.getNextVertex(h),g=u?this.m_shape.getPrevVertex(m):this.m_shape.getNextVertex(m),d=this.detectAndResolveCrossOver_(l,u,o,h,c,a,m,g);1!==d?0===d?(s=this.getNextEdgeIndex_(s),n=this.getNextEdgeIndex_(s)):(s=this.getPrevEdgeIndex_(s),n=this.getNextEdgeIndex_(s)):e=!0}}return e}simplify_(){this.m_shape.getGeometryType(this.m_geometry)===o.enumPolygon&&1===this.m_shape.getFillRule(this.m_geometry)&&new Jc(this.m_progressTracker).planarSimplifyNoCrackingAndCluster(this.m_bFixSelfTangency,this.m_shape,this.m_geometry,0);let t=!1;this.m_userIndexSortedIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=-1,this.m_userIndexSortedAngleIndexToVertex=this.m_shape.createUserIndexUninitialized();const e=this.m_shape.getPointCount(this.m_geometry),s=new Fe(0);this.m_shape.dbgVerifyMonotone();for(let t=this.m_shape.getFirstPath(this.m_geometry);t!==Ar;t=this.m_shape.getNextPath(t)){let e=this.m_shape.getFirstVertex(t);for(let n=0,i=this.m_shape.getPathSize(t);n<i;n++)this.m_shape.setUserIndex(e,this.m_userIndexSortedAngleIndexToVertex,-1),s.add(e),e=this.m_shape.getNextVertex(e)}this.m_shape.sortVerticesSimpleByY(s,0,e),this.progress_(!0),this.m_userIndexSortedIndexToVertex=this.m_shape.createUserIndexUninitialized(),this.m_sortedVertices.reserveNodes(e),this.m_sortedVerticesListIndex=this.m_sortedVertices.createList(0);for(let t=0;t<e;t++){const e=s.read(t),n=this.m_sortedVertices.addElement(this.m_sortedVerticesListIndex,e);this.m_shape.setUserIndex(e,this.m_userIndexSortedIndexToVertex,n)}this.m_nextVertexToProcess=-1,this.cleanupSpikes_()&&(t=!0);let n=0,i=!1;do{i=!1,this.m_nextVertexToProcess=-1,this.m_firstCoincidentVertex=this.m_sortedVertices.getFirst(this.m_sortedVerticesListIndex);const e=new l(0,0);this.m_firstCoincidentVertex!==Ke.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(this.m_firstCoincidentVertex),e);let s=0,r=this.m_firstCoincidentVertex;for(;r!==Ke.st_nullNode()&&(r=this.m_sortedVertices.getNext(r),r!==Ke.st_nullNode());){this.progress_();const t=this.m_sortedVertices.getData(r),n=l.getNAN();if(this.m_shape.queryXY(t,n),e.equals(n))s++;else{if(s>0){this.m_nextVertexToProcess=r;const t=this.processBunch_();r=this.m_nextVertexToProcess,r!==Ke.st_nullNode()&&this.m_shape.queryXY(this.m_sortedVertices.getData(r),n),t&&(i=!0)}e.setCoordsPoint2D(n),this.m_firstCoincidentVertex=r,s=0}}this.m_nextVertexToProcess=-1,s>0&&this.processBunch_()&&(i=!0),n++>10&&P(""),i&&this.fixOrphanVertices_(),this.cleanupSpikes_()&&(i=!0),t||=i}while(i);return this.m_shape.dbgVerifyMonotone(),this.m_shape.dbgVerifyCurves(),this.m_shape.removeUserIndex(this.m_userIndexSortedIndexToVertex),this.m_shape.removeUserIndex(this.m_userIndexSortedAngleIndexToVertex),t=function(t,e,s,n,i){const r=new jl(i);return r.m_shape=t,r.m_geometry=e,r.m_sortedVertices=s,r.m_bFixSelfTangency=n,r.fixRingOrientation_()}(this.m_shape,this.m_geometry,this.m_sortedVertices,this.m_bFixSelfTangency,this.m_progressTracker)||t,this.m_shape.dbgVerifyCurves(),t}getDirection_(t,e){return this.m_shape.getNextVertex(e)!==t}detectAndResolveCrossOver_(t,e,s,n,i,r,o,a){if(n===o)return this.removeAngleSortInfo_(s),this.removeAngleSortInfo_(r),-1;const m=this.m_shape.getUserIndex(s,this.m_userIndexSortedAngleIndexToVertex),l=this.m_shape.getUserIndex(i,this.m_userIndexSortedAngleIndexToVertex),u=this.m_shape.getUserIndex(r,this.m_userIndexSortedAngleIndexToVertex),c=this.m_shape.getUserIndex(a,this.m_userIndexSortedAngleIndexToVertex),g=h(8,Number.NaN),d=h(4,Number.NaN);g[0]=0,d[0]=m,g[1]=0,d[1]=l,g[2]=1,d[2]=u,g[3]=1,d[3]=c;for(let t=1;t<4;t++){const e=d[t],s=g[t];let n=t-1;for(;n>=0&&d[n]>e;)d[n+1]=d[n],g[n+1]=g[n],n--;d[n+1]=e,g[n+1]=s}let _=0;if(g[0]&&(_|=1),g[1]&&(_|=2),g[2]&&(_|=4),g[3]&&(_|=8),5!==_&&10!==_)return 0;if(t!==e&&(a=p(r,r=a)),t)this.m_shape.setNextVertex(a,n),this.m_shape.setPrevVertex(n,a),this.m_shape.setNextVertex(i,o),this.m_shape.setPrevVertex(o,i),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(n,!0),this.m_shape.setSegmentParentageBreakVertex(o,!0));else{if(this.m_shape.setPrevVertex(a,n),this.m_shape.setNextVertex(n,a),this.m_shape.setPrevVertex(i,o),this.m_shape.setNextVertex(o,i),this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(n),e=this.m_shape.getSegmentParentage(o);this.m_shape.setSegmentParentageAndBreak(n,e,!0),this.m_shape.setSegmentParentageAndBreak(o,t,!0)}if(this.m_bHasSegments){const t=this.m_shape.getVertexIndex(n),e=this.m_shape.getVertexIndex(o),s=this.m_shape.getSegmentFromIndex(t);this.m_shape.setSegmentToIndex(t,null);const i=this.m_shape.getSegmentFromIndex(e);this.m_shape.setSegmentToIndex(e,null),this.m_shape.setSegmentToIndex(t,i),this.m_shape.setSegmentToIndex(e,s)}}return 1}resolveOverlap_(t,e,s,n,i,r){return this.resolveOverlapOddEven_(t,e,s,n,i,r)}resolveOverlapOddEven_(t,e,s,n,i,r){if(t!==e){t||(i=p(s,s=i),r=p(n,n=r));const e=this.m_shape.getNextVertex(i),o=this.m_shape.getNextVertex(s);if(this.m_shape.setNextVertex(s,e),this.m_shape.setPrevVertex(e,s),this.m_shape.setNextVertex(i,o),this.m_shape.setPrevVertex(o,i),this.m_bHasSegments){const t=this.m_shape.getVertexIndex(s),e=this.m_shape.getVertexIndex(i),n=this.m_shape.getSegmentFromIndex(t);this.m_shape.setSegmentToIndex(t,null);const r=this.m_shape.getSegmentFromIndex(e);this.m_shape.setSegmentToIndex(e,null),this.m_shape.setSegmentToIndex(t,r),this.m_shape.setSegmentToIndex(e,n)}if(this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(s),e=this.m_shape.getSegmentParentage(i);this.m_shape.setSegmentParentageAndBreak(s,e,!0),this.m_shape.setSegmentParentageAndBreak(i,t,!0),this.m_shape.setSegmentParentageBreakVertex(n,!0),this.m_shape.setSegmentParentageBreakVertex(r,!0)}this.removeSpike_(i)}else{const o=t?s:n,a=e?i:r,h=t?n:s,m=e?r:i;let l=null;if(this.m_bHasSegments){const t=this.m_shape.getVertexIndex(m);l=this.m_shape.getSegmentFromIndex(t),this.m_shape.setSegmentToIndex(t,null);const e=this.m_shape.getVertexIndex(a);this.m_shape.setSegmentToIndex(e,null);const s=this.m_shape.getVertexIndex(o);this.m_shape.setSegmentToIndex(s,null)}let u=-1;this.m_bHasSegmentParentage&&(u=this.m_shape.getSegmentParentage(m));let c=!1;this.m_shape.setNextVertex(o,a),this.m_shape.setNextVertex(a,o),this.m_shape.setPrevVertex(h,m),this.m_shape.setPrevVertex(m,h);let g=m;for(;g!==a;){const t=this.m_shape.getPrevVertex(g),e=this.m_shape.getNextVertex(g);if(this.m_shape.setPrevVertex(g,e),this.m_shape.setNextVertex(g,t),c||=g===o,this.m_bHasSegments&&g!==o){const t=this.m_shape.getVertexIndex(e),s=l;l=this.m_shape.getSegmentFromIndex(t),null!==s&&s.reverse(),this.m_shape.setSegmentToIndex(t,s)}if(this.m_bHasSegmentParentage){const t=this.m_shape.getSegmentParentage(e);this.m_shape.setSegmentParentagePreserveBreak(e,u),u=t}g=e}let d=null;if(!c){const t=this.m_shape.getPrevVertex(a),e=this.m_shape.getNextVertex(a);if(this.m_shape.setPrevVertex(a,e),this.m_shape.setNextVertex(a,t),this.m_bHasSegments){const t=this.m_shape.getVertexIndex(a);d=this.m_shape.getSegmentFromIndex(t),this.m_shape.setSegmentToIndex(t,null)}}let _=-1,p=-1;if(this.m_bHasSegmentParentage&&(_=c?this.m_shape.getSegmentParentage(o):this.m_shape.getSegmentParentage(a),p=this.m_shape.getSegmentParentage(h)),this.transferVertexData_(a,o),this.beforeRemoveVertex_(a,!0),this.m_shape.removeVertexInternal(a,!0),this.removeAngleSortInfo_(o),this.transferVertexData_(m,h),this.beforeRemoveVertex_(m,!0),this.m_shape.removeVertexInternal(m,!0),this.removeAngleSortInfo_(h),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageAndBreak(o,_,!0),this.m_shape.setSegmentParentageAndBreak(h,p,!0)),d){const t=this.m_shape.getVertexIndex(o);this.m_shape.setSegmentToIndex(t,d)}}return!0}cleanupSpikes_(){let t=!1;for(let e=this.m_shape.getFirstPath(this.m_geometry);e!==Ar;){const s=this.m_shape.getNextPath(e);let n=this.m_shape.getFirstVertex(e);for(let s=0,i=this.m_shape.getPathSize(e);s<i&&i>1;){this.progress_();const{v:r,bModified:o}=this.checkAndCleanupSpike_(e,n);if(r===Ar)break;o?(t=!0,n=r,s=0,i=this.m_shape.getPathSize(e)):(n=r,s++)}e=s}return t}checkAndCleanupSpike_(t,e){const s={v:Ar,bModified:!1};let n=this.m_shape.getPrevVertex(e),i=this.m_shape.getNextVertex(e),r=Ar,o=Ar;for(;this.m_shape.isEqualXY(n,i)&&(r=n,o=i,i!==e);)n=this.m_shape.getPrevVertex(n),i=this.m_shape.getNextVertex(i);if(r===Ar)return s.v=i,s;s.bModified=!0;for(let t=this.m_shape.getNextVertex(r);this.beforeRemoveVertex_(t,!1),t!==o;t=this.m_shape.getNextVertex(t));if(r===e)return this.m_polylineDegeneracies!==Ar?this.m_shape.movePath(this.m_polylineDegeneracies,Ar,t):this.m_shape.removePath(t),s.v=Ar,s;{const t=this.m_shape.peelALoopIntoAPath(r,o);this.m_polylineDegeneracies!==Ar?this.m_shape.movePath(this.m_polylineDegeneracies,Ar,t):this.m_shape.removePath(t)}return s.v=r,s}removeSpike_(t){let e=this.m_shape.getPrevVertex(t),s=this.m_shape.getNextVertex(t),n=Ar,i=Ar;for(;this.m_shape.isEqualXY(e,s)&&(n=e,i=s,s!==t);)e=this.m_shape.getPrevVertex(e),s=this.m_shape.getNextVertex(s);if(n===Ar)return!1;if(this.m_shape.peelALoop(n,i),this.m_bHasSegmentParentage&&(this.m_shape.setSegmentParentageBreakVertex(n,!0),this.m_shape.setSegmentParentageBreakVertex(i,!0)),this.removeAngleSortInfo_(n),this.m_polylineDegeneracies===Ar)for(let t=this.m_shape.getNextVertex(i);;){const e=this.m_shape.getNextVertex(t);if(this.removeAngleSortInfo_(t),this.beforeRemoveVertex_(t,!0),this.m_shape.setSegmentToIndex(this.m_shape.getVertexIndex(t),null),this.m_shape.removeVertexInternal(t,!1),t===i)break;t=e}else{for(let t=i;;){const e=this.m_shape.getNextVertex(t);if(this.removeAngleSortInfo_(t),this.beforeRemoveVertex_(t,!1),t=e,t===i)break}const t=[!1];this.m_shape.insertClosedPath(this.m_polylineDegeneracies,Ar,i,i,t)}return!0}fixOrphanVertices_(){let t=0;for(let t=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==t;t=this.m_sortedVertices.getNext(t)){const e=this.m_sortedVertices.getData(t);this.m_shape.setPathToVertex(e,Ar)}let e=0;for(let s=this.m_shape.getFirstPath(this.m_geometry);s!==Ar;){const n=this.m_shape.getFirstVertex(s);if(n===Ar||this.m_shape.getPathFromVertex(n)!==Ar){const t=s;s=this.m_shape.getNextPath(s),this.m_shape.removePathOnly(t);continue}this.m_shape.setPathToVertex(n,s);let i=1;for(let t=this.m_shape.getNextVertex(n);t!==n;t=this.m_shape.getNextVertex(t))this.m_shape.setPathToVertex(t,s),i++;this.m_shape.setRingAreaValid(s,!1),this.m_shape.setPathSize(s,i),this.m_shape.setLastVertex(s,this.m_shape.getPrevVertex(n)),e+=i,t++,s=this.m_shape.getNextPath(s)}for(let s=this.m_sortedVertices.getFirst(this.m_sortedVertices.getFirstList());-1!==s;s=this.m_sortedVertices.getNext(s)){const n=this.m_sortedVertices.getData(s);if(this.m_shape.getPathFromVertex(n)!==Ar)continue;const i=[!1],r=this.m_shape.insertClosedPath(this.m_geometry,Ar,n,n,i);e+=this.m_shape.getPathSize(r),t++}this.m_shape.setGeometryPathCount(this.m_geometry,t),this.m_shape.setGeometryVertexCount(this.m_geometry,e);let s=0;for(let t=this.m_shape.getFirstGeometry();t!==Ar;t=this.m_shape.getNextGeometry(t))s+=this.m_shape.getPointCount(t);this.m_shape.setTotalPointCount(s)}getNextEdgeIndex_(t){if(-1===t)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(t+1)%this.m_bunchEdgeIndices.length,-1!==this.m_bunchEdgeIndices[t])return t;return-1}getPrevEdgeIndex_(t){if(-1===t)return-1;for(let e=0,s=this.m_bunchEdgeIndices.length-1;e<s;e++)if(t=(this.m_bunchEdgeIndices.length+t-1)%this.m_bunchEdgeIndices.length,-1!==this.m_bunchEdgeIndices[t])return t;return-1}transferVertexData_(t,e){const s=this.m_shape.getUserIndex(e,this.m_userIndexSortedIndexToVertex),n=this.m_shape.getUserIndex(e,this.m_userIndexSortedAngleIndexToVertex);this.m_shape.transferAllDataToTheVertex(t,e),this.m_shape.setUserIndex(e,this.m_userIndexSortedIndexToVertex,s),this.m_shape.setUserIndex(e,this.m_userIndexSortedAngleIndexToVertex,n)}removeAngleSortInfo_(t){const e=this.m_shape.getUserIndex(t,this.m_userIndexSortedAngleIndexToVertex);-1!==e&&(this.m_bunchEdgeIndices[e]=-1,this.m_shape.setUserIndex(t,this.m_userIndexSortedAngleIndexToVertex,-1))}progress_(t=!1){}}function Kl(e,n,i,r,a,m=!0){switch(Jl(r)){case 0:break;case 1:s("relation string length has to be 9 characters");break;default:s("relation string")}if(m){const t=function(t,e,s){return function(t){return"T*F**FFF*"===t}(t)?3:function(t){return"FF*FF****"===t}(t)?4:function(t,e,s){return!(0===e&&0===s||(2===e&&2===s?"F***T****"!==t:2!==e&&1!==e||0!==s||"F**T*****"!==t))}(t,e,s)?8:function(t,e,s){return e>s?"T*****T**"===t:1===e&&1===s&&"0********"===t}(t,e,s)?16:function(t){return"T**FF*FF*"===t}(t)?64:function(t){return"T*****FF*"===t}(t)?1:function(t,e,s){return e===s&&(1!==e?"T*T***T**"===t:"1*T***T**"===t)}(t,e,s)?32:0}(r,e.getDimension(),n.getDimension());if(0!==t)return du(e,n,i,t,a)}let u=0;if("number"==typeof i)u=i;else{const s=t.constructEmpty();e.queryEnvelope(s);const r=t.constructEmpty();n.queryEnvelope(r);const o=t.constructEmpty();o.setCoords({env2D:s}),o.mergeEnvelope2D(r),u=Ze(i,o,!1)}const c=mu(e,u),g=mu(n,u);if(c.isEmpty()||g.isEmpty())return function(e,s,n){const i=h(9,-1);if(e.isEmpty()&&s.isEmpty())return ru(i,n);let r,a=!1;e.isEmpty()?(r=s,a=!0):r=e,i[0]=-1,i[1]=-1,i[3]=-1,i[4]=-1,i[6]=-1,i[7]=-1,i[8]=2;const m=r.getGeometryType();if(Z(m))if(m===o.enumPolygon)if(0!==r.calculateArea2D())i[2]=2,i[5]=1;else{i[5]=-1;const e=t.constructEmpty();r.queryEnvelope(e),i[2]=e.height()||e.width()?1:0}else{const t=0!==r.calculateLength2D();i[2]=t?1:0,i[5]=Zn(r)?0:-1}else i[2]=0,i[5]=-1;return a&&hu(i),ru(i,n)}(c,g,r);const d=c.getGeometryType(),_=g.getGeometryType();let p=!1;switch(d){case o.enumPolygon:switch(_){case o.enumPolygon:p=function(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setAreaAreaPredicates_();const a=t.constructEmpty(),h=t.constructEmpty();e.queryEnvelope(a),s.queryEnvelope(h);let m=!1;if(pu(a,h,n)&&(o.areaAreaDisjointPredicates_(e,s),m=!0),m||fu(e,s),!m){const t=new Vr,i=t.addGeometry(e),a=t.addGeometry(s);o.setEditShapeCrackAndCluster_(t,new cs(n,0),r),o.computeMatrixTopoGraphHalfEdges_(i,a),o.m_topoGraph.removeShape()}return ru(o.m_matrix,o.m_scl)}(c,g,u,r,a);break;case o.enumPolyline:p=$l(c,g,u,r,a);break;case o.enumPoint:p=su(c,g,u,r);break;case o.enumMultiPoint:p=tu(c,g,u,r,a)}break;case o.enumPolyline:switch(_){case o.enumPolygon:p=$l(g,c,u,lu(r),a);break;case o.enumPolyline:p=function(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setLineLinePredicates_();const a=t.constructEmpty(),h=t.constructEmpty();e.queryEnvelope(a),s.queryEnvelope(h);let m=!1;if(pu(a,h,n)&&(o.lineLineDisjointPredicates_(e,s),m=!0),m||fu(e,s),!m){const t=new Vr,i=t.addGeometry(e),a=t.addGeometry(s);o.setEditShapeCrackAndCluster_(t,new cs(n,0),r),o.m_clusterIndexA=o.m_topoGraph.createUserIndexForClusters(),o.m_clusterIndexB=o.m_topoGraph.createUserIndexForClusters(),ou(i,o.m_topoGraph,o.m_clusterIndexA),ou(a,o.m_topoGraph,o.m_clusterIndexB),o.computeMatrixTopoGraphHalfEdges_(i,a),o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexA),o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexB),o.m_topoGraph.removeShape()}return ru(o.m_matrix,o.m_scl)}(c,g,u,r,a);break;case o.enumPoint:p=nu(c,g,u,r,a);break;case o.enumMultiPoint:p=eu(c,g,u,r,a)}break;case o.enumPoint:switch(_){case o.enumPolygon:p=su(g,c,u,lu(r));break;case o.enumPolyline:p=nu(g,c,u,lu(r),a);break;case o.enumPoint:p=function(t,e,s,n){const i=t.getXY(),r=e.getXY(),o=h(9,-1);return l.sqrDistance(i,r)<=s*s?o[0]=0:(o[2]=0,o[6]=0),o[8]=2,ru(o,n)}(c,g,u,r);break;case o.enumMultiPoint:p=iu(g,c,u,lu(r))}break;case o.enumMultiPoint:switch(_){case o.enumPolygon:p=tu(g,c,u,lu(r),a);break;case o.enumPolyline:p=eu(g,c,u,lu(r),a);break;case o.enumMultiPoint:p=function(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setPointPointPredicates_();const a=new t,h=new t;e.queryEnvelope(a),s.queryEnvelope(h);let m=!1;if(pu(a,h,n)&&(o.pointPointDisjointPredicates_(),m=!0),!m){const t=new Vr,i=t.addGeometry(e),a=t.addGeometry(s);o.setEditShapeCrackAndCluster_(t,new cs(n,0),r),o.computeMatrixTopoGraphClusters_(i,a),o.m_topoGraph.removeShape()}return ru(o.m_matrix,o.m_scl)}(c,g,u,r,a);break;case o.enumPoint:p=iu(c,g,u,r)}break;default:p=!1}return p}function Jl(t){if(9!==t.length)return 1;for(let e=0;e<9;e++){const s=t[e];if("*"!==s&&"T"!==s&&"F"!==s&&"0"!==s&&"1"!==s&&"2"!==s)return 2}return 0}function $l(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setAreaLinePredicates_();const a=t.constructEmpty(),h=t.constructEmpty();e.queryEnvelope(a),s.queryEnvelope(h);let m=!1;if(pu(a,h,n)&&(o.areaLineDisjointPredicates_(e,s),m=!0),m||fu(e,s),!m){const t=new Vr,i=t.addGeometry(e),a=t.addGeometry(s);o.setEditShapeCrackAndCluster_(t,new cs(n,0),r),o.m_clusterIndexB=o.m_topoGraph.createUserIndexForClusters(),ou(a,o.m_topoGraph,o.m_clusterIndexB),o.computeMatrixTopoGraphHalfEdges_(i,a),o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexB),o.m_topoGraph.removeShape()}return ru(o.m_matrix,o.m_scl)}function tu(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setAreaPointPredicates_();const a=t.constructEmpty(),h=t.constructEmpty();e.queryEnvelope(a),s.queryEnvelope(h);let m=!1;if(pu(a,h,n)&&(o.areaPointDisjointPredicates_(e),m=!0),m||fu(e,s),!m){const t=new Vr,i=t.addGeometry(e),a=t.addGeometry(s);o.setEditShapeCrackAndCluster_(t,new cs(n,0),r),o.computeMatrixTopoGraphClusters_(i,a),o.m_topoGraph.removeShape()}return ru(o.m_matrix,o.m_scl)}function eu(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setLinePointPredicates_();const a=t.constructEmpty(),h=t.constructEmpty();e.queryEnvelope(a),s.queryEnvelope(h);let m=!1;if(pu(a,h,n)&&(o.linePointDisjointPredicates_(e),m=!0),m||fu(e,s),!m){const t=new Vr,i=t.addGeometry(e),a=t.addGeometry(s);o.setEditShapeCrackAndCluster_(t,new cs(n,0),r),o.m_clusterIndexA=o.m_topoGraph.createUserIndexForClusters(),ou(i,o.m_topoGraph,o.m_clusterIndexA),o.computeMatrixTopoGraphClusters_(i,a),o.m_topoGraph.deleteUserIndexForClusters(o.m_clusterIndexA),o.m_topoGraph.removeShape()}return ru(o.m_matrix,o.m_scl)}function su(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setAreaPointPredicates_();const a=t.constructEmpty();e.queryEnvelope(a);const h=s.getXY();let m=!1;if(xu(h,a,n)&&(o.areaPointDisjointPredicates_(e),m=!0),!m){const s=_c(e,h,n);if(1===s)o.m_matrix[0]=0,o.m_matrix[2]=2,o.m_matrix[3]=-1,o.m_matrix[5]=1,o.m_matrix[6]=-1;else if(2===s)if(o.m_matrix[6]=-1,0!==e.calculateArea2D())o.m_matrix[0]=-1,o.m_matrix[3]=0,o.m_matrix[2]=2,o.m_matrix[5]=1;else{o.m_matrix[0]=0,o.m_matrix[3]=-1,o.m_matrix[5]=-1;const s=t.constructEmpty();e.queryEnvelope(s),o.m_matrix[2]=s.height()||s.width()?1:-1}else o.areaPointDisjointPredicates_(e)}return ru(o.m_matrix,i)}function nu(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setLinePointPredicates_();const a=t.constructEmpty();e.queryEnvelope(a);let h=!1;if(xu(s.getXY(),a,n)&&(o.linePointDisjointPredicates_(e),h=!0),!h){let t=null,i=!1,a=!1;if((o.m_performPredicates[0]||o.m_performPredicates[6])&&(du(e,s,n,4,r)?(o.m_matrix[0]=-1,o.m_matrix[6]=0):(o.m_performPredicates[0]&&(t=Qn(e),a=!du(t,s,n,4,r),i=!0,o.m_matrix[0]=a?-1:0),o.m_matrix[6]=-1)),o.m_performPredicates[3]&&(null!==t&&t.isEmpty()?o.m_matrix[3]=-1:(i||(null==t&&(t=Qn(e)),a=!du(t,s,n,4,r),i=!0),o.m_matrix[3]=a?0:-1)),o.m_performPredicates[5])if(null!==t&&t.isEmpty())o.m_matrix[5]=-1;else if(i&&!a)o.m_matrix[5]=0;else{null===t&&(t=Qn(e));const i=du(t,s,n,3,r);o.m_matrix[5]=i?-1:0}if(o.m_performPredicates[2])if(0!==e.calculateLength2D())o.m_matrix[2]=1;else{const t=new Fs({vd:e.getDescription()});t.addPoints(e,0,e.getPointCount());const i=du(t,s,n,3,r);o.m_matrix[2]=i?-1:0}}return ru(o.m_matrix,o.m_scl)}function iu(e,s,n,i,r){const o=new au;o.resetMatrix_(),o.setPredicates_(i),o.setPointPointPredicates_();const a=t.constructEmpty();e.queryEnvelope(a);const h=s.getXY(),m=new l;let u=!1;if(xu(h,a,n)&&(o.pointPointDisjointPredicates_(),u=!0),!u){let t=!1,s=!0;const i=n*n;for(let n=0;n<e.getPointCount()&&(e.queryXY(n,m),l.sqrDistance(m,h)<=i?t=!0:s=!1,!t||s);n++);t?(o.m_matrix[0]=0,o.m_matrix[2]=s?-1:0,o.m_matrix[6]=-1):(o.m_matrix[0]=-1,o.m_matrix[2]=0,o.m_matrix[6]=0)}return ru(o.m_matrix,i)}function ru(t,e){for(let s=0;s<9;s++)switch(e[s]){case"T":if(-1===t[s])return!1;break;case"F":if(-1!==t[s])return!1;break;case"0":if(0!==t[s])return!1;break;case"1":if(1!==t[s])return!1;break;case"2":if(2!==t[s])return!1}return!0}function ou(t,e,s){const n=e.getGeometryID(t);for(let t=e.getFirstCluster();t!==Ar;t=e.getNextCluster(t)){if(0===(e.getClusterParentage(t)&n))continue;const i=e.getClusterHalfEdge(t);if(i===Ar){e.setClusterUserIndex(t,s,0);continue}let r=i,o=0;do{const t=r;0!==(e.getHalfEdgeParentage(t)&n)&&o++,r=e.getHalfEdgeNext(e.getHalfEdgeTwin(t))}while(r!==i);e.setClusterUserIndex(t,s,o)}}class au{nullFunc(){return P("should not be called"),!1}constructor(){this.m_clusterIndexA=-1,this.m_clusterIndexB=-1,this.m_visitedIndex=-1,this.m_topoGraph=new ll,this.m_matrix=h(9,0),this.m_maxDim=h(9,0),this.m_performPredicates=h(9,!1),this.m_scl="",this.m_predicateCount=0,this.m_predicatesHalfEdge=this.nullFunc,this.m_predicatesCluster=this.nullFunc}resetMatrix_(){this.m_matrix.fill(-2),this.m_maxDim.fill(-2)}setPredicates_(t){this.m_scl=t;for(let t=0;t<9;t++)"*"!==this.m_scl[t]?(this.m_performPredicates[t]=!0,this.m_predicateCount++):this.m_performPredicates[t]=!1}setRemainingPredicatesToFalse_(){for(let t=0;t<9;t++)this.m_performPredicates[t]&&-2===this.m_matrix[t]&&(this.m_matrix[t]=-1,this.m_performPredicates[t]=!1)}isPredicateKnown_(t){return!(-2===this.m_matrix[t]||(-1===this.m_matrix[t]?(this.m_performPredicates[t]=!1,this.m_predicateCount--,0):"T"!==this.m_scl[t]&&"F"!==this.m_scl[t]&&this.m_matrix[t]<this.m_maxDim[t]||(this.m_performPredicates[t]=!1,this.m_predicateCount--,0)))}setAreaAreaPredicates_(){this.m_predicatesHalfEdge=this.areaAreaPredicates_,this.m_maxDim[0]=2,this.m_maxDim[1]=1,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=1,this.m_maxDim[5]=1,this.m_maxDim[6]=2,this.m_maxDim[7]=1,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaLinePredicates_(){this.m_predicatesHalfEdge=this.areaLinePredicates_,this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=2,this.m_maxDim[3]=1,this.m_maxDim[4]=0,this.m_maxDim[5]=1,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLineLinePredicates_(){this.m_predicatesHalfEdge=this.lineLinePredicates_,this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=1,this.m_maxDim[1]=0,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=0,this.m_maxDim[5]=0,this.m_maxDim[6]=1,this.m_maxDim[7]=0,this.m_maxDim[8]=2,this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setAreaPointPredicates_(){this.m_predicatesCluster=this.areaPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=2,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setLinePointPredicates_(){this.m_predicatesCluster=this.linePointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=1,this.m_maxDim[3]=0,this.m_maxDim[4]=-1,this.m_maxDim[5]=0,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}setPointPointPredicates_(){this.m_predicatesCluster=this.pointPointPredicates_,this.m_maxDim[0]=0,this.m_maxDim[1]=-1,this.m_maxDim[2]=0,this.m_maxDim[3]=-1,this.m_maxDim[4]=-1,this.m_maxDim[5]=-1,this.m_maxDim[6]=0,this.m_maxDim[7]=-1,this.m_maxDim[8]=2,this.m_performPredicates[1]&&(this.m_matrix[1]=-1,this.m_performPredicates[1]=!1,this.m_predicateCount--),this.m_performPredicates[3]&&(this.m_matrix[3]=-1,this.m_performPredicates[3]=!1,this.m_predicateCount--),this.m_performPredicates[4]&&(this.m_matrix[4]=-1,this.m_performPredicates[4]=!1,this.m_predicateCount--),this.m_performPredicates[5]&&(this.m_matrix[5]=-1,this.m_performPredicates[5]=!1,this.m_predicateCount--),this.m_performPredicates[7]&&(this.m_matrix[7]=-1,this.m_performPredicates[7]=!1,this.m_predicateCount--),this.m_performPredicates[8]&&(this.m_matrix[8]=2,this.m_performPredicates[8]=!1,this.m_predicateCount--)}areaAreaDisjointPredicates_(t,e){this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5]),this.areaGeomContainsOrDisjointPredicates_(e,this.m_performPredicates[6]?6:-1,this.m_scl[6],this.m_performPredicates[7]?7:-1,this.m_scl[7])}areaGeomContainsOrDisjointPredicates_(e,s,n,i,r){const o=-1!==s,a=-1!==i;if(o||a)if(("T"!==n&&"F"!==n&&o||"T"!==r&&"F"!==r&&a)&&0===e.calculateArea2D()){if(a&&(this.m_matrix[i]=-1),o){const n=t.constructEmpty();e.queryEnvelope(n),this.m_matrix[s]=n.height()||n.width()?1:0}}else o&&(this.m_matrix[s]=2),a&&(this.m_matrix[i]=1)}areaAreaContainsPredicates_(t){this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[0]?0:-1,this.m_scl[0],this.m_performPredicates[1]?1:-1,this.m_scl[1])}areaAreaWithinPredicates_(t){this.areaAreaContainsPredicates_(t),hu(this.m_matrix)}areaLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[6]){const t=this.m_scl[6],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[6]=s?1:0}if(this.m_performPredicates[7]){const t=Zn(e);this.m_matrix[7]=t?0:-1}this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaLineContainsPredicates_(t,e){if(this.m_performPredicates[0]){const t=this.m_scl[0],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[0]=s?1:0}if(this.m_performPredicates[1]){const t=Zn(e);this.m_matrix[1]=t?0:-1}this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1,this.m_matrix[7]=-1}areaPointDisjointPredicates_(t){this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_matrix[6]=0,this.areaGeomContainsOrDisjointPredicates_(t,this.m_performPredicates[2]?2:-1,this.m_scl[2],this.m_performPredicates[5]?5:-1,this.m_scl[5])}areaPointContainsPredicates_(t){this.m_matrix[0]=0,this.m_matrix[2]=2,this.m_matrix[3]=-1,this.m_matrix[5]=1,this.m_matrix[6]=-1}lineLineDisjointPredicates_(t,e){if(this.m_matrix[0]=-1,this.m_matrix[1]=-1,this.m_matrix[3]=-1,this.m_matrix[4]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s="T"===e||"F"===e||0!==t.calculateLength2D();this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=Zn(t);this.m_matrix[5]=e?0:-1}if(this.m_performPredicates[6]){const t=this.m_scl[6],s="T"===t||"F"===t||0!==e.calculateLength2D();this.m_matrix[6]=s?1:0}if(this.m_performPredicates[7]){const t=Zn(e);this.m_matrix[7]=t?0:-1}}linePointDisjointPredicates_(t){if(this.m_matrix[0]=-1,this.m_matrix[3]=-1,this.m_performPredicates[2]){const e=this.m_scl[2],s="T"===e||"F"===e||0!==t.calculateLength2D();this.m_matrix[2]=s?1:0}if(this.m_performPredicates[5]){const e=Zn(t);this.m_matrix[5]=e?0:-1}this.m_matrix[6]=0}pointPointDisjointPredicates_(){this.m_matrix[0]=-1,this.m_matrix[2]=0,this.m_matrix[6]=0}areaAreaPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorArea_(t,e,s);const i=this.isPredicateKnown_(0);n&&=i}if(this.m_performPredicates[1]){this.interiorAreaBoundaryArea_(t,e,1);const s=this.isPredicateKnown_(1);n&&=s}if(this.m_performPredicates[2]){this.interiorAreaExteriorArea_(t,e,s,2);const i=this.isPredicateKnown_(2);n&&=i}if(this.m_performPredicates[3]){this.interiorAreaBoundaryArea_(t,s,3);const e=this.isPredicateKnown_(3);n&&=e}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryArea_(t,e,s);const i=this.isPredicateKnown_(4);n&&=i}if(this.m_performPredicates[5]){this.boundaryAreaExteriorArea_(t,e,s,5);const i=this.isPredicateKnown_(5);n&&=i}if(this.m_performPredicates[6]){this.interiorAreaExteriorArea_(t,s,e,6);const i=this.isPredicateKnown_(6);n&&=i}if(this.m_performPredicates[7]){this.boundaryAreaExteriorArea_(t,s,e,7);const i=this.isPredicateKnown_(7);n&&=i}return n}areaLinePredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorLine_(t,e,s);const i=this.isPredicateKnown_(0);n&&=i}if(this.m_performPredicates[1]){this.interiorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(1);n&&=i}if(this.m_performPredicates[2]){this.interiorAreaExteriorLine_(t,e,s);const i=this.isPredicateKnown_(2);n&&=i}if(this.m_performPredicates[3]){this.boundaryAreaInteriorLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(3);n&&=i}if(this.m_performPredicates[4]){this.boundaryAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(4);n&&=i}if(this.m_performPredicates[5]){this.boundaryAreaExteriorLine_(t,e,s);const i=this.isPredicateKnown_(5);n&&=i}if(this.m_performPredicates[6]){this.exteriorAreaInteriorLine_(t,e);const s=this.isPredicateKnown_(6);n&&=s}if(this.m_performPredicates[7]){this.exteriorAreaBoundaryLine_(t,e,s,this.m_clusterIndexB);const i=this.isPredicateKnown_(7);n&&=i}return n}lineLinePredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const i=this.isPredicateKnown_(0);n&&=i}if(this.m_performPredicates[1]){this.interiorLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB,1);const i=this.isPredicateKnown_(1);n&&=i}if(this.m_performPredicates[2]){this.interiorLineExteriorLine_(t,e,s,2);const i=this.isPredicateKnown_(2);n&&=i}if(this.m_performPredicates[3]){this.interiorLineBoundaryLine_(t,s,e,this.m_clusterIndexB,this.m_clusterIndexA,3);const i=this.isPredicateKnown_(3);n&&=i}if(this.m_performPredicates[4]){this.boundaryLineBoundaryLine_(t,e,s,this.m_clusterIndexA,this.m_clusterIndexB);const i=this.isPredicateKnown_(4);n&&=i}if(this.m_performPredicates[5]){this.boundaryLineExteriorLine_(t,e,s,this.m_clusterIndexA,5);const i=this.isPredicateKnown_(5);n&&=i}if(this.m_performPredicates[6]){this.interiorLineExteriorLine_(t,s,e,6);const i=this.isPredicateKnown_(6);n&&=i}if(this.m_performPredicates[7]){this.boundaryLineExteriorLine_(t,s,e,this.m_clusterIndexB,7);const i=this.isPredicateKnown_(7);n&&=i}return n}areaPointPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorAreaInteriorPoint_(t,e);const s=this.isPredicateKnown_(0);n&&=s}if(this.m_performPredicates[2]){this.interiorAreaExteriorPoint_(t,e);const s=this.isPredicateKnown_(2);n&&=s}if(this.m_performPredicates[3]){this.boundaryAreaInteriorPoint_(t,e,s);const i=this.isPredicateKnown_(3);n&&=i}if(this.m_performPredicates[5]){this.boundaryAreaExteriorPoint_(t,e);const s=this.isPredicateKnown_(5);n&&=s}if(this.m_performPredicates[6]){this.exteriorAreaInteriorPoint_(t,e);const s=this.isPredicateKnown_(6);n&&=s}return n}linePointPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(0);n&&=i}if(this.m_performPredicates[2]){this.interiorLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(2);n&&=i}if(this.m_performPredicates[3]){this.boundaryLineInteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(3);n&&=i}if(this.m_performPredicates[5]){this.boundaryLineExteriorPoint_(t,e,s,this.m_clusterIndexA);const i=this.isPredicateKnown_(5);n&&=i}if(this.m_performPredicates[6]){this.exteriorLineInteriorPoint_(t,e,s);const i=this.isPredicateKnown_(6);n&&=i}return n}pointPointPredicates_(t,e,s){let n=!0;if(this.m_performPredicates[0]){this.interiorPointInteriorPoint_(t,e,s);const i=this.isPredicateKnown_(0);n&&=i}if(this.m_performPredicates[2]){this.interiorPointExteriorPoint_(t,e,s,2);const i=this.isPredicateKnown_(2);n&&=i}if(this.m_performPredicates[6]){this.interiorPointExteriorPoint_(t,s,e,6);const i=this.isPredicateKnown_(6);n&&=i}return n}interiorAreaInteriorArea_(t,e,s){if(2===this.m_matrix[0])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t);0!==(n&e)&&0!==(n&s)&&(this.m_matrix[0]=2)}interiorAreaBoundaryArea_(t,e,s){if(1===this.m_matrix[s])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t),i=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));0!==(n&e)&&0!==(i&e)&&(this.m_matrix[s]=1)}interiorAreaExteriorArea_(t,e,s,n){if(2===this.m_matrix[n])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t);0!==(i&e)&&0===(i&s)&&(this.m_matrix[n]=2)}boundaryAreaBoundaryArea_(t,e,s){if(1===this.m_matrix[4])return;const n=this.m_topoGraph.getHalfEdgeParentage(t);if(0===(n&e)||0===(n&s)){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const n=this.m_topoGraph.getHalfEdgeTo(t),i=this.m_topoGraph.getClusterParentage(n);if(0!==(i&e)&&0!==(i&s))return void(this.m_matrix[4]=0)}}else this.m_matrix[4]=1}boundaryAreaExteriorArea_(t,e,s,n){if(1===this.m_matrix[n])return;const i=this.m_topoGraph.getHalfEdgeFaceParentage(t),r=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));0===(i&s)&&0===(r&s)&&(this.m_matrix[n]=1)}interiorAreaInteriorLine_(t,e,s){if(1===this.m_matrix[0])return;const n=this.m_topoGraph.getHalfEdgeFaceParentage(t),i=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));0!==(n&e)&&0!==(i&e)&&(this.m_matrix[0]=1)}interiorAreaBoundaryLine_(t,e,s,n){if(0!==this.m_matrix[1]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(0===(r&e)&&0!==(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e)){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(0!==(r&s)&&t%2!=0)return void(this.m_matrix[1]=0)}}}interiorAreaExteriorLine_(t,e,s){2!==this.m_matrix[2]&&0!==(this.m_topoGraph.getHalfEdgeParentage(t)&e)&&(this.m_matrix[2]=2)}boundaryAreaInteriorLine_(t,e,s,n){if(1===this.m_matrix[3])return;const i=this.m_topoGraph.getHalfEdgeParentage(t);if(0===(i&e)||0===(i&s)){if(0!==this.m_matrix[3]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(0!==(r&e)){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(0!==(r&s)&&t%2==0)return void(this.m_matrix[3]=0)}}}else this.m_matrix[3]=1}boundaryAreaBoundaryLine_(t,e,s,n){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(0!==(r&e)){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(0!==(r&s)&&t%2!=0)return void(this.m_matrix[4]=0)}}}boundaryAreaExteriorLine_(t,e,s){if(1===this.m_matrix[5])return;const n=this.m_topoGraph.getHalfEdgeParentage(t);0!==(n&e)&&0===(n&s)&&(this.m_matrix[5]=1)}exteriorAreaInteriorLine_(t,e){if(1===this.m_matrix[6])return;const s=this.m_topoGraph.getHalfEdgeFaceParentage(t),n=this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t));0===(s&e)&&0===(n&e)&&(this.m_matrix[6]=1)}exteriorAreaBoundaryLine_(t,e,s,n){if(0!==this.m_matrix[7]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const i=this.m_topoGraph.getHalfEdgeTo(t),r=this.m_topoGraph.getClusterParentage(i);if(0===(r&e)&&0===(this.m_topoGraph.getHalfEdgeFaceParentage(t)&e)){const t=this.m_topoGraph.getClusterUserIndex(i,n);if(0!==(r&s)&&t%2!=0)return void(this.m_matrix[7]=0)}}}interiorLineInteriorLine_(t,e,s,n,i){if(1===this.m_matrix[0])return;const r=this.m_topoGraph.getHalfEdgeParentage(t);if(0===(r&e)||0===(r&s)){if(0!==this.m_matrix[0]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const r=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(r);if(0!==(o&e)&&0!==(o&s)){const t=this.m_topoGraph.getClusterUserIndex(r,n),e=this.m_topoGraph.getClusterUserIndex(r,i);if(t%2==0&&e%2==0)return void(this.m_matrix[0]=0)}}}else this.m_matrix[0]=1}interiorLineBoundaryLine_(t,e,s,n,i,r){if(0!==this.m_matrix[r]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const o=this.m_topoGraph.getHalfEdgeTo(t),a=this.m_topoGraph.getClusterParentage(o);if(0!==(a&e)&&0!==(a&s)){const t=this.m_topoGraph.getClusterUserIndex(o,n),e=this.m_topoGraph.getClusterUserIndex(o,i);if(t%2==0&&e%2!=0)return void(this.m_matrix[r]=0)}}}interiorLineExteriorLine_(t,e,s,n){if(1===this.m_matrix[n])return;const i=this.m_topoGraph.getHalfEdgeParentage(t);0!==(i&e)&&0===(i&s)&&(this.m_matrix[n]=1)}boundaryLineBoundaryLine_(t,e,s,n,i){if(0!==this.m_matrix[4]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const r=this.m_topoGraph.getHalfEdgeTo(t),o=this.m_topoGraph.getClusterParentage(r);if(0!==(o&e)&&0!==(o&s)){const t=this.m_topoGraph.getClusterUserIndex(r,n),e=this.m_topoGraph.getClusterUserIndex(r,i);if(t%2!=0&&e%2!=0)return void(this.m_matrix[4]=0)}}}boundaryLineExteriorLine_(t,e,s,n,i){if(0!==this.m_matrix[i]&&1!==this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgePrev(this.m_topoGraph.getHalfEdgeTwin(t)),this.m_visitedIndex)){const e=this.m_topoGraph.getHalfEdgeTo(t);if(0===(this.m_topoGraph.getClusterParentage(e)&s)&&this.m_topoGraph.getClusterUserIndex(e,n)%2!=0)return void(this.m_matrix[i]=0)}}interiorAreaInteriorPoint_(t,e){if(0!==this.m_matrix[0]&&0===(this.m_topoGraph.getClusterParentage(t)&e)){const s=this.m_topoGraph.getClusterChain(t);if(0!==(this.m_topoGraph.getChainParentage(s)&e))return void(this.m_matrix[0]=0)}}interiorAreaExteriorPoint_(t,e){2!==this.m_matrix[2]&&0!==(this.m_topoGraph.getClusterParentage(t)&e)&&(this.m_matrix[2]=2)}boundaryAreaInteriorPoint_(t,e,s){if(0===this.m_matrix[3])return;const n=this.m_topoGraph.getClusterParentage(t);0===(n&e)||0===(n&s)||(this.m_matrix[3]=0)}boundaryAreaExteriorPoint_(t,e){1!==this.m_matrix[5]&&0!==(this.m_topoGraph.getClusterParentage(t)&e)&&(this.m_matrix[5]=1)}exteriorAreaInteriorPoint_(t,e){if(0!==this.m_matrix[6]&&0===(this.m_topoGraph.getClusterParentage(t)&e)){const s=this.m_topoGraph.getClusterChain(t);if(0===(this.m_topoGraph.getChainParentage(s)&e))return void(this.m_matrix[6]=0)}}interiorLineInteriorPoint_(t,e,s,n){if(0===this.m_matrix[0])return;const i=this.m_topoGraph.getClusterParentage(t);0===(i&e)||0===(i&s)||this.m_topoGraph.getClusterUserIndex(t,n)%2!=0||(this.m_matrix[0]=0)}interiorLineExteriorPoint_(t,e,s,n){if(1!==this.m_matrix[2])if(-1===this.m_topoGraph.getClusterHalfEdge(t)){if(0!==this.m_matrix[2]&&0===(this.m_topoGraph.getClusterParentage(t)&s))return void(this.m_matrix[2]=0)}else this.m_matrix[2]=1}boundaryLineInteriorPoint_(t,e,s,n){if(0===this.m_matrix[3])return;const i=this.m_topoGraph.getClusterParentage(t);0===(i&e)||0===(i&s)||this.m_topoGraph.getClusterUserIndex(t,n)%2==0||(this.m_matrix[3]=0)}boundaryLineExteriorPoint_(t,e,s,n){if(0===this.m_matrix[5])return;const i=this.m_topoGraph.getClusterParentage(t);0===(i&e)||0!==(i&s)||this.m_topoGraph.getClusterUserIndex(t,n)%2==0||(this.m_matrix[5]=0)}exteriorLineInteriorPoint_(t,e,s){if(0===this.m_matrix[6])return;const n=this.m_topoGraph.getClusterParentage(t);0!==(n&e)||0===(n&s)||(this.m_matrix[6]=0)}interiorPointInteriorPoint_(t,e,s){if(0===this.m_matrix[0])return;const n=this.m_topoGraph.getClusterParentage(t);0===(n&e)||0===(n&s)||(this.m_matrix[0]=0)}interiorPointExteriorPoint_(t,e,s,n){if(0===this.m_matrix[n])return;const i=this.m_topoGraph.getClusterParentage(t);0===(i&e)||0!==(i&s)||(this.m_matrix[n]=0)}computeMatrixTopoGraphHalfEdges_(t,e){let s=!1;const n=this.m_topoGraph.getGeometryID(t),i=this.m_topoGraph.getGeometryID(e);this.m_visitedIndex=this.m_topoGraph.createUserIndexForHalfEdges();for(let t=this.m_topoGraph.getFirstCluster();t!==Ar;t=this.m_topoGraph.getNextCluster(t)){const e=this.m_topoGraph.getClusterHalfEdge(t);if(e===Ar){if(null!==this.m_predicatesCluster&&(s=this.m_predicatesCluster(t,n,i),s))break;continue}let r=e;do{let t=r;if(1!==this.m_topoGraph.getHalfEdgeUserIndex(t,this.m_visitedIndex))do{if(s=this.m_predicatesHalfEdge(t,n,i),s)break;this.m_topoGraph.setHalfEdgeUserIndex(t,this.m_visitedIndex,1),t=this.m_topoGraph.getHalfEdgeNext(t)}while(t!==r&&!s);if(s)break;r=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(t))}while(r!==e);if(s)break}s||this.setRemainingPredicatesToFalse_(),this.m_topoGraph.deleteUserIndexForHalfEdges(this.m_visitedIndex)}computeMatrixTopoGraphClusters_(t,e){let s=!1;const n=this.m_topoGraph.getGeometryID(t),i=this.m_topoGraph.getGeometryID(e);for(let t=this.m_topoGraph.getFirstCluster();t!==Ar&&(s=this.m_predicatesCluster(t,n,i),!s);t=this.m_topoGraph.getNextCluster(t));s||this.setRemainingPredicatesToFalse_()}setEditShape_(t,e){this.m_topoGraph.setEditShape(t,e)}setEditShapeCrackAndCluster_(t,e,s){let n=0;if(t.hasCurves()){const i=new Tc,r=t.getEnvelope2D(s),o=bc(e.total(),r);n=Dc(o,0),Ec(t,o,e.total(),0,i,null,s),i.clearStitcher(t)}Ac(t,e.add(n),s,!1,!1),t.filterClosePoints(0,!0,!0,!1,Ar);for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e))t.getGeometryType(e)===o.enumPolygon&&Zl(t,e,-1,!1,Ar,s);this.setEditShape_(t,s)}}function hu(t){const e=t[1],s=t[2],n=t[5];t[1]=t[3],t[2]=t[6],t[5]=t[7],t[3]=e,t[6]=s,t[7]=n}function mu(e,s,n){const i=e.getGeometryType();if(F(i)){const t=new Wn({vd:e.getDescription()});return t.addSegment(e,!0),t}if(i===o.enumEnvelope){const n=e,i=t.constructEmpty();if(e.queryEnvelope(i),i.height()<=s&&i.width()<=s){const t=new qe({vd:e.getDescription()});return n.getCenter(t),t}if(i.height()<=s||i.width()<=s){const t=new Wn({vd:e.getDescription()}),s=new qe;return n.queryCornerByVal(0,s),t.startPathPoint(s),n.queryCornerByVal(2,s),t.lineToPoint(s),t}const r=new Tr({vd:e.getDescription()});return r.addEnvelope(n,!1),r}return e}function lu(t){return`${t[0]}${t[3]}${t[6]}${t[1]}${t[4]}${t[7]}${t[2]}${t[5]}${t[8]}`}class uu{nullFunc(){return P("should not be called"),!1}constructor(e,s,n,i=!1){this.m_bDone=!1,this.m_tolerance=0,this.m_elementHandle=-1,this.m_query=t.constructEmpty(),this.m_envInter=t.constructEmpty(),this.m_quadTree=null,this.m_intersector=null,this.m_function=this.nullFunc;const r=e.getAccelerators();let o=null;null!=r&&(o=i?r.getQuadTreeForPaths():r.getQuadTree());const a=s.getAccelerators();let h=null;if(null!=a&&(h=i?a.getQuadTreeForPaths():a.getQuadTree()),null===o&&null===h&&!i){const i=e.getPointCount(),r=s.getPointCount();if(i>10&&r>10){const a=t.constructEmpty(),m=t.constructEmpty(),l=t.constructEmpty();e.queryLooseEnvelope(a),s.queryLooseEnvelope(m),a.inflateCoords(n,n),m.inflateCoords(n,n),l.setCoords({env2D:a}),l.intersect(m),i>=r?o=Z(e.getGeometryType())?Le(e,l):_s(e,l):h=Z(s.getGeometryType())?Le(s,l):_s(s,l)}}this.construct_(e,o,s,h,n,i)}next(){if(this.m_bQuadTree){if(this.m_bDone)return!1;for(;this.m_function(););return!this.m_bDone}return!!this.m_intersector&&this.m_intersector.next()}getRedElement(){return this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElement(this.m_elementHandle):Z(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_bSwapElements?this.m_intersector.getBlueElement(this.m_intersector.getHandleB()):this.m_intersector.getRedElement(this.m_intersector.getHandleA())}getBlueElement(){return this.m_bQuadTree?this.m_bSwapElements?Z(this.m_queryType)?this.m_bPaths?this.m_pathIndex:this.m_segIter.getStartPointIndex():this.m_pointIndex:this.m_quadTree.getElement(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedElement(this.m_intersector.getHandleA()):this.m_intersector.getBlueElement(this.m_intersector.getHandleB())}getRedEnvelope(){return this.m_bPaths||K(""),this.m_bQuadTree?this.m_bSwapElements?this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_query:this.m_bSwapElements?this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB()):this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA())}getBlueEnvelope(){return this.m_bPaths||K(""),this.m_bQuadTree?this.m_bSwapElements?this.m_query:this.m_quadTree.getElementExtent(this.m_elementHandle):this.m_bSwapElements?this.m_intersector.getRedEnvelope(this.m_intersector.getHandleA()):this.m_intersector.getBlueEnvelope(this.m_intersector.getHandleB())}construct_(e,s,n,i,r,a){const h=t.constructEmpty(),m=t.constructEmpty();e.queryLooseEnvelope(h),n.queryLooseEnvelope(m),h.inflateCoords(r,r),m.inflateCoords(r,r),this.m_envInter.setCoords({env2D:h}),this.m_envInter.intersect(m),this.m_multiVertexImplA=e,this.m_multiVertexImplB=n;const l=e.getGeometryType(),u=n.getGeometryType();this.m_bPaths=a,this.m_pathIndex=-1,this.m_pointIndex=-1,this.m_bSwapElements=!1,this.m_queryType=o.enumUnknown,this.m_bQuadTree=!1,null!==s&&(this.m_bDone=!1,this.m_tolerance=r,this.m_quadTree=s,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!0,Z(u)?(this.m_queryType=u,this.m_function=this.nextPath_,a?this.m_pathIndex=n.getPathCount():this.m_segIter=n.querySegmentIterator()):(this.m_queryType=u,this.m_function=this.nextPoint_,this.m_pointIndex=n.getPointCount())),this.m_bQuadTree||null!==i&&(this.m_bDone=!1,this.m_tolerance=r,this.m_quadTree=i,this.m_qtIter=this.m_quadTree.getIteratorForQT(),this.m_bQuadTree=!0,this.m_bSwapElements=!1,Z(l)?(this.m_queryType=l,this.m_function=this.nextPath_,a?this.m_pathIndex=e.getPathCount():this.m_segIter=e.querySegmentIterator()):(this.m_queryType=l,this.m_function=this.nextPoint_,this.m_pointIndex=e.getPointCount())),this.m_bQuadTree||(a&&Z(l)&&Z(u)?this.m_intersector=ys(e,n,r):Z(l)&&Z(u)?(this.m_intersector=ps(e,n,r),this.m_bSwapElements=!1):Z(l)&&!Z(u)?(this.m_intersector=fs(e,n,r),this.m_bSwapElements=!1):!Z(l)&&Z(u)?(this.m_intersector=fs(n,e,r),this.m_bSwapElements=!0):(this.m_intersector=xs(e,n,r),this.m_bSwapElements=!1))}nextPath_(){return this.m_bPaths?-1===--this.m_pathIndex?(this.m_bDone=!0,!1):(this.m_bSwapElements?this.m_multiVertexImplB.queryPathEnvelope(this.m_pathIndex,this.m_query):this.m_multiVertexImplA.queryPathEnvelope(this.m_pathIndex,this.m_query),this.m_qtIter.resetIterator(this.m_query,this.m_tolerance),this.m_function=this.iterate_,!0):this.m_segIter.nextPath()?(this.m_function=this.nextSegment_,!0):(this.m_bDone=!0,!1)}nextSegment_(){if(!this.m_segIter.hasNextSegment())return this.m_function=this.nextPath_,!0;const e=this.m_segIter.nextSegment(),s=new t;return e.queryLooseEnvelope(s),!s.isIntersecting(this.m_envInter)||(this.m_qtIter.resetIterator(e,this.m_tolerance),this.m_function=this.iterate_,!0)}nextPoint_(){if(-1===--this.m_pointIndex)return this.m_bDone=!0,!1;const e=new l;if(this.m_bSwapElements){const t=this.m_multiVertexImplB.getXY(this.m_pointIndex);e.setCoordsPoint2D(t)}else{const t=this.m_multiVertexImplA.getXY(this.m_pointIndex);e.setCoordsPoint2D(t)}return!this.m_envInter.contains(e)||(this.m_qtIter.resetIterator(t.construct(e.x,e.y,e.x,e.y),this.m_tolerance),this.m_function=this.iterate_,!0)}iterate_(){return this.m_elementHandle=this.m_qtIter.next(),-1===this.m_elementHandle&&(Z(this.m_queryType)?(this.m_function=this.m_bPaths?this.nextPath_:this.nextSegment_,!0):(this.m_function=this.nextPoint_,!0))}}function cu(t){return 2===t?1:1===t?2:128===t?64:64===t?128:t}function gu(e,s,n){let i;if(e instanceof wp||null===e){const r=t.constructEmpty();r.setCoords({env2D:s}),r.mergeEnvelope2D(n),i=Ze(e,r,!1)}else i=e;return i}function du(e,s,n,i,r){if(e.isEmpty()||s.isEmpty())return 4===i;Xt(e),Xt(s);let a=e.getGeometryType(),h=s.getGeometryType();if(a===o.enumEnvelope){if(h===o.enumEnvelope)return function(e,s,n,i){if(e.isEmpty()||s.isEmpty())return 4===i;const r=t.constructEmpty();e.queryEnvelope(r);const o=t.constructEmpty();s.queryEnvelope(o);const a=gu(n,r,o);switch(i){case 4:return pu(r,o,a);case 2:return zu(o,r,a,!1);case 128:return zu(o,r,a,!0);case 1:return zu(r,o,a,!1);case 64:return zu(r,o,a,!0);case 3:return Uu(r,o,a);case 8:return function(e,s,n){if(e.height()<=n||e.width()<=n||s.height()<=n||s.width()<=n)return!1;const i=new t;return i.setCoords({env2D:e}),i.inflateCoords(-n,-n),i.intersect(s),!(!i.isEmpty()&&i.height()>n&&i.width()>n||(i.setCoords({env2D:e}),i.inflateCoords(n,n),i.intersect(s),i.isEmpty()))}(r,o,a);case 32:return function(e,s,n){if(e.height()<=n||e.width()<=n||s.height()<=n||s.width()<=n)return!1;if(ju(e,s,n))return!1;if(ju(s,e,n))return!1;const i=new t;return i.setCoords({env2D:e}),i.inflateCoords(-n,-n),i.intersect(s),!i.isEmpty()&&(i.height()>n||i.width()>n)}(r,o,a);case 16:return!1}return!1}(e,s,n,i);if(h===o.enumPoint)return _u(s,e,n,cu(i))}else if(a===o.enumPoint){if(h===o.enumEnvelope)return _u(e,s,n,i);if(h===o.enumPoint)return function(e,s,n,i){if(e.isEmpty()||s.isEmpty())return 4===i;const r=e.getXY(),o=s.getXY();let a;if(n instanceof wp||null===n){const e=t.constructEmpty();e.setCoords({pt:r}),e.merge(o),a=Ze(n,e,!1)}else a=n;switch(i){case 4:return function(t,e,s){return l.sqrDistance(t,e)>s*s}(r,o,a);case 2:case 128:return Bu(o,r,a);case 1:case 64:return Bu(r,o,a);case 3:return Hu(r,o,a)}return!1}(e,s,n,i)}const m=t.constructEmpty();e.queryEnvelope(m);const u=t.constructEmpty();s.queryEnvelope(u);const c=gu(n,m,u);if(pu(m,u,c))return 4===i;let g=!1,d=null,_=null,p=null,f=null;switch(F(a)?(d=new Wn({vd:e.getDescription()}),d.addSegment(e,!0),p=d,a=o.enumPolyline):p=e,F(h)?(_=new Wn({vd:s.getDescription()}),_.addSegment(s,!0),f=_,h=o.enumPolyline):f=s,a!==o.enumEnvelope&&h!==o.enumEnvelope?(p.getDimension()<f.getDimension()||a===o.enumPoint&&h===o.enumMultiPoint)&&(i=cu(i)):a!==o.enumPolygon&&h!==o.enumEnvelope&&(i=cu(i)),a){case o.enumPolygon:switch(h){case o.enumPolygon:g=function(t,e,s,n,i){switch(n){case 4:return function(t,e,s){return fu(t,e,0,!0),1===Ou(t,e,s,!0)}(t,e,s);case 2:return Tu(e,t,s,i);case 128:return Nu(e,t,s);case 1:return Tu(t,e,s,i);case 64:return Nu(t,e,s);case 3:return Du(t,e,s,i);case 8:return function(t,e,s){return fu(t,e),oc(t,e,s,null)}(t,e,s);case 32:return function(t,e,s,n){return fu(t,e),ac(t,e,s,n)}(t,e,s,i)}return!1}(p,f,c,i,r);break;case o.enumPolyline:g=yu(p,f,c,i,r);break;case o.enumPoint:g=Pu(p,f,c,i);break;case o.enumMultiPoint:g=Cu(p,f,c,i);break;case o.enumEnvelope:g=Eu(p,f,c,i,r)}break;case o.enumPolyline:switch(h){case o.enumPolygon:g=yu(f,p,c,i,r);break;case o.enumPolyline:g=function(e,s,n,i,r){switch(i){case 4:return function(t,e,s){fu(t,e);const n=t.getImpl(),i=e.getImpl();return!new uu(n,i,s,!0).next()||!ec(t,e,s)}(e,s,n);case 2:return Fu(s,e,n,r);case 128:return Vu(s,e,n,r);case 1:return Fu(e,s,n,r);case 64:return Vu(e,s,n,r);case 3:return function(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!Uu(r,o,n)&&(fu(e,s),!!Ku(e,s,n)||(e.hasNonLinearSegments()||s.hasNonLinearSegments()?Kl(e,s,n,"**F**FFF*",i,!1):$u(e,s,n,!1)))}(e,s,n,r);case 8:return function(e,s,n,i){fu(e,s);const r=[],o=sc(e,s,n,r);if(-2===o){const r=t.constructEmpty(),o=t.constructEmpty(),a=t.constructEmpty();let h,m;if(e.queryEnvelope(r),s.queryEnvelope(o),r.inflateCoords(1e3*n,1e3*n),o.inflateCoords(1e3*n,1e3*n),a.setCoords({env2D:r}),a.intersect(o),e.getPointCount()>10){if(h=Pm(e,a,n,0,i),h.isEmpty())return!1}else h=e;if(s.getPointCount()>10){if(m=Pm(s,a,n,0,i),m.isEmpty())return!1}else m=s;return Kl(h,m,n,"F********",i,!1)}if(0!==o)return!1;const a=new Fs;for(let t=0;t<r.length;t+=2){const e=r[t],s=r[t+1];a.addXY(e,s)}const h=e.getBoundary(),m=s.getBoundary();return h.addPoints(m,0,m.getPointCount()),!h.isEmpty()&&Xu(h,a,n)}(e,s,n,r);case 32:return function(e,s,n,i){fu(e,s);const r=t.constructEmpty(),o=t.constructEmpty();e.queryEnvelope(r),s.queryEnvelope(o);const a=Qu(r,o,n),h=Qu(o,r,n),m=e.hasNonLinearSegments(),l=s.hasNonLinearSegments(),u=sc(e,s,n,null);if(-1===u)return!1;if(1===u){if(a&&h)return!0;if(!m&&!l)return a&&!h?!tc(s,e,n,!1):h&&!a?!tc(e,s,n,!1):!tc(e,s,n,!1)&&!tc(s,e,n,!1)}const c=t.constructEmpty(),g=t.constructEmpty(),d=t.constructEmpty();let _,p;c.setCoords({env2D:r}),c.inflateCoords(1e3*n,1e3*n),g.setCoords({env2D:o}),g.inflateCoords(1e3*n,1e3*n),d.setCoords({env2D:c}),d.intersect(g);let f="";if(f+="1*",a){if(s.getPointCount()>10){if(p=Pm(s,d,n,0,i),p.isEmpty())return!1}else p=s;f+="****"}else p=s,f+="T***";if(h){if(e.getPointCount()>10){if(_=Pm(e,d,n,0,i),_.isEmpty())return!1}else _=e;f+="***"}else _=e,f+="T**";return Kl(_,p,n,f,i,!1)}(e,s,n,r);case 16:return function(e,s,n,i){fu(e,s);const r=[],o=sc(e,s,n,r);if(-2===o){const r=t.constructEmpty(),o=t.constructEmpty(),a=t.constructEmpty();let h,m;if(e.queryEnvelope(r),s.queryEnvelope(o),r.inflateCoords(1e3*n,1e3*n),o.inflateCoords(1e3*n,1e3*n),a.setCoords({env2D:r}),a.intersect(o),e.getPointCount()>10){if(h=Pm(e,a,n,0,i),h.isEmpty())return!1}else h=e;if(s.getPointCount()>10){if(m=Pm(s,a,n,0,i),m.isEmpty())return!1}else m=s;return Kl(h,m,n,"0********",i,!1)}if(0!==o)return!1;const a=new Fs;for(let t=0;t<r.length;t+=2){const e=r[t],s=r[t+1];a.addXY(e,s)}const h=e.getBoundary(),m=s.getBoundary();return h.addPoints(m,0,m.getPointCount()),!!h.isEmpty()||!Xu(h,a,n)}(e,s,n,r)}return!1}(p,f,c,i,r);break;case o.enumPoint:g=Su(p,f,c,i);break;case o.enumMultiPoint:g=vu(p,f,c,i);break;case o.enumEnvelope:g=Iu(p,f,c,i,r)}break;case o.enumPoint:switch(h){case o.enumPolygon:g=Pu(f,p,c,i);break;case o.enumPolyline:g=Su(f,p,c,i);break;case o.enumMultiPoint:g=bu(f,p,c,i)}break;case o.enumMultiPoint:switch(h){case o.enumPolygon:g=Cu(f,p,c,i);break;case o.enumPolyline:g=vu(f,p,c,i);break;case o.enumMultiPoint:g=function(e,s,n,i){switch(i){case 4:return function(t,e,s){const n=t,i=e,r=new uu(n,i,s,!1),o=s*s,a=new l,h=new l;for(;r.next();){const t=r.getRedElement(),e=r.getBlueElement();if(n.queryXY(t,a),i.queryXY(e,h),l.sqrDistance(a,h)<=o)return!1}return!0}(e,s,n);case 2:case 128:return Xu(s,e,n);case 1:case 64:return Xu(e,s,n);case 3:return function(e,s,n){const i=t.constructEmpty(),r=t.constructEmpty();return e.queryEnvelope(i),s.queryEnvelope(r),!!Uu(i,r,n)&&(!!function(t,e,s){if(t.getPointCount()!==e.getPointCount())return!1;const n=new l,i=new l;let r=!0;const o=s*s;for(let s=0;s<t.getPointCount();s++)if(t.queryXY(s,n),e.queryXY(s,i),l.sqrDistance(n,i)>o){r=!1;break}return!!r}(e,s,n)||Ju(e,s,n,!1,!0,!1))}(e,s,n);case 32:return function(t,e,s){return Ju(t,e,s,!1,!1,!0)}(e,s,n)}return!1}(p,f,c,i);break;case o.enumPoint:g=bu(p,f,c,i);break;case o.enumEnvelope:g=wu(p,f,c,i)}break;case o.enumEnvelope:switch(h){case o.enumPolygon:g=Eu(f,p,c,i,r);break;case o.enumPolyline:g=Iu(f,p,c,i,r);break;case o.enumMultiPoint:g=wu(f,p,c,i)}}return g}function _u(e,s,n,i,r){if(e.isEmpty()||s.isEmpty())return 4===i;const o=e.getXY(),a=t.constructEmpty();s.queryEnvelope(a);const h=function(e,s,n){let i;if(e instanceof wp||null===e){const r=t.constructEmpty();r.setCoords({pt:s}),r.mergeEnvelope2D(n),i=Ze(e,r,!1)}else i=e;return i}(n,o,a);switch(i){case 4:return xu(o,a,h);case 2:case 128:return function(e,s,n){if(s.height()<=n||s.width()<=n)return!1;const i=t.constructEmpty();return i.setCoords({env2D:s}),i.inflateCoords(-n,-n),i.containsExclusive(e)}(o,a,h);case 1:case 64:return!1;case 3:return function(e,s,n){const i=new t;return i.setCoords({pt:e}),Uu(i,s,n)}(o,a,h);case 8:return function(e,s,n){if(s.height()<=n||s.width()<=n)return!1;const i=new t,r=new t;return i.setCoords({env2D:s}),i.inflateCoords(n,n),!!i.contains(e)&&(r.setCoords({env2D:s}),r.inflateCoords(-n,-n),!r.containsExclusive(e))}(o,a,h)}return!1}function pu(e,s,n){const i=t.constructEmpty();return i.setCoords({env2D:s}),i.inflateCoords(n,n),!e.isIntersecting(i)}function fu(t,s,i,r=!1){const o=t.getGeometryType(),a=s.getGeometryType();if(e(o)){const e=t.getImpl().getAccelerators();if(null!==e){const t=e.getRasterizedGeometry();n(null===t)}}if(e(a)){const t=s.getImpl().getAccelerators();if(null!==t){const e=t.getRasterizedGeometry();n(null===e)}}return 0}function xu(e,s,n,i){const r=t.constructEmpty();return r.setCoords({env2D:s}),r.inflateCoords(n,n),!r.contains(e)}function yu(e,s,n,i,r){switch(i){case 4:return function(t,e,s){return fu(t,e,0,!0),1===Ou(t,e,s,!0)}(e,s,n);case 1:return function(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!ju(r,o,n)&&(fu(e,s),function(e,s,n,i){const r=[!1],o=Wu(e,s,n,r);if(r[0])return o;const a=t.constructEmpty();let h;if(s.queryEnvelope(a),a.inflateCoords(1e3*n,1e3*n),e.getPointCount()>10){if(h=Pm(e,a,n,0,i),h.isEmpty())return!1}else h=e;return function(e,s,n,i){const r=new au;r.resetMatrix_(),r.setPredicates_("T*****F**"),r.setAreaLinePredicates_();const o=t.constructEmpty(),a=t.constructEmpty();e.queryEnvelope(o),s.queryEnvelope(a);let h=!1;if(pu(o,a,n)&&(r.areaLineDisjointPredicates_(e,s),h=!0),h||fu(e,s),h)return ru(r.m_matrix,r.m_scl);const m=new Vr,l=m.addGeometry(e),u=m.addGeometry(s);return r.setEditShapeCrackAndCluster_(m,new cs(n,0),i),0!==m.getPointCount(l)&&(r.computeMatrixTopoGraphHalfEdges_(l,u),r.m_topoGraph.removeShape(),ru(r.m_matrix,r.m_scl))}(h,s,n,i)}(e,s,n,i))}(e,s,n,r);case 64:return function(e,s,n){const i=t.constructEmpty(),r=t.constructEmpty();return e.queryEnvelope(i),s.queryEnvelope(r),!!ju(i,r,n)&&(fu(e,s),2===Ou(e,s,n,!1))}(e,s,n);case 8:return Au(e,s,n,r);case 16:return function(e,s,n){return fu(e,s),function(e,s,n,i){const r=e.getImpl(),o=s.getImpl(),a=r.querySegmentIterator(),m=o.querySegmentIterator(),l=h(2,Number.NaN),u=h(2,Number.NaN),c=new uu(r,o,n);let g=!1;for(;c.next();){const t=c.getRedElement(),e=c.getBlueElement();a.resetToVertex(t,-1),m.resetToVertex(e,-1);const s=a.nextSegment(),i=m.nextSegment();let r=0;if(uc(s,i)?!g&&i.isIntersecting(s,n)&&(g=!0):r=i.intersect(s,null,u,l,n),2===r)g=!0;else if(r){const t=l[0],e=u[0];if(t>0&&t<1&&e>0&&e<1)return!0;g=!0}}if(!g)return!1;const d=t.constructEmpty(),_=t.constructEmpty(),p=t.constructEmpty(),f=t.constructEmpty(),x=t.constructEmpty();if(e.queryEnvelope(d),s.queryEnvelope(_),Qu(_,d,n)){let t,r;if(p.setCoords({env2D:d}),p.inflateCoords(1e3*n,1e3*n),f.setCoords({env2D:_}),f.inflateCoords(1e3*n,1e3*n),x.setCoords({env2D:p}),x.intersect(f),e.getPointCount()>10){if(t=Pm(e,x,n,0,i),t.isEmpty())return!1}else t=e;if(s.getPointCount()>10){if(r=Pm(s,x,n,0,i),r.isEmpty())return!1}else r=s;return Kl(t,r,n,"T********",i,!1)}return Kl(e,s,n,"T*****T**",i,!1)}(e,s,n,null)}(e,s,n)}return!1}function Pu(t,e,s,n,i){switch(n){case 4:return function(t,e,s){return 0===dc(t,e,s)}(t,e,s);case 1:case 64:return function(t,e,s){return function(t,e,s){return 1===_c(t,e,s)}(t,e.getXY(),s)}(t,e,s);case 8:return function(t,e,s){return function(t,e,s){return 2===_c(t,e,s)}(t,e.getXY(),s)}(t,e,s)}return!1}function Cu(e,s,n,i,r){switch(i){case 4:return function(e,s,n){fu(e,s);const i=function(e,s,n){const i=t.constructEmpty();e.queryEnvelope(i),i.inflateCoords(n,n);const r=new l,o=e.getImpl(),a=new Tr;let h=e,m=!1,u=!1,c=!1;for(let t=0;t<s.getPointCount();t++){if(s.queryXY(t,r),i.contains(r)){const t=_c(h,r,n);if(1===t)return u=!0,4;if(2===t)return 4;c=!0}else c=!0;m||(!Bl(e,s.getPointCount()-1)||null!==o.getAccelerators()&&null!=o.getAccelerators().getQuadTree()?h=e:(e.copyTo(a),a.getImpl().buildQuadTreeAccelerator(1),h=a),m=!0)}return u?c?4:2:1}(e,s,n);return 1===i}(e,s,n);case 1:return Mu(e,s,n,!1);case 64:return Mu(e,s,n,!0);case 8:return function(e,s,n){fu(e,s);const i=t.constructEmpty();e.queryEnvelope(i),i.inflateCoords(n,n);const r=new l;let o=!1;const a=e.getImpl(),h=new Tr;let m=e,u=!1;for(let t=0;t<s.getPointCount();t++){if(s.queryXY(t,r),i.contains(r)){const t=_c(m,r,n);if(2===t)o=!0;else if(1===t)return!1}u||(!Bl(e,s.getPointCount()-1)||null!==a.getAccelerators()&&null!==a.getAccelerators().getQuadTree()?m=e:(e.copyTo(h),h.getImpl().buildQuadTreeAccelerator(1),m=h),u=!0)}return!!o}(e,s,n);case 16:return function(e,s,n){fu(e,s);const i=new t,r=new t,o=new t;e.queryEnvelope(i),s.queryEnvelope(o),r.setCoords({env2D:i}),r.inflateCoords(n,n);let a=!1,h=!1;const m=new l,u=e.getImpl(),c=new Tr;let g=e,d=!1;for(let t=0;t<s.getPointCount();t++){if(s.queryXY(t,m),r.contains(m)){const t=_c(g,m,n);0===t?h=!0:1===t&&(a=!0)}else h=!0;if(a&&h)return!0;d||(!Bl(e,s.getPointCount()-1)||null!==u.getAccelerators()&&null!==u.getAccelerators().getQuadTree()?g=e:(e.copyTo(c),c.getImpl().buildQuadTreeAccelerator(1),g=c),d=!0)}return!1}(e,s,n)}return!1}function Eu(e,s,n,i,r){if(function(e,s,n){fu(e,s);const i=t.constructEmpty(),r=t.constructEmpty();return e.queryEnvelope(i),s.queryEnvelope(r),!ju(r,i,n)&&(0===_c(e,r.getLowerLeft(),0)&&!r.contains(e.getXY(0))&&!rc(e,r,n))}(e,s,n))return 4===i;if(4===i)return!1;switch(i){case 2:return Gu(e,s,n,!1);case 128:return Gu(e,s,n,!0);case 1:return qu(e,s,n,!1,r);case 64:return qu(e,s,n,!0,r);case 3:return function(e,s,n,i){const r=new t,o=new t;if(e.queryEnvelope(r),s.queryEnvelope(o),!Uu(r,o,n))return!1;const a=new Tr;return a.addEnvelope(s,!1),Du(e,a,n,i)}(e,s,n,r);case 8:return function(e,s,n,i){fu(e,s);const r=new t,o=new t;if(e.queryEnvelope(r),s.queryEnvelope(o),ju(o,r,n))return!1;if(o.height()<=n||o.width()<=n)return!1;const a=new Tr;return a.addEnvelope(s,!1),oc(e,a,n,i)}(e,s,n,r);case 32:return function(e,s,n,i){fu(e,s);const r=new t,o=new t;if(e.queryEnvelope(r),s.queryEnvelope(o),ju(o,r,n))return!1;if(o.height()<=n||o.width()<=n)return!1;const a=new Tr;return a.addEnvelope(s,!1),ac(e,a,n,i)}(e,s,n,r);case 16:return!1}return!1}function Su(t,e,s,n,i){switch(n){case 4:return function(t,e,s){return fu(t,e),!ic(t,e.getXY(),s)}(t,e,s);case 1:case 64:return function(t,e,s){return fu(t,e),function(t,e,s){return ic(t,e,s)&&!lc(t,e,s)}(t,e.getXY(),s)}(t,e,s);case 8:return function(t,e,s){return fu(t,e),lc(t,e.getXY(),s)}(t,e,s)}return!1}function vu(e,s,n,i,r){switch(i){case 4:return function(t,e,s){return fu(t,e),!nc(t,e,s,!1)}(e,s,n);case 1:case 64:return function(e,s,n){const i=t.constructEmpty(),r=t.constructEmpty();if(e.queryEnvelope(i),s.queryEnvelope(r),!ju(i,r,n))return!1;fu(e,s);const o=nc(e,s,n,!0);if(!o)return o;const a=e.getBoundary();return a.isEmpty()?o:!Xu(a,s,n)}(e,s,n);case 8:return function(t,e,s){fu(t,e);const n=t.getImpl(),i=e.getImpl(),r=new Fs,o=new uu(n,i,s,!1),a=n.querySegmentIterator();let h=!1;for(;o.next();){const t=o.getRedElement(),e=o.getBlueElement();a.resetToVertex(t,-1);const n=a.nextSegment(),m=i.getXY(e);n.isIntersectingPoint(m,s)&&(h=!0,r.addPoint2D(m))}if(!h)return!1;const m=t.getBoundary();return!m.isEmpty()&&Xu(m,r,s)}(e,s,n);case 16:return function(t,e,s){fu(t,e);const n=t.getImpl(),i=e.getImpl(),r=i.getPointCount(),o=h(r,!1),a=new uu(n,i,s,!1),m=n.querySegmentIterator();let l=!1;for(;a.next();){const t=a.getRedElement(),e=a.getBlueElement();m.resetToVertex(t,-1);const n=m.nextSegment(),r=i.getXY(e);n.isIntersectingPoint(r,s)&&(l=!0,o[e]=!0)}if(!l)return!1;let u=!1;for(let t=0;t<r;t++)if(!o[t]){u=!0;break}if(!u)return!1;const c=t.getBoundary();if(c.isEmpty())return!0;const g=new Fs;for(let t=0;t<r;t++)o[t]&&g.addPoint2D(i.getXY(t));return!Xu(c,g,s)}(e,s,n)}return!1}function Iu(e,s,i,r,a){if(function(e,s,n){const i=t.constructEmpty(),r=t.constructEmpty();e.queryEnvelope(i),s.queryEnvelope(r);const o=function(e,s,n){const i=t.constructEmpty();return i.setCoords({env2D:e}),i.inflateCoords(n,n),i.containsEnvelope(s)?1073741824:i.isIntersecting(s)?e.isIntersecting(s)?e.xmin<s.xmin&&s.xmax<e.xmax?s.ymin<e.ymin&&s.ymax>e.ymax?0:1073741824:e.ymin<s.ymin&&s.ymax<e.ymax?s.xmin<e.xmin&&s.xmax>e.xmax?0:1073741824:0:0:4}(r,i,n);return 0===o?!rc(e,r,n):4===o}(e,s,i))return 4===r;if(4===r)return!1;switch(r){case 2:return Yu(e,s,i,!1);case 128:return Yu(e,s,i,!0);case 1:case 64:case 32:return!1;case 3:return function(e,s,n){const i=new t,r=new t;return e.queryEnvelope(i),s.queryEnvelope(r),!(r.height()>n&&r.width()>n)&&Uu(i,r,n)}(e,s,i);case 8:return function(e,s,n,i){const r=new t,a=new t;if(e.queryEnvelope(r),s.queryEnvelope(a),a.height()<=n||a.width()<=n)return!1;const h=new t,m=new t;if(h.setCoords({env2D:a}),m.setCoords({env2D:a}),h.inflateCoords(n,n),m.inflateCoords(-n,-n),m.containsEnvelope(r)||!r.isIntersecting(h))return!1;const u=e.getImpl().querySegmentIterator();u.stripAttributes();const c=e.getImpl().getAccelerators();let g=null,d=null;null!==c&&(g=c.getQuadTree(),null!==g&&(d=g.getIterator(a,n))),d||u.nextPath()||P("relational_operations");let _=!1,p=null;const f=new l,x=new l,y=e.hasNonLinearSegments();let C=!1;for(;;){if(null!==d){const t=d.next();if(-1===t)break;u.resetToVertex(g.getElement(t),-1),p=u.nextSegment()}else{for(;!u.hasNextSegment()&&u.nextPath(););if(!u.hasNextSegment())break;p=u.nextSegment()}if(y&&p.getGeometryType()!==o.enumLine){const e=new t;if(p.queryEnvelope(e),m.containsEnvelope(e))return!1;if(h.isIntersecting(e)){C=!0;break}}else{f.assign(p.getStartXY()),x.assign(p.getEndXY());let t=m.clipLine(f,x);if(0!==t)return!1;_||(t=h.clipLine(f,x),0!==t&&(_=!0))}}if(!C)return _;const E=new Tr;return E.addEnvelope(a,!1),Au(E,e,n,i)}(e,s,i,a);case 16:return function(e,s,i){const r=new t,a=new t;if(e.queryEnvelope(r),s.queryEnvelope(a),a.height()<=i||a.width()<=i)return!1;const h=new t;if(h.setCoords({env2D:a}),h.inflateCoords(i,i),h.containsEnvelope(r))return!1;const m=new t;if(m.setCoords({env2D:a}),m.inflateCoords(-i,-i),!m.isIntersecting(r))return!1;const u=e.getImpl().querySegmentIterator();u.stripAttributes();const c=e.getImpl().getAccelerators();let g=null,d=null;if(null!==c&&(g=c.getQuadTree(),null!==g&&(d=g.getIterator(a,i))),!d){const t=u.nextPath();n(t)}let _=!1,p=null;const f=new l,x=new l;let y=null,P=null,C=null,E=null;for(e.hasNonLinearSegments()&&(y=new pm,P=new pm,C=new pm,E=new pm,m.querySide(0,y),m.querySide(1,P),m.querySide(2,C),m.querySide(3,E));;){if(null!==d){const t=d.next();if(-1===t)break;u.resetToVertex(g.getElement(t),-1),p=u.nextSegment()}else{for(;!u.hasNextSegment()&&u.nextPath(););if(!u.hasNextSegment())break;p=u.nextSegment()}if(p.getGeometryType()===o.enumLine){if(f.assign(p.getStartXY()),x.assign(p.getEndXY()),0!==m.clipLine(f,x)){_=!0;break}}else{if(y.isIntersecting(p,i)){_=!0;break}if(P.isIntersecting(p,i)){_=!0;break}if(C.isIntersecting(p,i)){_=!0;break}if(E.isIntersecting(p,i)){_=!0;break}}}return _&&!0}(e,s,i)}return!1}function bu(t,e,s,n,i){switch(n){case 4:return Ru(t,e,s);case 2:case 128:return function(t,e,s){return ku(t,e,s)}(t,e,s);case 1:case 64:return function(t,e,s){return!Ru(t,e,s)}(t,e,s);case 3:return ku(t,e,s)}return!1}function wu(e,s,n,i,r){switch(i){case 4:return function(e,s,n){const i=t.constructEmpty(),r=t.constructEmpty();if(e.queryEnvelope(i),s.queryEnvelope(r),ju(r,i,n))return!1;const o=t.constructEmpty();o.setCoords({env2D:r}),o.inflateCoords(n,n);const a=new l;for(let t=0;t<e.getPointCount();t++)if(e.queryXY(t,a),o.contains(a))return!1;return!0}(e,s,n);case 2:return Lu(e,s,n,!1);case 128:return Lu(e,s,n,!0);case 1:case 64:return!1;case 3:return function(e,s,n){const i=new t,r=new t;return e.queryEnvelope(i),s.queryEnvelope(r),!(r.height()>n||r.width()>n)&&Uu(i,r,n)}(e,s,n);case 8:return function(e,s,n){const i=new t,r=new t,o=new t;if(s.queryEnvelope(i),i.height()<=n||i.width()<=n)return!1;r.setCoords({env2D:i}),o.setCoords({env2D:i}),r.inflateCoords(n,n),o.inflateCoords(-n,-n);const a=new l;let h=!1;for(let t=0;t<e.getPointCount();t++)if(e.queryXY(t,a),r.contains(a)){if(o.containsExclusive(a))return!1;h=!0}return h}(e,s,n);case 16:return function(e,s,n){const i=new t,r=new t;if(e.queryEnvelope(i),s.queryEnvelope(r),ju(r,i,n))return!1;if(r.height()<=n||r.width()<=n)return!1;const o=new t,a=new t;o.setCoords({env2D:r}),o.inflateCoords(-n,-n),a.setCoords({env2D:r}),a.inflateCoords(n,n);const h=new l;let m=!1,u=!1;for(let t=0;t<e.getPointCount();t++)if(e.queryXY(t,h),!m&&o.containsExclusive(h)&&(m=!0),u||a.contains(h)||(u=!0),m&&u)return!0;return!1}(e,s,n)}return!1}function Du(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();if(e.queryEnvelope(r),s.queryEnvelope(o),!Uu(r,o,n))return!1;if(fu(e,s),Ku(e,s,n))return!0;const a=e.calculateLength2D(),h=s.calculateLength2D(),m=Math.max(e.getPointCount(),s.getPointCount());return!(Math.abs(a-h)>4*m*n)&&(e.hasNonLinearSegments()||s.hasNonLinearSegments()?Kl(e,s,n,"**F**FFF*",i,!1):$u(e,s,n,!0))}function Tu(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!ju(r,o,n)&&(fu(e,s),hc(e,s,n,i))}function Nu(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!ju(r,o,n)&&(fu(e,s),2===Ou(e,s,n,!1))}function Au(e,s,n,i){return fu(e,s),function(e,s,n,i){const r=e.getImpl(),o=s.getImpl(),a=r.querySegmentIterator(),m=o.querySegmentIterator(),l=h(2,Number.NaN),u=h(2,Number.NaN),c=new uu(r,o,n);let g=!1;for(;c.next();){const t=c.getRedElement(),e=c.getBlueElement();a.resetToVertex(t,-1),m.resetToVertex(e,-1);const s=a.nextSegment(),i=m.nextSegment();let r=0;if(uc(s,i)?!g&&i.isIntersecting(s,n)&&(g=!0):r=i.intersect(s,null,u,l,n),2===r)g=!0;else if(r){const t=l[0],e=u[0];if(t>0&&t<1&&e>0&&e<1)return!1;g=!0}}if(!g)return!1;const d=t.constructEmpty(),_=t.constructEmpty(),p=t.constructEmpty();let f,x;if(e.queryEnvelope(d),s.queryEnvelope(_),d.inflateCoords(1e3*n,1e3*n),_.inflateCoords(1e3*n,1e3*n),p.setCoords({env2D:d}),p.intersect(_),e.getPointCount()>10){if(f=Pm(e,p,n,0,i),f.isEmpty())return!1}else f=e;if(s.getPointCount()>10){if(x=Pm(s,p,n,0,i),x.isEmpty())return!1}else x=s;return Kl(f,x,n,"F********",i,!1)}(e,s,n,i)}function Mu(e,s,n,i,r){const o=t.constructEmpty(),a=t.constructEmpty();if(e.queryEnvelope(o),s.queryEnvelope(a),!ju(o,a,n))return!1;fu(e,s);let h=!1;const m=new l,u=e.getImpl(),c=new Tr;let g=e,d=!1;for(let t=0;t<s.getPointCount();t++){if(s.queryXY(t,m),!o.contains(m))return!1;const r=_c(g,m,n);if(1===r)h=!0;else if(0===r)return!1;if(i&&2===r)return!1;d||(!Bl(e,s.getPointCount()-1)||null!==u.getAccelerators()&&null!==u.getAccelerators().getQuadTree()?g=e:(e.copyTo(c),c.getImpl().buildQuadTreeAccelerator(1),g=c),d=!0)}return h}function Gu(e,s,n,i,r){const o=t.constructEmpty(),a=t.constructEmpty();return e.queryEnvelope(o),s.queryEnvelope(a),i?Zu(a,o,n):ju(a,o,n)}function qu(e,s,n,i,r){const o=t.constructEmpty(),a=t.constructEmpty();if(e.queryEnvelope(o),s.queryEnvelope(a),!ju(o,a,n))return!1;fu(e,s);const h=new Tr;return h.addEnvelope(s,!1),i?2===Ou(e,h,n,!1):hc(e,h,n,r)}function Fu(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!ju(r,o,n)&&(fu(e,s),e.hasNonLinearSegments()||s.hasNonLinearSegments()?Kl(e,s,n,"******FF*",i,!1):tc(s,e,n,!1))}function Vu(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!ju(r,o,n)&&(fu(e,s),Kl(e,s,n,"T**FF*FF*",i,!1))}function Yu(e,s,n,i,r){const a=t.constructEmpty(),h=t.constructEmpty();if(e.queryEnvelope(a),s.queryEnvelope(h),h.height()<=n||h.width()<=n)return!1;if(i)return Zu(h,a,n);if(!ju(h,a,n))return!1;const m=t.constructEmpty();m.setCoords({env2D:h}),m.inflateCoords(-n,-n);const l=t.constructEmpty();if(l.setCoords({env2D:h}),l.inflateCoords(n,n),m.containsEnvelope(a))return!0;const u=e.getImpl().querySegmentIterator();u.stripAttributes(),u.nextPath()||P("relational_operations");let c,g,d,_,p,f,x=!1;const y=e.hasNonLinearSegments();for(y&&(d=new pm,_=new pm,p=new pm,f=new pm,m.querySide(0,d),m.querySide(1,_),m.querySide(2,p),m.querySide(3,f));;){for(;!u.hasNextSegment()&&u.nextPath(););if(!u.hasNextSegment())break;const t=u.nextSegment();if(y&&t.getGeometryType()!==o.enumLine){if(t.isIntersecting(d,n)){x=!0;break}if(t.isIntersecting(_,n)){x=!0;break}if(t.isIntersecting(p,n)){x=!0;break}if(t.isIntersecting(f,n)){x=!0;break}}else if(c=t.getStartXY(),g=t.getEndXY(),0!==m.clipLine(c,g)){x=!0;break}}return x}function Xu(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),!!ju(r,o,n)&&Ju(s,e,n,!0,!1,!1)}function ku(e,s,n,i){const r=t.constructEmpty(),o=t.constructEmpty();return e.queryEnvelope(r),s.queryEnvelope(o),Uu(r,o,n)}function Ru(t,e,s,n){return mc(t,e.getXY(),s)}function Lu(e,s,n,i,r){const o=t.constructEmpty(),a=t.constructEmpty();if(e.queryEnvelope(o),s.queryEnvelope(a),a.height()<=n||a.width()<=n)return!1;if(i)return Zu(a,o,n);if(!ju(a,o,n))return!1;let h=!1;const m=t.constructEmpty(),u=t.constructEmpty();m.setCoords({env2D:a}),u.setCoords({env2D:a}),m.inflateCoords(-n,-n),u.inflateCoords(n,n);const c=new l;for(let t=0;t<e.getPointCount();t++){if(e.queryXY(t,c),!u.contains(c))return!1;m.containsExclusive(c)&&(h=!0)}return h}function Hu(t,e,s,n){return l.sqrDistance(t,e)<=s*s}function Bu(t,e,s,n){return Hu(t,e,s)}function Uu(t,e,s,n){return ju(t,e,s)&&ju(e,t,s)}function zu(e,s,n,i,r){if(e.height()<=n||e.width()<=n)return!1;if(i)return Zu(e,s,n);if(!ju(e,s,n))return!1;const o=t.constructEmpty();return o.setCoords({env2D:e}),o.inflateCoords(-n,-n),o.intersect(s),!o.isEmpty()}function Ou(e,s,n,i,r){const a=new l,m=new l,u=t.constructEmpty(),c=t.constructEmpty(),g=e.getImpl(),d=s.getImpl(),_=d.getGeometryType(),p=new uu(g,d,n,!0);if(!p.next())return 1;if(ec(e,s,n))return i?4:0;const f=new Tr;let x=e;const y=new Tr;let P=null;_===o.enumPolygon&&(P=s);const C=_===o.enumPolygon?h(g.getPathCount(),!1):[],E=h(d.getPathCount(),!1);let S=!1,v=!1,I=!1,b=!1,w=!1,D=!1;do{if(I&&w||b&&D)break;if(I&&b)break;const t=p.getRedElement(),r=p.getBlueElement();if(!E[r]&&(m.assign(s.getXY(s.getPathStart(r))),u.setCoords({env2D:p.getRedEnvelope()}),u.inflateCoords(n,n),u.contains(m))){if(0!==_c(x,m,0)){if(b=!0,i)return 4}else D=!0;E[r]=!0}if(_===o.enumPolygon&&!C[t]&&(a.assign(e.getXY(e.getPathStart(t))),c.setCoords({env2D:p.getBlueEnvelope()}),c.inflateCoords(n,n),c.contains(a))){if(0!==_c(P,a,0)){if(I=!0,i)return 4}else w=!0;C[t]=!0}if(S||(!Bl(e,s.getPathCount()-1)||null!==g.getAccelerators()&&null!==g.getAccelerators().getQuadTree()?x=e:(e.copyTo(f),f.getImpl().buildQuadTreeAccelerator(1),x=f),S=!0),_===o.enumPolygon&&!v){const t=s;!Bl(t,e.getPathCount()-1)||null!==d.getAccelerators()&&null!==d.getAccelerators().getQuadTree()?P=s:(t.copyTo(y),y.getImpl().buildQuadTreeAccelerator(1),P=y),v=!0}}while(p.next());if(!I&&!b)return 1;if(!w||!D){if(_===o.enumPolygon)for(let t=0,e=g.getPathCount();t<e;t++)if(!C[t]){w=!0;break}for(let t=0,e=d.getPathCount();t<e;t++)if(!E[t]){D=!0;break}}return I&&w||b&&D||I&&b?4:b?2:3}function Wu(e,s,i,r,a){r[0]=!1;const h=e.getImpl(),m=s.getImpl(),l=h.querySegmentIterator(),u=m.querySegmentIterator(),c=[0,0],g=[0,0],d=new uu(h,m,i);let _=!1;for(;d.next();){const t=d.getRedElement(),e=d.getBlueElement();l.resetToVertex(t,-1),u.resetToVertex(e,-1);const s=l.nextSegment(),n=u.nextSegment();let o=0;if(uc(s,n)?!_&&n.isIntersecting(s,i)&&(_=!0):o=n.intersect(s,null,g,c,i),0!==o&&(_=!0,1===o)){const t=c[0],e=g[0];if(t>0&&t<1&&e>0&&e<1)return r[0]=!0,!1}}if(!_){r[0]=!0;const a=t.constructEmpty();e.queryEnvelope(a),a.inflateCoords(i,i);const l=new Tr;let u=e,c=!1;for(let i=0,r=s.getPathCount();i<r;i++)if(s.getPathSize(i)>0){const r=t.constructEmpty();if(s.queryPathEnvelope(i,r),!a.isIntersecting(r))return!1;{const t=Hl(u,s.getXY(s.getPathStart(i)),0);if(n(-1!==t),0===t)return!1}c||(!Bl(e,s.getPathCount()-1)||null!==h.getAccelerators()&&null!==h.getAccelerators().getQuadTree()?u=e:(e.copyTo(l),l.getImpl().buildQuadTreeAccelerator(1),u=l),c=!0)}if(1===e.getPathCount()||s.getGeometryType()===o.enumPolyline)return!0;const g=s,d=t.constructEmpty();g.queryEnvelope(d),d.inflateCoords(i,i);const _=new Tr;let p=g,f=!1;for(let s=0,i=e.getPathCount();s<i;s++)if(e.getPathSize(s)>0){const i=t.constructEmpty();if(e.queryPathEnvelope(s,i),d.isIntersecting(i)){const t=Hl(p,e.getXY(e.getPathStart(s)),0);if(n(-1!==t),1===t)return!1}f||(!Bl(g,e.getPathCount()-1)||null!==m.getAccelerators()&&null!==m.getAccelerators().getQuadTree()?p=g:(g.copyTo(_),_.getImpl().buildQuadTreeAccelerator(1),p=_),f=!0)}return!0}return!1}function ju(e,s,n){const i=t.constructEmpty();return i.setCoords({env2D:e}),i.inflateCoords(n,n),i.containsEnvelope(s)}function Zu(e,s,n){const i=t.constructEmpty();return i.setCoords({env2D:s}),i.inflateCoords(n,n),e.containsExclusiveEnvelope(i)}function Qu(e,s,n){const i=t.constructEmpty();return i.setCoords({env2D:s}),i.inflateCoords(n,n),!(i.contains(e.getLowerLeft())&&i.contains(e.getLowerRight())&&i.contains(e.getUpperLeft())&&i.contains(e.getUpperRight()))}function Ku(t,e,s,n){if(t.getPathCount()!==e.getPathCount()||t.getPointCount()!==e.getPointCount())return!1;if(t.hasNonLinearSegments()||e.hasNonLinearSegments())return t.equals(e);const i=new l,r=new l;let o=!0;const a=s*s;for(let s=0;s<t.getPathCount();s++){if(t.getPathEnd(s)!==e.getPathEnd(s)){o=!1;break}for(let n=t.getPathStart(s);n<e.getPathEnd(s);n++)if(t.queryXY(n,i),e.queryXY(n,r),l.sqrDistance(i,r)>a){o=!1;break}if(!o)break}return!!o}function Ju(t,e,s,n,i,r,o){const a=t.getImpl(),m=e.getImpl(),u=a.getPointCount(),c=m.getPointCount(),g=h(u,!1),d=i||r?h(c,!1):[],_=s*s,p=new uu(a,m,s);for(;p.next();){const t=p.getRedElement(),e=p.getBlueElement(),s=a.getXY(t),n=m.getXY(e);l.sqrDistance(s,n)<=_&&(g[t]=!0,(i||r)&&(d[e]=!0))}let f=!1,x=!1;for(let t=0;t<u;t++){const e=g[t];if(f||=!e,x||=e,(i||n)&&f)return!1}if(n)return!0;let y=!1,P=!1;for(let t=0;t<c;t++){const e=d[t];if(y||=!e,P||=e,i&&y)return!1}return!!i||f&&x&&y&&P}function $u(t,e,s,n){return tc(t,e,s,n)&&tc(e,t,s,n)}function tc(e,s,n,i){if(Ft(e),Ft(s),s.isEmpty())return!1;let r=!0;const o=h(2,Number.NaN),a=h(2,Number.NaN),m=[],l=new gc;let u;const c=t.constructEmpty(),g=t.constructEmpty(),d=t.constructEmpty();e.queryEnvelope(c),s.queryEnvelope(g),c.inflateCoords(n,n),g.inflateCoords(n,n),d.setCoords({env2D:c}),d.intersect(g);const _=e.getImpl().querySegmentIterator(),p=s.getImpl().querySegmentIterator(),f=s.getImpl().getAccelerators();let x=null,y=null,C=null,E=null;if(null!==f&&(x=f.getQuadTree(),y=f.getQuadTreeForPaths(),null!==y&&(E=y.getIteratorForQT())),null===x){const t=e.getPointCount(),n=s.getPointCount();t>10&&n>10&&(x=Le(s.getImpl(),d))}for(null!==x&&(C=x.getIteratorForQT());_.nextPath();)for(;_.hasNextSegment();){let t=_.nextSegment();if(t.queryEnvelope(c),!c.isIntersecting(d))return r=!1,!1;if(null!==E&&(E.resetIterator(c,n),-1===E.next()))continue;let e=0,s=null;if(null!=C)C.resetIterator(t,n);else if(p.resetToFirstPath(),!p.nextPath())return r=!1,!1;do{if(e=0,null!==C){const i=C.next();if(-1===i)return r=!1,!1;p.resetToVertex(x.getElement(i),-1),s=p.nextSegment(),e=t.intersect(s,null,o,a,n)}else{for(;!p.hasNextSegment();)if(!p.nextPath())return r=!1,!1;s=p.nextSegment(),s.queryEnvelope(g),g.inflateCoords(n,n),c.isIntersecting(g)&&(e=t.intersect(s,null,o,a,n))}}while(2!==e||0!==o[0]||i&&!(a[0]<=a[1]));let h=Number.NaN,f=!1;do{let i=!1;if(1===o[1]){if(!_.hasNextSegment()){f=!0;break}t=_.nextSegment(),i=!0}if(1===a[1]&&a[0]<=a[1]){if(-1===h)break;if(h=1,!p.hasNextSegment())break;s=p.nextSegment(),i=!0}if(0===a[1]&&a[0]>a[1]){if(1===h)break;if(Number.isNaN(h)){if(!p.hasPreviousSegment())break;p.previousSegment(),h=-1}if(!p.hasPreviousSegment())break;s=p.previousSegment(),i=!0}if(!i)break;e=t.intersect(s,null,o,a,n)}while(2===e&&(!i||a[0]<=a[1]));if(f)continue;const y=t.calculateLength2D();t.queryEnvelope(c),m.length=0,l.m_overlapEvents.length=0;let S=!1,v=!1,I=0;const b=Ze(null,c,!0);for(null!==C?C.resetIterator(t,n):(p.resetToFirstPath(),p.nextPath()||P("relational_operations"));;){if(e=0,null!==C){const i=C.next();if(-1===i)break;p.resetToVertex(x.getElement(i),-1),s=p.nextSegment(),e=t.intersect(s,null,o,a,n)}else{for(;!p.hasNextSegment()&&p.nextPath(););if(!p.hasNextSegment())break;s=p.nextSegment(),s.queryEnvelope(g),g.inflateCoords(n,n),c.isIntersecting(g)&&(e=t.intersect(s,null,o,a,n))}if(2===e&&(!i||a[0]<=a[1])){const t=_.getStartPointIndex(),e=_.getPathIndex(),s=p.getStartPointIndex(),i=p.getPathIndex();if(u=cc(t,e,o[0],o[1],s,i,a[0],a[1]),l.m_overlapEvents.push(u),m.push(m.length),!(S||u.m_scalarA0<I&&u.m_scalarA1<I))if(0===I&&y*(u.m_scalarA0-I)>n)S=!0;else if(0!==I&&y*(u.m_scalarA0-I)>b)S=!0;else if(I=u.m_scalarA1,y*(1-I)<=n||1===I){v=!0;break}}}if(!v){if(!S)return r=!1,!1;m.length>1&&m.sort((t,e)=>l.compareOverlapEvents(t,e)),I=0;for(let t=0;t<l.m_overlapEvents.length;t++)if(u=l.m_overlapEvents[m[t]],!(u.m_scalarA0<I&&u.m_scalarA1<I)){if(0===I&&y*(u.m_scalarA0-I)>n)return r=!1,!1;if(0!==I&&y*(u.m_scalarA0-I)>b)return r=!1,!1;if(I=u.m_scalarA1,y*(1-I)<=n||1===I)break}if(y*(1-I)>n)return r=!1,!1;m.length=0,l.m_overlapEvents.length=0}}return r}function ec(t,e,s){const n=t.getImpl(),i=e.getImpl(),r=n.querySegmentIterator(),o=i.querySegmentIterator(),a=new uu(n,i,s);for(;a.next();){const t=a.getRedElement(),e=a.getBlueElement();r.resetToVertex(t,-1),o.resetToVertex(e,-1);const n=r.nextSegment();if(o.nextSegment().isIntersecting(n,s))return!0}return!1}function sc(t,e,s,n){const i=t.getImpl(),r=e.getImpl(),o=i.querySegmentIterator(),a=r.querySegmentIterator(),m=h(2,Number.NaN),u=new uu(i,r,s);let c=!1,g=-1;for(;u.next();){const t=u.getRedElement(),e=u.getBlueElement();o.resetToVertex(t,-1),a.resetToVertex(e,-1);const i=o.nextSegment(),r=a.nextSegment();let h=0;if(uc(i,r)){if(r.isIntersecting(i,s))return-2}else h=i.intersect(r,null,m,null,s);if(h)if(2===h){const t=i.calculateLength2D(),e=m[0];if(t*(m[1]-e)>s)return g=1,g;c=!0}else if(g=0,n){const t=m[0],e=new l;i.queryCoord2D(t,e),n.push(e.x),n.push(e.y)}}return c?-2:g}function nc(t,e,s,n){const i=t.getImpl(),r=e,o=r.getPointCount(),a=n?h(o,!1):[],m=new uu(i,r,s,!1),l=i.querySegmentIterator();for(;m.next();){const t=m.getRedElement(),e=m.getBlueElement();l.resetToVertex(t,-1);const i=l.nextSegment(),o=r.getXY(e);if(i.isIntersectingPoint(o,s)){if(!n)return!0;a[e]=!0}}if(!n)return!1;for(let t=0;t<o;t++)if(!a[t])return!1;return!0}function ic(e,s,n){const i=new l,r=n*n,o=e.querySegmentIterator(),a=e.getImpl().getAccelerators();if(null!==a){const e=a.getQuadTree();if(null!==e){const a=t.constructEmpty();a.setCoords({pt:s});const h=e.getIterator(a,n);for(let t=h.next();-1!==t;t=h.next())if(o.resetToVertex(e.getElement(t),-1),o.hasNextSegment()){const t=o.nextSegment(),e=t.getClosestCoordinate(s,!1);if(t.queryCoord2D(e,i),l.sqrDistance(s,i)<=r)return!0}return!1}}const h=t.constructEmpty();for(;o.nextPath();)for(;o.hasNextSegment();){const t=o.nextSegment();if(t.queryEnvelope(h),h.inflateCoords(n,n),!h.contains(s))continue;const e=t.getClosestCoordinate(s,!1);if(t.queryCoord2D(e,i),l.sqrDistance(s,i)<=r)return!0}return!1}function rc(e,s,n,i){const r=e.querySegmentIterator(),a=e.getImpl().getAccelerators(),h=e.hasNonLinearSegments();let m=null,u=null,c=null,g=null;if(null!==a){const e=a.getQuadTree();if(null!==e){const i=e.getIterator(s,n);h&&(m=new pm,u=new pm,c=new pm,g=new pm,s.querySide(0,m),s.querySide(1,u),s.querySide(2,c),s.querySide(3,g));const a=t.constructEmpty();a.setCoords({env2D:s}),a.inflateCoords(n,n);for(let t=i.next();-1!==t;t=i.next())if(r.resetToVertex(e.getElement(t),-1),r.hasNextSegment()){const t=r.nextSegment();if(t.getGeometryType()===o.enumLine){const e=t.getStartXY(),s=t.getEndXY();if(a.clipLine(e,s))return!0;continue}if(s.contains(t.getStartXY())||s.contains(t.getEndXY()))return!0;if(t.isIntersecting(m,n))return!0;if(t.isIntersecting(u,n))return!0;if(t.isIntersecting(c,n))return!0;if(t.isIntersecting(g,n))return!0}return!1}}if(h){m=new pm,u=new pm,c=new pm,g=new pm,s.querySide(0,m),s.querySide(1,u),s.querySide(2,c),s.querySide(3,g);const t=e.querySegmentIterator();for(;t.nextPath();)for(;t.hasNextSegment();){const e=t.nextSegment();if(s.contains(e.getStartXY())||s.contains(e.getEndXY()))return!0;if(e.isIntersecting(m,n))return!0;if(e.isIntersecting(u,n))return!0;if(e.isIntersecting(c,n))return!0;if(e.isIntersecting(g,n))return!0}}else{const i=t.constructEmpty();i.setCoords({env2D:s}),i.inflateCoords(n,n);const r=e.getImpl(),o=r.getAttributeStreamRef(0),a=new l;for(let t=0,e=r.getPathCount();t<e;t++){let e=!0;const s=new l,n=new l,h=new l,m=r.getPathStart(t),u=new l;for(let l=m,c=r.getPathEnd(t);l<c;l++)if(e)o.queryPoint2D(2*l,s),u.assign(s),e=!1;else{if(o.queryPoint2D(2*l,a),n.setCoordsPoint2D(s),h.setCoordsPoint2D(a),i.clipLine(n,h))return!0;s.assign(a)}if(r.isClosedPath(t)&&!e&&(n.setCoordsPoint2D(s),h.setCoordsPoint2D(u),i.clipLine(n,h)))return!0}}return!1}function oc(e,s,n,i){const r=e.getImpl(),o=s.getImpl(),a=[0],m=ns(r.getIsSimple(0,a))&&ns(o.getIsSimple(0,a)),l=r.querySegmentIterator(),u=o.querySegmentIterator(),c=h(2,0),g=h(2,0),d=new uu(r,o,n);let _=!1;for(;d.next();){const t=d.getRedElement(),e=d.getBlueElement();l.resetToVertex(t,-1),u.resetToVertex(e,-1);const s=l.nextSegment(),i=u.nextSegment();let r=0;if(uc(s,i)){if(i.isIntersecting(s,n)){_=!0;break}}else r=i.intersect(s,null,g,c,n);if(2===r){const t=c[0],e=c[1],i=s.calculateLength2D();if(m&&(e-t)*i>n)return!1;_=!0}else if(r){const t=c[0],e=g[0];if(t>0&&t<1&&e>0&&e<1)return!1;_=!0}}if(!_)return!1;const p=t.constructEmpty(),f=t.constructEmpty(),x=t.constructEmpty();let y,P;if(e.queryEnvelope(p),s.queryEnvelope(f),p.inflateCoords(1e3*n,1e3*n),f.inflateCoords(1e3*n,1e3*n),x.setCoords({env2D:p}),x.intersect(f),e.getPointCount()>10){if(y=Pm(e,x,n,0,i),y.isEmpty())return!1}else y=e;if(s.getPointCount()>10){if(P=Pm(s,x,n,0,i),P.isEmpty())return!1}else P=s;return Kl(y,P,n,"F********",i,!1)}function ac(e,s,n,i){const r=e.getImpl(),o=s.getImpl(),a=[0],m=ns(r.getIsSimple(0,a))&&ns(o.getIsSimple(0,a)),l=t.constructEmpty(),u=t.constructEmpty(),c=t.constructEmpty();e.queryEnvelope(l),s.queryEnvelope(u);let g=!1;const d=Qu(l,u,n),_=Qu(u,l,n),p=r.querySegmentIterator(),f=o.querySegmentIterator(),x=h(2,Number.NaN),y=h(2,Number.NaN),P=new uu(r,o,n);for(;P.next();){const t=P.getRedElement(),e=P.getBlueElement();p.resetToVertex(t,-1),f.resetToVertex(e,-1);const s=p.nextSegment(),i=f.nextSegment();let r=0;if(uc(s,i)){if(i.isIntersecting(s,n))break}else r=i.intersect(s,null,y,x,n);if(2===r){const t=x[0],e=x[1],i=s.calculateLength2D();if(m&&(e-t)*i>n&&(g=!0,d&&_))return!0}else if(r){const t=x[0],e=y[0];if(t>0&&t<1&&e>0&&e<1)return!0}}const C=t.constructEmpty(),E=t.constructEmpty();let S,v;C.setCoords({env2D:l}),C.inflateCoords(1e3*n,1e3*n),E.setCoords({env2D:u}),E.inflateCoords(1e3*n,1e3*n),c.setCoords({env2D:C}),c.intersect(E);let I="";if(I+=g?"**":"T*",d){if(s.getPointCount()>10){if(v=Pm(s,c,n,0,i),v.isEmpty())return!1}else v=s;I+="****"}else v=s,I+="T***";if(_){if(e.getPointCount()>10){if(S=Pm(e,c,n,0,i),S.isEmpty())return!1}else S=e;I+="***"}else S=e,I+="T**";return Kl(S,v,n,I,i,!1)}function hc(e,s,n,i){const r=[!1],o=Wu(e,s,n,r);if(r[0])return o;const a=t.constructEmpty();let h;if(s.queryEnvelope(a),a.inflateCoords(1e3*n,1e3*n),e.getPointCount()>10){if(h=Pm(e,a,n,0,i),h.isEmpty())return!1}else h=e;const m=function(e,s,n,i){const r=new au;r.resetMatrix_(),r.setPredicates_("T*****F**"),r.setAreaAreaPredicates_();const o=t.constructEmpty(),a=t.constructEmpty();e.queryEnvelope(o),s.queryEnvelope(a);let h=!1;if(pu(o,a,n)&&(r.areaAreaDisjointPredicates_(e,s),h=!0),h||fu(e,s),h)return ru(r.m_matrix,r.m_scl);let m=new Vr,l=m.addGeometry(e),u=m.addGeometry(s),c=null,g=0;if(e.hasNonLinearSegments()||s.hasNonLinearSegments()){c=new Tc;const t=bc(n,m.getEnvelope2D(i));g=Dc(t,0),Ec(m,t,n,0,c,null,i)}Ac(m,new cs(n,0).add(g),i,!1,!1);const d=m.getGeometry(u).getBoundary();if(m.filterClosePoints(0,!0,!0,!1,Ar),Zl(m,l,-1,!1,Ar,i),0===m.getPointCount(l))return!1;Zl(m,u,-1,!1,Ar,i),r.setEditShape_(m,i);const _=0===m.getPointCount(u);if(!_){r.computeMatrixTopoGraphHalfEdges_(l,u),r.m_topoGraph.removeShape();const t=ru(r.m_matrix,r.m_scl);if(!t)return t}const p=m.getGeometry(l);return m=new Vr,l=m.addGeometry(p),u=m.addGeometry(d),r.setEditShape_(m,i),r.m_predicateCount=0,r.resetMatrix_(),r.setPredicates_(_?"T*****F**":"******F**"),r.setAreaLinePredicates_(),r.computeMatrixTopoGraphHalfEdges_(l,u),r.m_topoGraph.removeShape(),ru(r.m_matrix,r.m_scl)}(h,s,n,i);return m}function mc(t,e,s,n){const i=new l,r=s*s;for(let s=0;s<t.getPointCount();s++)if(t.queryXY(s,i),l.sqrDistance(i,e)<=r)return!1;return!0}function lc(t,e,s){const n=t.getBoundary();return!n.isEmpty()&&!mc(n,e,s)}function uc(t,e){return t.getGeometryType()!==o.enumLine||e.getGeometryType()!==o.enumLine}function cc(t,e,s,n,i,r,o,a){return{m_ivertexA:t,m_ipathA:e,m_scalarA0:s,m_scalarA1:n,m_ivertexB:i,m_ipathB:r,m_scalarB0:o,m_scalarB1:a}}class gc{constructor(){this.m_overlapEvents=[]}compareOverlapEvents(t,e){const s=this.m_overlapEvents[t],n=this.m_overlapEvents[e];if(s.m_ipathA<n.m_ipathA)return-1;if(s.m_ipathA===n.m_ipathA){if(s.m_ivertexA<n.m_ivertexA)return-1;if(s.m_ivertexA===n.m_ivertexA){if(s.m_scalarA0<n.m_scalarA0)return-1;if(s.m_scalarA0===n.m_scalarA0){if(s.m_scalarA1<n.m_scalarA1)return-1;if(s.m_scalarA1===n.m_scalarA1&&s.m_ivertexB<n.m_ivertexB)return-1}}}return 1}}function dc(t,e,s){const n=function(t,e,s){return e.isEmpty()?0:Hl(t,e.getXY(),s)}(t,e,s);return n?1===n?1:2:0}function _c(t,e,s){const n=Hl(t,e,s);return n?1===n?1:2:0}function pc(e,s,n,i,r){if(e.getGeometryType()===o.enumPolygon)!function(t,e,s,n,i){for(let r=0;r<s;r++)i[r]=_c(t,e[r],n)}(e,s,n,i,r);else if(e.getGeometryType()===o.enumEnvelope){const o=t.constructEmpty();e.queryEnvelope(o),function(t,e,s,n,i){if(t.isEmpty()){for(let t=0;t<s;t++)i[t]=0;return}const r=t.clone();r.inflateCoords(.5*-n,.5*-n);const o=t.clone();o.inflateCoords(.5*n,.5*n);for(let t=0;t<s;t++)r.contains(e[t])?i[t]=1:o.contains(e[t])?i[t]=2:i[t]=0}(o,s,n,i,r)}else K("")}function fc(e,s,i,r,a){const h=e.getGeometryType();h===o.enumPolyline?function(e,s,i,r,o){const a=e.getImpl(),h=a.getAccelerators();let m=null;h&&(m=h.getRasterizedGeometry());let l=i;for(let t=0;t<i;t++)o[t]=1,m&&n(0);if(l){if(h){let e=null;null!==h&&null!==h.getQuadTree()&&(e=h.getQuadTree());const n=a.getPointCount();if(null===e&&n>20&&n*i>4*n+Math.log(n)*i&&(e=Le(a)),e){let n=null;const h=a.querySegmentIterator(),m=new t;for(let t=0;t<i&&l;t++)if(1===o[t]){m.setCoords(s[t]),null===n?n=e.getIterator(m,r):n.resetIterator(m,r);let i=-1;for(let a=n.next();-1!==a;a=n.next()){if(h.resetToVertex(e.getElement(a),i),i=h.getPathIndex(),h.nextSegment().isIntersectingPoint(s[t],r)){o[t]=2,l--;break}o[t]=0}}return}}const e=a.querySegmentIterator();for(;e.nextPath()&&l;)for(;e.hasNextSegment()&&l;){const t=e.nextSegment();for(let e=0;e<i&&l;e++)1===o[e]&&t.isIntersectingPoint(s[e],r)&&(o[e]=2,l--)}}for(let t=0;t<i;t++)1===o[t]&&(o[t]=0)}(e,s,i,r,a):F(h)?n(0):K("")}function xc(t){if(t.isEmpty())return 0;switch(t.getGeometryType()){case o.enumMultiPoint:return t.getImpl().getPointCount();case o.enumPolyline:return t.getImpl().getPathCount();case o.enumPolygon:return t.getImpl().getOGCPolygonCount();case o.enumGeometryCollection:return t.getGeometryCount()}return 1}function yc(){return Number.isNaN(this.radius.value())}function Pc(t,e,s,n){return{pt:t.clone(),t:e,err:s,checkCount:n}}class Cc{constructor(t,e,s,n,i){this.m_left=t,this.m_tracker=i,this.m_eps=s,this.m_trackerCounter=0,this.m_tolerance=n,this.m_circleCheckCounter=0,this.m_bReversedLeft=!1,this.m_leftArc={ptStart:new l,ptEnd:new l,center:new Rs,radius:new v,fcenter:new Hs,fradius2:new y,maxError:Number.NaN,isLine:yc}}closeToCircularArc(t,e,s,n,i,r){if(this.m_circleCheckCounter++,r.maxError=0,!Cc.checkSweepAngle(t,e))return!1;if(r.ptStart.setCoordsPoint2D(s),r.ptEnd.setCoordsPoint2D(i),t.isCircular()){const e=t;return r.fradius2=y.constructDouble(e.getSemiMajorAxis()).mulDouble(e.getSemiMajorAxis()),r.radius.set(e.getSemiMajorAxis()),r.fcenter.assignPoint2D(e.getCenter()),r.center.set(e.getCenter()),!0}const o=r.ptEnd.sub(r.ptStart).clone();if(o.leftPerpendicularThis(),o.normalize(),Math.abs(o.dotProduct(n.sub(r.ptStart)))<=this.m_eps)return!!this.confirmIsLine(r,o)&&(r.radius.set(Number.NaN),r.center.setCoords(0,0),!0);{const s=r.ptEnd.sub(r.ptStart),i=n.sub(r.ptStart),o=s.crossProduct(i);if(0===o)return!1;const a=.5*s.sqrLength(),h=.5*i.sqrLength();let m=a*i.y-h*s.y;m/=o;let l=s.x*h-i.x*a;l/=o;const u=Math.sqrt(m*m+l*l);if(4*Number.EPSILON*u>this.m_eps)return!1;const c=m+r.ptStart.x,g=l+r.ptStart.y;r.radius.set(u),r.center.setCoords(c,g);const d=this.maxCircleApproximationError(t,e,r);if(d>this.m_eps)return r.maxError=d,!1}const a=(new Hs).assignPoint2D(r.ptStart),h=(new Hs).assignPoint2D(r.ptEnd).sub(a),m=(new Hs).assignPoint2D(n).sub(a),l=h.crossProduct(m);if(l.isZero())return!1;const u=h.sqrLength().mulDouble(.5),c=m.sqrLength().mulDouble(.5),g=u.mul(m.y).sub(c.mul(h.y)),d=h.x.mul(c).sub(m.x.mul(u)),_=g.mul(g).add(d.mul(d)),p=l.clone();p.invertThis(),r.fradius2=_.mul(p).mul(p),r.fcenter.setCoords(g.mul(p).add(a.x),d.mul(p).add(a.y)),r.center.setWithEps(r.fcenter.asPoint2D()),r.radius.setWithEps(Math.sqrt(r.fradius2.toDouble()));const f=Rs.constructPoint2D(r.ptStart).subE(r.center),x=Rs.constructPoint2D(r.ptEnd).subE(r.center);if(!f.dotProduct(x).gt(b))return!1;const P=this.maxCircleApproximationError(t,e,r);return r.maxError=P,P<=this.m_eps}static checkSweepAngle(t,e){if(t.getGeometryType()===o.enumEllipticArc){const s=t,n=wh(s,e.vmin),i=wh(s,e.vmax);return!(Math.abs(i-n)>.5*z)}return!0}confirmIsLine(t,e){const s=t.ptEnd.sub(t.ptStart);return!(Math.abs(e.dotProduct(s.mul(.25)))>this.m_eps||Math.abs(e.dotProduct(s.mul(.75)))>this.m_eps)}maxCircleApproximationError(t,e,s){const n=[.25,.75],i=[.1,.25,.75,.9];let r,a;t.getGeometryType()===o.enumEllipticArc?(r=n,a=n.length):(r=i,a=i.length);let h=0;for(let n=0;n<a;++n){const i=new l;t.queryCoord2D(C(e.vmin,e.vmax,r[n]),i);const o=i.sub(s.center.value()).length(),a=Math.abs(o-s.radius.value());a>h&&(h=a)}return h}approximateWithCirclesImpl(t,e){let s=1;e&&e.push(0);const n=h(9,Number.NaN);let i;t?i=this.m_left.getMonotonicPartParams(n.length,n):(n[0]=0,n[1]=1,i=2);const o=[],a=[],m=new l(0,0);for(let t=1;t<i;t++){const i=new r(n[t-1],n[t]);for(this.m_bReversedLeft=!Cc.goodOrientation(this.m_left,i),this.m_bReversedLeft?(o.push(Pc(m,i.vmin,0,0)),o.push(Pc(m,i.vmax,0,0))):(o.push(Pc(m,i.vmax,0,0)),o.push(Pc(m,i.vmin,0,0))),o[0].pt=this.m_left.getCoord2D(o[0].t),o[1].pt=this.m_left.getCoord2D(o[1].t);o.length>1;){this.progress_();const t=o.at(-1);let n=t.checkCount,i=t.err;const h=t.pt.clone(),m=t.t,l=o[o.length-2].t,u=.5*(m+l),c=this.m_left.getCoord2D(u);if(i<=this.m_eps||n>=5){const t=new r;if(t.setCoords(m,l),this.closeToCircularArc(this.m_left,t,h,c,o[o.length-2].pt,this.m_leftArc)){e&&(this.m_bReversedLeft?a.push(m):e.push(l)),s++,o.pop();continue}n=0,i=this.m_leftArc.maxError}t.t=u,t.pt.setCoordsPoint2D(c),i*=.125,n++,t.err=i,t.checkCount=n,o.push(Pc(h,m,i,n))}this.m_bReversedLeft&&e&&(e.length=e.length+a.length,g(e,a.reverse(),e.length-a.length,0,a.length),a.length=0),o.length=0}return s}approximateWithCirclesImplPolyline(t){const e=new Wn,s=[];if(!this.approximateWithCirclesImpl(!0,s))return e;let n=0;const i=this.m_left.getStartXY();e.startPath(i);for(let r=1;r<s.length;++r)if(t)e.lineTo(this.m_left.getCoord2D(s[r]));else{const t=new l;this.m_left.queryCoord2D(s[r],t);const o=new l;this.m_left.queryCoord2D(.5*(s[r]+n),o);const a=new eh;a.constructCircularArcThreePoint(i,t,o),e.addSegment(a,!1),i.assign(t),n=s[r]}return e}static goodOrientation(t,e){const s=t.getCoord2D(e.vmin),n=t.getCoord2D(e.vmax);return s.compare(n)<0}progress_(t=!1){}}function Ec(t,e,s,n,i,r,o){!function(t,e,s,n,i,r){t.hasCurves()?(t.setCurveStitcherPointer(n),n.m_impl=new Nc(r,!1,null),n.m_impl.buildMonotonicCurveParentage(t,e,s,i)):n.m_impl=null}(t,e,s,i,r,o),qc(t,s,o)}function Sc(t,e,s,n){if(!Z(t.getGeometryType()))return t;const i=t.getImpl();if(!i.hasNonLinearSegments())return t;const r=t.createInstance();r.getGeometryType()===o.enumPolygon&&r.setFillRule(t.getFillRule()),new Vr;const a=new qe,h=new fm,m=[],l=[],u=[],c=t.getDescription().getAttributeCount()>1,g=i.querySegmentIterator();for(;g.nextPath();){let t=!0;for(;g.hasNextSegment();){const n=g.isClosingSegment(),i=g.nextSegment();if(!i.isCurve()){r.addSegment(i,t,n),t=!1;continue}let d,_=!1;const p=!0,f=!0;switch(i.getGeometryType()){case o.enumEllipticArc:case o.enumRationalBezier2:d=mh(i,0,s,p,f,l,u,m),_=!0;break;default:d=hh(i,e,s,!0,p,l,m)}const x=_?2:3;l[1].isNAN()?(h.createLine(),h.get().construct(l[0],l[x])):_?(h.createQuadraticRationalBezier(),h.get().constructArrayWeights(l,u)):(h.createCubicBezier(),h.get().constructPoints(l)),c&&t&&(i.queryCoord(m[0],a),h.get().setStart(a)),c&&(i.queryCoord(m[1],a),h.get().setEnd(a)),r.addSegment(h.get(),t,n&&1===d),t=!1;for(let t=1,e=d,s=x;t<e;++t,s+=x)l[s+1].isNAN()?(h.createLine(),h.get().construct(l[s],l[s+x])):_?(h.createQuadraticRationalBezier(),h.get().constructArrayWeights(l.slice(s),u.slice(s))):(h.createCubicBezier(),h.get().constructPoints(l.slice(s))),c&&(i.queryCoord(m[t+1],a),h.get().setEnd(a)),r.addSegment(h.get(),!1,n&&t+1===e)}}return r}function vc(t,e,s,n,i,r,o,a){t.hasCurves()?(t.setCurveStitcherPointer(r),r.m_impl=new Nc(a,!0,i),r.m_impl.buildMonotonicCurveParentage(t,e,s,o),qc(t,s,a)):r.m_impl=null}function Ic(t){if(!t.hasSegmentParentage())return;const e=t.queryVertexIteratorOnSelection();for(let s=e.next();s!==Ar;s=e.next())if(!t.getSegmentParentageBreakVertex(s)){t.getPathFromVertex(s);const e=t.getPrevVertex(s),n=e!==Ar?t.getSegmentParentage(e):-1,i=t.getSegmentParentage(s);-1!==i&&-1!==n&&i!==n&&t.setSegmentParentageBreakVertex(s,!0)}}function bc(e,s){return s||(s=t.constructEmpty()),function(t,e){let s=e.isEmpty()?t:Oe(null,e,!0).total();return s>t&&(s=t),.125*s}(e,s)}function wc(t,e){return.125*t}function Dc(t,e){return 3*t+3*e}class Tc{constructor(){this.m_impl=null}stitchCurves(t,e,s,n){this.m_impl&&(this.m_impl.stitchCurves(t,e,s),n&&this.clearStitcher(t))}clearStitcher(t){this.m_impl&&(this.m_impl.clearStitcher(t),this.m_impl=null)}getOriginalVertexIndex(t,e){return this.m_impl.getOriginalVertexIndex(t,e)}getOriginalSegmentTypeInfo(t){return this.m_impl.getOriginalSegmentTypeInfo(t)}}class Nc{constructor(t,e,s){this.m_originalPlanarSegments=[],this.m_progressTracker=null,this.m_nsr=null,this.m_progressTracker=t,this.m_nsr=s,this.m_tolerance=0,this.m_originalVertexIndex=-1,this.m_type=1,this.m_progressCounter=0,this.m_bIsSimple=e,this.m_densificationDeviation=NaN,this.m_maxSegmentsPerCurve=-1}buildMonotonicCurveParentage(t,e,s,i){const r=!1;if(!t.hasCurves())return;n(!t.hasSegmentParentage()),this.m_originalPlanarSegments.length=0,this.m_bIsSimple&&(this.m_originalVertexIndex=t.createUserIndex()),this.m_tolerance=s;const a=new qe,h=new fm,m=[],l=[],u=[];for(let i=t.getFirstGeometry();i!==Ar;i=t.getNextGeometry(i))for(let c=t.getFirstPath(i);c!==Ar;c=t.getNextPath(c)){let i=t.getPathSize(c),g=t.getFirstVertex(c),d=0,_=-1;for(let p=0;p<i;p++){let f=t.getNextVertex(g);if(!t.querySegment(g,h,!0,!1)){g=f;continue}if(0===d){_=t.getVertexIndex(g);const e=Nc.regularizeCurve(t,h.get(),g,s);if(e>=0){this.m_nsr&&0===this.m_nsr.m_reason&&this.m_nsr.assign(new Is(13,_,-1)),d=e,i=t.getPathSize(c),f=t.getNextVertex(g);const s=t.querySegment(g,h,!0,!1);n(s)}}else d--;const x=t.getVertexIndex(g);let y;-1!==this.m_originalVertexIndex&&t.setUserIndex(g,this.m_originalVertexIndex,_),t.setSegmentToIndex(x,null);let P=!1;switch(h.get().getGeometryType()){case o.enumEllipticArc:case o.enumRationalBezier2:y=mh(h.get(),0,s,r,!0,l,u,m),P=!0;break;default:{const t=!this.m_bIsSimple||!h.get().isMonotoneQuickAndDirty();y=hh(h.get(),e,s,t,r,l,m)}}const C=this.m_originalPlanarSegments.length;if(t.setSegmentParentageAndBreak(g,C,!0),!l[1].isNAN()){let e=null;e=P?new pi({points:l,weights:u}):new jo({cp:l}),e.snapControlPoints(s*s),t.setSegmentToIndex(x,e)}const E=P?2:3;for(let e=1,n=y,i=E;e<n;++e,i+=E){h.get().queryCoord(m[e],a);const n=t.insertVertex(c,f,a);if(-1!==this.m_originalVertexIndex&&t.setUserIndex(n,this.m_originalVertexIndex,_),!l[i+1].isNAN())if(P){const e=new pi({points:l.slice(i),weights:u.slice(i)});e.snapControlPoints(s*s),t.setSegmentToIndex(t.getVertexIndex(n),e)}else{const e=new jo({cp:l.slice(i)});e.snapControlPoints(s*s),t.setSegmentToIndex(t.getVertexIndex(n),e)}t.setSegmentParentageAndBreak(n,C,!1)}y>1&&(p+=y-1,i=t.getPathSize(c)),this.m_originalPlanarSegments.push(h.releaseSegment()),g=f}}}buildLinearSegmentParentage(t,e,s,i,r){if(this.m_type=0,this.m_densificationDeviation=e,this.m_maxSegmentsPerCurve=i,!t.hasCurves())return;n(!t.hasSegmentParentage()),this.m_tolerance=s,this.m_originalPlanarSegments=[],this.m_bIsSimple&&(this.m_originalVertexIndex=t.createUserIndex());const o=new qe,a=new fm,h=new lh(0,e,0,this.m_progressTracker,!1,i),m=[];for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e))for(let i=t.getFirstPath(e);i!==Ar;i=t.getNextPath(i)){let e=t.getPathSize(i),r=t.getFirstVertex(i);for(let l=0;l<e;l++){let l=t.getNextVertex(r);if(!t.querySegment(r,a,!0,!1)){r=l;continue}if(Nc.regularizeCurve(t,a.get(),r,s)>=0){e=t.getPathSize(i),l=t.getNextVertex(r);const s=t.querySegment(r,a,!0,!1);n(s)}const u=t.getVertexIndex(r);-1!==this.m_originalVertexIndex&&t.setUserIndex(r,this.m_originalVertexIndex,u),t.setSegmentToIndex(u,null),m.length=0,h.densifySegment(a.get(),m),this.progress_();const c=this.m_originalPlanarSegments.length;t.setSegmentParentageAndBreak(r,c,!0);for(let e=1,s=m.length-1;e<s;++e){a.get().queryCoord(m[e],o);const s=t.insertVertex(i,l,o);t.setSegmentParentageAndBreak(s,c,!1),-1!==this.m_originalVertexIndex&&t.setUserIndex(s,this.m_originalVertexIndex,u)}this.m_originalPlanarSegments.push(a.releaseSegment()),r=l}}t.clearSegments()}stitchCurves(t,e,s){Nc.st_stitchCurvesImpl(this,t,e,s,!1)}clearStitcher(t){this.m_originalPlanarSegments.length=0,-1!==this.m_originalVertexIndex&&(t.removeUserIndex(this.m_originalVertexIndex),this.m_originalVertexIndex=-1),t.deleteSegmentParentage()}static st_verifyParentage(t){Nc.st_stitchCurvesImpl(null,t,Ar,0,!0)}getOriginalVertexIndex(t,e){return-1!==this.m_originalVertexIndex&&e!==Ar?t.getUserIndex(e,this.m_originalVertexIndex):-1}getOriginalSegmentTypeInfo(t){if(-1!==t){const e=this.m_originalPlanarSegments[t];switch(e.getGeometryType()){case o.enumEllipticArc:return 0===e.projectionBehavior()?0:1;case o.enumBezier:return 2;case o.enumBezier2:return 3;case o.enumLine:return-1;case o.enumRationalBezier2:return 4;default:f("")}}return-1}progress_(t=!1){this.m_progressCounter++}processSpanSmartTe_(t,e,s,i,r,o,a){if(e===s&&0===i)return n(t.getNextVertex(e)===Ar),t.setSegmentToIndex(t.getVertexIndex(e),null),void t.setSegmentParentageAndBreak(e,-1);const h=t.getNextVertex(e),m=t.getXY(e),u=t.getXY(s);let c,g=0;{let e=2,r=m;for(let n=h;n!==s;n=t.getNextVertex(n)){const s=t.getXY(n);g+=l.distance(s,r),r=s,e++}g+=l.distance(u,r),n(e===i)}if(null===r)return t.setSegmentToIndex(t.getVertexIndex(e),null),void t.removeVertices(h,s);const d=a;let _=r.getClosestCoordinate(m,!1),p=r.getClosestCoordinate(u,!1);const f=r.calculateLength2D();let x=r.tToLength(_),y=r.tToLength(p);const P=Math.abs(x)>10*d&&Math.abs(x-f)>10*d,C=Math.abs(y)>10*d&&Math.abs(y-f)>10*d,E=t=>{const e=t.calculateLength2D();return Math.abs(e-g)>Math.max(.2*g,4*d)?null:t};let S=r.isClosed();if(!S){const t=l.distance(r.getStartXY(),r.getEndXY());t<=d&&f>5*t&&(S=!0)}if(S){let o,a,h=new l;if(2===i)h=l.lerp(m,u,.5),o=r.getClosestCoordinate(h,!1),a=r.tToLength(o);else{let s=t.getNextNthVertex(e,(i-1)/2);h=t.getXY(s),o=r.getClosestCoordinate(h,!1),a=r.tToLength(o);let n=Math.abs(a)>10*d&&Math.abs(a-f)>10*d;if(!n&&(i-1>=4&&(s=t.getNextNthVertex(e,(i-1)/4),o=r.getClosestCoordinate(h,!1),a=r.tToLength(o),n=Math.abs(a)>10*d&&Math.abs(a-f)>10*d),!n))return}let g=!1;const S=x===y;if(S){const s=0;let n=2,o=4;i-1<=4&&(n=s+1,o=s+2);const a=m,h=t.getXY(t.getNextNthVertex(e,n)),u=t.getXY(t.getNextNthVertex(e,o));g=-l.orientationNonRobust(a,h,u)*gt(r.calculateArea2DHelper())>0}else C?P?g=a>x:a<y?(x=0,_=0):(x=f,_=1):a>x?(y=f,p=1):(y=0,p=0);if(S)c=r.clone(),c.dropAllAttributes(),g||c.reverse(),n(m.equals(u));else{let t=!1;_>p&&(t=!0,[_,p]=[p,_]),c=r.cut(_,p,!0),c.getDescription().getAttributeCount(),t&&c.reverse()}c.setCoordsForIntersector(m,u,!1),c=E(c),c&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),c))}else if(P||C){if((!P||!C)&&l.distance(r.getStartXY(),r.getEndXY())<10*d){const n=[ft(_,p),ft(_,p),ft(_,p)];P?(n[1].second=0,n[2].second=1):(n[1].first=1,n[2].first=0);const i=[null,null,null],o=[0,0,0];let a=Number.MAX_VALUE,h=0;for(let t=0;t<3;t++){let e=!1;if(n[t].first>n[t].second){e=!0;const s=n[t].first;n[t].first=n[t].second,n[t].second=s}i[t]=r.cut(n[t].first,n[t].second,!0),i[t].dropAllAttributes(),e&&i[t].reverse(),i[t].setCoordsForIntersector(m,u,!1),o[t]=i[t].calculateLength2D();const s=Math.abs(g-o[t]);s<a&&(a=s,h=t)}return c=i[h],c=E(c),void(c&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),c)))}let n=!1;_>p&&(n=!0,[_,p]=[p,_]),c=r.cut(_,p,!0),c.dropAllAttributes(),n&&c.reverse(),c.setCoordsForIntersector(m,u,!1),c=E(c),c&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),c))}else{if(c=r.clone(),c.dropAllAttributes(),x>y&&c.reverse(),g<Math.max(.75*f,f-this.m_densificationDeviation*(i-1))){const t=_>p?p:_,e=c.tToLength(t)+g;let s=c.lengthToT(e);s=A(s,t,1),c=c.cut(t,s,!0)}c.setCoordsForIntersector(m,u,!1),c=E(c),c&&(this.removeSpanBetween(t,e,s),t.setSegmentToIndex(t.getVertexIndex(e),c))}}processSpanCurves_(t,e,s,i,r,o,a){if(e===s&&0===i)return n(t.getNextVertex(e)===Ar),t.setSegmentToIndex(t.getVertexIndex(e),null),void t.setSegmentParentageAndBreak(e,-1);const h=t.getNextVertex(e);{let e=2;for(let n=h;n!==s;n=t.getNextVertex(n))e++;n(e===i)}if(null===r)return t.setSegmentToIndex(t.getVertexIndex(e),null),void t.removeVertices(h,s);const m=t.getXY(e),l=t.getXY(s);if(r.isClosed()){if(m.isEqualPoint2D(l)&&m.isEqualPoint2D(r.getStartXY())){let n;if(n=this.verifySegmentFitnessCurves(t,e,s,i,r,o,a)){const i=r.clone();return i.dropAllAttributes(),n<0&&i.reverse(),this.removeSpanBetween(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),i)}}}else if(m.isEqualPoint2D(r.getStartXY())){if(l.isEqualPoint2D(r.getEndXY())){const h=r.clone();h.dropAllAttributes();const m=this.verifySegmentFitnessCurves(t,e,s,i,h,o,a);if(m)return n(m>0),this.removeSpanBetween(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),h)}}else if(l.isEqualPoint2D(r.getStartXY())&&m.isEqualPoint2D(r.getEndXY())){const h=r.getReversed();h.dropAllAttributes();const m=this.verifySegmentFitnessCurves(t,e,s,i,h,o,a);if(m)return n(m>0),this.removeSpanBetween(t,e,s),void t.setSegmentToIndex(t.getVertexIndex(e),h)}this.processSpanSplitSegmentCurves(t,e,s,i,r,o,a)}processSpan_(t,e,s,n,i,r,o){return 0===this.m_type?void this.processSpanSmartTe_(t,e,s,n,i,r,o):void this.processSpanCurves_(t,e,s,n,i,r,o)}processSpanSplitSegmentCurves(t,e,s,n,i,r,o){if(i.isLine())return;if(this.fitSegmentToSpanCurves(t,e,s,n,i,r,o))return;const a=o*o;let h=n,m=e;const u=t.getXY(e);let c=i.getClosestCoordinate(u,!1);const g=i.getCoord2D(c);let d=!1;const _=l.sqrDistance(u,g);if(_>a){const n=t.getNextVertex(e);if(this.approximateSpanSectionCurves(t,e,i,r,o),n===s)return;m=n,d=!0,h-=1}let p=s;const f=t.getXY(s);c=i.getClosestCoordinate(f,!1);const x=i.getCoord2D(c);let y=!1;const P=l.sqrDistance(f,x);if(P>a){const e=t.getPrevVertex(s);if(this.approximateSpanSectionCurves(t,e,i,r,o),e===m)return;p=e,y=!0,h-=1}if((d||y)&&this.fitSegmentToSpanCurves(t,m,p,h,i,r,o))return;let C=!1;if(!d&&_>0){const s=t.getNextVertex(e);if(this.approximateSpanSectionCurves(t,e,i,r,o),s===p)return;m=s,d=!0,C=!0,h-=1}if(!y&&P>0){const e=t.getPrevVertex(s);if(this.approximateSpanSectionCurves(t,e,i,r,o),e===m)return;p=e,y=!0,C=!0,h-=1}if(C&&this.fitSegmentToSpanCurves(t,m,p,h,i,r,o))return;let E=m;for(;;){const e=t.getNextVertex(E);if(this.approximateSpanSectionCurves(t,E,i,r,o),E=e,E===p)return}}fitSegmentToSpanCurves(t,e,s,n,i,r,o){const a=[];a.push(t.getXY(e));let h=e;const m=new fm;for(;;){t.querySegment(h,m,!1,!0);const e=[.1,.25,.4,.5,.6,.75,.9,1];let i=0;for(const t of e)(2===n||1&i)&&a.push(m.get().getCoord2D(t)),i++;if(h=t.getNextVertex(h),h===s)break}const u=(()=>{let t=a[0].compare(a.at(-1));if(0===t){const e=new q(0);!function(t,e,s){if(s.reset(),e<3)return;const n=t[0].clone(),i=n.x,r=n.y,o=t[1].clone(),a=new l;for(let i=2;i<e;i++)a.assign(t[i]),s.pe((a.x-n.x)*(o.y-r)),n.assign(o),o.assign(a);s.pe((i-n.x)*(o.y-r))}(a,a.length,e),t=e.getResult()>=0?-1:1}return t>0})();u&&a.reverse();const c=i.clone();if(c.dropAllAttributes(),u&&c.reverse(),c.setSegmentFromCoordsForStitcher(a,a.length),u&&c.reverse(),c.snapControlPoints(this.m_tolerance*this.m_tolerance),this.verifySegmentFitnessCurves(t,e,s,n,c,r,o)){this.removeSpanBetween(t,e,s);const n=t.getVertexIndex(e);return t.setSegmentToIndex(n,c),!0}return!1}approximateSpanSectionCurves(t,e,s,n,i){const r=new fm;if(!t.querySegment(e,r,!0,!1))return;const a=s.getGeometryType();if(a!==r.get().getGeometryType()){if(a===o.enumEllipticArc){if(r.get().getGeometryType()!==o.enumRationalBezier2)return;if(0===s.projectionBehavior()){const s=[];!function(t,e,s,n,i){const r=hn(e),o=Math.max(4*r,s);new Cc(e,null,o,Number.NaN,i).approximateWithCirclesImpl(!1,n)}(0,r.get(),i,s,this.m_progressTracker);const n=t.getNextVertex(e),o=t.getPathFromVertex(e),a=new qe;let h=e;for(let e=1,i=s.length;e<i;e++){const i=s[e],m=r.get().getCoord2D(s[e-1]),l=r.get().getCoord2D(C(s[e-1],i,.5));r.get().queryCoord(i,a);const u=a.getXY(),c=new eh;c.constructCircularArcThreePoint(m,u,l);let g=Ar;i<1&&(g=t.insertVertex(o,n,a)),t.setSegmentToIndex(t.getVertexIndex(h),c),h=g}return}{const s=T(l,3);r.get().queryControlPoints(s);const n=[0,0,0];r.get().queryWeights(n);const i=ka(n),o=new eh;return function(t,e,s,n,i){Zh(t,e,null,!1,i)}(s,i*i,0,0,o),void t.setSegmentToIndex(t.getVertexIndex(e),o)}}P("approximate_span_section_")}}verifySegmentFitnessCurves(t,e,s,n,i,o,a){const m=t.getXY(e),l=t.getXY(s);if(!m.isEqualPoint2D(i.getStartXY())||!l.isEqualPoint2D(i.getEndXY()))return 0;let u=0;if(i.isClosed()){const t=i.getCoord2D(.1).sub(m);u=i.getCoord2D(.7).sub(m).crossProduct(t)>=0?1:-1}const c=h(gn.s_maxMonotonicPartParams,Number.NaN);let g=i.getMonotonicPartParams(c.length,c);g--;const d=new pm,_=[1,.5,.75,.25];let f=0,x=e;const y=m.clone();for(;;){const e=t.getNextVertex(x);let n=t.getSegment(x);null===n&&(t.queryLineConnector(x,d,!0),n=d);for(let t=e===s?1:0;t<_.length;t++){const e=n.getCoord2D(_[t]);if(!i.isCloserThanDistance(e,r.unit(),a))return 0}if(g>1)for(let t=1;t<g;){const e=i.getCoord2D(c[t]);n.isCloserThanDistance(e,r.unit(),a)?(c[g-1]=p(c[t],c[t]=c[g-1]),g--):t++}if(u){const t=n.getCoord2D(.25);f+=t.sub(m).crossProduct(y.sub(m)),y.assign(t),t.assign(n.getCoord2D(.75)),f+=t.sub(m).crossProduct(y.sub(m)),y.assign(t)}if(x=e,x===s)return g>1?0:u?f<0?-u:u:1}}removeSpanBetween(t,e,s){t.setSegmentToIndex(t.getVertexIndex(e),null);const n=t.getNextVertex(e);n!==s&&t.removeVertices(n,s)}static st_stitchCurvesImpl(t,e,s,i,r){if(!e.hasSegmentParentage())return;Ic(e);let o=s===Ar?e.getFirstGeometry():s;for(;o!==Ar;)if(Zt(e.getGeometryType(o))){for(let s=e.getFirstPath(o);s!==Ar;s=e.getNextPath(s)){let o=e.getPathSize(s);const a=e.isClosedPath(s);a&&(o+=1);let h=e.getFirstVertex(s);const m=e.getSegmentParentage(h);if(a){if(-1!==m&&!e.getSegmentParentageBreakVertex(h)){let t=e.getPrevVertex(h);const s=h;for(let i=0;;i++){const r=e.getSegmentParentage(t);if(m!==r){n(-1===r);break}if(h=t,e.getSegmentParentageBreakVertex(t))break;if(t===s){h=s,e.setSegmentParentageBreakVertex(h,!0);break}t=e.getPrevVertex(t),n(i<o)}}}else n(-1===m||e.getSegmentParentageBreakVertex(h));let l=h;for(let s=0;s<o&&l!==Ar;){const a=e.getSegmentParentage(l);if(-1===a){if(s++,l=e.getNextVertex(l),l===h)break;continue}let m=0,u=Ar;const c=l;m=1;let g=e.getNextVertex(c);for(;s<o&&g!==Ar;){s++,u=g,m++;const t=e.getSegmentParentage(g);if(-1===t||e.getSegmentParentageBreakVertex(g))break;n(t===a),g=e.getNextVertex(g)}if(u===Ar){n(0);break}if(!r){const s=t.m_originalPlanarSegments[a];t.processSpan_(e,c,u,m,s,a,i)}if(l=u,l===h)break}}if(s!==Ar)break;o=e.getNextGeometry(o)}else o=s===Ar?e.getNextGeometry(o):Ar}static st_stitchCurvesFromLinesImpl(t,e,s,i,r){let o=s===Ar?e.getFirstGeometry():s;for(;o!==Ar;){for(let s=e.getFirstPath(o);s!==Ar;s=e.getNextPath(s)){let o=e.getPathSize(s);e.isClosedPath(s)&&(o+=1);let a=!0,h=!1;const m=e.getFirstVertex(s);let l=m;for(let s=0;s<o&&l!==Ar;){let u=e.getSegmentParentage(l);if(-1===u||a){a=!1,s++,l=e.getNextVertex(l),h=!0;continue}let c,g,d=0;if(h?(c=e.getPrevVertex(l),g=l,n(c!==Ar),n(g!==c),n(-1===e.getSegmentParentage(c)||m===c)):(c=l,g=e.getNextVertex(c),s++,n(g!==Ar),n(g!==c),u=e.getSegmentParentage(g)),d=2,h=!1,-1===u||e.getSegmentParentageBreakVertex(g)){l=g;continue}let _=e.getNextVertex(g);for(s++;s<o&&_!==Ar;){g=_,d++;const t=e.getSegmentParentage(_);if(-1===t||e.getSegmentParentageBreakVertex(_))break;n(t===u),s++,_=e.getNextVertex(_)}if(!r){const s=t.m_originalPlanarSegments[u];t.processSpan_(e,c,g,d,s,u,i)}l=g}}if(s!==Ar)break;o=e.getNextGeometry(o)}}static st_stitchCurvesFromCurvesImpl(t,e,s,i,r){let o=s===Ar?e.getFirstGeometry():s;for(;o!==Ar;)if(Zt(e.getGeometryType(o))){for(let s=e.getFirstPath(o);s!==Ar;s=e.getNextPath(s)){let o=e.getPathSize(s);const a=e.isClosedPath(s);a&&(o+=1);let h=e.getFirstVertex(s);if(a){if(-1!==e.getSegmentParentage(h)){let t=h;for(let n=0;!e.getSegmentParentageBreakVertex(t);n++){if(n===o){h=e.getFirstVertex(s),e.setSegmentParentageBreakVertex(t,!0);break}t=e.getPrevVertex(t)}}}else n(-1===e.getSegmentParentage(h)||e.getSegmentParentageBreakVertex(h));let m=h;for(let s=0;s<o&&m!==Ar;){const a=e.getSegmentParentage(m);if(-1===a){s++,m=e.getNextVertex(m);continue}let h=0,l=Ar;const u=m;h=1;let c=e.getNextVertex(u);for(;s<o&&c!==Ar;){s++,l=c,h++;const t=e.getSegmentParentage(c);if(-1===t||e.getSegmentParentageBreakVertex(c))break;n(t===a),c=e.getNextVertex(c)}if(l===Ar)break;if(!r){const s=t.m_originalPlanarSegments[a];t.processSpan_(e,u,l,h,s,a,i)}m=l}}if(s!==Ar)break;o=e.getNextGeometry(o)}else o=s===Ar?e.getNextGeometry(o):Ar}static regularizeCurve(t,e,s,n){let i=e.snapControlPoints(n*n);if(i){const n=t.getVertexIndex(s),i=e.clone();t.setSegmentToIndex(n,i)}if(e.getGeometryType()===jo.type){const r=[],o=e.calculateSpecialPointsForCracking(n,r);if(o>0){const a=[];if(o>1)for(let t=0;t<o;t++)if(a.push(e.getCoord2D(r[t])),t>0){const e=(Math.abs(a[t].x)+Math.abs(a[t].y))*w(),s=l.distance(a[t-1],a[t]);if(s<e&&s>0){const e=new l;st(a[t-1],a[t],.5,e),a[t-1]=e,a[t]=e}}t.splitSegment(s,r,o),i=t.snapControlPoints(s,o+1,n*n)||i;for(let e=0;e<o;e++)s=t.getNextVertex(s),t.setSegmentParentageBreakVertex(s,!0);return o}}return i?0:-1}}function Ac(t,e,s,n,i){return new Vc(t,s,e,n,i).do_()}function Mc(t,e,s=1,n=1,i=1,r=1){if(n>r)return t;if(r>n)return e;const o=new qe;return function(t,e,s,n,i,r,o,a,h){const m=t.equals(e);if(n>r)return o.assignCopy(t),h[0]=n,a[0]=s,m;if(r>n)return o=e,h[0]=r,a[0]=i,m;o.assignCopy(t);const l=xl(t.getXY(),e.getXY(),s,n,i,r);o.setXY(l.pt),a[0]=l.weight,h[0]=l.rank}(t,e,s,n,i,r,o,[0],[0]),o}function Gc(t,e,s){const n=Je(e),i=$e(e);return!!function(t,e,s,n,i){const r=new Cl(i);return r.m_shape=t,r.m_sqrTolerance=e*e,r.m_cellSize=2*e,r.m_invCellSize=1/r.m_cellSize,r.m_geometry=-1,r.m_bTrackChanges=!1,r.needsClustering()}(t,n,0,0,s)||Xl(!0,t,i,null,s)}function qc(t,e,s){return Vc.fixCurveTwoPointLoops(t,e,s)}function Fc(t){return Je(t)}class Vc{constructor(t,e,s,n,i){this.m_shape=t,this.m_progressTracker=e,this.m_tolerance=s,this.m_bFilterDegenerateSegments=n,this.m_bTrackChanges=i,this.m_progressCounter=0}do_(){const t=new cs(this.m_tolerance.tolerance,this.m_tolerance.resolution),e=Fc(t);let s=$e(t);const n=1.00001*s;s*=1.000001;let i=!1;const r=this.m_shape.getTotalPointCount()+10>30?1e3:(this.m_shape.getTotalPointCount()+10)*(this.m_shape.getTotalPointCount()+10),o=this.m_shape.hasPointFeatures();for(let t=0;;t++){this.m_shape.dbgCheckSelection(),t>r&&P("crack_and_cluster_iteration_exceeded"),this.m_shape.dbgVerifyMonotone();let a=-1;0===t&&(a=this.firstCrack_(),i||=a>0);const h=this.cluster_(e);if(this.m_shape.dbgVerifyMonotone(),i||=h,this.m_bFilterDegenerateSegments){const t=0!==this.m_shape.filterClosePoints(e,!0,!1,this.m_bTrackChanges,Ar);i||=t,this.m_shape.dbgVerifyMonotone()}const m=this.m_shape.snapControlPointsOnSelection(n*n);i||=m,this.m_shape.dbgCheckSelection();let l=!1;if((0===t&&-1===a||o||Xl(!0,this.m_shape,s,null,this.m_progressTracker))&&(l=this.crack_(n),i||=l,this.m_shape.dbgVerifyMonotone()),!l&&!Vc.fixCurveTwoPointLoops(this.m_shape,e,this.m_progressTracker)){this.m_shape.dbgVerifyMonotone();break}}return i&&function(t){if(!t.hasSegmentParentage())return;Ic(t);const e=new Fe(0),s=t.queryVertexIteratorOnSelection();for(let t=s.next();t!==Ar;t=s.next())e.add(t);if(0===e.size())return;t.sortVerticesSimpleByY(e,0,e.size()),e.add(Ar);const n=l.getNAN();t.queryXY(e.read(0),n);let i=0;const r=l.getNAN();for(let s=1,o=e.size();s<o;s++){{const n=e.read(s);n!==Ar?t.queryXY(n,r):r.setNAN()}if(!r.isEqualPoint2D(n)){if(s-i>1){let n=!1;for(let r=i;r<s;++r){const s=e.read(r);if(t.getSegmentParentageBreakVertex(s)){n=!0;break}}if(!n){const r=(e,s,n)=>{const i=t.getPrevVertex(e),r=t.getNextVertex(e);i!==Ar?s.assign(t.getXY(i)):s.setNAN(),r!==Ar?n.assign(t.getXY(r)):n.setNAN()},o=new l,a=new l;r(e.read(i),o,a);for(let t=i+1;t<s;++t){const s=e.read(t);if(s===Ar)continue;const i=new l,h=new l;r(s,i,h);const m=(t,e)=>!!(t.equals(e)||t.isNAN()&&e.isNAN());if(!(m(i,o)&&m(h,a)||m(h,o)&&m(i,a))){n=!0;break}}}if(n)for(let n=i;n<s;++n)t.setSegmentParentageBreakVertex(e.read(n),!0)}n.setCoordsPoint2D(r),i=s}}}(this.m_shape),i}cluster_(t){return pl(this.m_shape,t,Ar,this.m_bTrackChanges,this.m_progressTracker)}crack_(t){return function(t,e,s,n){if(!Yl(t))return!1;const i=new Rl(n);i.m_shape=t,i.m_tolerance=e,i.m_bTrackChanges=s;let r=!1;const o=t.hasCurves()?5:15;return r=t.getTotalPointCount()<o?i.crackBruteForce_():i.crackerPlaneSweep_(),r}(this.m_shape,t,this.m_bTrackChanges,this.m_progressTracker)}static fixCurveTwoPointLoops(t,e,s){if(!t.hasCurves())return!1;t.dbgVerifyCurves();const i=t.createUserIndexUninitialized(),r=new Fe(0),o=t.queryVertexIteratorOnSelection();for(let e=o.next();e!==Ar;e=o.next())r.add(e),t.setUserIndex(e,i,-1);if(0===r.size())return!1;r.add(Ar),t.sortVerticesSimpleByY(r,0,r.size()-1);let a=0;const h=t.getXY(r.read(a)),m=new l(Number.NaN,Number.NaN),u=[];for(let e=1,s=r.size();e<s;++e){const s=r.read(e),n=s!==Ar?t.getXY(s):m;if(n.equals(h))continue;const o=[];for(let s=a;s<e;s++){const e=r.read(s),n=t.getPrevVertex(e);if(n!==Ar&&-1===t.getUserIndex(n,i)){const e=Yc(t.getXY(n),t.getSegment(n));0!==l.sqrDistance(h,e.otherPt)&&(e.vert=n,e.dir=-1,o.push(e)),t.setUserIndex(n,i,1)}const a=t.getNextVertex(e);if(a!==Ar&&-1===t.getUserIndex(e,i)){const s=Yc(t.getXY(a),t.getSegment(e));0!==l.sqrDistance(h,s.otherPt)&&(s.vert=e,s.dir=1,o.push(s)),t.setUserIndex(e,i,1)}}if(o.length>1){o.sort((t,e)=>kc(t,e));const t=Yc(m.clone(),null);o.push(t);let e=0;for(let t=1,s=o.length;t<s;t++)if(!o[t].otherPt.equals(o[t-1].otherPt)){if(t-e>1&&null!==o[e].seg){let s=!1;const n=e;for(let i=e+1;i<t;i++)if(!Xc(o[n],o[i])){s=!0;break}if(s)for(let s=e;s<t&&null!==o[s].seg;s++)u.push(o[s].vert)}e=t}}a=e,h.setCoordsPoint2D(n)}for(const s of u){const i=t.getSegment(s);n(null!==i);const r=t.getXY(s),o=t.getXY(t.getNextVertex(s));if(l.distance(r,o)<3*e)t.setSegmentToIndex(t.getVertexIndex(s),null);else{const e=i.lengthToT(.5*i.calculateLength2D());t.splitSegment(s,[e],1)}}return t.removeUserIndex(i),u.length>0}firstCrack_(){const t=this.m_shape.getEnvelope2D(this.m_progressTracker),e=Oe(null,t,!0).total();if(4*e<this.m_tolerance.total()){let t=!1;const s=1.1*e,n=e,i=this.cluster_(s);t||=i;let r=0;this.m_bFilterDegenerateSegments&&(r=this.m_shape.filterClosePoints(0,!0,!1,this.m_bTrackChanges,Ar));const o=this.crack_(n);return t||=o,t?1:r?2:0}return-1}progress_(t=!1){this.m_progressCounter++,!t&&4095&this.m_progressCounter||(this.m_progressCounter=0)}}function Yc(t,e){return{otherPt:t,seg:e,vert:-1,dir:0}}function Xc(t,e){if(n(t.otherPt.equals(e.otherPt)),null===t.seg)return null===e.seg;if(null===e.seg)return!1;const s=t.seg.getGeometryType();if(s!==e.seg.getGeometryType())return!1;if(s===o.enumBezier){const s=t.seg,n=e.seg;let i=s.getControlPoint1(),r=s.getControlPoint2();-1===t.dir&&(r=p(i,i=r));let o=n.getControlPoint1(),a=n.getControlPoint2();return-1===e.dir&&(a=p(o,o=a)),i.equals(o)&&r.equals(a)}if(s===o.enumRationalBezier2){const s=t.seg,n=e.seg,i=s.getControlPoint1(),r=n.getControlPoint1();if(!i.equals(r))return!1;const o=[0,0,0];s.queryWeights(o),-1===t.dir&&(o[2]=p(o[0],o[0]=o[2]));const a=[0,0,0];return n.queryWeights(a),-1===e.dir&&(a[2]=p(a[0],a[0]=a[2])),o[0]===a[0]&&o[1]===a[1]&&o[2]===a[2]}P("")}function kc(t,e){const s=t.otherPt.compare(e.otherPt);return 0!==s?s:function(t,e){if(null===t.seg||null===e.seg)return null!==t.seg?-1:null!==e.seg?1:0;const s=t.seg.getGeometryType(),n=e.seg.getGeometryType();return s<n?-1:s>n?1:0}(t,e)}var Rc=Z,Lc=F,Hc=jt;function Bc(t){switch(t){case 1:return 1;case 2:return 2;case 3:return 3;case 4:return 4;case 0:return 0;default:n(0,"unrecognized cut side")}return 3}function Uc(t,e,s,n){return new Jc(n).autoCompleteImpl(t,e,s)}function zc(t,e,s,n,i,r,a){const h=new Jc(i);h.m_bOGCOutput=!0;const m=t.getGeometryType()===o.enumPolygon&&1===t.getFillRule()&&!ns(n);return h.planarSimplifyImpl_(t,e,m,s,n,i,r,a)}function Oc(t,e,s,n,i,r,o,a){return new Jc(r).planarSimplifyImpl_(t,e,s,n,i,r,o,a)}function Wc(t,e,s){return function(t,e,s){const n=t.createInstance(),i=T(l,100),r=new Array(100),o=t.getPointCount();let a=!0;const h=2===e.getDimension();1!==e.getDimension()&&2!==e.getDimension()&&P("");for(let m=0;m<o;){const o=t.queryCoordinates(i,i.length,m,-1)-m;h?pc(e,i,o,s.total(),r):fc(e,i,o,s.total(),r);let l=0;for(let e=0;e<o;e++)0===r[e]&&(a&&(a=!1,n.addPoints(t,0,m)),l!==e&&n.addPoints(t,m+l,m+e),l=e+1);a||l===o||n.addPoints(t,m+l,m+o),m+=o}return a?t:n}(t,e,s)}function jc(e,s,n,i){if(e.getDimension()>s.getDimension())return $c(tg(e),e,0,"^");if(e.getDimension()<s.getDimension())return $c(tg(s),e,0,"^");if(e.isEmpty())return $c(tg(s),e,0,"^");if(s.isEmpty())return $c(tg(e),e,0,"^");const r=new t;e.queryEnvelope(r);const a=new t;s.queryEnvelope(a);const h=new t;h.setCoords({env2D:r}),h.mergeEnvelope2D(a);const m=Oe(n,h,!0),l=new Jc(i),u=new Vr,c=u.addGeometry(tg(e)),g=u.addGeometry(tg(s));let d=0,_=null;if(u.hasCurves()){_=new Tc;const t=u.getEnvelope2D(i);d=wc(m.total()),Ec(u,bc(m.total(),t),m.total(),0,_,null,i)}l.setEditShapeCrackAndCluster(u,m);const p=l.symmetricDifference(c,g);null!==_&&_.stitchCurves(u,p,d,!0);const f=$c(u.getGeometry(p),e,0,"^");return Rc(f.getGeometryType())&&(f.getImpl().setIsSimple(4,m.total()),f.getGeometryType()===o.enumPolygon&&f.getImpl().updateOGCFlagsProtected()),f}function Zc(t,e,s){return function(t,e,s){if(t.isEmpty())return t.createInstance();if(e.isEmpty())return t.createInstance();const n=[new l],i=[0],r=2===e.getDimension();return 1!==e.getDimension()&&2!==e.getDimension()&&P(""),n[0]=t.getXY(),r?pc(e,n,1,s.total(),i):fc(e,n,1,s.total(),i),0!==i[0]?t:t.createInstance()}(t,e,s)}function Qc(t,e,n,i,r,o=!1){0===e&&s("not enough geometries to dissolve");let a=0;for(let s=0,n=e;s<n;s++)a=Math.max(t[s].getDimension(),a);if(2===a||1===a)return new Jc(i).dissolveMultiPaths_(a,!1,t,e,n,r,o);let h=0,m=-1;for(let s=0,n=e;s<n;s++)t[s].getDimension()===a&&(-1===m&&(m=s),t[s].isEmpty()||(m=s,h++));if(h<2)return tg(t[m]);const l=ve.constructEmpty(),u=new Vr;let c=Ar;for(let s=0,n=e;s<n;s++)if(t[s].getDimension()===a&&!t[s].isEmpty()){c===Ar?c=u.addGeometry(tg(t[s])):u.appendGeometry(c,tg(t[s]));const e=ve.constructEmpty();t[s].queryLooseEnvelope(e),l.mergeEnv3D(e)}const g=Oe(n,l.getEnvelope2D(),!0),d=new Jc(i);if(o){const t=ls(n,l.getEnvelopeZs(),!0);return d.planarSimplify3DImpl_(u,g,t,0,!0)}return d.m_bOGCOutput=!0,d.planarSimplifyMultiPoints(u,g,!1,-1)}function Kc(t,e,n,i,r,o=!1){e<2&&s("not enough geometries to dissolve");let a=0;for(let s=0,n=e;s<n;s++)a=Math.max(t[s].getDimension(),a);if(2===a||1===a)return new Jc(i).dissolveMultiPaths_(a,!0,t,e,n,r,o);const h=ve.constructEmpty(),m=new Vr;let l=Ar,u=0,c=-1;for(let s=0,n=e;s<n;s++)if(t[s].getDimension()===a&&(-1===c&&(c=s),!t[s].isEmpty())){c=s,l===Ar?l=m.addGeometry(tg(t[s])):m.appendGeometry(l,tg(t[s]));const e=ve.constructEmpty();t[s].queryLooseEnvelope(e),h.mergeEnv3D(e),u++}if(u<2)return tg(t[c]);const g=0===a?n:null,d=Oe(g,h.getEnvelope2D(),!0),_=new Jc(i);if(o){const t=ls(g,h.getEnvelopeZs(),!0);return _.m_bOGCOutput=!0,_.planarSimplify3DImpl_(m,d,t,0,!0)}return _.planarSimplifyMultiPoints(m,d,!0,-1)}class Jc{constructor(t){this.m_topoGraph=null,this.m_maskLookup=[],this.m_dummyPt1=l.getNAN(),this.m_dummyPt2=l.getNAN(),this.m_fromEdgeForPolylines=Ar,this.m_progressCounter=0,this.m_bOGCOutput=!1,this.m_progressTracker=t}linesToPolygonsImpl(t,e){let s=0,n=0,i=null;if(t.hasCurves()){i=new Tc;const r=t.getEnvelope2D(this.m_progressTracker);n=wc(e.total());const o=bc(e.total(),r);s=Dc(o,n),Ec(t,o,e.total(),0,i,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,e.add(s));const r=this.m_topoGraph.createUserIndexForChains(),o=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(o,r,1);for(let t=this.m_topoGraph.getChainFirstIsland(o);t!==Ar;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,r,1);const a=[];for(let e=this.m_topoGraph.getFirstChain();e!==Ar;e=this.m_topoGraph.getChainNext(e)){if(1===this.m_topoGraph.getChainUserIndex(e,r))continue;this.m_topoGraph.setChainUserIndex(e,r,1);for(let t=this.m_topoGraph.getChainFirstIsland(e);t!==Ar;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,r,1);if(0===this.m_topoGraph.getChainArea(e))continue;const s=this.m_topoGraph.extractPolygonFromChainAndIslands(t,Ar,e,Ar);null!=i&&i.stitchCurves(t,s,n,!1);const o=t.getGeometry(s);a.push(o)}return new Es(a)}autoCompleteImpl(t,e,s){let n=0,i=0,r=null;if(t.hasCurves()){r=new Tc;const e=t.getEnvelope2D(this.m_progressTracker);i=wc(s.total());const o=bc(s.total(),e);n=Dc(o,i),Ec(t,o,s.total(),0,r,null,this.m_progressTracker)}this.setEditShapeCrackAndCluster(t,s.add(n));const o=this.m_topoGraph.getGeometryID(e),a=this.m_topoGraph.createUserIndexForChains(),h=this.m_topoGraph.getFirstChain();this.m_topoGraph.setChainUserIndex(h,a,1);for(let t=this.m_topoGraph.getChainFirstIsland(h);t!==Ar;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,a,1);const m=[];for(let e=this.m_topoGraph.getFirstChain();e!==Ar;e=this.m_topoGraph.getChainNext(e)){if(1===this.m_topoGraph.getChainUserIndex(e,a))continue;this.m_topoGraph.setChainUserIndex(e,a,1);for(let t=this.m_topoGraph.getChainFirstIsland(e);t!==Ar;t=this.m_topoGraph.getChainNextInParent(t))this.m_topoGraph.setChainUserIndex(t,a,1);if(0!==this.m_topoGraph.getChainParentage(e))continue;const s=this.m_topoGraph.getChainHalfEdge(e);let n=s,h=!1;do{const t=this.m_topoGraph.getHalfEdgeTwin(n);if(this.m_topoGraph.getHalfEdgeChain(t)!==e&&0!==(this.m_topoGraph.getHalfEdgeParentage(n)&o)){h=!0;break}n=this.m_topoGraph.getHalfEdgeNext(n)}while(n!==s);if(!h)continue;if(0===this.m_topoGraph.getChainArea(e))continue;const l=this.m_topoGraph.extractPolygonFromChainAndIslands(t,Ar,e,Ar);null!==r&&r.stitchCurves(t,l,i,!1);const u=t.getGeometry(l);m.push(u)}return new Es(m)}setEditShape(t,e=!1){null===this.m_topoGraph&&(this.m_topoGraph=new ll),this.m_topoGraph.setEditShape(t,this.m_progressTracker,!0,e)}setEditShapeCrackAndCluster(t,e){Ac(t,e,this.m_progressTracker,!0,!1);for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e))t.getGeometryType(e)===o.enumPolygon&&Zl(t,e,-1,this.m_bOGCOutput,Ar,this.m_progressTracker);this.setEditShape(t)}setHalfEdgeOrientations_(t,e){const s=this.m_topoGraph.getShape();for(let n=s.getFirstGeometry();n!==Ar;n=s.getNextGeometry(n))if(n===e)for(let e=s.getFirstPath(n);e!==Ar;e=s.getNextPath(e)){let n=s.getFirstVertex(e);if(n===Ar)continue;let i=s.getNextVertex(n);for(;i!==Ar;){const e=this.m_topoGraph.getClusterFromVertex(n),r=this.m_topoGraph.getClusterFromVertex(i),o=this.m_topoGraph.getHalfEdgeConnector(e,r);if(o!==Ar){const e=this.m_topoGraph.getHalfEdgeTwin(o);this.m_topoGraph.setHalfEdgeUserIndex(o,t,1),this.m_topoGraph.setHalfEdgeUserIndex(e,t,2)}n=i,i=s.getNextVertex(n)}}}flushVertices_(t,e){const s=this.m_topoGraph.getShape(),n=s.hasSegmentParentage(),i=new fm,r=s.insertPath(t,Ar);e.push(e[0]);const o=e.length;let a=Ar;for(let t=0;t<o;t++){const h=e[t];if(a=s.addVertex(r,h),!n)continue;const m=this.m_topoGraph.getClusterFromVertex(h);if(t>0&&this.m_topoGraph.isBreakNode(m)&&s.setSegmentParentageBreakVertex(a,!0),t<o-1){const n=this.m_topoGraph.getHalfEdgeConnector(m,this.m_topoGraph.getClusterFromVertex(e[t+1])),r=this.m_topoGraph.getSegmentParentage(n);s.setSegmentParentageAndBreak(a,r,t>0||this.m_topoGraph.isBreakNode(m)),this.m_topoGraph.isHalfEdgeCurve(n)&&(this.m_topoGraph.querySegmentXY(n,i),s.setSegmentToIndex(s.getVertexIndex(a),i.get().clone()))}}if(n){const t=this.m_topoGraph.getClusterFromVertex(e[o-1]);this.m_topoGraph.isBreakNode(t)&&s.setSegmentParentageBreakVertex(a,!0)}s.setClosedPath(r,!0)}processPolygonCuts_(t,e,s,n){const i=this.m_topoGraph.getGeometryID(s),r=this.m_topoGraph.getGeometryID(n),a=[],h=this.m_topoGraph.getShape(),m=this.m_topoGraph.createUserIndexForHalfEdges();for(let s=this.m_topoGraph.getFirstCluster();s!==Ar;s=this.m_topoGraph.getNextCluster(s)){const n=this.m_topoGraph.getClusterHalfEdge(s);if(n===Ar)continue;let l=n;do{if(1!==this.m_topoGraph.getHalfEdgeUserIndex(l,m)){let s=l,n=l,u=!1,c=0;do{if(this.m_topoGraph.setHalfEdgeUserIndex(s,m,1),u||0!==(this.m_topoGraph.getHalfEdgeParentage(s)&r)&&0!==(this.m_topoGraph.getHalfEdgeFaceParentage(s)&i)&&(n=s,u=!0),u){const e=this.m_topoGraph.getHalfEdgeOrigin(s),n=this.m_topoGraph.getClusterVertexIterator(e),i=this.m_topoGraph.getVertexFromVertexIterator(n);a.push(i),-1!==t&&0!==(this.m_topoGraph.getHalfEdgeParentage(s)&r)&&(c|=this.m_topoGraph.getHalfEdgeUserIndex(s,t))}s=this.m_topoGraph.getHalfEdgeNext(s)}while(s!==n);if(u&&this.m_topoGraph.getChainArea(this.m_topoGraph.getHalfEdgeChain(n))>0){const t=h.createGeometry(o.enumPolygon);this.flushVertices_(t,a),-1!==e&&h.setGeometryUserIndex(t,e,c)}a.length=0}l=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(l))}while(l!==n)}this.m_topoGraph.deleteUserIndexForHalfEdges(m)}cutPolygonPolyline_(t,e,s,n){this.m_topoGraph.removeSpikes_();let i=-1;-1!==t&&(i=this.m_topoGraph.createUserIndexForHalfEdges(),this.setHalfEdgeOrientations_(i,s)),this.processPolygonCuts_(i,t,e,s),-1!==i&&(this.m_topoGraph.deleteUserIndexForHalfEdges(i),i=-1);const r=this.m_topoGraph.getShape();for(let t=r.getFirstGeometry();t!==Ar;t=r.getNextGeometry(t))t!==e&&t!==s&&n.push(t);n.sort((t,e)=>{const s=r.getFirstPath(t),n=r.getRingArea(s),i=r.getFirstPath(e),o=r.getRingArea(i);return n<o?-1:n>o?1:0})}cut(t,e,s,n,i){const r=this.m_topoGraph.getShape().getGeometryType(s),o=this.m_topoGraph.getShape().getGeometryType(n),a=jt(r),h=jt(o);if(2!==a||1!==h){if(1===a&&1===h)return void new sg(this,t,e,s,n,i).Do();P("")}else this.cutPolygonPolyline_(e,s,n,i)}progress_(t=!1){}isGoodParentage(t){return t>=0&&t<this.m_maskLookup.length&&this.m_maskLookup[t]}normalizeInputGeometry(t){const e=t.getGeometryType();if(e===o.enumEnvelope){const e=new Tr({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(e===o.enumPoint){const e=new Fs({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(F(e)){const e=new Wn({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}return e!==o.enumMultiPoint&&e!==o.enumPolyline&&e!==o.enumPolygon&&s("Unexpected geometry type"),t}dissolveNonSimplePolygons(t,e,s,i){n(e>0);const r=new Vr;let o=0,a=-1;for(let s=0,n=e;s<n;s++)2===t[s].getDimension()&&(-1===a&&(a=s),t[s].isEmpty()||(o++,r.addGeometry(t[s])));return 0===o?(n(a>=0),this.normalizeInputGeometry(t[a])):this.planarSimplifyPolygons(r,s,!0,!1,-1,!0)}dissolveMultiPaths_(e,s,i,r,a,m,l){n(e>=1&&e<=2),n(r>0);const u=8&m?1:2,c=ve.constructEmpty();let g=0,d=-1,_=!0;for(let t=0,s=r;t<s;t++)if(i[t].getDimension()===e&&(-1===d&&(d=t),!i[t].isEmpty())){d=t,g++;const s=ve.constructEmpty();if(i[t].queryLooseEnvelope(s),c.mergeEnv3D(s),2===e&&_&&i[t].getGeometryType()===o.enumPolygon)if(16&m){const e=[0],s=i[t].getImpl().getIsSimple(0,e),n=this.m_bOGCOutput?5===s:je(s);_&&=n}else{const e=ms(i[t],0);_&&=e}}if(g<2&&(n(d>=0),0===g||!(16&m)))return this.normalizeInputGeometry(i[d]);if(!_){const t=Oe(s?null:a,c.getEnvelope2D(),!0);return this.dissolveNonSimplePolygons(i,r,t,m)}const p=i.slice(0,r),f=Oe(a,c.getEnvelope2D(),!0),x=10*Je(f);let y=new cs(0,0);if(l&&(y=ls(a,c.getEnvelopeZs(),!0)),1===g&&1===e&&2===u&&!s)return l?(n(0),{}):this.m_bOGCOutput?zc(p[d],f,!1,-1,this.m_progressTracker,u,!1):Oc(p[d],f,!1,!1,-1,this.m_progressTracker,u,!1);const P=new us;P.startConstruction();let C=2===e?3:4,E=0;for(let i=0,a=r;i<a;i++){if(p[i].getDimension()!==e||p[i].isEmpty())continue;let r=p[i].getGeometryType();if(r!==o.enumEnvelope){if(F(r)?(p[i]=this.normalizeInputGeometry(p[i]),r=o.enumPolyline):n(Z(r)),1===e){n(r===o.enumPolyline);let t=-1;if(l)n(0,"3d not implemented yet");else{const e=[0];t=p[i].getImpl().getIsSimple(f.total(),e)}if(this.m_bOGCOutput?5!==t:!je(t))if(s)C=-1;else{l?n(0,"3d not implemented yet"):this.m_bOGCOutput?p[i]=zc(p[i],f,!1,-1,this.m_progressTracker,u,!1):p[i]=Oc(p[i],f,!1,!1,-1,this.m_progressTracker,u,!1);const t=[0];n(je(p[i].getImpl().getIsSimple(f.total(),t)))}}else{n(r===o.enumPolygon);const t=[0],e=p[i].getImpl().getIsSimple(0,t);n(ns(e))}const a=p[i].getImpl();for(let e=0,s=a.getPathCount();e<s;e++){const s=t.constructEmpty();a.queryLoosePathEnvelope(e,s),s.inflateCoords(x,x),P.addEnvelope(E,s),E++}}else{n(r===o.enumEnvelope);const e=t.constructEmpty();p[i].queryLooseEnvelope(e),e.inflateCoords(x,x),P.addEnvelope(E,e),E++,C=-1}}P.endConstruction();const S=E,v=h(S,-2147483647),I=h(S,-1);let b=0;d=-1,E=0;for(let t=0,s=r;t<s;t++){if(p[t].getDimension()!==e)continue;if(-1===d&&(d=t),p[t].isEmpty())continue;d=t,b++;const s=p[t].getGeometryType();if(Z(s))for(let e=0,s=p[t].getPathCount();e<s;e++)I[E]=t,v[E]=-e-1,E++;else n(s===o.enumEnvelope),I[E]=t,v[E]=-1,E++}if(b<2&&2===e)return n(d>=0),this.normalizeInputGeometry(p[d]);let w=S;for(;P.next()&&w>0;){this.progress_();const t=P.getHandleA(),e=P.getHandleB(),s=P.getElement(t),n=P.getElement(e);I[s]!==I[n]&&(v[s]<0&&(w--,v[s]=-(v[s]+1)),v[n]<0&&(w--,v[n]=-(v[n]+1)))}const D=new Vr;let T,N=!1,A=0;for(let t=0,s=r;t<s;t++){if(p[t].getDimension()!==e||p[t].isEmpty())continue;const s=p[t].getGeometryType(),i=A;let r=0,a=0;const h=Z(s)?p[t]:null;for(let e=i,s=v.length;e<s&&I[e]===t;e++)v[e]>=0&&(r++,a+=h?h.getPathSize(v[e]):Qt(p[t])),A++;if(a>.95*Qt(p[t])){D.addGeometry(this.normalizeInputGeometry(p[t]));for(let t=i;t<A;t++)v[t]<0&&(v[t]=-(v[t]+1))}else{if(0===r){N=!0;continue}{N=!0,n(Z(s)),n(null!=h);const e=new Tr({vd:p[t].getDescription()}),r=new Wn({vd:p[t].getDescription()}),a=s===o.enumPolygon?e:r;for(let t=i;t<A;t++)v[t]>=0&&a.addPath(h,v[t],!0);D.addGeometry(a)}}}if(D.getFirstGeometry()!==Ar){const t=2===e,n=s?Oe(null,c.getEnvelope2D(),!0):f;let i=new cs(0,0);if(l&&(i=s?ls(null,c.getEnvelopeZs(),!0):y),2===e&&!(2&m)){D.collapseAllGeometriesToFirst();let t=0,e=null;if(D.hasCurves()&&!D.hasSegmentParentage()){e=new Tc;const s=D.getEnvelope2D(this.m_progressTracker);t=wc(n.total()),Ec(D,bc(n.total(),s),n.total(),0,e,null,this.m_progressTracker)}!function(t,e,s,n){s>0&&pl(t,s,e,!1,n),new Vl(n).executeImpl_(t,e)}(D,D.getFirstGeometry(),n.total(),this.m_progressTracker),null!==e&&e.stitchCurves(D,Ar,t,!0)}if(l)T=this.planarSimplify3DImpl_(D,n,i,u,!0);else if(2===e)T=this.planarSimplifyPolygons(D,n,t,s,-1,!1);else{const t={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};t.ogcRule=this.m_bOGCOutput,t.allCrossRoadsImpassable=!0,t.unsplitBehavior=u,T=this.planarSimplifyPolylines(D,n,s,t,-1)}if(!N){const t=[0];C=T.getImpl().getIsSimple(n.total(),t)}}else n(N),n(d>=0),T=2===e?new Tr({vd:p[d].getDescription()}):new Wn({vd:p[d].getDescription()});if(N){let t=0;for(let e=0,s=v.length;e<s;e++){const s=I[e];if(!(s<0)&&v[e]<0){const n=p[s].getGeometryType(),i=Z(n)?p[s]:null;if(i){const s=-(v[e]+1);t+=i.getPathSize(s)}else t+=4}}T.reserve(T.getPointCount()+t);for(let t=0,e=v.length;t<e;t++){const e=I[t];if(!(e<0)&&v[t]<0){const s=p[e].getGeometryType(),i=Z(s)?p[e]:null;if(i){const e=-(v[t]+1);T.addPath(i,e,!0)}else s===o.enumEnvelope?T.addEnvelope(p[e],!1):(n(F(s)),T.addSegment(p[e],!0))}}}let M=0;if(2===e?-1!==C&&(C=3,M=s?0:f.total()):(n(1===e),s||-1===C||(M=f.total())),l||T.getImpl().setIsSimple(C,M),!s&&N)if(2===e){if(!l)return(new xg).execute(T,a,!1,this.m_progressTracker);n(0,"3d not yet implemented")}else 1===e&&1!==u&&(l?(n(0),T={}):T=function(t,e,s,i){const r=new Jc(i),o=new Vr,a=o.addGeometry(e),h=r.planarSimplifyNoCrackingAndCluster(t,o,a,s);return n(h,"planar_simplify_no_cracking_and_cluster"),o.getGeometry(a)}(this.m_bOGCOutput,T,u,this.m_progressTracker),T.getImpl().setIsSimple(C,M));return T}dissolveTopoGraphCommonEdges_(){const t=this.m_topoGraph.createUserIndexForHalfEdges(),e=[];for(let s=this.m_topoGraph.getFirstCluster();s!==Ar;s=this.m_topoGraph.getNextCluster(s)){const n=this.m_topoGraph.getClusterHalfEdge(s);let i=n;if(n!==Ar)do{if(this.progress_(),1!==this.m_topoGraph.getHalfEdgeUserIndex(i,t)){const s=this.m_topoGraph.getHalfEdgeTwin(i);this.m_topoGraph.setHalfEdgeUserIndex(s,t,1),this.m_topoGraph.setHalfEdgeUserIndex(i,t,1);const n=this.m_topoGraph.getHalfEdgeFaceParentage(i);if(this.isGoodParentage(n)){const t=this.m_topoGraph.getHalfEdgeFaceParentage(s);this.isGoodParentage(t)&&e.push(i)}}i=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(i))}while(i!==n)}this.m_topoGraph.deleteUserIndexForHalfEdges(t),this.m_topoGraph.deleteEdgesBreakFaces_(e)}chooseVertexByOrder(t,e,s,i){let r=W(),o=Ar;for(let n=this.m_topoGraph.getClusterVertexIterator(t);n!==Ar;n=this.m_topoGraph.incrementVertexIterator(n)){const t=this.m_topoGraph.getVertexFromVertexIterator(n),i=e.getUserIndex(t,s);i>=0&&i<r&&(r=i,o=t)}n(o!==Ar);let a=e.getUserIndex(o,i);return a>0&&(e.setUserIndex(o,i,--a),0===a&&e.setUserIndex(o,s,-1)),o}chooseVertexFromCluster_(t,e){return this.m_topoGraph.getVertexDominantFromCluster(t,e)}chooseVertexFromVertexCluster_(t,e){return this.m_topoGraph.getVertexDominant(t,e)}collectPolygonPathsPreservingFrom_(t,e,s,n,i){const r=this.m_topoGraph.getShape();if(r.getGeometryType(t)!==o.enumPolygon)return;const a=r.hasSegmentParentage(),h=new fm;for(let o=r.getFirstPath(t);o!==Ar;o=r.getNextPath(o)){const t=r.getFirstVertex(o);this.m_topoGraph.getClusterFromVertex(t);const m=this.m_topoGraph.getHalfEdgeFromVertex(t);if(m===Ar)continue;const l=this.m_topoGraph.getHalfEdgeUserIndex(m,s);if(1===l||2===l)continue;const u=this.m_topoGraph.getHalfEdgeFaceParentage(m);if(!this.isGoodParentage(u)){this.m_topoGraph.setHalfEdgeUserIndex(m,s,2);continue}this.m_topoGraph.setHalfEdgeUserIndex(m,s,1);const c=r.insertPath(e,Ar);r.setClosedPath(c,!0);let g=m,d=t,_=this.m_topoGraph.getClusterFromVertex(d),p=1;do{this.progress_();const t=this.chooseVertexFromVertexCluster_(d,i),e=r.addVertex(c,t);if(this.m_topoGraph.isHalfEdgeCurve(g)&&(this.m_topoGraph.querySegmentXY(g,h),r.setSegmentToIndex(r.getVertexIndex(e),h.get().clone())),a){const t=this.m_topoGraph.getSegmentParentage(g);r.setSegmentParentageAndBreak(e,t,this.m_topoGraph.isBreakNode(_))}let o,m;-1!==n&&this.m_topoGraph.setClusterUserIndex(_,n,1),this.m_topoGraph.setHalfEdgeUserIndex(g,s,1),g=this.m_topoGraph.getHalfEdgeNext(g);do{o=1===p?r.getNextVertex(d):r.getPrevVertex(d),m=o!==Ar?this.m_topoGraph.getClusterFromVertex(o):Ar}while(m===_);const l=this.m_topoGraph.getHalfEdgeOrigin(g);if(l!==m){do{o=1===p?r.getPrevVertex(d):r.getNextVertex(d),m=o!==Ar?this.m_topoGraph.getClusterFromVertex(o):Ar}while(m===_);if(l!==m){m=l;const t=this.m_topoGraph.getClusterVertexIterator(m);o=this.m_topoGraph.getVertexFromVertexIterator(t)}else p=-p}_=m,d=o}while(g!==m)}}topoOperationPolygonPolygonHelper_(t,e,s,n,i,r){this.progress_(!0),t!==Ar&&this.collectPolygonPathsPreservingFrom_(t,s,i,r,n),e!==Ar&&this.collectPolygonPathsPreservingFrom_(e,s,i,r,n);const o=new fm,a=this.m_topoGraph.getShape();a.dbgVerifyCurves();const h=a.hasSegmentParentage();for(let t=this.m_topoGraph.getFirstCluster();t!==Ar;t=this.m_topoGraph.getNextCluster(t)){const e=this.m_topoGraph.getClusterHalfEdge(t);if(e===Ar)continue;let m=e;do{this.progress_();const t=this.m_topoGraph.getHalfEdgeUserIndex(m,i);if(1!==t&&2!==t){const t=this.m_topoGraph.getHalfEdgeFaceParentage(m);if(this.isGoodParentage(t)){const t=a.insertPath(s,Ar);a.setClosedPath(t,!0);let e=m;do{const s=this.m_topoGraph.getHalfEdgeVertexIterator(e);let m=Ar;if(s!==Ar)m=this.m_topoGraph.getVertexFromVertexIterator(s);else{const t=this.m_topoGraph.getHalfEdgeVertexIterator(this.m_topoGraph.getHalfEdgeTwin(e));m=this.m_topoGraph.getVertexFromVertexIterator(t),m=a.getNextVertex(m)}const l=this.chooseVertexFromVertexCluster_(m,n),u=a.addVertex(t,l);if(h){const t=this.m_topoGraph.getSegmentParentage(e),s=this.m_topoGraph.getHalfEdgeOrigin(e);a.setSegmentParentageAndBreak(u,t,this.m_topoGraph.isBreakNode(s))}if(this.m_topoGraph.isHalfEdgeCurve(e)&&(this.m_topoGraph.querySegmentXY(e,o),a.setSegmentToIndex(a.getVertexIndex(u),o.get().clone())),this.m_topoGraph.setHalfEdgeUserIndex(e,i,1),-1!==r){const t=this.m_topoGraph.getClusterFromVertex(l);this.m_topoGraph.setClusterUserIndex(t,r,1)}e=this.m_topoGraph.getHalfEdgeNext(e)}while(e!==m)}else this.m_topoGraph.setHalfEdgeUserIndex(m,i,2)}m=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(m))}while(m!==e)}}topoOperationPolygonPolygon_(t,e,s,n=!1){this.dissolveTopoGraphCommonEdges_();const i=this.m_topoGraph.getShape(),r=i.createGeometry(o.enumPolygon),a=this.m_topoGraph.createUserIndexForHalfEdges();return this.topoOperationPolygonPolygonHelper_(t,e,r,s,a,-1),this.m_topoGraph.deleteUserIndexForHalfEdges(a),n||Zl(i,r,3,this.m_bOGCOutput,Ar,this.m_progressTracker),r}topoOperationPolyline_(t,e){const s={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(Ar,t,!1,s).first}topoOperationMultiPoint_(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(o.enumMultiPoint),s=t.insertPath(e,Ar);for(let e=this.m_topoGraph.getFirstCluster();e!==Ar;e=this.m_topoGraph.getNextCluster(e)){const n=this.m_topoGraph.getClusterParentage(e);if(this.isGoodParentage(n)){let n=Ar;for(let s=this.m_topoGraph.getClusterVertexIterator(e);s!==Ar;s=this.m_topoGraph.incrementVertexIterator(s)){const e=this.m_topoGraph.getVertexFromVertexIterator(s);n===Ar&&(n=e);const i=t.getGeometryFromPath(t.getPathFromVertex(e)),r=this.m_topoGraph.getGeometryID(i);if(this.isGoodParentage(r)){n=e;break}}t.addVertex(s,n)}}return e}intersection(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),r=jt(s),o=jt(i),a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);n(a>=0),n(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a|h]=!0;let m=Ar;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(m=t),2===r&&2===o?this.topoOperationPolygonPolygon_(t,e,m):1===r&&o>0||1===o&&r>0?this.topoOperationPolyline_(m,this.m_bOGCOutput):0===r||0===o?this.topoOperationMultiPoint_():void P("")}topoOperationPolygonPolygonEx(t,e,s){const n=this.m_topoGraph.getShape(),i=n.createGeometry(o.enumPolygon),r=n.createGeometry(o.enumPolyline),a=n.createGeometry(o.enumMultiPoint);this.dissolveTopoGraphCommonEdges_();let h=Ar;const m=this.m_topoGraph.createUserIndexForHalfEdges(),l=this.m_topoGraph.createUserIndexForClusters();n.dbgVerifyCurves(),this.topoOperationPolygonPolygonHelper_(t,e,i,s,m,l),n.dbgVerifyCurves();const u=n.hasSegmentParentage(),c=new fm;for(let t=this.m_topoGraph.getFirstCluster();t!==Ar;t=this.m_topoGraph.getNextCluster(t)){const e=this.m_topoGraph.getClusterHalfEdge(t);if(e===Ar)continue;let i=e;do{let e=this.m_topoGraph.getHalfEdgeUserIndex(i,m),o=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(i),m),a=e|o;if(2===a){let h=this.m_topoGraph.getHalfEdgeParentage(i);if(this.isGoodParentage(h)){const g=n.insertPath(r,Ar);let d=i;const _=this.chooseVertexFromCluster_(t,s);let p=n.addVertex(g,_);if(u){const t=this.m_topoGraph.getSegmentParentage(i),e=this.m_topoGraph.getHalfEdgeOrigin(i);n.setSegmentParentageAndBreak(p,t,this.m_topoGraph.isBreakNode(e))}this.m_topoGraph.isHalfEdgeCurve(i)&&(this.m_topoGraph.querySegmentXY(i,c),n.setSegmentToIndex(n.getVertexIndex(p),c.get().clone())),this.m_topoGraph.setClusterUserIndex(t,l,1);do{this.progress_();const t=this.m_topoGraph.getHalfEdgeTo(d),r=this.chooseVertexFromCluster_(t,s);if(p=n.addVertex(g,r),u){const t=this.m_topoGraph.getSegmentParentage(i),e=this.m_topoGraph.getHalfEdgeOrigin(i);n.setSegmentParentageAndBreak(p,t,this.m_topoGraph.isBreakNode(e))}if(this.m_topoGraph.setHalfEdgeUserIndex(d,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(d),m,1),this.m_topoGraph.setClusterUserIndex(t,l,1),d=this.m_topoGraph.getHalfEdgeNext(d),e=this.m_topoGraph.getHalfEdgeUserIndex(d,m),o=this.m_topoGraph.getHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(d),m),a=e|o,2!==a)break;if(h=this.m_topoGraph.getHalfEdgeParentage(d),!this.isGoodParentage(h)){this.m_topoGraph.setHalfEdgeUserIndex(d,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(d),m,1);break}this.m_topoGraph.isHalfEdgeCurve(i)&&d!==i&&(this.m_topoGraph.querySegmentXY(i,c),n.setSegmentToIndex(n.getVertexIndex(p),c.get().clone()))}while(d!==i)}else this.m_topoGraph.setHalfEdgeUserIndex(i,m,1),this.m_topoGraph.setHalfEdgeUserIndex(this.m_topoGraph.getHalfEdgeTwin(i),m,1)}i=this.m_topoGraph.getHalfEdgeNext(this.m_topoGraph.getHalfEdgeTwin(i))}while(i!==e)}for(let t=this.m_topoGraph.getFirstCluster();t!==Ar;t=this.m_topoGraph.getNextCluster(t)){if(this.progress_(),1===this.m_topoGraph.getClusterUserIndex(t,l))continue;const e=this.m_topoGraph.getClusterParentage(t);if(this.isGoodParentage(e)){h===Ar&&(h=n.insertPath(a,Ar));const e=this.m_topoGraph.getClusterVertexIterator(t);let i=Ar;if(e!==Ar){i=this.m_topoGraph.getVertexFromVertexIterator(e);const t=this.chooseVertexFromVertexCluster_(i,s);n.addVertex(h,t)}}}this.m_topoGraph.deleteUserIndexForClusters(l),this.m_topoGraph.deleteUserIndexForHalfEdges(m),n.dbgVerifyCurves(),Zl(n,i,3,this.m_bOGCOutput,Ar,this.m_progressTracker);const g=[Ar,Ar,Ar];return g[0]=a,g[1]=r,g[2]=i,g}topoOperationPolylinePolylineOrPolygonEx(t,e){const s={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return s.ogcRule=e,s.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(Ar,t,!0,s)}topoOperationMultiPoint(){const t=this.m_topoGraph.getShape(),e=t.createGeometry(o.enumMultiPoint),s=t.insertPath(e,Ar);for(let e=this.m_topoGraph.getFirstCluster();e!==Ar;e=this.m_topoGraph.getNextCluster(e)){const n=this.m_topoGraph.getClusterParentage(e);if(this.isGoodParentage(n)){let n=Ar;for(let s=this.m_topoGraph.getClusterVertexIterator(e);s!==Ar;s=this.m_topoGraph.incrementVertexIterator(s)){const e=this.m_topoGraph.getVertexFromVertexIterator(s);n===Ar&&(n=e);const i=t.getGeometryFromPath(t.getPathFromVertex(e)),r=this.m_topoGraph.getGeometryID(i);if(this.isGoodParentage(r)){n=e;break}}t.addVertex(s,n)}}return e}intersectionEx(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),r=Hc(s),o=Hc(i),a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);n(a>=0),n(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a|h]=!0;let m=Ar;if(this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(m=t),2===r&&2===o)return this.topoOperationPolygonPolygonEx(t,e,m);if(1===r&&o>0||1===o&&r>0){const{first:t,second:e}=this.topoOperationPolylinePolylineOrPolygonEx(m,this.m_bOGCOutput);return[e,t]}if(0===r||0===o){const t=[];return t.push(this.topoOperationMultiPoint()),t}P("")}getCombinedHalfEdgeParentage(t){return this.m_topoGraph.getHalfEdgeParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(t)|this.m_topoGraph.getHalfEdgeFaceParentage(this.m_topoGraph.getHalfEdgeTwin(t))}prevailingDirection(t,e){const s=this.getCombinedHalfEdgeParentage(e),n=this.m_topoGraph.getHalfEdgeOrigin(e),i=this.m_topoGraph.getHalfEdgeTo(e);let r=0,o=0;for(let a=this.m_topoGraph.getClusterVertexIterator(n);a!==Ar;a=this.m_topoGraph.incrementVertexIterator(a)){const n=this.m_topoGraph.getVertexFromVertexIterator(a),h=t.getPathFromVertex(n),m=t.getGeometryFromPath(h),l=this.m_topoGraph.getGeometryID(m),u=t.getFirstVertex(h),c=0!==(l&s);c&&u===n&&(this.m_fromEdgeForPolylines=e);const g=t.getNextVertex(n);if(g!==Ar&&this.m_topoGraph.getClusterFromVertex(g)===i){if(r++,c){if(this.m_fromEdgeForPolylines===Ar&&u===g){const t=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(t))&&(this.m_fromEdgeForPolylines=t)}o++}}else{const s=t.getPrevVertex(n);if(s!==Ar&&this.m_topoGraph.getClusterFromVertex(s)===i&&(r--,c)){if(this.m_fromEdgeForPolylines===Ar&&u===s){const t=this.m_topoGraph.getHalfEdgeNext(e);this.isGoodParentage(this.getCombinedHalfEdgeParentage(t))&&(this.m_fromEdgeForPolylines=t)}o--}}}return this.m_topoGraph.queryXY(n,this.m_dummyPt1),this.m_topoGraph.queryXY(i,this.m_dummyPt2),(0!==o?o:r)*l.distance(this.m_dummyPt1,this.m_dummyPt2)}tryMoveThroughCrossroadBackwards(t,e){const s=this.m_topoGraph.getHalfEdgePrev(t),n=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t)))return Ar;const e=this.m_topoGraph.getHalfEdgeTwin(t);if(n===this.m_topoGraph.getHalfEdgeNext(e))return s}let i=n,r=Ar;for(;i!==t;){const t=this.getCombinedHalfEdgeParentage(i);if(this.isGoodParentage(t)){if(r!==Ar)return Ar;r=this.m_topoGraph.getHalfEdgeTwin(i)}i=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgePrev(i))}return r}tryMoveThroughCrossroadForward(t,e){const s=this.m_topoGraph.getHalfEdgeNext(t),n=this.m_topoGraph.getHalfEdgeTwin(s);if(!e){const e=this.m_topoGraph.getHalfEdgeTwin(t);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(e)))return Ar;if(n===this.m_topoGraph.getHalfEdgePrev(e))return s}let i=n,r=Ar;for(;i!==t;){const t=this.getCombinedHalfEdgeParentage(i);if(this.isGoodParentage(t)){if(r!==Ar)return Ar;r=this.m_topoGraph.getHalfEdgeTwin(i)}i=this.m_topoGraph.getHalfEdgeTwin(this.m_topoGraph.getHalfEdgeNext(i))}return r}isOnALoop(t,e){let s=t;const n=2*this.m_topoGraph.getShape().getTotalPointCount()+10;for(let i=0;i<n;i++){if(1===this.m_topoGraph.getHalfEdgeUserIndex(s,e))return!1;const n=this.m_topoGraph.getHalfEdgeNext(s);if(n===this.m_topoGraph.getHalfEdgeTwin(s))return!1;if(s=n,s===t)return!0}P("is_on_a_loop_")}restorePolylineParts(t,e,s,i,r,o,a,h,m,l){n(r===Ar&&o>=0&&a>=0||-1===o&&-1===a),n(-1===h&&1!==l.unsplitBehavior||-1!==h&&1===l.unsplitBehavior);const u=l.ogcRule,c=l.allCrossRoadsImpassable,g=1===l.unsplitBehavior,d=0===l.unsplitBehavior,_=this.m_topoGraph.getShape(),f=_.hasSegmentParentage();let x=t,y=this.m_topoGraph.getHalfEdgeTwin(x);const P=new fm;this.m_fromEdgeForPolylines=Ar;let C=this.prevailingDirection(_,x),E=x,S=Ar,v=!1,I=!1,b=!1;if(!g)for(;;){const e=this.m_topoGraph.getHalfEdgePrev(x);if(e===y){b=!0;break}const n=this.m_topoGraph.getHalfEdgeNext(y);if(this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(n))){v=!0;break}if(this.m_topoGraph.getHalfEdgeTwin(e)!==n){if(c){v=!0;break}if(x=this.tryMoveThroughCrossroadBackwards(x,!0),x===Ar){v=!0;break}y=this.m_topoGraph.getHalfEdgeTwin(x)}else x=e,y=n;if(1===this.m_topoGraph.getHalfEdgeUserIndex(x,s)){b=!0;break}if(x===t){S=t,I=!0;break}const i=this.getCombinedHalfEdgeParentage(x);if(!this.isGoodParentage(i))break;E=x,C+=this.prevailingDirection(_,x)}if(S===Ar){for(x=t,y=this.m_topoGraph.getHalfEdgeTwin(x),S=x;;){const t=this.m_topoGraph.getHalfEdgeNext(x),e=this.m_topoGraph.isStrongPathNode(this.m_topoGraph.getHalfEdgeOrigin(t));if(e){v=!0;break}if(t===y){b=!0;break}if(-1!==h){const t=this.m_topoGraph.getHalfEdgeOrigin(y);if(1===this.m_topoGraph.getClusterUserIndex(t,h)){v=!0;break}}const n=this.m_topoGraph.getHalfEdgePrev(y);if(this.m_topoGraph.getHalfEdgeTwin(t)!==n){if(e||c){v=!0;break}if(x=this.tryMoveThroughCrossroadForward(x,!0),x===Ar){v=!0;break}y=this.m_topoGraph.getHalfEdgeTwin(x)}else x=t,y=n;if(1===this.m_topoGraph.getHalfEdgeUserIndex(x,s)){b=!0;break}const i=this.getCombinedHalfEdgeParentage(x);if(!this.isGoodParentage(i))break;S=x,C+=this.prevailingDirection(_,x)}const e=this.m_topoGraph.getHalfEdgeOrigin(E);I=this.m_topoGraph.getHalfEdgeTo(S)===e}else if(this.m_fromEdgeForPolylines!==Ar){E=t,S=this.tryMoveThroughCrossroadBackwards(E,!1),n(S!==Ar);const e=this.m_topoGraph.getHalfEdgeTwin(E);this.m_topoGraph.getHalfEdgeNext(e)}let w=I;I||b||m&&(w=this.isOnALoop(t,s),w||(w=this.isOnALoop(y,s)));const D=C>=0;let T=!1;w&&v&&(I?(T=u,D&&(T||g||d)&&E!==t&&(n(!g),E=t,T=!1)):(g||D&&d)&&(E=t));let N=0;for(x=E;y=this.m_topoGraph.getHalfEdgeTwin(x),this.m_topoGraph.setHalfEdgeUserIndex(x,s,1),this.m_topoGraph.setHalfEdgeUserIndex(y,s,1),N++,x!==S;)x=c?this.m_topoGraph.getHalfEdgeNext(x):this.tryMoveThroughCrossroadForward(x,!1);D||(S=p(E,E=S),S=this.m_topoGraph.getHalfEdgeTwin(S),E=this.m_topoGraph.getHalfEdgeTwin(E));let A=_.insertPath(e,Ar);x=E;const M=this.m_topoGraph.getHalfEdgeOrigin(E);let G;G=-1!==o?this.chooseVertexByOrder(M,_,o,a):this.chooseVertexFromCluster_(M,r),this.m_topoGraph.isStrongPathNode(M)&&_.setStrongPathStart(A,!0);let q=_.addVertex(A,G),F=q;-1!==i&&this.m_topoGraph.setClusterUserIndex(M,i,1);let V=0;const Y=T?Math.trunc((N+1)/2):-1;let X=Ar,k=!0,R=Ar;for(;;){if(f){const t=this.m_topoGraph.getSegmentParentage(x),e=this.m_topoGraph.getHalfEdgeOrigin(x);_.setSegmentParentageAndBreak(F,t,k||this.m_topoGraph.isBreakNode(e))}k=!1,this.m_topoGraph.isHalfEdgeCurve(x)&&(this.m_topoGraph.querySegmentXY(x,P),_.setSegmentToIndex(_.getVertexIndex(F),P.get().clone())),X!==Ar&&-1!==a&&_.addToUserIndex(X,a,-1);const t=c?this.m_topoGraph.getHalfEdgeNext(x):this.tryMoveThroughCrossroadForward(x,!1),s=this.m_topoGraph.getHalfEdgeTo(x);let n;if(n=-1!==o?this.chooseVertexByOrder(s,_,o,a):this.chooseVertexFromCluster_(s,r),q=_.addVertex(A,n),R=s,-1!==i&&this.m_topoGraph.setClusterUserIndex(s,i,1),f&&this.m_topoGraph.isBreakNode(s)&&_.setSegmentParentageBreakVertex(q,!0),X=n,V++,T&&V===Y&&(A=_.insertPath(e,Ar),q=_.addVertex(A,n),k=!0,-1!==a&&_.addToUserIndex(n,a,-1),X=Ar),x===S)break;x=t,F=q}R!==Ar&&this.m_topoGraph.isStrongPathNode(R)&&_.setStrongPathEnd(A,!0)}topoOperationPolylineSimplify_(t,e){return this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,Ar,!1,e).first}topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,e,s,i){n(e===Ar||t===Ar);const r=this.m_topoGraph.getShape(),a=e=>t===Ar?e===Ar?r.getFirstGeometry():r.getNextGeometry(e):e===Ar?t:Ar,h=r.createGeometry(o.enumPolyline);let m=-1;s&&(m=this.m_topoGraph.createUserIndexForClusters());const l=this.m_topoGraph.createUserIndexForHalfEdges(),u=e===Ar?r.createUserIndex():-1,c=e===Ar?r.createUserIndex():-1;let g=-1;if(1===i.unsplitBehavior){g=this.m_topoGraph.createUserIndexForClusters();for(let t=a(Ar);t!==Ar;t=a(t))for(let e=r.getFirstPath(t);e!==Ar;e=r.getNextPath(e)){{const t=r.getFirstVertex(e),s=this.m_topoGraph.getClusterFromVertex(t);this.m_topoGraph.setClusterUserIndex(s,g,1)}if(!r.isClosedPath(e)){const t=r.getLastVertex(e),s=this.m_topoGraph.getClusterFromVertex(t);this.m_topoGraph.setClusterUserIndex(s,g,1)}}}if(e===Ar){let t=0;for(let e=a(Ar);e!==Ar;e=a(e))for(let s=r.getFirstPath(e);s!==Ar;s=r.getNextPath(s))if(r.isClosedPath(s)){let e=r.getFirstVertex(s);for(let n=0,i=r.getPathSize(s);n<i;n++,e=r.getNextVertex(e))r.setUserIndex(e,u,t++),r.setUserIndex(e,c,2)}else{const e=r.getFirstVertex(s);r.setUserIndex(e,u,t++),r.setUserIndex(e,c,1);let n=r.getNextVertex(e);for(let e=1,i=r.getPathSize(s)-1;e<i;++e)r.setUserIndex(n,u,t++),r.setUserIndex(n,c,2),n=r.getNextVertex(n);r.setUserIndex(n,u,t++),r.setUserIndex(n,c,1)}}for(let t=a(Ar);t!==Ar;t=a(t))for(let s=r.getFirstPath(t);s!==Ar;s=r.getNextPath(s)){let t=r.getFirstVertex(s);for(let n=0,o=r.getPathSize(s);n<o;n++,t=r.getNextVertex(t)){const s=this.m_topoGraph.getHalfEdgeFromVertex(t);if(s===Ar)continue;if(1===this.m_topoGraph.getHalfEdgeUserIndex(s,l))continue;const r=this.getCombinedHalfEdgeParentage(s);if(this.isGoodParentage(r)){const t=0===n;this.restorePolylineParts(s,h,l,m,e,u,c,g,t,i)}}}let d=Ar;if(s){d=r.createGeometry(o.enumMultiPoint);let t=Ar;for(let s=this.m_topoGraph.getFirstCluster();s!==Ar;s=this.m_topoGraph.getNextCluster(s))if(this.progress_(),1!==this.m_topoGraph.getClusterUserIndex(s,m)){const n=this.m_topoGraph.getClusterParentage(s);if(this.isGoodParentage(n)){t===Ar&&(t=r.insertPath(d,Ar));const n=this.m_topoGraph.getClusterVertexIterator(s);if(n!==Ar){let i;this.m_topoGraph.getVertexFromVertexIterator(n),i=-1!==u?this.chooseVertexByOrder(s,r,u,c):this.chooseVertexFromCluster_(s,e),r.addVertex(t,i)}}}}return-1!==c&&r.removeUserIndex(c),-1!==u&&r.removeUserIndex(u),-1!==m&&r.removeUserIndex(m),this.m_topoGraph.deleteUserIndexForHalfEdges(l),ft(h,d)}difference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),n=this.m_topoGraph.getShape().getGeometryType(e),i=jt(s),r=jt(n);if(i>r)return t;const o=this.m_topoGraph.getGeometryID(t),a=this.m_topoGraph.getGeometryID(e);if(this.m_maskLookup.length=0,this.m_maskLookup.length=1+(o|a),this.m_maskLookup[o]=!0,2===i&&2===r){let s=Ar;return this.m_topoGraph.getShape().getVertexDescription().getAttributeCount()>1&&(s=t),this.topoOperationPolygonPolygon_(t,e,s)}if(1===i&&2===r){const e={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};return e.ogcRule=this.m_bOGCOutput,e.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,Ar,!1,e).first}if(1===i&&1===r){const e={unsplitBehavior:0,allCrossRoadsImpassable:!0,ogcRule:!1};return e.ogcRule=this.m_bOGCOutput,e.unsplitBehavior=0,this.topoOperationPolylineSimplifyOrPolylineTopoHelper_(t,Ar,!1,e).first}if(0===i)return this.topoOperationMultiPoint_();P("")}symmetricDifference(t,e){const s=this.m_topoGraph.getShape().getGeometryType(t),i=this.m_topoGraph.getShape().getGeometryType(e),r=Hc(s),o=Hc(i),a=this.m_topoGraph.getGeometryID(t),h=this.m_topoGraph.getGeometryID(e);return n(a>=0),n(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=1+(a|h),this.m_maskLookup[a]=!0,this.m_maskLookup[a]=!0,this.m_maskLookup[h]=!0,2===r&&2===o?this.topoOperationPolygonPolygon_(t,e,Ar):1===r&&1===o?this.topoOperationPolyline_(Ar,this.m_bOGCOutput):0===r&&0===o?this.topoOperationMultiPoint():void P("")}planarSimplifyNoCrackingAndCluster(t,e,s,i){this.m_bOGCOutput=t,this.m_topoGraph=new ll;const r=e.getFillRule(s),a=e.getGeometryType(s);if(1!==r||a===o.enumMultiPoint?this.m_topoGraph.setAndSimplifyEditShapeAlternate(e,s,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeWinding(e,s,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return!1;this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const h=this.m_topoGraph.getGeometryID(s);if(n(h>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=h+1,this.m_maskLookup[h]=!0,e.getGeometryType(s)===o.enumPolygon||1===r&&e.getGeometryType(s)!==o.enumMultiPoint){e.setFillRule(s,0);const n=this.topoOperationPolygonPolygon_(s,Ar,Ar);if(e.swapGeometry(n,s),e.removeGeometry(n),1===r&&this.m_bOGCOutput)return this.planarSimplifyNoCrackingAndCluster(t,e,s,i)}else if(e.getGeometryType(s)===o.enumPolyline){const t={unsplitBehavior:0,allCrossRoadsImpassable:!1,ogcRule:!1};t.ogcRule=this.m_bOGCOutput,t.allCrossRoadsImpassable=!0,t.unsplitBehavior=i;const n=this.topoOperationPolylineSimplify_(e.getFirstGeometry(),t);e.swapGeometry(n,s),e.removeGeometry(n)}else if(e.getGeometryType(s)===o.enumMultiPoint){const t=this.topoOperationMultiPoint_();e.swapGeometry(t,s),e.removeGeometry(t)}else P("");return!0}unsplitPolylineExact(t){return n(0),new Wn}planarSimplifyPolylines(t,e,s,i,r){for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e)){const s=t.getGeometryType(e);n(s===o.enumPolyline)}let a=0,h=0,m=null;if(t.hasCurves()&&!t.hasSegmentParentage()){m=new Tc;const s=t.getEnvelope2D(this.m_progressTracker);h=wc(e.total());const n=bc(e.total(),s);a=Dc(n,h),Ec(t,n,e.total(),0,m,null,this.m_progressTracker)}{const s=Fc(e.add(a));t.filterClosePoints(s,!1,!1,!1,Ar)}if(this.m_topoGraph=new ll,4!==r&&5!==r)if(null===m&&s){const n=new ql(this.m_progressTracker,!1);n.sweepVertical(t,e.total()),n.hadComplications()?(Ac(t,e,this.m_progressTracker,!0,!1),s=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(e.total())}else Ac(t,e.add(a),this.m_progressTracker,!0,!1),s=!1;else s=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const l=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,l,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return n(s&&null===m),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolylines(t,e,!1,i,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const u=this.m_topoGraph.getGeometryID(l);n(u>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=u+1,this.m_maskLookup[u]=!0;const c=this.topoOperationPolylineSimplify_(t.getFirstGeometry(),i);null!==m&&m.stitchCurves(t,c,h,!0);const g=t.getGeometry(c);return s||g.getImpl().setIsSimple(4,e.total()),g}planarSimplifyMultiPoints(t,e,s,i){for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e)){const s=t.getGeometryType(e);n(s===o.enumMultiPoint)}this.m_topoGraph=new ll,4!==i&&5!==i?(Ac(t,e,this.m_progressTracker,!0,!1),s=!1):s=!1,t.removeSelection(),t.collapseAllGeometriesToFirst();const r=t.getFirstGeometry();if(this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,r,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return n(s),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyMultiPoints(t,e,!1,-1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const a=this.m_topoGraph.getGeometryID(r);n(a>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=a+1,this.m_maskLookup[a]=!0;const h=this.topoOperationMultiPoint(),m=t.getGeometry(h);return s||m.getImpl().setIsSimple(4,e.total()),m}planarSimplifyPolygons(t,e,s,i,r,a){for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e)){const i=t.getGeometryType(e);n(i===o.enumPolygon||i===o.enumPolyline&&s)}let h=0,m=0,l=null;if(t.hasCurves()&&!t.hasSegmentParentage()){l=new Tc;const s=t.getEnvelope2D(this.m_progressTracker);m=wc(e.total());const n=bc(e.total(),s);h=Dc(n,m),Ec(t,n,e.total(),0,l,null,this.m_progressTracker)}if(a){Ac(t,e.add(h),this.m_progressTracker,!0,!1);for(let e=t.getFirstGeometry();e!==Ar;e=t.getNextGeometry(e))t.getGeometryType(e)===o.enumPolygon&&Zl(t,e,-1,!1,Ar,this.m_progressTracker)}if(this.m_topoGraph=new ll,a||4===r||5===r)i=!1;else if(null===l&&i){const s=new ql(this.m_progressTracker,!1);s.sweepVertical(t,e.total()),s.hadComplications()?(Ac(t,e,this.m_progressTracker,!0,!1),i=!1):this.m_topoGraph.setCheckDirtyPlanesweepTolerance(e.total())}else Ac(t,e.add(h),this.m_progressTracker,!0,!1),i=!1;t.removeSelection(),t.collapseAllGeometriesToFirst();const u=t.getFirstGeometry();if(s?this.m_topoGraph.setAndSimplifyEditShapeWinding(t,u,this.m_progressTracker):this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,u,this.m_progressTracker),this.m_topoGraph.dirtyCheckFailed())return n(i&&null===l),this.m_topoGraph.removeShape(),this.m_topoGraph=null,this.planarSimplifyPolygons(t,e,s,!1,-1,!1);this.m_topoGraph.setCheckDirtyPlanesweepTolerance(Number.NaN);const c=this.m_topoGraph.getGeometryID(u);n(c>=0),this.m_maskLookup.length=0,this.m_maskLookup.length=c+1,this.m_maskLookup[c]=!0,t.setFillRule(u,0);const g=this.m_bOGCOutput&&s,d=g;let _=this.topoOperationPolygonPolygon_(u,Ar,Ar,d);g&&(this.m_topoGraph.removeShape(),this.m_topoGraph=null,t.removeGeometry(u),this.m_topoGraph=new ll,this.m_topoGraph.setAndSimplifyEditShapeAlternate(t,_,this.m_progressTracker),_=this.topoOperationPolygonPolygon_(_,Ar,Ar,!1)),null!==l&&l.stitchCurves(t,_,m,!0);const p=t.getGeometry(_);return p.setFillRule(0),i?p.getImpl().setIsSimple(3,0):(p.getImpl().setIsSimple(4,e.total()),p.getImpl().updateOGCFlagsProtected()),p}planarSimplify3DImpl_(t,e,s,i,r){return n(0),{}}planarSimplifyImpl_(t,e,s,n,i,r,a,h){if(t.isEmpty())return t.clone();const m=t.getGeometryType(),l=new Vr,u=l.addGeometry(t);if(ns(i)&&m===o.enumPolygon&&(s=!1,l.setFillRule(u,0)),h&&(t.hasAttribute(1)&&l.replaceNaNs(1,0),l.removeNaNVertices()),m===o.enumPolygon||m===o.enumPolyline&&s)return this.planarSimplifyPolygons(l,e,s,n,i,!1);if(m===Wn.type){const t={unsplitBehavior:0,allCrossRoadsImpassable:!0,ogcRule:!1};return t.ogcRule=this.m_bOGCOutput,t.unsplitBehavior=a,this.planarSimplifyPolylines(l,e,n,t,i)}if(m===o.enumMultiPoint)return this.planarSimplifyMultiPoints(l,e,n,i);P("what else?")}}function $c(t,e,s,n){const i=t.getGeometryType();if(i===o.enumEnvelope){const e=new Tr({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(i===o.enumPoint&&("|"===n||"^"===n)){const e=new Fs({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(i===o.enumLine){const e=new Wn({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}if(i===o.enumMultiPoint&&"-"===n&&e.getGeometryType()===o.enumPoint){const e=new qe({vd:t.getDescription()});return t.isEmpty()||t.getPointByVal(0,e),e}if(i===o.enumMultiPoint&&"&"===n&&e.getGeometryType()===o.enumPoint){const e=new qe({vd:t.getDescription()});return t.isEmpty()||t.getPointByVal(0,e),e}return t}function tg(t){const e=t.getGeometryType();if(e===o.enumEnvelope){const e=new Tr({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(e===o.enumPoint){const e=new Fs({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}if(Lc(e)){const e=new Wn({vd:t.getDescription()});return t.isEmpty()||e.addSegment(t,!0),e}return e!==o.enumMultiPoint&&e!==o.enumPolyline&&e!==o.enumPolygon&&s("Unexpected geometry type"),t}function eg(t,e,s,i){const r=s===Ar?t.getClusterHalfEdge(e):s;let o=r;n(t.getHalfEdgeOrigin(r)===e);do{i(o),o=t.getHalfEdgeNext(t.getHalfEdgeTwin(o))}while(o!==r)}class sg{constructor(t,e,s,n,i,r){this.m_rParent=t,this.m_rTopoGraph=t.m_topoGraph,this.m_rShape=this.m_rTopoGraph.getShape(),this.m_IDCuttee=this.m_rTopoGraph.getGeometryID(n),this.m_IDCutter=this.m_rTopoGraph.getGeometryID(i),this.m_IDBoth=this.m_IDCuttee|this.m_IDCutter,this.m_bConsiderTouch=e,this.m_sideIndex=s,this.m_cuttee=n,this.m_cutter=i,this.m_rCutHandles=r,this.m_cutteeBreadcrumbsIndex=this.m_rShape.createUserIndexUninitialized(),this.m_clusterParentageIndex=this.m_rShape.createUserIndexUninitialized();for(let t=this.m_rShape.getFirstPath(this.m_cuttee);t!==Ar;t=this.m_rShape.getNextPath(t)){let e=0;const s=this.m_rShape.getPathSize(t);for(let n=this.m_rShape.getFirstVertex(t);e<s;e++,n=this.m_rShape.getNextVertex(n))this.m_rShape.setUserIndex(n,this.m_clusterParentageIndex,this.m_rTopoGraph.getClusterParentage(this.m_rTopoGraph.getClusterFromVertex(n)))}}Do(){this.cutPolylinePolyline_(),this.m_rShape.removeUserIndex(this.m_cutteeBreadcrumbsIndex),this.m_rShape.removeUserIndex(this.m_clusterParentageIndex)}setTbd(t){return 8|t}classifyStandardCut(t,e,s,n){const i=this.m_rShape.getPrevVertex(t),r=this.m_rShape.getNextVertex(t),o=i===Ar?Ar:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i)),a=r===Ar?Ar:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(r)),h=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),m=this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n));let l=1,u=32,c=32;if(eg(this.m_rTopoGraph,e,m,t=>{t===h&&(l=2),t===o&&(u=l),t===a&&(c=l)}),this.m_bConsiderTouch)32!==u&&this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|u),32!==c&&this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|c);else{if(32===u||32===c)return 1;if(u===c&&o!==h&&o!==m&&a!==h&&a!==m)return 1;this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|u),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|c)}return 0}classifyTouchCut(t,e,s,n){const i=this.m_rShape.getPrevVertex(t),r=this.m_rShape.getNextVertex(t),o=i===Ar?Ar:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(i)),a=r===Ar?Ar:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(r)),h=s===Ar?Ar:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(s)),m=n===Ar?Ar:this.m_rTopoGraph.getHalfEdgeConnector(e,this.m_rTopoGraph.getClusterFromVertex(n));if(!this.m_bConsiderTouch){let e;return(e=h===o||m===o)?this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))):(e=h===a||m===a)&&this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),e?0:1}if(o===Ar)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(a===Ar)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),0;if(o===a)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(m!==Ar){if(o===m)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(a===m)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),0;let s=1;eg(this.m_rTopoGraph,e,m,e=>{if(e===o){const t=this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,t),s=2}else if(e===a){const e=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,e),s=2}})}else{if(o===h)return this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex))),0;if(a===h)return this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,this.setTbd(this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex))),0;let s=2;eg(this.m_rTopoGraph,e,h,e=>{if(e===o){const t=this.m_rShape.getUserIndex(i,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(i,this.m_cutteeBreadcrumbsIndex,t),s=1}else if(e===a){const e=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex)|s;this.m_rShape.setUserIndex(t,this.m_cutteeBreadcrumbsIndex,e),s=1}})}return 0}classifyCutVertex(t,e){let s=0,n=0;for(let i=this.m_rTopoGraph.getClusterVertexIterator(e);i!==Ar;i=this.m_rTopoGraph.incrementVertexIterator(i)){const r=this.m_rTopoGraph.getVertexFromVertexIterator(i);if(this.m_rShape.getGeometryFromVertex(r)===this.m_cutter){n++;const i=this.m_rShape.getPrevVertex(r),o=this.m_rShape.getNextVertex(r);s+=i===Ar||o===Ar?this.classifyTouchCut(t,e,i,o):this.classifyStandardCut(t,e,i,o)}}n&&s===n&&!this.m_bConsiderTouch&&this.m_rShape.setUserIndex(t,this.m_clusterParentageIndex,this.m_IDCuttee)}cutPolylinePolyline_(){this.m_rShape.getGeometryType(this.m_cuttee),this.m_rShape.getGeometryType(this.m_cutter),this.m_rParent.m_maskLookup.length=0,this.m_rParent.m_maskLookup.length=this.m_IDBoth+1,this.m_rParent.m_maskLookup[this.m_IDBoth]=!0;for(let t=this.m_rShape.getFirstPath(this.m_cuttee);t!==Ar;t=this.m_rShape.getNextPath(t)){const e=this.m_rShape.getPathSize(t);let s=this.m_rShape.getFirstVertex(t);for(let t=0;t<e;++t,s=this.m_rShape.getNextVertex(s))this.m_rShape.setUserIndex(s,this.m_cutteeBreadcrumbsIndex,0);s=this.m_rShape.getFirstVertex(t);for(let t=0;t<e;++t,s=this.m_rShape.getNextVertex(s)){const t=this.m_rTopoGraph.getClusterFromVertex(s);this.m_rTopoGraph.getClusterParentage(t)===this.m_IDBoth&&this.classifyCutVertex(s,t)}}const t=(t,e)=>{let s=this.m_rShape.getUserIndex(t,this.m_cutteeBreadcrumbsIndex);const n=this.m_rTopoGraph.getHalfEdgeConnector(this.m_rTopoGraph.getClusterFromVertex(t),this.m_rTopoGraph.getClusterFromVertex(e));return(this.m_rTopoGraph.getHalfEdgeParentage(n)&this.m_IDBoth)===this.m_IDBoth&&(s|=4),s};for(let e=this.m_rShape.getFirstPath(this.m_cuttee);e!==Ar;e=this.m_rShape.getNextPath(e)){let s=this.m_rShape.getFirstVertex(e);const n=this.m_rShape.isClosedPath(e),i=this.m_rShape.getPathSize(e)+(n?1:0);let r=1,o=32;for(let e=this.m_rShape.getNextVertex(s);r<i;++r,s=e,e=this.m_rShape.getNextVertex(e)){const n=t(s,e);this.m_rShape.getUserIndex(s,this.m_clusterParentageIndex)===this.m_IDBoth&&(o=n),32!==o&&this.m_rShape.setUserIndex(s,this.m_cutteeBreadcrumbsIndex,o|n)}s=this.m_rShape.getLastVertex(e);let a=32;r=1;for(let e=this.m_rShape.getPrevVertex(s);r<i;++r,s=e,e=this.m_rShape.getPrevVertex(e)){const n=t(e,s);this.m_rShape.getUserIndex(s,this.m_clusterParentageIndex)===this.m_IDBoth&&(a=n),32!==a&&this.m_rShape.setUserIndex(e,this.m_cutteeBreadcrumbsIndex,a|n)}}let e=Ar,s=Ar,n=32;const i=this.m_rShape.hasSegmentParentage(),r=new fm;for(let t=this.m_rShape.getFirstPath(this.m_cuttee);t!==Ar;t=this.m_rShape.getNextPath(t)){const a=this.m_rShape.isClosedPath(t),h=this.m_rShape.getPathSize(t)+(a?1:0);let m=1,l=this.m_rShape.getFirstVertex(t),u=Ar,c=!0;for(let t=this.m_rShape.getNextVertex(l);m<h;++m,t=this.m_rShape.getNextVertex(t)){let a=this.m_rShape.getUserIndex(l,this.m_cutteeBreadcrumbsIndex);8===a?a=3:(a&=-9,4&a?a=4:3&~a||(a=3)),a!==n?(e!==Ar&&(u=this.m_rShape.addVertex(s,l),i&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l))&&this.m_rShape.setSegmentParentageBreakVertex(u,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,n)),e=this.m_rShape.createGeometry(o.enumPolyline),s=this.m_rShape.insertPath(e,Ar),n=a,c=!0):this.m_rShape.getUserIndex(l,this.m_clusterParentageIndex)===this.m_IDBoth&&4!==a&&(u=this.m_rShape.addVertex(s,l),i&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l))&&this.m_rShape.setSegmentParentageBreakVertex(u,!0),s=this.m_rShape.insertPath(e,Ar),c=!0),u=this.m_rShape.addVertex(s,l);const h=this.m_rTopoGraph.getClusterFromVertex(l);!c&&i&&this.m_rTopoGraph.isBreakNode(h)&&this.m_rShape.setSegmentParentageBreakVertex(u,!0);const m=this.m_rTopoGraph.getHalfEdgeFromVertex(l);if(i){const t=this.m_rTopoGraph.getSegmentParentage(m);this.m_rShape.setSegmentParentageAndBreak(u,t,c||this.m_rTopoGraph.isBreakNode(h))}this.m_rTopoGraph.isHalfEdgeCurve(m)&&(this.m_rTopoGraph.querySegmentXY(m,r),this.m_rShape.setSegmentToIndex(this.m_rShape.getVertexIndex(u),r.get().clone())),l=t,c=!1}u=this.m_rShape.addVertex(s,l),i&&this.m_rTopoGraph.isBreakNode(this.m_rTopoGraph.getClusterFromVertex(l))&&this.m_rShape.setSegmentParentageBreakVertex(u,!0),this.m_rCutHandles.push(e),this.m_rShape.setGeometryUserIndex(e,this.m_sideIndex,n),e=Ar,s=Ar,n=32}}}function ng(t,e,s){return new Jc(s).linesToPolygonsImpl(t,e)}function ig(s,n,i,r,a){if(r&&(r.m_reason=0,r.m_vertexIndex1=-1,r.m_vertexIndex2=-1),s.isEmpty())return 5;const h=s.getGeometryType();if(h===o.enumPoint)return hg(s,r);const m=Qe(n,s,!1).total();if(h===o.enumEnvelope){const e=s,n=new t;return e.queryEnvelope(n),n.isDegenerate(m)?(r&&(r.m_reason=4,r.m_vertexIndex1=-1,r.m_vertexIndex2=-1),0):5}if(F(h)){const t=s,e=new Wn({vd:t.getDescription()});return e.addSegment(t,!0),ig(e,n,i,r,a)}zt(h),e(h)||f("OGC simplify is not implemented for this geometry type");const l=s.getImpl().getIsSimple(m,[0]);let u=i?-1:l;if(5===u||0===u)return u;const c=new fg(s,n,u,a,!0);return h===o.enumMultiPoint||h===o.enumPolyline||h===o.enumPolygon?(u=c.isSimplePlanarImpl(),je(u)&&(u=5)):P(""),s.getImpl().setIsSimple(u,m),r&&r.assign(c.m_nonSimpleResult),u}function rg(e,s,n,i,r){if(i&&(i.m_reason=0,i.m_vertexIndex1=-1,i.m_vertexIndex2=-1),e.isEmpty())return 5;const a=e.getGeometryType();if(a===o.enumPoint)return hg(e,i);const h=Qe(s,e,!1).total();if(a===o.enumEnvelope){const s=e,n=t.constructEmpty();return s.queryEnvelope(n),n.isDegenerate(h)?(i&&(i.m_reason=4,i.m_vertexIndex1=-1,i.m_vertexIndex2=-1),0):5}if(F(a)){const t=e,o=new Wn({vd:t.getDescription()});return o.addSegment(t,!0),rg(o,s,n,i,r)}const m=e.getImpl().getIsSimple(h,[0]);let l=n?-1:m;if(-1!==l)return l;const u=new fg(e,s,l,r,!1);return a===o.enumMultiPoint?l=u.multipointIsSimpleAsFeature():a===o.enumPolyline?l=u.polylineIsSimpleAsFeature():a===o.enumPolygon?l=u.polygonIsSimpleAsFeature():P(""),e.getImpl().setIsSimple(l,h),i&&i.assign(u.m_nonSimpleResult),l}function og(e,s,n,i){if(e.isEmpty())return e;const r=e.getGeometryType();if(r===o.enumPoint){const t=new Is;if(hg(e,t),3===t.m_reason){const t=e.clone();return t.replaceNaNs(1,0),t}return 2===t.m_reason?e.createInstance():e}if(r===o.enumEnvelope){const n=Qe(s,e,!0).total(),i=e,r=t.constructEmpty();return i.queryEnvelope(r),r.isDegenerate(n)?i.createInstance():e}if(F(r)){const t=e,r=new Wn({vd:t.getDescription()});return r.addSegment(t,!0),og(r,s,n,i)}zt(r);const a=Qe(s,e,!1).total(),h=e.getImpl().getIsSimple(a,[0]),m=n?-1:h;if(je(m)){if(r===o.enumPolygon&&0!==e.getFillRule()){const t=e.clone();return t.setFillRule(0),t}return e}if((r===o.enumMultiPoint||r===o.enumPolyline)&&m>=1)return e;const l=new fg(e,s,m,i,!1);let u;return r===o.enumMultiPoint?u=l.multipointSimplifyAsFeature():r===o.enumPolyline?u=l.polylineSimplifyAsFeature():r===o.enumPolygon?u=l.polygonSimplifyAsFeature():P(""),u}function ag(s,n,i,r){if(s.isEmpty())return s;const a=s.getGeometryType();if(a===o.enumPoint){const t=new Is;if(hg(s,t),3===t.m_reason){const t=s.clone();return t.replaceNaNs(1,0),t}return 2===t.m_reason?s.createInstance():s}if(a===o.enumEnvelope){const e=s,i=new t;e.queryEnvelope(i);const r=Qe(n,s,!0).total();return i.isDegenerate(r)?e.createInstance():s}if(F(a)){const t=s,e=new Wn({vd:t.getDescription()});return e.addSegment(t,!0),ag(e,n,i,r)}zt(a),e(a)||f("OGC simplify is not implemented for this geometry type");const h=Qe(n,s,!1).total(),m=s.getImpl().getIsSimple(h,[0]),l=i?-1:m;if(5===l){if(a===o.enumPolygon&&0!==s.getFillRule()){const t=s.clone();return t.setFillRule(0),t}return s}return zc(s,Qe(n,s,!0),!1,l,r,0,!0)}function hg(t,e){const s=t.getX(),n=t.getY();if(!Number.isFinite(s)||!Number.isFinite(n))return e&&(e.m_reason=2,e.m_vertexIndex1=-1,e.m_vertexIndex2=-1),0;if(t.hasAttribute(1)){const s=t.getZ();if(!Number.isFinite(s))return e&&(e.m_reason=Number.isNaN(s)?3:2,e.m_vertexIndex1=-1,e.m_vertexIndex2=-1),0}return 5}class mg{constructor(){this.m_segment=null,this.m_vertexIndex=-1,this.m_pathIndex=-1,this.m_flags=0}setReversed(t){this.m_flags&=-2,this.m_flags=this.m_flags|(t?1:0)}getReversed(){return!!(1&this.m_flags)}getRightSide(){return this.getReversed()?0:1}}function lg(t,e,s,n,i){return{x:t,y:e,ipath:s,ivertex:n,ipolygon:i}}function ug(t,e){return t.x===e.x&&t.y===e.y&&t.ipath===e.ipath&&t.ivertex===e.ivertex&&t.ipolygon===e.ipolygon}function cg(t,e){t.x=e.x,t.y=e.y,t.ipath=e.ipath,t.ivertex=e.ivertex,t.ipolygon=e.ipolygon}function gg(t,e,s,n,i,r){return{x:t,y:e,ipath:s,ivertex:n,bBoundary:i,bEndPoint:r}}function dg(t,e){t.x=e.x,t.y=e.y,t.ipath=e.ipath,t.ivertex=e.ivertex,t.bBoundary=e.bBoundary,t.bEndPoint=e.bEndPoint}class _g extends hs{constructor(t){super(),this.m_helper=t}compare(t,e,s){const n=t.getElement(s),i=this.m_helper.m_xy.read(2*e)-this.m_helper.m_xy.read(2*n);return i<0?-1:i>0?1:0}}class pg extends hs{constructor(t){super(),this.m_helper=t}compare(t,e,s){const n=t.getElement(s),i=this.m_helper.m_edges[e],r=this.m_helper.m_edges[n],o=i.getReversed(),a=r.getReversed();let h=i.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0),m=r.m_segment.intersectionOfYMonotonicWithAxisX(this.m_helper.m_yScanline,0);if(h===m){const t=o?i.m_segment.getStartY():i.m_segment.getEndY(),e=a?r.m_segment.getStartY():r.m_segment.getEndY(),s=Math.min(t,e);let n=.5*(s-this.m_helper.m_yScanline)+this.m_helper.m_yScanline;n===this.m_helper.m_yScanline&&(n=s),h=i.m_segment.intersectionOfYMonotonicWithAxisX(n,0),m=r.m_segment.intersectionOfYMonotonicWithAxisX(n,0)}return h<m?-1:h>m?1:0}}class fg{constructor(t,e,s,n,i){this.m_multiVertexGeom=null,this.m_edges=[],this.m_freeEdges=[],this.m_lineEdgesRecycle=[],this.m_newEdges=[],this.m_recycledSegIter=null,this.m_crossOverHelperList=new Ke,this.m_progressTracker=null,this.m_progressCounter=0,this.m_AET=new ze,this.m_xyToNode1=null,this.m_xyToNode2=null,this.m_pathOrientations=null,this.m_pathParentage=null,this.m_xy=null,this.m_pairs=[],this.m_pairIndices=null,this.m_pathsForOGCTests=[],this.m_curveStitcher=null,this.m_editShape=null,this.m_multiPathStitcher=null,this.m_nonSimpleResult=new Is,this.m_progressCounter=0,this.m_progressTracker=n,this.m_geometry=t,this.m_knownSimpleResult=s,this.m_sr=e;const r=Qe(e,t,!1);this.m_toleranceIsSimple=r,this.m_toleranceIsSimpleClustering=Je(r),this.m_toleranceIsSimpleCracking=$e(r),this.m_toleranceSimplify=Qe(e,t,!0),this.m_description=this.m_geometry.getDescription(),this.m_attributeCount=this.m_description.getAttributeCount(),this.m_bOGCRestrictions=i,this.m_bPlanarSimplify=this.m_bOGCRestrictions,this.m_unknownOrientationPathCount=-1,this.m_yScanline=0,this.m_progressCounter=0}isSimplePlanarImpl(){if(this.m_bPlanarSimplify=!0,!this.checkStructure())return 0;const t=this.m_geometry.getGeometryType();return Z(t)&&!this.checkDegenerateSegments(!1)?0:this._CheckClustering()?Z(t)?this._CheckCracking()?this.m_geometry.getGeometryType()===o.enumPolyline?this.checkSelfIntersectionsPolylinePlanar()?4:0:this._CheckSelfIntersections()?this._CheckValidRingOrientation():0:0:5:0}isSimplePlanarImpl3D(){return n(0),7}generateSortedPairs(t){let e=null;Z(t.getGeometryType())&&(e=t);const s=(this.m_bPlanarSimplify||this.m_bOGCRestrictions)&&null!==e,n=t.getPointCount();this.m_xy=t.getAttributeStreamRef(0),this.m_pairs.length=0,this.m_pairIndices=new Fe(0),s&&(this.m_pathsForOGCTests.length=0);let i=0;for(let t=0;t<n;t++)if(this.m_pairs.push(2*t),this.m_pairs.push(2*t+1),this.m_pairIndices.add(2*t),this.m_pairIndices.add(2*t+1),s){for(;t>=e.getPathEnd(i);)i++;this.m_pathsForOGCTests.push(i)}const r=new Ve,o={parent:this,workPt:new l,userSort(t,e,n){n.sort(t,e,(t,e)=>this.parent.compareVerticesForPlanarClustering(t,e,s))},getValue(t){const e=this.parent.m_pairs[t],s=e>>1;return this.parent.m_xy.queryPoint2D(2*s,this.workPt),this.workPt.y+(1&e?this.parent.m_toleranceIsSimpleClustering:-this.parent.m_toleranceIsSimpleClustering)}};r.sort(this.m_pairIndices,0,2*n,o)}_TestToleranceDistancePlanar(t,e){const s=this.m_xy.read(2*t),n=this.m_xy.read(2*t+1),i=this.m_xy.read(2*e),r=this.m_xy.read(2*e+1);return!fl(s,n,i,r,this.m_toleranceIsSimpleClustering*this.m_toleranceIsSimpleClustering)||0!==this.m_geometry.getDimension()&&s===i&&n===r}checkStructure(){const t=this.m_geometry.getGeometryType();if(Z(t)){const t=this.m_geometry.getImpl(),e=this.m_geometry.getGeometryType()===o.enumPolygon?3:2;for(let s=0,n=t.getPathCount();s<n;s++)if(t.getPathSize(s)<e){if(t.hasNonLinearSegments()&&t.hasNonLinearSegmentsPath(s)&&t.getPathSize(s)>0)continue;return this.m_nonSimpleResult=new Is(1,s,0),!1}}if(e(t)){const t=this.m_geometry.getImpl(),e=t.getAttributeStreamRef(0);for(let s=0,n=t.getPointCount();s<n;s++)if(!e.readPoint2D(2*s).isFinite())return this.m_nonSimpleResult=new Is(2,s,0),!1;if(this.m_geometry.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,n=t.getPointCount();s<n;s++){const t=e.read(s);if(!Number.isFinite(t))return Number.isNaN(t)?this.m_nonSimpleResult=new Is(3,s,0):this.m_nonSimpleResult=new Is(2,s,0),!1}}}return!0}checkDegenerateSegments(t){const e=this.m_geometry.getImpl(),s=e.querySegmentIterator(),n=e.hasAttribute(1),i=n?ts(this.m_sr,e,!1).total():0,r=e.hasNonLinearSegments(),o=this.m_toleranceIsSimple.total();for(;s.nextPath();)for(;s.hasNextSegment();){const e=s.nextSegment();let a=e.calculateLowerLength2D();if(!(a>o||r&&e.isCurve()&&(a=e.calculateLength2D(),a>o))){if(t&&n){const t=e.getStartAttributeAsDbl(1,0),s=e.getEndAttributeAsDbl(1,0);if(Math.abs(s-t)>i)continue}return this.m_nonSimpleResult=new Is(4,s.getStartPointIndex(),-1),!1}}return!0}checkDegenerateSegments3D(){return n(0),!1}_CheckClustering(){const t=this.m_geometry.getImpl();this.generateSortedPairs(t);const e=t.getPointCount();this.m_AET.clear(),this.m_AET.setComparator(new _g(this)),this.m_AET.setCapacity(e);for(let t=0,s=2*e;t<s;t++){this.progress_();const e=this.m_pairIndices.read(t),s=this.m_pairs[e],n=s>>1;if(1&s){const t=this.m_AET.search(n),e=this.m_AET.getPrev(t),s=this.m_AET.getNext(t);if(this.m_AET.deleteNode(t),e!==ze.st_nullNode()&&s!==ze.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(e),this.m_AET.getElement(s)))return this.m_nonSimpleResult=new Is(5,this.m_AET.getElement(e),this.m_AET.getElement(s)),!1}else{const t=this.m_AET.addElement(n),e=this.m_AET.getPrev(t);if(e!==ze.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(e),n))return this.m_nonSimpleResult=new Is(5,n,this.m_AET.getElement(e)),!1;const s=this.m_AET.getNext(t);if(s!==ze.st_nullNode()&&!this._TestToleranceDistancePlanar(this.m_AET.getElement(s),n))return this.m_nonSimpleResult=new Is(5,n,this.m_AET.getElement(s)),!1}}return!0}_CheckCracking(){const t=this.m_geometry.getImpl(),e=t.getPointCount();return!t.hasNonLinearSegments()&&e<10?this._CheckCrackingBrute():this._CheckCrackingPlanesweep()}_CheckCrackingPlanesweep(){if(this.m_editShape=new Vr,this.m_editShape.addGeometry(this.m_geometry),this.m_editShape.hasCurves()){this.m_curveStitcher=new Tc;const e=t.constructEmpty();this.m_geometry.queryEnvelope(e);const s=bc(this.m_toleranceSimplify.total(),e),n=new Is;if(vc(this.m_editShape,s,this.m_toleranceSimplify.total(),0,n,this.m_curveStitcher,null,this.m_progressTracker),0!==n.m_reason)return this.m_editShape=null,this.m_nonSimpleResult.assign(n),!1}const e=new Is;return Xl(!1,this.m_editShape,this.m_toleranceIsSimpleCracking,e,this.m_progressTracker)?(null!=this.m_curveStitcher?(e.m_vertexIndex1=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,e.m_vertexIndex1),e.m_vertexIndex2=this.m_curveStitcher.getOriginalVertexIndex(this.m_editShape,e.m_vertexIndex2),this.m_curveStitcher=null):(e.m_vertexIndex1=this.m_editShape.getVertexIndex(e.m_vertexIndex1),e.m_vertexIndex2=this.m_editShape.getVertexIndex(e.m_vertexIndex2)),this.m_editShape=null,this.m_nonSimpleResult.assign(e),!1):(null==this.m_curveStitcher&&(this.m_editShape=null),!0)}_CheckCrackingBrute(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator();for(;e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(!e.isLastSegmentInPath()||!e.isLastPath()){s.resetTo(e);do{for(;s.hasNextSegment();){const n=om(!0,t,s.nextSegment(),this.m_toleranceIsSimpleCracking,!0);if(n){const t=2===n?7:6;return this.m_nonSimpleResult=new Is(t,e.getStartPointIndex(),s.getStartPointIndex()),!1}}}while(s.nextPath())}}return!0}_CheckSelfIntersections(){let t=this.m_geometry.getImpl();null!==this.m_curveStitcher&&(this.m_multiPathStitcher=this.m_editShape.getGeometry(this.m_editShape.getFirstGeometry()),t=this.m_multiPathStitcher.getImpl(),this.generateSortedPairs(t)),this.m_edges.length=0,this.m_lineEdgesRecycle.length=0,this.m_recycledSegIter=t.querySegmentIterator(),this.m_recycledSegIter.setCirculator(!0);const e=[],s=t.getPointCount();let n=Number.NaN,i=0;for(let t=0,r=2*s;t<r;t++){this.progress_();const s=this.m_pairIndices.read(t),r=this.m_pairs[s];if(1&r)continue;const o=r>>1,a=this.m_xy.read(2*o),h=this.m_xy.read(2*o+1);if(e.length&&(a!==n||h!==i)){if(!this.processBunchForSelfIntersectionTest(e))return!1;e.length=0}e.push(o),n=a,i=h}return!!this.processBunchForSelfIntersectionTest(e)}checkSelfIntersectionsPolylinePlanar(){const t=this.m_geometry.getImpl(),e=[];for(let s=0,n=t.getPathCount();s<n;s++)e.push(t.isClosedPathInXYPlane(s));const s={x:-1,y:-1,ipath:-1,ivertex:-1,bBoundary:!1,bEndPoint:!1};let n,i,r;{const o=this.m_pairIndices.read(0),a=this.m_pairs[o]>>1,h=this.m_xy.readPoint2D(2*a),m=this.m_pathsForOGCTests[a];n=e[m],i=t.getPathStart(m),r=t.getPathEnd(m)-1,s.bEndPoint=a===i||a===r,this.m_bOGCRestrictions?s.bBoundary=!n&&s.bEndPoint:s.bBoundary=s.bEndPoint,s.ipath=m,s.x=h.x,s.y=h.y,s.ivertex=a}for(let o=1,a=this.m_pairIndices.size();o<a;o++){const a=this.m_pairIndices.read(o),h=this.m_pairs[a];if(1&h)continue;const m=h>>1,l=this.m_xy.readPoint2D(2*m),u=this.m_pathsForOGCTests[m];let c;u!==s.ipath&&(n=e[u],i=t.getPathStart(u),r=t.getPathEnd(u)-1);const g=m===i||m===r;c=this.m_bOGCRestrictions?!n&&g:g;const d=gg(l.x,l.y,u,m,c,g);if(d.x===s.x&&d.y===s.y)if(this.m_bOGCRestrictions){if(!(d.bBoundary&&s.bBoundary||d.ipath===s.ipath&&d.bEndPoint&&s.bEndPoint))return this.m_nonSimpleResult=new Is(10,d.ivertex,s.ivertex),!1}else if(!d.bEndPoint||!s.bEndPoint)return this.m_nonSimpleResult=new Is(7,d.ivertex,s.ivertex),!1;dg(s,d)}return!0}checkSelfIntersectionsPolylinePlanar3D(t){return n(0),!1}checkSelfIntersectionsPolygonsOGC(){const t=this.m_geometry.getImpl(),e=[];let s=-1,n=!1;for(let i=0,r=t.getPathCount();i<r;i++)t.isExteriorRingOGC(i)&&(n=!1,s++,i<r-1&&(t.isExteriorRingOGC(i+1)||(n=!0))),e.push(n?s:-1);const i={x:-1,y:-1,ipath:-1,ivertex:-1,ipolygon:-1};{const t=this.m_pairIndices.read(0),s=this.m_pairs[t]>>1,n=this.m_xy.readPoint2D(2*s),r=this.m_pathsForOGCTests[s];i.ipath=r,i.x=n.x,i.y=n.y,i.ivertex=s,i.ipolygon=e[r]}const r=[];for(let t=1,s=this.m_pairIndices.size();t<s;t++){const s=this.m_pairIndices.read(t),n=this.m_pairs[s];if(1&n)continue;const o=n>>1,a=this.m_xy.readPoint2D(2*o),h=this.m_pathsForOGCTests[o],m=lg(a.x,a.y,h,o,e[h]);if(m.x===i.x&&m.y===i.y){if(m.ipath===i.ipath)return this.m_nonSimpleResult=new Is(11,m.ivertex,i.ivertex),!1;e[m.ipath]>=0&&e[m.ipath]===e[i.ipath]&&(0!==r.length&&ug(r.at(-1),i)||r.push({...i}),r.push(m))}cg(i,m)}if(0===r.length)return!0;const o=new Ke(!0);e.fill(-1);let a=-1;const h=new l;for(let t=0,s=r.length;t<s;t++){const s=r[t];s.x===h.x&&s.y===h.y||(a=o.createList(0),h.x=s.x,h.y=s.y);let n=e[s.ipath];-1===n&&(n=o.createList(2),e[s.ipath]=n),o.addElement(n,a),o.addElement(a,n)}const m=[];for(let t=o.getFirstList();-1!==t;t=o.getNextList(t)){const s=o.getListData(t);if(1&s||!(2&s))continue;let n=-1;for(m.push(t),m.push(-1);m.length;){const t=m.at(-1);m.pop();const e=m.at(-1);m.pop();const s=o.getListData(e);if(1&s){n=2&s?e:t;break}o.setListData(e,1|s);for(let s=o.getFirst(e);-1!==s;s=o.getNext(s)){const n=o.getData(s);n!==t&&(m.push(n),m.push(e))}}if(-1!==n){const t=e.indexOf(n);return this.m_nonSimpleResult=new Is(12,t,-1),!1}}return!0}_CheckValidRingOrientation(){const t=null!==this.m_multiPathStitcher?this.m_multiPathStitcher.getImpl():this.m_geometry.getImpl();if(t.calculateArea2D()<=0)return this.m_nonSimpleResult=new Is(8,1===t.getPathCount()?1:-1,-1),0;if(1===t.getPathCount())return this.m_bOGCRestrictions&&!this.checkSelfIntersectionsPolygonsOGC()?0:4;this.m_pathOrientations=new es(t.getPathCount(),0),this.m_pathParentage=new Fe(t.getPathCount(),-1);let e=-1,s=0;for(let n=0,i=t.getPathCount();n<i;n++){const i=t.calculateRingArea2D(n);if(this.m_pathOrientations.write(n,i<0?0:8),i>0)e=n,s=i;else{if(0===i)return this.m_nonSimpleResult=new Is(8,n,-1),0;if((e<0||s<Math.abs(i))&&(this.m_nonSimpleResult=new Is(9,n,-1),this.m_bOGCRestrictions))return 0;this.m_pathParentage.write(n,e)}}this.m_unknownOrientationPathCount=t.getPathCount(),this.m_newEdges.length=0;const n=t.getPointCount();this.m_yScanline=Number.NaN;const i=[];this.m_xyToNode1=new Fe(n,ze.st_nullNode()),this.m_xyToNode2=new Fe(n,ze.st_nullNode()),this.m_freeEdges.length=0,this.m_AET.clear(),this.m_AET.setComparator(new pg(this));for(let t=0,e=2*n;this.m_unknownOrientationPathCount>0&&t<e;t++){const e=this.m_pairIndices.read(t),s=this.m_pairs[e];if(1&s)continue;const n=s>>1,r=this.m_xy.read(2*n+1);if(r!==this.m_yScanline&&i.length){if(!this.processBunchForRingOrientationTest(i))return 0;i.length=0}i.push(n),this.m_yScanline=r}return this.m_unknownOrientationPathCount>0&&!this.processBunchForRingOrientationTest(i)?0:this.m_bOGCRestrictions?0!==this.m_nonSimpleResult.m_reason?0:this.checkSelfIntersectionsPolygonsOGC()?5:0:0===this.m_nonSimpleResult.m_reason?4:3}processBunchForSelfIntersectionTest(t){if(1===t.length)return!0;for(let e=0,s=t.length;e<s;e++){const s=t[e];this.m_recycledSegIter.resetToVertex(s,-1);const n=this.m_recycledSegIter.previousSegment();this.m_edges.push(this.createEdge(n,s,this.m_recycledSegIter.getPathIndex(),!0)),this.m_recycledSegIter.nextSegment();const i=this.m_recycledSegIter.nextSegment();this.m_edges.push(this.createEdge(i,s,this.m_recycledSegIter.getPathIndex(),!1))}this.m_edges.sort((t,e)=>this.edgeAngleCompare(t,e));let e=this.m_crossOverHelperList.getFirstList();-1===e&&(e=this.m_crossOverHelperList.createList(0)),this.m_crossOverHelperList.reserveNodes(this.m_edges.length);for(let t=0,s=this.m_edges.length;t<s;t++)this.m_crossOverHelperList.addElement(e,t);let s=!0,n=-1,i=-1;for(;s;){s=!1;let t=this.m_crossOverHelperList.getFirst(e);if(-1===t)break;let r=this.m_crossOverHelperList.getNext(t);for(;-1!==r;){const o=this.m_crossOverHelperList.getData(t),a=this.m_crossOverHelperList.getData(r);if(n=this.m_edges[o].m_vertexIndex,i=this.m_edges[a].m_vertexIndex,n!==i)t=r,r=this.m_crossOverHelperList.getNext(t);else if(s=!0,this.m_crossOverHelperList.deleteElement(e,t),t=this.m_crossOverHelperList.getPrev(r),r=this.m_crossOverHelperList.deleteElement(e,r),-1===r||-1===t)break}}const r=this.m_crossOverHelperList.getListSize(e);if(this.m_crossOverHelperList.clear(e),r>0)return this.m_nonSimpleResult=new Is(7,n,i),!1;for(let e=0,s=t.length;e<s;e++)this.recycleEdge(this.m_edges[e]);return this.m_edges.length=0,!0}processBunchForRingOrientationTest(t){for(let e=0,s=t.length;e<s;e++){const s=t[e];let n=this.m_xyToNode1.read(s);if(n!==ze.st_nullNode()){const t=this.m_AET.getElement(n);this.m_freeEdges.push(t),this.m_AET.deleteNode(n),this.recycleEdge(this.m_edges[t]),this.m_edges[t]=null,this.m_xyToNode1.write(s,ze.st_nullNode())}if(n=this.m_xyToNode2.read(s),n!==ze.st_nullNode()){const t=this.m_AET.getElement(n);this.m_freeEdges.push(t),this.m_AET.deleteNode(n),this.recycleEdge(this.m_edges[t]),this.m_edges[t]=null,this.m_xyToNode2.write(s,ze.st_nullNode())}}for(let e=0,s=t.length;e<s;e++){const s=t[e];this.m_recycledSegIter.resetToVertex(s,-1);const n=this.m_recycledSegIter.previousSegment();if(n.getStartY()>n.getEndY()){const t=this.m_recycledSegIter.getStartPointIndex(),e=this.createEdge(n,s,this.m_recycledSegIter.getPathIndex(),!0);let i;this.m_freeEdges.length>0?(i=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[i]=e):(i=this.m_edges.length,this.m_edges.push(e));const r=this.m_AET.addElement(i);this.m_xyToNode1.read(t)===ze.st_nullNode()?this.m_xyToNode1.write(t,r):this.m_xyToNode2.write(t,r),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(r)}this.m_recycledSegIter.nextSegment();const i=this.m_recycledSegIter.nextSegment();if(i.getStartY()<i.getEndY()){const t=this.m_recycledSegIter.getEndPointIndex(),e=this.createEdge(i,s,this.m_recycledSegIter.getPathIndex(),!1);let n;this.m_freeEdges.length>0?(n=this.m_freeEdges.at(-1),this.m_freeEdges.pop(),this.m_edges[n]=e):(n=this.m_edges.length,this.m_edges.push(e));const r=this.m_AET.addElement(n);this.m_xyToNode1.read(t)===ze.st_nullNode()?this.m_xyToNode1.write(t,r):this.m_xyToNode2.write(t,r),3&this.m_pathOrientations.read(this.m_recycledSegIter.getPathIndex())||this.m_newEdges.push(r)}}for(let t=0,e=this.m_newEdges.length;t<e&&this.m_unknownOrientationPathCount>0;t++){const e=this.m_newEdges[t],s=this.m_AET.getElement(e),n=this.m_edges[s].m_pathIndex;if(!(3&this.m_pathOrientations.read(n))){let t=-1,s=this.m_AET.getPrev(e),n=e,i=0;{let e=-1,r=null,o=-1,a=0;for(;s!==ze.st_nullNode()&&(e=this.m_AET.getElement(s),r=this.m_edges[e],o=r.m_pathIndex,a=this.m_pathOrientations.read(o),!(3&a));)n=s,s=this.m_AET.getPrev(s);s===ze.st_nullNode()?(i=1,s=n):(t=1==(3&a)?o:this.m_pathParentage.read(o),i=r.getRightSide()?0:1,s=this.m_AET.getNext(s))}do{const e=this.m_AET.getElement(s),r=this.m_edges[e],o=r.m_pathIndex;let a=this.m_pathOrientations.read(o);if(!(3&a)){if(i!==r.getRightSide())return this.m_nonSimpleResult=new Is(8,o,-1),!1;const e=i&&!r.getReversed()?1:2;if(a=-4&a|e,this.m_pathOrientations.write(o,a),2===e&&0===this.m_nonSimpleResult.m_reason){const e=this.m_pathParentage.read(o);if(e!==t&&(this.m_nonSimpleResult=new Is(9,o,e),this.m_bOGCRestrictions))return!1}if(this.m_unknownOrientationPathCount--,!this.m_unknownOrientationPathCount)return!0}t=1==(3&a)?o:this.m_pathParentage.read(o),n=s,s=this.m_AET.getNext(s),i=i?0:1}while(n!==e)}}return this.m_newEdges.length=0,!0}createEdge(t,e,s,n){let i;return t.getGeometryType()===o.enumLine?i=this.createEdgeLine(t):(i=new mg,i.m_segment=t.clone()),i.m_vertexIndex=e,i.m_pathIndex=s,i.m_flags=0,i.setReversed(n),i}createEdgeLine(t){let e;return this.m_lineEdgesRecycle.length>0?(e=this.m_lineEdgesRecycle.at(-1),this.m_lineEdgesRecycle.pop(),t.copyTo(e.m_segment)):(e=new mg,e.m_segment=t.clone()),e}recycleEdge(t){t.m_segment.getGeometryType()===o.enumLine&&this.m_lineEdgesRecycle.push(t)}static isShortSegment(t,e,s,n){let i=t.calculateLowerLength2D();if(i<=s){let r=!0;if(t.isCurve()&&(i=t.calculateLength2D(),r=i<=s),r){if(e){let e=t.getEndAttributeAsDbl(1,0);Number.isNaN(e)&&(e=0);let s=t.getStartAttributeAsDbl(1,0);return Number.isNaN(s)&&(s=0),Math.abs(s-e)<=n}return!0}return!1}return!1}static isShortSegmentPoints(t,e,s,n,i){if(s){const s=t.getXYZ(),r=e.getXYZ();return ss(s,r,n,i)}{const s=t.getXY(),i=e.getXY();return l.sqrDistance(s,i)<=n*n}}removeDegenerateSegmentsFromCurvedPath(t,e,s,i){const r=t.hasAttribute(1),o=t.querySegmentIterator();o.resetToPath(e),n(o.nextPath());const a=this.m_toleranceSimplify.total();let h=!1,m=!0;const u=new qe,c=new qe,g=new l;for(;o.hasNextSegment();){this.progress_();const t=o.nextSegment();if(fg.isShortSegment(t,r,a,s))if(h){if(t.queryEnd(c),fg.isShortSegmentPoints(u,c,r,a,s))continue;m&&(i.startPathPoint(u),m=!1),t.queryEnd(u),i.lineToPoint(u),h=!1}else g.assign(t.getStartXY()),t.queryStart(u),h=!0;else if(h)if(t.isCurve()){const e=t.clone();if(e.setCoordsForIntersector(g,t.getEndXY(),!1),e.setStart(u),fg.isShortSegment(e,r,a,s))continue;i.addSegment(e,m),m=!1,h=!1}else{if(t.queryEnd(c),fg.isShortSegmentPoints(u,c,r,a,s))continue;m&&(i.startPathPoint(u),m=!1),i.lineToPoint(c),h=!1}else i.addSegment(t,m),m=!1}if(m)return;if(!h)return;t.isClosedPath(e)?t.getPointByVal(t.getPathStart(e),u):t.getPointByVal(t.getPathEnd(e)-1,u);const d=i.querySegmentIterator();d.resetToLastPath(),d.resetToLastSegment();const _=i.getDescription().getAttributeCount()>1;for(n(d.previousPath());d.hasPreviousSegment();){const t=d.previousSegment();if(t.isCurve()){const e=t.clone();if(e.setCoordsForIntersector(t.getStartXY(),u.getXY(),!1),!fg.isShortSegment(e,r,a,s)){_&&e.setEnd(u);const t=d.getEndPointIndex();for(let e=i.getPointCount()-1;e>=t;e--)i.removePoint(e);return void i.addSegment(e,!1)}}else if(t.queryStart(c),!fg.isShortSegmentPoints(c,u,r,a,s)){const t=d.getEndPointIndex();for(let e=i.getPointCount()-1;e>=t;e--)i.removePoint(e);return void i.lineToPoint(u)}}i.removePath(i.getPathCount()-1)}multipointIsSimpleAsFeature(){if(!this.checkStructure())return 0;const t=this.m_geometry.getImpl();this.m_multiVertexGeom=t;const e=t.getPointCount(),s=h(e,0);for(let t=0;t<e;t++)s[t]=t;s.sort((t,e)=>this.compareVerticesMultiPoint(t,e));for(let t=1;t<e;t++)if(0===this.compareVerticesMultiPoint(s[t-1],s[t]))return this.m_nonSimpleResult=new Is(5,s[t-1],s[t]),0;return 1}polylineIsSimpleAsFeature(){return this.checkStructure()&&this.checkDegenerateSegments(!0)?1:0}polygonIsSimpleAsFeature(){return this.isSimplePlanarImpl()}multipointSimplifyAsFeature(){let t=this.m_geometry.getImpl();const e=fg.hasNanZs(t);let s,n=this.m_geometry;e&&(s=this.m_geometry.clone(),t=s.getImpl(),s.replaceNaNs(1,Ee.getDefaultValue(1)),n=s),this.m_multiVertexGeom=t;const i=t.getPointCount(),r=h(i,0);for(let t=0;t<i;t++)r[t]=t;r.sort((t,e)=>this.compareVerticesMultiPoint(t,e));const o=new Array(i);o.fill(!1);let a=-1;for(let e=0;e<i;e++){const s=r[e];t.getXY(s).isFinite()&&((a<0||0!==this.compareVerticesMultiPoint(a,s))&&(o[s]=!0),a=s)}const m=this.m_geometry.createInstance();let l=0,u=0;for(let t=0;t<i;t++)o[t]?u=t+1:(l<u&&m.addPoints(n,l,u),l=t+1);return l<u&&m.addPoints(n,l,u),m.getImpl().setIsSimple(1,this.m_toleranceSimplify.total()),m}polylineSimplifyAsFeature(){const t=this.m_geometry.getImpl(),e=t.querySegmentIterator(),s=t.querySegmentIterator(),n=this.m_geometry.createInstance(),i=this.m_geometry,r=t.hasAttribute(1),o=r?ts(this.m_sr,t,!0).total():0,a=[],h=[];let m=null;r&&(m=t.getAttributeStreamRef(1));const u=new qe,c=t.hasNonLinearSegments(),g=this.m_toleranceSimplify.total();for(;e.nextPath();){if(s.nextPath(),t.getPathSize(e.getPathIndex())<2)continue;if(c&&t.hasNonLinearSegmentsPath(e.getPathIndex())){this.removeDegenerateSegmentsFromCurvedPath(t,e.getPathIndex(),o,n);continue}s.resetToLastSegment();let d=0,_=0,p=!0,f=!0;for(;e.hasNextSegment();){this.progress_();const n=e.nextSegment(),i=s.previousSegment();if(e.getStartPointIndex()>s.getStartPointIndex())break;if(p){const s=e.getStartPointIndex();t.getXY(s).isNAN()||(p=!1,a.push(s))}if(f){const e=s.getEndPointIndex();t.getXY(e).isNAN()||(h.push(e),f=!1)}if(!p){const s=a.at(-1),i=e.getEndPointIndex();if(i-s>1){const e=new l;e.setSub(t.getXY(s),t.getXY(i)),d=e.length()}else d=n.calculateLength2D();if(d>g)a.push(i),d=0;else if(r){let t=m.read(s);Number.isNaN(t)&&(t=0);let e=m.read(i);Number.isNaN(e)&&(e=0),Math.abs(e-t)>o&&(a.push(i),d=0)}}if(!f){const e=h.at(-1),n=s.getStartPointIndex();if(n-e>1){const s=new l;s.setSub(t.getXY(e),t.getXY(n)),_=s.length()}else _=i.calculateLength2D();if(_>g)h.push(n),_=0;else if(r){let t=m.read(e);Number.isNaN(t)&&(t=0);let s=m.read(n);Number.isNaN(s)&&(s=0),Math.abs(s-t)>o&&(h.push(n),_=0)}}}if(a.length>0&&h.length>0&&(a.at(-1)<h.at(-1)?a.length>h.length?a.pop():h.pop():(a.at(-1)===h.at(-1)||h.pop(),h.pop())),h.length+a.length>=2){let t=!1;for(let e=0,s=a.length;e<s;e++)i.getPointByVal(a[e],u),t?n.lineToPoint(u):(n.startPathPoint(u),t=!0);for(let e=h.length-1;e>0;e--)i.getPointByVal(h[e],u),t?n.lineToPoint(u):(n.startPathPoint(u),t=!0);i.isClosedPath(e.getPathIndex())?n.closePathWithLine():h.length>0&&(i.getPointByVal(h[0],u),n.lineToPoint(u))}a.length=0,h.length=0}return r&&n.replaceNaNs(1,0),n.getImpl().setIsSimple(1,g),n}polygonSimplifyAsFeature(){return this.simplifyPlanar()}simplifyPlanar(){if(1===this.m_geometry.getFillRule()&&!ns(this.m_knownSimpleResult))return Oc(this.m_geometry,this.m_toleranceSimplify,!0,!1,this.m_knownSimpleResult,this.m_progressTracker,0,!0);const e=new Vr;if(e.addGeometry(this.m_geometry),this.m_geometry.hasAttribute(1)&&e.replaceNaNs(1,0),e.removeNaNVertices(),0!==e.getTotalPointCount()){let s=null,n=0,i=0;if(e.hasCurves()){s=new Tc;const r=t.constructEmpty();this.m_geometry.queryEnvelope(r);const o=bc(this.m_toleranceSimplify.total(),r);n=wc(this.m_toleranceSimplify.total()),i=Dc(o,n),Ec(e,o,this.m_toleranceSimplify.total(),0,s,null,this.m_progressTracker)}ns(this.m_knownSimpleResult)||Ac(e,this.m_toleranceSimplify.add(i),this.m_progressTracker,!0,!1),this.m_geometry.getGeometryType()===o.enumPolygon&&Zl(e,e.getFirstGeometry(),this.m_knownSimpleResult,!1,-1,this.m_progressTracker),null!==s&&s.stitchCurves(e,e.getFirstGeometry(),n,!0)}const s=e.getGeometry(e.getFirstGeometry());return s.getGeometryType()===o.enumPolygon&&(s.getImpl().updateOGCFlagsProtected(),s.setFillRule(0)),s.getImpl().setIsSimple(4,this.m_toleranceSimplify.total()),s}progress_(){}static hasNanZs(t){if(t.hasAttribute(1)){const e=t.getAttributeStreamRef(1);for(let s=0,n=t.getPointCount();s<n;s++){const t=e.read(s);if(Number.isNaN(t))return!0}}return!1}compareVerticesForPlanarClustering(t,e,s){if(t===e)return 0;const n=this.m_pairs[t],i=this.m_pairs[e],r=n>>1,o=i>>1,a=this.m_xy.readPoint2D(2*r);a.y+=1&n?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const h=this.m_xy.readPoint2D(2*o);h.y+=1&i?this.m_toleranceIsSimpleClustering:-this.m_toleranceIsSimpleClustering;const m=a.compare(h);if(0===m&&s){const t=this.m_pathsForOGCTests[r]-this.m_pathsForOGCTests[o];return gt(t)}return m}compareVerticesMultiPoint(t,e){if(t===e)return 0;const s=this.m_multiVertexGeom.getXY(t),n=this.m_multiVertexGeom.getXY(e),i=!s.isFinite(),r=!n.isFinite();if(i||r)return i<r?-1:i>r?1:0;if(s.y<n.y)return-1;if(s.y>n.y)return 1;if(s.x<n.x)return-1;if(s.x>n.x)return 1;for(let s=1;s<this.m_attributeCount;s++){const n=this.m_description.getSemantics(s),i=Ee.getComponentCount(n);for(let s=0;s<i;s++){const i=this.m_multiVertexGeom.getAttributeAsDbl(n,t,s),r=this.m_multiVertexGeom.getAttributeAsDbl(n,e,s),o=Ut(i,r);if(0!==o)return o}}return 0}edgeAngleCompare(t,e){if(t===e)return 0;const s=t.m_segment.getTangent(t.getReversed()?1:0);t.getReversed()&&s.negateThis();const n=e.m_segment.getTangent(e.getReversed()?1:0);e.getReversed()&&n.negateThis();const i=s.getQuarter(),r=n.getQuarter();if(r===i){const t=s.crossProduct(n);return t<0?1:t>0?-1:0}return i<r?-1:1}}class xg{getOperatorType(){return 10103}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}isSimpleAsFeature(t,e,s,n,i){const r=rg(t,e,s,n,i);return We(t.getGeometryType(),r)}isSimplePlanarDONOTUSE(e,s,n,i,r){const a=function(e,s,n,i,r){if(i&&(i.m_reason=0,i.m_vertexIndex1=-1,i.m_vertexIndex2=-1),e.isEmpty())return 5;const a=e.getGeometryType();if(a===o.enumPoint)return hg(e,i);const h=Qe(s,e,!1).total();if(a===o.enumEnvelope){const s=e,n=new t;return s.queryEnvelope(n),n.isDegenerate(h)?(i&&(i.m_reason=4,i.m_vertexIndex1=-1,i.m_vertexIndex2=-1),0):5}if(F(a)){const t=e,o=new Wn({vd:t.getDescription()});return o.addSegment(t,!0),rg(o,s,n,i,r)}const m=e.getImpl().getIsSimple(h,[0]);let l=n?-1:m;if(je(l)||0===l)return l;const u=new fg(e,s,l,r,!1);return a===o.enumMultiPoint||a===o.enumPolyline||a===o.enumPolygon?l=u.isSimplePlanarImpl():P(""),e.getImpl().setIsSimple(l,h),i&&i.assign(u.m_nonSimpleResult),l}(e,s,n,i,r);return je(a)}executeMany(t,e,s,n){return new yg(t,e,s,n)}execute(t,e,s,n){const i=new Es([t]),r=this.executeMany(i,e,s,n).next();return r||P("null geometry"),r}}class yg extends Cs{constructor(t,e,s,n){super(),this.m_progressTracker=n,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=t,this.m_spatialReference=e}next(){const t=this.m_inputGeometryCursor.next();return t?(this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(t)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(t){if(t||s(""),t.getGeometryType()===o.enumGeometryCollection){const e=pn(t,-1),s=(new xg).executeMany(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker),n=t.createInstance();for(let t=s.next();null!=t;t=s.next())n.addGeometry(t);return n}return og(t,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}class Pg{constructor(t,e,s,n){this.m_intersectorGeom=null,this.m_sr=null,this.m_dimensionMask=-1,this.m_progressTracker=null,this.m_intersectorGeomType=o.enumUnknown,this.m_geomIntersectorEmptyGeom=null,this.m_intersectorGeom=t,this.m_sr=e,this.m_dimensionMask=s,this.m_progressTracker=n,this.m_intersectorGeomType=t.getGeometryType()}intersect(e){const s=this.tryFastImplementation(e);if(null!==s)return s;const n=is(this.m_intersectorGeom,e),i=Oe(this.m_sr,n,!0).total(),r=t.constructEmpty();this.m_intersectorGeom.queryEnvelope(r);const a=t.constructEmpty();e.queryEnvelope(a),r.inflateCoords(2*i,2*i),r.intersect(a),r.inflateCoords(100*i,100*i);let h=Pm(this.m_intersectorGeom,r,0,0,this.m_progressTracker),m=Pm(e,r,0,0,this.m_progressTracker);return e.getDimension()>this.m_intersectorGeom.getDimension()&&(h=p(m,m=h)),function(e,s,n,i){const r=t.constructEmpty();e.queryEnvelope(r);const a=t.constructEmpty();s.queryEnvelope(a);const h=t.constructEmpty();h.setCoords({env2D:r}),h.mergeEnvelope2D(a);const m=Oe(n,h,!0),l=new t(a),u=Je(m);if(l.inflateCoords(u,u),!r.isIntersecting(l)){if(e.getDimension()<=s.getDimension())return $c(tg(e.createInstance()),e,0,"&");if(e.getDimension()>s.getDimension())return $c(tg(s.createInstance()),e,0,"&")}const c=new Jc(i),g=new Vr,d=g.addGeometry(tg(e)),_=g.addGeometry(tg(s));let p=0,f=0,x=null;if(g.hasCurves()){x=new Tc;const t=g.getEnvelope2D(i);f=wc(m.total());const e=bc(m.total(),t);p=Dc(e,f),Ec(g,e,m.total(),0,x,null,i)}c.setEditShapeCrackAndCluster(g,m.add(p));const y=c.intersection(d,_);null!==x&&x.stitchCurves(g,y,f,!0);const P=$c(g.getGeometry(y),e,0,"&");return Rc(P.getGeometryType())&&(P.getImpl().setIsSimple(4,m.total()),P.getGeometryType()===o.enumPolygon&&P.getImpl().updateOGCFlagsProtected()),P}(m,h,this.m_sr,this.m_progressTracker)}intersectEx(e){const s=this.tryFastImplementation(e);if(null!==s){const t=[];return t.length=3,t[s.getDimension()]=s,this.prepareVector(e.getDescription(),this.m_dimensionMask,t)}const n=is(this.m_intersectorGeom,e),i=Oe(this.m_sr,n,!0).total(),r=t.constructEmpty();this.m_intersectorGeom.queryEnvelope(r);const a=t.constructEmpty();e.queryEnvelope(a),r.inflateCoords(2*i,2*i),r.intersect(a),r.inflateCoords(100*i,100*i);let h=Pm(this.m_intersectorGeom,r,0,0,this.m_progressTracker),m=Pm(e,r,0,0,this.m_progressTracker);e.getDimension()>this.m_intersectorGeom.getDimension()&&(h=p(m,m=h));const l=function(e,s,n,i){const r=new Array(3),a=t.constructEmpty();e.queryEnvelope(a);const h=t.constructEmpty();s.queryEnvelope(h);const m=t.constructEmpty();m.setCoords({env2D:a}),m.mergeEnvelope2D(h);const l=Oe(n,m,!0),u=new t(h),c=Je(l);if(u.inflateCoords(c,c),!a.isIntersecting(u)){if(e.getDimension()<=s.getDimension()){const t=$c(tg(e.createInstance()),e,0,"&");return r[t.getDimension()]=t,r}if(e.getDimension()>s.getDimension()){const t=$c(tg(s.createInstance()),e,0,"&");return r[t.getDimension()]=t,r}}const g=new Jc(i),d=new Vr,_=d.addGeometry(tg(e)),p=d.addGeometry(tg(s));let f=0,x=0,y=null;if(d.hasCurves()){y=new Tc;const t=d.getEnvelope2D(i);x=wc(l.total());const e=bc(l.total(),t);f=Dc(e,x),Ec(d,e,l.total(),0,y,null,i)}g.setEditShapeCrackAndCluster(d,l.add(f)),d.dbgVerifyCurves();const P=g.intersectionEx(_,p);for(const t of P){null!==y&&y.stitchCurves(d,t,x,!1);const s=$c(d.getGeometry(t),e,0,"&");Rc(s.getGeometryType())&&(s.getImpl().setIsSimple(4,l.total()),s.getGeometryType()===o.enumPolygon&&s.getImpl().updateOGCFlagsProtected()),r[s.getDimension()]=s}return null!==y&&y.clearStitcher(d),r}(m,h,this.m_sr,this.m_progressTracker);return this.prepareVector(e.getDescription(),this.m_dimensionMask,l)}init(t,e,s,i=null){n(0)}static intersectPoints(t,e,s){const n=is(t,e);return i=t,r=e,o=Oe(s,n,!0),i.isEmpty()||r.isEmpty()?i.createInstance():function(t,e,s){const n=Je(t);return fl(e.getX(),e.getY(),s.getX(),s.getY(),ot(n))}(o,i,r)?new qe({copy:Mc(i,r)}):i.createInstance();var i,r,o}tryFastImplementation(e){const s=e.getGeometryType();if(this.m_intersectorGeomType===o.enumPoint&&s===o.enumPoint){const t=Pg.intersectPoints(e,this.m_intersectorGeom,this.m_sr);if(-1!==this.m_dimensionMask){const e=new Fs({vd:t.getDescription()});return t.isEmpty()||e.add(t),e}return t}if(s===o.enumEnvelope&&this.m_intersectorGeomType===o.enumEnvelope&&(-1===this.m_dimensionMask||4===this.m_dimensionMask)){const t=e,s=this.m_intersectorGeom,n=new Ne({copy:t});return n.intersect(s),n}const n=is(e,this.m_intersectorGeom),i=Oe(this.m_sr,n,!0),r=e.isEmpty(),a=this.m_intersectorGeom.isEmpty();let h=r||a;if(!h){const s=function(e,s,n){const i=new t;e.queryEnvelope(i);const r=new t;s.queryEnvelope(r);const a=new t(r);if(a.inflate(2*n),!a.isIntersecting(i))return 4;const h=e.getGeometryType(),m=s.getGeometryType();if(h===o.enumEnvelope&&i.containsEnvelope(a))return 1;if(m===o.enumEnvelope){const e=new t(i);if(e.inflate(2*n),r.containsEnvelope(e))return 2}return 0}(this.m_intersectorGeom,e,i.total());if(4===s)h=!0;else{if(2&s)return this.m_intersectorGeom;if(1&s)return e}}if(h){const t=jt(s),n=jt(this.m_intersectorGeomType);return t<n?Pg.ReturnEmpty(e,r):t>n||0===t&&s===o.enumMultiPoint&&this.m_intersectorGeomType===o.enumPoint?this.ReturnEmptyIntersector():Pg.ReturnEmpty(e,r)}if(s===o.enumEnvelope&&0===jt(this.m_intersectorGeomType)||this.m_intersectorGeomType===o.enumEnvelope&&0===jt(s)){const n=s===o.enumEnvelope?e:this.m_intersectorGeom,r=s===o.enumEnvelope?this.m_intersectorGeom:e,a=t.constructEmpty();return n.queryEnvelope(a),Pm(r,a,i.total(),0,this.m_progressTracker)}if(0===jt(s)&&jt(this.m_intersectorGeomType)>0||jt(s)>0&&0===jt(this.m_intersectorGeomType)){if(s===o.enumMultiPoint)return Wc(e,this.m_intersectorGeom,i);if(s===o.enumPoint)return Zc(e,this.m_intersectorGeom,i);if(this.m_intersectorGeomType===o.enumMultiPoint)return Wc(this.m_intersectorGeom,e,i);if(this.m_intersectorGeomType===o.enumPoint)return Zc(this.m_intersectorGeom,e,i);P("")}return null}ReturnEmptyIntersector(){return null===this.m_geomIntersectorEmptyGeom&&(this.m_geomIntersectorEmptyGeom=this.m_intersectorGeom.createInstance()),this.m_geomIntersectorEmptyGeom}static ReturnEmpty(t,e){return e?t:t.createInstance()}prepareVector(t,e,s){let n=0;return 1&e?(s[0]||(s[0]=new Fs({vd:t})),n++):s.shift(),2&e?(s[n]||(s[n]=new Wn({vd:t})),n++):s.splice(n,1),4&e?s[n]||(s[n]=new Tr({vd:t})):s.splice(n,1),new Es(s)}}class Cg extends Cs{constructor(t,e,n,i,r){super(),this.m_smallCursor=null,this.m_progressTracker=i,this.m_geomIntersector=e.next(),this.m_intersector=new Pg(this.m_geomIntersector,n,r,i),this.m_index=-1,this.m_inputGeoms=t,this.m_dimensionMask=r,-1!==this.m_dimensionMask&&(this.m_dimensionMask<=0||this.m_dimensionMask>7)&&s("bad dimension mask")}next(){if(!this.m_geomIntersector)return null;let t;if(null!==this.m_smallCursor){if(t=this.m_smallCursor.next(),t)return t;this.m_smallCursor=null}for(;t=this.m_inputGeoms.next();)return Xt(t),this.m_index=this.m_inputGeoms.getGeometryID(),-1===this.m_dimensionMask?this.m_intersector.intersect(t):(this.m_smallCursor=this.m_intersector.intersectEx(t),this.m_smallCursor.next());return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class Eg{getOperatorType(){return 1e4}accelerateGeometry(t,e,s){if(!this.canAccelerateGeometry(t))return!1;Qe(e,t,!0);let n=0;return t.getGeometryType()!==o.enumPolygon&&t.getGeometryType()!==o.enumPolyline||!Vn(t)||0===s||(n|=t.getImpl().buildQuadTreeAccelerator(s)?1:0),!!n}canAccelerateGeometry(t){return Vn(t)}supportsCurves(){return!0}executeMany(t,e,s,n,i=-1){return new Cg(t,e,s,n,i)}execute(t,e,s,n){if(t.getGeometryType()===o.enumPoint&&e.getGeometryType()===o.enumPoint)return Pg.intersectPoints(t,e,s);const i=new Es([t]),r=new Es([e]),a=this.executeMany(i,r,s,n,-1).next();return a||P("null output"),a}}function Sg(t,e,s){return e.m_projector.project(t,s)}function vg(t,e,s,n,i){return t.m_projector.transformInPlaceZ(e,null,s,n,null,i)}function Ig(e,n,i,r){if(e&&n&&n.isPannable()||s("fold_into_360_range_geodetic"),e.isEmpty())return e;if(4===i)return bg(e,n,r);let a=e;const h=a.getGeometryType();if(Z(h)){a=Od(e,n);const s=new t;a.queryEnvelope(s);const r=Oe(n,s,!1).total(),o=n.getPannableExtent();let h=Math.floor((s.xmin-o.xmin)/o.width())*o.width()+o.xmin,m=a;for(;h<s.xmax;)h>s.xmin+r&&h<s.xmax-r&&(m=Ud(m,n,i,!0,h)),h+=o.width();a=m}else{if(h===o.enumEnvelope){const t=new Tr({vd:a.getDescription()});return t.addEnvelope(a,!1),Ig(t,n,i,r)}if(F(h)){const t=new Wn({vd:a.getDescription()});return t.addSegment(a,!0),Ig(t,n,i,r)}}return bg(a,n,r)}function bg(t,e,n){if(t&&e&&e.isPannable()||s(""),t.isEmpty())return t;let i;const r=t.getGeometryType();if(r===o.enumEnvelope){const e=new Tr({vd:t.getDescription()});e.addEnvelope(t,!1),i=e}else if(F(r)){const e=new Wn({vd:t.getDescription()});e.addSegment(t,!0),i=e}else i=t;const a=Od(i,e);return a.isEmpty()?a:kd(a,e,0,a!==t,0,n)}function wg(t,e,s,n){const i=e.getXYGridRange(),o=t.hasAttribute(1),a=t.hasAttribute(2);let h=new r,m=new r;o&&(h=e.getZGridRange()),a&&(m=e.getMGridRange());let l=(new Sm).execute(t,i,s,n);if(o){const e=l.queryInterval(1,0);h.contains(e)||(t===l&&(l=l.clone()),as(l,h,1,0))}if(a){const e=l.queryInterval(2,0);m.contains(e)||(t===l&&(l=l.clone()),as(l,m,2,0))}return l}class Dg{constructor(t){this.m_inputPCSHorizonClipOption=0,this.m_outputPCSHorizonClipOption=0,this.m_bDontGeonormalizePolygon=!1,this.m_bClipOutCurvedPoles=!1,this.m_bNormalizeOutputGeometry=!1,this.m_bDontHackPolesInGeogToGeog=!1,this.m_centralMeridianOfOutputGCS=0,this.m_densificationStepInput=0,t||s(""),this.m_projTransform=t,this.m_bClipOutCurvedPoles=!1;const e=this.m_projTransform.getExtendedParamsImpl();this.m_bNormalizeOutputGeometry=e.normalizeResultGeometry,this.m_bNormalizeOutputGeometry&&(e.legacyHorizonClipping?this.m_bNormalizeOutputGeometry=!1:this.m_projTransform.getOutputSR().isPannable()||(this.m_bNormalizeOutputGeometry=!1)),e.clipWithInputHorizon?(this.m_inputPCSHorizonClipOption=0,!e.legacyHorizonClipping&&this.m_projTransform.getInputSR().isPannable()&&(this.m_inputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_inputPCSHorizonClipOption=1,e.clipWithOutputHorizon?(this.m_outputPCSHorizonClipOption=0,!e.legacyHorizonClipping&&this.m_projTransform.getOutputSR().isPannable()&&(this.m_outputPCSHorizonClipOption=this.m_bNormalizeOutputGeometry?4:2)):this.m_outputPCSHorizonClipOption=1,this.m_centralMeridianOfOutputGCS=e.centralMeridianOfOutputGCS,this.m_densificationStepInput=e.densificationStep;const n=this.m_projTransform.getExtendedParamsInternal();this.m_bDontGeonormalizePolygon=n.hasFlag(2147483648),this.m_bDontHackPolesInGeogToGeog=n.hasFlag(1073741824),this.m_bClipOutCurvedPoles=n.hasFlag(536870912)}project(t,e){if(this.m_projTransform.isIdentity()||t.isEmpty())return t;const s=t.getGeometryType();if(s===o.enumPoint)return this.projectPoint(t,e);const n=this.m_projTransform.getInputSR().getCoordinateSystemType(),i=this.m_projTransform.getOutputSR().getCoordinateSystemType(),r=this.m_projTransform.getInputSR(),a=this.m_projTransform.getOutputSR();if(0===n&&n===i){const e=Ng(r,a),s=t.clone();return s.applyTransformation(e),s}switch(s){case o.enumPolyline:case o.enumPolygon:return this.projectMultiPath(t,e);case o.enumMultiPoint:return this.projectMultiPoint(t,e);case o.enumEnvelope:return this.projectEnvelope(t,e);case o.enumGeometryCollection:return this.projectGeometryCollection(t,e);default:P("")}}projectPoint(t,e){const s=[t.getXY()];let n,i=null;(n=t.hasAttribute(1))&&(i=[t.getZ()]),this.transformInPlaceZ(s,i,1,s,i,null);const r=t.clone();return r.setXY(s[0]),n&&r.setZ(i[0]),r}projectMultiPoint(t,e){let s=new Fs({copy:t});const i=this.m_projTransform.getInputSR(),r=this.m_projTransform.getOutputSR(),o=i.getCoordinateSystemType(),a=r.getCoordinateSystemType();if(3===o&&n(0),s=Jd(s,i,this.m_inputPCSHorizonClipOption,e),s.isEmpty())return s;2===o&&o_(i,0,s),c_(this.m_projTransform,s,!1);let h=0;3===a&&n(0);const m=2===a;return m?h=r.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(h=this.m_centralMeridianOfOutputGCS),m&&0!==this.m_outputPCSHorizonClipOption||(s=kd(s,pp(r),h,!1,0,e)),m&&(s=Fd(s,r,this.m_outputPCSHorizonClipOption,e),n_(r,s,this.m_bNormalizeOutputGeometry),s.isEmpty()),s}projectMultiPath(t,e){const s=t.getGeometryType();return s===o.enumPolygon?this.projectPolygon(t,e):s===o.enumPolyline?this.projectPolyline(t,e):void P("project_multi_path_")}projectEnvelope(t,e){this.m_projTransform.getInputSR(),this.m_projTransform.getOutputSR();const s=this.m_projTransform.isVertical()&&t.hasAttribute(1);let n=r.constructEmpty();if(s&&(n=t.queryInterval(1,0)),n.width()>0){const s=t.clone();s.setInterval(1,0,n.vmin,n.vmin);const i=this.projectEnvelopeHelper(s,e);s.setInterval(1,0,n.vmax,n.vmax);const r=this.projectEnvelopeHelper(s,e);return i.merge(r),i}return this.projectEnvelopeHelper(t,e)}projectPolygon(e,s){n(e.getGeometryType()===o.enumPolygon),n(!this.m_projTransform.isIdentity()),n(!e.isEmpty());const i=this.m_projTransform.getInputSR(),r=this.m_projTransform.getOutputSR(),a=i.getCoordinateSystemType(),h=r.getCoordinateSystemType(),m=new Tr({copy:e});3===a&&n(0),3===h&&n(0);const l=2===a,u=2===h,c=l?i.getGCS():i,g=u?r.getGCS():r,d=!u&&!this.m_bDontHackPolesInGeogToGeog;let _=!1,p=Jd(m,i,this.m_inputPCSHorizonClipOption,s);if(p.isEmpty())return p;let f=this.m_densificationStepInput;const x=!Number.isNaN(f);let y;x&&(p=(new wm).execute(p,f,0,0,s));let P=u?r.getPCSInfo():null,C=Number.NaN;l&&(C=i.getCentralMeridian());const E=null!==r.getGCSSplitLines();if(this.m_bDontGeonormalizePolygon){const t=p;if(l&&(m_(i,C,t),x)){const t=i.getUnitsPerMillimeter();f*=i.getGCS().getUnitsPerMillimeter()/t}if(d_(this.m_projTransform,t,d),x){const t=i.getGCS().getUnitsPerMillimeter();f*=r.getGCS().getUnitsPerMillimeter()/t}y=t}else{let e=new Wn({vd:p.getDescription()});if(e.addAndExplicitlyOpenAllPaths(p,!1),l){if(m_(i,C,e),x){const t=i.getUnitsPerMillimeter();f*=i.getGCS().getUnitsPerMillimeter()/t}if(this.m_bClipOutCurvedPoles){const n=i.getPCSInfo(),r=n.getSouthPoleGeometry()===Op.PE_POLE_LINE_CURVED,o=n.getNorthPoleGeometry()===Op.PE_POLE_LINE_CURVED;if(r||o){const n=t.constructEmpty();e.queryLooseEnvelope(n),n.inflateCoords(1,1);const i=89.9999*c.getOneDegreeGCSUnit();r&&(n.ymin=-i),o&&(n.ymax=i),e=function(e,s,n,i,r,o){const a=new Em(s,o),h=new t;return e.queryLooseEnvelope(h),s.containsEnvelope(h)?e:s.isIntersecting(h)?a.clipPolesOut(e,0):e.createInstance()}(e,n,0,0,0,s)}}}if(d_(this.m_projTransform,e,d),x){const t=pp(i).getUnitsPerMillimeter();f*=pp(r).getUnitsPerMillimeter()/t}let n=Number.NaN;u?(P=r.getPCSInfo(),n=r.getCentralMeridian()):Number.isNaN(this.m_centralMeridianOfOutputGCS)||(n=this.m_centralMeridianOfOutputGCS);let o=Tg(i)|Tg(r),a=10*g.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(o=3,a=10*g.getTolerance(0)),y=function(t,e,s,n,i,r,o,a,h){return new ud(t,null,s,e,n,i,o,a,r).geoNormalizePolygonGeometry(h)}(p,i,e,g,n,s,o,a,this.m_bNormalizeOutputGeometry),o=0}if(E&&(n(!r.isPannable()),y=Md(y,r,s)),u){if(!_){const t=g.getPannableExtent().width();if(y.queryInterval(0,0).width()>=t-10*g.getTolerance(0)){const t=P.getNorthPoleLocation(),e=P.getSouthPoleLocation(),s=P.getNorthPoleGeometry(),n=P.getSouthPoleGeometry();let i=0;s===Op.PE_POLE_POINT&&t!==Op.PE_POLE_OUTSIDE_BOUNDARY&&(i=1),n===Op.PE_POLE_POINT&&e!==Op.PE_POLE_OUTSIDE_BOUNDARY&&(i|=2),_||=0!==i}}y=Fd(y,r,this.m_outputPCSHorizonClipOption,s),x&&(y=(new wm).execute(y,f,0,0,s)),r_(r,y,this.m_bNormalizeOutputGeometry)}return y.isEmpty()||_&&(y=(new xg).execute(y,r,!1,s)),y}projectPolyline(t,e){n(t.getGeometryType()===o.enumPolyline),n(!this.m_projTransform.isIdentity()),n(!t.isEmpty());const s=this.m_projTransform.getInputSR(),i=this.m_projTransform.getOutputSR(),r=s.getCoordinateSystemType(),a=i.getCoordinateSystemType(),h=new Wn({copy:t});3===r&&n(0),3===a&&n(0);const m=2===r,l=2===a;m&&s.getGCS();const u=l?i.getGCS():i,c=!l&&!this.m_bDontHackPolesInGeogToGeog;let g=Jd(h,s,this.m_inputPCSHorizonClipOption,e);if(g.isEmpty())return g;let d=Number.NaN;m&&(d=s.getCentralMeridian());const _=null!==i.getGCSSplitLines();let p=this.m_densificationStepInput;const f=!Number.isNaN(p);let x;if(f&&(g=(new wm).execute(g,p,0,0,e)),this.m_bDontGeonormalizePolygon){if(m&&(m_(s,d,g),f)){const t=s.getUnitsPerMillimeter();p*=s.getGCS().getUnitsPerMillimeter()/t}if(d_(this.m_projTransform,g,c),f){const t=s.getGCS().getUnitsPerMillimeter();p*=i.getGCS().getUnitsPerMillimeter()/t}x=g}else{const t=new Wn({vd:g.getDescription()});if(t.addAndExplicitlyOpenAllPaths(g,!1),m&&(m_(s,d,t),f)){const t=s.getUnitsPerMillimeter();p*=s.getGCS().getUnitsPerMillimeter()/t}if(d_(this.m_projTransform,t,c),f){const t=s.getGCS().getUnitsPerMillimeter();p*=i.getGCS().getUnitsPerMillimeter()/t}let n=Number.NaN;l?n=i.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(n=this.m_centralMeridianOfOutputGCS);let r=Tg(s)|Tg(i),o=10*u.getTolerance(0);this.m_bDontHackPolesInGeogToGeog&&(r=3,o=0),x=function(t,e,s,n,i,r,o,a,h){return new ud(t,null,s,e,n,i,o,a,r).geoNormalizePolylineGeometry(h)}(g,s,t,u,n,e,r,o,this.m_bNormalizeOutputGeometry),r=0}return _&&(n(!i.isPannable()),x=Md(x,i,e)),l&&(x=Fd(x,i,this.m_outputPCSHorizonClipOption,e),f&&(x=(new wm).execute(x,p,0,0,e)),r_(i,x,this.m_bNormalizeOutputGeometry)),x.isEmpty(),x}projectGeometryCollection(t,e){return n(0),{}}projectEnvelopeHelper(e,s){const n=(e.height()+e.width())/400;if(0!==n){const i=(new wm).execute(e,n,0,0,s),r=this.projectMultiPath(i,s),o=new Ne({vd:e.getDescription()});if(r.isEmpty()){const n=Math.min(e.height(),e.width()),r=Qe(this.m_projTransform.getInputSR(),e,!0).total();if(n>100*r){const e=t.constructEmpty(),s=Oe(this.m_projTransform.getOutputSR(),e,!0).total(),i=this.m_projTransform.getInputSR().getOneMeter()/this.m_projTransform.getOutputSR().getOneMeter();if(n>100*Math.max(r,s*i))return o}const a=new Wn;a.addAndExplicitlyOpenAllPaths(i,!1),this.projectMultiPath(a,s).queryEnvelope(o);const h=new Fs({vd:e.getDescription()});h.reserve(4);const m=new qe;for(let t=0;t<4;t++)e.queryCornerByVal(t,m),h.add(m);const l=this.projectMultiPoint(h,s),u=new Ne;return l.queryEnvelope(u),o.merge(u),o}return r.queryEnvelope(o),o}{const t=e.getCenterXY(),n=new qe(t),i=this.projectPoint(n,s),r=new Ne({vd:e.getDescription()});if(i.isEmpty())r.setEmpty();else{e.copyTo(r);const t=i.getXY();r.setCoords(t.x,t.y,t.x,t.y)}return r}}transformInPlace(t,e,s,i){return n(0),0}transformInPlaceZ(t,e,i,r,a,h){if(this.m_projTransform.isIdentity())return t!==r&&Rt(r,t,i),e!==a&&g(a,e,0,0,i),i;const m=this.m_projTransform,l=m.getInputSR(),u=m.getOutputSR(),c=l.getCoordinateSystemType(),d=u.getCoordinateSystemType();if(0===c&&c===d)return Ng(l,u).transformPoints2D(t,i,r),m.isVertical()&&n(0),i;3===c&&f("image: transform_in_place_"),3===d&&f("image: transform_in_place_"),function(t,e,i,r,a){const h=r.getCoordinateSystemType();if(2===h){if(0===a)i!==t&&Rt(i,t,e),function(t,e,n){const i=t.getPCSHorizon();if(i.getGeometryType()===o.enumPolygon){const s=t.getDefaultPrecisionSR().getTolerance(0),r=i;for(let t=0;t<n;t++)1!==_c(r,e[t],s)&&e[t].setNAN();return}if(i.getGeometryType()===o.enumEnvelope){const t=i;for(let s=0;s<n;s++)t.contains(e[s])||e[s].setNAN();return}s("")}(r,i,e);else if(i!==t&&Rt(i,t,e),r.isPannable()){const t=r.getTolerance(0);!function(t,e,s,n){for(let i=0;i<e;i++){if(t[i].y<s.ymin||t[i].y>s.ymax){t[i].setNAN();continue}const e=t[i].x;t[i].x=Hd(e,s,n)}}(i,e,r.getPannableExtent(),t),Rd(i,e,r,0)}}else{n(1===h);const s=r.getTolerance(0),o=r.getPannableExtent();for(let n=0;n<e;n++)i[n].assign(Kd(t[n],o,s))}}(t,i,r,l,this.m_inputPCSHorizonClipOption),a!==e&&g(a,e,0,0,i),2===c&&l_(l,0,r,i),x_(this.m_projTransform,r,a,i,!1);let _=0;const p=2===d;if(p?_=u.getCentralMeridian():Number.isNaN(this.m_centralMeridianOfOutputGCS)||(_=this.m_centralMeridianOfOutputGCS),p&&0!==this.m_outputPCSHorizonClipOption||Rd(r,i,u.getGCS(),_),p){if(!Xd(r,i,u,this.m_outputPCSHorizonClipOption))for(let t=0;t<i;++t)r[t].setNAN();t_(u,r,i,!1)}let x=i;for(let t=0;t<i;++t)r[t].isNAN()&&(a&&(a[t]=Number.NaN),x--);return x}}function Tg(t){if(2!==t.getCoordinateSystemType())return 0;let e=0;const s=t.getPCSInfo(),n=s.getNorthPoleLocation(),i=s.getSouthPoleLocation(),r=s.getNorthPoleGeometry(),o=s.getSouthPoleGeometry();return r===Op.PE_POLE_POINT&&n!==Op.PE_POLE_OUTSIDE_BOUNDARY&&(e=1),o===Op.PE_POLE_POINT&&i!==Op.PE_POLE_OUTSIDE_BOUNDARY&&(e|=2),e}function Ng(t,e){const s=t.getHorzUnitFactor(),n=e.getHorzUnitFactor();let i=1,r=1;const o=20015077/180;1===t.getUnit().getUnitType()&&(i=o),1===e.getUnit().getUnitType()&&(r=o);const a=s/n*(i!==r?i/r:1),h=new Ps;return h.setScaleCoords(a,a),h}let Ag=class{getOperatorType(){return 10300}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s){return!e||e.isIdentity()?t:new Mg(t,e,s)}execute(t,e,s){return e.isIdentity()?t:Sg(t,e,s)}transform(t,e,s,n,i=!0){return i?function(t,e,s,n){t.m_projector.transformInPlaceZ(e,null,s,n,null,null);const i=n.slice(0,s).filter(t=>!t.isNAN());for(let t=0,e=i.length;t<e;++t)n[t].assign(i[t]);return i.length}(t,e,s,n):vg(t,e,s,n,null)}transform3D(t,e,s,i,r=!0){return n(0),0}foldInto360Range(t,e){return bg(t,e,null)}foldInto360RangeGeodetic(t,e,s){return Ig(t,e,s,null)}normalizeGeometryEx(t,s,n,i,r=0){return function(t,s,n,i,r){if(!s.isPannable()||t.isEmpty())return t;const a=t.getGeometryType();a===o.enumGeometryCollection&&f("not yet impl for geometry collection");const h=s.getPannableExtent();Number.isNaN(n)&&(n=h.getCenterX());const m=h.width(),u=.5*m,c=r>0,g=t.queryInterval(0,0);if(!c&&g.width()<u||!e(t.getGeometryType())){const e=g.getCenter();if(Math.abs(e-n)<=u)return t;{const s=new Ps,i=Ht((n-e)/m)*m;s.setShiftCoords(i,0);const r=t.clone();return r.applyTransformation(s),r}}if(a===o.enumPolygon){let e=new Wn({vd:t.getDescription()});e.addAndExplicitlyOpenAllPaths(t,!1),c&&(e=Gg(e,s,2,r,Number.NaN,null,!0));const o=[];if(!i){{let n=t;c&&(n=new Tr,n.add(e,!1));const i=function(t,e,s){const n=rp();e.querySpheroidData(n);const i=e.getGCS()!==e?e.getSRToGCSTransform():null,r=T(l,100),o=new Se(0,0,0),a=t.getPointCount(),h=e.getGCS().getUnit().getUnitToBaseFactor();for(let e=0,s=a;e<s;){const a=Math.min(100,s-e);t.queryCoordinates(r,a,e,e+a),i&&(new Ag).transform(i,r,a,r,!1);for(let t=0;t<a;t++){if(r[t].isNAN())continue;r[t].scale(h);const e=Vm(n.majorSemiAxis,n.e2,r[t]);o.addThis(e)}e+=a}const m=km(n.majorSemiAxis,n.e2,o);m.scale(1/h);const u=t;if(!new rd(e.getGCS(),m).project(u))return 0;s.length=t.getPathCount();const c=u.calculateArea2D()<0;for(let e=0,n=t.getPathCount();e<n;e++){const t=u.calculateRingArea2D(e),n=c?t<0:t>0;s[e]=n}return c?-1:1}(t,s,o);if(i)i<0&&e.reverseAllPaths();else{const t=n.getPathCount();for(let e=0;e<t;e++)o.push(n.calculateRingArea2D(e)>0)}}i=o}return new ud(null,i,e,null,s,n,3,0,null).geoNormalizePolygonGeometry(!0)}if(a===o.enumPolyline){let e=new Wn({vd:t.getDescription()});return e.addAndExplicitlyOpenAllPaths(t,!1),c&&(e=Gg(e,s,2,r,Number.NaN,null,!0)),new ud(null,null,e,null,s,n,3,0,null).geoNormalizePolylineGeometry(!0)}if(a===o.enumMultiPoint){const e=t,s=e.getAttributeStreamRef(0);let i,r=null,o=n,a=0;const h=.1*m;for(let n=0,l=e.getPointCount();n<l;n++){const e=s.read(2*n);let l=e-o;if(Math.abs(l)>u&&(l=Ht(l/m)*m,a-=l,Math.abs(a)<h&&(a=0)),0!==a){r||(i=t.clone(),r=i.getAttributeStreamRef(0));const s=e+a;r.write(2*n,s)}o=e}return r?(i.notifyModified(),i):t}P("")}(t,s,n,i,r)}normalizeGeometry(t,s,n){return function(t,s,n){if(!s.isPannable()||t.isEmpty())return t;const i=s.getPannableExtent().width(),o=.5*i,a=t.queryInterval(0,0);if(a.width()<o||!e(t.getGeometryType())){if(Number.isNaN(n))return t;const e=a.getCenter();if(Math.abs(e-n)<=o)return t;{const s=new Ps,r=Ht((n-e)/i)*i;s.setShiftCoords(r,0);const o=t.clone();return o.applyTransformation(s),o}}const h=t.getGeometryType(),m=t,l=m.getAttributeStreamRef(0),u=t.clone(),c=u.getAttributeStreamRef(0);let g=0,d=0,_=0,p=Z(h)?0:-1;const f=r.constructEmpty();let x=!1;for(let t=0,e=m.getPointCount();t<e;t++){const e=l.read(2*t);t===d&&(Z(h)?(0===p&&Number.isNaN(n)&&(x=!0),p>0&&Number.isNaN(n)&&(n=f.getCenter(),x=!1),d=m.getPathEnd(p),p++):d=m.getPointCount(),Number.isNaN(n)?_=e:(_=n,g=0));let s=e-_;Math.abs(s)>o&&(s=Ht(s/i)*i,g-=s,Math.abs(g)<.1*i&&(g=0));const r=e+g;c.write(2*t,r),x&&f.mergeCoordinate(r),_=e}return u.notifyModified(),u}(t,s,n)}clipToSpatialReference(e,s,n,i=0){return function(e,s,n,i){const r=s.getCoordinateSystemType();if(0===r){const t=new Dp;return s.queryPrecisionDescriptor(t),wg(e,t,s,n)}let o=e;2!==i&&3!==i||!s.isPannable()||(o=bg(o,s,n));const a=new Dp;if(s.queryPrecisionDescriptor(a),o=wg(o,a,s,n),0===i||o.isEmpty())return o;if(1===r){if(1===i){const e=new t;o.queryLooseEnvelope(e);const i=s.getPannableExtent(),r=.01*i.width();return i.xmin=e.xmin-r,i.xmax=e.xmax+r,(new Sm).execute(o,i,s,n)}return o}if(2===r){const t=s.getPCSHorizon();if(1===i||2===i){const e=(new Eg).execute(o,t,s,n);return e===t?e.clone():e}return o}if(3===r)return o;P("missing implementation")}(e,s,n,i)}};class Mg extends Cs{constructor(t,e,n){super(),this.m_projTrans=e,this.m_progressTracker=n,this.m_index=-1,t||s(""),this.m_inputGeoms=t}next(){const t=this.m_inputGeoms.next();return null!=t?(Ft(t),Xt(t),this.m_index=this.m_inputGeoms.getGeometryID(),Sg(t,this.m_projTrans,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}function Gg(t,e,i,r,a,h,m=!1){t||s("Geometry.Geodetic_densify.densify");let l=t.getGeometryType();if(Xt(t),t.isEmpty()||V(l))return t;const u=new kg;u.m_sr=e,u.m_gcs=e.getGCS(),u.m_transform=u.m_gcs!==e?e.getSRToGCSTransform():null,u.m_progressTracker=h;const c=rp();let g,d,_;if(u.m_gcs.querySpheroidData(c),u.m_a=c.majorSemiAxis,u.m_eSquared=c.e2,u.m_rpu=u.m_gcs.getUnit().getUnitToBaseFactor(),u.m_gcsTolerance=u.m_gcs.getTolerance(0),u.m_radTolerance=u.m_gcsTolerance*u.m_rpu,u.m_maxLength=r,u.m_maxDeviation=a,u.m_curveType=i,l===o.enumEnvelope){const e=new Tr({vd:t.getDescription()});e.addEnvelope(t,!1),g=e,l=o.enumPolygon}else if(F(l)){const e=new Wn({vd:t.getDescription()});e.addSegment(t,!0),g=e,l=o.enumPolyline}else g=t;if(4!==u.m_curveType){if(n(Z(l)),d=u.replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(g),d.isEmpty())return d;d=qg(u.m_rpu,d);let t=u.geodeticDensify(d);m||(t=(new Ag).foldInto360RangeGeodetic(t,u.m_gcs,u.m_curveType)),_=u.m_transform&&!u.m_transform.isIdentity()?(new Ag).execute(t,u.m_transform.getInverse(),h):t}else{let t;if(n(Z(l)),e.isPannable())t=Od(g,e);else{const s=e.getPCSHorizon();t=(new Eg).execute(g,s,e,h),t===s&&(t=s.clone())}if(d=t,d.isEmpty())return d;_=u.shapePreservingDensify(d)}return _}function qg(e,s){const n=new t;if(s.queryLooseEnvelope(n),n.width()*e<Math.PI)return s;let i=!1;const r=s.querySegmentIterator(),o=new l,a=new l;for(;r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment();if(o.setCoordsPoint2D(t.getStartXY()),a.setCoordsPoint2D(t.getEndXY()),o.scale(e),a.scale(e),Math.abs(o.x-a.x)>Math.PI){if(!Vg(o,a)){i=!0;break}if(Math.abs(o.x-a.x)>2*Math.PI){i=!0;break}}}if(!i)return s;const h=s.createInstance();h.reserve(s.getPointCount());const m=s.getDescription().getAttributeCount()>1,u=new l,c=new l,g=new l(0,0),d=new l(0,0),_=new qe;for(r.resetToFirstPath();r.nextPath();){let t=Number.NaN,s=0;for(;r.hasNextSegment();){const n=r.nextSegment();if(o.setCoordsPoint2D(n.getStartXY()),a.setCoordsPoint2D(n.getEndXY()),o.scale(e),a.scale(e),Number.isNaN(t)?(s=Kg(o.x,Number.NaN,s),g.setCoordsPoint2D(o)):g.setCoordsPoint2D(d),t=g.x,Vg(o,a)){if(a.x-o.x>2*Math.PI)for(;a.x-o.x>2*Math.PI;)a.x-=2*Math.PI;else if(a.x-o.x<2*-Math.PI)for(;a.x-o.x<2*-Math.PI;)a.x+=2*Math.PI;s=Kg(a.x,Number.NaN,s),d.setCoordsPoint2D(a)}else u.setCoordsPoint2D(a),sd(u),s=Kg(u.x,t,s),d.setCoords(s+u.x,u.y);if(Math.abs(d.x-a.x)<.5&&d.setCoordsPoint2D(a),m)n.queryCoord(0,_),c.setCoordsPoint2D(g),c.scale(1/e),_.setXY(c),r.isFirstSegmentInPath()?h.startPathPoint(_):h.lineToPoint(_),r.isLastSegmentInPath()&&!r.isPathClosed()&&(n.queryCoord(1,_),c.setCoordsPoint2D(d),c.scale(1/e),_.setXY(c),h.lineToPoint(_));else{r.isFirstSegmentInPath()&&h.insertPath2D(-1,null,0,0,!0);const t=h.getPathCount()-1;c.setCoordsPoint2D(g),c.scale(1/e),h.insertPoint2D(t,-1,c),r.isLastSegmentInPath()&&!r.isPathClosed()&&(c.setCoordsPoint2D(d),c.scale(1/e),h.insertPoint2D(t,-1,c))}}}return h}function Fg(t,e,s,n,i,r,o,a,h,m,u,c){const g=new l,d=new l,_=n.compare(i)>0;Zg(_,n,i,g,d);const p=Hg(t,e,s,g,d,r,o,a,h,m,null,u,c);return _&&jg(h,m,null,u),p}function Vg(t,e){return!(!Rp(t.y,z)||!Rp(e.y,z))||!(!Rp(t.y,-z)||!Rp(e.y,-z))}function Yg(t,e){return!(!Rp(t.y,z)||Rp(e.y,z))||!(!Rp(t.y,-z)||Rp(e.y,-z))}function Xg(t,e){return!(!Rp(e.y,z)||Rp(t.y,z))||!(!Rp(e.y,-z)||Rp(t.y,-z))}class kg{constructor(){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_progressTracker=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_gcsTolerance=0,this.m_radTolerance=0,this.m_maxLength=0,this.m_maxDeviation=0,this.m_curveType=0}geodeticDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),n=[],i=[],r=new fm,o=t.getDescription().getAttributeCount()>1;for(;s.nextPath();){const t=[0];for(;s.hasNextSegment();){const a=s.nextSegment(),h=a.getStartXY(),m=a.getEndXY();h.scale(this.m_rpu),m.scale(this.m_rpu);const u=new l,c=new l,g=h.compare(m)>0;Zg(g,h,m,u,c),n.length=0,i.length=0,this.m_maxLength>0?Hg(this.m_a,this.m_eSquared,this.m_curveType,u,c,this.m_maxLength,this.m_maxDeviation,this.m_radTolerance,null,null,o?i:null,n,t):Bg(),g&&jg(null,null,o?i:null,n),n[0].setCoordsPoint2D(a.getStartXY()),n.at(-1).setCoordsPoint2D(a.getEndXY());const d=1/this.m_rpu;for(let t=1,e=n.length-1;t<e;t++)n[t].scale(d);if(o){const t=Qg(g,a,r);Lg(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),a,t,i,n,e)}else Rg(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),n,e)}}return e}shapePreservingDensify(t){const e=t.createInstance(),s=t.querySegmentIterator(),n=[],i=[],r=new fm,o=t.getDescription().getAttributeCount()>1;for(;s.nextPath();)for(;s.hasNextSegment();){const t=s.nextSegment(),a=t.getStartXY(),h=t.getEndXY(),m=a.compare(h)>0,l=Qg(m,t,r);n.length=0,i.length=0,Wg(this.m_a,this.m_eSquared,this.m_rpu,l,this.m_sr,this.m_maxLength,this.m_maxDeviation,o?i:null,n),m&&jg(null,null,o?i:null,n),o?Lg(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),t,l,i,n,e):Rg(s.isFirstSegmentInPath(),s.isLastSegmentInPath()&&!s.isPathClosed(),n,e)}return e}replaceCurvesWithLinesAndProjectToGCSAsMultiPoint_(t){const e=t.hasNonLinearSegments();if((!this.m_transform||this.m_transform.isIdentity())&&(t=Od(t,this.m_gcs),!e))return t;const s=t.createInstance();s.reserveParts(t.getPointCount(),t.getPathCount());for(let e=0,n=t.getPathCount();e<n;++e){let n=new Fs;const i=t.getPathStart(e),r=t.getPathEnd(e);n.addPoints(t,i,r);const o=t.isClosedPath(e);let a=!1;if(o&&r-i===1&&t.hasNonLinearSegmentsPath(e)){const e=new qe;t.getPointByVal(i,e),n.add(e),a=!0}if(this.m_transform&&!this.m_transform.isIdentity()){if(o&&!a){const e=new qe;t.getPointByVal(i,e),n.add(e)}if(n=(new Ag).execute(n,this.m_transform,this.m_progressTracker),o&&n.getPointCount()>1){const t=n.getXY(0),e=n.getXY(n.getPointCount()-1);t.equals(e)&&n.removePoint(n.getPointCount()-1)}}n.getPointCount()>1&&(s.addPathMultiPoint(n,0,-1,!0),o&&s.closePathWithLine())}return s}}function Rg(t,e,s,n){t&&n.insertPath2D(-1,null,0,0,!0);const i=n.getPathCount()-1;n.insertPointsFromPoints(i,-1,s,0,s.length-1,!0),e&&n.insertPoint2D(i,-1,s.at(-1))}function Lg(t,e,s,n,i,r,o){o.reserve(o.getPointCount()+r.length-1);const a=new qe;if(s.queryStart(a),t?o.startPathPoint(a):o.lineToPoint(a),r.length>2){const t=n.calculateLength2D();for(let e=1;e<r.length-1;e++){const s=n.lengthToT(i[e]*t);n.queryCoord(s,a),a.setXY(r[e]),o.lineToPoint(a)}}e&&(s.queryEnd(a),o.lineToPoint(a))}function Hg(t,e,s,n,i,r,o,a,h,m,u,c,g){const d={stack:[],error:void 0,hasError:!1};try{const _=Ss(d,new Lp,!1),p=Ss(d,new Lp,!1),f=Ss(d,new Lp,!1);Zp.geodeticDistance(t,e,n.x,n.y,i.x,i.y,f,_,p,s);const x=f.val,y=_.val,P=p.val;let C=y,E=P;C<0&&(C+=2*Math.PI),E<0&&(E+=2*Math.PI),h&&(h[0]=C),m&&(m[0]=E);let S=Number.NaN,v=Number.NaN;if(null!==u){const s=Qp.q90(t,e),i=Qp.q(t,e,n.y);S=(s-i)/x,v=(s+i)/x}const I=Yg(n,i),b=Xg(n,i),w=I||b,D=function(t,e,s){return!(!ed(t,e,s)||Rp(t.y,z)||Rp(t.y,-z)||Rp(e.y,z)||Rp(e.y,-z))}(n,i,a),T=Ss(d,new te(new Lp,new Lp),!1),N=new l,A=new l,M=new l;g[0]=Kg(n.x,Number.NaN,g[0]);let G=g[0];if(x<=r)return c.push(n.clone()),g[0]=Kg(i.x,Number.NaN,g[0]),null!=u&&u.push(0),w?(I&&Jg(n,i,u,c),b&&$g(n,i,u,c)):D?td(n,i,y,S,v,u,c):o>0&&(A.setCoords(n.x-G,n.y),N.setCoords(i.x-g[0],i.y),G=Ug()),c.push(i.clone()),x;const q=1+Math.ceil(x/r),F=x/(q-1),V=new l;c.push(n.clone()),V.setCoordsPoint2D(n),A.setCoords(n.x-g[0],n.y),null!==u&&u.push(0);for(let r=1;r<q;r++){let h;if(r<q-1){const i=r*F;Zp.geodeticCoordinate(t,e,n.x,n.y,i,y,T.at(0),T.at(1),s),N.setCoords(T.at(0).val,T.at(1).val),g[0]=Kg(N.x,V.x,g[0]),M.setCoords(g[0]+N.x,N.y),h=r/(q-1)}else g[0]=Kg(i.x,Number.NaN,g[0]),N.setCoords(i.x-g[0],i.y),M.setCoordsPoint2D(i),h=1;w?(1===r&&I&&Jg(n,M,u,c),r===q-1&&b&&$g(V,i,u,c)):D?ed(V,M,a)&&(n.x<i.x?V.x>M.x&&(g[0]+=2*Math.PI,M.setCoords(g[0]+N.x,N.y)):V.x<M.x&&(g[0]-=2*Math.PI,M.setCoords(g[0]+N.x,N.y)),td(V,M,y,S,v,u,c)):o>0&&Ug(),c.push(M.clone()),null!=u&&u.push(h),V.setCoordsPoint2D(M),A.setCoordsPoint2D(N),G=g[0]}return x}catch(t){d.error=t,d.hasError=!0}finally{vs(d)}}function Bg(t,e,s,i,r,o,a,h,m,l){n(0)}function Ug(t,e,s,i,r,o,a,h,m,l,u,c,g,d,_){return n(0),0}function zg(t,e,s,n){const i=Vm(t,e,s),r=Vm(t,e,n);return Se.distance(i,r)}function Og(t,e,s,i,r,o,a,h){const m=new Array,u=T(Array,8);let c=2,g=r.getCoord2D(o);u[0][0]=g.x,u[0][1]=g.y,g=r.getCoord2D(a),u[1][0]=g.x,u[1][1]=g.y;const d=t=>{if(null!==s){const e=Up.projToGeog(s,t,u);n(e===t)}for(const t of u)t[0]*=i,t[1]*=i};d(2),m.push(Vm(t,e,new l(u[0][0],u[0][1]))),m.push(Vm(t,e,new l(u[1][0],u[1][1])));let _=Se.distance(m[0],m[1]);if(_>h)return _;let p=0;for(c=3;c<=17;){const s=1/(c-1);let i=0;for(let t=1;t<c;++t)if(1&t){const e=C(o,a,t*s);r.queryCoord2D(e,g),u[i][0]=g.x,u[i][1]=g.y,i++}d(i);let f=1;for(let s=0;s<i;++s)m.splice(f,0,Vm(t,e,new l(u[s][0],u[s][1]))),f++;f=0;let x=m[f];f++;let y=0;for(;f!==m.length;++f){const t=m[f];y+=Se.distance(x,t),x=t}if(y>h)return y;if(p=y-_,n(p>=0||Math.abs(p)<1e-14*y),p<0&&(p=0),_=y,y+p<=h)return y+p;c=2*c-1}return _+p}function Wg(t,e,s,i,o,a,h,m,u){const c=i.isCurve(),g=function(t,e){return t*Math.sqrt(1-e)}(t,e)*Math.PI*179/180;let d=a;a>0&&!(a>g)||(d=g);const _=h,p=_>0;let f=Number.NaN;p&&(f=function(t,e,s){const n=s/(2*Qm(t,e)),i=n*n;return s*(1-i*(.16666666666666666-.008333333333333333*i))}(t,e,_));const x=1===o.getCoordinateSystemType();let y=null;x||(y=o.getPECoordSys());const P=o.getTolerance(0),E=i.getStartXY(),S=i.getEndXY(),v=new l,I=new l;if(x)v.setCoordsPoint2D(E),v.scale(s),I.setCoordsPoint2D(S),I.scale(s);else{const t=[E.x,E.y,S.x,S.y];Up.projToGeog(y,2,t),v.setCoords(t[0],t[1]),v.scale(s),I.setCoords(t[2],t[3]),I.scale(s)}let b=0,w=0;const D=[],T=[],N=[];D.push(S.clone()),T.push(I.clone()),N.push(1),u.push(E.clone()),null!==m&&m.push(w);const A=o.isPannable(),M=E.clone(),G=[.5,.33333333333333337,.6666666666666666,.16666666666666669,.8333333333333333];let q=5;c||(p?(G[0]=.5,G[1]=.25,G[2]=.75,q=3):q=1),n(d>0);const F=t=>{if(t=t.clone(),null!==y){const e=[t.x,t.y];Up.projToGeog(y,1,e),t.setCoords(e[0],e[1])}return t.scale(s),t};for(;T.length>0;){const a=D.at(-1).clone();I.assign(T.at(-1));const h=N.at(-1);let g=!1,_=Number.NaN;const E=Og(t,e,y,s,i,w,h,d);let S=d>=E&&Math.abs(v.y-I.y)<.9*Math.PI;x&&S&&(S=Math.abs(v.x-I.x)<.9*Math.PI);const V=new l,Y=new l;let X=!1;if(!p&&S&&S&&(X=!0),i.calculateSubLength(w,h)<=P&&(X=!0),!X)for(let m=0;m<q;m++){const u=C(w,h,G[m]),d=new l;i.queryCoord2D(u,d);const y=F(d);if(0===m&&(_=u,V.setCoordsPoint2D(d),Y.setCoordsPoint2D(y),!S)){g=!0;break}if(n(p),x&&Math.abs(v.x-y.x)>=Math.PI){g=!0;break}let P=new l,E=new l;c?(P=l.lerp(M,a,G[m]),E=F(P)):(P=d.clone(),E=y.clone());const b=Lm(t,e,v,I,G[m]),D=b.clone();if(x?(D.x/=s,D.y/=s):(D.x/=s,D.y/=s,vg(o.getGCSToSRTransform(),[D],1,[D],null)),D.isNAN()){const s=Vm(t,e,y),n=Vm(t,e,v),i=Vm(t,e,I),{second:r}=Um(t,e,s,n,i,2,null);if(r>f){g=!0;break}}else{if(A){const t=o.getPannableExtent().width(),e=C(i.getStartX(),i.getEndX(),.5);for(;D.x<e-.5*t;)D.x+=t;for(;D.x>=e+.5*t;)D.x-=t}const s=i.getClosestCoordinateOnInterval(D,new r(w,h),-1);let n=i.getCoord2D(s);n=F(n);let a=zg(t,e,n,b);if(a>f){if(a<4*f){const s=Vm(t,e,n),i=Vm(t,e,v),r=Vm(t,e,I),{second:o}=Um(t,e,s,i,r,2,null);a=o}if(a>f){g=!0;break}}else if(c){let s=Vm(t,e,y);const n=Vm(t,e,v),i=Vm(t,e,I);let{second:r}=Um(t,e,s,n,i,3,null);if(r<=f){s=Vm(t,e,E);const{second:o}=Um(t,e,s,n,i,3,null);r=o}if(r>f){g=!0;break}}}}g?(D.push(V.clone()),T.push(Y.clone()),N.push(_)):(D.pop(),T.pop(),N.pop(),u.push(a.clone()),b+=E,null!==m&&m.push(b),M.setCoordsPoint2D(a),v.setCoordsPoint2D(I),w=h)}if(null!==m){const t=1/b;for(let e=0;e<m.length;e++)m[e]*=t}}function jg(t,e,s,n){if(n.reverse(),null!==s&&s.reverse(),t){const s=t[0],n=e[0];t[0]=n,e[0]=s}}function Zg(t,e,s,n,i){t?(n.setCoordsPoint2D(s),i.setCoordsPoint2D(e)):(n.setCoordsPoint2D(e),i.setCoordsPoint2D(s))}function Qg(t,e,s){return t?(s.create(e.getGeometryType()),e.copyTo(s.get()),s.get().reverse(),s.get()):e}function Kg(t,e,s){if(Number.isNaN(e)){for(;s-t>Math.PI;)s-=2*Math.PI;for(;t-s>Math.PI;)s+=2*Math.PI;return s}return s+t-e>Math.PI?s-=2*Math.PI:e-(s+t)>Math.PI&&(s+=2*Math.PI),s}function Jg(t,e,s,n){if(t.y>0){const i=new l;i.setCoords(e.x,z),Rp(t.x,i.x)||Rp(e.y,i.y)||(n.push(i),null!==s&&s.push(0))}else{const i=new l;i.setCoords(e.x,-z),Rp(t.x,i.x)||Rp(e.y,i.y)||(n.push(i),null!==s&&s.push(0))}}function $g(t,e,s,n){if(e.y>0){const i=new l;i.setCoords(t.x,z),Rp(e.x,i.x)||Rp(t.y,i.y)||(n.push(i),null!==s&&s.push(1))}else{const i=new l;i.setCoords(t.x,-z),Rp(e.x,i.x)||Rp(t.y,i.y)||(n.push(i),null!==s&&s.push(1))}}function td(t,e,s,n,i,r,o){if(h=kp,0===(a=s)||Math.abs(a)<=h){if(z-t.y>0){const e=new l;e.setCoords(t.x,z),o.push(e),null!==r&&r.push(n)}if(z-e.y>0){const t=new l;t.setCoords(e.x,z),o.push(t),null!==r&&r.push(n)}}else{if(z+t.y>0){const e=new l;e.setCoords(t.x,-z),o.push(e),null!==r&&r.push(i)}if(z+e.y>0){const t=new l;t.setCoords(e.x,-z),o.push(t),null!==r&&r.push(i)}}var a,h}function ed(t,e,s){return Math.abs(Math.abs(t.x-e.x)-Math.PI)<=s}function sd(t){if(t.x<-Math.PI)for(;t.x<-Math.PI;)t.x+=2*Math.PI;else if(t.x>Math.PI)for(;t.x>Math.PI;)t.x-=2*Math.PI}function nd(t,e,s,n){const i={stack:[],error:void 0,hasError:!1};try{const r=[s.x],o=[s.y-n],a=[s.x],h=[s.y+n];Om(r,o),Om(a,h);const m=Ss(i,new Lp,!1),l=Ss(i,new Lp,!1);return Zp.greatEllipticDistance(t,e,s.x,s.y,r[0],o[0],m,null,null),Zp.greatEllipticDistance(t,e,s.x,s.y,a[0],h[0],l,null,null),Math.min(m.val,l.val)}catch(t){i.error=t,i.hasError=!0}finally{vs(i)}}function id(e,s,n,i,r){const o=new t;n.queryEnvelope(o);const a=Qe(null,n,!0).total();if(s.xmin-o.xmin<=a&&o.xmax-s.xmax<=a)return n;const h=s.width();let m=0;for(;s.xmin+m*h<o.xmin;)m++;for(;s.xmin+m*h>o.xmin;)m--;const l=m*h,u=new Ps;u.setShiftCoords(-l,0);const c=n;c.applyTransformation(u);const g=new t;c.queryEnvelope(g);let d=null;if(g.xmax>s.xmax){let n=0;const i=new t;i.setCoords({env2D:s}),i.ymin-=1,i.ymax+=1;let o=c;for(;i.xmin<g.xmax;){g.xmax>i.xmax&&(o=Ud(o,e,2,!0,i.xmax));const t=ds(o,i),a=Pm(o,i,Oe(null,t,!0).total(),Number.NaN,r);null===d?d=a===o?a.clone():a:(u.setShiftCoords(-n*h,0),a.applyTransformation(u),d.add(a,!1)),n++,i.xmin=i.xmax,i.xmax=s.xmax+n*h}}else d=c;return d}class rd{constructor(t,e){this.m_basisX=new Se,this.m_basisY=new Se,this.m_normal=new Se,n(1===t.getCoordinateSystemType()),this.m_gcs=t;const s=rp();t.querySpheroidData(s),this.m_a=s.majorSemiAxis,this.m_e2=s.e2,this.m_rpu=t.getUnit().getUnitToBaseFactor(),this.m_curvCenterRad=e.mul(this.m_rpu);const i=this.m_curvCenterRad.x,r=this.m_curvCenterRad.y,o=Math.cos(i),a=Math.sin(i),h=Math.cos(r),m=Math.sin(r);this.m_cartCenter3D=function(t,e,s,n,i,r){return Ym(t,e,s,n,i,r,0)}(this.m_a,this.m_e2,o,a,h,m),this.m_normal.setCoordsPoint3D(this.m_cartCenter3D),this.m_d=this.m_cartCenter3D.length(),this.m_normal.divThis(this.m_d),Se.selectRightHandedBasisFromNormal(this.m_normal,this.m_basisX,this.m_basisY),this.m_northPolePcs=this.projectPoint(l.construct(0,.5*Math.PI/this.m_rpu)),this.m_southPolePcs=this.projectPoint(l.construct(0,.5*-Math.PI/this.m_rpu))}project(t){const n=t.getGeometryType();if(e(n)){Ft(t);const e=t;return this.projectMultiVertex(e)}s("Gnomonic.project")}unproject(n,i,r){const a=n.getGeometryType();if(e(a)){Ft(n);let e=n;const s=[];if(a===o.enumPolygon){const t=e.getPathCount();for(let n=0;n<t;n++){const t=e.calculateRingArea2D(n);s.push(t)}}return this.unprojectMultiVertex(i,e),Z(a)?(function(t,e,s){const n=t.getPannableExtent(),i=l.construct(0,0);n.centerAt(i);const r=n.width(),o=.5*r,a=new l;a.setNAN();let h=Number.NaN;for(let t=0;t<s.getPathCount();t++)for(let e=s.getPathStart(t);e<s.getPathEnd(t);e++){const i=s.getXY(e),m=Rp(i.y,n.ymax)||Rp(n.ymin,i.y);e===s.getPathStart(t)?(a.setNAN(),h=0):a.isNAN()||m||(h=hd(i.x,a.x,o,r,h)),i.x+=h,s.setXYNoCurves(e,i),m||a.setCoordsPoint2D(i)}s.getImpl().notifyModifiedFlags(2001)}(this.m_gcs,0,e),function(e,s,n,i,r){const a=i.getGeometryType(),h=s.getPannableExtent();let m=i,u=!1,c=!1;if(a===o.enumPolygon){const n=new t,i=l.construct(0,0);n.setCoords({env2D:h}),n.centerAt(i),u=function(e,s,n,i,r){const o=function(e,s){const n=new t;s.queryEnvelope(n);const i=Rp(e.ymax,n.ymax),r=Rp(e.ymin,n.ymin),o=i||r;return!!o&&(function(e,s){const n=new Tr,i=new t;for(let t=0;t<s.getPathCount();t++){s.queryPathEnvelope(t,i);let r=Rp(e.ymax,i.ymax),o=Rp(e.ymin,i.ymin);if(!r&&!o){n.addPath(s,t,!0);continue}n.insertPath2D(-1,null,0,0,!0);const a=s.getPathStart(t),h=s.getPathEnd(t),m=h-a;let u=-1;for(u=a;u<h;u++){const t=s.getXY(u);if(r=Rp(e.ymax,t.y),o=Rp(e.ymin,t.y),!r&&!o)break}let c=u,g=!1,d=Number.NaN;do{const i=s.getXY(c);r=Rp(e.ymax,i.y),o=Rp(e.ymin,i.y);const h=a+(c+1-a)%m;if(r||o){let r=l.construct(d,i.y);n.insertPoint2D(t,-1,r);const o=s.getXY(h),a=Rp(e.ymax,o.y),m=Rp(e.ymin,o.y);a||m||(r=l.construct(o.x,i.y),g?n.setXYNoCurves(n.getPointCount()-1,r):n.insertPoint2D(t,-1,r)),g=!0}else n.insertPoint2D(t,-1,i),d=i.x,g=!1;c=h}while(c!==u)}s.setEmpty(),s.add(n,!1)}(e,s),o)}(n,i),a=function(t,e,s,n,i){const r=[],o=[],a=.5*s.width();for(let h=0;h<n.getPathCount();h++){const m=n.getXY(n.getPathStart(h)),l=n.getXY(n.getPathEnd(h)-1),u=t[h]<0;if(Math.abs(m.x-l.x)>a){const t=od(u,e,s,h,n,i);r.push(t),o.push(h)}else if(!u&&n.calculateRingArea2D(h)<0){const t=ad(e,s,h,n,i);r.push(t),o.push(h)}}if(0===r.length)return!1;const h=new Tr({vd:n.getDescription()});let m=0,l=o[m];for(let t=0;t<n.getPathCount();t++)t===l?(h.add(r[m],!1),m++,m<o.length&&(l=o[m])):h.addPath(n,t,!0);return n.setEmpty(),n.add(h,!1),!0}(e,s,n,i,r);return o||a}(e,s,n,m,r);const o=function(e,s,n,i){const r=new t;n.queryEnvelope(r);const o=Qe(null,n,!0).total();if(s.xmin-r.xmin<=o&&r.xmax-s.xmax<=o)return n;const a=n.createInstance();let h=n.createInstance();const m=new t,l=n.getPathCount();for(let t=0;t<l;t++)n.queryPathEnvelope(t,m),s.xmin-m.xmin<=o&&m.xmax-s.xmax<=o?a.addPath(n,t,!0):(h.setEmpty(),h.addPath(n,t,!0),h=id(e,s,h,0,i),a.add(h,!0));return a}(s,n,m,r);o!==m&&(c=!0),m=o}else m=(new Ag).foldInto360RangeGeodetic(m,s,2);a===o.enumPolygon&&(u||c)&&(m=(new xg).execute(m,s,!1,r)),m!==i&&(i.setEmpty(),i.add(m,!1))}(s,this.m_gcs,0,e,r)):e=kd(e,this.m_gcs,0,!0,0,r),e}s("Gnomonic.unproject")}projectPoint(t){const e=t.mul(this.m_rpu),s=Vm(this.m_a,this.m_e2,e),n=this.m_normal.dotProduct(s);if(n<=0)return l.construct(Number.NaN,Number.NaN);const i=this.m_d/n,r=s.mul(i).sub(this.m_cartCenter3D),o=new l;return o.x=this.m_basisX.dotProduct(r),o.y=this.m_basisY.dotProduct(r),o}unprojectPoint(t){const e=this.m_cartCenter3D.add(this.m_basisX.mul(t.x).add(this.m_basisY.mul(t.y)));return km(this.m_a,this.m_e2,e).divide(this.m_rpu)}projectMultiVertex(t){const e=t.getImpl();let s=!0;const n=new l,i=new l;for(let t=0,r=e.getPointCount();t<r;t++)e.queryXY(t,n),n.y*this.m_rpu>.5*Math.PI?i.assign(this.m_northPolePcs):n.y*this.m_rpu<.5*-Math.PI?i.assign(this.m_southPolePcs):i.assign(this.projectPoint(n)),e.setXYNoCurves(t,i),i.isNAN()&&(s=!1);return e.notifyModifiedFlags(2001),s}unprojectMultiVertex(t,e){const s=e.getImpl(),n=t*t,i=!this.m_northPolePcs.isNAN(),r=!this.m_southPolePcs.isNAN();for(let t=0,e=s.getPointCount();t<e;t++){const e=s.getXY(t);let o=new l;i&&l.sqrDistance(e,this.m_northPolePcs)<=n?(o.setCoords(this.m_curvCenterRad.x,.5*Math.PI),o.scale(1/this.m_rpu)):r&&l.sqrDistance(e,this.m_southPolePcs)<=n?(o.setCoords(this.m_curvCenterRad.x,.5*-Math.PI),o.scale(1/this.m_rpu)):o=this.unprojectPoint(e),s.setXYNoCurves(t,o)}s.notifyModifiedFlags(2001)}}function od(e,s,n,i,r,o){const a=new Tr,h=new Tr,m=new Ps,u=r.getXY(r.getPathStart(i)),c=r.getXY(r.getPathEnd(i)-1),g=n.width(),d=.5*g,_=new t;r.queryEnvelope(_);const p=Math.ceil(_.width()/g)+1;let f,x;u.x>c.x?(f=-g,x=e?n.ymin:n.ymax):(f=g,x=e?n.ymax:n.ymin),m.setShiftCoords(f,0),a.addPath(r,i,!0),h.add(a,!1);const y=new qe;for(let t=0;t<p;t++)h.applyTransformation(m),h.getPointByVal(0,y),a.lineToPoint(y),a.addSegmentsFromPath(h,0,0,h.getSegmentCount()-1,!1);const P=a.getXY(0),C=a.getXY(a.getPointCount()-1);P.y=x,C.y=x,a.lineTo(C);const E=new l;for(E.setCoordsPoint2D(C),E.x-=.5*f;Math.abs(E.x-P.x)>d;)a.lineTo(E),E.x-=.5*f;a.lineTo(P);const S=n.getCenter().x,v=new t;a.queryEnvelope(v);let I=0;const b=v.getCenter().x;b-S>d?I=-Math.ceil((b-S-d)/g):S-b>d&&(I=Math.ceil((S-b-d)/g)),0!==I&&(m.setShiftCoords(I*g,0),a.applyTransformation(m));const w=new Vr,D=w.addGeometry(a);zd(w,D,s,0,2,!0,n.xmin),zd(w,D,s,0,2,!0,n.xmax);const T=w.getGeometry(D),N=ds(T,n);return N.inflateCoords(0,1),Pm(T,n,Oe(null,N,!0).total(),Number.NaN,o)}function ad(e,s,n,i,r){const o=s.width(),a=.5*o,h=s.getCenter().x,m=new t;i.queryPathEnvelope(n,m);let u,c=0,g=m.getCenter().x;if(g-h>a?c=-Math.ceil((g-h-a)/o):h-g>a&&(c=Math.ceil((h-g-a)/o)),0!==c){const t=new Ps;t.setShiftCoords(c*o,0),i.getImpl().applyTransformationToPath(t,n),i.queryPathEnvelope(n,m),g=m.getCenter().x}const d=new t;s.containsExclusiveEnvelope(m)?(u=!1,d.setCoords({env2D:s})):(u=!0,d.setCoords({env2D:s}),d.xmin-=o,d.xmax+=o);let _=i.createInstance();_.addPathPoint2D(null,0,!0);const p=new l;if(p.setCoords(d.xmin,d.ymin),_.insertPoint2D(0,-1,p),p.setCoords(d.xmin,d.ymax),_.insertPoint2D(0,-1,p),p.setCoords(.5*(d.xmin+d.xmax),d.ymax),_.insertPoint2D(0,-1,p),p.setCoords(d.xmax,d.ymax),_.insertPoint2D(0,-1,p),p.setCoords(d.xmax,d.ymin),_.insertPoint2D(0,-1,p),p.setCoords(.5*(d.xmin+d.xmax),d.ymin),_.insertPoint2D(0,-1,p),u){_.addPath(i,n,!0);const t=new Ps;g<h?t.setShiftCoords(o,0):t.setShiftCoords(-o,0),i.getImpl().applyTransformationToPath(t,n),_.addPath(i,n,!0);const a=new Vr,m=a.addGeometry(_);zd(a,m,e,0,2,!0,s.xmin),zd(a,m,e,0,2,!0,s.xmax),_=a.getGeometry(m);const l=ds(_,s);l.inflateCoords(0,1),_=Pm(_,s,Oe(null,l,!0).total(),Number.NaN,r)}else _.addPath(i,n,!0);return _}function hd(t,e,s,n,i){return i+t-e>s?i-=n:e-(i+t)>s&&(i+=n),i}function md(t,e,s,n,i,r){const o=e.getAttributeStreamRef(0),a=e.getPointCount();let h=!1;const m=new l;for(let t=0;t<a;++t){if(o.queryPoint2D(2*t,m),1&r&&m.y>=s){h=!0;break}if(2&r&&m.y<=-s){h=!0;break}}if(!h)return!1;let u=!1;t&&(u=e.getImpl().isClosedPathInXYPlane(0));const c=new Vr,g=c.addGeometry(e),d=c.getFirstPath(g);let _=-1,p=!0;const f=new l,x=new qe;let y=Ar;const P=ld*i/360;for(let t=c.getFirstVertex(d);t!==Ar;t=c.getNextVertex(t)){c.queryXY(t,m);let e=1&r&&m.y>=s?1:0;if(e|=2&r&&m.y<=-s?2:0,_>0&&_!==e){if(f.x!==m.x){const e=c.getPrevVertex(t);c.queryPoint(e,x);const s=c.insertVertex(d,t,x);f.x=m.x,c.setXY(s,f)}if(u){let e=y!==Ar?c.getNextVertex(y):c.getFirstVertex(d);const s=c.getPrevVertex(t);for(;e!==s;)e=c.removeVertex(e,!1);if(y!==Ar){const t=c.getXY(y),e=c.getXY(s);if(Math.abs(t.x-e.x)>P){c.queryPoint(y,x);const n=c.insertVertex(d,s,x);t.x=C(t.x,e.x,.5),c.setXY(n,t)}}}y=Ar}if(e&&(m.y=kt(n,m.y),c.setXY(t,m),!p&&_!==e))if(m.x!==f.x){c.queryPoint(t,x);const e=c.insertVertex(d,t,x);c.setXYCoords(e,f.x,m.y),y=e}else y=t;_=e,f.assign(m),p=!1}if(u){if(y!==Ar){let t=c.getNextVertex(y);for(;t!==Ar;)t=c.removeVertex(t,!1)}const t=c.getFirstVertex(d);let e=c.getLastVertex(d);const s=c.getXY(t),n=c.getXY(e);if(!s.equals(n)&&(c.queryPoint(t,x),e=c.insertVertex(d,Ar,x),Math.abs(s.x-n.x)>P)){const t=c.insertVertex(d,e,x);s.x=C(s.x,n.x,.5),c.setXY(t,s)}}return e.assignCopy(c.getGeometry(g)),!0}const ld=210;class ud{constructor(t,e,s,i,r,o,a,h,m){this.m_bAdjustedAtPoles=0,this.m_inputPoly=s,this.m_progressTracker=m,this.m_originalGeometry=t,this.m_originalSR=i,this.m_polygonRingFlags=e,this.m_pannableSR=r,this.m_poleSnappingTolerance=h,this.m_poleFlags=a,this.m_bAdjustedAtPoles=0,this.m_pannableExtent=function(t,e){const s=t.getPannableExtent();return Number.isNaN(e)||s.centerAtCoords(e,0),s}(this.m_pannableSR,o),this.m_centralLongitude=Number.isNaN(o)?this.m_pannableExtent.getCenterX():o,this.m_width360=this.m_pannableExtent.width(),this.m_degree=this.m_width360/360,this.m_GCSLargeDelta=ld*this.m_degree,n(null===this.m_originalGeometry&&null===this.m_originalSR||null!==this.m_originalGeometry&&null!==this.m_originalSR)}geonormalizeRing(t,e,s,i,r,o,a){let h=s;const m=new Wn({vd:this.m_inputPoly.getDescription()});m.addPath(this.m_inputPoly,t,!0),0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=md(!0,m,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,this.m_pannableExtent.width(),this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(h=!1));let u=-1;h&&(u=this.m_originalGeometry.getPathStart(t));const c=m.getAttributeStreamRef(0),g=m.getPointCount();let d=0,_=c.read(0),p=0;const f=3*this.m_pannableSR.getTolerance(0);let x=!1;const y=new l,C=new l;let E=!1;const S=m.hasNonLinearSegments(),v=new l;for(let t=1;t<g;++t){c.queryPoint2D(2*t,v);const e=v.x;let s=e+d;const n=s-_;if(v.x=s,Math.abs(n)>this.m_GCSLargeDelta){if(h){const e=u+t-1,s=u+(t+1<g?t:0),r=o.read(2*e),a=(o.read(2*s)-r)*i;Math.abs(n-a)>1*this.m_degree&&(h=!1)}h||(d-=kt(this.m_width360,s-_),s=e+d,++p,E=0!==d,v.x=s)}else x||os(y,C,v,f)&&(x=!0);E&&(S&&P("error in geonormalize_ring_ for curves"),c.write(2*t,s)),_=s,y.setCoordsPoint2D(C),C.setCoordsPoint2D(v)}p&&m.notifyModified();const I=m.getXY(0),b=m.getXY(g-1);if(l.distance(I,b)<f){const t=this.finalizeGeoNormalizeClosedRing(m,x,r);a.add(t,!1)}else{e<0&&(null!==this.m_originalGeometry?(n(null!==this.m_originalGeometry),e=this.m_originalGeometry.calculateRingArea2D(t)>0?1:0):e=1);const s=this.finalizeGeoNormalizeOpenedRing(e>0,m);a.add(s,!1)}}geoNormalizePolygonGeometry(e){n(this.m_originalSR&&this.m_originalGeometry||!this.m_originalGeometry&&!this.m_originalSR),n(this.m_pannableSR.isPannable());let s=null,i=Number.NaN;const r=!!this.m_originalSR&&this.m_originalSR.isPannable();r&&(s=this.m_originalGeometry.getAttributeStreamRef(0),i=this.m_width360/this.m_originalSR.getPannableExtent().width()),this.m_bAdjustedAtPoles=0;const o=new Tr({vd:this.m_inputPoly.getDescription()});for(let t=0,n=this.m_inputPoly.getPathCount();t<n;++t){const n=this.m_polygonRingFlags?this.m_polygonRingFlags[t]?1:0:-1;this.geonormalizeRing(t,n,r,i,e,s,o)}const a=this.m_pannableSR.getTolerance(0),h=this.m_pannableExtent.width()/180;Qd(o,this.m_pannableExtent,.1*a,!1);const m=t.constructEmpty();if(m.setCoords({env2D:this.m_pannableExtent}),e){let e=!0;for(let s=0;s<2;s++){e=!0;const s=t.constructEmpty();for(let t=0,n=o.getPathCount();t<n;t++)if(o.queryPathEnvelope(t,s),!(m.xmin<=s.xmin&&m.xmax>=s.xmax||s.xmin>=m.xmax||s.xmax<=m.xmin)){e=!1;break}if(e)break;m.move(.5*this.m_width360,0)}e||m.setCoords({env2D:this.m_pannableExtent})}let l=Pm(o,m,a,h,this.m_progressTracker),u=o!==l;const c=this.m_originalGeometry?this.m_originalGeometry.calculateArea2D():1,g=l.calculateArea2D();let d=0;if(g>0&&c<0)d=1;else if(g<=0&&c>0)if(0===g){if(this.m_originalSR){let t=Number.NaN;2===this.m_originalSR.getCoordinateSystemType()?t=this.m_originalSR.getPCSHorizon().calculateArea2D():1===this.m_originalSR.getCoordinateSystemType()&&(t=this.m_originalSR.getPannableExtent().getArea()),c>.99*t&&(d=-1)}}else d=-1;if(0!==d){const t=function(t,e){let s=new Tr({vd:t});s.addEnvelope(e,!1);const n=e.width()/180;return s=(new wm).execute(s,n,0,0,null),s}(l.getDescription(),m);t.add(l,!1),u=!0,l=t}return u&&(l=(new xg).execute(l,this.m_pannableSR,!1,this.m_progressTracker)),l}geoNormalizePolylineGeometry(e){n(this.m_pannableSR.isPannable());let s=null;const i=this.m_originalSR&&this.m_originalSR.isPannable();let o=1;i&&(n(this.m_originalGeometry),o=this.m_width360/this.m_originalSR.getPannableExtent().width(),s=this.m_originalGeometry.getAttributeStreamRef(0));const a=this.m_pannableExtent.width(),h=a*G()*4;let m=e,u=Number.NaN;const c=r.constructEmpty();this.m_bAdjustedAtPoles=0;let g=new Wn({vd:this.m_inputPoly.getDescription()});for(let e=0,r=this.m_inputPoly.getPathCount();e<r;++e){let r=i;const d=new Wn({vd:this.m_inputPoly.getDescription()});d.addPath(this.m_inputPoly,e,!0);const _=this.m_inputPoly.isClosedPath(e);0!==this.m_poleFlags&&(this.m_bAdjustedAtPoles|=md(_,d,this.m_pannableExtent.ymax-this.m_poleSnappingTolerance,this.m_pannableExtent.ymax,a,this.m_poleFlags)?1:0,this.m_bAdjustedAtPoles&&(r=!1));let p=-1;const f=d.getPointCount();let x=!1;r&&(p=this.m_originalGeometry.getPathStart(e),x=this.m_originalGeometry.isClosedPath(e));const y=d.getAttributeStreamRef(0);let C=0,E=y.read(0),S=0;const v=new l,I=new l;let b=!1;const w=d.hasNonLinearSegments(),D=new l;for(let t=1;t<f;++t){y.queryPoint2D(2*t,D);const e=D.x;let n=e+C;const i=n-E;if(D.x=n,Math.abs(i)>this.m_GCSLargeDelta){if(r){const e=p+t-1;let n=p;(!x||t+1<f)&&(n+=t);const a=s.read(2*e),h=(s.read(2*n)-a)*o;Math.abs(i-h)>1*this.m_degree&&(r=!1)}r||(C-=kt(this.m_width360,n-E),n=e+C,++S,b=0!==C,D.x=n)}b&&(w&&P("error in geonormalize_ring_ for curves"),y.write(2*t,n)),E=n,v.setCoordsPoint2D(I),I.setCoordsPoint2D(D)}if(S&&d.notifyModified(),m){let e=!1;if(!d.isEmpty()){const s=t.constructEmpty();if(d.queryEnvelope(s),s.width()>=a||s.ymin<=this.m_pannableExtent.ymin||s.ymax>=this.m_pannableExtent.ymax)e=!0;else{if(Number.isNaN(u)){const t=this.m_centralLongitude-.5*a;u=s.xmin,u+=Math.round((t-s.xmin)/a)*a,u>t&&(u-=a),n(u<=t),u<t&&(u+=a),n(u>=t)}let t=Math.round((u-s.xmin)/a)*a;if(s.xmin+t>u+h&&(t-=a),s.xmin+t<u-h&&(t+=a),c.mergeCoordinate(s.xmin+t),c.mergeCoordinate(s.xmax+t),e=c.width()>=a,!e){const e=new Ps;e.setShiftCoords(t,0),d.applyTransformation(e)}}}g.add(d,!1),e&&(g=(()=>{const t=new Wn({vd:g.getDescription()});for(let e=0,s=g.getPathCount();e<s;++e){const s=new Wn({vd:g.getDescription()});s.addPath(g,e,!0);const n=kd(s,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);t.add(n,!1)}return t})(),m=!1)}else{const t=kd(d,this.m_pannableSR,this.m_centralLongitude,!0,0,this.m_progressTracker);g.add(t,!1)}}if(m)return g;const d=this.m_pannableSR.getTolerance(0),_=this.m_pannableExtent.width()/180;return Qd(g,this.m_pannableExtent,.1*d,!1),Pm(g,this.m_pannableExtent,d,_,this.m_progressTracker)}finalizeGeoNormalizeOpenedRing(e,s){const i=s.getPointCount(),r=s.getXY(0),o=s.getXY(i-1);{const t=Math.abs(o.x-r.x),e=Math.round(t/this.m_width360)*this.m_width360;n(Math.abs(t-e)<this.m_pannableSR.getTolerance(0))}const a=gt(o.x-r.x),h=t.constructEmpty();s.queryLooseEnvelope(h);const m=this.m_pannableExtent.getCenterX();let u=0,c=m-this.m_width360,g=m+this.m_width360;if(a>=0){let t=Math.ceil((c-h.xmin)/this.m_width360);for(t*=this.m_width360;c>h.xmin+t;)t+=this.m_width360;for(;c<h.xmax+t;)t-=this.m_width360;for(u=t,h.width()>720&&(g=c+360*Math.ceil(h.width()/360));g<h.xmax;)g+=this.m_width360}else{let t=Math.ceil((g-h.xmax)/this.m_width360);for(t*=this.m_width360;g<h.xmax+t;)t-=this.m_width360;for(;g>h.xmin+t;)t+=this.m_width360;for(u=t,h.width()>720&&(c=g-360*Math.ceil(h.width()/360));c>h.xmin;)c-=this.m_width360}const d=Math.round(Math.abs(o.x-r.x)/this.m_width360)*this.m_width360,_=a*d,p=h.clone();p.move(u,0);const f=new l(0,0),x=new Ps;x.setShiftCoords(u,0),s.applyTransformation(x);const y=new Wn({vd:s.getDescription()});y.add(s,!1),f.assign(s.getXY(i-1));let P=0,C=y.getXY(0).x;for(;a>0?p.xmax<g:p.xmin>c;)p.move(_,0),x.xd=_,s.applyTransformation(x),C+=_,this.m_pannableExtent.xmin<=C&&this.m_pannableExtent.xmax>=C&&(P=y.getPointCount()-1),s.setXY(0,f),f.assign(s.getXY(i-1)),y.addSegmentsFromPath(s,0,0,i-1,!1);const E=new Tr({vd:y.getDescription()});E.add(y,!1);const S=y.getXY(0),v=y.getXY(y.getPointCount()-1),I=a<0?e:!e,b=E.getPointCount()-1;if(I){const t=new l(v.x,this.m_pannableExtent.ymax);E.lineTo(t);const e=new l(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymax);E.lineTo(e);const s=new l(S.x,this.m_pannableExtent.ymax);E.lineTo(s)}else{const t=new l(v.x,this.m_pannableExtent.ymin);E.lineTo(t);const e=new l(this.m_pannableExtent.getCenterX(),this.m_pannableExtent.ymin);E.lineTo(e);const s=new l(S.x,this.m_pannableExtent.ymin);E.lineTo(s)}if(E.interpolateAttributesPath(0,b,0),E.getImpl().changeRingStartPoint(P),d>this.m_width360){const t=new Tr({copy:E});x.setShiftCoords(this.m_width360,0),t.applyTransformation(x),E.add(t,!1)}return E}finalizeGeoNormalizeClosedRing(e,s,n){const i=new Tr({vd:e.getDescription()});if(i.add(e,!1),i.hasNonLinearSegments()&&(()=>{const t=i.getPointCount()-2;return i.getSegmentType(t)!==o.enumLine})()){const t=new fm,e=i.getPointCount()-2;i.getSegmentBuffer(e,t,!1),i.removePointFromPath(0,e+1),i.closeLastPathWithSegment(t.get())}else i.removePointFromPath(0,i.getPointCount()-1);const r=t.constructEmpty();i.queryLooseEnvelope(r);let a=Math.ceil((this.m_pannableExtent.xmin-r.xmin)/this.m_width360);for(a*=this.m_width360;this.m_pannableExtent.xmin>r.xmin+a;)a+=this.m_width360;for(;this.m_pannableExtent.xmin<r.xmax+a;)a-=this.m_width360;if(a+=this.m_width360,0!==a){r.move(a,0);const t=new Ps;t.setShiftCoords(a,0),i.applyTransformation(t)}if(this.m_pannableExtent.xmin<=r.xmin&&this.m_pannableExtent.xmax>=r.xmax){if(s){const t=i.calculateArea2D(),e=(new xg).execute(i,this.m_pannableSR,!0,this.m_progressTracker);if(e!==i){const s=e.calculateArea2D();gt(t)!==gt(s)&&e.reverseAllPaths(),i.assignMove(e)}}let t;if(t=new Tr(n?{copy:i}:{move:i}),n)for(;r.xmin<this.m_pannableExtent.xmax;){r.move(this.m_width360,0);const e=new Ps;e.setShiftCoords(this.m_width360,0),i.applyTransformation(e),t.add(i,!1)}return t}let h=new Tr({vd:e.getDescription()});h.add(i,!1);const m=s||r.width()>this.m_width360-10*this.m_pannableSR.getTolerance(0);for(;r.xmin<this.m_pannableExtent.xmax;){r.move(this.m_width360,0);const t=new Ps;t.setShiftCoords(this.m_width360,0),i.applyTransformation(t),h.add(i,!1)}if(m){const t=h.calculateArea2D();h.setFillRule(1),h=(new xg).execute(h,this.m_pannableSR,!0,this.m_progressTracker);const e=h.calculateArea2D();gt(t)!==gt(e)&&h.reverseAllPaths()}return h}geonormalize_ring_(t,e,s,i,r,o,a){n(0)}}function cd(t){n(0);const e=function(t){const e=new w_({},!0);return e.m_WKID=t,e}(t),s=new dd;return s.setVertProj_(e),s}function gd(t){return!1}class dd{constructor(){this.m_hashCode=0,this.m_peVertSysVal=null,this.m_verticalUnit=new K_,this.m_verticalShift=0,this.m_userVerticalWKID=0,this.m_bIsDepth=!1}getType(){return n(0),0}getID(){return n(0),0}getLatestID(){return this.m_peVertSysVal?this.m_peVertSysVal.getLatestID():0}getOldID(){return this.m_peVertSysVal?this.m_peVertSysVal.getOldID():0}getText(){return n(0),""}getTextExtended(t){return n(0),""}getText2(t){return n(0),""}getUnit(){return n(0),{}}equals(t){return n(0),!1}equalForProjection(t){return n(0),!1}getPeVertcsCopy(){return n(0),{}}getOneMeter(){return 1/this.m_verticalUnit.getUnitToBaseFactor()}getUnitToBaseFactor(){return n(0),0}isDepth(){return n(0),!1}getVerticalShift(){return n(0),0}isCustomWkid(){return!!this.m_peVertSysVal&&this.m_peVertSysVal.isCustomWkid()}getHashCode(){return this.m_hashCode}setVertProj_(t){this.m_peVertSysVal=t}getPEVerticalCoordSys(){return this.m_peVertSysVal?this.m_peVertSysVal.m_peVertcs:null}}function _d(t,e,s,n,i){if(t.equals(e))return!1;if(n){let s=1,r=0,o=1,a=1,h=0,m=1;Number.isNaN(t.m_heightMetersPerUnit)||(s=t.m_heightMetersPerUnit,r=t.m_heightZ0,o=t.m_heightSign,a=e.m_heightMetersPerUnit,h=e.m_heightZ0,m=e.m_heightSign);const l=o*m*s/a;for(let t=0;t<i;t++)n[t]=(n[t]-r)*l+h}let r=1,o=0;if(Number.isNaN(t.m_XYToRadians)||(r=t.m_XYToRadians/e.m_XYToRadians,o=t.m_PrimeMeridianDegrees-e.m_PrimeMeridianDegrees,0!==o&&(o=Za(o),o/=e.m_XYToRadians)),Array.isArray(s)){const t=s;for(let e=0;e<i;e++)t[e][0]=t[e][0]*r+o,t[e][1]=t[e][1]*r}else{const t=s;for(let e=0;e<i;e++){const s=e<<1;t[s]=t[s]*r+o,t[s+1]=t[s+1]*r}}return!0}function pd(){return{m_heightMetersPerUnit:0,m_heightSign:0,m_heightZ0:0,m_XYToRadians:0,m_PrimeMeridianDegrees:0,assign(t){this.m_heightMetersPerUnit=t.m_heightMetersPerUnit,this.m_heightSign=t.m_heightSign,this.m_heightZ0=t.m_heightZ0,this.m_XYToRadians=t.m_XYToRadians,this.m_PrimeMeridianDegrees=t.m_PrimeMeridianDegrees},equals(t){return j(this.m_heightSign,t.m_heightSign)&&j(this.m_heightMetersPerUnit,t.m_heightMetersPerUnit)&&j(this.m_heightZ0,t.m_heightZ0)&&j(this.m_XYToRadians,t.m_XYToRadians)&&j(this.m_PrimeMeridianDegrees,t.m_PrimeMeridianDegrees)},initFromGcsAndVcsPe(t,e){this.m_heightSign=1,this.m_heightMetersPerUnit=Number.NaN,this.m_heightZ0=0,this.m_XYToRadians=Number.NaN,this.m_PrimeMeridianDegrees=Number.NaN,e&&n(0),t&&(this.m_XYToRadians=t.getUnit().getUnitFactor(),this.m_PrimeMeridianDegrees=t.getPrimem().getLongitude())},initFromGcsAndVcs(t,e){const s=t?t.getPECoordSys():null,n=e?e.getPEVerticalCoordSys():null;this.initFromGcsAndVcsPe(s,n)},processUnitParams(t){Number.isNaN(this.m_heightMetersPerUnit)&&(this.m_heightMetersPerUnit=t.m_heightMetersPerUnit,this.m_heightSign=t.m_heightSign,this.m_heightZ0=t.m_heightZ0),Number.isNaN(this.m_XYToRadians)&&(this.m_XYToRadians=t.m_XYToRadians,this.m_PrimeMeridianDegrees=t.m_PrimeMeridianDegrees)}}}class fd{constructor(t){this.m_constantsLoaded=-1,this.m_isUsable=-1,this.m_inputSR=null,this.m_outputSR=null,this.m_inputSRHorz=null,this.m_outputSRHorz=null,this.m_inputVCS=null,this.m_outputVCS=null,this.m_hashCode=0,this.m_areaOfUse=new Ne,this.m_inputUnitParams=pd(),this.m_outputUnitParams=pd(),n(t),this.m_geogTran=t,this.m_vertTran=null,this.m_latestID=Hp.getCode(this.m_geogTran),this.m_latestID<0&&(this.m_latestID=0);const e=this.m_geogTran.getGeogcs1();Hp.getCode(e);const s=this.m_geogTran.getGeogcs2();Hp.getCode(s),this.initUnitParams()}getLatestId(){return this.m_latestID}getText(){return this.m_geogTran?this.m_geogTran.toString():(n(0),"")}getGeogtran(){return this.m_geogTran}getVerttran(){return null}loadConstants(t){let e=this.m_constantsLoaded;if(-1===e){if(!t){this.m_geogTran||P("vcs not impl");const e=this.m_geogTran.getParameters();null!==e[Bp.PE_PARM_ND]&&(t=0===e[Bp.PE_PARM_ND].getValue())}e=this.m_geogTran.loadConstants()?1:0,this.m_constantsLoaded=e}return 0!==e}isUsable(){let t=this.m_isUsable;return-1===t&&(this.m_geogTran?this.m_isUsable=t=this.m_geogTran?1:0:this.m_isUsable=t=this.m_vertTran?1:0),1===t}getInputSr(t){return this.updateSrs(),t?this.m_inputSR:this.m_inputSRHorz}getOutputSr(t){return this.updateSrs(),t?this.m_outputSR:this.m_outputSRHorz}getHashCode(){let t=this.m_hashCode;return 0===t&&(t=this.m_latestID>0?Yt(this.m_latestID):Ot(this.getText()),0===t&&(t=345),this.m_hashCode=t),t}isGeogtran(){return null!==this.m_geogTran}prepareOrThrow(){}getName(){return this.isGeogtran()?this.getGeogtran().getName():(f("vcs not impl"),"")}updateSrs(){if(this.m_inputSR||this.m_inputVCS)return;let t,e,s,i,r,o;if(this.m_geogTran){const n=this.m_geogTran.getGeogcs1(),a=L_(n),h=this.m_geogTran.getGeogcs2(),m=L_(h);let l=-1,u=-1;l=a.getVcsCode(),u=m.getVcsCode(),s=cp(n,null,0,1),i=cp(h,null,0,1),l>0&&u>0?(r=cd(l),o=cd(u),t={},e={}):(t=s,e=i)}else n(0);this.m_inputSR||this.m_inputVCS||(this.m_inputSR=t,this.m_outputSR=e,this.m_inputSRHorz=s,this.m_outputSRHorz=i,this.m_inputVCS=r,this.m_outputVCS=o)}initUnitParams(){if(this.m_inputUnitParams.m_heightSign=1,this.m_inputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_inputUnitParams.m_heightZ0=0,this.m_outputUnitParams.m_heightSign=1,this.m_outputUnitParams.m_heightMetersPerUnit=Number.NaN,this.m_outputUnitParams.m_heightZ0=0,this.m_inputUnitParams.m_XYToRadians=Number.NaN,this.m_inputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_outputUnitParams.m_XYToRadians=Number.NaN,this.m_outputUnitParams.m_PrimeMeridianDegrees=Number.NaN,this.m_vertTran)n(0);else if(this.m_geogTran){const t=this.m_geogTran;let e=t.getGeogcs1();this.m_inputUnitParams.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_inputUnitParams.m_PrimeMeridianDegrees=e.getPrimem().getLongitude(),e=t.getGeogcs2(),this.m_outputUnitParams.m_XYToRadians=e.getUnit().getUnitFactor(),this.m_outputUnitParams.m_PrimeMeridianDegrees=e.getPrimem().getLongitude()}}}function xd(t,e,s,n,i,r,o){let a=null;e&&(a=e.getPEVerticalCoordSys());let h=null;t&&(h=t.getPECoordSys());let m=null;n&&(m=n.getPEVerticalCoordSys());let l=null;if(s&&(l=s.getPECoordSys()),!(h||a||l||m))return!1;const u=pd();u.initFromGcsAndVcsPe(h,a);const c=pd();return c.initFromGcsAndVcsPe(l,m),_d(u,c,i,r,o)}function yd(t,e,s,n,i,r,o,a){const h=e,m=t,l=pd();l.initFromGcsAndVcsPe(m,h),a.assign(n?s.m_outputUnitParams:s.m_inputUnitParams),a.processUnitParams(l),l.processUnitParams(a),o>0&&_d(l,a,i,r,o)}function Pd(t,e,s,n,i,r,o,a,h){const m=pd(),l=pd();m.assign(s?e.m_inputUnitParams:e.m_outputUnitParams),l.assign(i?n.m_outputUnitParams:n.m_inputUnitParams),m.processUnitParams(t),l.processUnitParams(m),m.processUnitParams(l),a>0&&_d(m,l,r,o,a),h.assign(l)}function Cd(t,e,s,n,i,r,o){const a=e.getVerttran(),h=e.getGeogtran();if(o.assign(s?e.m_inputUnitParams:e.m_outputUnitParams),o.processUnitParams(t),r>0){e.prepareOrThrow();const t=s?Bp.PE_TRANSFORM_2_TO_1:Bp.PE_TRANSFORM_1_TO_2;a?p_():f_(h,r,n,i,t)}}class Ed{supportsCurves(){return!0}accelerateGeometry(t,e,s){return Sd(t,e,s)}canAccelerateGeometry(t){return vd(t)}}function Sd(t,e,s){if(!vd(t))return!1;rs(e,t,!1);let n=0;const i=t.getGeometryType();return Z(i)&&Vn(t)&&0!==s&&(n|=t.getImpl().buildQuadTreeAccelerator(s)?1:0),Z(i)&&Yn(t)&&0!==s&&(n|=t.getImpl().buildQuadTreeForPathsAccelerator(s)?1:0),n>0}function vd(t){return Vn(t)||Yn(t)}class Id extends Ed{getOperatorType(){return 8}execute(t,e,s,n){return du(t,e,s,1,n)}}class bd{getOperatorType(){return 10002}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,n){return new wd(t,e,s,n)}execute(t,e,s,n){return this.executeMany(new Es([t]),new Es([e]),s,n).next()}}class wd extends Cs{constructor(t,e,s,n){super(),this.m_progressTracker=n,this.m_index=-1,this.m_inputGeoms=t,this.m_spatialReference=s;const i=e.next();this.m_geomSubtractor=i||new Tr}next(){const e=this.m_inputGeoms.next();return e?(Xt(e),$t(e),this.m_index=this.m_inputGeoms.getGeometryID(),function(e,n,i,r){if(e.isEmpty()||n.isEmpty())return e;const a=e.getDimension(),m=n.getDimension();if(a>m)return e;const u=e.getGeometryType(),c=n.getGeometryType(),g=new t,d=new t,_=new t;e.queryEnvelope(g),n.queryEnvelope(d),_.setCoords({env2D:g}),_.mergeEnvelope2D(d);const p=Oe(i,_,!0),f=Je(p),x=new t;if(x.setCoords({env2D:g}),x.inflateCoords(f,f),!x.isIntersecting(d))return e;if(1===a&&2===m){const s=function(e,s,n,i,r){const a=new Ne;e.queryEnvelope(a);const h=new t;s.queryEnvelope(h),a.merge(h);const m=.1*a.width(),l=.1*a.height();a.inflateCoords(m,l);const u=new Tr;u.addEnvelope(a,!1);const c=u.getImpl();if(n===o.enumPolygon){const t=s.getImpl();c.add(t,!0)}else c.addEnvelope(s,!0);return new Pg(u,i,-1,r).tryFastImplementation(e)}(e,n,c,i,r);if(s)return s}if(u===o.enumPoint){let i;switch(F(c)?(i=new Wn({vd:n.getDescription()}),i.addSegment(n,!0)):i=n,c){case o.enumPolygon:return function(t,e,s){return 0===dc(e,t,s.total())?t:t.createInstance()}(e,i,p);case o.enumPolyline:return function(e,s,n){const i=e.getXY(),r=s.querySegmentIterator(),o=Je(n),a=o*o;for(;r.nextPath();)for(;r.hasNextSegment();){const s=r.nextSegment(),h=new t;if(s.queryEnvelope(h),h.inflateCoords(o,o),!h.contains(i))continue;if(s.isIntersectingPoint(i,n.total()))return e.createInstance();let m=s.getStartXY();if(l.sqrDistance(i,m)<=a)return e.createInstance();if(m=s.getEndXY(),l.sqrDistance(i,m)<=a)return e.createInstance()}return e}(e,i,p);case o.enumMultiPoint:return function(t,e,s){const n=e.getImpl().getAttributeStreamRef(0),i=e.getPointCount(),r=t.getXY(),o=Je(s),a=o*o,h=new l;for(let e=0;e<i;e++)if(n.queryPoint2D(2*e,h),l.sqrDistance(h,r)<=a)return t.createInstance();return t}(e,i,p);case o.enumEnvelope:return function(e,s,n){const i=new t;s.queryEnvelope(i),i.inflate(n.total());const r=e.getXY();return i.contains(r)?e.createInstance():e}(e,i,p);case o.enumPoint:return function(t,e,s){const n=Je(s),i=n*n,r=t.getXY(),o=e.getXY();return l.sqrDistance(r,o)<=i?t.createInstance():t}(e,i,p);default:s("invalid shape type")}}else if(u===o.enumMultiPoint)switch(c){case o.enumPolygon:return function(e,s,n){const i=new t;s.queryEnvelope(i),i.inflate(n.total());const r=e.getPointCount();let o=!1;const a=h(r,!1),m=new l;for(let t=0;t<r;t++)e.queryXY(t,m),i.contains(m)&&0!==_c(s,m,n.total())&&(o=!0,a[t]=!0);if(!o)return e;const u=e.createInstance();for(let t=0;t<r;t++)a[t]||u.addPoints(e,t,t+1);return u}(e,n,p);case o.enumEnvelope:return function(e,s,n){const i=new t;s.queryEnvelope(i),i.inflate(n.total());const r=e.getPointCount();let o=!1;const a=h(r,!1),m=new l;for(let t=0;t<r;t++)e.queryXY(t,m),i.contains(m)&&(o=!0,a[t]=!0);if(!o)return e;const u=e.createInstance();for(let t=0;t<r;t++)a[t]||u.addPoints(e,t,t+1);return u}(e,n,p);case o.enumPoint:return function(t,e,s){const n=t.getImpl().getAttributeStreamRef(0),i=t.getPointCount(),r=e.getXY();let o=!1;const a=h(i,!1),m=Je(s),u=m*m,c=new l;for(let t=0;t<i;t++)n.queryPoint2D(2*t,c),l.sqrDistance(c,r)<=u&&(o=!0,a[t]=!0);if(!o)return t;const g=t.createInstance();for(let e=0;e<i;e++)a[e]||g.addPoints(t,e,e+1);return g}(e,n,p)}const y=new t(g);return y.inflate(100*p.total()),function(e,s,n,i){if(e.isEmpty()||s.isEmpty()||e.getDimension()>s.getDimension())return $c(tg(e),e,0,"-");const r=new t;e.queryEnvelope(r);const a=new t;s.queryEnvelope(a);const h=new t;h.setCoords({env2D:r}),h.mergeEnvelope2D(a);const m=Oe(n,h,!0),l=a.clone(),u=Je(m);if(l.inflateCoords(u,u),!r.isIntersecting(l))return $c(tg(e),e,0,"-");const c=new Jc(i),g=new Vr,d=g.addGeometry(tg(e)),_=g.addGeometry(tg(s));let p=0,f=0,x=null;if(g.hasCurves()){x=new Tc;const t=g.getEnvelope2D(i);f=wc(m.total());const e=bc(m.total(),t);p=Dc(e,f),Ec(g,e,m.total(),0,x,null,i)}c.setEditShapeCrackAndCluster(g,m.add(p));const y=c.difference(d,_);null!==x&&x.stitchCurves(g,y,f,!0);const P=$c(g.getGeometry(y),e,0,"-");return Rc(P.getGeometryType())&&(P.getImpl().setIsSimple(4,m.total()),P.getGeometryType()===o.enumPolygon&&P.getImpl().updateOGCFlagsProtected()),P}(e,Pm(n,y,0,0,r),i,r)}(e,this.m_geomSubtractor,this.m_spatialReference,this.m_progressTracker)):null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class Dd{getOperatorType(){return 10001}supportsCurves(){return!0}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}executeMany(t,e,s,n=0){return new Nd(t,e,s,n)}execute(t,e,s,n){const i=new Es([t,e]),r=new Nd(i,s,n,0).next();return r||P("null output"),r}}class Td{constructor(){this.binVertexCount=0,this.geometries=[]}addPair(t){this.binVertexCount+=t.vertexCount,this.geometries.push(t)}sort(){this.geometries.sort((t,e)=>function(t,e){return l.compareZorder(t.location,e.location)?-1:t.location.equals(e.location)?0:1}(t,e))}geomCount(){return this.geometries.length}geomPairs(){return this.geometries}clear(){this.binVertexCount=0,this.geometries.length=0}getBinVertexCount(){return this.binVertexCount}}class Nd extends Cs{constructor(t,e,s,n,i=!1){super(),this.m_index=-1,this.m_currentDim=-1,this.m_bDone=!1,this.m_unionBins=[],this.m_readyGeoms=Kt(4),this.m_dimGeomCounts=h(4,0),this.m_addedGeoms=0,this.m_maxDimension=-1,this.m_bHadGeometry=h(4,!1),this.m_complexUnionGeoms=Kt(4),this.m_totalNonEmptyGeomCounters=h(4,0),this.m_progressTracker=s,this.m_bUnionAllDimensions=!!(4&n),this.m_bPreserveAllPathEnds=!!(8&n),this.m_inputGeoms=t,this.m_spatialReference=e,this.m_options=n,this.m_bIs3D=i}next(){if(this.m_bDone&&this.m_currentDim===this.m_maxDimension)return null;for(;!this.step_(););if(-1===this.m_maxDimension)return null;if(this.m_bUnionAllDimensions){if(-1===this.m_currentDim)for(let t=0;t<=this.m_maxDimension;t++)if(this.m_bHadGeometry[t]){this.m_complexUnionGeoms[t]=this.getResultGeometry(t);for(let e=t+1;e<=this.m_maxDimension;e++)this.m_complexUnionGeoms[e]=this.getResultGeometry(e),this.m_bHadGeometry[e]&&!this.m_complexUnionGeoms[e].isEmpty()&&(this.m_bIs3D?n(0):this.m_complexUnionGeoms[t]=(new bd).execute(this.m_complexUnionGeoms[t],this.m_complexUnionGeoms[e],this.m_spatialReference,this.m_progressTracker))}for(;this.m_currentDim++,(this.m_currentDim>this.m_maxDimension||this.m_currentDim<0)&&P(""),!this.m_bHadGeometry[this.m_currentDim];);if(this.m_index++,0===this.m_currentDim&&this.m_complexUnionGeoms[this.m_currentDim].getGeometryType()===o.enumPoint){const t=new Fs({vd:this.m_complexUnionGeoms[this.m_currentDim].getDescription()});return this.m_complexUnionGeoms[this.m_currentDim].isEmpty()||t.add(this.m_complexUnionGeoms[this.m_currentDim]),t}return this.m_complexUnionGeoms[this.m_currentDim]}return this.m_index=0,this.m_currentDim=this.m_maxDimension,this.getResultGeometry(this.m_maxDimension)}getGeometryID(){return this.m_index}getRank(){return 1}tock(){return this.step_()}getResultGeometry(t){return this.m_readyGeoms[t]}finishDim(t,e,s){let i=e;if(!s)return 16&this.m_options?(i=Qc([i],1,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D),i):i;if(1&this.m_options)return i;if(1===t)if(8&this.m_options||!(16&this.m_options||this.m_totalNonEmptyGeomCounters[t]>1))1===this.m_totalNonEmptyGeomCounters[t]&&(this.m_bIs3D?n(0):i=(new xg).execute(i,this.m_spatialReference,!1,this.m_progressTracker));else{i=Qc([i],1,this.m_spatialReference,this.m_progressTracker,16|this.m_options,this.m_bIs3D);const t=[0],e=i.getImpl().getIsSimple(0,t);n(this.m_bIs3D||je(e))}else this.m_bIs3D?n(0):i=(new xg).execute(i,this.m_spatialReference,!1,this.m_progressTracker);if(0===t&&i.getGeometryType()===o.enumPoint){const t=new Fs({vd:i.getDescription()});i.isEmpty()||t.add(i),i=t}return i}static getLevel(t){const e=Qt(t);let s=e>0?(Math.log(e)-Math.log(32))/Math.log(4):0;return s<0&&(s=0),Math.floor(s)}step_(){if(this.m_bDone)return!0;let t;if(this.m_inputGeoms?(t=this.m_inputGeoms.next(),null===t?(this.m_bDone=!0,this.m_inputGeoms=null):(this.checkAndThrow(t),t.isEmpty()||this.m_totalNonEmptyGeomCounters[t.getDimension()]++)):t=null,null!==t){const e=t.getDimension();this.m_bHadGeometry[e]=!0,(e>=this.m_maxDimension||this.m_bUnionAllDimensions)&&(this.addGeom(e,!1,t),e>this.m_maxDimension&&!this.m_bUnionAllDimensions&&this.removeAllBinsWithLowerDimension(e))}if(this.m_addedGeoms>0)for(let t=0;t<=this.m_maxDimension;t++){for(;this.m_dimGeomCounts[t]>1;){const e=this.collectGeometriesToUnion(t);if(null===e)break;{let s;s=1&this.m_options?Qc(e,e.length,this.m_spatialReference,this.m_progressTracker,this.m_options,this.m_bIs3D):Kc(e,e.length,this.m_spatialReference,this.m_progressTracker,8|this.m_options,this.m_bIs3D),this.addGeom(t,!0,s)}}if(this.m_bDone&&(n(this.m_dimGeomCounts[t]<=1),0!==this.m_dimGeomCounts[t])){const e=this.m_unionBins[t].entries().next().value,s=e[1].geomPairs()[0].geom,n=e[1].geomPairs()[0].bUnioned;this.m_unionBins[t].clear(),this.m_readyGeoms[t]=this.finishDim(t,s,n)}}return this.m_bDone}addGeom(e,s,n){const i={geom:null,vertexCount:-1,bUnioned:!1,location:new l};i.geom=n;const r=Qt(n);i.vertexCount=r;const o=t.constructEmpty();n.queryEnvelope(o),i.location=r>0?o.getCenter():new l(0,0);const a=Nd.getLevel(n);if(e+1>this.m_unionBins.length)for(;this.m_unionBins.length<Math.max(2,e+1);)this.m_unionBins.push(new Map);let h=null;const m=this.m_unionBins[e].get(a);m&&(h=m),null===h&&(h=new Td,this.m_unionBins[e].set(a,h)),i.bUnioned=s,h.addPair(i),this.m_dimGeomCounts[e]++,this.m_addedGeoms++,this.m_maxDimension=Math.max(this.m_maxDimension,e)}removeAllBinsWithLowerDimension(t){for(let e=0;e<t;e++)this.m_unionBins[e].clear(),this.m_addedGeoms-=this.m_dimGeomCounts[e],this.m_dimGeomCounts[e]=0}collectGeometriesToUnion(t){if(1&this.m_options&&!this.m_bDone)return null;let e=null;const s=[];for(const e of this.m_unionBins[t].keys())s.push(e);lt(s);for(let n=0;n<s.length;n++){if(-1===s[n])continue;const i=this.m_unionBins[t].get(s[n]);{const r=5e3,o=4,a=i.getBinVertexCount()>r&&i.geomCount()>=o;if(this.m_bDone||a){for(let i=0;i<n;i++){if(-1===s[i])continue;const n=this.m_unionBins[t].get(s[i]);n.sort(),this.m_dimGeomCounts[t]-=n.geomCount(),this.m_addedGeoms-=n.geomCount();for(const t of n.geomPairs())e||(e=new Array),e.push(t.geom);n.clear(),this.m_unionBins[t].delete(s[i]),s[i]=-1}i.sort(),this.m_dimGeomCounts[t]-=i.geomCount(),this.m_addedGeoms-=i.geomCount();for(const t of i.geomPairs())e||(e=new Array),e.push(t.geom);if(i.clear(),this.m_unionBins[t].delete(s[n]),s[n]=-1,!this.m_bDone)break}}}return e}checkAndThrow(t){this.m_bIs3D&&(t.getDimension()>1&&Jt(),t.hasAttribute(1)||s("Geometry must have Zs")),Xt(t)}}class Ad extends Ed{getOperatorType(){return 3}execute(t,e,s,n=null){return du(t,e,s,4,n)}}function Md(e,s,n){const i=s.getGCSSplitLines();if(null===i)return e;const o=s.getGCS(),a=o.getPannableExtent().width(),h=t.constructEmpty();e.queryLooseEnvelope(h);const m=r.constructEmpty();h.queryIntervalX(m);const l=i.querySegmentIterator();let u=null;const c=new Ps;for(;l.nextPath();)for(;l.hasNextSegment();){const t=l.nextSegment(),e=t.queryInterval(0,0),s=r.constructEmpty();s.setCoordsFromEnvelope(e);let n=0;for(;s.vmax>m.vmin;)s.move(-a),n--;for(;s.vmin<=m.vmax;){if(s.isIntersecting(m)){null===u&&(u=new Wn);const e=new pm({start:t.getStartXY(),end:t.getEndXY()});0!==n&&(c.setShiftCoords(n*a,0),e.applyTransformation(c)),u.addSegment(e,!0)}s.move(a),++n}}if(null!==u){const t=Qe(o,u,!0);return function(t,e,s,n){const i=e.getGeometryType();if(Z(i))return new Rl(n).crackAWithBMultiPath_(t,e,s);f("crack_A_with_B")}(e,u,Je(t),n)}return e}function Gd(t,e,s){let n=t.getName();return Sp(n)||(s||e>0?(n=t.toString(Bp.PE_STR_NAME_CANON|Bp.PE_STR_AUTH_NONE),n=n.toLocaleUpperCase("en-US")):n=t.toString(Bp.PE_STR_AUTH_TOP)),n}function qd(t,e=-1){if((e>1||e<-1)&&s("verbosity"),-1===e)return t.toString();{const s=0===e?Bp.PE_STR_AUTH_TOP:Bp.PE_STR_AUTH_ALL;return t.toString(s)}}function Fd(e,s,n,i){if(e.isEmpty()||1===n)return e;const r=e.getGeometryType();if(r===o.enumPoint){const t=e,i=t.getXY();return 0===Xd([i],1,s,n)||i.isNAN()?t.setEmpty():t.setXY(i),e}if(r===o.enumMultiPoint){const t=e,i=e.createInstance(),r=t.getPointCount();i.reserve(r);const o=t.getAttributeStreamRef(0),a=t.getDescription().getAttributeCount()>1,h=new qe,m=Float64Array.from(o.getArray());if(Xd(m,r,s,n)>0)for(let e=0,s=2*r;e<s;e+=2)Number.isNaN(m[e])||(a?(t.getPointByVal(e>>1,h),h.setXYCoords(m[e],m[e+1]),i.add(h)):i.addXY(m[e],m[e+1]));return i}let a=e;const h=s.getOneDegreeGCSUnit(),m=90*h,l=180*h,u=360*h,c=s.getCentralMeridian(),g=.5*h,d=t.constructEmpty();a.queryEnvelope(d);const _=s.getGCSHorizon(),p=s.getGCSHorisonIsInclusive(),f=_.getGeometryType()===o.enumEnvelope,x=t.constructEmpty();_.queryEnvelope(x);const y=s.getGCS();if(2!==n&&4!==n||(x.xmin=c-l,x.xmax=x.xmin+u),4===n){if(!(d.width()>u-h)){const e=t.constructEmpty();e.setCoords({xmin:d.xmin-h,ymin:x.ymin,xmax:d.xmax+h,ymax:x.ymax}),a=(new Sm).execute(a,e,y,i);let s=Math.floor((c-d.getCenterX())/u);for(d.move(s*u,0);d.xmin>x.xmax;)s-=1,d.move(-u,0);for(;d.xmin<x.xmin;)s+=1,d.move(u,0);if(0!==s){const t=new Ps;t.setShiftCoords(s*u,0),a.applyTransformation(t)}return a}n=2}if(2===n&&(x.xmin=c-l,x.xmax=x.xmin+u),d.ymin<-m||d.ymax>m){const e=t.constructEmpty();if(e.setCoords({xmin:d.xmin-h,ymin:-m,xmax:d.xmax+h,ymax:m}),a=(new Sm).execute(a,e,y,i),a.isEmpty())return a;a.queryEnvelope(d)}if(p&&(x.ymax<d.ymin||x.ymin>d.ymax))return a.createInstance();d.width()>u&&(a=jd(a,c-l,u,y,!0,0,!0,i),a.queryEnvelope(d));let C=(E=d.xmin,S=d.xmax,v=x.xmin,I=x.xmax,E>=v&&S<=I?0:Wd(.5*(S+E),v,I,u));var E,S,v,I;if(0!==C&&d.move(C,0),d.xmax>x.xmax||d.xmin<x.xmin){if(d.xmax>x.xmax)for(;d.xmin>=x.xmax;)d.move(-u,0),C-=u;for(;d.xmin<x.xmax-u;)d.move(u,0),C+=u}const b=rs(y,_,!1);if(0!==C){const t=new Ps;t.setShiftCoords(C,0),a.applyTransformation(t),C=0}if(p){if(f&&x.containsEnvelope(d))return a;const t=new Array(2);for(let e=0;e<2;e++){let s;if(f?s=Z(r)?Pm(a,x,b,g,i):Pm(a,x,b,0,i):(s=(new Eg).execute(a,_,y,i),s===_&&(s=s.clone())),x.xmin<=d.xmin&&x.xmax>=d.xmax)return s;if(x.xmin>=d.xmin&&x.xmax<=d.xmax)return s;if(t[e]=s,0===e){d.move(-u,0);const t=new Ps;t.setShiftCoords(-u,0),a.applyTransformation(t)}}return Z(r)?t[0].add(t[1],!1):P("intersect_with_GCS_horizon: unexpected geometry type"),t[0]}{if(x.ymax<d.ymin||x.ymin>d.ymax)return a;let t=0;for(;!a.isEmpty()&&d.xmax>x.xmin;){if(0!==t){const e=new Ps;e.setShiftCoords(t,0),a.applyTransformation(e)}if((new Ad).execute(a,_,y,i)||(a=(new bd).execute(a,_,y,i),_===a&&(a=a.clone())),0!==t){const e=new Ps;e.setShiftCoords(-t,0),a.applyTransformation(e)}t-=u,d.move(-u,0)}return a}}function Vd(t,e,s,n,i,o){const a={stack:[],error:void 0,hasError:!1};try{if(2===o)return function(t,e,s,n,i){if(Math.abs(s.x-n.x)>Math.PI)return Number.NaN;if(Math.abs(s.y)>z||Math.abs(n.y)>z)return Number.NaN;if((Math.abs(s.y)===z||Math.abs(n.y)===z)&&s.x!==n.x)return Number.NaN;const{first:o,second:a}=ne(s.x,n.x);let h=i;if(h=Fm(h,o,a),!r.construct(s.x,n.x).containsCoordinate(h))return Number.NaN;const m=Rs.constructPoint2D(s),u=Rs.constructPoint2D(n),c=Xm(1,e,m),g=Xm(1,e,u),d=c.crossProductVector(g);if(d.z.isZero())return s.y;const _=d.x.divE(d.z.negate()),p=d.y.divE(d.z.negate()),f=_.mulE(_).addE(p.mulE(p)).sqrt();if(f.isZero()||_.isZero()&&p.isZero())return s.y;const x=Math.atan2(p.value(),_.value());let y=Math.atan2(f.value()*Math.cos(x-h),1-e);const P=Vm(1,e,l.construct(h,y)),C=Se.construct(P.x,P.y,-P.z),E=d.value().dotProduct(P),S=d.value().dotProduct(C);return Math.abs(S)<Math.abs(E)&&(y=-y),y}(0,e,s,n,i);if(Math.abs(s.x-n.x)>=Math.PI||!E_(s.x,n.x,i))return Number.NaN;s.x>n.x&&(n=p(s,s=n));const h=Ss(a,new Lp,!1),m=Ss(a,new Lp,!1),u=Ss(a,new Lp,!1),c=s.clone();Zp.geodeticDistance(t,e,s.x,s.y,n.x,n.y,m,h,null,o);const g=m.val;let d=0,_=1;for(;g*(_-d)>1e-12*t;){const r=.5*(d+_);if(Zp.geodeticCoordinate(t,e,s.x,s.y,g*r,h.val,m,u,o),c.x=m.val,c.y=u.val,c.x===i)return c.y;if(E_(s.x,c.x,i))_=r;else{if(!E_(n.x,c.x,i))return Number.NaN;d=r}}return c.y}catch(t){a.error=t,a.hasError=!0}finally{vs(a)}}function Yd(t,e,s,n){for(let i=0,r=0;i<n;i++,r+=2)e[s+i].x=t[r],e[s+i].y=t[r+1]}function Xd(e,s,n,i){if(0===s||1===i)return s;const r=function(t,e){let s;if(Array.isArray(t)){const n=t;s=new Float64Array(2*e);for(let t=0,i=0;t<e;t++,i+=2)s[i]=n[t].x,s[i+1]=n[t].y}else s=t;return s}(e,s);if(2===i){const t=n.getPannableExtentInGCS();let i=s;for(let e=0,n=2*s;e<n;e+=2)(r[e+1]>t.ymax||r[e+1]<t.ymin)&&(r[e]=Number.NaN,i--);return i?(Zd(r,s,t.xmin,t.width(),!0),e!==r&&Yd(r,e,0,s),i):0}const a=n.getOneDegreeGCSUnit(),h=90*a,m=180*a,u=360*a;let c=s;for(let t=0,e=2*s;t<e;t+=2)(r[t+1]>h||r[t+1]<-h)&&(r[t]=Number.NaN,c--);if(!c)return 0;const g=t.constructEmpty();g.setFromPoints(r,s);const d=n.getGCSHorizon(),_=n.getGCSHorisonIsInclusive(),p=d.getGeometryType()===o.enumEnvelope,f=t.constructEmpty();if(d.queryEnvelope(f),_&&(f.ymax<g.ymin||f.ymin>g.ymax))return 0;if(_)if(Zd(r,s,f.getCenterX()-m,u,!0),c=s,p)for(let t=0,e=2*s;t<e;t+=2)f.containsCoords(r[t],r[t+1])||(r[t]=Number.NaN,c--);else{const t=rs(n.getGCS(),d,!1),e=new l;for(let n=0,i=2*s;n<i;n+=2)e.setCoords(r[n],r[n+1]),0!==_c(d,e,t)||(r[n]=Number.NaN,c--)}else{Zd(r,s,-m,u,!0),c=s;const t=rs(n.getGCS(),d,!1),e=new l;for(let n=0,i=2*s;n<i;n+=2){e.setCoords(r[n],r[n+1]),e.isNAN()&&c--;const s=Wd(e.x,f.xmin,f.xmax,u);e.x+=s,0!==_c(d,e,t)&&(r[n]=Number.NaN,c--)}}return c>0&&Array.isArray(e)&&Yd(r,e,0,s),c}function kd(t,e,n,i,r,o){if(e.isPannable()||s("fold_into_360_degree_range"),t.isEmpty())return t;let a,h;if(2===e.getCoordinateSystemType()){const t=e.getPannableExtent();h=t.xmin,a=t.width()}else{const t=e.getOneDegreeGCSUnit();a=360*t,h=n-180*t}return jd(t,h,a,e,i,r,!0,o)}function Rd(t,e,s,n){let i,r;if(2===s.getCoordinateSystemType()){const t=s.getPannableExtent();i=t.xmin,r=t.width()}else{const t=s.getOneDegreeGCSUnit();r=360*t,i=n-180*t}Zd(t,e,i,r)}function Ld(t,e){const s=e.width();let n=Pt(t-e.vmin,s);return n<0&&(n+=s),e.snapClip(n+e.vmin)}function Hd(t,e,s){return t>e.xmax&&t-e.xmax<s?e.xmax:t<e.xmin&&e.xmin-t<s?e.xmin:t}function Bd(t,e,s){if(t[0]<e.vmin||t[0]>e.vmax||s&&t[0]===e.vmax){const s=e.width();return t[0]+=Math.ceil((e.vmin-t[0])/s)*s,t[0]=e.snapClip(t[0]),!0}return!1}function Ud(t,e,s,n,i){const r=new Vr,o=r.addGeometry(t);return zd(r,o,e,rs(e,t,!1),s,n,i),r.getGeometry(o)}function zd(t,e,s,i,o,a,m){const u={stack:[],error:void 0,hasError:!1};try{n(ap()),s.isPannable()||K("insert_geodetic_points");const c=s.getPannableExtent(),g=s.getGCS(),d=rp();g.querySpheroidData(d);const _=g.getUnit().getUnitToBaseFactor(),p=d.majorSemiAxis,f=d.e2;let x=0;const y=new r;c.queryIntervalX(y);let P=null;const C=h(4,Number.NaN);2===s.getCoordinateSystemType()?(P=s.getPECoordSys(),a?(C[0]=Ld(m,y),C[1]=c.getCenterY(),Up.projToGeog(P,1,C),x=C[0]*_):(C[0]=c.getCenterX(),C[1]=m,Up.projToGeog(P,1,C),x=C[1]*_)):x=m*_,a||0===x||2===o||K("insert_geodetic_points: 1");const E=Ss(u,new Lp,!1),S=new l,v=new l,I=new l,b=new l,w=new l,D=new l;for(let n=t.getFirstPath(e);n!==Ar;n=t.getNextPath(n)){const e=t.getFirstVertex(n);t.queryXY(e,I);let r=!1;const h=t.getNextVertex(e);for(let e=h;e!==Ar;e=t.getNextVertex(e)){if(e===h){if(r)break;r=!0}if(t.queryXY(e,b),a&&(i<m-I.x&&b.x-m>i||i<m-b.x&&I.x-m>i)||!a&&(0!==m||i<-I.y&&b.y>i||i<-b.y&&I.y>i))do{if(Math.abs(I.x-b.x)>=.5*y.width())break;2===s.getCoordinateSystemType()?(C[0]=Ld(I.x,y),C[1]=I.y,C[2]=Ld(b.x,y),C[3]=b.y,h_(P,2,C,0),w.x=C[0]*_,w.y=C[1]*_,D.y=C[3]*_):(w.x=I.x*_,w.y=I.y*_,D.y=b.y*_),D.x=(b.x-I.x)*Math.PI*2/y.width()+w.x;let n=0;const i=T(l,2);if(a){if(v.x=x,v.y=Vd(p,f,w,D,x,o),Number.isNaN(v.y))break;i[0]=v,n=1}else if(2===o){const t=[0,0];if(n=zm(0,f,w,D,x,t),!n)break;i[0].x=t[0],i[0].y=x,2===n&&(i[1].x=t[1],i[1].y=x)}else{if(v.x=S_(p,f,w,D,o),Number.isNaN(v.x))break;v.y=0,i[0]=v,n=1}let r=-1;for(let h=0;h<n;h++){Zp.geodeticDistance(p,f,w.x,w.y,D.x,D.y,E,null,null,o);const n=E.val;Zp.geodeticDistance(p,f,w.x,w.y,i[h].x,i[h].y,E,null,null,o);const l=E.val;2===s.getCoordinateSystemType()?(C[0]=i[h].x/_,C[1]=i[h].y/_,Up.geogToProj(P,1,C),a?(S.y=C[1],S.x=m):(S.x=v_(C[0],I.x,b.x,y),S.y=m)):a?(S.x=m,S.y=i[h].y/_):(S.x=v_(i[h].x/_,I.x,b.x,y),S.y=m);const u=n>0?A(l/n,0,1):.5;if(0===u||1===u)continue;if(r>u)continue;const c=t.getPrevVertex(e);t.splitSegment(c,[u],1);const g=t.getNextVertex(c);t.setXYCoords(g,S.x,S.y),r=u}}while(0);I.setCoordsPoint2D(b)}}}catch(t){u.error=t,u.hasError=!0}finally{vs(u)}}function Od(e,s){n(s.isPannable());const i=s.getPannableExtent();if(e.getGeometryType()===o.enumPoint){const t=e.getY();return i.ymin<=t&&t<=i.ymax?e:e.createInstance()}const r=t.constructEmpty();e.queryEnvelope(r);const a=t.constructEmpty();a.setCoords({env2D:i}),a.xmin=r.xmin,a.xmax=r.xmax,a.inflateCoords(.01*a.height(),0);const h=Ze(s,r,!1);let m;return m=a.containsEnvelope(r)?e:Pm(e,a,h,0,null),m}function Wd(t,e,s,n){return Ht((.5*(s+e)-t)/n)*n}function jd(e,s,n,i,a,h,m,l){const u=e.getGeometryType(),c=r.constructEmpty();c.setCoords(s,s+n);const g=[0];if(u===o.enumPoint){const t=e;if(g[0]=t.getX(),Bd(g,c,m)){const t=a?e:e.clone();return t.setX(g[0]),t}return e}const d=t.constructEmpty();if(e.queryEnvelope(d),d.isEmpty())return e;if(u===o.enumMultiPoint){const t=a?e:e.clone(),s=t.getImpl(),n=s.getAttributeStreamRef(0),i=2*s.getPointCount();let r=!1;for(let t=0;t<i;t+=2)g[0]=n.read(t),Bd(g,c,m)&&(n.write(t,g[0]),r=!0);return r&&s.notifyModifiedFlags(2001),t}const _=r.constructEmpty();if(d.queryIntervalX(_),c.contains(_))return c.vmax,_.vmax,e;const p=t.constructEmpty();if(p.setCoords({env2D:d}),0===_.width()){let t=_.vmin;t+=Math.ceil((c.vmin-t)/n)*n,t=c.snapClip(t);const s=a?e:e.clone();return s.setAttributeBasic(0,0,t),s}if(u===o.enumEnvelope){const t=a?e:e.clone();return d.intersect(p),t.setEnvelope(d),t}const f=.1*Math.max(d.height(),d.width())*1;p.inflateCoords(0,f);let x=e;const y=i.getTolerance(0),P=new Ps;for(;;){const t=Math.floor((_.vmin-s)/n),e=Math.ceil((_.vmax-s)/n);if(!(e-t>3))break;{const r=Math.floor(.5*(e+t));p.xmin=d.xmin-f,p.xmax=s+n*r;const a=Pm(x,p,y,h,l);p.xmin=p.xmax,p.xmax=d.xmax+f;const m=Pm(x,p,y,h,l);P.setShiftCoords((r-e)*n,0),m.applyTransformation(P),u===o.enumPolygon?x=(new Dd).execute(a,m,i,l):(x=a,x.add(m,!1)),x.queryEnvelope(d),d.queryIntervalX(_)}}p.xmin=s,p.xmax=s+n;const C=t.constructEmpty();C.setCoords({env2D:p}),C.inflateCoords(y,0);const E=Math.floor((d.xmin-p.xmin)/n)*n;let S;E?(p.move(E,0),P.setShiftCoords(-E,0)):P.setIdentity(),S=u===o.enumPolyline?new Wn({vd:x.getDescription()}):new Tr({vd:x.getDescription()});const v=t.constructEmpty(),I=t.constructEmpty();for(;d.xmax>p.xmin;){const t=Pm(x,p,y,0,l);t.queryEnvelope(I);let e=!1;e=u===o.enumPolyline?!t.isEmpty()&&(I.width()>y||I.height()>y):!t.isEmpty()&&(u!==o.enumPolygon||I.width()>y),e&&(t.applyTransformation(P),t.queryEnvelope(I),S.queryEnvelope(v),v.inflateCoords(y,y),v.isIntersecting(I)&&u===o.enumPolygon?S=(new Dd).execute(S,t,i,l):S.add(t,!1)),p.move(n,0),P.shiftCoords(-n,0)}return S}function Zd(t,e,s,n,i=!0){const o=new r;o.setCoords(s,s+n);const a=[0];if(Array.isArray(t)){const s=t;for(let t=0;t<e;t++)o.containsRightExclusive(s[t].x)||(a[0]=s[t].x,Bd(a,o,i),s[t].x=a[0])}else{const s=t;for(let t=0;t<e;t++){const e=t<<1;o.containsRightExclusive(s[e])||(a[0]=s[e],Bd(a,o,i),s[e]=a[0])}}}function Qd(s,i,r,a=!0){if(s.isEmpty())return;const h=s.getGeometryType();if(!a||h!==o.enumPolygon)if(e(h)){let t=!1;if(Z(h)&&s.hasNonLinearSegments()){const e=s.getImpl(),o=e.getAttributeStreamRef(0),a=e.getSegmentFlagsStreamRef();n(null!==a);for(let s=0,n=e.getPathCount();s<n;s++){let n=!0;const h=e.isClosedPath(s),m=e.getPathEnd(s);h&&e.getPathSize(s)>0&&(n=1==(31&a.read(m-1)));for(let h=e.getPathStart(s);h<m;h++)if(1==(31&a.read(h))){if(n){const e=o.read(2*h),s=Hd(e,i,r);s!==e&&(t=!0,o.write(2*h,s))}n=!0}else n=!1}}else{const e=s.getImpl(),n=e.getAttributeStreamRef(0);for(let s=0,o=e.getPointCount();s<o;s++){const e=n.read(2*s),o=Hd(e,i,r);o!==e&&(t=!0,n.write(2*s,o))}}t&&s.getImpl().notifyModifiedFlags(2001)}else if(h===o.enumEnvelope){const e=s,n=t.constructEmpty();e.queryEnvelope(n),n.xmin=Hd(n.xmin,i,r),n.xmax=Hd(n.xmax,i,r),e.setEnvelope(n)}else if(h===o.enumPoint){const t=s;t.setX(Hd(t.getX(),i,r))}else P("")}function Kd(t,e,s){const n=new l;return n.x=Hd(t.x,e,s),n.y=t.y,n}function Jd(e,s,i,r){const a=e.getGeometryType();n(a===o.enumPolygon||a===o.enumPolyline||a===o.enumMultiPoint);const h=s.getCoordinateSystemType();if(2===h){let n=e;if(0===i){const i=function(e,s){if(s.isEmpty())return 0;const n=e.getPECoordSys();if(n.getProjection().getCode()===Bp.PE_PRJ_AZIMUTHAL_EQUIDISTANT){const i=rp();e.querySpheroidData(i);const r=n.getParameters();if(null===r[Bp.PE_PARM_LAM0])return 0;if(null===r[Bp.PE_PARM_PHI0])return 0;const o=[r[Bp.PE_PARM_LAM0].getValue(),r[Bp.PE_PARM_PHI0].getValue()];Up.geogToProj(n,1,o);const a=new l(o[0],o[1]),h=t.constructEmpty();s.queryEnvelope(h);const m=T(l,4);h.queryCorners(m);let u=0;const c=e.getOneMeter();let g=Math.max(i.majorSemiAxis,i.minorSemiAxis)*Math.PI,d=Math.min(i.majorSemiAxis,i.minorSemiAxis)*Math.PI;d-=g/180,g*=c,d*=c;for(let t=0;t<4;t++){const e=l.distance(m[t],a);if(e>g)u++;else if(e>d)return-1}if(0===u)return 1;if(4===u){const e=t.constructEmpty();return e.setCoords({center:a,width:g,height:g}),h.isIntersectingNe(e)?-1:0}return-1}return-1}(s,e);if(0===i)return e.createInstance();if(1===i)return e;const a=s.getPCSHorizon(),h=a.getGeometryType(),m=s.getDefaultPrecisionSR();if(h===o.enumEnvelope){const i=t.constructEmpty();a.queryEnvelope(i),n=Pm(e,i,Ze(m,i,!1),5e4*s.getOneMeterPCSUnit(),r)}else(new Id).execute(a,e,m,r)||(n=(new Eg).execute(n,a,m,r),n===a&&(n=n.clone()))}else if(s.isPannable()){const e=t.constructEmpty();n.queryEnvelope(e);const h=s.getPannableExtent();h.containsEnvelope(e)||(Qd(n,h,s.getTolerance(0)),2!==i&&4!==i||(n=Od(n,s)),4!==i?n=kd(n,s,0,!0,1e5*s.getOneMeterPCSUnit(),r):a===o.enumPolygon&&e.width()>2*h.width()&&(n=jd(n,-2*h.width(),2*h.width(),s,!0,0,!0,r)))}return n}if(n(1===h),a===o.enumMultiPoint)return Qd(e,s.getPannableExtent(),s.getTolerance(0)),e;{const n=t.constructEmpty();e.queryEnvelope(n);let i=e;const h=s.getPannableExtent();if(n.ymin<h.ymin||n.ymax>h.ymax){const e=Math.max(1,n.calculateToleranceFromEnvelope()),o=new t(n.xmin-e,h.ymin,n.xmax+e,h.ymax);if(i=(new Sm).execute(i,o,s,r),i.isEmpty())return i}return a===o.enumPolygon&&n.width()>2*h.width()&&(i=jd(i,-2*h.width(),2*h.width(),s,!0,0,!0,r)),i}}function $d(t,e){const s=e.getPointCount();if(!s)return;const n=e.getImpl(),i=n.getAttributeStreamRef(0),r=t;Up.geogToProj(r,s,i.getArray()),n.notifyModifiedFlags(2001)}function t_(t,e,s,n){if(!s)return;const i=t.getPECoordSys();if(1===s){const s=[e[0].x,e[0].y];if(Up.geogToProj(i,1,s),n){const{first:n,second:i}=t.m_peCoordSysVal.getGeogToProjFactors();s[0]=n*(e[0].x-t.getCentralMeridian())+i}return void e[0].setCoords(s[0],s[1])}const r=t.isPannable(),o=r?t.getPannableExtent().width():0,a=179*o/360;let h=0;r&&(h=t.getCentralMeridian());const m=new Float64Array(512);for(let l=0;l<s;){for(let t=l;t<s&&e[t].isNAN();++t)l++;let u=Math.min(256,s-l);if(u>0){for(let t=1,s=l+1;t<u;++t,++s)if(e[s].isNAN()){u=t;break}for(let t=0;t<u;++t){const s=t<<1;m[s]=e[l+t].x,m[s+1]=e[l+t].y}if(Up.geogToProj(i,u,m),n){const{first:s,second:n}=t.m_peCoordSysVal.getGeogToProjFactors();for(let t=0;t<u;++t)m[t<<1]=s*(e[l+t].x-h)+n}if(r)for(let t=0,s=l;t<u;t++,s++){const n=t<<1,i=m[n],r=gt(i),l=e[s].x-h;r*gt(l)<0&&Math.abs(i)>a&&(m[n]-=r*o)}Yd(m,e,l,u),l+=u}}}function e_(t,e,s,n){const i=t.getSRToGCSTransform();return(new Ag).transform(i,e,s,n,!1)}function s_(e,s,n,i){const r=new Fs({vd:s.getDescription()});let o;r.addPoints(s,0,-1),o=(new Ag).execute(r,e,i);const a=s.getPointCount();if(n.setEmpty(),e.getInputSR().isPannable()){if(a!==o.getPointCount())return!1;const i=new t;s.queryEnvelope(i);const r=new t;o.queryEnvelope(r);const h=i.width(),m=r.width();if(0!==h&&0!==m){const t=m/h,s=e.getOutputSR().getPannableExtent().width()/e.getInputSR().getPannableExtent().width();if(Math.abs(t/s-1)>1e-10)return!1}else if(0!==h||0!==m)return!1;n.add(s,!1);for(let t=0;t<a;t++){const e=o.getXY(t);n.setXY(t,e)}return!0}return!1}function n_(t,e,s){n(!s||t.isPannable());const i=e.getPointCount();if(!i)return;const r=e.getImpl(),o=r.getAttributeStreamRef(0),a=t.getPECoordSys();let h=0;const m=o.readRange(0,2*i);let l=()=>{Up.geogToProj(a,i,m)};const u=t.isPannable()&&!s,c=u?t.getPannableExtent().width():0,g=179*c/360;if(t.isPannable()&&(h=t.getCentralMeridian(),s)){const e=t.m_peCoordSysVal.getGeogToProjFactors(),s=e.first,n=e.second;l=()=>{Up.geogToProj(a,i,m);for(let t=0;t<i;t++){const e=t<<1,i=o.read(e),r=s*(i-h)+n;m[e]=r}}}if(l(),u)for(let t=0;t<i;t++){const e=t<<1,s=m[e],n=gt(s),i=o.read(e)-h;n*gt(i)<0&&Math.abs(s)>g&&(m[e]+=-n*c)}o.writeRangeFromArray(0,2*i,m,!0,1),r.notifyModifiedFlags(2001)}function i_(t,e,s){switch(e.getGeometryType()){case o.enumLine:return void function(t,e,s){const n=[e.getStartXY(),e.getEndXY()];t_(t,n,2,s),e.setStartXY(n[0]),e.setEndXY(n[1]),e.normalizeAfterEndpointChange()}(t,e,s);case o.enumBezier:return void function(t,e,s){const n=T(l,4);e.queryControlPoints(n),y_(t,n,4,s),e.setControlPoints(n)}(t,e,s);case o.enumEllipticArc:return void function(t,e,s){if(0===e.projectionBehavior())!function(t,e,s){C_(!0,t,0,e,s)}(t,e,s);else{const n=e.isClosed()&&e.isMajor(),i=[e.getStartXY(),n?e.getCenter():e.getEndXY()],r=[i[0].clone(),i[1].clone()];y_(t,r,2,s);const o=new Ps;o.initializeFromTwoPointsArray(i,r),e.applyTransformation(o);const a=n?0:1;e.setCoordsForIntersector(r[0],r[a],!1)}}(t,e,s);case o.enumBezier2:case o.enumRationalBezier2:return void n(0);default:P("")}}function r_(t,e,s){if(!e.hasNonLinearSegments())return void n_(t,e,s);if(n(!s||t.isPannable()),e.isEmpty())return;const i=t.getPECoordSys(),r=t.isPannable(),o=r?t.getPannableExtent().width():0,a=179*o/360;let h=0;r&&(h=t.getCentralMeridian());const m=e.createInstance();m.reserveParts(e.getPointCount(),e.getPathCount());const u=e.getImpl(),c=new fm;for(let n=0,g=e.getPathCount();n<g;++n)if(u.hasNonLinearSegmentsPath(n)){let e=!0,i=-1;const r=u.getPathStart(n),o=r+u.getSegmentCountPath(n);u.isClosedPath(n)&&(i=o-1);const a=new l;for(let n=r;n<o;++n){if(u.getSegmentBuffer(n,c,!1),i_(t,c.get(),s),e||c.get().getStartXY().equals(a)||c.get().moveTo(a),n!==i)m.addSegment(c.get(),e);else{if(e){const t=new qe;c.get().queryStart(t),m.startPathPoint(t)}m.closeLastPathWithSegment(c.get())}a.assign(c.get().getEndXY()),e=!1}}else{const t=1024;let s,l=u.getPathSize(n),c=Math.min(l,t);m.insertPath(-1,e,n,!0);const g=u.getAttributeStreamRef(0),d=m.getAttributeStreamRef(0);for(let e=u.getPathStart(n),m=u.getPathEnd(n);e<m;){if(s=g.readRange(e,c),Up.geogToProj(i,c,s),r)for(let t=0;t<c;t++){const e=t<<1,n=s[e],i=gt(n),r=g.read(2*(0+t))-h;i*gt(r)<0&&Math.abs(n)>a&&(s[e]+=-i*o)}d.writeRangeFromArray(e,c,s,!0,1),e+=c,l-=c,c=Math.min(l,t)}}e.assignMove(m)}function o_(t,e,s){let n=s.getPointCount();if(!n)return;const i=s.getImpl(),r=i.getAttributeStreamRef(0);let o=Math.min(n,1e3),a=0;const h=t.getPECoordSys();Number.isNaN(e)&&(e=0);const m=t.isPannable(),l=t.getOneDegreeGCSUnit(),u=360*l,c=179*l;let g;for(;n;){if(g=r.readRange(2*a,2*o),h_(h,o,g,e),m)for(let t=0;t<o;t++){const s=t<<1,n=g[s]-e,i=gt(n),o=r.read(2*(a+t));i*gt(o)<0&&Math.abs(n)>c&&(g[s]+=-i*u)}r.writeRangeFromArray(2*a,2*o,g,!0,1),a+=o,n-=o,o=Math.min(n,1e3)}i.notifyModifiedFlags(2001)}function a_(t,e,s){switch(s.getGeometryType()){case o.enumLine:return void function(t,e,s){const n=[s.getStartXY(),s.getEndXY()];l_(t,e,n,2),s.setStartXY(n[0]),s.setEndXY(n[1]),s.normalizeAfterEndpointChange()}(t,e,s);case o.enumBezier:return void function(t,e,s){const n=T(l,4);s.queryControlPoints(n),P_(t,e,n,4),s.setControlPoints(n)}(t,e,s);case o.enumEllipticArc:return void function(t,e,s){if(0===s.projectionBehavior())!function(t,e,s){C_(!1,t,e,s,!1)}(t,e,s);else{const n=s.isClosed()&&s.isMajor(),i=[s.getStartXY(),n?s.getCenter():s.getEndXY()],r=[i[0].clone(),i[1].clone()];P_(t,e,r,2);const o=new Ps;o.initializeFromTwoPointsArray(i,r),s.applyTransformation(o);const a=n?0:1;s.setCoordsForIntersector(r[0],r[a],!1)}}(t,e,s);case o.enumBezier2:case o.enumRationalBezier2:return void n(0);default:P("")}}function h_(t,e,s,i){const r=Up.projToGeogCenter(t,e,s,i);for(let t=0;t<e;++t){const e=t<<1;n(Number.isFinite(s[e]+s[e+1]))}return r}function m_(t,e,s){if(!s.hasNonLinearSegments())return void o_(t,e,s);if(s.isEmpty())return;const n=t.getPECoordSys();Number.isNaN(e)&&(e=0);const i=t.isPannable(),r=t.getOneDegreeGCSUnit(),o=360*r,a=179*r,h=s.createInstance();h.reserveParts(s.getPointCount(),s.getPathCount());const m=s.getImpl(),u=new fm;for(let r=0,c=s.getPathCount();r<c;++r)if(m.hasNonLinearSegmentsPath(r)){let s=!0,n=-1;const i=m.getPathStart(r),o=i+m.getSegmentCountPath(r);m.isClosedPath(r)&&(n=o-1);const a=new l;for(let r=i;r<o;++r){if(m.getSegmentBuffer(r,u,!1),a_(t,e,u.get()),s||u.get().getStartXY().equals(a)||u.get().moveTo(a),r!==n)h.addSegment(u.get(),s);else{if(s){const t=new qe;u.get().queryStart(t),h.startPathPoint(t)}h.closeLastPathWithSegment(u.get())}a.assign(u.get().getEndXY()),s=!1}}else{const t=1e3;let l,u=m.getPathSize(r),c=Math.min(u,t);h.insertPath(-1,s,r,!0);const g=m.getAttributeStreamRef(0),d=h.getAttributeStreamRef(0);for(let s=m.getPathStart(r),h=m.getPathEnd(r);s<h;){if(l=g.readRange(2*s,2*c),h_(n,c,l,e),i)for(let t=0;t<c;t++){const n=t<<1,i=l[n]-e,r=gt(i),h=g.read(2*s);r*gt(h)<0&&Math.abs(i)>a&&(l[n]+=-r*o)}d.writeRangeFromArray(2*s,2*c,l,!0,1),s+=c,u-=c,c=Math.min(u,t)}}s.assignMove(h)}function l_(t,e,s,n){const i=t.getPECoordSys();Number.isNaN(e)&&(e=0);const r=t.isPannable(),o=t.getOneDegreeGCSUnit(),a=360*o,h=179*o,m=new Float64Array(512);for(let t=0;t<n;){for(let e=t;e<n&&s[e].isNAN();++e)t++;let o=Math.min(256,n-t);if(o>0){for(let e=1,n=t+1;e<o;++e,++n)if(s[n].isNAN()){o=e;break}for(let e=0;e<o;e++){const n=e<<1;m[n]=s[t+e].x,m[n+1]=s[t+e].y}if(h_(i,o,m,e),r)for(let n=0,i=t;n<o;++n,++i){const t=n<<1,r=s[i].x,o=m[t]-e,l=gt(o);l*gt(r)<0&&Math.abs(o)>h&&(m[t]-=l*a)}for(let e=0;e<o;e++){const n=e<<1;s[t+e].x=m[n],s[t+e].y=m[n+1]}t+=o}}}function u_(t,e,s,i){n(0)}function c_(t,e,s){let n=e.getPointCount();if(!n)return!1;const i=e.getImpl(),r=i.getAttributeStreamRef(0);let o=null;const a=t.getInputSR(),m=t.getOutputSR();a.getVCS(),m.getVCS();const l=a.getOneDegreeGCSUnit(),u=m.getOneDegreeGCSUnit(),c=t.isVertical();c&&e.hasAttribute(1)&&(o=i.getAttributeStreamRef(1));const g=t.getDatumTransformation(),d=!!g&&1===g.getType();if(d||null===o||(u_(o.getArray()),o=null),!g||0===g.count()){const t=a.getGcsUnitFactor()/m.getGcsUnitFactor(),e=(a.getPrimeMeridian()-m.getPrimeMeridian())*u,s=-90*l,o=90*l;let h=0;const c=r.getArray(),g=[0];for(let t=1,e=2*n;t<e;)g[0]=c[t],h|=se(g,s,o)?1:0,c[t]=g[0],t+=2;if(0!==e||1!==t){h=1;const s=r.getArray();for(let i=0,r=2*n;i<r;){let n=s[i];n*=t,n+=e,s[i]=n,s[i+1]*=t,i+=2}}return 0!==h&&i.notifyModifiedFlags(2001),!!h}let _=Math.min(n,1e3);const p=h(_,Number.NaN),f=h(_,Number.NaN);let x=null;null!==o&&(x=new Float64Array(_));let y=0,P=Number.NaN,C=Number.NaN;const E=360*u,S=u/l;s&&(C=90*u,P=89.9*l,f.fill(0));let v=!0,I=0;for(;n;){let t=!1;const e=r.readRange(2*y,2*_);for(let t=0;t<_;t++)p[t]=e[t<<1];if(s)for(let s=0;s<_;s++){const n=1+(s<<1),i=Math.abs(e[n])-P;if(i>0){const r=e[n];e[n]=kt(P,r),f[s]=kt(i,r),t=!0}}const i=e[0];if(d){const t=g;x&&o.queryRange(y,_,x,!0,1),t.transform(!1,e,x,_),x&&o.writeRangeFromArray(y,_,x,!0,1)}else g.transform(!1,e,_);v&&(I=e[0]-S*i,v=!1);for(let t=0;t<_;t++){const s=t<<1,n=e[s]-p[t]*S-I;Math.abs(n)>200&&(e[s]+=n>0?-E:E)}if(t){for(let t=0;t<_;t++)if(f[t]){const s=1+(t<<1);e[s]+=S*f[t],e[s]>C?e[s]=C:e[s]<-C&&(e[s]=-C)}f.fill(0)}r.writeRangeFromArray(2*y,2*_,e,!0,1),c&&o&&o.writeRangeFromArray(y,_,x,!0,1),y+=_,n-=_,_=Math.min(n,1e3)}return i.notifyModifiedFlags(2001),!0}function g_(t,e,s){switch(e.getGeometryType()){case o.enumLine:return function(t,e,s){const n=[e.getStartXY(),e.getEndXY()];let i=null;e.hasAttribute(1)&&(i=[0,0],i[0]=e.getAttributeAsDbl(0,1,0),i[1]=e.getAttributeAsDbl(1,1,0));const r=x_(t,n,i,2,s);return e.setStartXY(n[0]),e.setEndXY(n[1]),i&&(e.setStartAttribute(1,0,i[0]),e.setEndAttribute(1,0,i[1])),e.normalizeAfterEndpointChange(),r}(t,e,s);case o.enumBezier:return function(t,e,s){const n=T(l,4);e.queryControlPoints(n);let i=null;e.hasAttribute(1)&&(i=[0,0,0,0],i[0]=e.getAttributeAsDbl(0,1,0),i[3]=e.getAttributeAsDbl(1,1,0),i[1]=C(i[0],i[3],.5),i[2]=i[1]);const r=x_(t,n,i||null,n.length,s);return e.setControlPoints(n),i&&(e.setStartAttribute(1,0,i[0]),e.setEndAttribute(1,0,i[3])),e.normalizeAfterEndpointChange(),r}(t,e,s);case o.enumEllipticArc:return function(t,e,s){if(0===e.projectionBehavior())return function(t,e,s){const n=[e.getStartXY(),e.getEndXY(),e.getInteriorPoint(),e.getCenter()];let i=4;e.isDegenerateToLine()&&(i=2);const r=[0,0,0,0];let o=null;if(e.hasAttribute(1)){o=r,o[0]=e.getAttributeAsDbl(0,1,0),o[1]=e.getAttributeAsDbl(1,1,0);const t=C(o[0],o[1],.5);o[2]=t,o[3]=t}const a=e.getStartXY().equals(e.getEndXY())&&!e.isDegenerateToLine(),h=x_(t,n,o,i,s);return a?e.constructCircleCenterAndPoint(n[3],n[0],!e.isClockwise()):e.isDegenerateToLine()?e.constructLineCircularArc(n[0],n[1]):e.constructCircularArcThreePoint(n[0],n[1],n[2]),o&&(e.setStartAttribute(1,0,o[0]),e.setEndAttribute(1,0,o[1])),h}(t,e,s);const n=e.getStartXY().equals(e.getEndXY()),i=T(l,3),r=T(l,3);let o=null;i[0].assign(e.getStartXY()),i[1].assign(n?e.getCenter():e.getEndXY());let a=!1;e.hasAttribute(1)&&(o=[0,0,0],o[0]=e.getAttributeAsDbl(0,1,0),o[1]=e.getAttributeAsDbl(1,1,0),o[2]=C(o[0],o[1],.5),n&&(o[1]=o[2])),r[0].setCoordsPoint2D(i[0]),r[1].setCoordsPoint2D(i[1]);const h=new Ps;if(n||e.isDegenerateToLine())a=x_(t,r,o,2,s),h.initializeFromTwoPoints(i[0],i[1],r[0],r[1]);else{const n=new l;e.queryCoord2D(.5,n),i[2].setCoordsPoint2D(n),r[2].setCoordsPoint2D(n),a=x_(t,r,o,3,s),h.setFromTwoTriangles(i,r)}return h.isIdentity()||(e.applyTransformation(h),e.setStartXY(r[0]),e.setEndXY(n?r[0]:r[1]),e.normalizeAfterEndpointChange()),o&&(e.setStartAttribute(1,0,o[0]),e.setEndAttribute(1,0,n?o[0]:o[1])),a}(t,e,s);case o.enumBezier2:case o.enumRationalBezier2:return n(0),!1;default:P("")}}function d_(t,e,s){if(!e.hasNonLinearSegments())return c_(t,e,s);if(e.isEmpty())return!1;const n=e.createInstance();n.reserveParts(e.getPointCount(),e.getPathCount());const i=e.getImpl(),r=new fm;for(let o=0,a=e.getPathCount();o<a;++o){let e=!0,a=-1;const h=i.getPathStart(o),m=h+i.getSegmentCountPath(o);i.isClosedPath(o)&&(a=m-1);const u=new l;for(let o=h;o<m;++o){if(i.getSegmentBuffer(o,r,!1),g_(t,r.get(),s),e||r.get().getStartXY().equals(u)||r.get().moveTo(u),o!==a)n.addSegment(r.get(),e);else{if(e){const t=new qe;r.get().queryStart(t),n.startPathPoint(t)}n.closeLastPathWithSegment(r.get())}u.assign(r.get().getEndXY()),e=!1}}return e.assignMove(n),!0}function __(t,e,s,n,i,r){if(t.isIdentityGeogToGeog()){const s=90*t.getInputSR().getOneDegreeGCSUnit();let i=0;const r=[0];for(let t=0;t<n;t++)r[0]=e[t].y,i|=se(r,-s,s)?1:0,e[t].y=r[0];return i}const o=t.getInputSR(),a=t.getOutputSR(),m=o.getVCS(),l=a.getVCS(),u=o.getOneDegreeGCSUnit(),c=90*u,g=a.getOneDegreeGCSUnit(),d=t.isVertical(),_=t.getDatumTransformation(),p=!!_&&1===_.getType();if(d||(s=null),!_||0===_.count()){let t=0;const i=[0];for(let s=0;s<n;s++)i[0]=e[s].y,t|=se(i,-c,c)?1:0,e[s].y=i[0];return t|=xd(o.getGCS(),m,a.getGCS(),l,e,s,n)?1:0,t}p||null===s||u_();let f=Math.min(n,1024);const x=h(f,Number.NaN),y=h(f,Number.NaN);let P=0,C=Number.NaN,E=Number.NaN;const S=360*g,v=g/u;i&&(E=90*g,C=89.9*u);let I=!0,b=0,w=n;for(;w;){let t=!1;for(let t=0;t<f;t++)x[t]=e[t+P].x;if(i)for(let s=0;s<f;s++){const n=Math.abs(e[s+P].y)-C;if(n>0){const i=e[s+P].y;e[s+P].y=kt(C,i),y[s]=kt(n,i),t=!0}}const n=e[0].x;p?_.transform(!1,e,s,f):_.transform(!1,e,f),I&&(b=e[0].x-v*n,I=!1);for(let t=0;t<f;t++){const s=e[P+t].x-x[t]*v-b;Math.abs(s)>200&&(s>0?e[P+t].x-=S:e[P+t].x+=S)}if(t){for(let t=0;t<f;t++)y[t]&&(e[P+t].y+=v*y[t],e[P+t].y>E?e[P+t].y=E:e[P+t].y<-E&&(e[P+t].y=-E));y.fill(0,0,f)}P+=f,w-=f,f=Math.min(w,1024)}return 1}function p_(t,e,s,i,r){return n(0),0}function f_(t,e,s,i,r){n(null===i),n(e<2147483647);const o=Array.isArray(s);let a;a=o?ue(s):s;const h=zp.geogToGeog(t,e,a,null,r);return o&&ce(a,s),h}function x_(t,e,s,n,i,r){let o=0,a=!0,h=0;for(let r=0;r<n;++r)e[r].isNAN()?a||(o|=__(t,e.slice(h,r-h),s?s.slice(h,r-h):null,r-h,i),h=r,a=!0):a&&(h=r,a=!1);return a||(o|=__(t,0===h?e:e.slice(h),s?0===h?s:s.slice(h):null,n-h,i)),0!==o}function y_(t,e,s,n){t_(t,e,s,n)}function P_(e,s,n,i){l_(e,s,n,i);const r=new t;r.setFromPoints(n,i);const o=e.getOneDegreeGCSUnit(),a=360*o,h=180*o;if(r.width()>h){for(let t=0;t<i;t++)for(;n[t].x<s;)n[t].x+=a;if(r.setFromPoints(n,i),r.xmax>h+s)for(let t=0;t<i;t++)n[t].x-=a}}function C_(t,e,s,n,i){const r=T(l,3);let o=0,a=!1,h=!1;const m=n.isDegenerateToLine();m?(r[0].assign(n.getStartXY()),r[1].assign(n.getEndXY()),r[2].setCoords(0,0),o=2):n.isClosed()&&n.isMajor()?(a=!0,h=!n.isClockwise(),r[0].assign(n.getStartXY()),r[1].assign(n.getCenter()),r[2].setCoords(0,0),o=2):(r[0].assign(n.getStartXY()),r[1].assign(n.getEndXY()),r[2].assign(n.getInteriorPoint()),o=3),t?y_(e,r,o,i):P_(e,s,r,o),m?n.constructLineCircularArc(r[0],r[1]):a?n.constructCircleCenterAndPoint(r[1],r[0],h):n.constructCircularArcThreePoint(r[0],r[1],r[2])}function E_(t,e,s){const n=Qa(t),i=$a(n,Qa(e)),r=$a(n,Qa(s));return 0===r||i>0&&r>0&&r<=i||i<0&&r<0&&r>=i}function S_(t,e,s,i,o){const a={stack:[],error:void 0,hasError:!1};try{const h=s.clone(),m=i.clone();if(2===o){const t=[0,0];return zm(0,e,h,m,0,t),t[0]}if(h.y>m.y){const t=new l;t.assign(h),h.assign(m),m.assign(t)}const u=Ss(a,new Lp,!1),c=Ss(a,new Lp,!1),g=Ss(a,new Lp,!1),d=new r;if(d.setCoords(h.y,m.y),!d.containsCoordinate(0)||Math.abs(h.x-m.x)>=Math.PI)return Number.NaN;if(h.x===m.x)return h.x;Zp.geodeticDistance(t,e,h.x,h.y,m.x,m.y,c,u,null,o);const _=c.val;let p=0,f=1;const x=h.clone();for(;_*(f-p)>1e-12*t;){const s=.5*(p+f);if(Zp.geodeticCoordinate(t,e,h.x,h.y,_*s,u.val,c,g,o),x.x=c.val,x.y=g.val,d.setCoords(h.y,x.y),0===x.y)return x.x;if(d.containsCoordinate(0))f=s;else{if(d.setCoords(m.y,x.y),!d.containsCoordinate(0))return n(!1),Number.NaN;p=s}}return x.x}catch(t){a.error=t,a.hasError=!0}finally{vs(a)}}function v_(t,e,s,n){const i=new r;i.setCoords(e,s);const o=n.width();let a=Math.floor((t-e)/o)*o+t;const h=i.getCenter();for(;Math.abs(a-h)>Math.abs(a+o-h);)a+=o;return a}class I_ extends Cs{constructor(){super(),this.m_geometryDeque=[],this.m_index=-1}next(){if(this.m_geometryDeque.length>0){this.m_index++;const t=this.m_geometryDeque[0];return this.m_geometryDeque.shift(),t}return null}getGeometryID(){return this.m_index}tick(t){this.m_geometryDeque.push(t)}tock(){return!0}getRank(){return 1}}class b_{constructor(e,i=!0){this.m_PCSHorizon=null,this.m_GCSHorizon=null,this.m_GCSSplitLines=null,this.m_bGCSHorisonIsInclusive=!1,this.m_oneMeterPCS=0,this.m_oneDegreeGCS=0,this.m_gcsUnitFactor=0,this.m_northPole=l.getNAN(),this.m_southPole=l.getNAN(),this.m_polesUpdated=0,this.m_domain=t.constructEmpty(),this.m_primeMeridian=Number.NaN,this.m_geogToProjFactor=1,this.m_geogToProjOffset=0,this.m_geogToProjFactorsUpdated=0,this.m_oneMillimeter=0,this.m_centralMeridian=0,this.m_pPCSInfoNoDomain=null,this.m_oldWKID=-1973,this.m_vcsWKID=-1,this.m_bIsPannable=!1,this.m_bCached=!1,this.m_pannableExtent=t.constructEmpty(),this.m_pannableExtentGCS=t.constructEmpty(),this.m_areaOfUse=null,this.m_canonicalWkt="",this.m_peCoordSys=e,this.m_WKID=Hp.getCode(e),this.m_WKID<=0?(this.m_WKID=0,this.m_canonicalWkt=Gd(e,0,!0),this.m_hashCode=Ot(this.m_canonicalWkt)):this.m_hashCode=d(this.m_WKID);const r=this.m_peCoordSys.getType();this.m_csType=r===Bp.PE_TYPE_PROJCS?2:1,n(r===Bp.PE_TYPE_PROJCS||r===Bp.PE_TYPE_GEOGCS),r===Bp.PE_TYPE_PROJCS&&(e.loadConstants()||s("PeProjcs.loadConstants failed"));const o=r===Bp.PE_TYPE_GEOGCS?this.m_peCoordSys:this.m_peCoordSys.getGeogcs();r!==Bp.PE_TYPE_GEOGCS&&Hp.getCode(o),this.m_unit=function(t){const e=Jp(null);return t.getType()===Bp.PE_TYPE_PROJCS||t.getType()===Bp.PE_TYPE_GEOGCS?e.reset(t.getUnit()):s("PE_coord_sys"),e.get()||P("cannot create units from coord sys"),function(t){return t.getType()===Bp.PE_TYPE_LINUNIT?new K_(t):t.getType()===Bp.PE_TYPE_ANGUNIT?new Tm(t):void s("peUnit")}(e.get())}(e),this.m_primeMeridian=o.getPrimem().getLongitude();{const t=o.getUnit().getUnitFactor();this.m_gcsUnitFactor=t;let e=Math.PI/(180*t);Math.abs(e-1)<1e-10&&(e=1),this.m_oneDegreeGCS=e}if(r===Bp.PE_TYPE_PROJCS){const t=this.m_peCoordSys,e=t.getUnit().getUnitFactor();this.m_oneMeterPCS=1/e,this.m_oneMillimeter=.001/e,this.m_pPCSInfoNoDomain=Op.generate(t,Op.PE_PCSINFO_OPTION_NONE),this.m_pPCSInfoNoDomain||P("cannot create pcs info"),this.m_bIsPannable=this.m_pPCSInfoNoDomain.isPannableRectangle(),this.m_centralMeridian=this.m_pPCSInfoNoDomain.getCentralMeridian()}else{this.m_bIsPannable=!0,this.m_polesUpdated=1,this.m_oneMeterPCS=0;const t=1/o.getUnit().getUnitFactor(),e=o.getDatum().getSpheroid().getAxis();this.m_oneMillimeter=.001/e*t,this.m_centralMeridian=0}this.m_bIsPannable&&(this.updateGCSHorizon(),this.updatePCSHorizon(),this.updatePoles(),this.updateDomain(),this.updatePannableExtent(),this.updatePannableExtentGCS())}[Symbol.dispose](){}getHashCode(){return this.m_hashCode}getPCSHorizonPannable(){return this.m_PCSHorizon}getGCSHorizonPannable(){return this.m_GCSHorizon}getPCSInfo(){return n(this.m_pPCSInfoNoDomain),this.m_pPCSInfoNoDomain}getCentralMeridian(){return this.m_centralMeridian}updateGCSHorizon(){if(this.m_peCoordSys.getType()!==Bp.PE_TYPE_PROJCS)return;let e=!0;const s=this.m_peCoordSys,i=s.getGeogcs(),o=s.horizonGcsGenerate();if(!o)return;n(o.length>0);const a=o[0].getNump(),h=o[0].getKind();let m,u;e=o[0].getInclusive()>0;const c=this.getOneDegreeGCSUnit(),g=90*c,d=360*c,_=370*c,p=180*c*Bp.PE_HORIZON_DELTA/Math.PI,f=t.constructEmpty();let x=null;if(a>1)for(let t=1;t<a;t++)if(o[t].getKind()===Bp.PE_HORIZON_LINE){x||(x=new Wn);const e=o[t].getCoord();x.startPathCoords(e[0][0],e[0][1]),x.lineToCoords(e[1][0],e[1][1])}if(h===Bp.PE_HORIZON_RECT){const t=o[0].getCoord();if(f.setFromPoints([new l(t[0][0],t[0][1]),new l(t[1][0],t[1][1])],2),Math.abs(f.ymax-g)<1e-7*p&&(f.ymax=g),Math.abs(f.ymin+g)<1e-7*p&&(f.ymin=-g),f.width()>_){const t=-400*c,e=t+5*d;f.setCoords({xmin:t,ymin:f.ymin,xmax:e,ymax:f.ymax})}const s=new Ne({env2D:f});this.m_GCSHorizon||(this.m_GCSHorizon=s,this.m_bGCSHorisonIsInclusive=e)}else{let s=this.getPCSInfo().isGcsHorizonMultiOverlap();const h=cp(i,null,0,1),l=[],_=new r;for(let e=0;e<a;e++){if(o[e].getKind()!==Bp.PE_HORIZON_POLY)continue;m=o[e].getSize();const s=o[e].getCoord(),n=t.constructEmpty();n.setFromPoints(Wt(s),m),l.push(new r(n.xmin,n.xmax)),n.width(),_.merge(l.at(-1))}let p=!1;const f=new r;_.width()>d&&l.length>1?(f.vmin=this.getCentralMeridian()-d,f.vmax=f.vmin+2*d,p=!0,s=!0):(f.vmin=_.vmin,f.vmax=f.vmin+d);const y=t=>{let e=0;for(;l[t].vmin+e<f.vmin;)e+=d;for(;l[t].vmax+e-d>f.vmin;)e-=d;return e};let P=new Tr;if(s){const t=new I_,e=(new Dd).executeMany(t,h,null);for(let s=0;s<a;s++){if(o[s].getKind()!==Bp.PE_HORIZON_POLY)continue;m=o[s].getSize();const n=o[s].getCoord();u=o[s].getInclusive()>0;const i=new Tr;if(i.addPathPoint2D(Wt(n),m-1,!0),p){const e=y(s),n=l[s].clone();n.move(e);let r=e;const o=new Ps;do{o.setShiftCoords(r,0);const e=i.clone();e.applyTransformation(o),t.tick(e),t.tock(),r+=d,n.move(d)}while(n.vmin<f.vmax)}else t.tick(i),e.tock()}P=e.next()}else{P=new Tr;for(let t=0;t<a;t++){if(o[t].getKind()!==Bp.PE_HORIZON_POLY)continue;m=o[t].getSize();const s=o[t].getCoord();if(u=o[t].getInclusive()>0,n(u===e),p){const e=new Tr;e.addPathPoint2D(Wt(s),m-1,!0);const n=y(t),i=l[t].clone();i.move(n);let r=n;const o=new Ps;do{if(0!==r){o.setShiftCoords(r,0);const t=new Tr({copy:e});t.applyTransformation(o),P.addPath(t,0,!0)}else P.addPath(e,0,!0);r+=d,i.move(d)}while(i.vmin<f.vmax)}else P.addPathPoint2D(Wt(s),m-1,!0)}}p&&(P=(new Sm).execute(P,new t(f.vmin,-g-c,f.vmax,g+c),h,null)),e?(new Eg).accelerateGeometry(P,h,1):(new bd).accelerateGeometry(P,h,1),(new Ad).accelerateGeometry(P,h,1),null===this.m_GCSHorizon&&(this.m_GCSHorizon=P,this.m_bGCSHorisonIsInclusive=e,this.m_GCSSplitLines=x)}}updateAreaOfUse(){return null}updatePCSHorizon(){if(this.m_peCoordSys.getType()!==Bp.PE_TYPE_PROJCS)return;const e=this.m_peCoordSys.horizonPcsGenerate();if(!e)return;let s;this.getPCSInfo();const i=e[0].getKind();e[0].getInclusive();const r=t.constructEmpty(),o=e[0].getNump();let a=!1;if(i===Bp.PE_HORIZON_RECT){const t=e[0].getCoord();r.setFromPoints(Wt(t),2),s=new Ne({env2D:r})}else{let t=-1;for(let s=0;s<o;s++)e[s].getKind()===Bp.PE_HORIZON_POLY&&(t=s);n(t>=0);const i=e[t].getSize()-1,r=e[t].getCoord(),h=new Tr;s=h,h.addPathPoint2D(Wt(r),i,!0),a=!0}if(this.getPCSInfo().isDensificationNeeded()){n(i!==Bp.PE_HORIZON_RECT);const t=1e5*this.getOneMeterPCSUnit();s=(new wm).execute(s,t,0,0,null)}if(a){{const t=new Ne;s.queryEnvelope(t),s.calculateArea2D(),s.calculateLength2D(),s.getExteriorRingCount()}(new Eg).accelerateGeometry(s,null,1)}null===this.m_PCSHorizon&&(this.m_PCSHorizon=s)}updatePannableExtent(){const e=this.m_peCoordSys.getType();if(e===Bp.PE_TYPE_PROJCS){const e=this.m_peCoordSys,s=this.getPCSInfo().getCentralMeridian(),n=e.getGeogcs();n||P("");const i=[s+1/n.getUnit().getUnitFactor()*Math.PI,0];Up.geogToProj(e,1,i);const r=i[0],o=e.getParameters()[Bp.PE_PARM_X0].getValue(),a=this.getPCSHorizon(),h=t.constructEmpty();a.queryEnvelope(h);const m=Math.abs(r-o),l=m+o,u=-1*m+o,c=h.ymax,g=h.ymin;this.m_pannableExtent.setCoords({xmin:u,ymin:g,xmax:l,ymax:c})}else if(e===Bp.PE_TYPE_GEOGCS){const t=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtent.setCoords({xmin:-t,ymin:-t/2,xmax:t,ymax:t/2})}else P("")}updatePannableExtentGCS(){const e=this.m_peCoordSys.getType();if(e===Bp.PE_TYPE_PROJCS){const e=this.m_peCoordSys,s=this.m_centralMeridian,n=e.getGeogcs();n||P("");const i=1/n.getUnit().getUnitFactor()*Math.PI,r=this.getGCSHorizon(),o=t.constructEmpty();r.queryEnvelope(o),this.m_pannableExtentGCS.setCoords({xmin:s-i,ymin:o.ymin,xmax:s+i,ymax:o.ymax})}else if(e===Bp.PE_TYPE_GEOGCS){const t=1/this.m_peCoordSys.getUnit().getUnitFactor()*Math.PI;this.m_pannableExtentGCS.setCoords({xmin:-t,ymin:-t/2,xmax:t,ymax:t/2})}else P("")}updateDomain(){if(1===this.m_csType){const e=400*this.getOneDegreeGCSUnit();this.m_domain=t.construct(-e,-e,e,e)}else{n(2===this.m_csType);const e=Op.generate(this.m_peCoordSys,Op.PE_PCSINFO_OPTION_DOMAIN);e||P("generate pcs info failed");const s=new t(e.getDomainMinx(),e.getDomainMiny(),e.getDomainMaxx(),e.getDomainMaxy());this.m_domain.isEmpty()&&this.m_domain.setCoords({env2D:s})}}updatePoles(){if(this.m_peCoordSys.getType()===Bp.PE_TYPE_PROJCS){const t=90*this.getOneDegreeGCSUnit(),e=[[0,t],[0,-t]];Up.geogToProj(this.m_peCoordSys,2,e);const s=this.getPCSInfo().getNorthPoleLocation()!==Op.PE_POLE_OUTSIDE_BOUNDARY,n=this.getPCSInfo().getSouthPoleLocation()!==Op.PE_POLE_OUTSIDE_BOUNDARY;this.m_polesUpdated||(s&&this.m_northPole.setCoords(e[0][0],e[0][1]),n&&this.m_southPole.setCoords(e[1][0],e[1][1]),this.m_polesUpdated=1)}else this.m_polesUpdated=1}updateGeogToProjFactors(){if(this.m_peCoordSys.getType()===Bp.PE_TYPE_PROJCS){const t=this.getOneDegreeGCSUnit(),e=this.m_pPCSInfoNoDomain.getCentralMeridian(),s=[0,0,0,0];s[0]=e,s[1]=0,s[2]=e+t,s[3]=0;const i=Up.geogToProj(this.m_peCoordSys,2,s);n(2===i);const r=(s[2]-s[0])/t,o=s[0];0===this.m_geogToProjFactorsUpdated&&(this.m_geogToProjFactor=r,this.m_geogToProjOffset=o,this.m_geogToProjFactorsUpdated=1)}else this.m_geogToProjFactorsUpdated=1}getOneMeterPCSUnit(){return this.m_oneMeterPCS}getOneDegreeGCSUnit(){return this.m_oneDegreeGCS}getGcsUnitFactor(){return this.m_gcsUnitFactor}getUnitsPerMillimeter(){return this.m_oneMillimeter}getGCSSplitLines(){return this.m_bIsPannable?null:(this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSSplitLines)}getGCSHorizon(){return this.m_bIsPannable?this.getGCSHorizonPannable():(null!==this.m_GCSHorizon||this.updateGCSHorizon(),this.m_GCSHorizon)}getGCSHorisonIsInclusive(){return this.m_bIsPannable||this.getGCSHorizon(),this.m_bGCSHorisonIsInclusive}getPCSHorizon(){return this.m_bIsPannable?this.getPCSHorizonPannable():(null!==this.m_PCSHorizon||this.updatePCSHorizon(),this.m_PCSHorizon)}getPole(t){return this.m_bIsPannable||0!==this.m_polesUpdated||this.updatePoles(),t?this.m_southPole:this.m_northPole}getGeogToProjFactors(){return 0===this.m_geogToProjFactorsUpdated&&this.updateGeogToProjFactors(),ft(this.m_geogToProjFactor,this.m_geogToProjOffset)}getDomainXY(){if(this.m_bIsPannable)return this.m_domain.clone();let t=!1;return t=this.m_domain.isEmpty(),t&&this.updateDomain(),this.m_domain.clone()}getPrimeMeridian(){return this.m_primeMeridian}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;if(t<0){if(t=0,this.m_WKID>0){const e=[0],s=[0];(function(t,e,s,n){return e<=0?(s[0]=0,n[0]=0,!1):(s[0]=e,n[0]=e,!0)})(this.m_peCoordSys.getType(),this.m_WKID,e,s)||P("query_code_change"),t=e[0]}this.m_oldWKID=t}return t}isCustomWkid(){return!1}isPannable(){return this.m_bIsPannable}getPannableExtent(){return this.m_pannableExtent.clone()}getPannableExtentGCS(){return this.m_pannableExtentGCS.clone()}getAreaOfUse(){return null!==this.m_areaOfUse?this.m_areaOfUse:this.updateAreaOfUse()}getVcsCode(){return 0}saveMemory(){}getCSType(){return this.m_csType}getUnit(){return this.m_unit}setCached(){this.m_bCached=!0}getCached(){return this.m_bCached}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}class w_{constructor(t,e=!0){this.m_oneMeter=0,this.m_WKID=-1,this.m_oldWKID=-1,this.m_canonicalWkt="not yet implemented",this.m_model=0,this.m_unit=new K_,this.m_cached=!1}setCached(t=!0){this.m_cached=t}getCached(){return this.m_cached}getOneMeterUnit(){return 0}getLatestID(){return this.m_WKID}getOldID(){let t=this.m_oldWKID;return t<0&&(t=0,this.m_WKID>0&&(t=this.m_WKID),this.m_oldWKID=t),t}getModel(){return 0}isCustomWkid(){return!1}getVerticalUnit(){return this.m_unit}static equal(t,e){return!1}static equal_for_projection(t,e){return!1}}function D_(e,i,r,o){return function(e,i,r,o,a){return ap()||Lt("cannot create projection transformation"),i.hasVCS()&&r.hasVCS()?(n(0),{}):function(e,n,i,r){e&&n||s("!inputSR || !outputSR");const o=e.getLatestID(),a=n.getLatestID();if(3857===o&&4326===a){if(e.m_bDefaultDescriptor&&n.m_bDefaultDescriptor)return W_()}else if(4326===o&&3857===a&&e.m_bDefaultDescriptor&&n.m_bDefaultDescriptor)return z_||(z_=W_().getInverse()),z_;const h=t.constructEmpty();h.setCoords({env2D:i});const m=e.getCoordinateSystemType(),l=n.getCoordinateSystemType();if(0===m||0===l)return G_(e,n);if(r){const t=r.find(0,e.getGCS(),n.getGCS());if(t)return G_(e,n,t)}const u=e.getGCS().getLatestID(),c=n.getGCS().getLatestID();if(u>0&&u===c)return G_(e,n);const g=new H_(e,n,i);{const t=function(t){if(B_.has(t.getHashCode()))return B_.get(t.getHashCode())}(g);if(t)return t}const d=A_(0,e,n,h,1,!0);return function(t,e){return B_.set(t.getHashCode(),e),e}(g,G_(e,n,d.length?d[0]:void 0))}(i,r,o,a)}(0,e,i,r,o)}function T_(t,e,s,n){return N_(!0,t,e,s,n)}function N_(t,e,s,n,i,r){return ap()||Lt("cannot create projection transformation"),new Y_(t?2:1,e,s,n,i,r)}function A_(t,e,n,i,r,o=!1){if(e&&n||s(""),ap()||Lt("cannot obtain geotransformation list"),1===t&&e.hasVCS()&&n.hasVCS())return f("hv xform not impl"),[];{const t=hf(e,n,i,r,o),s=[];for(const e of t)s.push(e);return s}}function M_(){return{centralMeridianOfOutputGCS:Number.NaN,densificationStep:Number.NaN,clipWithInputHorizon:!0,clipWithOutputHorizon:!0,legacyHorizonClipping:!1,normalizeResultGeometry:!1,equals(t){return j(this.centralMeridianOfOutputGCS,t.centralMeridianOfOutputGCS)&&j(this.densificationStep,t.densificationStep)&&this.clipWithInputHorizon===t.clipWithInputHorizon&&this.clipWithOutputHorizon===t.clipWithOutputHorizon&&this.legacyHorizonClipping===t.legacyHorizonClipping&&this.normalizeResultGeometry===t.normalizeResultGeometry}}}function G_(t,e,s,n,i){return new Y_(1,t,e,s,n,i)}function q_(){return{flagsMask:0,setFlag(t,e){e?this.flagsMask|=t:this.flagsMask&=~t},hasFlag(t){return 0!==(this.flagsMask&t)}}}function F_(){return{m_extendedParams:M_(),m_extendedParamsInternal:q_()}}function V_(){return F_()}let Y_=class t{constructor(t,e,i,r,o,a){let h,m;this.m_datumTran=null,this.m_bIdentity=!0,this.m_bIdentityGeogToGeog=!0,this.m_bVertical=!1,this.m_bNormalize=!1,e&&i||s("!inputSR || !outputSR"),r&&0===r.getType()&&(r.m_bReadOnly=!0),this.m_bNormalize=!1,1!==t&&(h=e.getVCS(),m=i.getVCS(),this.m_bVertical=null!=h&&null!=m),this.m_inputSR=e,this.m_outputSR=i,this.m_bIdentity=!1,this.m_bIdentityGeogToGeog=!1,n(!this.m_params),o&&(this.m_params=F_(),this.m_params.m_extendedParams=o),a&&(this.m_params||(this.m_params=F_()),this.m_params.m_extendedParamsInternal=a);let l=!1;const u=null!=r,c=e.getCoordinateSystemType(),g=i.getCoordinateSystemType();if(i.isPannable()&&0!==c&&o){const t=o.centralMeridianOfOutputGCS;if(!Number.isNaN(t)&&i.isPannable()){const e=i.getPannableExtent(),s=e.getCenterX();if(s!==t){const n=Math.ceil(e.width());t+n!==s+n&&(l=!0)}}}const d=o&&o.normalizeResultGeometry;if(e.equals(i))return this.m_bIdentity=!l,this.m_bIdentityGeogToGeog=!0,void this.updateProjector();const _=!u&&e.equalForProjection(i,this.m_bVertical);this.m_bIdentity=_&&!l,this.m_bIdentity?this.m_bIdentityGeogToGeog=!0:0!==c&&0!==g&&(d&&this.m_outputSR.isPannable()&&(this.m_bNormalize=d),this.m_datumTran=r||null,this.m_bIdentityGeogToGeog=(!this.m_datumTran||0===this.m_datumTran.count())&&this.m_inputSR.getGCS().equalForProjection(this.m_outputSR.getGCS(),this.m_bVertical)),this.updateProjector()}getInputSR(){return this.m_inputSR}getOutputSR(){return this.m_outputSR}getDatumTransformation(){return this.m_datumTran}getInverse(){const e=new t(1,this.m_outputSR,this.m_inputSR,this.m_datumTran?.createInverse());return e.m_bIdentity=this.m_bIdentity,e.m_bVertical=this.m_bVertical,e.m_bIdentityGeogToGeog=this.m_bIdentityGeogToGeog,e.updateProjector(),e}isIdentity(){return this.m_bIdentity}getExtendedParams(){return this.m_params?this.m_params.m_extendedParams:V_().m_extendedParams}equals(t){return n(0),!1}isVertical(){return this.m_bVertical}isMatchingTransformation(t,e){return n(0),!1}getGeographicTransformations(){return this.m_datumTran}getExtendedParamsImpl(){return this.m_params?this.m_params.m_extendedParams:V_().m_extendedParams}getExtendedParamsInternal(){return this.m_params?this.m_params.m_extendedParamsInternal:V_().m_extendedParamsInternal}isIdentityGeogToGeog(){return this.m_bIdentityGeogToGeog}normalizeOutput(){return this.m_bNormalize}updateProjector(){this.m_projector=new Dg(this)}};const X_=new Map,k_=new Map,R_=new Map;function L_(t){let e=t.getCode();if(e>0)return Q_(e)||Z_(Hp.coordsys(e));const s=t.getName();if(k_.has(s)){const e=k_.get(s);if(e&&e.deref()){const s=e.deref();if(s.m_peCoordSys.isEqual(t))return s}}return e=Hp.getCode(t),Z_(e>0?Hp.coordsys(e):t)}class H_{constructor(t,e,s){this.m_hashCode=-1,t&&(this.m_inputSR=t,this.m_outputSR=e,this.m_env=s.clone(),this.m_hashCode=this.m_inputSR.getHashCode(),this.m_hashCode=Vt(this.m_hashCode,this.m_outputSR.getHashCode()),this.m_env.isEmpty()||(this.m_hashCode=Vt(this.m_hashCode,ge(this.m_env.xmin)),this.m_hashCode=Vt(this.m_hashCode,ge(this.m_env.xmax)),this.m_hashCode=Vt(this.m_hashCode,ge(this.m_env.ymin)),this.m_hashCode=Vt(this.m_hashCode,ge(this.m_env.ymax))))}getHashCode(){return this.m_hashCode}equals(t){return!(this.m_inputSR&&!t.m_inputSR||!this.m_inputSR&&t.m_inputSR)&&this.m_env.equals(t.m_env)&&this.m_inputSR.equals(t.m_inputSR)&&this.m_outputSR.equals(t.m_outputSR)}clear(){this.m_inputSR=void 0,this.m_outputSR=void 0,this.m_hashCode=-1,this.m_env=void 0}}const B_=new Map;let U_,z_,O_;function W_(){return U_||(U_=T_(Tp(),Ap())),U_}const j_=new Map;function Z_(t){const e=Jp(t),s=t.getCode();if(s>0){const t=Q_(s);if(t)return t}const n=t.getName();let i=k_.get(n);if(i){const e=i.deref();if(e&&e.m_peCoordSys.isEqual(t))return e}const r=new b_(e.release());if(s>0)return r.setCached(),X_.set(s,new WeakRef(r)),k_.set(n,new WeakRef(r)),r;const o=Gd(t,0,!1);if(i=R_.get(o),i){const t=i.deref();if(t)return t}return r.setCached(),R_.set(o,new WeakRef(r)),r}function Q_(t){const e=X_.get(t);if(e)return e.deref()}class K_ extends ym{constructor(t){return void 0===t?(super(),this.m_wkid=9001,void(this.m_peUnit=null)):"number"==typeof t?(super(),this.m_factor=t,void(this.m_wkid=0)):(super(t),void(t||(this.m_factor=1,this.m_wkid=9001,this.m_peUnit=(O_||(O_=Hp.unit(9001)),O_))))}getUnitType(){return 0}convertFromMeters(t){return t/this.getUnitToBaseFactor()}convertToMeters(t){return t*this.getUnitToBaseFactor()}}const J_=["0","1","2","3","4","5","6","7","8","9","b","c","d","e","f","g","h","j","k","m","n","p","q","r","s","t","u","v","w","x","y","z"];function $_(t,e,s,i,r){n(i>>5<r.length);let o=e,a=s;for(let e=i;e>=0;e-=2){const s=31&e,n=.5*(a+o);t>=n?(r[e>>5]|=1<<s,o=n):a=n}}let tp=new Set;const ep=2147483645n,sp=9007199254740990n,np="operation is not supported for unknown coordinate systems";var ip;function rp(){return{majorSemiAxis:0,e2:0,minorSemiAxis:0,flattening:0,isSphere(){return 0===this.e2}}}function op(t){$p=t,n($p)}function ap(){return!!Hp}function hp(){return!!$p}function mp(){return!!Hp||!!$p}function lp(t,e,s){return n(mp()),Vp(t,void 0===e?0:e,0,!1)}function up(t,e){n(mp());const s=new wp;let i;return ap()?(i=function(t){const e=Jp(Hp.fromString(Bp.PE_TYPE_COORDSYS,t));return e.get()||le(t),L_(e.release())}(t),s.setHorzProj_(i),s.m_vertcs=null,s.m_userWKID=i.getLatestID()):(i=tf(t),s.m_unit=i.isPCS?new K_(i.metersOrRadiansPerUnit):new Tm(i.metersOrRadiansPerUnit)),Gp(s.m_precisionDescriptor,i,null,1),s.m_bDefaultDescriptor=!0,s.m_userWKT=t,s.calculateHashCode(),s.initDbgName(),s}function cp(t,e,i,r,o=!0){let a=null;return e&&(n(0),a={}),function(t,e,n,i,r){t||s("!PE_coord_sys");const o=new wp;let a;return a=r?L_(t):new b_(t,!1),Gp(o.m_precisionDescriptor,a,e,i),o.m_bDefaultDescriptor=!0,o.setHorzProj_(a),o.m_vertcs=e,o.m_userWKID=a.getLatestID(),o.calculateHashCode(),o.initDbgName(),o}(t,a,0,r,o)}function gp(t,e,n=!1){3===t.getCoordinateSystemType()&&s("image spatial reference cannot be altered");const i=new wp,r=t;return i.m_peCoordSysVal=r.m_peCoordSysVal,i.m_vertcs=r.m_vertcs,i.m_unit=r.m_unit,i.m_precisionDescriptor.assign(e),i.m_localZToXYFactor=r.m_localZToXYFactor,(Number.isNaN(i.m_precisionDescriptor.m_falseX)||Number.isNaN(i.m_precisionDescriptor.m_falseY))&&(i.m_precisionDescriptor.m_falseX=r.m_precisionDescriptor.m_falseX,i.m_precisionDescriptor.m_falseY=r.m_precisionDescriptor.m_falseY),i.m_precisionDescriptor.snapPrecision(),i.m_precisionDescriptor.fixTolerance(),i.m_userWKID=r.m_userWKID,i.m_precisionDescriptor.equals(r.m_precisionDescriptor)?i.m_bDefaultDescriptor=r.m_bDefaultDescriptor:i.m_bDefaultDescriptor=!1,n&&(i.m_bDefaultDescriptor=!0),i.calculateHashCode(),i.initDbgName(),i}function dp(t,e,n){void 0===e&&(e=1),(e<=0||!Number.isFinite(e))&&s(""),t||1===e||s("null Unit has to have z_to_xy_factor equal to 1");const i=new wp;i.m_unit=t;const r=t||new K_(9001);return Fp(i.m_precisionDescriptor,r,null,1),i.m_bDefaultDescriptor=!0,Number.isNaN(i.m_precisionDescriptor.m_falseX)&&s("NAN false X/Y are not allowed here"),i.m_localZToXYFactor=e,i.calculateHashCode(),i.initDbgName(),i}function _p(t,e){return t.snapGeometry(e)}function pp(t){const e=t.getCoordinateSystemType();return 1===e?t:(3===e&&n(0),t.getGCS())}function fp(t){return n(mp()),hp()?function(t){return n(hp()),!!$p(t).isPCS||(e=t,Hp&&K("pe has been loaded. no-pe methods should not be used at this point."),Xp||sf(),Xp.has(e));var e}(t):function(t){if(j_.has(t))return j_.get(t);{const e=function(t){return null!==Jp(Hp.coordsys(t)).get()}(t);return j_.set(t,e),e}}(t)}function xp(t){if(ap())return null!==Jp(Hp.fromString(Bp.PE_TYPE_COORDSYS,t)).get();try{return tf(t),!0}catch(t){}return!1}let yp;function Pp(){return yp||(yp=(()=>{const t=Math.trunc(Math.random()*c()),e=Date.now();return`|abba_000|${t.toString(16)}|${e.toString(16)}|`})()),yp}!function(t){t[t.utmDefault=0]="utmDefault",t[t.utmNorthSouth=1]="utmNorthSouth"}(ip||(ip={}));let Cp=0;function Ep(t=""){let e=`${Pp()}${Cp++}`;return""!==t&&(e+=`|${t}`),e}function Sp(t){return t.startsWith(Pp())}let vp,Ip,bp,wp=class t{destroy(){var t;t=this.m_peCoordSysVal,k_.delete(t.m_peCoordSys.getName()),R_.delete(Gd(t.m_peCoordSys,0,!1)),1===this.getCoordinateSystemType()||2===this.getCoordinateSystemType()?this.getPECoordSys().destroy():P("SpatialReference.destroy")}constructor(){this.m_vertcs=null,this.m_peCoordSysVal=null,this.m_userWKID=0,this.m_userWKT=null,this.m_geogSpatialReference=null,this.m_srToGcs=null,this.m_gcsToSr=null,this.m_defaultPrecisionSR=null,this.m_localZToXYFactor=-1,this.m_precisionDescriptor=new Dp,this.m_hashCode=0,this.m_bDefaultDescriptor=!1,Mp(this.m_precisionDescriptor),tp&&tp.add(new WeakRef(this))}attachToPe(){(this.m_userWKID>0?lp(this.m_userWKID):up(this.m_userWKT)).copyTo(this,!1)}copyTo(t,e=!0){(e||t.m_bDefaultDescriptor)&&(t.m_bDefaultDescriptor=this.m_bDefaultDescriptor,t.m_precisionDescriptor.assign(this.m_precisionDescriptor)),t.m_defaultPrecisionSR=null,t.m_gcsToSr=this.m_gcsToSr,t.m_geogSpatialReference=this.m_geogSpatialReference,t.m_hashCode=this.m_hashCode,t.m_localZToXYFactor=this.m_localZToXYFactor,t.m_peCoordSysVal=this.m_peCoordSysVal,t.m_srToGcs=this.m_srToGcs,t.m_userWKID=this.m_userWKID,t.m_userWKT=this.m_userWKT,t.m_vertcs=this.m_vertcs,t.m_unit=this.m_unit}getHashCode(){return this.m_hashCode}getHashCodeHorizontal(){let t=0;return t=this.m_peCoordSysVal?this.m_peCoordSysVal.getHashCode():this.m_unit?this.m_unit.getHashCode():305419891,t}updateTransform(t){if(1===this.getCoordinateSystemType())return T_(this,this,null);let e=t?this.m_srToGcs:this.m_gcsToSr;if(e)return e;const s=this.getGCS();e=t?T_(this,s,null):T_(s,this,null);const n=e;return(t?this.m_srToGcs:this.m_gcsToSr)||(t?this.m_srToGcs=n:this.m_gcsToSr=n,e)}getHashCodeVertical(){return this.m_vertcs?this.m_vertcs.getHashCode():0}calculateHashCode(){let t=this.getHashCodeHorizontal();const e=this.getHashCodeVertical(),s=this.m_precisionDescriptor.getHashCode();t=Vt(t,e),this.m_hashCode=Vt(t,s)}initDbgName(){}setHorzProj_(t){this.m_peCoordSysVal=t,this.m_unit=this.m_peCoordSysVal.getUnit()}getTolerance(t=0){return this.m_precisionDescriptor.getTolerance(t)}getResolution(t=0){return this.m_precisionDescriptor.getResolution(t)}getPECoordSys(){return this.m_peCoordSysVal?this.m_peCoordSysVal.m_peCoordSys:null}getPCSInfo(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSInfo()}getCentralMeridian(){return this.throwIfNotGCSOrPCS(),1===this.getCoordinateSystemType()?0:this.getPCSInfo().getCentralMeridian()}getCoordinateSystemType(){const t=this.getPECoordSys();if(t)switch(t.getType()){case Bp.PE_TYPE_GEOGCS:return 1;case Bp.PE_TYPE_PROJCS:return 2;default:return 0}else{if((this.m_userWKID>0||this.m_userWKT)&&this.m_unit instanceof K_)return 2;if(this.m_unit instanceof Tm)return 1}return 0}getID(){return this.m_userWKID}getLatestID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getLatestID():this.m_userWKID}getOldID(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getOldID():this.m_userWKID}getVerticalID(){return f("vcs not implemented"),0}getLatestVerticalID(){return this.m_vertcs?this.m_vertcs.getLatestID():0}getOldVerticalID(){return f("vcs not implemented"),0}getPEVerticalCoordSys(){return null}getPole(t){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getPole(t)}getText(){const t=this.getPECoordSys();return t?qd(t):this.m_userWKT??""}getTextExtended(t){const e=this.getPECoordSys();return e?this.getPEVerticalCoordSys()?(this.getPEVerticalCoordSys(),n(0),""):qd(e,t):this.m_userWKT??""}getText2(t=-1){const e=this.getPECoordSys();return e?function(t,e){(e>1||e<-1)&&s("verbosity");let n=Bp.PE_STR_FMT_WKT2;return-1!==e&&(n|=0===e?Bp.PE_STR_AUTH_TOP:Bp.PE_STR_AUTH_ALL),t.toString(n)}(e,t):this.m_userWKT??""}getUnit(){return this.m_unit}getUnitsPerMillimeter(){return this.m_peCoordSysVal?this.m_peCoordSysVal.getUnitsPerMillimeter():this.m_unit instanceof K_?.001/this.m_unit.getUnitToBaseFactor():this.m_unit instanceof Tm?.001/(tf(this.m_userWKT??this.m_userWKID).semiMajor*this.m_unit.getUnitToBaseFactor()):(K("sr object not in valid state"),0)}getAuthorityName(){return this.getPECoordSys()?(n(0),""):""}getVerticalUnit(){return f("vcs not implemented"),{}}getVCS(){return this.m_vertcs}hasVCS(){return!1}getGCSHorisonIsInclusive(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorisonIsInclusive()}getGCSHorizon(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSHorizon()}getGCS(){const t=this.getCoordinateSystemType();if(0===t)K(np);else{if(1===t)return this;3===t&&K("image cs not supported")}if(this.m_geogSpatialReference)return this.m_geogSpatialReference;let e;if(this===Tp()||this===Np())e=Ap();else{n(this.m_peCoordSysVal);const t=this.m_peCoordSysVal.m_peCoordSys.getGeogcs();t||P(""),e=cp(t,this.m_vertcs,0,this.m_precisionDescriptor.getPrecision(),this.m_peCoordSysVal.getCached())}return this.m_geogSpatialReference?e=this.m_geogSpatialReference:this.m_geogSpatialReference=e,e}getGCSSplitLines(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getGCSSplitLines()}toGCS(t,e){if(0===t.length)return 0;t.length>e.length&&s("coordsSrc.size() > coordsDst.size()");const i=this.getCoordinateSystemType();if(0===i&&K(np),1===i)return Rt(e,t,t.length),t.length;n(this.m_peCoordSysVal);const r=this.getSRToGCSTransform();return(new Ag).transform(r,t,t.length,e)}toGeohash(t,e=8){const s=t.clone();s.scale(9102===this.getGCS().getUnit().getID()?1:this.getGCS().getUnit().getUnitToBaseFactor()/Math.PI*180),s.x<-180?(s.x=Pt(s.x,360),s.x<-180&&(s.x+=360)):s.x>180&&(s.x=Pt(s.x,360),s.x>180&&(s.x-=360)),s.y>90&&(s.y=90),s.y<-90&&(s.y=-90);const n=5*e,i=new Uint32Array(4);return $_(s.x,-180,180,n-1,i),$_(s.y,-90,90,n-2,i),function(t,e,s){const n=h(e,"R");let i=0,r=0;for(let s=0;s<e;s++){let o=t[i]>>r&31;if(r+=5,r>31){const e=37-r;o&=(1<<e)-1,r-=32,i++,o|=(t[i]&(1<<r)-1)<<e}const a=J_[o];n[e-1-s]=a}return s>e?n.push(..."0".repeat(s-e)):s<e&&(n.length=s),n.join("")}(i,e,e)}isPannable(){const t=this.getCoordinateSystemType();return 0!==t&&3!==t&&(n(this.m_peCoordSysVal),this.m_peCoordSysVal.isPannable())}getPannableExtent(){return this.isPannable()||s("!is_pannable"),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtent()}getPannableExtentInGCS(){return this.isPannable()||s("!is_pannable"),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getPannableExtentGCS()}throwIfNotGCSOrPCS(){const t=this.getCoordinateSystemType();1!==t&&2!==t&&s("Not a GCS or PCS")}getDomainXY(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getDomainXY()}getFullWorldExtent(){return this.throwIfNotGCSOrPCS(),this.isPannable()?this.getPannableExtent():this.getDomainXY()}queryPrecisionDescriptor(t){if(t.assign(this.m_precisionDescriptor),Number.isNaN(t.m_falseX))if(ap()||Lt("cannot query precision descriptor"),n(null!==this.m_peCoordSysVal),2!==this.m_precisionDescriptor.m_precision){const e=this.m_peCoordSysVal.getDomainXY();t.m_falseX=e.xmin,t.m_falseY=e.ymin}else t.m_falseX=-Number.MAX_VALUE,t.m_falseY=-Number.MAX_VALUE}queryPrecisionDescriptorWithoutFalseXY(t){t.assign(this.m_precisionDescriptor),t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}queryDefaultPrecisionDescriptorWithoutFalseXY(t){if(this.m_bDefaultDescriptor)t.assign(this.m_precisionDescriptor);else{const e=this.getCoordinateSystemType();0===e?Fp(t,this.m_unit,this.m_vertcs,this.m_precisionDescriptor.getPrecision()):3===e?f("image cs"):Gp(t,this.m_peCoordSysVal,this.m_vertcs,this.m_precisionDescriptor.getPrecision())}t.m_falseX=Number.NaN,t.m_falseY=Number.NaN}horizontalEqual(t){return(e=this.m_peCoordSysVal)===(s=t.m_peCoordSysVal)||null!==e&&null!==s&&e.m_csType===s.m_csType&&(0===e.m_WKID&&0===s.m_WKID?e.m_hashCode===s.m_hashCode&&e.m_canonicalWkt===s.m_canonicalWkt:e.m_WKID===s.m_WKID);var e,s}verticalEqual(t){return null!==this.m_vertcs==(null!==t.m_vertcs)&&(!this.m_vertcs||this.m_vertcs.equals(t.m_vertcs))}equals(t){const e=t;if(this===e)return!0;if(!this.horizontalEqual(e)||!this.verticalEqual(e))return!1;if(!e.m_peCoordSysVal){if(n(!this.m_peCoordSysVal),null!==this.m_unit!=(null!==e.m_unit))return!1;if(this.m_unit&&!this.m_unit.equals(e.m_unit))return!1;if(this.m_localZToXYFactor!==e.m_localZToXYFactor)return!1}if(!this.m_bDefaultDescriptor||!e.m_bDefaultDescriptor){if(this.m_peCoordSysVal){if(!this.m_precisionDescriptor.equalsWithoutFalseXY(e.m_precisionDescriptor))return!1;n(e.m_peCoordSysVal);let t=this.m_precisionDescriptor.m_falseX,s=this.m_precisionDescriptor.m_falseY;if(Number.isNaN(t)){const e=this.m_peCoordSysVal.getDomainXY();t=e.xmin,s=e.ymin}let i=e.m_precisionDescriptor.m_falseX,r=e.m_precisionDescriptor.m_falseY;if(Number.isNaN(i)){const t=e.m_peCoordSysVal.getDomainXY();i=t.xmin,r=t.ymin}return t===i&&s===r}return this.m_precisionDescriptor.equals(e.m_precisionDescriptor)}return!0}equalForProjection(t,e){if(this===t)return!0;const s=this.getCoordinateSystemType(),n=t.getCoordinateSystemType();if(0===s||0===n)return 0===s&&0===n?(!e||this.getZToXYFactor()===t.getZToXYFactor())&&(!this.getUnit()||!t.getUnit()||this.getUnit().equals(t.getUnit())):3!==s&&3!==n&&(null===this.getUnit()||null===t.getUnit()||(!e||this.getZToXYFactor()===t.getZToXYFactor())&&this.getUnit().equals(t.getUnit()));if(s!==n)return!1;if(3===s)return this.equals(t);if((i=this.m_peCoordSysVal)===(r=t.m_peCoordSysVal)||null!==i&&null!==r&&i.m_csType===r.m_csType&&(0===i.m_WKID&&0===r.m_WKID?1===i.m_csType?i.m_peCoordSys.isEqual(r.m_peCoordSys):i.m_peCoordSys===r.m_peCoordSys:i.m_WKID===r.m_WKID)){if(!e)return!0;if(null!==this.m_vertcs==(null!==t.m_vertcs))return!this.m_vertcs||this.m_vertcs.equalForProjection(t.m_vertcs)}var i,r;return!1}equalHorizontal(t){return this.horizontalEqual(t)}equalVertical(t){return n(0),!1}equalVerticalVCS(t){return n(0),!1}convergenceAngle(t){return n(0),0}getPeCoordsysCopy(){if(this.m_peCoordSysVal){const t=this.m_peCoordSysVal.m_peCoordSys;return t||P("cannot clone coord sys"),t}return null}getPeVertcsCopy(){return n(0),0}throwIfLocal(){0===this.getCoordinateSystemType()&&s(np)}getPrimeMeridian(){return this.throwIfLocal(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getPrimeMeridian()}getSRToGCSTransform(){return this.updateTransform(!0)}getGCSToSRTransform(){return this.updateTransform(!1)}getOneMeter(){return 1e3*this.getUnitsPerMillimeter()}getOneMeterPCSUnit(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneMeterPCSUnit()}getDefaultPrecisionSR(){if(this.m_bDefaultDescriptor)return this;if(null===this.m_defaultPrecisionSR){const t=new Dp;this.queryDefaultPrecisionDescriptorWithoutFalseXY(t),this.m_defaultPrecisionSR=gp(this,t,!0)}return this.m_defaultPrecisionSR}getPCSHorizon(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getPCSHorizon()}getHorzUnitFactor(){return this.m_unit?this.m_unit.getUnitToBaseFactor():1}querySpheroidData(t){this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal);const e=this.getGCS().getPECoordSys().getDatum().getSpheroid(),s=e.getFlattening();var i,r,o;r=e.getAxis(),o=s,(i=t).majorSemiAxis=r,i.minorSemiAxis=r*(1-o),i.e2=o*(2-o),i.flattening=o}getAreaOfUse(){0===this.getCoordinateSystemType()&&K(""),n(this.m_peCoordSysVal);const t=this.m_peCoordSysVal.getAreaOfUse();return null===t?new xm:new xm({geom:t.clone(),sr:lp(4326)})}getZToXYFactor(){return 1}isCustomWkid(){return!1}getOneDegreeGCSUnit(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getOneDegreeGCSUnit()}getGcsUnitFactor(){return this.throwIfNotGCSOrPCS(),n(this.m_peCoordSysVal),this.m_peCoordSysVal.getGcsUnitFactor()}snapGeometry(t){if(t.isEmpty())return!1;if(2===this.m_precisionDescriptor.getPrecision())return!1;const s=t.getGeometryType();if(e(s))return this.snapMultiVertex_(t);if(s===o.enumPoint)return this.snapPoint_(t);if(s===o.enumEnvelope)return this.snapEnvelope_(t);if(F(s))return this.snapSegment_(t);if(s===o.enumGeometryCollection){const e=t;let s=!1;for(let t=0,n=e.getGeometryCount();t<n;++t)s=this.snapGeometry(e.getGeometry(t))||s;return s}P("what else?")}snapMultiVertex_(t){if(n(!t.isEmpty()),n(2!==this.m_precisionDescriptor.getPrecision()),Z(t.getGeometryType())){const e=t;if(e.hasNonLinearSegments())return this.snapGeometryWithCurves_(e)}const e=t.getImpl(),s=e.getDescription();let i=!1;for(let t=0,n=s.getAttributeCount();t<n;t++){const n=s.getSemantics(t),r=e.getAttributeStreamRef(n);i=this.snapAttributes(n,r,0,e.getPointCount())||i}return i&&e.notifyModifiedFlags(2001),i}snapPoint_(t){return!1}snapEnvelope_(t){return!1}snapSegment_(t){n(!t.isEmpty()),n(2!==this.m_precisionDescriptor.getPrecision());const e=new Dp;this.queryPrecisionDescriptor(e);const s=t.getStartXY(),i=new l;i.x=Yp(s.x,e.getFalseX(),e.getGridUnitsXY()),i.y=Yp(s.y,e.getFalseY(),e.getGridUnitsXY());let r=!i.equals(s);const o=t.getEndXY(),a=new l;a.x=Yp(o.x,e.getFalseX(),e.getGridUnitsXY()),a.y=Yp(o.y,e.getFalseY(),e.getGridUnitsXY()),r||=!a.equals(o),r&&t.changeEndPoints2D(i,a);const h=(e,s,n)=>{let i=!1;{const r=t.getStartAttributeAsDbl(e,0),o=Yp(r,s,n),a=!j(o,r);i||=a,a&&t.setStartAttribute(e,0,o)}{const r=t.getEndAttributeAsDbl(e,0),o=Yp(r,s,n),a=!j(o,r);i||=a,a&&t.setEndAttribute(e,0,o)}return i};let m=r?1:0;return t.hasAttribute(1)&&(m|=h(1,e.getFalseZ(),e.getGridUnitsZ())?1:0),t.hasAttribute(2)&&(m|=h(2,e.getFalseM(),e.getGridUnitsM())?1:0),!!m}snapGeometryWithCurves_(t){n(!t.isEmpty()),n(2!==this.m_precisionDescriptor.getPrecision());const e=t.createInstance(),s=new fm;let i=0;for(let n=0,r=t.getPathCount();n<r;++n){const r=t.getSegmentCountPath(n);if(0===r){if(e.addPath(t,n,!0),1===e.getPathSize(n)){const t=new qe;e.getPointByVal(e.getPointCount()-1,t),i|=this.snapGeometry(t)?1:0,e.setPointByVal(e.getPointCount()-1,t)}continue}const o=t.isClosedPath(n);for(let a=0,h=o?r-1:r;a<h;++a)t.getSegmentFromPath(n,a,s,!1),i|=this.snapGeometry(s.get())?1:0,e.addSegment(s.get(),0===a);o&&(t.getSegmentFromPath(n,r-1,s,!1),i|=this.snapGeometry(s.get())?1:0,1===r?e.addPathFromClosedSegment(s.get(),!1):e.closeLastPathWithSegment(s.get()))}return i&&e.copyTo(t),!!i}snapAttributes(e,s,n,i){let r=!1;const o=new Dp;if(this.queryPrecisionDescriptor(o),0===e){const e=s;for(let s=n;s<i;s++){const n=e.read(2*s),i=t.s_SnapValue(n,o.getFalseX(),o.getGridUnitsXY()),a=e.read(2*s+1),h=t.s_SnapValue(a,o.getFalseY(),o.getGridUnitsXY());r=r||i!==n||h!==a,r&&(e.write(2*s,i),e.write(2*s+1,h))}}else if(1===e){const e=s;for(let s=n;s<i;s++){const n=e.read(s),i=t.s_SnapValue(n,o.getFalseZ(),o.getGridUnitsZ());r=r||!j(i,n),r&&e.write(s,i)}}else if(2===e){const e=s;for(let s=n;s<i;s++){const n=e.read(s),i=t.s_SnapValue(n,o.getFalseM(),o.getGridUnitsM());r=r||!j(i,n),r&&e.write(s,i)}}return r}static s_SnapValue(t,e,s){return Ht((t-e)*s)/s+e}};class Dp{constructor(){const t=sp,e=.001,s=1e-4*Number(t)*.5;this.m_precision=1,this.m_falseX=-s,this.m_falseY=-s,this.m_unitsXY=Number(t)/(2*s),this.m_falseM=-1e5,this.m_unitsM=1e4,this.m_falseZ=-1e5,this.m_unitsZ=1e4,this.m_toleranceXY=e,this.m_toleranceM=e,this.m_toleranceZ=e}getHashCode(){let t=7777,e=7777;return e=Vt(e,this.m_falseM),e=Vt(e,this.m_unitsM),t=Vt(t,this.m_unitsXY),e=Vt(e,this.m_toleranceXY),t=Vt(t,this.m_falseZ),e=Vt(e,this.m_toleranceZ),t=Vt(t,this.m_unitsZ),e=Vt(e,this.m_toleranceM),t=Vt(t,this.m_precision),Vt(t,e)}clone(){const t=new Dp;return t.m_falseX=this.m_falseX,t.m_falseY=this.m_falseY,t.m_unitsXY=this.m_unitsXY,t.m_falseZ=this.m_falseZ,t.m_unitsZ=this.m_unitsZ,t.m_falseM=this.m_falseM,t.m_unitsM=this.m_unitsM,t.m_toleranceXY=this.m_toleranceXY,t.m_toleranceZ=this.m_toleranceZ,t.m_toleranceM=this.m_toleranceM,t.m_precision=this.m_precision,t}assign(t){return this.m_falseX=t.m_falseX,this.m_falseY=t.m_falseY,this.m_unitsXY=t.m_unitsXY,this.m_falseZ=t.m_falseZ,this.m_unitsZ=t.m_unitsZ,this.m_falseM=t.m_falseM,this.m_unitsM=t.m_unitsM,this.m_toleranceXY=t.m_toleranceXY,this.m_toleranceZ=t.m_toleranceZ,this.m_toleranceM=t.m_toleranceM,this.m_precision=t.m_precision,this}initialize2D(t,e){}getTolerance(t){switch(t){case 0:return this.m_toleranceXY;case 1:return this.m_toleranceZ;case 2:return this.m_toleranceM;default:return 0}}getResolution(t){if(2===this.m_precision)return 0;switch(t){case 0:return 1/this.m_unitsXY;case 1:return 1/this.m_unitsZ;case 2:return 1/this.m_unitsM;default:return 0}}getFalseX(){return this.m_falseX}getFalseY(){return this.m_falseY}getFalseZ(){return this.m_falseZ}getFalseM(){return this.m_falseM}getGridUnitsXY(){return this.m_unitsXY}getGridUnitsZ(){return this.m_unitsZ}getGridUnitsM(){return this.m_unitsM}getPrecision(){return this.m_precision}static getLimit32(){return 2147483645}static getLimit64(){return 9007199254740990n}static getLimitFloat(){return 0}getXYGridRange(){const e=new t;switch(this.m_precision){case 0:{const t=Dp.getLimit32()/this.getGridUnitsXY();e.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+t,ymax:this.getFalseY()+t})}break;case 1:{const t=Number(Dp.getLimit64())/this.getGridUnitsXY();e.setCoords({xmin:this.getFalseX(),ymin:this.getFalseY(),xmax:this.getFalseX()+t,ymax:this.getFalseY()+t})}break;case 2:e.setCoords({xmin:-Number.MAX_VALUE,ymin:-Number.MAX_VALUE,xmax:Number.MAX_VALUE,ymax:Number.MAX_VALUE});break;default:e.setEmpty(),P("")}return e}getZGridRange(){const t=new r;switch(this.m_precision){case 0:{const e=Dp.getLimit32()/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 1:{const e=Number(Dp.getLimit64())/this.getGridUnitsZ();t.setCoords(this.getFalseZ(),this.getFalseZ()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),P("")}return t}getMGridRange(){const t=new r;switch(this.m_precision){case 0:{const e=Dp.getLimit32()/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 1:{const e=Number(Dp.getLimit64())/this.getGridUnitsM();t.setCoords(this.getFalseM(),this.getFalseM()+e)}break;case 2:t.setCoords(-Number.MAX_VALUE,Number.MAX_VALUE);break;default:t.setEmpty(),P("")}return t}setTolerance(t,e){switch(e<0&&s("tol < 0"),Number.isFinite(e)||s("tol is not finite"),t){case 0:this.m_toleranceXY=e;break;case 1:this.m_toleranceZ=e;break;case 2:this.m_toleranceM=e;break;default:s("cannot set tolerance for this attribute")}}setGridParams(t,e,n){Number.isFinite(t)&&Number.isFinite(e)&&Number.isFinite(n)||s("grid params are not finite"),n<1&&s("grid units cannot be smaller than 1.0"),this.m_falseX=t,this.m_falseY=e,this.m_unitsXY=n}setZParams(t,e){Number.isFinite(t)&&Number.isFinite(e)||s("grid params are not finite"),e<1&&s("grid units cannot be smaller than 1.0"),this.m_falseZ=t,this.m_unitsZ=e}setMParams(t,e){Number.isFinite(t)&&Number.isFinite(e)||s("grid params are not finite"),e<1&&s("grid units cannot be smaller than 1.0"),this.m_falseM=t,this.m_unitsM=e}setPrecision(t){}equals(t){return this===t||j(this.m_falseX,t.m_falseX)&&j(this.m_falseY,t.m_falseY)&&this.equalsWithoutFalseXY(t)}snapPrecision(){if(2===this.m_precision)return;const t=(t,e,s,n)=>{if(!Number.isFinite(e)||!Number.isFinite(s))return s;if(s<1)return 1;if(!n)return s;const i=Number(t)/s;return Math.trunc((e+i-e)*s)>t&&(s=t/(e+i-e)),Math.max(1,s)},e=Number(0===this.m_precision?ep:sp);this.m_unitsXY=t(e,this.m_falseX,this.m_unitsXY,!0),this.m_unitsXY=t(e,this.m_falseY,this.m_unitsXY,!0),this.m_unitsZ=t(e,this.m_falseZ,this.m_unitsZ,!1),this.m_unitsM=t(e,this.m_falseM,this.m_unitsM,!1)}verifyPrecision(){if(2===this.m_precision)return!0;const t=(t,e,s,n)=>{if(s<1)return!1;if(!Number.isFinite(e)||!Number.isFinite(s))return!1;if(!n)return!0;const i=Number(t)/s;return!(BigInt((e+i-e)*s)>t)},e=0===this.m_precision?ep:sp;return!!(t(e,this.m_falseX,this.m_unitsXY,!0)&&t(e,this.m_falseY,this.m_unitsXY,!0)&&t(e,this.m_falseZ,this.m_unitsZ,!1)&&t(e,this.m_falseM,this.m_unitsM,!1))}fixTolerance(){2!==this.m_precision&&(this.m_toleranceXY=Math.max(2/this.m_unitsXY,this.m_toleranceXY),this.m_toleranceZ=Math.max(2/this.m_unitsZ,this.m_toleranceZ),this.m_toleranceM=Math.max(2/this.m_unitsM,this.m_toleranceM),(Number.isNaN(this.m_falseX)||Number.isNaN(this.m_falseY))&&(this.m_falseX=this.m_falseY=Number.NaN))}equalsWithoutFalseXY(t){return this===t||this.m_unitsXY===t.m_unitsXY&&this.m_falseZ===t.m_falseZ&&this.m_unitsZ===t.m_unitsZ&&this.m_falseM===t.m_falseM&&this.m_unitsM===t.m_unitsM&&this.m_toleranceXY===t.m_toleranceXY&&this.m_toleranceZ===t.m_toleranceZ&&this.m_toleranceM===t.m_toleranceM&&this.m_precision===t.m_precision}setBestXyDomainFromEnvelope(t,e){}setBestZDomainFromZRange(t,e,s){}setBestMDomainFromMRange(t,e,s){}}function Tp(){return(!vp||ap()&&null===vp.getPECoordSys())&&(vp=Vp(3857,0,0,!0)),vp}function Np(){return(!Ip||ap()&&null===Ip.getPECoordSys())&&(Ip=Vp(102100,0,0,!0)),Ip}function Ap(){return(!bp||ap()&&null===bp.getPECoordSys())&&(bp=Vp(4326,0,0,!0)),bp}function Mp(t){t.m_falseX=0,t.m_falseY=0,t.m_unitsXY=1,t.m_falseZ=0,t.m_unitsZ=1,t.m_falseM=0,t.m_unitsM=1,t.m_toleranceXY=100*G(),t.m_toleranceZ=100*G(),t.m_toleranceM=100*G(),t.m_precision=2}function Gp(t,e,n,i){const r=e instanceof b_;Mp(t),t.m_precision=i,t.m_falseX=Number.NaN,t.m_falseY=Number.NaN;const o=1e-4,a=.001,h=r?e.m_csType:e.isPCS?2:1;if(1===h){const s=(0===i?1/18e5:1e-9)*(r?e.getOneDegreeGCSUnit():Math.PI/e.metersOrRadiansPerUnit/180);t.m_unitsXY=1/s}else if(2===h){const s=(0===i?a:o)*(r?e.getOneMeterPCSUnit():1/e.metersOrRadiansPerUnit);t.m_unitsXY=1/s}else s("unrecognized cs type");t.m_falseM=-1e5,t.m_unitsM=1/(0===i?a:o),t.m_unitsM=Math.max(1,t.m_unitsM),t.m_unitsXY=Math.max(1,t.m_unitsXY);let m=0,l=0;0!==i&&1!==i||(m=2/t.m_unitsXY,l=2/t.m_unitsM),t.m_toleranceXY=Math.max(m,r?e.getUnitsPerMillimeter():2===h?.001/e.metersOrRadiansPerUnit:.001/(e.semiMajor*e.metersOrRadiansPerUnit)),t.m_toleranceM=Math.max(a,l),qp(t,n)}function qp(t,e){const s=1e-4,n=.001;if(t.m_falseZ=-1e5,e){const i=(0===t.m_precision?n:s)*e.getOneMeter();t.m_unitsZ=1/i}else t.m_unitsZ=1/(0===t.m_precision?n:s);t.m_unitsZ=Math.max(1,t.m_unitsZ);let i=0;0!==t.m_precision&&1!==t.m_precision||(i=2/t.m_unitsZ),t.m_toleranceZ=Math.max(e?e.getOneMeter()*n:n,i)}function Fp(t,e,s,n){Mp(t),t.m_precision=n;const i=0===n?ep:sp,r=1e-4,o=.001;let a=1,h=1,m=.001;e&&(h=e.getUnitToBaseFactor()),e&&1===e.getUnitType()?(a=400*Math.PI/180,m=8.983152841195215e-9*Math.PI/180/h):(a=(0===n?o:r)*Number(i)*.5,m=o/h),a/=h,t.m_falseX=-a,t.m_falseY=-a,t.m_unitsXY=Number(i)/(2*a),t.m_falseM=-1e5,t.m_unitsM=1/(0===n?o:r),t.m_unitsM=Math.max(1,t.m_unitsM),t.snapPrecision();let l=0,u=0;0!==t.m_precision&&1!==t.m_precision||(u=2/t.m_unitsM,l=2/t.m_unitsXY),t.m_toleranceXY=Math.max(l,m),t.m_toleranceM=Math.max(o,u),qp(t,s)}function Vp(t,e,s,n){if(!n&&e<=0){if(3857===t)return Tp();if(102100===t)return Np();if(4326===t)return Ap()}const i=new wp;let r,o=null;return ap()?(r=function(t){t<=0&&Bt(t);{const e=Q_(t);if(e)return e}const e=Jp(Hp.coordsys(t));e.get()||Bt(t);const s=Z_(e.release());return s.getLatestID()!==t&&X_.set(t,new WeakRef(s)),s}(t),e>0?o=null:e=0,i.setHorzProj_(r),i.m_vertcs=o):(r=tf(t),i.m_unit=r.isPCS?new K_(r.metersOrRadiansPerUnit):new Tm(r.metersOrRadiansPerUnit)),Gp(i.m_precisionDescriptor,r,o,1),i.m_bDefaultDescriptor=!0,i.m_userWKID=t,i.calculateHashCode(),i.initDbgName(),i}function Yp(t,e,s){return Ht((t-e)*s)/s+e}let Xp=null;const kp=3552713678800501e-30;function Rp(t,e){return function(t,e,s){return t===e||Math.abs(t-e)<=s*(1+(Math.abs(t)+Math.abs(e))/2)}(t,e,kp)}let Lp,Hp,Bp,Up,zp,Op,Wp,jp,Zp,Qp,Kp;function Jp(t){return{_this:t,get(){return this._this},reset(t){this._this=t},release(){const t=this._this;return this._this=null,t}}}let $p=null;function tf(t){n($p);const e=$p(t);return e.semiMajor=e.isPCS?Number.NaN:function(t){if(Hp&&K("pe has been loaded. no-pe methods should not be used at this point."),"string"==typeof t){const e=t.match(ef);e&&2===e.length||s("bad gcs wkt");const n=Number.parseFloat(e[1]);return Number.isFinite(n)||s("bad gcs wkt"),n}return Xp||sf(),Xp.has(t)||K("gcs wkid not found"),Xp.get(t)}(t),e}const ef=/(?:ELLIPSOID|SPHEROID)\["(?:\w|[-()])+",(\d+\.\d+)/;function sf(){Xp=new Map;for(const t in Dm){const e=Number.parseFloat(t),s=Dm[t];if(Array.isArray(s))for(const t of s)Xp.set(t,e);else Xp.set(s,e)}!function(){for(const t in Dm)delete Dm[t]}()}function nf(t,e){return new af(t,e)}const rf=Yt(0),of=Yt(1);let af=class t{constructor(e,s){if(e instanceof t)return this.m_geogTranWrapper=e.m_geogTranWrapper,this.m_bInverted=s?!e.m_bInverted:e.m_bInverted,void(this.m_hashCode=Vt(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?of:rf));this.m_geogTranWrapper=new fd(e),this.m_bInverted=s,this.m_hashCode=Vt(this.m_geogTranWrapper.getHashCode(),this.m_bInverted?of:rf)}getID(){return this.m_geogTranWrapper.getLatestId()}getLatestID(){return this.m_geogTranWrapper.getLatestId()}getText(){return this.m_geogTranWrapper.getText()}getTextExtended(t){if(!this.m_geogTranWrapper.getGeogtran())return"";if(-1===t)return this.m_geogTranWrapper.getGeogtran().toString();{const e=0===t?Bp.PE_STR_AUTH_TOP:Bp.PE_STR_AUTH_ALL;return this.m_geogTranWrapper.getGeogtran().toString(e)}}getText2(t=-1){let e=Bp.PE_STR_FMT_WKT2;return-1!==t&&(e|=0===t?Bp.PE_STR_AUTH_TOP:Bp.PE_STR_AUTH_ALL),this.m_geogTranWrapper.getGeogtran().toString(e)}getName(){return this.m_geogTranWrapper&&this.m_geogTranWrapper.getGeogtran()?this.m_geogTranWrapper.getGeogtran().getName():""}getInputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getOutputSr(!1):this.m_geogTranWrapper.getInputSr(!1)}getOutputSpatialReference(){return this.m_bInverted?this.m_geogTranWrapper.getInputSr(!1):this.m_geogTranWrapper.getOutputSr(!1)}getInverse(){return new t(this,!0)}isInverted(){return this.m_bInverted}getHashCode(){return this.m_hashCode}GetPeGeogtran(){return this.m_geogTranWrapper.getGeogtran()}equals(t){const e=t;return e===this||this.m_bInverted===e.m_bInverted&&(this.GetPeGeogtran()===e.GetPeGeogtran()||this.getID()===e.getID()&&!(0===this.getID()&&!this.GetPeGeogtran().isEqual(e.GetPeGeogtran())))}referencesMissingData(){return!!this.m_geogTranWrapper&&!this.m_geogTranWrapper.isUsable()}getWrapper(){return this.m_geogTranWrapper}};function hf(t,e,s,i,r){const o=t.getGCS(),a=e.getGCS(),h=o.getPECoordSys(),m=a.getPECoordSys();let l=null;if(!s.isEmpty()){const e=s.clone();if(!e.isEmpty()&&2===t.getCoordinateSystemType()){let s=new Ne({env2D:e});const n=T_(t,o,null);s=(new Ag).execute(s,n,null),s.queryEnvelope(e)}if(!e.isEmpty()){const t=h.getPrimem().getLongitude(),s=h.getUnit().getUnitFactor();l=new Kp(e.xmin,e.ymin,e.xmax,e.ymax,t,s)}}let u=i;u>=c()&&(u=0);const g=[];let d=Wp.PE_GTLIST_OPTS_COMMON;r||(d&=~Wp.PE_GTLIST_OPTS_USABLE);for(let t=0;t<2;t++){g.length=0;const t=u,e=Wp.getGTlist(h,m,2,d,l,t);let s=!1;if(e&&e.length>0)for(let t=0,o=e.length;t<o;t++){const o=mf([e[t]]);if(n(o),r&&o.referencesMissingData())s=!0;else if(g.push(o),i>0&&g.length===i)break}if(!s)break;0===u||(u=0)}return l&&l.destroy(),g}function mf(t){n(null!==t);const e=new uf,s=t[0].getSteps();if(s){const n=t[0].getEntries();for(let t=0;t<s;t++){const s=0!==n[t].getDirection(),i=nf(n[t].getGeogtran(),s);e.add(i)}return e.create()}return null}let lf=class{constructor(t,e,s,n){this.m_bReadOnly=!0,this.m_name="",this.m_fastTrack=-1,this.m_bNameIsSet=!1,this.m_transforms=t,e&&(this.m_name=e,this.m_bNameIsSet=!0),this.m_inputSr=s,this.m_outputSr=n}getType(){return 0}getName(){if(this.m_bNameIsSet)return this.m_name;if(0===this.m_transforms.length)return"";let t="";for(const e of this.m_transforms)t.length>0&&(t+=" + "),e.isInverted()&&(t+="~"),t+=e.getName();return t}count(){return this.m_transforms.length}createInverse(){return this.getInverse()}getHashCode(){let t=1973;for(let e=0;e<this.m_transforms.length;e++)t=Vt(t,this.m_transforms[e].getHashCode());return t}equals(t){return n(0),!1}referencesMissingData(){if(0===this.m_transforms.length)return!1;for(const t of this.m_transforms)if(t.referencesMissingData())return!0;return!1}isMatchingTransformation(t,e){return n(0),!1}validateTransformation(t,e){return n(0),!1}nameIsSet(){return n(0),!1}getInputSpatialReference(){return this.m_inputSr}getOutputSpatialReference(){return this.m_outputSr}getStep(t){return(t<0||t>this.count())&&i(""),this.m_transforms[t]}getInverse(){const t=new uf;return t.addSteps(this,!0),t.setInputSpatialReference(this.m_outputSr),t.setOutputSpatialReference(this.m_inputSr),t.create()}transform(t,e,s){if(0===this.count())return;let n=this.m_inputSr,i=this.m_outputSr;if(t&&(i=p(n,n=i)),0===this.m_transforms.length)return void xd(n,null,i,null,e,null,s);let r=this.m_fastTrack;if(1===r)return void function(t,e,s){if(t)for(let t=e.length-1;t>=0;--t)s(e[t]);else e.forEach(s)}(t,this.m_transforms,n=>{!function(t,e,s,n,i){const r=t.getVerttran(),o=t.getGeogtran();if(i>0){t.prepareOrThrow();const n=e?Bp.PE_TRANSFORM_2_TO_1:Bp.PE_TRANSFORM_1_TO_2;r?p_():f_(o,i,s,null,n)}}(n.getWrapper(),t!==n.isInverted(),e,0,s)});const o=pd();-1===r&&o.initFromGcsAndVcs(n,null);const a=pd();let h=t?this.m_transforms.length-1:0;const m=t?-1:1;for(let i=0,l=this.m_transforms.length;i<l;i++,h+=m){if(0===i){const i=this.m_transforms[h];yd(n.getPECoordSys(),null,i.getWrapper(),t!==i.isInverted(),e,null,s,a),-1===r&&(o.equals(a)||(r=0)),o.assign(a)}else{const n=this.m_transforms[h-m],i=this.m_transforms[h];Pd(o,n.getWrapper(),t!==n.isInverted(),i.getWrapper(),t!==i.isInverted(),e,null,s,a),-1===r&&(o.equals(a)||(r=0)),o.assign(a)}const l=this.m_transforms[h];Cd(o,l.getWrapper(),t!==l.isInverted(),e,null,s,a),o.assign(a)}const l=this.m_transforms[h-m];!function(t,e,s,n,i,r,o,a){const h=pd();h.assign(s?e.m_inputUnitParams:e.m_outputUnitParams),h.processUnitParams(t);let m=null;n&&(m=n.getPECoordSys());const l=pd();l.initFromGcsAndVcsPe(m,null),l.processUnitParams(h),h.processUnitParams(l),a>0&&_d(h,l,r,null,a)}(o,l.getWrapper(),t!==l.isInverted(),i,0,e,0,s),-1===r&&(a.initFromGcsAndVcs(i,null),o.equals(a)||(r=0)),this.m_fastTrack=0===r?0:1}};class uf{constructor(){this.m_transforms=[],this.m_inputGCS=null,this.m_outputGCS=null,this.m_name="",this.m_bNameIsSet=!1}getInputSpatialReference(){return null!==this.m_inputGCS?this.m_inputGCS:this.count()>0?this.m_transforms[0].getInputSpatialReference():null}setInputSpatialReference(t){this.m_inputGCS=t?t.getGCS():null}getOutputSpatialReference(){return null!==this.m_outputGCS?this.m_outputGCS:this.count()>0?this.m_transforms.at(-1).getOutputSpatialReference():null}setOutputSpatialReference(t){this.m_outputGCS=t?t.getGCS():null}getName(){if(this.m_bNameIsSet)return this.m_name;if(0===this.m_transforms.length)return"";let t="";for(const e of this.m_transforms)t.length>0&&(t+=" + "),e.isInverted()&&(t+="~"),t+=e.getName();return t}count(){return this.m_transforms.length}getStep(t){return(t<0||t>this.count())&&i(""),this.m_transforms[t]}setStep(t,e){n(0)}add(t){this.m_transforms.push(t)}addSteps(t,e){if(e)for(let e=t.count()-1;e>=0;--e)this.add(t.getStep(e).getInverse());else for(let e=0;e<t.count();++e)this.add(t.getStep(e))}clear(){this.m_transforms=[],this.m_name="",this.m_bNameIsSet=!1,this.m_inputGCS=null,this.m_outputGCS=null}remove(t){n(0)}create(){const t=this.getInputSpatialReference(),e=this.getOutputSpatialReference(),s=new lf(this.m_transforms,this.m_bNameIsSet?this.m_name:null,t,e);return s.m_bReadOnly=!0,this.clear(),s}}const cf=Object.freeze(Object.defineProperty({__proto__:null,SpatialReference:wp,SpatialReferencePrecisionDescriptor:Dp,create:lp,createFromWKT:up,createImplFromPe:cp,createLocal:dp,createWithNewPrecision:gp,createWithNewVCS:function(t,e,s){return{}},getGCS:pp,getTempName:Ep,hasNoPe:hp,hasPe:ap,injectNoPe:op,injectPe:function(t){if(Hp)return;!function(t){const e=t;Hp=e.PeFactory,n(Hp),Kp=e.PeGCSExtent,n(Kp),Zp=e.PeLineType,n(Zp),Qp=e.PeMath,n(Qp),Lp=e.PeDouble,n(Lp),Bp=e.PeDefs,n(Bp),Up=e.PeCSTransformations,n(Up),zp=e.PeGTTransformations,n(zp),Op=e.PePCSInfo,n(Op),Wp=e.PeGTlistExtended,n(Wp),Hp.initialize(),jp=e.PeGTlistExtendedEntry,n(jp),Bp.PE_TYPE_ANGUNIT=512,Bp.PE_STR_AUTH_ALL=2,Op.PE_POLE_LINE_STRAIGHT=2,Op.PE_POLE_LINE_CURVED=3,Bp.PE_PARM_LAM0=2,Bp.PE_PARM_PHI0=6,Bp.PE_PRJ_AZIMUTHAL_EQUIDISTANT=43032,Bp.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA=43033,Bp.PE_PRJ_ALBERS=43007,Bp.PE_PRJ_CYLINDRICAL_EQAREA=43034,Bp.PE_TYPE_VERTCS=8,Bp.PE_LINETYPE_GEODESIC=0,Bp.PE_LINETYPE_LOXODROME=1,Bp.PE_LINETYPE_GREAT_ELLIPTIC=2,Bp.PE_LINETYPE_NORMAL_SECTION=3,Wp.PE_GTLIST_OPTS_USABLE=1,$p=null}(t);const e=tp;tp=null,e.forEach(t=>{const e=t.deref();e&&e.attachToPe()})},isInitialized:mp,isTempName:Sp,isValidWkid:fp,isValidWkt:xp,makeSpheroidData:rp,snapGeometry:_p,webMercator:Tp,webMercator102100:Np,wgs84:Ap},Symbol.toStringTag,{value:"Module"})),gf=Object.freeze(Object.defineProperty({__proto__:null,OperatorProject:Ag},Symbol.toStringTag,{value:"Module"})),df=Object.freeze(Object.defineProperty({__proto__:null,CompositeGeographicTransformation:lf,CompositeGeographicTransformationEditor:uf,createImpl:mf,queryGtListImpl:hf},Symbol.toStringTag,{value:"Module"})),_f=Object.freeze(Object.defineProperty({__proto__:null,GeographicTransformation:af,create:function(t,e){const s=Hp.geogtran(t);return s||Bt(t),new af(s,e)},createFromPe:nf,createFromWKT:function(t,e){const s=Hp.fromString(Bp.PE_TYPE_GEOGTRAN,t);return s||le(t),new af(s,e)}},Symbol.toStringTag,{value:"Module"})),pf=Object.freeze(Object.defineProperty({__proto__:null,ProjectionTransformation:Y_,create:function(e,s,n){return D_(e,s,t.constructEmpty(),n)},createEx:T_,createFromAoi:D_,createImplEx:N_,makeExtendedParams:M_,makeExtendedParamsInternal:q_,queryTransformationList:A_},Symbol.toStringTag,{value:"Module"}));export{id as $,Od as A,Ld as B,Tc as C,lh as D,Vr as E,s_ as F,Ag as G,Lp as H,Zp as I,Up as J,Sm as K,pm as L,Fs as M,T_ as N,Dd as O,Tr as P,Vm as Q,Qp as R,fm as S,Jc as T,Gg as U,qg as V,dp as W,Nm as X,I_ as Y,bd as Z,Pm as _,up as a,ah as a$,zd as a0,Rp as a1,nd as a2,Yg as a3,Xg as a4,Fg as a5,Vg as a6,rd as a7,Jd as a8,Qm as a9,Jl as aA,Sd as aB,vd as aC,ki as aD,Ep as aE,Hp as aF,$d as aG,Wm as aH,As as aI,Ts as aJ,Uc as aK,ap as aL,Zl as aM,_p as aN,Gc as aO,Ac as aP,Dc as aQ,Sc as aR,ng as aS,_n as aT,nh as aU,sh as aV,eh as aW,Mr as aX,ll as aY,ul as aZ,Jm as a_,Za as aa,Bm as ab,Um as ac,km as ad,vg as ae,Zm as af,Hm as ag,e_ as ah,Bp as ai,t_ as aj,l_ as ak,qm as al,jd as am,pc as an,q_ as ao,M_ as ap,N_ as aq,Md as ar,x_ as as,Rr as at,pn as au,Yr as av,Hr as aw,Dn as ax,oh as ay,Kl as az,Wn as b,$n as b0,Jn as b1,po as b2,Ds as b3,$r as b4,jc as b5,op as b6,xp as b7,fp as b8,gd as b9,Dp as ba,gp as bb,jo as bc,zh as bd,Oh as be,Xh as bf,Ch as bg,Rn as bh,xm as bi,cf as bj,gf as bk,df as bl,_f as bm,pf as bn,lp as c,xg as d,ig as e,wm as f,Id as g,Ed as h,kr as i,wc as j,bc as k,Ec as l,Bc as m,Ar as n,Ad as o,Oc as p,_c as q,du as r,ag as s,ws as t,Eg as u,vc as v,Ul as w,xc as x,rp as y,Qn as z};
