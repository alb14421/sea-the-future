/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{A as e,T as t,D as r}from"./TimeOnly.js";import s from"../core/Error.js";import"../core/lang.js";import{fromJSON as i}from"../geometry/support/jsonUtils.js";import n from"../layers/support/FieldsIndex.js";import{l as a}from"../layers/support/fieldUtils.js";import{u as o,s as c}from"./constants.js";const l=["geometry","scale","timeProperties"];function u(e,t){if(null!=t)for(const r of l)t.hasArcadeDependency(r)&&e.add(r);return e}function d(e,t){return m.create(e,t,null,["$feature","$view"])}function h(e,t){return m.create(e,t,null,["$feature","$view"])}function p(e,t,r){return m.create(e,t,r,["$feature","$view","$config"])}class m{static async create(e,t,r,i){const{arcade:n,Dictionary:o}=await a();let c;try{c=n.parseScript(e)}catch(t){throw new s("arcade-bad-expression","Failed to parse arcade script",{script:e,error:t})}const l=n.scriptUsesGeometryEngine(c);l&&await n.enableGeometrySupport(),await n.loadDependentModules(new Set,c,null,!1,l);const u={vars:i.reduce((e,t)=>({...e,[t]:null}),{}),spatialReference:t,useAsync:!1},d=n.compileScript(c,u);let h=null;null!=r&&(h=new o(r),h.immutable=!0);const p=new o;return p.immutable=!1,p.setField("scale",0),new m(e,n,c,d,t,p,h,o)}constructor(e,t,r,s,i,n,a,o){this.script=e,this._arcade=t,this._syntaxTree=r,this._compiled=s,this._spatialReference=i,this._viewDict=n,this._configDict=a,this._dictionaryCtor=o,this._dependencies=new Map,this._featureReader=new f,this._dependencies.set("geometry",t.scriptTouchesGeometry(this._syntaxTree)),this._dependencies.set("scale",this._arcade.referencesMember(this._syntaxTree,"scale")),this._dependencies.set("timeProperties",this._arcade.scriptUsesViewProperties(this._syntaxTree,["timeProperties"]))}evaluate(t,r){const s=r.$view?.timeZone;if(r.$view){let t;if(this._viewDict.setField("scale",r.$view.scale),null!=r.$view.timeProperties){const{currentStart:i,currentEnd:n}=r.$view.timeProperties;t=new this._dictionaryCtor({currentStart:null!=i?null!=s?e.epochToArcadeDate(i,s):e.unknownEpochToArcadeDate(i):void 0,currentEnd:null!=n?null!=s?e.epochToArcadeDate(n,s):e.unknownEpochToArcadeDate(n):void 0,startIncluded:!0,endIncluded:!0})}this._viewDict.setField("timeProperties",t)}return this._compiled({vars:{$view:this._viewDict,$config:this._configDict,$feature:t},spatialReference:this._spatialReference,timeZone:s})}repurposeFeature(e,t){return this._featureReader.bind(e,t,this._spatialReference),this._featureReader}references(e){return this._dependencies.get(e)??!1}}class f{constructor(){this._boundTarget=null,this._boundSchema={fields:null,fieldsIndex:null,spatialReference:null,get geometryType(){return null},get objectIdField(){return null}},this.arcadeDeclaredClass="esri.arcade.Feature",this._contextTimeZone=null}bind(e,t,r){const s=t??new n(_(e.attributes));this._boundTarget=e,this._boundSchema.fields=s.fields,this._boundSchema.fieldsIndex=s,this._boundSchema.spatialReference=r}_getField(e){return this._boundSchema.fieldsIndex.get(e)}get contextTimeZone(){return this._contextTimeZone}set contextTimeZone(e){this._contextTimeZone=e}readArcadeFeature(){return this}hasField(e){return this._boundSchema.fieldsIndex.has(e)}geometry(){if("fromJSON"in this._boundTarget)return this._boundTarget.geometry;const e=i(this._boundTarget.geometry);if(e){if(!this._boundSchema.spatialReference)throw new Error("InternalError: Expected spatial reference to be defined");e.spatialReference=this._boundSchema.spatialReference}return e}isUnknownDateTimeField(e){return this._boundSchema.fieldsIndex.getTimeZone(e)===o}field(s,i=!0){const n=this._getField(s);if(n){const i=this._boundTarget.attributes[n.name];if(null==i)return null;switch(n.type){case"date-only":case"esriFieldTypeDateOnly":return r.fromReader(i);case"time-only":case"esriFieldTypeTimeOnly":return t.fromReader(i);case"esriFieldTypeTimestampOffset":case"timestamp-offset":return e.fromReaderAsTimeStampOffset(i);case"date":case"esriFieldTypeDate":return this.isUnknownDateTimeField(s)?e.unknownEpochToArcadeDate(i):e.epochToArcadeDate(i,this.contextTimeZone??c);default:return i}}if(i)throw new Error(`Field ${s} does not exist`);return null}setField(e,t){throw new Error("Unable to update feature attribute values, feature is readonly")}keys(){return this._boundSchema.fieldsIndex.fields.map(e=>e.name)}castToText(e=!1){return JSON.stringify(this._boundTarget)}gdbVersion(){return null}fullSchema(){return this._boundSchema}castAsJson(e=null){return{attributes:this._boundTarget.attributes,geometry:!0===e?.keepGeometryType?this.geometry():this.geometry()?.toJSON()??null}}castAsJsonAsync(e=null,t=null){return Promise.resolve(this.castAsJson(t))}}function _(e){const t=[];for(const r in e)t.push({name:r,alias:r,type:"string"==typeof e[r]?"esriFieldTypeString":"esriFieldTypeDouble"});return t}export{f as A,d as a,h as b,p as c,_ as d,u as e};
