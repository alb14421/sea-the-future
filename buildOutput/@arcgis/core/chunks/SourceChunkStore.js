/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{h as e}from"../core/lang.js";import{d as t}from"./memoryEstimations.js";import{O as s}from"./OptimizedGeometry.js";import{Q as r}from"./parquet.js";import{i,b as n,c as o,a}from"./FeatureMetadata.js";import{EventEmitter as h}from"../core/Evented.js";import{c as d}from"./aaBoundingBox.js";import{r as u}from"./rbush.js";import{r as l}from"./mathUtils.js";import c from"../geometry/Polygon.js";import _ from"../geometry/SpatialReference.js";import{t as f}from"./aaBoundingRect.js";import{m as g,J as p,x as m}from"./unitUtils.js";import{t as y,v as x,q as I,m as v,w as b,a as w}from"./featureConversionUtils.js";import{p as T}from"./projectionSupport.js";import{p as k}from"./definitions.js";import{c as W}from"./arcadeUtils.js";import{n as M,f as S,g as j}from"./quantizationUtils.js";class F{constructor(e){this._statistics=e}get statistics(){return this._statistics}}const C=Math.PI/180;class G{static create(e){return new G(e.map(e=>function(e){switch(e.statisticType){case"min":return new O(e);case"max":return new U(e);case"avg":return new B(e);case"avg_angle":return new D(e);case"sum":case"count":return new z(e);case"mode":return new E(e)}}(e)))}constructor(e){this._statistics=e}values(){return this._statistics.values()}insert(e,t){for(const s of this._statistics)s.insert(e,t)}merge(e){for(let t=0;t<this._statistics.length;t++){const s=this._statistics[t],r=e._statistics[t];if(s.field.name!==r.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");s.merge(r)}}clone(){return new G(this._statistics.map(e=>e.clone()))}}class A{constructor(e){this.field=e}insert(e,t){if(!this.field.computed)return;const s=this.field.computed.read(e,t);i(s)||this._insertValue(s)}}class O extends A{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue(e){this.value=Math.min(this.value,e)}merge(e){this.value=Math.min(this.value,e.value)}clone(){const e=new O(this.field);return e.value=this.value,e}}class U extends A{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue(e){this.value=Math.max(this.value,e)}merge(e){this.value=Math.max(this.value,e.value)}clone(){const e=new U(this.field);return e.value=this.value,e}}class z extends A{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue(e){this.value+=e}merge(e){this.value+=e.value}clone(){const e=new z(this.field);return e.value=this.value,e}}class B extends A{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue(e){this._total+=e,this._count+=1}merge(e){this._total+=e._total,this._count+=e._count}clone(){const e=new B(this.field);return e._total=this._total,e._count=this._count,e}}class D extends A{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const e=this._x/this._count,t=this._y/this._count,s=180/Math.PI;return Math.atan2(t,e)*s}_insertValue(e){this._x=this._x+Math.cos(e*C),this._y=this._y+Math.sin(e*C),this._count+=1}merge(e){this._x+=e._x,this._y+=e._y,this._count+=e._count}clone(){const e=new D(this.field);return e._x=this._x,e._y=this._y,e._count=this._count,e}}class E extends A{constructor(){super(...arguments),this._frequencies=new Map}get value(){let e,t=0;for(const[s,r]of this._frequencies.entries())r>t&&(t=r,e=s);return e}_insertValue(e){const t=this._frequencies.get(e);null!=t?this._frequencies.set(e,t+1):this._frequencies.set(e,1)}merge(e){for(const[t,s]of e._frequencies.entries()){const e=this._frequencies.get(t);null!=e?this._frequencies.set(t,e+s):this._frequencies.set(t,s)}}clone(){const e=new E(this.field);return e._frequencies=new Map(this._frequencies),e}}class X extends F{static createId(e,t){return`${e}.${t}`}static create(e,t,s,r){return new X(e,t,G.create(s),r)}constructor(e,t,s,r){super(s),this.gridX=e,this.gridY=t,this._worldUnitsPerCell=r,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._objectIds=new Set}get id(){return X.createId(this.gridX,this.gridY)}get containedObjectIds(){return this._objectIds}get count(){return this._count}get firstObjectId(){return this._objectIds.values().next().value}get centroidXWorld(){return this._xWorldTotal/this._count}get centroidYWorld(){return this._yWorldTotal/this._count}clone(){const e=new X(this.gridX,this.gridY,this._statistics.clone(),this._worldUnitsPerCell);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._firstFeatureAttributes=this._firstFeatureAttributes,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r){0===this._count?this._firstFeatureAttributes=e.readAttributes():this._firstFeatureAttributes=null,this._count+=1,this._xWorldTotal+=s,this._yWorldTotal+=r,this._statistics.insert(e,t),this._objectIds.add(e.getObjectId())}merge(e){if(0!==e._count){this._count+=e._count,this._firstFeatureAttributes=e._firstFeatureAttributes,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroidX(e){return null==e?this.centroidXWorld:y(e,this.centroidXWorld)}getCentroidY(e){return null==e?this.centroidYWorld:x(e,this.centroidYWorld)}getGeometry(e,t){const r=this.gridX*this._worldUnitsPerCell,i=this.gridY*this._worldUnitsPerCell,n=new s([4],[r,i,r+this._worldUnitsPerCell,i,r+this._worldUnitsPerCell,i+this._worldUnitsPerCell,r,i+this._worldUnitsPerCell]);if(null!=t){const e=new s;return I(e,n,!1,!1,"esriGeometryPolygon",t)}return n}getCentroid(e){const t=new s([],[this.centroidXWorld,this.centroidYWorld]);if(null!=e){const r=new s;return I(r,t,!1,!1,"esriGeometryPoint",e)}return t}getGeometricCentroid(e,t){const r=this.gridX*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,i=this.gridY*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,n=new s([],[r,i]);if(null!=t){const e=new s;return I(e,n,!1,!1,"esriGeometryPoint",t)}return n}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return null!=this._firstFeatureAttributes?{...e,...this._firstFeatureAttributes}:e}}class Y{constructor(e){this._options=e}insert(e,t){const s=e.getCursor(),{arcadeContextInfo:r,scale:i}=this._options,n=W(i,r);for(;s.next();)this._insertFeature(s,n,this._options.sqlOptions,t)}_insertFeature(e,t,s,r){const{featureFilter:i}=this._options;if(null!==i&&!i.check(e,s))return;let n=0,o=0;if("esriGeometryPoint"===e.geometryType)n=e.readXWorldSpace(),o=e.readYWorldSpace();else{if(r){const t=e.readCentroidForDisplay();if(null==t)return;const[s,r]=t.coords;if(s<0||s>k||r<0||r>k)return}const t=e.readCentroidWorldSpace();if(null==t)return;n=t.coords[0],o=t.coords[1]}this._insert(e,n,o,t)}}function P(e,t){return g(e)*p*96/t}class L extends Y{constructor(e){super(e),this._cells=new Map,this._pixelsPerMapUnit=P(e.spatialReference,e.scale)}put(e){for(const t of this._cells.values()){const s=e.get(t.id);s?s.merge(t):e.set(t.id,t.clone())}}putBounded(e,t,s){const r=[t.xmin,t.ymin,t.xmax,t.ymax],[i,n,o,a]=r,h=Math.floor(i*this._pixelsPerMapUnit/this._options.cellSize),d=Math.floor(n*this._pixelsPerMapUnit/this._options.cellSize),u=Math.ceil(o*this._pixelsPerMapUnit/this._options.cellSize),l=Math.ceil(a*this._pixelsPerMapUnit/this._options.cellSize);for(let t=d;t<=l;t++)for(let s=h;s<=u;s++){const r=`${s}.${t}`,i=this._cells.get(r);if(!i)continue;const n=e.get(i.id);n?i&&!e.has(i.id)&&n.merge(i):e.set(i.id,i.clone())}}_insert(e,t,s,r){const i=t*this._pixelsPerMapUnit,n=s*this._pixelsPerMapUnit,o=Math.floor(i/this._options.cellSize),a=Math.floor(n/this._options.cellSize);this._getCellOrCreate(o,a).insert(e,r,t,s)}_getCellOrCreate(e,t){const s=X.createId(e,t);let r=this._cells.get(s);if(!r){const i=1*this._options.cellSize/this._pixelsPerMapUnit;r=X.create(e,t,this._options.fields,i),this._cells.set(s,r)}return r}}class q{static fromReader(e){const t=[],s=e.copy(),r=d();for(;s.next();)s.getBounds(r)&&t.push(s.getIndex());const i=u(9,e=>(s.setIndex(e),{minX:s.getBoundsXMin(),minY:s.getBoundsYMin(),maxX:s.getBoundsXMax(),maxY:s.getBoundsYMax()}));return i.load(t),new q(i)}constructor(e){this._index=e}search(e){const t={minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]};return this._index.search(t)}}function N(e,t,s,r){if(r.isWebMercator){const r=l(e/m.radius),i=r-360*Math.floor((r+180)/360),n=[0,0];return R(n,0,l(Math.PI/2-2*Math.atan(Math.exp(-t/m.radius))),i,s),n}const i=T({x:e,y:t},r,_.WGS84);if(!i)return null;const n=[0,0];return R(n,0,i.y,i.x,s),n}function R(e,t,s,r,i){i%2&&(i+=1);let n=0,o=0,a=-90,h=90,d=-180,u=180;for(let e=0;e<i/2;e++){for(let t=0;t<5;t++){const s=(d+u)/2,i=r>s?1:0;n|=i<<29-(t+5*e),d=(1-i)*d+i*s,u=(1-i)*s+i*u}for(let t=0;t<5;t++){const r=(a+h)/2,i=s>r?1:0;o|=i<<29-(t+5*e),a=(1-i)*a+i*r,h=(1-i)*r+i*h}}e[2*t]=n,e[2*t+1]=o}class $ extends F{static create(e,t,s,r){const i=G.create(e),n=new Array(32);for(let e=0;e<n.length;e++)n[e]=null;return new $(i,t,s,r,n)}constructor(e,t,s,r,i){super(e),this.xNode=t,this.yNode=s,this.depth=r,this.children=i,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}get id(){return`${this.xNode}.${this.yNode}`}get containedObjectIds(){return this._objectIds}get count(){return this._count}clone(){const e=new $(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._xGeohashTotal=this._xGeohashTotal,e._yGeohashTotal=this._yGeohashTotal,e.next=this.next,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r,i,n){this._count+=1,this._xWorldTotal+=t,this._yWorldTotal+=s,this._xGeohashTotal+=r,this._yGeohashTotal+=i,this._statistics.insert(e,n),this._objectIds.add(e.getObjectId())}merge(e){if(0!==e._count){this._count+=e._count,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._xGeohashTotal+=e._xWorldTotal,this._yGeohashTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroid(e){throw new Error("getCentroid not supported for GeohashNode")}getGeometry(e,t){const r=this._getLngLatBounds(),[i,n,o,a]=r,h=T({rings:[[[i,n],[i,a],[o,a],[o,n],[i,n]]]},_.WGS84,e),d=v(new s,h,!1,!1);return null!=t?I(new s,d,!1,!1,"esriGeometryPolygon",t,!1,!1):d}getGeometricCentroid(e,t){const r=this._getLngLatBounds(),[i,n,o,a]=r,h=T({x:(i+o)/2,y:(n+a)/2},_.WGS84,e),d=b(new s,h);return null!=t?I(new s,d,!1,!1,"esriGeometryPoint",t,!1,!1):d}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return e.aggregateCount=this._count,e}find(e,t,s,r,i,n){if(r>=s)return this;const o=1-r%2,a=3*o+2*(1-o),h=2*o+3*(1-o),d=30-i-a,u=30-n-h,l=((e&7*o+3*(1-o)<<d)>>d)+((t&3*o+7*(1-o)<<u)>>u)*(8*o+4*(1-o)),c=this.children[l];return null==c?null:c.find(e,t,s,r+1,i+a,n+h)}_getLngLatBounds(){const e=this.depth,t=Math.ceil(e/2),s=Math.floor(e/2),r=30-(3*t+2*s),i=30-(2*t+3*s);return function(e,t){let s=-90,r=90,i=-180,n=180;for(let o=0;o<t;o++){const t=Math.ceil((o+1)/2),a=Math.floor((o+1)/2),h=1-o%2,d=30-(3*t+2*a),u=30-(2*t+3*a),l=2*h+3*(1-h),c=(7*h+3*(1-h)<<d&e.geohashX)>>d,_=(3*h+7*(1-h)<<u&e.geohashY)>>u;for(let e=3*h+2*(1-h)-1;e>=0;e--){const t=(i+n)/2,s=c&1<<e?1:0;i=(1-s)*i+s*t,n=(1-s)*t+s*n}for(let e=l-1;e>=0;e--){const t=(s+r)/2,i=_&1<<e?1:0;s=(1-i)*s+i*t,r=(1-i)*t+i*r}}return[i,s,n,r]}({geohashX:this.xNode<<r,geohashY:this.yNode<<i},this.depth)}}class V{constructor(e){this._fields=e,this._size=0,this._depth=0,this._root=$.create(this._fields,0,0,0)}destroy(){}get size(){return this._size}get depth(){return this._depth}find(e,t,s){return this._root.find(e,t,s,0,0,0)}insert(e,t,s,r,i,n,o){let a=this._root,h=0,d=0,u=0;for(;null!==a;){if(a.insert(e,t,s,r,i,o),h>=n)return;const l=Math.ceil((h+1)/2),c=Math.floor((h+1)/2),_=1-h%2,f=30-(3*l+2*c),g=30-(2*l+3*c),p=(r&7*_+3*(1-_)<<f)>>f,m=(i&3*_+7*(1-_)<<g)>>g,y=p+m*(8*_+4*(1-_));d=d<<3*_+2*(1-_)|p,u=u<<2*_+3*(1-_)|m,null==a.children[y]&&(a.children[y]=$.create(this._fields,d,u,h+1),this._depth=Math.max(this._depth,h+1),this._size+=1),h+=1,a=a.children[y]}}putBins(e,t){for(const s of this.getNodes(t)){const t=e.get(s.id);t?t.merge(s):e.set(s.id,s.clone())}}getNodes(e){const t=[],{geohashBounds:s,level:r}=e;let i=this._root;for(;null!==i;){const e=i.depth,n=i.xNode,o=i.yNode;if(e>=r){t.push(i),i=i.next;continue}const a=Math.ceil((e+1)/2),h=Math.floor((e+1)/2),d=1-e%2,u=30-(3*a+2*h),l=30-(2*a+3*h),c=~((1<<u)-1),_=~((1<<l)-1),f=(s.xLL&c)>>u,g=(s.yLL&_)>>l,p=(s.xTR&c)>>u,m=(s.yTR&_)>>l,y=n<<3*d+2*(1-d),x=o<<2*d+3*(1-d),I=y+8*d+4*(1-d),v=x+4*d+8*(1-d),b=Math.max(y,f),w=Math.max(x,g),T=Math.min(I,p),k=Math.min(v,m);let W=null,M=null;for(let e=w;e<=k;e++)for(let t=b;t<=T;t++){const s=t-y+(e-x)*(8*d+4*(1-d)),r=i.children[s];r&&(W||(W=r,W.next=i.next),M&&(M.next=r),M=r,r.next=i.next)}i=W||i.next}return t}}class Z extends Y{constructor(e){super(e),this._tree=new V(this._options.fields)}put(e){throw new Error("Geohash tree does not support put")}putBounded(e,t,r){const{geohashLevel:i,spatialReference:n}=this._options,o=function(e,t,r,i){const n=[e.xmin,e.ymin,e.xmax,e.ymax],o=c.fromExtent(f(n,i)),a=T(o,i,_.WGS84,{densificationStep:64*t});if(!a)return null;const h=v(new s,a,!1,!1),d=h.coords.filter((e,t)=>!(t%2)),u=h.coords.filter((e,t)=>t%2),l=Math.min(...d),g=Math.min(...u),p=Math.max(...d),m=Math.max(...u),y=N(l,g,r,_.WGS84),x=N(p,m,r,_.WGS84);return y&&x?{bounds:n,geohashBounds:{xLL:y[0],yLL:y[1],xTR:x[0],yTR:x[1]},level:r}:null}(t,r,i,n);null!=o&&this._tree.putBins(e,o)}_insert(e,t,s,r){const{geohashLevel:i,spatialReference:n}=this._options,o=N(t,s,i,n);o&&this._tree.insert(e,t,s,o[0],o[1],i,r)}}class H extends n{static from(e,t){if(e instanceof this){const s=new Set(t),r=e._indices.filter(e=>s.has(e));return new H(e._reader,r)}return new H(e.copy(),t)}constructor(e,t){super(e.metadata),this._currentIndex=-1,this._displayTransform=null,this._reader=e,this._indices=t}setTransformForDisplay(e){const t=this._reader.getInTransform();if(null==t)return void(this._displayTransform=M(e));const s=M(t),r=M(e),[i,n]=s.scale,[o,a]=s.translate,[h,d]=r.scale,[u,l]=r.translate,c=i/h,_=n/d,f=(o-u)/h,g=(a-l)/d;this._displayTransform={originPosition:"lowerLeft",scale:[1/c,1/_,1,1],translate:[-f/c,-g/_,0,0]}}getInTransform(){return this._reader.getInTransform()}get fields(){return this._reader.fields}get hasNext(){return this._currentIndex+1<this._indices.length}getSize(){return this._indices.length}getCursor(){return this.copy()}copy(){const e=new H(this._reader.copy(),this._indices);return e._currentIndex=this._currentIndex,e._displayTransform=this._displayTransform,e._processorAttributes=this._processorAttributes,e}get contextTimeZone(){return this._reader.contextTimeZone}set contextTimeZone(e){this._reader.contextTimeZone=e}get usedMemory(){return t+this._reader.usedMemory}setProcessorAttributes(e){this._processorAttributes=Object.assign(this._processorAttributes??{},e)}_nextIndex(){return++this._currentIndex<this._indices.length&&(this._reader.setIndex(this._indices[this._currentIndex]),!0)}next(){for(;this._nextIndex()&&!this._reader._getExists(););return this._currentIndex<this._indices.length}readXForDisplay(){return this._displayTransform?S(this._displayTransform,this._reader.readXForDisplay()):this._reader.readXForDisplay()}readYForDisplay(){return this._displayTransform?j(this._displayTransform,this._reader.readYForDisplay()):this._reader.readYForDisplay()}readGeometryForDisplay(){return this._displayTransform?this._reader.readGeometryForDisplayTransformed(this._displayTransform):this._reader.readGeometryForDisplay()}readCentroidForDisplay(){const e=this._reader.readCentroidForDisplay()?.clone();if(e){const[t,s]=e.coords;this._displayTransform?(e.coords[0]=S(this._displayTransform,t),e.coords[1]=j(this._displayTransform,s)):(e.coords[0]=t,e.coords[1]=s)}return e}get geometryType(){return this._reader.geometryType}get hasFeatures(){return this._reader.hasFeatures}get exceededTransferLimit(){return this._reader.exceededTransferLimit}get hasZ(){return this._reader.hasZ}get hasM(){return this._reader.hasM}readAttribute(e,t=!1){const s=this._reader.readAttribute(e,t);return null==s&&this._processorAttributes?this._processorAttributes[e]:s}readAttributes(){return{...this._processorAttributes??{},...this._reader.readAttributes()}}joinAttributes(e){return this._reader.joinAttributes(e)}getBounds(e){return this._reader.getBounds(e)}getAttributeHash(){return this._reader.getAttributeHash()}getObjectId(){return this._reader.getObjectId()}getDisplayId(){return this._reader.getDisplayId()}setDisplayId(e){return this._reader.setDisplayId(e)}setIndex(e){return this._reader.setIndex(e)}getIndex(){return this._reader.getIndex()}readXWorldSpace(){return this._reader.readXWorldSpace()}readYWorldSpace(){return this._reader.readYWorldSpace()}_readX(){return this._reader.readXForDisplay()}_readY(){return this._reader.readYForDisplay()}_readServerCentroid(){return this._reader._readServerCentroid()}readLegacyFeatureForDisplay(){const e=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:(e&&{x:e.coords[0],y:e.coords[1]})??null}}readLegacyGeometryForDisplay(){const e=this.readGeometryForDisplay();return w(e,this.geometryType,!1,!1)}readGeometryArea(){return this._displayTransform?this._reader.readGeometryForDisplayTransformed(this._displayTransform)?.area()??0:this._reader.readGeometryArea()}readGeometryWorldSpace(){return this._reader.readGeometryWorldSpace()}_readGeometry(){return this._reader._readGeometry()}_readAttribute(e,t){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}_readAttributes(){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}readArcadeFeature(){return this._reader.readArcadeFeature()}geometry(){return this._reader.geometry()}field(e){return this._reader.field(e)}hasField(e){return this._reader.hasField(e)}setField(e,t){return this._reader.setField(e,t)}keys(){return this._reader.keys()}castToText(e=!1){return this._reader.castToText(e)}}class J{size(){return this.reader.getSize()}get fields(){return this.reader.fields}invalidate(){this._aggregateIndex=null,this._aggregateIndexHash=null,this._spatialIndex=null}registerOverrides(e){this.reader.registerOverrides(e),this.invalidate()}queryFeaturesInBounds(e){const t=this._getSpatialIndex().search(e);return H.from(this.reader,t)}getAggregateIndex(e){const t=JSON.stringify(e);if(t!==this._aggregateIndexHash){switch(this._aggregateIndexHash=t,e.type){case"grid":this._aggregateIndex=new L(e);break;case"geohash":this._aggregateIndex=new Z(e)}this._aggregateIndex.insert(this.reader,this.isTiled)}return this._aggregateIndex}_getSpatialIndex(){return this._spatialIndex||(this._spatialIndex=q.fromReader(this.reader)),this._spatialIndex}}class Q{constructor(){this.modified=[],this.removed=[]}modify(e){this.modified.push(e)}remove(e){this.removed.push(e)}get isEmpty(){return 0===this.modified.length&&0===this.removed.length}}class K extends J{constructor(e){super(),this._reader=e,this.chunkId="override",this.normalizedChunkId="override"}static fromFeatures(e,t){const s=o.fromOptimizedFeatures(e,t);return new K(s)}get reader(){return this._reader}get queryInfo(){return{}}get first(){return!1}get end(){return!1}get isTiled(){return!1}getTileReader(e){if(!this._reader.getSize())return null;const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}}class ee{constructor(e,t){this.inner=e,this.isWeak=t,this.lastWeak=null}get isStrong(){return!this.isWeak}}class te{constructor(){this._overrides=new Map,this._update=new Q,this._lastCleanup=0}hasOverride(e){return this._overrides.has(e)}onChunkInsert(e){if(this._overrides.size){const t=e.reader.getCursor();for(;t.next();){const e=t.getObjectId(),s=this._overrides.get(e);if(s?.lastWeak&&(s.lastWeak=null),s?.isWeak){const e=t.readOptimizedFeatureWorldSpace();s.inner=e,this._update.modify(e),this.invalidate()}}}e.registerOverrides(this)}apply(e,t){const{updateWeak:s,removeWeak:r,update:i,remove:n,release:o}=e.commands;this.invalidate();for(const e of s){const t=new ee(e,!0),s=this._overrides.get(e.objectId);s?.isStrong?s.lastWeak=t:(this._overrides.set(e.objectId,t),this._update.modify(e))}for(const e of i){const t=new ee(e,!1),s=this._overrides.get(e.objectId);t.lastWeak=s?.isWeak?s:s?.lastWeak??null,this._overrides.set(e.objectId,t),this._update.modify(e)}for(const e of r){const t=new ee(null,!0),s=this._overrides.get(e);s?.isStrong?s.lastWeak=t:(this._overrides.set(e,t),this._update.remove(e))}for(const e of n){const t=new ee(null,!1),s=this._overrides.get(e);t.lastWeak=s?.isWeak?s:s?.lastWeak??null,this._overrides.set(e,t),this._update.remove(e)}if(o.length){const e=new Set;for(const t of o){const s=this._overrides.get(t);s?.lastWeak?(this._overrides.set(t,s.lastWeak),null==s.lastWeak.inner?this._update.remove(t):this._update.modify(s.lastWeak.inner)):s&&!s.isWeak&&(this._overrides.delete(t),e.add(t))}t.forEachUnsafe(t=>{const s=t.getObjectId();e.has(s)&&(this._update.modify(t.readOptimizedFeatureWorldSpace()),e.delete(s))});for(const t of e.values())this._update.remove(t)}}clearWeakOverrides(){for(const[e,t]of this._overrides.entries())t.isWeak&&this._overrides.delete(e);this.invalidate()}cleanup(e){if(this._overrides.size<1e4)return;const t=performance.now();if(t-this._lastCleanup<1e3)return;this._lastCleanup=t;const s=this._getWeakDeletions();if(!(s.size<1e4)){for(const t of e){const e=t.reader.withoutOverrides().getCursor();for(;e.next();){const t=e.getObjectId();s.delete(t)}}for(const e of s)this._overrides.delete(e);s.size&&this.invalidate()}}takeOverrideUpdate(){const e=this._update;return e.isEmpty?null:(this._update=new Q,e)}asChunk(e){if(!this._chunk){const t=[];for(const e of this._overrides.values())null!=e.inner&&t.push(e.inner);this._chunk=K.fromFeatures(t,e)}return this._chunk}invalidate(){this._chunk=null}putWeakObjectIdsFromGlobalIds(e,t,s){for(const[r,i]of this._overrides.entries()){if(i.isWeak&&null!=i.inner){const n=i.inner.attributes[s];n&&t.has(n)&&!e.has(n)&&e.set(n,r);continue}if(null!=i.lastWeak&&null!=i.lastWeak.inner){const n=i.lastWeak.inner.attributes[s];n&&t.has(n)&&!e.has(n)&&e.set(n,r)}}}_getWeakDeletions(){const e=new Set;for(const[t,s]of this._overrides.entries())s.isWeak&&null==s.inner&&e.add(t);return e}}class se extends J{constructor(e,t,s,r){super(),this._reader=e,this._queryJSON=t,this._page=s,this._end=r,this.chunkId=`${this._page}${this.end?"e":""}`,this.normalizedChunkId=this.chunkId}get reader(){return this._reader}get first(){return 0===this._page}get end(){return this._end}get queryInfo(){return{type:"snapshot",chunkId:this.chunkId,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(e){const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}}let re;class ie extends n{constructor(e,s,r,i,n=new Uint32Array(r.size())){super(e),this._fields=s,this._inner=r,this._chunkId=i,this._displayIds=n,this._index=-1,this.usedMemory=t,this._size=this._inner.size(),e.featureIdInfo.type,this._chunkId>65535&&console.error("Exceeded max allowed parquet reader size")}destroy(){super.destroy(),this._inner.free()}get fields(){return this._fields}get geometryType(){return this.metadata.geometryType}get hasFeatures(){return!0}get hasNext(){throw new Error("Method not implemented.")}get exceededTransferLimit(){return!1}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return null}getSize(){return this._size}getCursor(){return this.copy()}getAttributeHash(){let e="";for(const t of this.fields.fields)e+=this._readAttribute(t.name,!1)+".";return e}getObjectId(){return this._inner.rowId(this._index)}getDisplayId(){return this._displayIds[this._index]}setDisplayId(e){this._displayIds[this._index]=e}setIndex(e){this._index=e}getBoundsXMin(){return this._inner.boundsXMin(this._index)}getBoundsYMin(){return this._inner.boundsYMin(this._index)}getBoundsXMax(){return this._inner.boundsXMax(this._index)}getBoundsYMax(){return this._inner.boundsYMax(this._index)}setBoundsXMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsXMax(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMax(e){throw new Error("InternalError: Setting bounds is unsupported")}getIndex(){return this._index}next(){for(;++this._index<this._size&&!this._getExists(););return this._index<this._size}readGeometryArea(){return this.readGeometryForDisplay()?.area()??0}copy(){const e=new ie(this.metadata,this._fields,this._inner,this._chunkId,this._displayIds);return this.copyInto(e),e}copyInto(e){super.copyInto(e),e._index=this._index}readGeometryForDisplayTransformed(e){const[t,i]=e.translate,[n,o]=e.scale;return re||(re=r.new()),this._inner.transformGeometry(re,t,i,n,o,this._index)?new s(re.readLengthsUnsafe(),re.readCoordsUnsafe()):null}_readGeometry(e){const t=this._inner.readCoords(this._index),r=this._inner.readLengths(this._index);return t&&r?new s(r,t):null}_readX(){return this._inner.readX(this._index)}_readY(){return this._inner.readY(this._index)}_readServerCentroid(){return null}_readAttribute(e,t){const s=this.fields.get(e);if(!s)return;if(null==s.column)return this.getObjectId();const r=this._inner.readAttribute(this._index,s.column);if(null==r)return r;const i=this.fields.isDateField(s.name);return t?null==r?r:i?new Date(r):r:r}_readAttributes(){const e={};for(const t of this._fields.fields)null!=t.column&&(this._inner.isEmpty(t.column)||(e[t.name]=this._readAttribute(t.name,!1)));return e.__OBJECTID=this.getObjectId(),e}}class ne{constructor(e){this._metadata=e,this._chunks=new Map,this._chunksToRemove=[],this._overrides=new te,this.events=new h,this.featureAdapter=new a}destroy(){this.clear()}clear(){for(const e of this._chunks.values())this._chunksToRemove.push(e);this._chunks.clear(),this._overrides.clearWeakOverrides()}*chunks(){this._overrides&&(yield this._overrides.asChunk(this._metadata)),yield*this._chunks.values()}insert(t){e("esri-2d-update-debug")&&console.debug(`Chunk[${t.chunkId}] SourceChunkStore.insert`),this._overrides.onChunkInsert(t),this._chunks.set(t.chunkId,t),this.events.emit("changed")}remove(t){e("esri-2d-update-debug")&&console.debug(`Chunk[${t.chunkId}] SourceChunkStore.remove`),this._chunks.delete(t.chunkId),this._chunksToRemove.push(t)}removeById(t){e("esri-2d-update-debug")&&console.debug(`Chunk[${t}] SourceChunkStore.remove`);const s=this._chunks.get(t);this._chunks.delete(t),s&&this._chunksToRemove.push(s)}cleanup(){const e=this._chunksToRemove;return this._chunksToRemove=[],this._overrides.cleanup(this._chunks.values()),e}applyOverride(e){this._overrides.apply(e,this),this.events.emit("changed");for(const e of this._chunks.values())e.invalidate()}takeOverrideUpdate(){return this._overrides.takeOverrideUpdate()}refresh(){this.events.emit("refresh")}forEach(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const s=r.getObjectId();t.has(s)||(e(r.copy()),t.add(s))}}}forEachUnsafe(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const s=r.getObjectId();t.has(s)||(e(r),t.add(s))}}}mapObjectIdsFromGlobalIds(e,t){const s=new Map,r=new Set(e);return this._overrides.putWeakObjectIdsFromGlobalIds(s,r,t),this._forEachUnsafeIgnoreOverrides(e=>{const i=e.readAttribute(t);if(i&&r.has(i)&&!s.has(i)){const t=e.getObjectId();s.set(i,t)}}),s}forEachInBounds(e,t){const s=new Set;for(const r of this.chunks()){const i=r.queryFeaturesInBounds(e);for(;i.next();){const e=i.getObjectId();s.has(e)||(t(i.copy()),s.add(e))}}}forEachBounds(e,t){const s=d();for(const r of e)r.getBounds(s)&&t(s)}_forEachUnsafeIgnoreOverrides(e){const t=new Set;for(const s of this._chunks.values()){const r=s.reader.withoutOverrides().getCursor();for(;r.next();){const s=r.getObjectId();t.has(s)||(e(r),t.add(s))}}}}export{G as A,ie as F,X as G,K as O,se as a,ne as b,H as c,J as d,P as p};
