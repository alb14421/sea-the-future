/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{a as e,c as t}from"./mat3f32.js";import{c as s,f as i}from"./config.js";import"../core/lang.js";import{b as r,c as o,r as n,e as l}from"./mat3.js";import{t as a}from"./constants3.js";import{f as h}from"./maybe.js";import{e as c}from"./memoryEstimations.js";import"./TileStrategy.js";import{T as y}from"./TileKey2.js";import{B as u}from"./BufferObject.js";import{V as d}from"./VertexArrayObject.js";import{V as f}from"./VertexBuffer.js";import{T as m}from"./TiledDisplayObject.js";import{w as p,x as b}from"./definitions.js";import{i as _}from"./GeometryUtils.js";class g{constructor(e,t){this.sourceTile=t,this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.featureIndex=0,this.uniqueSymbol=null,this._colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=e}colliders(){return this._colliders}}class w{constructor(e){this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1,this.lastShow=!1,this.tileSymbols=[e],this.id=e.id}}function S(e,t,s,i){return M(e,t,s.level,s.col,i.key.level,i.key.col)}function x(e,t,s,i){return M(e,t,s.level,s.row,i.level,i.row)}function M(e,t,s,i,r,o){const n=s-r;if(n>=0)return(t>>n)+(i-(o<<n))*(e>>n);const l=-n;return t-(o-(i<<l))*(e>>l)<<l}class I{constructor(e,t,s){this._rows=Math.ceil(t/s),this._columns=Math.ceil(e/s),this._cellSize=s,this.cells=new Array(this._rows);for(let e=0;e<this._rows;e++){this.cells[e]=new Array(this._columns);for(let t=0;t<this._columns;t++)this.cells[e][t]=[]}}getCell(e,t){const s=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._rows-1),i=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._columns-1);return this.cells[s]&&this.cells[s][i]||null}getCellSpan(e,t,s,i){return[Math.min(Math.max(Math.floor(e/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(t/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(i/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function C(e,t,s){for(const[i,r]of e.symbols)O(e,t,s,r,i)}function O(e,t,s,i,r){const o=e.layerData.get(r);if(3===o.type){for(const t of i){const i=t.uniqueSymbol;let r;if(t.selectedForRendering){const t=i.parts[0],o=t.startOpacity,n=t.targetOpacity;e.allSymbolsFadingOut=e.allSymbolsFadingOut&&0===n;const l=s?Math.floor(127*o)|n<<7:n?255:0;r=l<<24|l<<16|l<<8|l}else r=0;for(const[e,s]of t.iconVertexRanges)for(let t=e;t<e+s;t+=4)o.iconOpacity[t/4]=r;if(t.selectedForRendering){const t=i.parts[1],o=t.startOpacity,n=t.targetOpacity;e.allSymbolsFadingOut=e.allSymbolsFadingOut&&0===n;const l=s?Math.floor(127*o)|n<<7:n?255:0;r=l<<24|l<<16|l<<8|l}else r=0;for(const[e,s]of t.textVertexRanges)for(let t=e;t<e+s;t+=4)o.textOpacity[t/4]=r}o.lastOpacityUpdate=t,o.opacityChanged=!0}}function T(e,t,s,i){const r=e.colliders();let o,n,l,a;for(const h of r)if(e.uniqueSymbol?.show&&e.uniqueSymbol.parts[h.partIndex].show&&(o=h.xScreen-i[0]+h.dxScreen,n=h.yScreen-i[1]+h.dyScreen,l=o+h.width,a=n+h.height,_(s,t.x,t.y,o,n,l,a)))return!0;return!1}class v{constructor(t,i,r,o,n,l){this._symbols=t,this._styleRepository=o,this._zoom=n,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new I(i,r,s),this._si=Math.sin(Math.PI*l/180),this._co=Math.cos(Math.PI*l/180),o.cachedStyles&&(this._styleProps=o.cachedStyles);for(const s of t)for(const t of s.symbols)this._allNeededMatrices.has(t.tile)||this._allNeededMatrices.set(t.tile,e(t.tile.transforms.tileUnitsToPixels))}work(e){const t=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],i=this._getProperties(s.styleLayerUID),r=this._styleRepository.layerContexts?.get(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-t>e)return!1;const o=s.symbols[this._currentSymbolCursor];if(!o.uniqueSymbol?.show)continue;const n=this._computeCoordinates(o,i,r),l=o.uniqueSymbol;if(!l.show)continue;const{iconAllowOverlap:a,textAllowOverlap:h}=i;for(const e of n){if(!e.enabled)continue;const t=l.parts[e.partIndex];t.show&&!(e.partIndex?h:a)&&this._doesCollide(e)&&(e.hard?l.show=!1:t.show=!1)}l.show&&this._insertColliders(l.parts,n,i)}}return!0}_insertColliders(e,t,s){const{iconIgnorePlacement:i,textIgnorePlacement:r}=s;for(const s of t){if(!s.enabled)continue;if(s.partIndex?r:i)continue;if(!e[s.partIndex].show)continue;const t=s.xScreen+s.dxScreen,o=s.yScreen+s.dyScreen,n=t+s.width,l=o+s.height,[a,h,c,y]=this._gridIndex.getCellSpan(t,o,n,l);for(let e=h;e<=y;e++)for(let t=a;t<=c;t++)this._gridIndex.cells[e][t].push(s)}}_computeCoordinates(e,t,s){const{iconRotationAlignment:i,textRotationAlignment:r,iconTranslate:o,iconTranslateAnchor:n,textTranslate:l,textTranslateAnchor:a}=t,h=this._si,c=this._co,y=this._zoom,u=this._allNeededMatrices.get(e.tile),d=e.uniqueSymbol,f=e.colliders(s);let m=0;for(const e of f){const[t,s]=0===e.partIndex?o:l,d=0===e.partIndex?n:a,f=e.minLod<=y&&y<=e.maxLod;m+=f?0:1,e.enabled=f,e.xScreen=e.xTile*u[0]+e.yTile*u[3]+u[6],e.yScreen=e.xTile*u[1]+e.yTile*u[4]+u[7],0===d?(e.xScreen+=c*t-h*s,e.yScreen+=h*t+c*s):(e.xScreen+=t,e.yScreen+=s),1===(0===e.partIndex?i:r)?(e.dxScreen=e.dxPixels,e.dyScreen=e.dyPixels):(e.dxScreen=c*(e.dxPixels+e.width/2)-h*(e.dyPixels+e.height/2)-e.width/2,e.dyScreen=h*(e.dxPixels+e.width/2)+c*(e.dyPixels+e.height/2)-e.height/2)}return f.length>0&&m===f.length&&d&&(d.show=!1),f}_getProperties(e){const t=this._styleProps.get(e);if(t)return t;const s=this._styleRepository.getLayerStyleProperties?.(e,this._zoom);return this._styleProps.set(e,s),s}_doesCollide(e){const t=e.xScreen+e.dxScreen,s=e.yScreen+e.dyScreen,i=t+e.width,r=s+e.height,[o,n,l,a]=this._gridIndex.getCellSpan(t,s,i,r);for(let h=n;h<=a;h++)for(let n=o;n<=l;n++){const o=this._gridIndex.cells[h][n];for(const n of o){if(null!=n.labelId&&null!=e.labelId&&n.labelId===e.labelId)continue;const o=n.xScreen+n.dxScreen,l=n.yScreen+n.dyScreen,a=o+n.width,h=l+n.height;if(!(i<o||t>a||r<l||s>h))return!0}}return!1}}class D{constructor(e,t){this.layerUIDs=[],this.isDestroyed=!1,this._data=e;let s=1;const i=new Uint32Array(e);this.layerUIDs=[];const r=i[s++];for(let e=0;e<r;e++)this.layerUIDs[e]=i[s++];this.bufferDataOffset=s,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(e){null!=this._data&&(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)}}class A extends D{constructor(e,t){super(e,t),this.type=2,this.lineIndexStart=0,this.lineIndexCount=0;const s=new Uint32Array(e);let i=this.bufferDataOffset;this.lineIndexStart=s[i++],this.lineIndexCount=s[i++];const r=s[i++];if(r>0){this.patternMap=new Map;for(let e=0;e<r;e++){const e=s[i++],t=s[i++],r=s[i++];this.patternMap.set(e,[t,r])}}this.bufferDataOffset=i}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=h(this.vao)}doPrepareForRendering(e,t,s){const i=new Uint32Array(t),r=new Int32Array(i.buffer),o=i[s++],n=this.layer.lineMaterial,l=new f(e,n.geometryLayout,new Int32Array(r.buffer,4*s,o));s+=o;const a=i[s++],h=u.createIndex(e,35044,new Uint32Array(i.buffer,4*s,a));s+=a,this.vao=new d(e,l,h)}}class L extends D{constructor(e,t){super(e,t),this.type=1,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const s=new Uint32Array(e);let i=this.bufferDataOffset;this.fillIndexStart=s[i++],this.fillIndexCount=s[i++],this.outlineIndexStart=s[i++],this.outlineIndexCount=s[i++];const r=s[i++];if(r>0){this.patternMap=new Map;for(let e=0;e<r;e++){const e=s[i++],t=s[i++],r=s[i++];this.patternMap.set(e,[t,r])}}this.bufferDataOffset=i}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.cachedMemory??0)+(this.outlineVAO?.cachedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=h(this.fillVAO),this.outlineVAO=h(this.outlineVAO)}doPrepareForRendering(e,t,s){const i=new Uint32Array(t),r=new Int32Array(i.buffer),o=i[s++],n=this.layer,l=n.fillMaterial,a=new f(e,l.geometryLayout,new Int32Array(r.buffer,4*s,o));s+=o;const h=i[s++],c=u.createIndex(e,35044,new Uint32Array(i.buffer,4*s,h));s+=h;const y=i[s++],m=n.outlineMaterial,p=new f(e,m.geometryLayout,new Int32Array(r.buffer,4*s,y));s+=y;const b=i[s++],_=u.createIndex(e,35044,new Uint32Array(i.buffer,4*s,b));s+=b,this.fillVAO=new d(e,a,c),this.outlineVAO=new d(e,p,_)}}class R extends D{constructor(e,t,s){super(e,t),this.type=3,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const i=new Uint32Array(e),r=new Int32Array(e),o=new Float32Array(e);let n=this.bufferDataOffset;this.isIconSDF=!!i[n++];const l=i[n++],a=i[n++],h=i[n++],c=new y(l,a,h,0),u=i[n++];for(let e=0;e<u;e++){const e=i[n++],t=i[n++],s=i[n++];this.iconPerPageElementsMap.set(e,[t,s])}const d=i[n++];for(let e=0;e<d;e++){const e=i[n++],t=i[n++],s=i[n++];this.glyphPerPageElementsMap.set(e,[t,s])}const f=i[n++],m=i[n++];this.iconOpacity=new Int32Array(f),this.textOpacity=new Int32Array(m),n=function(e,t,s,i,r,o,n){const l=t[i++];for(let a=0;a<l;a++){const l=new g(o,n);l.xTile=t[i++],l.yTile=t[i++],l.hash=t[i++],l.priority=t[i++],l.featureIndex=t[i++];const a=t[i++],h=l.colliders();for(let e=0;e<a;e++){const e=t[i++],r=t[i++],o=t[i++],n=t[i++],l=!!t[i++],a=t[i++],c=s[i++],y=s[i++],u=t[i++],d=t[i++];h.push({xTile:e,yTile:r,dxPixels:o,dyPixels:n,hard:l,partIndex:a,width:u,height:d,minLod:c,maxLod:y})}const c=e[i++];for(let t=0;t<c;t++)l.textVertexRanges.push([e[i++],e[i++]]);const y=e[i++];for(let t=0;t<y;t++)l.iconVertexRanges.push([e[i++],e[i++]]);r.push(l)}return i}(i,r,o,n,this.symbols,s,c),this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.cachedMemory??0)+(this.textVAO?.cachedMemory??0)+c(this.iconOpacity)+c(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const t of this.iconPerPageElementsMap.values())e+=t[1];for(const t of this.glyphPerPageElementsMap.values())e+=t[1];return e/3}doDestroy(){this.iconVAO=h(this.iconVAO),this.textVAO=h(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,t=this.iconVAO.buffer("opacity");e.length>0&&e.byteLength===t.usedMemory&&t.setSubData(e,0,0,e.length);const s=this.textOpacity,i=this.textVAO.buffer("opacity");s.length>0&&s.byteLength===i.usedMemory&&i.setSubData(s,0,0,s.length)}doPrepareForRendering(e,t,s){const i=new Uint32Array(t),r=new Int32Array(i.buffer),o=i[s++],n=this.layer,l=n.iconMaterial,a=new f(e,l.geometryLayout,new Int32Array(r.buffer,4*s,o));s+=o;const h=i[s++],c=u.createIndex(e,35044,new Uint32Array(i.buffer,4*s,h));s+=h;const y=i[s++],m=n.textMaterial,p=new f(e,m.geometryLayout,new Int32Array(r.buffer,4*s,y));s+=y;const b=i[s++],_=u.createIndex(e,35044,new Uint32Array(i.buffer,4*s,b));s+=b;const g=new f(e,l.opacityLayout,this.iconOpacity.buffer),w=new f(e,m.opacityLayout,this.textOpacity.buffer);this.iconVAO=new d(e,new Map([["geometry",a],["opacity",g]]),c),this.textVAO=new d(e,new Map([["geometry",p],["opacity",w]]),_)}}class q extends D{constructor(e,t){super(e,t),this.type=4,this.circleIndexStart=0,this.circleIndexCount=0;const s=new Uint32Array(e);let i=this.bufferDataOffset;this.circleIndexStart=s[i++],this.circleIndexCount=s[i++],this.bufferDataOffset=i}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=h(this.vao)}doPrepareForRendering(e,t,s){const i=new Uint32Array(t),r=new Int32Array(i.buffer),o=i[s++],n=this.layer.circleMaterial,l=new f(e,n.geometryLayout,new Int32Array(r.buffer,4*s,o));s+=o;const a=i[s++],h=u.createIndex(e,35044,new Uint32Array(i.buffer,4*s,a));s+=a,this.vao=new d(e,l,h)}}class k extends m{constructor(e,t,s,i,r,o,n,l=null){super(e,t,s,i,r,o,a,a),this.styleRepository=n,this._owner=l,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=e.id}get styleLayerUIDs(){return Array.from(this.layerData.keys())}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<i}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<i)}get wasRequested(){return"errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(e){let t=!1;for(const s of e){const e=this.layerData.get(s);e&&(this._usedMemory-=e.usedMemory,3===e.type&&this.symbols.delete(s)&&(t=!0),e.destroy(),this.layerData.delete(s))}this._owner?.updateTileSize(this),t&&(this.featureIndex?.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const e=this.layerData.values();for(const t of e)if(t.hasData())return!0;return!1}dispose(){"unloaded"!==this.status&&(k._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){0===--this._referenced&&(this._owner?.onDisposeTile(this),this.dispose(),this.stage=null)}retain(){++this._referenced}get cachedMemory(){return this._usedMemory}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(e){this.featureIndex?.clear();let t=!1;if(e){const{bucketsWithData:s,emptyBuckets:i}=e,r=this._createRenderBuckets(s);if(i&&i.byteLength>0){const e=new Uint32Array(i);for(const t of e)this._deleteLayerData(t)}for(const[e,s]of r)this._deleteLayerData(e),3===s.type&&(this.symbols.set(e,s.symbols),t=!0),this._usedMemory+=s.usedMemory,this.layerData.set(e,s);this._owner?.updateTileSize(this)}this._hasSymbolBuckets=!1;for(const e of this.layerData.values())3===e.type&&(this._hasSymbolBuckets=!0);t&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(e){e.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const t=this.resolution/(e.resolution*e.pixelRatio),s=this.width/this.rangeX*t,i=this.height/this.rangeY*t,a=[0,0];e.toScreen(a,[this.x,this.y]);const h=this.transforms.tileUnitsToPixels;r(h),o(h,h,a),n(h,h,Math.PI*e.rotation/180),l(h,h,[s,i,1])}_createTransforms(){return{displayViewScreenMat3:t(),tileMat3:t(),tileUnitsToPixels:t()}}static _destroyRenderBuckets(e){if(!e)return;const t=new Set;for(const s of e.values())t.has(s)||(s.destroy(),t.add(s));e.clear()}_createRenderBuckets(e){const t=new Map,s=new Map;for(const i of e){const e=this._deserializeBucket(i,s);for(const s of e.layerUIDs)t.set(s,e)}return t}_deserializeBucket(e,t){let s=t.get(e);if(s)return s;switch(new Uint32Array(e)[0]){case 1:s=new L(e,this.styleRepository);break;case 2:s=new A(e,this.styleRepository);break;case 3:s=new R(e,this.styleRepository,this);break;case 4:s=new q(e,this.styleRepository)}return t.set(e,s),s}_deleteLayerData(e){if(!this.layerData.has(e))return;const t=this.layerData.get(e);this._usedMemory-=t.usedMemory,t.destroy(),this.layerData.delete(e)}}function U(e){return(e.uniqueSymbol?.show&&e.uniqueSymbol?.lastShow)??!1}function P(e,t){if(e.priority-t.priority)return e.priority-t.priority;if(U(e)&&!U(t))return-1;if(U(t)&&!U(e))return 1;const s=e.tile.key,i=t.tile.key;return s.world-i.world?s.world-i.world:s.level-i.level?s.level-i.level:s.row-i.row?s.row-i.row:s.col-i.col?s.col-i.col:e.xTile-t.xTile?e.xTile-t.xTile:e.yTile-t.yTile}class F{get running(){return this._running}constructor(e,t,s,i,r,o,n,l){this.selectionMode=e,this._visibleTiles=t,this._symbolRepository=s,this._styleRepository=i,this._createCollisionJob=r,this._assignTileSymbolsOpacity=o,this._symbolLayerSorter=n,this._isLayerVisible=l,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(e,t){this._screenWidth===e&&this._screenHeight===t||this.restart(),this._screenWidth=e,this._screenHeight=t}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const t=performance.now();if(!this._selectionJob.work(e))return!1;if(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const t=performance.now();if(!this._collisionJob.work(e))return!1;if(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const t=performance.now();if(!this._opacityJob.work(e))return!1;if(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-t))))return!1}return this._running=!1,!0}_isFeatureFiltered(e,t,s){const i=t.getFilterFlags(e),r=i&b,o=null==s.featureEffect||s.featureEffect.excludedLabelsVisible||i&p;return!(r&&o)}_getFilteredByLayer(){let e;if(this._styleRepository?.layerContexts)for(const t of this._symbolRepository.uniqueSymbols){const s=this._styleRepository.layerContexts?.get(t.styleLayerUID);if(s?.attributeView)for(const i of t.uniqueSymbols){e??=new Map,e.get(t.styleLayerUID)||e.set(t.styleLayerUID,new Set);const r=e.get(t.styleLayerUID),o=s.attributeView,n=s.layerView;this._isFeatureFiltered(i.id,o,n)&&r.add(i.id)}}return e}_resetSelection(){for(let e=0;e<this._symbolRepository.uniqueSymbols.length;e++){const t=this._symbolRepository.uniqueSymbols[e];for(let e=0;e<t.uniqueSymbols.length;e++){const s=t.uniqueSymbols[e];for(const e of s.tileSymbols)e.selectedForRendering=!1}}}_createSelectionJob(){const e="feature-tile"===this.selectionMode?B:J,t=this._symbolRepository.uniqueSymbols;this._resetSelection();const s=[];let i=0,r=0;const o=this._isLayerVisible,n=this._getFilteredByLayer(),l=this._styleRepository?.layerContexts,a=this._symbolLayerSorter;return{work:function(a){let h;const c=performance.now();for(;r<t.length;r++,i=0){const y=t[r],u=y.styleLayerUID,d=n?.get(u);let f=0;if(l){const e=l.get(u).layerView;f=e.view.allLayerViews.items.indexOf(e)}if(!o(u)){s[r]||(s[r]={styleLayerUID:u,layerOrder:f,symbols:[]});continue}s[r]||={styleLayerUID:u,symbols:[],layerOrder:f};const m=s[r];for(;i<y.uniqueSymbols.length;i++){if(h=y.uniqueSymbols[i],i%100==99&&performance.now()-c>a)return!1;if(h.lastShow=h.show,h.id&&d?.has(h.id)){h.show=!1,h.parts[0].show=!1,h.parts[1].show=!1;continue}const t=e(h);if(t){t.selectedForRendering=!0,m.symbols.push(t),h.show=!0;for(const e of h.parts)e.show=!0}else h.show=!1}}for(const e of s)e.symbols.sort(P);return s.sort((e,t)=>t.layerOrder-e.layerOrder),!0},get sortedSymbols(){return s.sort(a)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,t=this._visibleTiles;let s=0;function i(t,s){for(const e of t.symbols.values())V(e,s);e(t,s);for(const e of t.childrenTiles)i(e,s)}return{work(r){const o=performance.now();for(;s<t.length;s++){if(performance.now()-o>r)return!1;const n=t[s];if(null!=n.parentTile)continue;const l=performance.now();n instanceof k?i(n,l):e(n,l)}return!0}}}}function V(e,t){for(const s of e){const e=s.uniqueSymbol;for(const s of e.parts){const r=s.targetOpacity>.5?1:-1;s.startOpacity+=r*((t-s.startTime)/i),s.startOpacity=Math.min(Math.max(s.startOpacity,0),1),s.startTime=t,s.targetOpacity=e.show&&s.show?1:0}}}function B(e){let t=null,s=null,i=null;for(const r of e.tileSymbols){const e=r.tile;e.isReady&&e.isCoverage?t=r:e.isReady?s=r:e.rendering&&(i=r)}return t??s??i}function J(e){let t=null,s=!1,i=!1;for(const r of e.tileSymbols)if(!i||!s){const e=r.tile;(!t||e.isCoverage||e.neededForCoverage&&!s)&&(t=r,(e.neededForCoverage||e.isCoverage)&&(i=!0),e.isCoverage&&(s=!0))}return i?t:null}class z{static fromSymbols(e,t){let s=e.length;if(s>=j){let i=t;do{i/=2,s/=4}while(s>E&&i>W);const r=new I(t,t,i);for(const t of e)r.getCell(t.xTile,t.yTile).push(t);return new z(t,e,r)}return new z(t,e,null)}constructor(e,t,s){this.tileCoordRange=e,this._symbols=t,this._index=s}addSymbols(e){for(const t of e)this._symbols.push(t);if(this._index)for(const t of e)this._index.getCell(t.xTile,t.yTile).push(t)}removeSymbols(e){const t=new Set(e);if(this._symbols=this._symbols.filter(e=>!t.has(e)),this._index)for(const e of this._index.cells)for(let s=0;s<e.length;s++)e[s]=e[s].filter(e=>!t.has(e))}getSymbols(){return this._symbols}getCandidate(e,t,s,i){if(!this._index){for(const r of this._symbols)if(s===r.hash&&Math.abs(e-r.xTile)<=i&&Math.abs(t-r.yTile)<=i)return r;return null}const r=this._index.getCellSpan(e-i,t-i,e+i,t+i),[o,n,l,a]=r;for(let r=n;r<=a;r++)for(let n=o;n<=l;n++){const o=this._index.cells[r][n];for(const r of o)if(s===r.hash&&Math.abs(e-r.xTile)<=i&&Math.abs(t-r.yTile)<=i)return r}return null}}const j=32,E=8,W=64;class H{constructor(e,t){this.tileCoordRange=e,this._visibleTiles=t,this._indexMapByTile=new Map,this._uniqueSymbolsByStyleLayerId=new Map}get uniqueSymbols(){return null==this._uniqueSymbolLayerArray&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}registerVectorTile(e,t){const s=this._ensureIndexMap(e),i=t?.values()??s.keys();for(const e of i){const t=s.get(e);t&&(this._removeSymbols(e,t.getSymbols()),s.delete(e))}this._addSymbols(e.key,s,e.symbols),this._invalidate()}unregisterVectorTile(e){this._removeTile(e),this._invalidate()}registerFeatureTile(e){this._ensureIndexMap(e),this._invalidate()}unregisterFeatureTile(e){this._removeTile(e),this._invalidate()}insertFeatureTileMetrics(e,t){const s=this._indexMapByTile.get(e);if(!s)throw new Error(`tile ${e.id} not registered!`);this._addSymbols(e.key,s,N(t)),this._invalidate()}removeFeatureTileMetrics(e,t){const s=this._indexMapByTile.get(e);if(!s)return;const i=N(t);for(const[e,t]of s.entries()){const s=i.get(e);s&&(t.removeSymbols(s),this._removeSymbols(e,s))}this._invalidate()}deleteStyleLayers(e){for(const t of this._indexMapByTile.values())for(const s of e){const e=t.get(s);e&&(this._removeSymbols(s,e.getSymbols()),t.delete(s))}this._invalidate()}querySymbols(e,t,s,i){const r=[];for(const[i,o]of this._uniqueSymbolsByStyleLayerId.entries())for(const n of o){const o=n.tileSymbols.find(e=>e.selectedForRendering);o&&T(o,e,t*(window.devicePixelRatio||1),s)&&r.push({vtlSymbol:o,styleLayerUID:i,tileKey:o.tile.key})}return r}_ensureIndexMap(e){let t=this._indexMapByTile.get(e);return t||(t=new Map,this._indexMapByTile.set(e,t)),t}_invalidate(){this._uniqueSymbolLayerArray=null}_addSymbols(e,t,s){for(const[e,i]of s){let s=t.get(e);s?s.addSymbols(i):(s=z.fromSymbols(i,this.tileCoordRange),t.set(e,s))}this._updateUniqueSymbols(e,s)}_removeTile(e){const t=this._indexMapByTile.get(e);if(t){for(const[e,s]of t.entries())this._removeSymbols(e,s.getSymbols());this._indexMapByTile.delete(e),this._invalidate()}}_removeSymbols(e,t){for(const s of t){const t=s.uniqueSymbol;if(t){if(t.tileSymbols=t.tileSymbols.filter(e=>e!==s),0===t.tileSymbols.length){const s=this._uniqueSymbolsByStyleLayerId.get(e);s.delete(t),0===s.size&&this._uniqueSymbolsByStyleLayerId.delete(e)}s.uniqueSymbol=null}}}_updateUniqueSymbols(e,t){if(0!==t.size){for(const s of this._visibleTiles)s.parentTile||s.key.world!==e.world||s.key.level===e.level&&!s.key.equals(e)||this._matchSymbols(s,e,t);for(const[e,s]of t)for(const t of s)if(!t.uniqueSymbol){t.uniqueSymbol=new w(t);let s=this._uniqueSymbolsByStyleLayerId.get(e);s||(s=new Set,this._uniqueSymbolsByStyleLayerId.set(e,s)),s.add(t.uniqueSymbol)}}}_matchSymbols(e,t,s){if(e.key.level>t.level){const s=e.key.level-t.level;if(e.key.row>>s!==t.row||e.key.col>>s!==t.col)return}if(t.level>e.key.level){const s=t.level-e.key.level;if(t.row>>s!==e.key.row||t.col>>s!==e.key.col)return}const i=new Map;for(const[r,o]of s){const s=[],n=20+(e.key.level<t.level?1:1<<e.key.level-t.level),l=this._indexMapByTile.get(e),a=l?.get(r);if(a)for(const i of o){if(i.uniqueSymbol)continue;const r=S(this.tileCoordRange,i.xTile,t,e.key),o=x(this.tileCoordRange,i.yTile,t,e.key),l=-20,h=this.tileCoordRange+20;if(!(r>=l&&r<h&&o>=l&&o<h)){s.push(i);continue}const c=a.getCandidate(r,o,i.hash,n),y=c?.uniqueSymbol;y?(i.uniqueSymbol=y,y.tileSymbols.push(i)):s.push(i)}s.length>0&&i.set(r,s)}for(const s of e.childrenTiles||[])this._matchSymbols(s,t,i)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsByStyleLayerId,t=new Array(e.size);let s,i=0;for(const[r,o]of e){const e=new Array(o.size);s=0;for(const t of o)e[s++]=t;t[i]={styleLayerUID:r,uniqueSymbols:e},i++}return t}}function N(e){const t=new Map;for(const s of e){const e=s.labelClassId;let i=t.get(e);i||(i=[],t.set(e,i)),i.push(s)}return t}export{v as C,H as S,k as V,F as a,C as w};
