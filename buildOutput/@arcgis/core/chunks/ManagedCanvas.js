/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import e from"../Viewpoint.js";import{watch as i,sync as s,when as a,whenOnce as n,initial as o,syncAndInitial as r}from"../core/reactiveUtils.js";import{property as h}from"../core/accessorSupport/decorators/property.js";import{h as l}from"../core/lang.js";import{L as c}from"./Logger.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import{isPromiseLike as d,throwIfAborted as u,whenOrAbort as m,c as v}from"../core/promiseUtils.js";import{addFrameTask as g,M as _}from"../core/scheduling.js";import{a as w}from"./Scheduler.js";import f from"../core/Accessor.js";import y from"../core/Collection.js";import x,{a as T,p as S}from"../geometry/Extent.js";import M from"../geometry/Polygon.js";import b from"../layers/support/LOD.js";import{NumericIdentifiableMixin as z}from"../core/Identifiable.js";import{project as k}from"./projectionUtils.js";import D from"../core/Error.js";import{s as R,d as P,c as V,u as Z}from"./vec2.js";import j,{d as C}from"../geometry/Point.js";import{m as O}from"./coordsUtils.js";import{c as A}from"./screenUtils.js";import{W as E}from"./Warning.js";import{i as I}from"./pe.js";import{p as N}from"./unitUtils.js";import{n as L,o as U,q as G,u as H,v as K,c as F,e as q,m as B,w as $,x as W,t as J,s as Y,j as Q}from"./viewpointUtils.js";import{V as X}from"./ViewEvents.js";import{p as tt}from"./a11yUtils.js";import et from"../views/ViewAnimation.js";import{r as it,d as st}from"./maybe.js";import{I as at,a as nt,V as ot}from"./InputManager.js";import{e as rt,D as ht,a as lt,r as ct,b as pt,i as dt,o as ut,g as mt,c as vt,m as gt,B as _t,I as wt,P as ft,S as yt,d as xt,f as Tt,h as St,j as Mt,A as bt}from"./Animation.js";import zt from"../core/Handles.js";import{i as kt,a as Dt}from"./screenUtils2.js";import{c as Rt}from"./vec2f64.js";import Pt from"../views/2d/ViewState.js";import{e as Vt,l as Zt}from"./mathUtils.js";import{E as jt}from"./easing.js";import{EventEmitter as Ct}from"../core/Evented.js";import{a as Ot}from"./events.js";import{h as At}from"./handleUtils.js";import{c as Et,s as It,r as Nt,t as Lt}from"./mat2d.js";import{c as Ut}from"./mat2df64.js";var Gt,Ht;let Kt=Gt=class extends f{constructor(){super(...arguments),this.left=0,this.top=0,this.right=0,this.bottom=0}clone(){return new Gt({left:this.left,top:this.top,right:this.right,bottom:this.bottom})}};t([h()],Kt.prototype,"left",void 0),t([h()],Kt.prototype,"top",void 0),t([h()],Kt.prototype,"right",void 0),t([h()],Kt.prototype,"bottom",void 0),Kt=Gt=t([p("esri.views.2d.PaddedViewState.Padding")],Kt);let Ft=Ht=class extends Pt{constructor(...t){super(...t),this.paddedViewState=new Pt,this._updateContent=(()=>{const t=Rt();return()=>{const e=this._get("size"),i=this._get("padding");if(!e||!i)return;const s=this.paddedViewState;R(t,i.left+i.right,i.top+i.bottom),P(t,e,t),V(s.size,t);const a=s.viewpoint;a&&(this.viewpoint=a)}})(),this.addHandles(i(()=>[this.size,this.padding],()=>this._updateContent(),s)),this.padding=new Kt,this.size=[0,0]}set padding(t){this._set("padding",t||new Kt)}set viewpoint(t){if(t){this.paddedViewState.viewpoint=t;let e=t;const i=this._get("padding");i&&(e=L(t.clone(),t,this._get("size"),i));const{targetGeometry:s,rotation:a,scale:n}=e,{x:o,y:r,spatialReference:h}=s,l=this._viewpoint2D;l.center[0]=o,l.center[1]=r,l.rotation=a,l.scale=n,l.spatialReference=h,this._update()}}clone(){return new Ht({padding:this.padding.clone(),size:this.size.slice(),viewpoint:this.paddedViewState.viewpoint.clone(),pixelRatio:this.pixelRatio})}};t([h()],Ft.prototype,"paddedViewState",void 0),t([h({type:Kt})],Ft.prototype,"padding",null),t([h()],Ft.prototype,"viewpoint",null),Ft=Ht=t([p("esri.views.2d.PaddedViewState")],Ft);const qt=Ft;class Bt{constructor(t){this.view=t,this._stationaryHandle=null,this._frameTaskHandle=null,this._updateParameters=null,this._updateRequested=!1,this._scheduler=w(),this._schedulerHandle=a(()=>this._scheduler.updating,()=>this.requestFrame()),this.stationary=!0,this.prepare=()=>{this._updateParameters&&(this._updateParameters.state=this.view.state,this._updateParameters.stationary=this.view.stationary,this._updateParameters.pixelRatio=window.devicePixelRatio,this._updateParameters.renderingOptions=this.view.renderingOptions,this._updateParameters.targetState.copy(this.view.state),null==this.view.animation?.target||d(this.view.animation.target)||(this._updateParameters.targetState.viewpoint=this.view.animation.target))},this.update=t=>{if(this._updateRequested=!1,this.view?.destroyed)return;const{allLayerViews:e,graphicsView:i,labelManager:s,state:{id:a}}=this.view;e?.forEach(this._updateLayerView,this),null!=s&&(s.lastUpdateId!==a&&(s.viewChange(),s.lastUpdateId=a),s.updateRequested&&s.processUpdate(this._updateParameters)),null!=i&&(i.lastUpdateId!==a&&(i.viewChange(),i.lastUpdateId=a),i.updateRequested&&i.processUpdate(this._updateParameters)),this.view.graphicsTileStore?.setViewState(this._updateParameters.state),this.view.animation?this._scheduler.state=0:this.view.interacting?this._scheduler.state=1:this._scheduler.state=2,this._scheduler.frame(t)||this._updateRequested||2!==this._scheduler.state||this._frameTaskHandle?.pause()}}destroy(){this.stop(),this._schedulerHandle.remove(),this._scheduler.destroy()}get scheduler(){return this._scheduler}start(){if(this._frameTaskHandle)return;const t=this.view;this.stationary=t.stationary,this._updateParameters={state:t.state,targetState:new qt,pixelRatio:window.devicePixelRatio,stationary:this.stationary,renderingOptions:t.renderingOptions},this._stationaryHandle=i(()=>t.stationary,t=>{this.stationary=t,this.requestFrame()}),this._frameTaskHandle=g(this),this.requestUpdate()}stop(){this._frameTaskHandle&&(this._updateRequested=!1,this._stationaryHandle?.remove(),this._frameTaskHandle.remove(),this._updateParameters=this._stationaryHandle=this._frameTaskHandle=null,this.stationary=!0)}requestUpdate(){this._updateRequested||(this._updateRequested=!0,this.requestFrame())}requestFrame(){this._frameTaskHandle&&this._frameTaskHandle.resume()}_updateLayerView(t){if(!t.attached)return void this.requestUpdate();const e=this.view.state,i=t.lastUpdateId;null!=i&&(this.stationary||t.moving)||(t.moving=!0),i!==e.id&&t.viewChange(),this.stationary&&t.moving&&(t.moving=!1,t.moveEnd()),t.lastUpdateId=e.id,t.updateRequested&&t.processUpdate(this._updateParameters),"layerViews"in t&&t.layerViews?.forEach(this._updateLayerView,this)}}var $t;let Wt=$t=class extends(z(f)){constructor(t){super(t),this.geometry=null,this.spatialReference=null}get normalizedGeometry(){if(null==this.geometry||!this.spatialReference)return null;if(!this.spatialReference.equals(this.geometry.spatialReference))try{return k(this.geometry,this.spatialReference)}catch(t){return c.getLogger(this).error("#constraints.geometry","could not project the geometry to the view's spatial reference",{geometry:this.geometry,spatialReference:this.spatialReference,error:t}),null}return this.geometry}constrain(t,e){if(null==this.normalizedGeometry)return t;const i=t.targetGeometry;if("extent"===this.normalizedGeometry.type?T(this.normalizedGeometry,i):S(this.normalizedGeometry,i))return t;const{coordinate:s}=function(t,e){const{spatialReference:i}=e,s=[e.x,e.y];let a,n,o,r;const h=[0,0],l=function(t){switch(t.type){case"extent":return[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]];case"polygon":return t.rings;case"polyline":return t.paths}}(t);for(let t=0;t<l.length;t++){const e=l[t];for(let i=0;i<e.length-1;i++){O(h,s,e,i);const l=Z(s,h);(null==a||l<a)&&(a=l,n=[...h],o=t,r=i)}}if(null==a||!n||null==o||null==r)throw new D("nearest-coordinate:failed","Failed to find the nearest coordinate");const[c,p]=n;return{coordinate:new j({x:c,y:p,spatialReference:i}),distance:a}}(this.normalizedGeometry,i);return s?(t.targetGeometry=s,t):t}clone(){return new $t({geometry:this.geometry?.clone(),spatialReference:this.spatialReference?.clone()})}};var Jt;t([h({constructOnly:!0})],Wt.prototype,"geometry",void 0),t([h({readOnly:!0})],Wt.prototype,"normalizedGeometry",null),t([h({constructOnly:!0})],Wt.prototype,"spatialReference",void 0),Wt=$t=t([p("esri.views.2d.constraints.GeometryConstraint")],Wt);let Yt=Jt=class extends(z(f)){constructor(){super(...arguments),this.enabled=!0,this.rotationEnabled=!0}constrain(t,e){return this.enabled&&e?(this.rotationEnabled||(t.rotation=e.rotation),t):t}clone(){return new Jt({enabled:this.enabled,rotationEnabled:this.rotationEnabled})}};t([h()],Yt.prototype,"enabled",void 0),t([h()],Yt.prototype,"rotationEnabled",void 0),Yt=Jt=t([p("esri.views.2d.constraints.RotationConstraint")],Yt);const Qt=Yt;var Xt;let te=Xt=class extends(z(f)){constructor(t){super(t),this._lodByScale={},this._scales=[],this.effectiveLODs=null,this.effectiveMinZoom=-1,this.effectiveMaxZoom=-1,this.effectiveMinScale=0,this.effectiveMaxScale=0,this.lods=null,this.minZoom=-1,this.maxZoom=-1,this.minScale=0,this.maxScale=0,this.snapToZoom=!0}initialize(){let t,{lods:e,minScale:i,maxScale:s,minZoom:a,maxZoom:n}=this,o=-1,r=-1,h=!1,l=!1;if(0!==i&&0!==s&&i<s&&([i,s]=[s,i]),!e?.length)return this._set("effectiveMinScale",i),void this._set("effectiveMaxScale",s);e=e.map(t=>t.clone()),e.sort((t,e)=>e.scale-t.scale),e.forEach((t,e)=>t.level=e);for(const a of e)!h&&i>0&&i>=a.scale&&(o=a.level,h=!0),!l&&s>0&&s>=a.scale&&(r=t?t.level:-1,l=!0),t=a;-1===a&&(a=0===i?0:o),-1===n&&(n=0===s?e.length-1:r),a=Math.max(a,0),a=Math.min(a,e.length-1),n=Math.max(n,0),n=Math.min(n,e.length-1),a>n&&([a,n]=[n,a]),i=e[a].scale,s=e[n].scale,e.splice(0,a),e.splice(n-a+1),e.forEach((t,e)=>{this._lodByScale[t.scale]=t,this._scales[e]=t.scale}),this._set("effectiveLODs",e),this._set("effectiveMinZoom",a),this._set("effectiveMaxZoom",n),this._set("effectiveMinScale",i),this._set("effectiveMaxScale",s)}constrain(t,e){if(e&&t.scale===e.scale)return t;const i=this.effectiveMinScale,s=this.effectiveMaxScale,a=t.targetGeometry,n=e&&e.targetGeometry,o=0!==s&&t.scale<s,r=0!==i&&t.scale>i;if(o||r){const o=r?i:s;if(e&&n){const i=(o-e.scale)/(t.scale-e.scale);a.x=n.x+(a.x-n.x)*i,a.y=n.y+(a.y-n.y)*i}t.scale=o}return this.snapToZoom&&this.effectiveLODs&&(t.scale=this._getClosestScale(t.scale)),t}fit(t){if(!this.effectiveLODs||!this.snapToZoom)return this.constrain(t,null);const e=this.scaleToZoom(t.scale),i=Math.abs(e-Math.floor(e));return t.scale=this.zoomToScale(i>.99?Math.round(e):Math.floor(e)),t}zoomToScale(t){if(!this.effectiveLODs)return 0;t-=this.effectiveMinZoom,t=Math.max(0,t);const e=this._scales;if(t<=0)return e[0];if(t>=e.length)return e[e.length-1];const i=Math.floor(t),s=Math.ceil(t);return e[i]+(t-i)*(e[s]-e[i])}scaleToZoom(t){if(!this.effectiveLODs)return-1;const e=this._scales;let i,s;if(t>=e[0])return this.effectiveMinZoom;if(t<=e[e.length-1])return this.effectiveMaxZoom;for(let a=0;a<e.length-1;a++){if(i=e[a],s=e[a+1],s===t)return a+this.effectiveMinZoom+1;if(i>t&&s<t)return a+this.effectiveMinZoom+1-(t-s)/(i-s)}return-1}snapToClosestScale(t){if(!this.effectiveLODs)return t;const e=this.scaleToZoom(t);return this.zoomToScale(Math.round(e))}snapToNextScale(t,e=.5){if(!this.effectiveLODs)return t*e;const i=Math.round(this.scaleToZoom(t));return this.zoomToScale(i+1)}snapToPreviousScale(t,e=2){if(!this.effectiveLODs)return t*e;const i=Math.round(this.scaleToZoom(t));return this.zoomToScale(i-1)}clone(){return new Xt({lods:this.lods,minZoom:this.minZoom,maxZoom:this.maxZoom,minScale:this.minScale,maxScale:this.maxScale})}_getClosestScale(t){return this._lodByScale[t]||(t=this._scales.reduce((e,i)=>Math.abs(i-t)<=Math.abs(e-t)?i:e,this._scales[0])),this._lodByScale[t].scale}};t([h({readOnly:!0})],te.prototype,"effectiveLODs",void 0),t([h({readOnly:!0})],te.prototype,"effectiveMinZoom",void 0),t([h({readOnly:!0})],te.prototype,"effectiveMaxZoom",void 0),t([h({readOnly:!0})],te.prototype,"effectiveMinScale",void 0),t([h({readOnly:!0})],te.prototype,"effectiveMaxScale",void 0),t([h()],te.prototype,"lods",void 0),t([h()],te.prototype,"minZoom",void 0),t([h()],te.prototype,"maxZoom",void 0),t([h()],te.prototype,"minScale",void 0),t([h()],te.prototype,"maxScale",void 0),t([h()],te.prototype,"snapToZoom",void 0),te=Xt=t([p("esri.views.2d.constraints.ZoomConstraint")],te);const ee=te,ie={base:null,key:"type",typeMap:{extent:x,polygon:M}};let se=class extends f{constructor(t){super(t),this.lods=null,this.minScale=0,this.maxScale=0,this.minZoom=-1,this.maxZoom=-1,this.rotationEnabled=!0,this.snapToZoom=!0,this.customConstraints=new y}destroy(){this.view=null}get effectiveLODs(){return this._zoom.effectiveLODs}get effectiveMinScale(){return this._zoom.effectiveMinScale}get effectiveMaxScale(){return this._zoom.effectiveMaxScale}get effectiveMinZoom(){return this._zoom.effectiveMinZoom}get effectiveMaxZoom(){return this._zoom.effectiveMaxZoom}set geometry(t){t?this._set("geometry",t):this._set("geometry",null)}get version(){return`${this._zoom?.uid}/${this._rotation?.uid}/${this._geometry?.uid}`}get _geometry(){const t=this._get("_geometry");return t&&this.geometry===t.geometry&&this.view?.constraintsInfo.spatialReference===t.spatialReference?t:new Wt({geometry:this.geometry,spatialReference:this.view?.constraintsInfo.spatialReference})}get _rotation(){return new Qt({rotationEnabled:this.rotationEnabled})}get _zoom(){const t=this._get("_zoom"),e=this.lods||this.view?.constraintsInfo.lods,i=this.minZoom,s=this.maxZoom,a=this.minScale,n=this.maxScale,o=this.snapToZoom;return t&&t.lods===e&&t.minZoom===i&&t.maxZoom===s&&t.minScale===a&&t.maxScale===n&&t.snapToZoom===o?t:new ee({lods:e,minZoom:i,maxZoom:s,minScale:a,maxScale:n,snapToZoom:o})}canZoomInTo(t){const e=this.effectiveMaxScale;return 0===e||t>=e}canZoomOutTo(t){const e=this.effectiveMinScale;return 0===e||t<=e}constrain(t,e){return this._zoom.constrain(t,e),this._rotation.constrain(t,e),this._geometry.constrain(t,e),this.customConstraints.forEach(i=>i.constrain(t,e)),t}constrainByGeometry(t){return this._geometry.constrain(t),this.customConstraints.forEach(e=>e.applyPanConstraint?.(t)),t}fit(t){return this._zoom.fit(t)}zoomToScale(t){return this._zoom.zoomToScale(t)}scaleToZoom(t){return this._zoom.scaleToZoom(t)}snapScale(t){return this._zoom.snapToClosestScale(t)}snapToNextScale(t){return this._zoom.snapToNextScale(t)}snapToPreviousScale(t){return this._zoom.snapToPreviousScale(t)}};t([h({readOnly:!0})],se.prototype,"effectiveLODs",null),t([h({readOnly:!0})],se.prototype,"effectiveMinScale",null),t([h({readOnly:!0})],se.prototype,"effectiveMaxScale",null),t([h({readOnly:!0})],se.prototype,"effectiveMinZoom",null),t([h({readOnly:!0})],se.prototype,"effectiveMaxZoom",null),t([h({types:ie,value:null})],se.prototype,"geometry",null),t([h({type:[b]})],se.prototype,"lods",void 0),t([h()],se.prototype,"minScale",void 0),t([h()],se.prototype,"maxScale",void 0),t([h()],se.prototype,"minZoom",void 0),t([h()],se.prototype,"maxZoom",void 0),t([h()],se.prototype,"rotationEnabled",void 0),t([h()],se.prototype,"snapToZoom",void 0),t([h({type:y})],se.prototype,"customConstraints",void 0),t([h()],se.prototype,"view",void 0),t([h({readOnly:!0})],se.prototype,"version",null),t([h({type:Wt,readOnly:!0})],se.prototype,"_geometry",null),t([h({type:Qt})],se.prototype,"_rotation",null),t([h({readOnly:!0,type:ee})],se.prototype,"_zoom",null),se=t([p("esri.views.2d.MapViewConstraints")],se);const ae=se;let ne=class extends f{constructor(t){super(t),this.constraints=null,this.ready=!1,this.resizeAlign="center",this.addHandles([i(()=>this.constraints?.version,t=>{this.constraints&&t&&this.ready&&(this.state.viewpoint=this.constraints.fit(this.state.paddedViewState.viewpoint))},s)])}get center(){if(!this.ready)return this._get("center");const{center:t,spatialReference:e}=this.state.paddedViewState;return this.state.commitProperty("id"),new j({x:t[0],y:t[1],spatialReference:e})}set center(t){if(null==t)return;if(!this.ready)return void this._set("center",t);let e;try{e=this._project(t,this.state.spatialReference)}catch(e){return void c.getLogger(this).error(new D("mapview:invalid-center","could not project the value in the view's spatial reference",{input:t,error:e}))}const i=this.viewpoint;U(i,i,e),this.viewpoint=i}get extent(){return this.ready?(this.state.commitProperty("id"),this.state.paddedViewState.extent.clone()):this._get("extent")}set extent(t){if(null==t)return;if(!t.width||!t.height)return void c.getLogger(this).error(new D("mapview:invalid-extent","invalid extent size"));if(!this.ready)return this._set("extent",t),this._set("center",void 0),this._set("viewpoint",void 0),this._set("scale",void 0),void this._set("zoom",void 0);let e;try{e=this._project(t,this.state.spatialReference)}catch(t){return void c.getLogger(this).error(new D("mapview:invalid-extent","could not project the value in the view's spatial reference",{error:t}))}const i=this.viewpoint;G(i,i,e,this.state.size,{constraints:this.constraints}),this.viewpoint=i}get padding(){return this.ready?this.state.padding:this._get("padding")}set padding(t){this.ready?(this.state.padding=t,this._set("padding",this.state.padding)):this._set("padding",t)}get resolution(){return this.ready?(this.state.commitProperty("id"),this.state.resolution):0}get rotation(){return this.ready?(this.state.commitProperty("id"),this.state.rotation):this._get("rotation")}set rotation(t){if(isNaN(t))return;if(!this.ready)return void this._set("rotation",t);const e=this.viewpoint;H(e,e,t),this.viewpoint=e}get scale(){return this.ready?(this.state.commitProperty("id"),this.state.scale):this._get("scale")}set scale(t){if(!t||isNaN(t))return;if(!this.ready){this._set("scale",t),this._set("zoom",void 0);const e=this._get("extent");return void(e&&(this._set("extent",void 0),this._set("center",e.center)))}const e=this.viewpoint;K(e,e,t),this.viewpoint=e}get viewpoint(){return this.ready?this.state.paddedViewState.viewpoint.clone():this._get("viewpoint")}set viewpoint(t){if(null==t)return;if(!this.ready)return this._set("viewpoint",t),this._set("extent",void 0),this._set("center",void 0),this._set("zoom",void 0),void this._set("scale",void 0);let i,s;try{i=this._project(t,this.state.spatialReference),!t.scale||isNaN(t.scale)?s=new D("mapview:invalid-viewpoint",`invalid scale value of ${t.scale}`):null==t.targetGeometry&&(s=new D("mapview:invalid-viewpoint","geometry not defined"))}catch(t){s=new D("mapview:invalid-viewpoint","could not project the value in the view's spatial reference",{error:t})}if(s)return void c.getLogger(this).error(s);this._scaleBeforeChangingSpatialReference=null;const a=new e({targetGeometry:new j,scale:0,rotation:0});F(a,i),this.constraints?.constrain(a,this.state.paddedViewState.viewpoint),this.state.viewpoint=a,this._set("viewpoint",a)}get visibleArea(){return this.ready?this.state.visibleArea:null}get zoom(){return this.ready?this.constraints?.scaleToZoom(this.scale)??-1:this._get("zoom")}set zoom(t){if(!(t>=0))return;if(!this.ready){this._set("zoom",t),this._set("scale",void 0);const e=this._get("extent");return void(e&&(this._set("extent",void 0),this._set("center",e.center)))}const e=this.constraints?.zoomToScale(t)??0;if(!e)return void this._set("zoom",-1);const i=this.viewpoint;K(i,i,e),this.viewpoint=i,this._set("zoom",this.constraints?.scaleToZoom(this.scale)??-1)}getUserStartupOptions(t){if(!t[0]&&!t[1])return{center:void 0,rotation:void 0,scale:void 0};const{padding:e,constraints:i}=this,s=this._get("center"),a=this._get("extent"),n=this._get("scale"),o=this._get("rotation"),r=this._get("viewpoint"),h=this._get("zoom"),l=null!=h&&null!=i&&i.zoomToScale(h)||void 0;let c,p,d;const u=r?.rotation,m=r?.targetGeometry;"extent"===m?.type?c=m:"point"===m?.type&&(p=m,d=r?.scale);const v=a??c;return{center:s??p??v?.center,rotation:o??u,scale:(n??l??d??(v&&q(v,[t[0]-e.left-e.right,t[1]-e.top-e.bottom])))||void 0}}startup(t,e,i,s){const a=t.targetGeometry;try{this._project(t,i)}catch(e){c.getLogger(this).warn(new E("mapview:startup-projection-error","projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.",{center:a.toJSON(),spatialReference:i,error:e})),t.targetGeometry=s||new j({x:0,y:0,spatialReference:i})}this.constraints?.fit(t),this._set("state",new qt({padding:this.padding,size:e,viewpoint:t})),this._set("ready",!0)}teardown(){this._set("ready",!1);const{center:[t,e],spatialReference:i,rotation:s,scale:a}=this.state.paddedViewState,n=new j({x:t,y:e,spatialReference:i});this._set("viewpoint",null),this._set("extent",null),this._set("center",n),this._set("zoom",-1),this._set("rotation",s),this._set("scale",a),this._set("state",null)}changeSpatialReference(t){const i=this.state.paddedViewState.clone();if(null==this._scaleBeforeChangingSpatialReference)this._scaleBeforeChangingSpatialReference=i.scale;else{const t=i.viewpoint.clone();t.scale=this._scaleBeforeChangingSpatialReference,i.viewpoint=t}const s=i.clone(),[a,n]=i.center;let o=null;try{o=this._project(new j({x:a,y:n,spatialReference:i.spatialReference}),t)}catch(e){I()||c.getLogger(this).warn(new E("mapview:spatial-reference-change","could not project the view's center to the new spatial reference",{center:o?.toJSON(),spatialReference:t,error:e}))}o||(o=new j({x:0,y:0,spatialReference:t}));const r=U(new e({targetGeometry:new j,scale:0,rotation:0}),i.viewpoint,o);s.viewpoint=r;try{const e=20,a=[i.size[0]/2,i.size[1]/2],n=[a[0]+e,a[1]],o=i.toMap([0,0],n),{x:h,y:c}=this._project(new j({x:o[0],y:o[1],spatialReference:i.spatialReference}),t);o[0]=h,o[1]=c,s.toScreen(o,o);const p=B(a,o,n),d=Math.hypot(o[0]-a[0],o[1]-a[1])/e;!Number.isFinite(d)||Math.abs(d)>4?(r.rotation=0,r.targetGeometry=new j({x:0,y:0,spatialReference:t})):(r.scale*=d,r.scale>l("mapview-srswitch-adjust-rotation-scale-threshold")?r.rotation=0:r.rotation+=Number.isFinite(p)?p:0)}catch{}this._get("constraints")?.constrain(r,void 0),this._get("state").viewpoint=r}resize(t,e){if(!this.ready)return;const i=this.state;let s=this.state.paddedViewState.viewpoint;const a=this.state.paddedViewState.size.slice();i.size=[t,e],$(s,s,a,this.state.paddedViewState.size,this.resizeAlign),s=this.constraints?.constrain(s,void 0)??s,this.state.viewpoint=s}toMap(t){if(!this.ready)return null;const[e,i]=this.state.toMap([0,0],[t.x,t.y]),s=this.state.spatialReference;return new j({x:e,y:i,spatialReference:s})}toScreen(t,e){if(!this.ready)return null;const i=this._project(t,this.state.spatialReference),s=[i.x,i.y];return!1===e?.pickClosestTarget||this.state.paddedViewState.wrapMapCoordinate(s,s),this.state.toScreen(s,s),A(s[0],s[1])}_project(t,e){const i=t?.targetGeometry||t;if(!e)return t;if(!i)return null;if(e.imageCoordinateSystem||i.spatialReference?.imageCoordinateSystem)return t;if(N(e,i.spatialReference))return t;const s=k(i,e);if(!s)throw new D("mapview:projection-not-possible","projecting input geometry to target spatial reference returned a null value",{geometry:i,spatialReference:e});return function(t){return"esri.Viewpoint"===t?.declaredClass}(t)?(t.targetGeometry=s,t):s}};t([h({type:j})],ne.prototype,"center",null),t([h()],ne.prototype,"constraints",void 0),t([h({type:x})],ne.prototype,"extent",null),t([h({value:{top:0,right:0,bottom:0,left:0},cast:t=>({top:0,right:0,bottom:0,left:0,...t})})],ne.prototype,"padding",null),t([h()],ne.prototype,"ready",void 0),t([h()],ne.prototype,"resizeAlign",void 0),t([h({readOnly:!0})],ne.prototype,"resolution",null),t([h({type:Number})],ne.prototype,"rotation",null),t([h({type:Number})],ne.prototype,"scale",null),t([h({readOnly:!0})],ne.prototype,"state",void 0),t([h({type:e})],ne.prototype,"viewpoint",null),t([h({readOnly:!0})],ne.prototype,"visibleArea",null),t([h()],ne.prototype,"zoom",null),ne=t([p("esri.views.2d.ViewStateManager")],ne);let oe=class extends f{constructor(){super(...arguments),this._timer=void 0}get stationary(){return!this._timer}flip(){this._timestamp=performance.now(),null==this._timer&&(this._timer=setInterval(()=>{performance.now()-this._timestamp>=160&&this.clear()},160))}clear(){this._timer&&(clearInterval(this._timer),this._timer=void 0)}};t([h()],oe.prototype,"_timer",void 0),t([h()],oe.prototype,"stationary",null),oe=t([p("esri.views.2d.support.StationaryManager")],oe);const re=a=>{const n=a;let o=class extends n{constructor(...t){super(...t),this.fullOpacity=1,this.stateManager=new ne({constraints:new ae({view:this})}),this.stationaryManager=new oe,this.mapViewNavigation=null,this.renderingOptions={samplingMode:"dynamic",edgeLabelsVisible:!1,labelsAnimationTime:0,labelCollisionsEnabled:!1},this.frameTask=new Bt(this),this.viewEvents=new X(this),this.padding={top:0,right:0,bottom:0,left:0},this.addHandles([i(()=>this.viewpoint,()=>this.stationaryManager.flip(),s)])}get constraintsInfo(){return{lods:null,spatialReference:null}}get extent(){return this.stateManager?.extent??null}set extent(t){this.stateManager.extent=t}get state(){return this.stateManager.state}get interacting(){return!1}get stationary(){return!this.animation&&this.stationaryManager.stationary}set animation(t){const e=this._get("animation");if(t===e)return;if(e&&e.stop(),t!==this.animationManager.animation&&this.animationManager.stop(),!t||t.isFulfilled())return void this._set("animation",null);this._set("animation",t);const i=()=>{this.destroyed||t===this._get("animation")&&(this._set("animation",null),this.frameTask?.requestFrame())};t.when(i,i)}get constraints(){return this.stateManager?.constraints}set constraints(t){t.view=this;const e=this.stateManager.constraints;this.stateManager.constraints=t,e?.destroy()}get padding(){return this.stateManager?.padding}set padding(t){this.stateManager&&(this.stateManager.padding=t)}get resizeAlign(){return this.stateManager.resizeAlign}set resizeAlign(t){this.stateManager.resizeAlign=t}get rotation(){return this.stateManager.rotation??0}set rotation(t){const{rotationEnabled:e}=this.constraints;this.constraints.rotationEnabled=!0,this.stateManager.rotation=t,this.constraints.rotationEnabled=e}get viewpoint(){return this.stateManager.viewpoint??null}set viewpoint(t){this.stateManager.viewpoint=t,this.frameTask.requestFrame()}};return t([h({readOnly:!0})],o.prototype,"animationManager",void 0),t([h({readOnly:!0})],o.prototype,"fullOpacity",void 0),t([h()],o.prototype,"stateManager",void 0),t([h()],o.prototype,"constraintsInfo",null),t([h()],o.prototype,"extent",null),t([h({readOnly:!0})],o.prototype,"state",null),t([h({readOnly:!0})],o.prototype,"mapViewNavigation",void 0),t([h()],o.prototype,"renderingOptions",void 0),t([h({readOnly:!0})],o.prototype,"interacting",null),t([h()],o.prototype,"stationary",null),t([h()],o.prototype,"animation",null),t([h({type:ae})],o.prototype,"constraints",null),t([h()],o.prototype,"padding",null),t([h()],o.prototype,"resizeAlign",null),t([h()],o.prototype,"rotation",null),t([h({readOnly:!0})],o.prototype,"viewEvents",void 0),t([h({type:e})],o.prototype,"viewpoint",null),o=t([p("esri.views.Viewport2DBaseMixin")],o),o};let he=class extends f{constructor(t){super(t),this._gotoTask=null}destroy(){this._gotoTask=null}async goTo(t,e){if(!t)return void c.getLogger(this).error("#goTo()","target cannot be null or undefined");const i=new et;this.view.animation=i,await n(()=>this.view.ready,e);const s={...e,animate:e?.animate??!tt(),animationMode:e?.animationMode??"auto"},{extent:a,spatialReference:o,size:r,viewpoint:h,constraints:l,padding:p,allLayerViews:d}=this.view,u=W(t,{extent:a,spatialReference:o,size:r,viewpoint:h,constraints:l,padding:p,allLayerViews:d,pickClosestTarget:e?.pickClosestTarget??!0});return i?.update(u),this._gotoTask={},s.animate?this._gotoAnimated(u,s):this._gotoImmediate(u,s)}_gotoImmediate(t,e){const i=this._gotoTask,s=this.view.animation,a=t.then(t=>{if(u(e),i!==this._gotoTask)throw new D("view:goto-interrupted","Goto was interrupted");this.view.viewpoint=s.target=t,s.finish()});return this._cancellableGoTo(i,s,a,e)}_gotoAnimated(t,e){const i=this._gotoTask,s=this.view.animation;if(!s)return Promise.resolve();const a=t.then(t=>{if(u(e),i!==this._gotoTask)throw new D("view:goto-interrupted","Goto was interrupted");return s.update(t),this.view.animationManager.animate(s,this.view.viewpoint,e),s.when().then(()=>{},()=>{})});return this._cancellableGoTo(i,s,a,e)}_cancellableGoTo(t,e,i,s){const a=()=>t===this._gotoTask;return m(i,s).finally(()=>{a()&&(e.done||e.stop())})}};t([h({constructOnly:!0})],he.prototype,"view",void 0),he=t([p("esri.views.2d.GoToManager")],he);class le extends at{constructor(t,e){super(!0),this._view=t,this.registerIncoming("double-click",e,t=>this._handleDoubleClick(t,e))}_handleDoubleClick(t,e){rt(t.data,"primary")&&(t.stopPropagation(),e?this._view.mapViewNavigation.zoomOut([t.data.x,t.data.y]):this._view.mapViewNavigation.zoomIn([t.data.x,t.data.y]))}}class ce extends at{constructor(t,e,i){super(!0),this.view=t,this.pointerType=e,this.registerIncoming("double-tap-drag",i,t=>this._handleDoubleTapDrag(t))}_handleDoubleTapDrag(t){const{data:e}=t,{pointerType:i}=e;if(i!==this.pointerType)return;t.stopPropagation();const{action:s,delta:a}=e,{view:n}=this,{mapViewNavigation:o}=n;switch(s){case"begin":{const{scale:t}=n;this._startScale=t,this._currentScale=t,this._previousDelta=a,o.begin();break}case"update":{if(this._previousDelta.y===a.y)return;this._previousDelta=a;const t=1.015**a.y,e=this._startScale*t,i=e/this._currentScale;o.setViewpointImmediate(i),this._currentScale=e;break}case"end":{const{constraints:t}=n,{effectiveLODs:e,snapToZoom:i}=t;if(!i||!e)return void o.end();const s=t.snapScale(this._currentScale),r=(a.y>0?Math.max(s,t.snapToPreviousScale(this._startScale)):Math.min(s,t.snapToNextScale(this._startScale)))/this._currentScale;o.zoom(r).then(()=>{o.end()});break}}}}class pe extends at{constructor(t,e,i){super(!0),this.view=t,this.pointerActions=e,this.registerIncoming("drag",i,t=>this._handleDrag(t)),this.registerIncoming("pointer-down",()=>this.stopMomentumNavigation())}onInstall(t){super.onInstall(t),this._dragEventSeparator=new ht({start:(t,e)=>{this.view.mapViewNavigation.pan.begin(this.view,e.data),e.stopPropagation()},update:(t,e)=>{this.view.mapViewNavigation.pan.update(this.view,e.data),e.stopPropagation()},end:(t,e)=>{this.view.mapViewNavigation.pan.end(this.view,e.data),e.stopPropagation()},condition:(t,e)=>1===t&&lt(e.data,this.pointerActions)})}_handleDrag(t){const e=this.view.mapViewNavigation;e.pinch.zoomMomentum||e.pinch.rotateMomentum?this.stopMomentumNavigation():this._dragEventSeparator.handle(t)}stopMomentumNavigation(){this.view.mapViewNavigation.pan.stopMomentumNavigation()}}class de extends at{constructor(t,e,i){super(!0),this._view=t,this.pointerActions=e;const s=this._view.mapViewNavigation;this._dragEventSeparator=new ht({start:(t,e)=>{s.rotate.begin(this._view,e.data),e.stopPropagation()},update:(t,e)=>{s.rotate.update(this._view,e.data),e.stopPropagation()},end:(t,e)=>{s.rotate.end(),e.stopPropagation()},condition:(t,e)=>1===t&&lt(e.data,this.pointerActions)}),this.registerIncoming("drag",i,t=>this._dragEventSeparator.handle(t))}}class ue extends at{constructor(t){super(!0),this._view=t,this._frameTask=null,this._watchHandles=new zt,this._currentDevice=null,this._transformation={translation:[0,0,0],heading:0,tilt:0,zoom:0},this._handle=this.registerIncoming("gamepad",t=>this._handleGamePadEvent(t)),this._handle.pause()}onInstall(t){super.onInstall(t),this._watchHandles.add([i(()=>this._view.navigation.gamepad?.enabled,t=>{t?(this._handle.resume(),this._frameTask||(this._frameTask=g({update:t=>this._frameUpdate(t.deltaTime)}))):(this._handle.pause(),this._frameTask&&(this._frameTask.remove(),this._frameTask=null))},o)])}onUninstall(){this._watchHandles.removeAll(),this._frameTask&&(this._frameTask.remove(),this._frameTask=null),super.onUninstall()}_handleGamePadEvent(t){const e=this._view.navigation.gamepad.device;e&&t.data.device!==e||this._currentDevice&&this._currentDevice!==t.data.device||("end"===t.data.action?(this._currentDevice=null,ct(this._transformation)):(this._currentDevice=t.data.device,pt(t.data,this._view.navigation.gamepad,this._transformation)),this._frameTask?.resume())}_frameUpdate(t){const e=this._transformation;if(dt(e))return void this._frameTask?.pause();const i=this._view.viewpoint.clone(),s=this._view.navigation.gamepad.velocityFactor,a=ve*s*t;J(i,i,[e.translation[0]*a,-e.translation[1]*a]);const n=1+e.translation[2]*ge*t,o=this._view.constraints.rotationEnabled?-e.heading*me*t:0,r=this._view.size,h=[r[0]/2,r[1]];Y(i,i,n,o,h,r);const l=this._view.constraints.constrain(i,this._view.viewpoint);this._view.viewpoint=l}}const me=.06,ve=.7,ge=6e-4;class _e extends at{constructor(t,e,i){super(!0),this.view=t,this.keys=e,this._isSticky=!1,this._pressedKeys=new Set,this._timeout=void 0,this._currentDirection=void 0,this._stickyKeyDuration=200,this._handleKey=t=>{const e=this._keyMap[t.data.key];if(t.modifiers.has("Meta")||t.modifiers.has("Control"))return void this._stopMovement();if(null==e)return;t.stopPropagation(),t.preventDefault();const i="key-down"===t.type;if(this._pressedKeys[i?"add":"delete"](e),i){if(this._direction===e)return;this._direction=e,this._isSticky=!1,this._setTimeout(()=>{this._isSticky&&this._handlePopKey()})}else{const t=void 0===this._timeout,e=this._pressedKeys.size>0;t||e?this._handlePopKey():this._isSticky=!0}},this._handlePopKey=()=>{this._direction=Array.from(this._pressedKeys).pop(),null==this._direction&&this._stopMovement()},this._stopMovement=()=>{this._isSticky=!1,this._direction=void 0,this._pressedKeys.clear(),this._setTimeout(void 0)},this._keyMap={[e.left]:"left",[e.right]:"right",[e.up]:"up",[e.down]:"down"},this.registerIncoming("key-down",i,this._handleKey),this.registerIncoming("key-up",i,this._handleKey),this.registerIncoming("blur",i,this._stopMovement),this._visibilityHandle=ut(t=>t?null:this._stopMovement())}onUninstall(){this._stopMovement(),this._visibilityHandle?.remove()}get _direction(){return this._currentDirection}set _direction(t){const e=null!=this._currentDirection;if(null!=t){if(e||this.view.mapViewNavigation.begin(),this._currentDirection!==t)switch(t){case"left":this.view.mapViewNavigation.continuousPanLeft();break;case"right":this.view.mapViewNavigation.continuousPanRight();break;case"up":this.view.mapViewNavigation.continuousPanUp();break;case"down":this.view.mapViewNavigation.continuousPanDown()}}else e&&this.view.mapViewNavigation.stop();this._currentDirection=t}_setTimeout(t){clearTimeout(this._timeout),this._timeout=void 0===t?void 0:setTimeout(()=>{this._timeout=void 0,t()},this._stickyKeyDuration)}}class we extends at{constructor(t,e,i){super(!0),this.view=t,this.keys=e,this._keyToDirection=new Map,this._pressed=!1,this._addKeysMapping(e),this.registerIncoming("key-down",i,t=>this._handleKeyDown(t)),this.registerIncoming("key-up",i,t=>this._handleKeyUp(t)),this.registerIncoming("blur",i,()=>this._handleStop()),this._visibilityHandle=ut(t=>t?null:this._handleStop())}onUninstall(){this._visibilityHandle?.remove(),this._handleStop()}_addKeysMapping(t){this._addKeyMapping(t.clockwise,"clockwise"),this._addKeyMapping(t.counterClockwise,"counterClockwise"),this._addKeyMapping(t.reset,"reset")}_addKeyMapping(t,e){for(const i of t)this._keyToDirection.set(i,e)}_handleKeyDown(t){t.data.repeat||this._handleKey(t,!0)}_handleKeyUp(t){this._handleKey(t,!1)}_handleStop(){this._pressed&&(this._pressed=!1,this.view.mapViewNavigation.stop())}_handleKey(t,e){const i=t.modifiers;if(i.size>0&&!i.has("Shift")||!this.view.constraints.rotationEnabled)return;const s=this._keyToDirection.get(t.data.key);if(this._pressed=null!=s,this._pressed){if(t.preventDefault(),e)switch(this.view.mapViewNavigation.begin(),s){case"clockwise":this.view.mapViewNavigation.continuousRotateClockwise();break;case"counterClockwise":this.view.mapViewNavigation.continuousRotateCounterclockwise();break;case"reset":this.view.mapViewNavigation.resetRotation()}else this._pressed=!1,this.view.mapViewNavigation.stop();t.stopPropagation()}}}class fe extends at{constructor(t,e,i){super(!0),this.view=t,this.keys=e,this._keysToZoomAction={},this.registerIncoming("key-down",i,t=>this._handleKeyDown(t)),e.zoomIn.forEach(t=>this._keysToZoomAction[t]=0),e.zoomOut.forEach(t=>this._keysToZoomAction[t]=1)}_handleKeyDown(t){this._handleKey(t)}_handleKey(t){const e=t.modifiers;if(e.size>0&&!e.has("Shift"))return;const{key:i}=t.data;if(!(i in this._keysToZoomAction))return;const s=this._keysToZoomAction[i],{mapViewNavigation:a}=this.view;let n=null;switch(s){case 0:n=a.zoomIn();break;case 1:n=a.zoomOut();break;default:return}a.begin(),n.then(()=>a.end()),t.stopPropagation()}}class ye extends at{constructor(t,e){super(!0),this._view=t,this._canZoom=!0,this.registerIncoming("mouse-wheel",e,t=>this._handleMouseWheel(t))}_handleMouseWheel(t){if("zoom"!==this._view.navigation.actionMap.mouseWheel)return;if(t.preventDefault(),t.stopPropagation(),!this._canZoom)return;const e=this._view.mapViewNavigation,{x:i,y:s,deltaY:a}=t.data,n=1/.6**(1/60*a),o=e.zoom(n,[i,s]);this._canZoom=!1,o.catch(()=>{}).then(()=>{this._canZoom=!0,e.end()})}}class xe extends at{constructor(t){super(!0),this.view=t,this.registerIncoming("drag",t=>this._handleDrag(t)),this.registerIncoming("pointer-down",()=>this._stopMomentumNavigation());const e=this.view.mapViewNavigation;this._dragEventSeparator=new ht({start:(t,i)=>{e.pinch.begin(this.view,i.data),i.stopPropagation()},update:(t,i)=>{e.pinch.update(this.view,i.data),i.stopPropagation()},end:(t,i)=>{e.pinch.end(this.view),i.stopPropagation()},condition:t=>t>=2})}_handleDrag(t){this._dragEventSeparator.handle(t)}_stopMomentumNavigation(){this.view.mapViewNavigation.pinch.stopMomentumNavigation()}}class Te extends at{constructor(t={},e=v){super(!1),this._clock=e,this._doubleTapDragReady=!1,this._doubleTapDragActive=!1,this._dragStartCenter=A(0,0),this._pointerState=new Map,this._parameters=mt(t),this._doubleTapDrag=this.registerOutgoing("double-tap-drag"),this._dragEventSeparator=new ht({start:(t,e)=>this._dragStart(t,e),update:(t,e)=>this._dragUpdate(e),end:(t,e)=>this._dragEnd(e)}),this.registerIncoming("drag",t=>this._dragEventSeparator.handle(t)),this.registerIncoming("pointer-down",t=>this._handlePointerDown(t)),this.registerIncoming("pointer-up",()=>this._handlePointerUp())}onUninstall(){this._pointerState.forEach(t=>{t.doubleTapTimeout=it(t.doubleTapTimeout)})}get hasPendingInputs(){for(const t of this._pointerState.values())if(null!=t.doubleTapTimeout)return!0;return!1}_clearPointerDown(t){const e=this._pointerState.get(t);e&&(e.doubleTapTimeout=it(e.doubleTapTimeout),this._pointerState.delete(t),this.refreshHasPendingInputs())}_dragStart(t,e){if(!this._doubleTapDragReady||1!==t)return;this._doubleTapDragReady=!1,this._doubleTapDragActive=!0;const{data:i,modifiers:s}=e,{center:a}=i;this._dragStartCenter=a;const n=Se("begin",A(0,0),i);this._doubleTapDrag.emit(n,void 0,s),e.stopPropagation()}_dragUpdate(t){if(!this._doubleTapDragActive)return;const{data:e,modifiers:i}=t,{center:s}=e,a=Se("update",A(s.x-this._dragStartCenter.x,s.y-this._dragStartCenter.y),e);this._doubleTapDrag.emit(a,void 0,i),t.stopPropagation()}_dragEnd(t){if(!this._doubleTapDragActive)return;const{data:e,modifiers:i}=t,{center:s}=e,a=Se("end",A(s.x-this._dragStartCenter.x,s.y-this._dragStartCenter.y),e);this._doubleTapDrag.emit(a,void 0,i),this._doubleTapDragActive=!1,t.stopPropagation()}_handlePointerDown(t){const{data:e}=t,i=vt(e),s=this._pointerState.get(i),{pointerType:a}=e.native;if(s){const n="touch"===a?this._parameters.maximumDoubleTouchDistance:this._parameters.maximumDoubleClickDistance;this._clearPointerDown(i),gt(s.event.data,e)>n?this._storePointerDown(t):this._doubleTapDragReady=!0}else this._storePointerDown(t)}_handlePointerUp(){this._doubleTapDragReady=!1}_storePointerDown(t){const{data:e}=t,{pointerType:i}=e.native,s=vt(e),a="touch"===i?this._parameters.maximumDoubleTouchDelay:this._parameters.maximumDoubleClickDelay,n=this._clock.setTimeout(()=>this._clearPointerDown(s),a);this._pointerState.set(s,{event:t,doubleTapTimeout:n}),this.refreshHasPendingInputs()}}function Se(t,e,i){const{button:s,buttons:a,pointer:n,pointers:o,pointerType:r,timestamp:h}=i;return{action:t,delta:e,button:s,buttons:a,pointer:n,pointers:o,pointerType:r,timestamp:h}}const Me={left:"ArrowLeft",right:"ArrowRight",up:"ArrowUp",down:"ArrowDown"},be={zoomIn:["=","+"],zoomOut:["-","_"]},ze={clockwise:["a","A"],counterClockwise:["d","D"],reset:["n","N"]},ke=Symbol("handles");let De=class extends f{initialize(){const t=()=>this.view?.ready;this.addHandles([a(()=>!t(),()=>this._disconnect()),a(t,()=>this._connect())])}destroy(){this._disconnect()}get latestPointerType(){return this._inputManager?.latestPointerType}get latestPointerLocation(){return this._inputManager?.latestPointerLocation}get multiTouchActive(){return this._inputManager?.multiTouchActive??!1}isModifierKeyDown(t){return this._inputManager?.isModifierKeyDown(t)??!1}_disconnect(){this.view.viewEvents.disconnect(),this.removeHandles(ke),this._inputManager=st(this._inputManager)}_connect(){const t=this.view.surface,e=new _t(t,this.view.input),s=[new wt,new ft,new yt,new xt(this.view.navigation),new Te],a=new nt({eventSource:e,recognizers:s}),n=new pe(this.view,["primary"]),h=new de(this.view,["secondary"]);a.installHandlers("prevent-context-menu",[new Tt],ot.INTERNAL),a.installHandlers("navigation",[new xe(this.view),new ue(this.view),new ye(this.view),new le(this.view),new le(this.view,["Control"]),n,new _e(this.view,Me),new fe(this.view,be),new we(this.view,ze),h,new ce(this.view,"touch")],ot.INTERNAL),this.view.viewEvents.connect(a),this._source=e,this._inputManager=a,this.addHandles([i(()=>this.view?.navigation?.browserTouchPanEnabled,t=>{this._source&&(this._source.browserTouchPanningEnabled=!t)},o),i(()=>{const{actionMap:t}=this.view.navigation;return{panActions:St("pan",t),rotateActions:St("rotate",t)}},({panActions:t,rotateActions:e})=>{n.pointerActions=t,h.pointerActions=e},r)],ke)}get test(){}};t([h()],De.prototype,"view",void 0),t([h()],De.prototype,"latestPointerType",null),t([h()],De.prototype,"latestPointerLocation",null),t([h()],De.prototype,"multiTouchActive",null),De=t([p("esri.views.2d.input.MapViewInputManager")],De);const Re=De,Pe=e=>{const i=e;let s=class extends i{constructor(...t){super(...t),this.goToManager=new he({view:this}),this.inputManager=new Re({view:this}),this.addHandles([this.on("resize",t=>this.stateManager.resize(t.width,t.height))])}get interacting(){return this.navigating}get stationary(){return!this.animation&&!this.navigating&&!this.resizing&&this.stationaryManager.stationary}on(t,e,i,s){return this.viewEvents.on(t,e,i,s)||super.on(t,e)}hasEventListener(t){return super.hasEventListener(t)||this.viewEvents.hasHandler(t)}goTo(t,e){return this.goToManager.goTo(t,e)}toMap(t){if(!this.ready)return null;const e=kt(t)?Dt(this,t):t;return this.stateManager.toMap(e)}};return t([h()],s.prototype,"goToManager",void 0),t([h({readOnly:!0})],s.prototype,"interacting",null),t([h()],s.prototype,"stationary",null),t([h({readOnly:!0})],s.prototype,"inputManager",void 0),s=t([p("esri.views.Viewport2DMixin")],s),s};class Ve{constructor(t){this._view=t,this.viewpoint=new e({targetGeometry:new j,scale:0,rotation:0})}get view(){return this._view}get size(){const[t,e]=this._view.size;return Math.sqrt(t*t+e*e)}get scale(){return this.viewpoint.scale}get rotation(){return this.viewpoint.rotation}get center(){return this.viewpoint.targetGeometry}get scaleToResolutionFactor(){return Q(this.center.spatialReference)}pixelsPerPanAtZoom(t){return 1/(t*this.scaleToResolutionFactor)}zoomAtPixelsPerPan(t){return 1/(t*this.scaleToResolutionFactor)}pixelsPerRotate(){return this.size/2}compareTo(t,e){e.pan=C(this.center,t.center);let i=Math.abs(t.rotation-this.rotation);i=i>=180?360-i:i,e.rotate=Vt(i),e.sourceZoom=this.scale,e.targetZoom=t.scale}interpolate(t,e,i){const{pan:s,rotate:a,zoom:n,zoomOffset:o}=i,{center:r}=this;r.spatialReference=t.center.spatialReference,r.x=Zt(t.center.x,e.center.x,s),r.y=Zt(t.center.y,e.center.y,s),this.viewpoint.scale=Zt(t.scale,e.scale+o,n);let h=t.rotation;const l=e.rotation;Math.abs(l-h)>=180&&(h+=360*(h<l?1:-1)),this.viewpoint.rotation=Zt(h,l,a)}copyFrom(t){F(this.viewpoint,t.viewpoint),this._view=t.view}}class Ze{constructor(t){this._view=t,this._animation=new bt(()=>new Ve(this._view)),this._current=new Ve(this._view)}get _source(){return this._animation.definition.source}get _target(){return this._animation.definition.target}get duration(){return this._animation.time}get animation(){return this._animation}update(t,e,i={}){F(this._current.viewpoint,t),F(this._source.viewpoint,t),F(this._target.viewpoint,e),this._animation.update(this._source,this._target,i)}applyRatio(t,e){this._animation.cameraAt(e,this._current),F(t,this._current.viewpoint)}}let je=class extends f{constructor(t){super(t),this._animation=null,this._destinationViewState=new qt,this.updateFunction=null,this.easing=jt.ease,this.viewpoint=new e({targetGeometry:new j,scale:0,rotation:0}),this._updateTask=g({postRender:this._postRender.bind(this)}),this._updateTask.pause(),this._transition=new Ze(t.view)}destroy(){this._updateTask=it(this._updateTask)}get animation(){return this._animation}set animation(t){this._animation=t,this.view.animation=t}animate(t,e,i){this.stop();const s=this.viewpoint;F(s,e);const a=t.target;this._transition.update(this.viewpoint,a,{apex:{maximumDistance:Math.min(64*Math.min(e.scale,a.scale),this.view.constraints.effectiveMinScale),desiredSlope:5e-8},duration:i?.duration,maxDuration:"auto"===i?.animationMode?_(1/0):i?.maxDuration??Mt.maxDuration,speedFactor:i?.speedFactor,easing:("string"==typeof i?.easing?jt[i.easing]:i?.easing)||this.easing}),"auto"===i?.animationMode&&(this._destinationViewState.copy(this.view.state),this._destinationViewState.viewpoint=a,function(t,e,i,s){if(null!=e?.duration)return!0;const{time:a,isLinear:n}=t,o=e?.speedFactor||1;if(a>(e?.maxDuration??Mt.maxDuration/o))return!1;if(n){const t=1.5,e=Rt(),n=A(...s.toScreen(e,...i.center)),r=A(...i.toScreen(e,...s.center)),h=null!=r&&r.x>-1*i.size[0]&&r.x<(t+.5)*i.size[0]&&r.y>-1*i.size[1]&&r.y<(t+.5)*i.size[1],l=null!=n&&n.x>-1*s.size[0]&&n.x<(t+.5)*s.size[0]&&n.y>-1*s.size[1]&&n.y<(t+.5)*s.size[1];if(a>2e3/o&&!h&&!l)return!1}return!0}(this._transition.animation,i,this.view.state,this._destinationViewState)||this._transition.update(this.viewpoint,a,{duration:_(0)}));const n=()=>{this.animation===t&&this._updateTask&&("finished"===t.state&&(this._transition.applyRatio(this.viewpoint,1),this.view.state&&(this.view.state.viewpoint=this.viewpoint.clone())),this.animation=null,this.updateFunction=null)};return t.when(n,n),this._startTime=performance.now(),this._updateTask.resume(),this.animation=t,t}animateContinuous(t,e){this.stop(),this.updateFunction=e,this.viewpoint=t;const i=new et({target:t.clone()}),s=()=>{this.animation===i&&this._updateTask&&(this.animation=null,this.updateFunction=null)};return i.when(s,s),this._startTime=performance.now(),this._updateTask.resume(),this.animation=i,i}stop(){this.animation&&(this.animation.stop(),this.animation=null,this.updateFunction=null)}_postRender(t){const e=this.animation;if(e&&e.state!==et.state.STOPPED){if(this.updateFunction)this.updateFunction(this.viewpoint,t.deltaTime),this.animation?.update(this.viewpoint);else{const t=performance.now()-this._startTime,e=this._transition.duration,i=e>0?t/e:1,s=i>=1;this._transition.applyRatio(this.viewpoint,i),s&&this.animation?.finish()}this.view.state&&(this.view.state.viewpoint=this.viewpoint.clone())}else this._updateTask.pause()}};t([h()],je.prototype,"easing",void 0),t([h()],je.prototype,"view",void 0),t([h()],je.prototype,"viewpoint",void 0),je=t([p("esri.views.2d.AnimationManager")],je);const Ce=je;class Oe{constructor(t,e={}){this.events=new Ct,this._hasMajorPerformanceCaveat=!1,this._lastRenderFrameCounter=0,null!=t?(this._canvas=document.createElement("canvas"),this._canvas.setAttribute("style","width: 100%; height:100%; display:block; willChange:transform"),t.contains(this._canvas)||t.appendChild(this._canvas)):null!=e.canvas&&(this._canvas=e.canvas);const i={failIfMajorPerformanceCaveat:!0,alpha:!0,antialias:!1,depth:!0,stencil:!0,powerPreference:"high-performance"};let s=this._canvas.getContext("webgl2",i);s||(s=this._canvas.getContext("webgl2",{...i,failIfMajorPerformanceCaveat:!1}),this._hasMajorPerformanceCaveat=!0),this._gl=s,this._handles=At([Ot(this._canvas,"webglcontextlost",t=>this.events.emit("webgl-context-lost",t))])}destroy(){this._canvas.remove(),this._canvas=null,this._handles.remove(),this._gl=null}get gl(){return this._gl}get canvas(){return this._canvas}render(t,e){if(this._hasMajorPerformanceCaveat||l("esri-force-performance-mode")){if(++this._lastRenderFrameCounter>=l("esri-performance-mode-frames-between-render")&&(e(),this._lastRenderViewState=t.state.clone(),this._lastRenderFrameCounter=0),this._lastRenderViewState){const[e,i,s,a,n,o]=this._computeViewTransform(this._lastRenderViewState,t.state);this._canvas.style.transform=`matrix(${e}, ${i}, ${s}, ${a}, ${n}, ${o})`}}else e()}resize(t){const e=this._canvas,i=e.style,{state:{size:s},pixelRatio:a}=t,n=s[0],o=s[1],r=Math.round(n*a),h=Math.round(o*a);e.width===r&&e.height===h||(e.width=r,e.height=h),i.width=n+"px",i.height=o+"px"}_computeViewTransform(t,e){const[i,s]=t.center,[a,n]=e.center,[o,r]=t.toScreen([0,0],a,n),[h,l]=t.toScreen([0,0],i,s),c=h-o,p=l-r,d=t.scale/e.scale,u=e.rotation-t.rotation,m=Ut();return Et(m),It(m,m,[d,d]),Nt(m,m,Vt(u)),Lt(m,m,[c,p]),m}}export{Ce as A,he as G,ae as M,re as V,Pe as a,ne as b,Oe as c};
