/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import s,{i as e}from"../request.js";import{h as t}from"../core/lang.js";import{L as r}from"./Logger.js";import{throwIfAborted as o,after as a,throwIfAbortError as n}from"../core/promiseUtils.js";import{M as i}from"../core/scheduling.js";import{join as c,parseData as p}from"../core/urlUtils.js";import{a as l}from"./uuid.js";import m from"../geometry/SpatialReference.js";import{e as u,b as f,c as d,a as g,S as j}from"./External.js";import{U as y,N as h,a as w,C as b,b as P,B as T,c as v,d as S,e as U}from"./uploadAssetErrors.js";import{m as A,e as F,u as x,a as D,s as E}from"./progressUtils.js";import{f as R,h as N,j as k,k as C,d as O}from"./infoFor3D.js";import{g as q}from"./meshSpatialReferenceScaleUtils.js";import{a as I,e as B}from"./meshFeatureAttributes.js";import"../config.js";import"./object.js";import"../kernel.js";import"../core/Error.js";import"./string.js";import"./jsonUtils.js";import"./MapUtils.js";import"./persistableUrlUtils.js";import"./handleUtils.js";import"./events.js";import"./maybe.js";import"./nextTick.js";import"./PooledArray.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"./ensureType.js";import"./Warning.js";import"./get.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"../core/JSONSupport.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"./writer.js";import"../geometry/support/MeshTransform.js";import"../core/Clonable.js";import"./mat4.js";import"./common.js";import"./mat4f64.js";import"./quat.js";import"./vec3f64.js";import"./vec3.js";import"./vec4.js";import"./quatf64.js";import"./axisAngleDegrees.js";import"./mathUtils.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"./reader.js";import"../geometry/Geometry.js";import"../geometry/support/webMercatorUtils.js";const M=2e7;async function L(s,e,r){const a=s.length;if(!a)return r?.onProgress?.(1),[];const n=A(a,r?.onProgress,"uploadAssets");return Promise.all(s.map((s,a)=>async function(s,{layer:e,ongoingUploads:r},a){const n=r.get(s);if(n)return n;if(!function(s){return!!s.infoFor3D&&!!s.url}(e))throw new y;if(function(s,e){const{parsedUrl:t}=e;return null!=t&&s.metadata.externalSources.some(s=>u(s,t))}(s,e))return a?.onProgress?.(1),s;const i=async function(s,e,r){const{metadata:a}=s,{displaySource:n}=a,i=z(n?.source,e,{checkForConversionRequired:t("enable-feature:georeferenced-uploads")}),p=null!=i?async function(s,e,t){return{source:{type:"service",assets:await $(s,e,t)},original:!0,unitConversionDisabled:!0}}(i,e,r):a.externalSources.length>0?async function(s,e,r){const o=_(e),{externalSources:a}=s.metadata,n=function(s,e){for(const t of s){const s=z(t.source,e);if(s)return s}return null}(a,e);if(!n)throw new h;const i=A(x.uploadConvertibleSource,r?.onProgress,"uploadConvertibleSource"),p={type:"service",assets:await $(n,e,{onProgress:i.makeOnProgress("uploadEditSource")})};s.addExternalSources([{source:p,original:!0}]);const l=n.reduce((s,{asset:e})=>e instanceof File?s+e.size:s,0),u=i.simulate("serviceAssetsToGlb",D(l));try{const{source:a,transform:n,origin:i}=await async function({assets:s},e,r){const o=s.map(({assetName:s,parts:e})=>({assetName:s,assetHash:e[0].partHash}));let a;try{const s=c(e.parsedUrl.path,"convert3D"),t=e.capabilities?.operations.supportsAsyncConvert3D;a=(await(t?W:G)(s,{query:{f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:r,async:t},responseType:"json",timeout:0})).data}catch(s){throw new b}return function(s,e){const r={source:{type:"service",assets:e.assets.map(e=>{const t=C(e.contentType,s.infoFor3D.supportedFormats);if(!t)throw new P(t);return new g(e.assetName,e.contentType,[new j(e.assetURL,e.assetHash)])})},origin:void 0,transform:void 0};if(t("enable-feature:georeferenced-uploads")&&e.transform){if(r.transform=I(e.transform),e.spatialReference){const s=m.fromJSON(e.spatialReference);r.origin=B(e.transform,s)}}else r.transform=q(s.spatialReference);return r}(e,a)}(p,e,o);return s.transform=n,i&&(s.metadata.georeferenced=!0,r?.useAssetOrigin&&(s.vertexSpace.origin=[i.x,i.y,i.z??0],s.spatialReference=i.spatialReference)),{source:a,unitConversionDisabled:!0}}finally{u.remove()}}(s,e,r):async function(s,e,t){const r=A(x.uploadLocalMesh,t?.onProgress,"uploadLocalMesh"),a=async function(s,e,t){const r=_(e),a=await s.load(t),n=await a.toBinaryGLTF({origin:a.origin,signal:t?.signal,ignoreLocalTransform:!0,unitConversionDisabled:!0});return o(t),{blob:new Blob([n],{type:"model/gltf-binary"}),assetName:`${l()}.glb`,assetType:r}}(s,e,{...t,onProgress:r.makeOnProgress("meshToAssetBlob")});return{source:{type:"service",assets:await J([a],e,{...t,onProgress:r.makeOnProgress("uploadAssetBlobs")})},extent:s.extent.clone(),original:!0}}(s,e,r),u=await p;return o(r),s.addExternalSources([u]),s}(s,e,a);r.set(s,i);try{await i}finally{r.delete(s)}return s}(s,e,{...r,onProgress:n.makeOnProgress(a)})))}function z(s,{infoFor3D:e},t={}){if(!s)return null;const r=f(s);if(!r)return null;const{supportedFormats:o,editFormats:a}=e,n=new Array,i=R(e),c=N(e);let p=!1;for(const s of r){const e=H(s,o);if(!e)return null;const{assetType:r}=e;if(t.checkForConversionRequired&&(r===i||r===c))return null;a.includes(r)&&(p=!0),n.push(e)}return p?n:null}function H(s,e){const t=d(s,e);return t?{asset:s,assetType:t}:null}async function $(s,e,t){const r=s.map(s=>async function(s,e){const{asset:t,assetType:r}=s;if(t instanceof File)return{blob:t,assetName:t.name,assetType:r};const a=await t.toBlob(e);return o(e),{blob:a,assetName:t.assetName,assetType:r}}(s,t));return J(r,e,t)}async function J(t,a,i){const l=A(x.uploadAssetBlobs,i?.onProgress,"uploadAssetBlobs"),m=await function(t,a,i){const l=A(t.length,i?.onProgress,"prepareAssetItems");return Promise.all(t.map(async(t,m)=>{const u=async function(t,a,i){const{blob:l,assetType:m,assetName:u}=t;let f=null;try{const t=await async function({data:t,name:r,description:a},n,i){let p=null;try{const m=c(n,"uploads"),u=c(m,"info"),{data:f}=await s(u,{query:{f:"json"},responseType:"json"});o(i);const d=e(n),g=1e6*f.maxUploadFileSize,j=d?2e9:g,y=d?Math.min(M,g):M;if(t.size>j)throw new Error("Data too large");const h=c(m,"register"),{data:w}=await s(h,{query:{f:"json",itemName:(l=r,l.replaceAll("/","_").replaceAll("\\","_")),description:a},responseType:"json",method:"post"});if(o(i),!w.success)throw new Error("Registration failed");const{itemID:b}=w.item;p=c(m,b);const P=c(p,"uploadPart"),T=Math.ceil(t.size/y),v=new Array;for(let s=0;s<T;++s)v.push(t.slice(s*y,Math.min((s+1)*y,t.size)));const S=v.slice().reverse(),U=new Array,x=A(T,i?.onProgress,"uploadItem"),D=async()=>{for(;0!==S.length;){const e=v.length-S.length,t=S.pop(),r=new FormData,a=x.simulate(e,F(t.size));try{r.append("f","json"),r.append("file",t),r.append("partId",`${e}`);const{data:a}=await s(P,{timeout:0,body:r,responseType:"json",method:"post"});if(o(i),!a.success)throw new Error("Part upload failed")}finally{a.remove()}}};for(let s=0;s<3&&0!==S.length;++s)U.push(D());await Promise.all(U);const E=c(p,"commit"),{data:R}=await s(E,{query:{f:"json",parts:v.map((s,e)=>e).join(",")},responseType:"json",method:"post"});if(o(i),!R.success)throw new Error("Commit failed");return R.item}catch(e){if(null!=p){const e=c(p,"delete");await s(e,{query:{f:"json"},responseType:"json",method:"post"})}throw e}var l}({data:l,name:u},a.url,i);o(i),f={assetType:m,assetUploadId:t.itemID}}catch(s){n(s),r.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${a.url} does not support the REST Uploads API.`)}if(!f){const s=await p(l);if(o(i),!s.isBase64)throw new S;f={assetType:m,assetData:s.data}}if(!f)throw new U;return{item:f,assetName:u}}(await t,a,{...i,onProgress:l.makeOnProgress(m)});return o(i),u}))}(t,a,{...i,onProgress:l.makeOnProgress("prepareAssetItems")});o(i);const u=m.map(({item:s})=>s),{uploadResults:f}=await async function(e,t,r){const a=E(r?.onProgress);try{const a=await s(c(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(o(r),a.data.uploadResults.length!==e.length)throw new T(e.length,a.data.uploadResults.length);return a.data}finally{a.remove()}}(u,a,{...i,onProgress:l.makeOnProgress("uploadAssetItems")});return o(i),t.map((s,e)=>function(s,e,t){const{success:r}=e;if(!r){const{error:t}=e;throw new v(s.assetName,t)}const{assetHash:o}=e,{assetName:a,item:{assetType:n}}=s,{infoFor3D:{supportedFormats:i}}=t,c=O(n,i);if(!c)throw new P(n);return new g(a,c,[new j(`${t.parsedUrl.path}/assets/${o}`,o)])}(m[e],f[e],a))}function G(e,t){return s(e,t)}async function W(e,t){const r=(await s(e,t)).data.statusUrl;for(;;){const e=(await s(r,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return s(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(e.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await a(K)}}function _({infoFor3D:s}){const e=k(s);if(!e)throw new w;return e}const K=i(1e3);export{L as uploadAssets};
