/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import{c as e}from"./asyncUtils.js";import{EventedAccessor as i}from"../core/Evented.js";import"../core/lang.js";import{throwIfAborted as n,isAborted as s}from"../core/promiseUtils.js";import{watch as r,syncAndInitial as a,sync as o}from"../core/reactiveUtils.js";import{property as h}from"../core/accessorSupport/decorators/property.js";import"./Logger.js";import{subclass as d}from"../core/accessorSupport/decorators/subclass.js";import{project as c,initializeProjection as p}from"./projectionUtils.js";import{h as l,c as u}from"./elevationInfoUtils.js";import{e as f,a as g,h as _,m,j as S}from"./normalizedPoint.js";import{d as v}from"./Settings.js";import w from"../views/interactive/snapping/SnappingOptions.js";import{D as y,L as P,P as T,j as C,c as E,s as j,f as x}from"./constraints.js";import{L as R,I as D,P as b,R as L}from"./RightAngleSnappingHint.js";import{e as M,h as q,j as V,g as I,m as H}from"./vec3.js";import{c as z,b as O}from"./vec3f64.js";import{d as U,e as k,u as Z}from"./vec2.js";import{f as A,b as F,c as G}from"./screenUtils.js";import{m as W}from"./dehydratedPoint.js";import{l as B}from"./geodesicLengthMeasurementUtils.js";function J(t,e,i,n){i.projectToRenderScreen(t,Q),i.projectToRenderScreen(e,X),U(n,X,Q),k(n,n)}function K(t,e,i,n,s=z()){const r=M(N,t);return r[2]=l(n,r,e,i)||0,n.renderCoordsHelper.toRenderCoords(r,e,s),s}const N=z(),Q=A(),X=A();class Y{constructor(t,e,i,n){this.targetPoint=t,this.constraint=e,this.isDraped=i,this.domain=n}}class $ extends Y{constructor({targetPoint:t,objectId:e,constraint:i,isDraped:n}){super(t,i,n,1),this.objectId=e}}class tt extends ${constructor(t){super({...t,isDraped:!0,constraint:new y(t.edgeStart,t.edgeEnd,t.getGroundElevation)})}get hints(){return[new R(1,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}class et extends ${constructor(t){super({...t,constraint:new P(t.edgeStart,t.edgeEnd)})}get hints(){return[new R(1,this.constraint.start,this.constraint.end,this.isDraped,this.domain)]}}class it extends Y{constructor(t,e,i,n){super(t,new T(t),n,3),this.first=e,this.second=i}get hints(){return this.first.targetPoint=this.targetPoint,this.second.targetPoint=this.targetPoint,[...this.first.hints,...this.second.hints,new D(this.targetPoint,this.isDraped,this.domain)]}}class nt extends Y{constructor({lineStart:t,lineEnd:e,targetPoint:i,isDraped:n}){super(i,new C(t,e),n,2),this._referenceLineHint=new R(2,t,e,n,this.domain)}get hints(){return[this._referenceLineHint,new R(0,this._lineEndClosestToTarget(),this.targetPoint,this.isDraped,this.domain)]}_lineEndClosestToTarget(){return this.constraint.closestEndTo(this.targetPoint)}}class st extends Y{constructor({referenceLine:t,lineStart:e,targetPoint:i,isDraped:n}){const s=O(e),{left:r,right:a}=t;q(s,V(s,s,a),r),super(i,new C(e,f(s)),n,2),this._referenceLines=[{edge:t,fadeLeft:!0,fadeRight:!0}]}get hints(){return[new R(0,this.constraint.start,this.targetPoint,this.isDraped,this.domain),new b(this.constraint.start,this.targetPoint,this.isDraped,this.domain),...this._referenceLines.map(t=>new R(1,t.edge.left,t.edge.right,this.isDraped,this.domain,t.fadeLeft,t.fadeRight))]}addReferenceLine(t){const e={edge:t,fadeLeft:!0,fadeRight:!0};this._referenceLines.forEach(i=>{I(t.right,i.edge.left)&&(i.fadeLeft=!1,e.fadeRight=!1),I(t.right,i.edge.right)&&(i.fadeRight=!1,e.fadeRight=!1),I(t.left,i.edge.right)&&(i.fadeRight=!1,e.fadeLeft=!1),I(t.left,i.edge.left)&&(i.fadeLeft=!1,e.fadeLeft=!1)}),this._referenceLines.push(e)}}class rt extends Y{constructor({targetPoint:t,constraint:e,previousVertex:i,otherVertex:n,otherVertexType:s,isDraped:r,selfSnappingType:a,objectId:o,domain:h}){super(t,e,r,h??2),this.previousVertex=i,this.otherVertex=n,this.otherVertexType=s,this.selfSnappingType=a??0,this.objectId=o??null}get hints(){const t=this.previousVertex,e=1===this.otherVertexType?this.otherVertex:this.targetPoint,i=1===this.otherVertexType?this.targetPoint:this.otherVertex;return[new R(0,e,i,this.isDraped,this.domain),new R(1,t,e,this.isDraped,this.domain),new L(this.previousVertex,e,i,this.isDraped,this.domain)]}}class at extends Y{constructor({targetPoint:t,point1:e,point2:i,isDraped:n}){super(t,new E(f(H(z(),e,i,.5)),.5*Z(g(e),g(i))),n,2),this._p1=e,this._p2=i}get hints(){return[new R(1,this.targetPoint,this._p1,this.isDraped,this.domain),new R(1,this.targetPoint,this._p2,this.isDraped,this.domain),new L(this._p1,this.targetPoint,this._p2,this.isDraped,this.domain)]}}function ot(t,e,i,n){return"2d"===n.type?(ht.x=t[0],ht.y=t[1],ht.spatialReference=e,n.toScreen(ht)):(K(t,e,i,n,dt),n.state.camera.projectToScreen(dt,ct),G(ct[0],ct[1]))}const ht=W(0,0,0,null),dt=z(),ct=F();let pt=class extends i{constructor(t){super(t),this.options=new w,this._engineCache=new Map,this._loadTask=null,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=0}initialize(){this.addHandles([r(()=>{const{distance:t,touchSensitivityMultiplier:e,effectiveSelfEnabled:i,effectiveFeatureEnabled:n,effectiveGridEnabled:s}=this.options;return{selfEnabled:i,featureEnabled:n,gridEnabled:"2d"===this.view.type&&s,viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,distance:t,touchSensitivityMultiplier:e}},(t,i)=>{i&&(this.doneSnapping(),this.emit("changed")),this._loadTask?.abort(),this._loadTask=e(e=>this._updateEngines(t,i,e))},a),r(()=>this.options,t=>{for(const e of this._engines)e.options=t},o)])}destroy(){this._loadTask?.abort(),this._destroyEngines()}get updating(){return this._engines.some(t=>t.updating)||!this._loadTask?.finished}_destroyEngines(){this._engineCache.forEach(t=>t.destroy()),this._engineCache.clear(),this._engines=[]}async _updateEngines(t,e,i){if(!t.viewReady)return void this._destroyEngines();e?.viewSpatialReference!==t.viewSpatialReference&&this._destroyEngines();const n=this._engineCache,s=await Promise.allSettled([t.featureEnabled&&!n.has("feature")?this._createFeatureSnappingEngine(i):void 0,t.selfEnabled&&!n.has("self")?this._createSelfSnappingEngine(i):void 0,t.gridEnabled&&!n.has("grid")?this._createGridSnappingEngine(i):void 0]);if(i.aborted)for(const t of s)"fulfilled"===t.status&&t.value?.engine.destroy();else{for(const t of s)"fulfilled"===t.status&&t.value&&n.set(t.value.type,t.value.engine);this._engines=Array.from(n.values())}}async _createSelfSnappingEngine(t){const[{SelfSnappingEngine:e},i]=await Promise.all([import("./SelfSnappingEngine.js"),B()]);return n(t),{type:"self",engine:new e({view:this.view,options:this.options,geodesicLengthMeasurementUtils:i})}}async _createGridSnappingEngine(t){const{view:e}=this;if("2d"!==e.type)return;const{GridSnappingEngine:i}=await import("./GridSnappingEngine.js");return n(t),{type:"grid",engine:new i({view:e,options:this.options})}}async _createFeatureSnappingEngine(t){const{FeatureSnappingEngine:e}=await import("./FeatureSnappingEngine.js");n(t);const{view:i,options:s}=this,{spatialReference:r}=i;return{type:"feature",engine:new e({view:i,options:s,spatialReference:r})}}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,i=t*e;return i*i}snap(t){return function(t){return null!=t.scenePoint}(t)?this._snapMultiPoint(t):this._snapSinglePoint(t)}update(t){const{point:e,context:i}=t;this._removeVisualization();const n=this._currentMainCandidate;if(null==n)return e;const s=this._selectUpdateInput(t);if(null==s)return e;const{spatialReference:r}=i,a=c(s,r);if(null==a)return e;const{view:o}=this,{elevationInfo:h,visualizer:d}=i,p=[],l=_(a,o,h),u=n.constraint.closestTo(l);if(!this._arePointsWithinScreenThreshold(l,u,i)||!ft(n,i.drawConstraints))return this._resetSnappingState(),e;n.targetPoint=m(u),p.push(...n.hints);for(const t of this._currentOtherActiveCandidates)ft(t,i.drawConstraints)&&(t.targetPoint=m(u),p.push(...t.hints));return null!=d&&this.addHandles(d.draw(p,{spatialReference:r,elevationInfo:_t(i),view:o,selfSnappingZ:i.selfSnappingZ}),lt),S(u,o,e,i)}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:t,scenePoint:e}){switch(this._currentSnappedType){case 0:return t;case 1:return e}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=0}_removeVisualization(){this.removeHandles(lt)}async _snapSinglePoint({point:t,context:e,signal:i}){const{view:n}=this,{elevationInfo:s}=e,r=_(t,n,s),a=await this._fetchCandidates(r,3,e,i);return this._createSnapResult(r,0,a,n,t,e,i)}async _snapMultiPoint({point:t,scenePoint:e,context:i,signal:n}){const{view:s}=this,{coordinateHelper:r,elevationInfo:a,spatialReference:o}=i;await p(e.spatialReference,o);const h=c(e,o),d=_(h,s,a),l=await this._fetchCandidates(d,1,i,n);if(l.length>0){const t=await this._fetchCandidates(d,2,i,n);return this._createSnapResult(d,1,[...l,...t],s,h,i,n)}const u=_(t,s,a),f=await this._fetchCandidates(u,2,i,n);return this._createSnapResult(u,0,f,s,{z:r.hasZ()&&t.hasZ?t.z??0:void 0,m:r.hasM()&&t.hasM?t.m??0:void 0},i,n)}async _fetchCandidates(t,e,i,n){return(await Promise.all(this._engines.map(s=>s.fetchCandidates(t,e,i,n)))).flat()}_createSnapResult(t,e,i,n,r,a,o){return{get valid(){return!s(o)},apply:()=>{const{spatialReference:s}=a,{snappedPoint:o,hints:h}=this._processCandidates(t,e,i,a);return this._removeVisualization(),null!=a.visualizer&&this.addHandles(a.visualizer.draw(h,{spatialReference:s,elevationInfo:u,view:n,selfSnappingZ:a.selfSnappingZ}),lt),S(o,n,r,a)}}}_processCandidates(t,e,i,n){if(i.length<1)return this.doneSnapping(),{snappedPoint:t,hints:[]};this._currentSnappedType!==e&&this._resetSnappingState(),j(t,i);const s=this._currentMainCandidate;if(null!=s){const o=(a=i,(r=s)instanceof it?gt(a,r.first)>=0&&gt(a,r.second)>=0?0:-1:gt(a,r));if(o>=0){if(!(i[o]instanceof it))return this._intersectWithOtherCandidates(o,i,t,e,n);if(this._arePointsWithinScreenThreshold(t,s.targetPoint,n))return this._updateSnappingCandidate(s,e,i,n)}}var r,a;return this._intersectWithOtherCandidates(0,i,t,e,n)}_intersectWithOtherCandidates(t,e,i,n,s){const{coordinateHelper:r}=s,a=e[t],o=[];for(let n=0;n<e.length;++n){if(n===t)continue;const s=e[n],h=a.constraint.intersect(s.constraint);if(h)for(const t of h.closestPoints(a.targetPoint))o.push([new it(m(t),a,s,s.isDraped),this._squaredScreenDistance(i,t,r)])}return o.length>0&&(o.sort((t,e)=>t[1]-e[1]),o[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(o[0][0],n,e,s):ft(a,s.drawConstraints)?this._updateSnappingCandidate(a,n,e,s):{snappedPoint:i,hints:[]}}_updateSnappingCandidate(t,e,i,n){this.doneSnapping(),this._currentMainCandidate=t,this._currentSnappedType=e;const s=this._currentMainCandidate.targetPoint,r=[];r.push(...t.hints);for(const e of i){if(t instanceof it){if(e.constraint.equals(t.first.constraint)||e.constraint.equals(t.second.constraint))continue}else if(e.constraint.equals(t.constraint))continue;const i=e.constraint.closestTo(s);this._squaredScreenDistance(i,s,n.coordinateHelper)<ut()&&(e.targetPoint=s,this._currentOtherActiveCandidates.push(e),r.push(...e.hints))}return{snappedPoint:s,hints:r}}_squaredPointProximityThreshold(t){return"touch"===t?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}_arePointsWithinScreenThreshold(t,e,i){return this._squaredScreenDistance(t,e,i.coordinateHelper)<this._squaredPointProximityThreshold(i.pointer)}_squaredScreenDistance(t,e,i){return x(this._toScreen(t,i),this._toScreen(e,i))}_toScreen(t,e){return ot(t,e.spatialReference,u,this.view)}get test(){}};t([h({constructOnly:!0})],pt.prototype,"view",void 0),t([h()],pt.prototype,"options",void 0),t([h({readOnly:!0})],pt.prototype,"updating",null),t([h()],pt.prototype,"_loadTask",void 0),t([h()],pt.prototype,"_engines",void 0),t([h()],pt.prototype,"_squaredMouseProximityThreshold",null),t([h()],pt.prototype,"_squaredTouchProximityThreshold",null),pt=t([d("esri.views.interactive.snapping.SnappingManager")],pt);const lt="visualization-handle";function ut(){return v.satisfiesConstraintScreenThreshold*v.satisfiesConstraintScreenThreshold}function ft(t,e){return!e||null==e.direction&&null==e.distance||!(t instanceof tt||t instanceof et||t instanceof nt||t instanceof st||t instanceof at)&&(!(t instanceof rt)||null==e.direction&&1===t.selfSnappingType)}function gt(t,e){let i=-1;for(let n=0;n<t.length;++n)if(e.constraint.equals(t[n].constraint)){i=n;break}return i}function _t({coordinateHelper:t,elevationInfo:e}){return t.hasZ()?u:e}export{tt as D,et as E,$ as F,it as I,nt as L,st as P,rt as R,pt as S,K as a,at as b,J as r,ot as v};
