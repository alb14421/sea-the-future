/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{throwIfAborted as n,waitTick as r}from"../core/promiseUtils.js";import{t}from"./tracking.js";import{S as o}from"./SimpleObservable.js";import{c as s}from"./vec3f64.js";import{a as i,b as l}from"../geometry/support/webMercatorUtils.js";import{p as a,A as u,B as p,C as c,i as m,j as f,D as j}from"./unitUtils.js";import g from"../geometry/Extent.js";import h from"../geometry/Multipoint.js";import{l as y,p as d,i as R}from"./pe.js";import x from"../geometry/Point.js";import w from"../geometry/Polygon.js";import b from"../geometry/Polyline.js";import S from"../geometry/SpatialReference.js";import{g as U,p as z}from"./projectBuffer.js";import{p as M}from"./projectXYZToVector.js";import v from"../geometry/support/GeographicTransformation.js";import{g as A}from"./zscale.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"./handleUtils.js";import"./events.js";import"./maybe.js";import"./utils.js";import"./ObservableBase.js";import"./jsonMap.js";import"./tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import"./MapUtils.js";import"./get.js";import"./metadata.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./Warning.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./ObjectPool.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"./reader.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"./persistableUrlUtils.js";import"./writer.js";import"./zmUtils.js";import"../core/accessorSupport/decorators/cast.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformationStep.js";let T=null,Z=null,G=null,P={};const B=new o;function E(){return!!T&&R()}function _(){return!!E()||(t(B),W(),!1)}function k(e,n){return!e||!n||F(e,n)||_()}function O(e,n){return!F(e,n)&&!E()}function W(e){return null==G&&(G=Promise.all([y(),import("./geometryEngineBase.js").then(e=>e.g),import("./hydrated.js")])),G.then(([,r,{hydratedAdapter:t}])=>{n(e),Z=t,T=r.default,T._enableProjection(d),B.notify()})}function C(e,n,r=null,t=null){return Array.isArray(e)?0===e.length?[]:(i(e),L(Z,e,e[0].spatialReference,n,r,t)):(l(e),L(Z,[e],e.spatialReference,n,r,t)[0])}function L(e,n,r,t,o=null,s=null){if(null==r||null==t)return n;if(F(r,t,o))return n.map(e=>$(e,r,t));if(null==o&&p(r))return n.map(e=>$(e,r,S.WGS84)).map(e=>X(e,t));if(null==o&&p(t))return n.map(e=>X(e,S.WGS84)).map(e=>$(e,S.WGS84,t));if(null==o){const e=v.cacheKey(r,t);void 0!==P[e]?o=P[e]:(null==(o=H(r,t,void 0))&&(o=new v),P[e]=o)}if(null==T||null==e)throw new K;return null!=s?T._project(e,n,r,t,o,s):T._project(e,n,r,t,o)}function q(e,n){const r=D([e],n);return null!=r.pending?{pending:r.pending,geometry:null}:null!=r.geometries?{pending:null,geometry:r.geometries[0]}:{pending:null,geometry:null}}function D(e,n){if(!E())for(const r of e)if(null!=r&&!a(r.spatialReference,n)&&u(r.spatialReference)&&u(n)&&!F(r.spatialReference,n))return t(B),{pending:W(),geometries:null};return{pending:null,geometries:e.map(e=>null==e?null:a(e.spatialReference,n)?e:u(e.spatialReference)&&u(n)?X(e,n):null)}}function H(e,n,r=null){if(null==e||null==n)return null;if(null==T||null==Z)throw new K;const t=T._getTransformation(Z,e,n,r,r?.spatialReference);return null!==t?v.fromGE(t):null}function J(e,n,r=null){if(null==T||null==Z)throw new K;const t=T._getTransformationBySuitability(Z,e,n,r,r?.spatialReference);if(null!==t){const e=[];for(const n of t)e.push(v.fromGE(n));return e}return[]}class K extends e{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}function N(){T=null,Z=null,G=null,P={}}const V={get loadPromise(){return G}};function X(e,n){try{const r=C(e,n);if(null==r)return null;"xmin"in e&&"xmin"in r&&(r.zmin=e.zmin,r.zmax=e.zmax);const t=A(r.type,e.spatialReference,n);return null!=t&&t(r),r}catch(e){if(!(e instanceof K))throw e;return null}}async function Y(e,n,r){const t=e.spatialReference;return null!=t&&null!=n&&await Q(t,n,null,r),X(e,n)}function F(e,n,r){return!r&&(!!a(e,n)||u(e)&&u(n)&&!!U(e,n))}function I(e,n){if(a(e,n))return!0;if(!u(e)||!u(n))return!1;const r=m(e)||f(e)||j(e),t=m(n)||f(n)||j(n);return r&&t}async function Q(e,n,t,o){if(E())return r(o);if(Array.isArray(e)){for(const{source:n,dest:r,geographicTransformation:t}of e)if(n&&r&&!F(n,r,t))return W(o)}else if(e&&n&&!F(e,n,t))return W(o);return r(o)}function $(e,n,r){return e?"x"in e?ne(e,n,new x,r,0):"xmin"in e?ue(e,n,new g,r,0):"rings"in e?le(e,n,new w,r,0):"paths"in e?se(e,n,new b,r,0):"points"in e?te(e,n,new h,r,0):null:null}function ee(e,n,r=n.spatialReference,t=0){return null!=r&&null!=e.spatialReference&&null!=ne(e,e.spatialReference,n,r,t)}function ne(e,n,r,t,o){ce[0]=e.x,ce[1]=e.y;const s=e.z;return ce[2]=void 0!==s?s:o,z(ce,n,0,ce,t,0)?(r.x=ce[0],r.y=ce[1],r.spatialReference=t,void 0!==s||c(t)?(r.z=ce[2],r.hasZ=!0):(r.z=void 0,r.hasZ=!1),void 0===e.m?(r.m=void 0,r.hasM=!1):(r.m=e.m,r.hasM=!0),r):null}function re(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=te(e,e.spatialReference,n,r,t)}function te(e,n,r,t,o){const{points:s,hasZ:i,hasM:l}=e,a=[],u=s.length,p=[];for(const e of s)p.push(e[0],e[1],i?e[2]:o);if(!z(p,n,0,p,t,0,u))return null;const m=i||c(t);for(let e=0;e<u;++e){const n=3*e,r=p[n],t=p[n+1];m&&l?a.push([r,t,p[n+2],s[e][3]]):m?a.push([r,t,p[n+2]]):l?a.push([r,t,s[e][2]]):a.push([r,t])}return r.points=a,r.spatialReference=t,r.hasZ=i,r.hasM=l,r}function oe(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=se(e,e.spatialReference,n,r,t)}function se(e,n,r,t,o){const{paths:s,hasZ:i,hasM:l}=e,a=[];if(!pe(s,i??!1,l??!1,n,a,t,o))return null;const u=i||c(t);return r.paths=a,r.spatialReference=t,r.hasZ=u,r.hasM=l,r}function ie(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=le(e,e.spatialReference,n,r,t)}function le(e,n,r,t,o){const{rings:s,hasZ:i,hasM:l}=e,a=[];if(!pe(s,i??!1,l??!1,n,a,t,o))return null;const u=i||c(t);return r.rings=a,r.spatialReference=t,r.hasZ=u,r.hasM=l,r}function ae(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=ue(e,e.spatialReference,n,r,t)}function ue(e,n,r,t,o){const{xmin:s,ymin:i,xmax:l,ymax:a,hasZ:u,hasM:p}=e,m=u?e.zmin:o;if(!M(s,i,m,n,ce,t))return null;const f=u||c(t);r.xmin=ce[0],r.ymin=ce[1],f&&(r.zmin=ce[2]);const j=u?e.zmax:o;return M(l,a,j,n,ce,t)?(r.xmax=ce[0],r.ymax=ce[1],f&&(r.zmax=ce[2]),p&&(r.mmin=e.mmin,r.mmax=e.mmax),r.spatialReference=t,r):null}function pe(e,n,r,t,o,s,i=0){const l=new Array;for(const r of e)for(const e of r)l.push(e[0],e[1],n?e[2]:i);if(!z(l,t,0,l,s,0))return!1;let a=0;o.length=0;const u=n||c(s);for(const n of e){const e=new Array;for(const t of n)u&&r?e.push([l[a++],l[a++],l[a++],t[3]]):u?e.push([l[a++],l[a++],l[a++]]):r?(e.push([l[a++],l[a++],t[2]]),a++):(e.push([l[a++],l[a++]]),a++);o.push(e)}return!0}const ce=s();export{F as canProjectWithoutEngine,H as getTransformation,J as getTransformations,Q as initializeProjection,I as isEqualBaseGCS,E as isLoaded,_ as isLoadedOrLoad,k as isLoadedOrLoadFor,W as load,C as project,ae as projectExtent,L as projectMany,re as projectMultipoint,q as projectOrLoad,D as projectOrLoadMany,ee as projectPoint,ie as projectPolygon,oe as projectPolyline,Y as projectWithZConversion,$ as projectWithoutEngine,O as requiresLoad,V as test,X as tryProjectWithZConversion,N as unload};
