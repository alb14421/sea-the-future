/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../request.js";import{p as e,e as o,a as r}from"./utils9.js";import s from"../rest/support/AddressCandidate.js";import{_ as i}from"./tslib.es6.js";import{JSONSupport as n}from"../core/JSONSupport.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import{e as p,b as l}from"./ensureType.js";import"../core/lang.js";import{subclass as u}from"../core/accessorSupport/decorators/subclass.js";import c from"../geometry/Extent.js";import y from"../geometry/Point.js";import d from"../geometry/SpatialReference.js";import{a as m}from"./commonProperties3.js";import f from"../core/Error.js";import{e as g}from"./enumeration.js";import{w as j}from"./writer.js";import{s as S}from"./jsonMap.js";import"./Logger.js";let h=class extends n{constructor(t){super(t),this.address=null,this.apiKey=null,this.categories=null,this.countryCode=null,this.forStorage=null,this.location=null,this.locationType=null,this.magicKey=null,this.maxLocations=null,this.outFields=null,this.outSpatialReference=null,this.searchExtent=null}};i([a({type:Object,json:{write:!0}})],h.prototype,"address",void 0),i([a(m)],h.prototype,"apiKey",void 0),i([a({type:[String],json:{read:{source:"category",reader:t=>t?t.split(","):null},write:{target:"category",writer:(t,e)=>{e.category=t?t.join(","):null}}}})],h.prototype,"categories",void 0),i([a({type:String,json:{write:!0}})],h.prototype,"countryCode",void 0),i([a({type:Boolean,json:{write:!0}})],h.prototype,"forStorage",void 0),i([a({type:y,json:{write:{writer:(t,e)=>{e.location=t?t.clone().normalize():null}}}})],h.prototype,"location",void 0),i([a({type:["rooftop","street"],json:{write:!0}})],h.prototype,"locationType",void 0),i([a({type:String,json:{write:!0}})],h.prototype,"magicKey",void 0),i([a({type:Number,json:{write:!0}})],h.prototype,"maxLocations",void 0),i([a({type:[String],json:{write:{writer:(t,e)=>{e.outFields=t?t.join(","):null}}}})],h.prototype,"outFields",void 0),i([a({type:d,json:{read:{source:"outSR"},write:{target:"outSR"}}})],h.prototype,"outSpatialReference",void 0),i([a({type:c,json:{write:{writer:(t,e)=>{const o=t?t.shiftCentralMeridian():null;e.searchExtent=o}}}})],h.prototype,"searchExtent",void 0),h=i([u("esri.rest.support.AddressToLocationsParameters")],h),h.from=p(h);const w=h;async function v(s,i,n){i=w.from(i);const a=e(s),{address:p,...l}=i.toJSON(),u={...p,...l,f:"json"},c=o({...a.query,...u}),y=r(c,n),d=`${a.path}/findAddressCandidates`;return t(d,y).then(x)}function x({data:t}){if(!t)return[];const{candidates:e,spatialReference:o}=t;return e?e.map(t=>{if(!t)return;const{extent:e,location:r}=t,i=!e||function(t){return t&&"number"==typeof t.xmin&&"number"==typeof t.ymin&&"number"==typeof t.xmax&&"number"==typeof t.ymax}(e),n=function(t){return!!t&&"number"==typeof t.x&&"number"==typeof t.y}(r);return n&&i?(e&&(e.spatialReference=o),r&&(r.spatialReference=o),s.fromJSON(t)):void 0}):[]}const b=S()({DistanceMarker:"distance-marker",Locality:"locality",POI:"poi",PointAddress:"point-address",Postal:"postal",StreetAddress:"street-address",StreetInt:"street-intersection",StreetName:"street-name",Subaddress:"sub-address"}),L=S()({localCity:"local-city",postalCity:"postal-city"});var T;let R=T=class extends n{constructor(t){super(t),this.apiKey=null,this.featureTypes=null,this.forStorage=null,this.language=null,this.location=null,this.locationType=null,this.outFields=null,this.outSpatialReference=null,this.preferredLabelValues=null,this.returnInputLocation=null}writeFeatureTypes(t,e){t?.length&&(e.featureTypes=t.map(t=>b.toJSON(t)))}writeLocation(t,e){e.location=t?.clone().normalize().toJSON()}static from(t){return l(T,t)}};i([a(m)],R.prototype,"apiKey",void 0),i([a({type:[["distance-marker","locality","poi","point-address","postal","street-address","street-intersection","street-name","sub-address"]],json:{write:!0}})],R.prototype,"featureTypes",void 0),i([j("featureTypes")],R.prototype,"writeFeatureTypes",null),i([a({type:Boolean,json:{write:!0}})],R.prototype,"forStorage",void 0),i([a({type:String,json:{name:"langCode",write:!0}})],R.prototype,"language",void 0),i([a({type:y,json:{write:!0}})],R.prototype,"location",void 0),i([j("location")],R.prototype,"writeLocation",null),i([a({type:["street","rooftop"],json:{write:!0}})],R.prototype,"locationType",void 0),i([a({type:[String],json:{write:!0}})],R.prototype,"outFields",void 0),i([a({type:d,json:{name:"outSR",write:!0}})],R.prototype,"outSpatialReference",void 0),i([g(L)],R.prototype,"preferredLabelValues",void 0),i([a({type:Boolean,json:{write:!0}})],R.prototype,"returnInputLocation",void 0),R=T=i([u("esri.rest.support.LocationToAddressParameters")],R);const C=R;async function N(o,r,i){const n=e(o),{path:a,query:p}=n,l=C.from(r);if(!l.location)throw new f("location-to-address:location-required","The location parameter is required");const u=function(t){const e=t.toJSON(),{featureTypes:o,forStorage:r,langCode:s,location:i,locationType:n,outFields:a,outSR:p,preferredLabelValues:l,returnInputLocation:u,token:c}=e;return{featureTypes:o?.join(","),forStorage:r,langCode:s,location:JSON.stringify(i),locationType:n,outFields:a?.join(","),outSR:p?.wkid??void 0,preferredLabelValues:l,returnInputLocation:u,token:c}}(l),c={...i,query:{...p,...u,f:"json"}},y=`${a}/reverseGeocode`,{data:d}=await t(y,c),{address:m,location:g}=d;return s.fromJSON({address:m?.Match_addr??"",attributes:m,location:g,score:100})}let O=class extends n{constructor(t){super(t),this.isCollection=null,this.magicKey=null,this.text=null}};i([a({type:Boolean,json:{write:!0}})],O.prototype,"isCollection",void 0),i([a({type:String,json:{write:!0}})],O.prototype,"magicKey",void 0),i([a({type:String,json:{write:!0}})],O.prototype,"text",void 0),O=i([u("esri.rest.support.SuggestionCandidate")],O);const J=O;let K=class extends n{constructor(t){super(t),this.apiKey=null,this.categories=null,this.countryCode=null,this.location=null,this.maxSuggestions=null,this.outSpatialReference=null,this.searchExtent=null,this.text=null}};i([a(m)],K.prototype,"apiKey",void 0),i([a({type:[String],json:{read:{source:"category",reader:t=>t?t.split(","):null},write:{target:"category",writer:(t,e)=>{e.category=t?t.join(","):null}}}})],K.prototype,"categories",void 0),i([a({type:String,json:{write:!0}})],K.prototype,"countryCode",void 0),i([a({type:y,json:{write:{writer:(t,e)=>{e.location=t?t.clone().normalize():null}}}})],K.prototype,"location",void 0),i([a({type:Number,json:{write:!0}})],K.prototype,"maxSuggestions",void 0),i([a({type:d,json:{read:{source:"outSR"},write:{target:"outSR"}}})],K.prototype,"outSpatialReference",void 0),i([a({type:c,json:{write:{writer:(t,e)=>{const o=t?t.shiftCentralMeridian():null;e.searchExtent=JSON.stringify(o)}}}})],K.prototype,"searchExtent",void 0),i([a({type:String,json:{write:!0}})],K.prototype,"text",void 0),K=i([u("esri.rest.support.SuggestLocationsParameters")],K),K.from=p(K);const F=K;async function E(s,i,n){const a=e(s),p={...(i=F.from(i)).toJSON(),f:"json"},l=o({...a.query,...p}),u=r(l,n),c=`${a.path}/suggest`;return t(c,u).then(P)}function P(t){const{data:e}=t;if(!e)return[];const{suggestions:o}=e;return o?o.map(t=>new J(t)):[]}export{w as A,C as L,F as S,v as a,N as l,E as s};
