/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../geometry/Point.js";import{c as t,d as n,s as o}from"./rasterProjectionHelper.js";const l=new Map,r=new class{constructor(e=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const n=e+"/"+t,o=this._cachedBlocks;if(o.has(n)){const e=o.get(n);return e.refCount--,e.refCount<=0&&(o.delete(n),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const n=e+"/"+t,o=this._cachedBlocks;if(o.has(n)){const e=o.get(n);return e.ts=Date.now(),e.refCount++,o.delete(n),o.set(n,e),e.block}return null}putBlock(e,t,n,o){const l=this._cachedBlocks,r=e+"/"+t;if(l.has(r)){const e=l.get(r);e.ts=Date.now(),e.refCount++}else l.set(r,{block:n,ts:Date.now(),refCount:1,controller:o});this._trim(),this._updateTimer()}deleteBlock(e,t){const n=this._cachedBlocks,o=e+"/"+t;n.has(o)&&n.delete(o)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval(()=>{const t=Array.from(e),n=Date.now();for(let o=0;o<t.length&&t[o][1].ts<=n-this._duration;o++)e.delete(t[o][0]);0===e.size&&this._clearTimer()},this._interval)}_trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let n=0;n<t.length-this._size;n++)e.delete(t[n][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function i(e,t,n){const o=[];return null!=t&&o.push(`sliceId=${t}`),null!=n&&o.push(`bandIds=${n.join(",")}`),o.length?`${e}?${o.join("&")}`:e}function c(e,t){const n={extent:null,rasterInfo:t,cache:new Map},o=l.get(e);return o?(o.push(n),o.length-1):(l.set(e,[n]),0)}function s(e,t){const n=l.get(e);n&&(n[t]=null,n.some(e=>null!=e)||l.delete(e))}function a(e,t,n){const o=l.get(e);if(!o)return null==t?r.decreaseRefCount(e,n):0;if(null==t||null==o[t])return r.decreaseRefCount(e,n);const i=o[t]?.cache,c=i?.get(n);if(i&&c){if(c.refCount--,0===c.refCount){i.delete(n);for(let e=0;e<o.length;e++)o[e]?.cache.delete(n);c.controller&&c.controller.abort()}return c.refCount}return 0}function u(e,t,n){const o=l.get(e);if(!o)return null==t?r.getBlock(e,n):null;if(null==t||null==o[t]){for(let e=0;e<o.length;e++){const t=o[e]?.cache.get(n);if(t)return t.refCount++,t.block}return r.getBlock(e,n)}const i=o[t]?.cache.get(n);if(i)return i.refCount++,i.block;for(let e=0;e<o.length;e++){if(e===t||!o[e])continue;const l=o[e]?.cache,r=l?.get(n);if(l&&r)return r.refCount++,l.set(n,r),r.block}return null}function h(e,t,n,o,i=null){const c=l.get(e);if(!c)return void(null==t&&r.putBlock(e,n,o,i));if(null==t||null==c[t])return void r.putBlock(e,n,o,i);const s={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:i};o.then(()=>s.isResolved=!0).catch(()=>s.isRejected=!0),c[t]?.cache.set(n,s)}function f(e,t,n){const o=l.get(e);o?null!=t&&null!=o[t]?o[t]?.cache.delete(n):r.deleteBlock(e,n):null==t&&r.deleteBlock(e,n)}function m(r,i,c,s,a,u,h=null){const f=function(e,t){const n=l.get(e);return n?n[t]??null:null}(r,i);if(!f)return;const m=f.extent,{cache:d,rasterInfo:x}=f;if(m&&m.xmin===c.xmin&&m.xmax===c.xmax&&m.ymin===c.ymin&&m.ymax===c.ymax)return;s=s??0;const g=c.clone().normalize(),{spatialReference:_,transform:k}=x,p=new Set;for(let l=0;l<g.length;l++){const r=g[l];if(r.xmax-r.xmin<=s||r.ymax-r.ymin<=s)continue;let i=t(r,_,h);if(null==i)continue;if(null!=k&&(i=k.inverseTransform(i),null==i))continue;const c=new e({x:s,y:s,spatialReference:r.spatialReference});if(null==a&&!(a=n(c,_,r,h)))return;const{pyramidLevel:f,pyramidResolution:m,excessiveReading:d}=o(a,x,u||"closest");if(d)return;const{storageInfo:y}=x,{origin:B}=y,{x:C,y:M}=m,R=Math.max(0,Math.floor((i.xmin-B.x)/C)),b=Math.max(0,Math.floor((B.y-i.ymax)/M)),w=Math.ceil(i.width/C-.1),v=Math.ceil(i.height/M-.1),z=f>0?y.pyramidBlockWidth:y.blockWidth,j=f>0?y.pyramidBlockHeight:y.blockHeight,I=y.blockBoundary[f];if(!I)continue;const $=1,T=Math.max(I.minCol,Math.floor(R/z)-$),D=Math.max(I.minRow,Math.floor(b/j)-$),H=Math.min(I.maxCol,Math.floor((R+w-1)/z)+$),S=Math.min(I.maxRow,Math.floor((b+v-1)/j)+$);for(let e=D;e<=S;e++)for(let t=T;t<=H;t++)p.add(`${f}/${e}/${t}`)}d.forEach((e,t)=>{if(!p.has(t)){const e=d.get(t);(null==e||e.isResolved||e.isRejected)&&d.delete(t)}}),f.extent={xmin:c.xmin,ymin:c.ymin,xmax:c.xmax,ymax:c.ymax}}export{u as a,a as b,s as c,f as d,i as g,h as p,c as r,m as u};
