/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{S as e,G as t}from"./SimpleGeometryCursor.js";import{p as s,t as n,a as i,v as r,z as o,G as m,l as a,o as h,j as c,u,A as l,r as _,m as f,P as d,S as g,B as p,C as P}from"./Point2D.js";import{Envelope2D as x}from"./Envelope2D.js";import{O as b,P as y,f as w,N as C,y as v,R as S,b as D,U as I,G,A as M,V as T,p as N,W as k,X as A,Y as E,Z as q,d as R,_ as z,$ as X,E as B,a0 as Y,a1 as O,H as j,I as F,a2 as W,a3 as J,a4 as U,a5 as H,a6 as V,a7 as L}from"./ProjectionTransformation.js";import{a as Z,b as $}from"./tslib.es6.js";import{e as K,c as Q,P as ee,b as te,f as se,h as ne,s as ie}from"./Envelope.js";import{T as re}from"./Transformation2D.js";import{c as oe}from"./GeometryCleaner-BEJM7I4l.js";import"./OperatorDefinitions.js";class me{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){const t=new y,s=new xe(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferPolyline(e){const t=new xe(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){const t=new be(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){const t=e.getXY();t.scale(this.m_rpu);let s=new y;if(this.bufferPoint2D(t,!1,s)){const e=te(null,s,!0);s=N(s,e,!0,!0,-1,this.m_progressTracker,0,!1)}return s=(new G).foldInto360RangeGeodetic(s,this.m_gcs,2),s}processGnomonicBufferPiecesCursor(e,t){const s=t;let n=s.getGnomonic();const i=k(A());let r=new E,o=(new b).executeMany(r,i,this.m_progressTracker,2);const m=_(6,!1),a=f(x,6);this.initializeGrid(m,a);const h=[null,null,null,null,null,null],c=[null,null,null,null,null,null],u=[null,null,null,null,null,null];let l,d,g;for(;null!==(l=s.next());){if(d=s.getGnomonic(),d!==n){if(null!==n){let t=o.next();if(r=null,o=null,null!=t){const s=te(i,t,!0),r=K(s);t=n.unproject(t,r,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,m,a,h,c,u)}}null!==d&&(r=new E,o=(new b).executeMany(r,i,this.m_progressTracker,2)),n=d}if(s.isRunningInGnomonic()){if(d.project(l),s.needsSimplify()){const e=te(null,l,!0);l=N(l,e,!0,!0,-1,this.m_progressTracker,0,!1)}r.tick(pe(l)),o.tock()}else this.putInGridCursors(e,l,i,!0,m,a,h,c,u)}let p=!1;for(let e=0;e<6;e++)if(null!=u[e]){p=!0;break}if(p){let t=!1;const l=[null,null,null,null,null,null];if(e){const n=s.m_densified;if(s.m_densified=null,null!==n){const s=new re;s.scale(1/this.m_rpu,1/this.m_rpu),n.applyTransformation(s),this.m_distance>0?this.putInGridCursors(e,n,i,!1,m,a,h,c,u):(this.processInGrid(e,n,!1,m,a,h,l),t=!0)}}const _=new E,f=(new b).executeMany(_,this.m_gcs,this.m_progressTracker,2);if(null!==o){let t=o.next();r=null,o=null;const s=te(i,t,!0),l=K(s);t=n.unproject(t,l,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,m,a,h,c,u)}for(let e=0;e<6;e++)if(null!=u[e]){let s=u[e].next();u[e]=null,c[e]=null,t&&null!==l[e]&&(s=(new q).execute(l[e],s,i,this.m_progressTracker));const n=te(i,s,!0),r=K(n);s=h[e].unproject(s,r,this.m_progressTracker),s=(new R).execute(s,this.m_gcs,!0,this.m_progressTracker),_.tick(pe(s)),f.tock()}g=f.next()}else{let t,m=!1;if(e){let e=s.m_densified;if(s.m_densified=null,null!==e){const s=new re;s.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(s),d.project(e);const n=te(null,e,!0);e=N(e,n,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(r.tick(pe(e)),o.tock()):(t=e,m=!0)}}let a=o.next();r=null,o=null,m&&(a=(new q).execute(t,a,i,this.m_progressTracker));const h=te(i,a,!0),c=K(h);g=n.unproject(a,c,this.m_progressTracker),g=(new R).execute(g,this.m_gcs,!0,this.m_progressTracker)}return g=(new G).foldInto360RangeGeodetic(g,this.m_gcs,2),g}putInGridCursors(e,t,s,n,i,r,o,m,a){const h=[null,null,null,null,null,null];this.processInGrid(e,t,n,i,r,o,h);for(let e=0;e<6;e++)null!==h[e]&&(null===m[e]&&(m[e]=new E,a[e]=(new b).executeMany(m[e],s,this.m_progressTracker,2)),m[e].tick(pe(h[e])),a[e].tock())}processInGrid(e,t,s,n,i,r,o){const m=.01,a=this.insertGeodeticPointsAlongGrid(t,i,m);for(let e=0;e<6;e++){if(n[e])continue;const h=i[e].clone();h.inflateCoords(m,m);const c=se(t,h),u=Q(null,c,!1).total();let l=z(a,h,u,Number.NaN,this.m_progressTracker);if(null!==l&&!l.isEmpty()){if(l===a&&(l=l.clone()),null===r[e]){const t=new d;e<3?t.setCoords(0,1):t.setCoords(0,-1);const s=new d;s.setAdd(i[e].getCenter(),t),r[e]=ge(this.m_gcs,s)}r[e].project(l);const t=te(null,l,!0);l=N(l,t,s,!0,-1,this.m_progressTracker,0,!1),o[e]=l}}}insertGeodeticPointsAlongGrid(e,t,s){const n=x.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),i=X(this.m_gcs,n,e,!0,this.m_progressTracker),r=new B,o=r.addGeometry(i);return Y(r,o,this.m_gcs,0,2,!0,t[0].xmax+s),Y(r,o,this.m_gcs,0,2,!0,t[1].xmax+s),Y(r,o,this.m_gcs,0,2,!1,t[1].ymin+s),0!==s&&(Y(r,o,this.m_gcs,0,2,!0,t[0].xmax-s),Y(r,o,this.m_gcs,0,2,!0,t[1].xmax-s),Y(r,o,this.m_gcs,0,2,!1,t[1].ymin-s)),r.getGeometry(o)}initializeGrid(e,t){for(let t=0;t<6;t++)e[t]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,s,n,i,r){const o=e[0],m=e.at(-1),a=o.y<m.y?o.y:m.y,h=o.y>m.y?o.y:m.y,c=S.q(this.m_a,this.m_eSquared,a),u=S.q(this.m_a,this.m_eSquared,h);if(this.m_q90-(c+t+this.m_absDistance)>.001&&this.m_q90+(u-t-this.m_absDistance)>.001)return!1;const l=s-p,_=n+p,f=l-Math.PI,d=l+Math.PI,g=_+Math.PI,P=[Number.NaN],x=[Number.NaN],b=[Number.NaN],y=[Number.NaN];let w=!1;if(ue(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,l,f,m,_,P,x),ue(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,g,_,o,f,b,y),(_<P[0]&&P[0]<g||_<x[0]&&x[0]<g)&&(w=!0),w||(f<b[0]&&b[0]<l||f<y[0]&&y[0]<l)&&(w=!0),!w&&i)return!1;const C=[];for(let t=e.length-1;t>=0;t--)C.push(e[t]);r.setEmpty(),r.addPathPoint2D(null,0,!0);let v=0;v=he(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,l,_,i,v,r),v=ce(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,_,g,this.m_cornerStep,i,v,r,P[0],x[0]),v=he(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,C,g,d,i,v,r),v=ce(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,f,l,this.m_cornerStep,i,v,r,b[0],y[0]);let D=!1;return i||(D=this.checkAndPrepForPole(r)),w||D}bufferPoint2D(e,t,s){s.setEmpty(),s.addPathPoint2D(null,0,!0),ce(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,0,s);let n=!1;return t||(n=this.checkAndPrepForPole(s)),n}checkAndPrepForPole(e){const t=this.checkAndPrepForPoleTouch(e),s=this.checkAndPrepForPoleWrap(e);return t||s}checkAndPrepForPoleTouch(e){const t=new x;return e.queryEnvelope(t),!(!O(t.ymax,this.m_gcs90)&&!O(t.ymin,-this.m_gcs90)||(this.prepPoleTouch(e),0))}checkAndPrepForPoleWrap(e){const t=e.getXY(0),s=e.getXY(e.getPointCount()-1);return Math.abs(t.x-s.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){const t=new y;t.insertPath2D(-1,null,0,0,!0);const s=e.getPathStart(0),n=e.getPathEnd(0),i=n-s;let r=-1;for(r=s;r<n;r++){const t=e.getXY(r),s=O(t.y,this.m_gcs90),n=O(t.y,-this.m_gcs90);if(!s&&!n)break}let o=r,m=!1,a=Number.NaN;do{const n=e.getXY(o),r=O(n.y,this.m_gcs90),h=O(n.y,-this.m_gcs90),c=s+(o+1-s)%i;if(r||h){let s=d.construct(a,n.y);t.insertPoint2D(0,-1,s);const i=e.getXY(c),r=O(i.y,this.m_gcs90),o=O(i.y,-this.m_gcs90);r||o||(s=d.construct(i.x,n.y),m?t.setXY(t.getPointCount()-1,s):t.insertPoint2D(0,-1,s)),m=!0}else t.insertPoint2D(0,-1,n),a=n.x,m=!1;o=c}while(o!==r);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){const t=new y,s=new y,n=new re,i=e.getXY(e.getPathStart(0)),r=e.getXY(e.getPathEnd(0)-1),o=this.m_gcs360,m=this.m_gcs180,a=new x;a.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const h=new x;e.queryEnvelope(h);const c=Math.ceil(h.width()/o);let u,l;i.x>r.x?(u=-o,l=this.m_gcs90):(u=o,l=-this.m_gcs90),n.setShiftCoords(u,0),t.addPath(e,0,!0),s.add(t,!1);const _=new ee;for(let e=0;e<c;e++)s.applyTransformation(n),s.getPointByVal(0,_),t.lineToPoint(_),t.addSegmentsFromPath(s,0,0,s.getSegmentCount()-1,!1);const f=t.getXY(0),g=t.getXY(t.getPointCount()-1);f.y=l,g.y=l,t.lineTo(g);const p=new d;for(p.setCoordsPoint2D(g),p.x-=.5*u;Math.abs(p.x-f.x)>m;)t.lineTo(p),p.x-=.5*u;t.lineTo(f);const P=a.getCenterX(),b=new x;t.queryEnvelope(b);let w=0;const C=b.getCenter().x;C-P>m?w=-Math.ceil((C-P-m)/o):P-C>m&&(w=Math.ceil((P-C-m)/o)),0!==w&&(n.setShiftCoords(w*o,0),t.applyTransformation(n));const v=new B,S=v.addGeometry(t);Y(v,S,this.m_gcs,0,2,!0,a.xmin),Y(v,S,this.m_gcs,0,2,!0,a.xmax);const D=v.getGeometry(S),I=se(D,a);I.inflateCoords(0,1);const G=Q(null,I,!0).total(),M=z(D,a,G,Number.NaN,this.m_progressTracker);e.setEmpty(),e.add(M,!1)}prepDoublePoleWrap(e){const t=this.m_gcs360,s=this.m_gcs180,n=new x;n.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const i=n.getCenter().x,r=new x;e.queryPathEnvelope(0,r);let o,m=0,a=r.getCenter().x;if(a-i>s?m=-Math.ceil((a-i-s)/t):i-a>s&&(m=Math.ceil((i-a-s)/t)),0!==m){const s=new re;s.setShiftCoords(m*t,0),e.getImpl().applyTransformationToPath(s,0),e.queryPathEnvelope(0,r),a=r.getCenter().x}const h=new x;n.containsExclusiveEnvelope(r)?(o=!1,h.setCoords({env2D:n})):(o=!0,h.setCoords({env2D:n}),h.xmin-=t,h.xmax+=t);let c=e.createInstance();c.addPathPoint2D(null,0,!0);const u=new d;if(u.setCoords(h.xmin,h.ymin),c.insertPoint2D(0,-1,u),u.setCoords(h.xmin,h.ymax),c.insertPoint2D(0,-1,u),u.setCoords(.5*(h.xmin+h.xmax),h.ymax),c.insertPoint2D(0,-1,u),u.setCoords(h.xmax,h.ymax),c.insertPoint2D(0,-1,u),u.setCoords(h.xmax,h.ymin),c.insertPoint2D(0,-1,u),u.setCoords(.5*(h.xmin+h.xmax),h.ymin),c.insertPoint2D(0,-1,u),o){c.addPath(e,0,!0);const s=new re;a<i?s.setShiftCoords(t,0):s.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(s,0),c.addPath(e,0,!0);const r=new B,o=r.addGeometry(c);Y(r,o,this.m_gcs,0,2,!0,n.xmin),Y(r,o,this.m_gcs,0,2,!0,n.xmax),c=r.getGeometry(o);const m=se(c,n);m.inflateCoords(0,1);const h=Q(null,m,!0).total();c=z(c,n,h,Number.NaN,this.m_progressTracker)}else c.addPath(e,0,!0);e.setEmpty(),e.add(c,!1)}setMinCornerStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new d;s.setCoords(0,10*this.m_rpu);const n=0;let i=45*this.m_rpu;const r=Z(e,new g(new j,new j),!1),o=Z(e,new g(new j,new j),!1),m=Z(e,new g(new j,new j),!1),a=Z(e,new g(new j,new j),!1),h=new d,c=new d,u=new d,l=new d;for(F.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,n,r.at(0),r.at(1)),h.setCoords(r.at(0).val,r.at(1).val),F.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,i,o.at(0),o.at(1)),c.setCoords(o.at(0).val,o.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const r=.5*(n+i);F.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,r,m.at(0),m.at(1)),u.setCoords(m.at(0).val,m.at(1).val);const _=Z(e,new j,!1),f=Z(e,new j,!1);F.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,c.x,c.y,_,f,null,2),F.geodeticCoordinate(this.m_a,this.m_eSquared,h.x,h.y,.5*_.val,f.val,a.at(0),a.at(1),2),l.setCoords(a.at(0).val,a.at(1).val);const d=Z(e,new j,!1);if(F.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,l.x,l.y,d,null,null,2),d.val<=this.m_convergenceOffset)break;i*=.9,F.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,i,o.at(0),o.at(1)),c.setCoords(o.at(0).val,o.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}const _=i-n,f=2*Math.PI/Math.ceil(2*Math.PI/_);this.m_cornerStep=f}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}setMinSegmentStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new d,n=new d;s.setCoords(0,10*this.m_rpu),n.setCoords(10*this.m_rpu,10*this.m_rpu);const i=Z(e,new j,!1),r=Z(e,new j,!1),o=Z(e,new j,!1);F.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,o,i,r,this.m_curveType);const m=Z(e,new g(new j,new j),!1),a=Z(e,new g(new j,new j),!1),h=new d,c=Z(e,new j,!1),u=Z(e,new g(new j,new j),!1),l=Z(e,new g(new j,new j),!1),_=Z(e,new g(new j,new j),!1),f=Z(e,new g(new j,new j),!1),p=new d,P=new d,x=new d,b=new d,y=0;let w=1;const C=i.val,v=r.val,S=C-.5*Math.PI,D=v+.5*Math.PI,I=o.val;for(F.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,S,u.at(0),u.at(1)),p.setCoords(u.at(0).val,u.at(1).val),F.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,t,D,l.at(0),l.at(1)),P.setCoords(l.at(0).val,l.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const i=.5*(y+w);F.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,i*I,C,m.at(0),m.at(1),this.m_curveType),h.setCoords(m.at(0).val,m.at(1).val),F.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,h.x,h.y,null,null,c,this.m_curveType);const r=c.val+.5*Math.PI;F.geodesicCoordinate(this.m_a,this.m_eSquared,h.x,h.y,t,r,_.at(0),_.at(1)),x.setCoords(_.at(0).val,_.at(1).val);const o=Z(e,new j,!1),u=Z(e,new j,!1);F.geodeticDistance(this.m_a,this.m_eSquared,p.x,p.y,P.x,P.y,o,u,null,2),F.geodeticCoordinate(this.m_a,this.m_eSquared,p.x,p.y,.5*o.val,u.val,f.at(0),f.at(1),2),b.setCoords(f.at(0).val,f.at(1).val);const d=Z(e,new j,!1);if(F.geodeticDistance(this.m_a,this.m_eSquared,x.x,x.y,b.x,b.y,d,null,null,2),d.val<=this.m_convergenceOffset)break;{const e={stack:[],error:void 0,hasError:!1};try{w*=.9,F.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,w*I,C,a.at(0),a.at(1),this.m_curveType),n.setCoords(a.at(0).val,a.at(1).val);const i=Z(e,new j,!1);F.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,null,null,i,this.m_curveType);const r=i.val+.5*Math.PI;F.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,t,r,l.at(0),l.at(1)),P.setCoords(l.at(0).val,l.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}let G=w*I;G>1e5&&(G=1e5),this.m_segmentStep=G}catch(t){e.error=t,e.hasError=!0}finally{$(e)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}}function ae(e,t,s,n,i,r,o){if(e.isEmpty())return new y({vd:e.getDescription()});let _=e;if(a(_)){const e=10*t.getTolerance(0);_=(new w).execute(_,0,e,0,o,12e3)}const f=new me(o);f.m_sr=t,f.m_gcs=t.getGCS(),f.m_transform=C(t,f.m_gcs,null);const g=v();f.m_gcs.querySpheroidData(g);const p=new x;_.queryEnvelope(p),f.m_a=g.majorSemiAxis,f.m_eSquared=g.e2,f.m_rpu=f.m_gcs.getUnit().getUnitToBaseFactor(),f.m_gcs90=.5*Math.PI/f.m_rpu,f.m_gcs180=Math.PI/f.m_rpu,f.m_gcs360=2*Math.PI/f.m_rpu,f.m_gcs60=f.m_gcs360/6,f.m_q90=S.q90(f.m_a,f.m_eSquared),f.m_ellipticToGeodesicMaxRatio=.5*f.m_a*Math.PI/f.m_q90;const P=f.m_gcs.getTolerance(0);f.m_radTolerance=P*f.m_rpu,4===s?(f.m_curveType=2,f.m_bShapePreserving=!0):(f.m_curveType=s,f.m_bShapePreserving=!1),f.m_distance=n,f.m_absDistance=Math.abs(n),Number.isNaN(i)||i<=0?f.setConvergenceOffset():f.m_convergenceOffset=Math.max(i,.001),f.m_convergenceOffset/=r;let b,N=_.getGeometryType();if(h(N)){const e=new D({vd:_.getDescription()});e.addSegment(_,!0),b=e,N=m.enumPolyline}else if(N===m.enumEnvelope){const e=_,t=new x;e.queryEnvelope(t);const s=K(Q(f.m_sr,p,!0));if(t.minDimension()<=s)if(0===t.maxDimension()){const t=new ee({vd:_.getDescription()});e.getCenter(t),b=t,N=m.enumPoint}else{const t=new D({vd:_.getDescription()});t.addEnvelope(e,!1),b=t,N=m.enumPolyline}else{const t=new y({vd:_.getDescription()});t.addEnvelope(e,!1),b=t,N=m.enumPolygon}}else b=_;if(f.setMinCornerStep(),c(N)||f.setMinSegmentStep(),f.m_absDistance<=.5*f.m_convergenceOffset)return N!==m.enumPolygon?new y({vd:b.getDescription()}):f.m_bShapePreserving?b:I(b,f.m_sr,f.m_curveType,f.m_segmentStep,-1,o);if(f.m_distance<0&&N!==m.enumPolygon)return new y({vd:b.getDescription()});if(f.m_bShapePreserving&&u(N)){const e=I(b,t,4,Number.NaN,f.m_convergenceOffset,o);b=(new G).execute(e,f.m_transform,o)}else b=(new G).execute(b,f.m_transform,o);if(b=M(b,f.m_gcs),b.isEmpty())return new y({vd:b.getDescription()});!f.m_bShapePreserving&&u(N)&&(b=T(f.m_rpu,b)),b=function(e,t){const s=e.getGeometryType();let n;if(n=u(s)?e.getPathCount():s===m.enumMultiPoint?e.getPointCount():1,1===n)return e;const i=[],r=[];for(let o=0;o<n;o++){i.push(o);const n=new d;if(u(s)){const t=new x;e.queryPathEnvelope(o,t),n.assign(t.getCenter())}else n.assign(e.getXY(o));const m=t.toGeohash(n);r.push(m)}i.sort((e,t)=>r[e]<r[t]?-1:r[e]>r[t]?1:0);const o=e.createInstance();for(let t=0;t<n;t++){const n=i[t];u(s)?o.addPath(e,n,!0):o.addPoints(e,n,n+1)}return o}(b,f.m_gcs);let k=new y;switch(N){case m.enumPolygon:k=f.bufferPolygon(b);break;case m.enumPolyline:k=f.bufferPolyline(b);break;case m.enumMultiPoint:k=f.bufferMultiPoint(b);break;case m.enumPoint:k=f.bufferPoint(b);break;default:l("")}const A=(new G).execute(k,f.m_transform.getInverse(),o);return A.mergeVertexDescription(b.getDescription()),A}function he(e,t,s,n,i,r,o,m,a,h,c){const u={stack:[],error:void 0,hasError:!1};try{const l=new d;l.setNAN(),a||c.getPointCount()>0&&(l.setCoordsPoint2D(c.getXY(c.getPointCount()-1)),l.scale(s));const _=Z(u,new j,!1),f=Z(u,new g(new j,new j),!1),p=new d,P=new d,x=r.at(-1),b=1/s;for(let s=0;s<r.length;s++){const u=r[s];let d;0===s?d=o:s===r.length-1?d=m:(F.geodeticDistance(e,t,x.x,x.y,u.x,u.y,null,null,_,i),d=_.val-.5*Math.PI),F.geodesicCoordinate(e,t,u.x,u.y,n,d,f.at(0),f.at(1)),a?P.setCoords(f.at(0).val,f.at(1).val):(p.setCoords(f.at(0).val,f.at(1).val),h=le(u.x,p.x,l.x,h),P.setCoords(h+p.x,p.y),l.setCoordsPoint2D(P)),P.scale(b),c.insertPoint2D(0,-1,P)}return h}catch(e){u.error=e,u.hasError=!0}finally{$(u)}}function ce(e,t,s,n,i,r,o,m,a,h,c,u=Number.NaN,l=Number.NaN){const _={stack:[],error:void 0,hasError:!1};try{if(o-r<m)return h;const f=Z(_,new g(new j,new j),!1),p=new d,P=new d,x=new d;P.setNAN(),a||c.getPointCount()>0&&(P.setCoordsPoint2D(c.getXY(c.getPointCount()-1)),P.scale(s));let b=Math.ceil(r/m),y=b++*m;y===r&&(y=b++*m);let w=r;const C=1/s;for(;y<o+m&&(w<u&&u<y?(y=u,b--):w<l&&l<y&&(y=l,b--),!(y>=o));)F.geodesicCoordinate(e,t,i.x,i.y,n,y,f.at(0),f.at(1)),a?x.setCoords(f.at(0).val,f.at(1).val):(p.setCoords(f.at(0).val,f.at(1).val),h=le(i.x,p.x,P.x,h),x.setCoords(h+p.x,p.y),P.setCoordsPoint2D(x)),x.scale(C),c.insertPoint2D(0,-1,x),w=y,y=b++*m;return h}catch(e){_.error=e,_.hasError=!0}finally{$(_)}}function ue(e,t,s,n,i,r,o,m,a,h,c){const u={stack:[],error:void 0,hasError:!1};try{const s=new d,l=new d,_=Z(u,new g(new j,new j),!1);F.geodesicCoordinate(e,t,i.x,i.y,n,r,_.at(0),_.at(1)),s.setCoords(_.at(0).val,_.at(1).val),F.geodesicCoordinate(e,t,i.x,i.y,n,o,_.at(0),_.at(1)),l.setCoords(_.at(0).val,_.at(1).val);const f=Z(u,new j,!1);for(F.geodeticDistance(e,t,m.x,m.y,s.x,s.y,null,f,null,0),h[0]=f.val,F.geodeticDistance(e,t,m.x,m.y,l.x,l.y,null,f,null,0),c[0]=f.val;h[0]<=c[0];)h[0]+=P;for(;h[0]>c[0];)h[0]-=P;for(;h[0]>=a;)h[0]-=P,c[0]-=P;for(;h[0]<a;)h[0]+=P,c[0]+=P}catch(e){u.error=e,u.hasError=!0}finally{$(u)}}function le(e,t,s,n){if(Number.isNaN(s)){for(;n+t-e>Math.PI;)n-=P;for(;e-(n+t)>Math.PI;)n+=P;return n}return n+t-s>Math.PI?n-=P:s-(n+t)>Math.PI&&(n+=P),n}function _e(e,t,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const m=s[0],a=s.at(-1),h=Z(o,new j,!1),c=Z(o,new j,!1),u=Z(o,new j,!1);F.greatEllipticDistance(e,t,i.x,i.y,m.x,m.y,h,null,null),F.greatEllipticDistance(e,t,i.x,i.y,a.x,a.y,c,null,null),F.greatEllipticDistance(e,t,m.x,m.y,a.x,a.y,u,null,null);let l=Math.min(h.val,c.val)+u.val,_=l+n;if(_<r)return!0;const f=Z(o,new j,!1);l=Math.max(h.val,c.val);for(let n=1;n<s.length-1;n++){const r=s[n];F.greatEllipticDistance(e,t,i.x,i.y,r.x,r.y,f,null,null),f.val>l&&(l=f.val)}return _=l+n,_<r}catch(e){o.error=e,o.hasError=!0}finally{$(o)}}function fe(e,t,s,n,i,r,o,m){let a;if(n.length%2==0){const e=n.length>>1,t=n[e],s=n[e-1];a=d.lerp(t,s,.5)}else a=n[n.length-1>>1].clone();const h=a.clone(),c=W(e,t,h,75/180*Math.PI);return!!_e(e,t,n,i,h,c)&&(null!==r&&(r.setCoordsPoint2D(a),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(h),null!==m&&(m[0]=c),!0)}function de(e,t,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const m=Z(o,new j,!1);return F.greatEllipticDistance(e,t,i.x,i.y,s.x,s.y,m,null,null),m.val+n<r}catch(e){o.error=e,o.hasError=!0}finally{$(o)}}function ge(e,t){return new L(e,t)}function pe(e){return ne(e,0)||ie(e,0),e}class Pe{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new d,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class xe extends Pe{constructor(e,t,s){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new y,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=s,this.m_bNeedsSimplify=!0;const n=new x;this.m_multiPath.queryEnvelope(n);const i=n.getCenter(),r=i.clone();r.scale(this.m_bufferer.m_rpu),this.m_gnomonic=ge(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=r.clone(),this.m_minGnomonicRadius=W(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,r,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let s=0;const n=new d,i=new d;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){const e=this.m_segIter.nextSegment();if(n.setCoordsPoint2D(e.getStartXY()),i.setCoordsPoint2D(e.getEndXY()),n.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),J(n,i))n.x=i.x;else if(U(n,i))i.x=n.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),r=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<r&&(e=this.m_multiPath.isClosedPath(s)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(s)?r:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),U(t,n)&&(n.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),J(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0;const r=H(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,n,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===s)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(fe(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(0===r||V(n,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(n,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(r,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===t&&(t=new y,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),s++}if(this.m_currentDensifiedDelta=[0],s>0){const e=this.m_segIter.getStartPointIndex(),r=this.m_segIter.getPathIndex();for(;s>0;){if(this.m_segIter.previousSegment(),n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),n.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(J(n,i))n.x=i.x;else if(U(n,i))i.x=n.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),r=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<r&&(e=this.m_multiPath.isClosedPath(s)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(s)?r:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),U(t,n)&&(n.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),J(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0,H(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,n,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),s--}return n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),n.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=ce(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,n,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,r),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&_e(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new d,s=new d,n=[0];return fe(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=ge(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){const t=this.m_densifiedPoints[0];let s=Number.NaN,n=this.m_startAzimuth[0]-p;const i=this.m_endAzimuth[0]+p;let r=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(s=this.m_lastAzimuth+p,n=s+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(s=this.m_lastAzimuth+p,n=s+Math.PI-(P-(this.m_startAzimuth[0]-this.m_lastAzimuth))),r=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI||this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let i=!1;if(Math.abs(n-s)<=.5*this.m_bufferer.m_cornerStep&&(r||(i=!0)),i){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){const t=new d;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=P:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=P)}n=.5*(n+s)}else if(r){const s=new d;s.setCoordsPoint2D(t),s.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,s)}else ce(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],s,n,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,he(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,n,i,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}}class be extends Pe{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;const s=new x;this.m_multiPoint.queryEnvelope(s);const n=s.getCenter(),i=n.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=ge(this.m_bufferer.m_gcs,n),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=W(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(e));const t=new y,s=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t);return this.m_bNeedsSimplify=s,t}isPointBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&de(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new d,s=new d,n=[0];return function(e,t,s,n,i,r,o,m){const a=W(e,t,n,75/180*Math.PI);return!!de(e,t,n,i,n,a)&&(null!==r&&(r.setCoordsPoint2D(n),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(n),null!==m&&(m[0]=a),!0)}(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=ge(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}}class ye{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n,i,r,o,m){if(o){const o=new we(e,t,s,n,i,!1,r,m);return(new b).executeMany(o,t,m)}return new we(e,t,s,n,i,!1,r,m)}execute(t,n,i,r,o,m,a){const h=new e([t]),c=[r],u=this.executeMany(h,n,i,c,o,!1,m,a).next();return u||s("geodesic buffer null output"),u}}class we extends t{constructor(e,t,s,r,o,m,a,h){super(),this.m_currentUnionEnvelope2D=new x,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=h,m&&n(""),t||i(""),0===t.getCoordinateSystemType()&&i(""),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=s,this.m_distances=r,this.m_convergenceOffset=o,this.m_bOutlineOnly=m,this.m_bUnion=a}next(){let e;for(;e=this.m_inputGeoms.next();)return r(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return function(e,t,s,n,a,h){n<Number.MAX_VALUE&&n>-Number.MAX_VALUE||i("Geodesic_bufferer.buffer - bad distance"),r(e);const c=oe(e),u=c.getGeometryType();if(o(u)){const e=c.getPointCount(),i=8e6;if(Math.abs(n)>i&&(e>50||u!==m.enumMultiPoint&&4===s&&e>2)){let e=c;const r=n>0?1:-1,o=7e6;let m=n,u=1;do{u++,m=(Math.abs(m)-o)*r}while(Math.abs(m)>i);m=n;for(let n=0;n<u-1;n++)e=ae(e,t,s,o*r,a,u,h),m=(Math.abs(m)-o)*r;return e=ae(e,t,s,m,a,u,h),e}}return ae(c,t,s,n,a,1,h)}(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}}export{ye as OperatorGeodesicBuffer};
