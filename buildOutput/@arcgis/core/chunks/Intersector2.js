/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{k as t,t as s,l as r,a as e,j as i}from"./vec3.js";import{c as n}from"./vec3f64.js";import{c as a,f as o,g as h}from"./ray.js";import f from"../views/3d/webgl/RenderCamera.js";import{H as l,a as c,I as m}from"./HUDIntersectorResult.js";import{g as u}from"./mat3.js";import{c as _}from"./mat3f64.js";import{i as p,t as d,c as y,m as g}from"./mat4.js";import{c as v}from"./mat4f64.js";import{b as O,g as b}from"./sphere.js";import{O as M,a as T}from"./orientedBoundingBox.js";class x{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.filteredLayerViewUids=[],this.store=2,this.normalRequired=!0,this.excludeLabels=!1}}class w{constructor(){this._transform=v(),this._transformInverse=new j({value:this._transform},p,v),this._transformInverseTranspose=new j(this._transformInverse,d,v),this._transformTranspose=new j({value:this._transform},d,v),this._transformInverseRotation=new j({value:this._transform},u,_)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){y(this._transform,t)}multiplyTransform(t){g(this._transform,this._transform,t)}set(t){y(this._transform,t),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,s){this.setTransformMatrix(t),this.multiplyTransform(s),this._invalidateLazyTransforms()}}class j{constructor(t,s,r){this._original=t,this._update=s,this._dirty=!0,this._transform=r()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}}const L=new class{constructor(t=0){this.offset=t,this.sphere=O(),this.tmpVertex=n()}applyToVertex(i,n,a){const o=this.objectTransform.transform,h=t(q,i,n,a),f=s(h,h,o),l=this.offset/r(f);e(f,f,f,l);const c=this.objectTransform.inverse;return s(this.tmpVertex,f,c),this.tmpVertex}applyToMinMax(t,s){const i=this.offset/r(t);e(t,t,t,i);const n=this.offset/r(s);e(s,s,s,n)}applyToAabb(t){const s=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*s,t[1]+=t[1]*s,t[2]+=t[2]*s;const r=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*r,t[4]+=t[4]*r,t[5]+=t[5]*r,t}applyToBoundingSphere(t){const s=r(b(t)),i=this.offset/s;return e(b(this.sphere),b(t),b(t),i),this.sphere[3]=t[3]+t[3]*this.offset/s,this.sphere}};function I(t){return null!=t?(L.offset=t,L):null}const V=new class{constructor(t=0){this.componentLocalOriginLength=0,this._totalOffset=0,this._offset=0,this._tmpVertex=n(),this._tmpMbs=O(),this._tmpObb=new M,this._resetOffset(t)}_resetOffset(t){this._offset=t,this._totalOffset=t}set offset(t){this._resetOffset(t)}get offset(){return this._offset}set componentOffset(t){this._totalOffset=this._offset+t}set localOrigin(t){this.componentLocalOriginLength=r(t)}applyToVertex(s,i,n){const a=t(q,s,i,n),o=t(z,s,i,n+this.componentLocalOriginLength),h=this._totalOffset/r(o);return e(this._tmpVertex,a,o,h),this._tmpVertex}applyToAabb(t){const s=this.componentLocalOriginLength,r=t[0],e=t[1],i=t[2]+s,n=t[3],a=t[4],o=t[5]+s,h=Math.abs(r),f=Math.abs(e),l=Math.abs(i),c=Math.abs(n),m=Math.abs(a),u=Math.abs(o),_=.5*(1+Math.sign(r*n))*Math.min(h,c),p=.5*(1+Math.sign(e*a))*Math.min(f,m),d=.5*(1+Math.sign(i*o))*Math.min(l,u),y=Math.max(h,c),g=Math.max(f,m),v=Math.max(l,u),O=Math.sqrt(_*_+p*p+d*d),b=Math.sign(h+r),M=Math.sign(f+e),T=Math.sign(l+i),x=Math.sign(c+n),w=Math.sign(m+a),j=Math.sign(u+o),L=this._totalOffset;if(O<L)return t[0]-=(1-b)*L,t[1]-=(1-M)*L,t[2]-=(1-T)*L,t[3]+=x*L,t[4]+=w*L,t[5]+=j*L,t;const I=L/Math.sqrt(y*y+g*g+v*v),V=L/O,E=V-I,A=-E;return t[0]+=r*(b*A+V),t[1]+=e*(M*A+V),t[2]+=i*(T*A+V),t[3]+=n*(x*E+I),t[4]+=a*(w*E+I),t[5]+=o*(j*E+I),t}applyToMbs(t){const s=r(b(t)),i=this._totalOffset/s;return e(b(this._tmpMbs),b(t),b(t),i),this._tmpMbs[3]=t[3]+t[3]*this._totalOffset/s,this._tmpMbs}applyToObb(t){return T(t,this._totalOffset,this._totalOffset,1,this._tmpObb),this._tmpObb}};function E(t){return null!=t?(V.offset=t,V):null}const A=new class{constructor(t=0){this.offset=t,this.tmpVertex=n()}applyToVertex(s,n,a){const o=t(q,s,n,a),h=i(z,o,this.localOrigin),f=this.offset/r(h);return e(this.tmpVertex,o,h,f),this.tmpVertex}applyToAabb(t){const s=P,r=U,e=W;for(let i=0;i<3;++i)s[i]=t[0+i]+this.localOrigin[i],r[i]=t[3+i]+this.localOrigin[i],e[i]=s[i];const i=this.applyToVertex(s[0],s[1],s[2]);for(let s=0;s<3;++s)t[s]=i[s],t[s+3]=i[s];const n=s=>{const r=this.applyToVertex(s[0],s[1],s[2]);for(let s=0;s<3;++s)t[s]=Math.min(t[s],r[s]),t[s+3]=Math.max(t[s+3],r[s])};for(let t=1;t<8;++t){for(let i=0;i<3;++i)e[i]=t&1<<i?r[i]:s[i];n(e)}let a=0;for(let t=0;t<3;++t)s[t]*r[t]<0&&(a|=1<<t);if(0!==a&&7!==a)for(let t=0;t<8;++t)if(0===(a&t)){for(let i=0;i<3;++i)e[i]=a&1<<i?0:t&1<<i?s[i]:r[i];n(e)}for(let s=0;s<3;++s)t[s]-=this.localOrigin[s],t[s+3]-=this.localOrigin[s];return t}};function R(t){return null!=t?(A.offset=t,A):null}const B="terrain",q=n(),z=n(),P=n(),U=n(),W=n(),k=1e-5;class D{constructor(t){this.options=new x,this._results=new N,this.transform=new w,this.camera=new f,this.tolerance=k,this.verticalOffset=null,this._ray=a(),this._rayEnd=n(),this._rayBeginTransformed=n(),this._rayEndTransformed=n(),this.viewingMode=t??1}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,s,r){this.resetWithRay(o(t,s,this._ray),r)}resetWithRay(t,s){this.camera=s,t!==this._ray&&h(t,this._ray),0!==this.options.verticalOffset?2===this.viewingMode?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,i(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,s,r,e,i){this.point=s,this.filterPredicate=e,this.tolerance=r??k;const n=I(this.verticalOffset);if(t&&t.length>0){const s=i?t=>{i(t)&&this.intersectObject(t)}:t=>{this.intersectObject(t)};for(const r of t){const t=r.getSpatialQueryAccelerator?.();null!=t?(null!=n?t.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,s,n):t.forEachAlongRay(this._ray.origin,this._ray.direction,s),this.options.selectionMode&&this.options.hud&&t.forEachDegenerateObject(s)):r.objects.forEach(t=>s(t))}}this.sortResults()}intersectObject(t){const r=t.geometries;if(!r)return;const e=t.effectiveTransformation,i=I(this.verticalOffset);for(const n of r){if(!n.visible)continue;const{material:r,id:a}=n;if(!r.visible)continue;this.transform.setAndInvalidateLazyTransforms(e,n.transformation),s(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),s(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const o=this.transform.transform;null!=i&&(i.objectTransform=this.transform),r.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(s,r,e,i)=>this.handleObjectIntersection({object:t,geometryId:a,primitiveIndex:e},s,r,o,i))}}handleObjectIntersection(t,s,r,e,i){if(s<0||null!=this.filterPredicate&&!this.filterPredicate(this._ray.origin,this._rayEnd,s))return;const n=i?this._results.hud:this._results;t=i?new l(t,i):t;const a=i?e=>e.set(1,t,s,r):i=>i.set(0,t,s,r,e);if((null==n.min.distance||s<n.min.distance)&&a(n.min),0!==this.options.store&&(null==n.max.distance||s>n.max.distance)&&a(n.max),2===this.options.store)if(i){const t=new c(this._ray);a(t),this._results.hud.all.push(t)}else{const t=new m(this._ray);a(t),this._results.all.push(t)}}sortResults(t=this._results.all){t.sort((t,s)=>t.distance!==s.distance?(t.distance??0)-(s.distance??0):t.drapedLayerOrder!==s.drapedLayerOrder?H(t.drapedLayerOrder,s.drapedLayerOrder):H(t.renderPriority,s.renderPriority))}}function H(t,s){return(s??-Number.MAX_VALUE)-(t??-Number.MAX_VALUE)}class N{constructor(){this.min=new m(a()),this.max=new m(a()),this.hud={min:new c(a()),max:new c(a()),all:new Array},this.ground=new m(a()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}export{D as I,I as a,R as b,k as d,E as g,B as t};
