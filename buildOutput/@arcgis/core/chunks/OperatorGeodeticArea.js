/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{a as e,v as t,G as i,P as s,K as n,r as a,D as _,p as r,B as h,c as o,b as m,E as l,y as p,O as u,f as c,Q as g,R as d,T as E}from"./Point2D.js";import{P as f,f as P,N as S,d as A,K as y,y as x,aD as R,J as M,G as C,ai as T,aE as w,a as N,A as q,F as b,aF as I,aG as v,H as D,I as G,Q as z,aH as O,ad as L,L as $,al as k}from"./ProjectionTransformation.js";import{Envelope2D as F}from"./Envelope2D.js";import{c as J,d as Y}from"./Envelope.js";import{O as U}from"./OperatorShapePreservingLength.js";import{a as j,b as X}from"./tslib.es6.js";import{T as B}from"./Transformation2D.js";import{a as H}from"./GeodeticDistanceCalculator-Ce-woMPw.js";import"./SimpleGeometryCursor.js";import"./OperatorDefinitions.js";import"./Distance2DCalculator-CXhBP-8I.js";import"./OperatorShapePreservingDensify.js";import"./OperatorGeodeticDensifyByLength.js";class Q{constructor(e,t,i,s,n=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=s,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=i.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===i.getCoordinateSystemType(),this.PEProjcs=i.getPECoordSys(),this.m_points=a(2*n,Number.NaN)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&M.projToGeogCenter(this.PEProjcs,1,t,0);const i=Math.sin(t[1]*this.m_cRpu);return 0===this.m_cE2?i:-Math.log((1-this.m_cE*i)/(1+this.m_cE*i))*this.m_c1By2e+i/(1-this.m_cE2*i*i)}}}function V(e,t,i,s,n){const a=(new P).execute(e,t,0,0,n);let _;_=s?(new C).execute(a,s,n):a;const r=1===i.getUnit().getUnitToBaseFactor()?Math.PI/180:1,h=new F;_.queryEnvelope(h);const o=new F,m=new F,l=new F;o.setCoords({xmin:h.xmin,ymin:75*r,xmax:h.xmax,ymax:90*r}),m.setCoords({xmin:h.xmin,ymin:-60*r,xmax:h.xmax,ymax:75*r}),l.setCoords({xmin:h.xmin,ymin:-90*r,xmax:h.xmax,ymax:-60*r}),o.inflateCoords(.01*o.width(),0),m.inflateCoords(.01*m.width(),0),l.inflateCoords(.01*l.width(),0);let p=0;return p+=Z(_,o,i,n),p+=Z(_,m,i,n),p+=Z(_,l,i,n),p}function Z(e,t,i,n){const a=(new y).execute(e,t,i,n);if(null!==a&&!a.isEmpty()){const e=new F;a.queryEnvelope(e);const{first:t,second:l}=function(e,t){const i=function(e,t){const i=e.getUnit().getUnitToBaseFactor(),n=t.getCenter();n.scale(180*i/Math.PI);const a=new s;a.x=0,a.y=0;let _=0;if(0===_){n.y>45?(a.y=h,_=0):n.y<-45?(a.y=-h,_=1):n.x>=45&&n.x<135?(a.x=h,_=2):n.x>=135||n.x<-135?(a.x=h,_=3):n.x<-45&&n.x>=-135?(a.x=-h,_=4):(a.x=0,_=5);const e=i*Math.sqrt(o(t.xmin-t.xmax)+o(t.ymin-t.ymax)),r=a.clone(),m=t.getCenter();if(m.scale(i),_<2&&(r.x=m.x),s.distance(r,m)+.5*e>h)return null}const l=K[_];if(null!==l&&l.getGCS().equalHorizontal(e))return l;const p=e.getText(),u=a.x,c=a.y;let g=0,d=-1;6!==_?d=T.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(m(!1),g=0,d=T.PE_PRJ_CYLINDRICAL_EQAREA);const E=w("EqualAreaPCS");let f;d===T.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?f=`PROJCS["${E}",${p},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${u}],PARAMETER["Latitude_of_Origin",${c}],UNIT["Meter",1.0]]`:d===T.PE_PRJ_CYLINDRICAL_EQAREA?f=`PROJCS["${E}",${p},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${u}],PARAMETER["Standard_Parallel_1",${g}],PARAMETER["Latitude_of_Origin",${c}],UNIT["Meter",1.0]]`:r("getEqualAreaPcsFixed");const P=N(f);return K[_]&&K[_].destroy(),K[_]=P,P}(e,t);if(null!==i)return _(i,!1);const n=e.getText(),a=e.getUnit().getUnitToBaseFactor(),l=(t.xmin+t.width()/2)*a,p=(t.ymin+t.height()/2)*a;let u=0,c=0,g=-1;t.ymin*a>=75*Math.PI/180||t.ymax*a<=-60*Math.PI/180?g=T.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:t.ymin>0||t.ymax<0?(u=(t.ymin+1/3*t.height())*a,c=(t.ymin+2/3*t.height())*a,g=T.PE_PRJ_ALBERS):(u=(t.ymin+2/3*t.height())*a,g=T.PE_PRJ_CYLINDRICAL_EQAREA);const d=w("EqualAreaPCS");let E;return g===T.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?E=`PROJCS["${d}",${n},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:g===T.PE_PRJ_ALBERS?E=`PROJCS["${d}",${n},PROJECTION["Albers"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${u}],PARAMETER["Standard_Parallel_2",${c}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:g===T.PE_PRJ_CYLINDRICAL_EQAREA?E=`PROJCS["${d}",${n},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${u}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:r("getEqualAreaPCSInstance"),_(N(E),!0)}(i,e),p=S(i,t,null),u=(new C).execute(a,p,n).calculateArea2D();return l&&t.destroy(),u}return 0}const K=[null,null,null,null,null,null,null];class W{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}execute(a,r,h){if(0===r.getCoordinateSystemType()&&e(""),a.isEmpty()||a.getDimension()<2)return 0;if(t(a),a.getGeometryType()===i.enumEnvelope){const e=new f;return e.addEnvelope(a,!1),this.execute(e,r,h)}let o=a;a.getDescription().getAttributeCount()>1&&(o=a.clone(),o.dropAllAttributes());const m=(new P).execute(o,0,r.getTolerance(0),0,h);let l=null;const p=r.getGCS();p!==r&&(l=S(r,p));let u=(new A).execute(m,r,!1,h);return u.isEmpty()?0:(u===a&&(u=a.clone()),r.isPannable()?function(e,t,i){const a=new F;e.queryEnvelope(a);const _=J(t,a,!0).total(),r=t.getPannableExtent();r.xmin=a.xmin-10*_,r.xmax=a.xmax+10*_;const h=(new y).execute(e,r,t,i).getImpl().querySegmentIterator();h.stripAttributes();const o=x();t.querySpheroidData(o);const m=o.e2,l=0===m?2:1,p=new s(0,0),u=new s(0,0),c=new n(0),g=new Q(p,u,t,m,100);for(;h.nextPath();)for(;h.hasNextSegment();){const e=h.nextSegment();p.assign(e.getStartXY()),u.assign(e.getEndXY()),g.setSegmentEndPoints(p,u);const t=R(6,0,1,1e-12,1e-15,g.makeFunctor());c.pe((u.x-p.x)*t)}const d=o.majorSemiAxis;return l*d*d*(1-m)*Math.PI*c.getResult()/t.getPannableExtent().width()}(u,r,h):function(e,t,i,s,n){const a=function(e,t,i){const s=e.calculateLength2D(),n=(new U).execute(e,t,i)/25e3,a=s/e.getSegmentCount()*2;let r=Math.min(a,s/n);return 0===r&&(r=1),_(r,s/r)}(e,t,n);let r=V(e,a.first,i,s,n),h=1,o=0,m=0;do{if(h++,a.first*=.5,a.first<50*t.getTolerance(0))return r;a.second*=2,m=V(e,a.first,i,s,n),o=Math.abs(m-r),r=m}while(Math.abs(r)>1&&o>1e-8*Math.abs(r)&&(a.second<65e3&&h<8||h<4));return m}(u,r,p,l,h))}}function ee(){return{m_p_PCS:new s,m_factor:Number.NaN,setValues:te,assign:ie}}function te(e,t){this.m_factor=e,this.m_p_PCS.assign(t)}function ie(e){this.m_factor=e.m_factor,this.m_p_PCS.assign(e.m_p_PCS)}class se{constructor(e,t,i,s){this.m_ptStart=new Y,this.m_ptEnd=new Y,this.m_ptStart.assign(t),this.m_ptEnd.assign(i),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const n=Math.sin(s);let a;a=0===this.m_e2?2*n:n*(d(this.m_e*n)+1/(1-this.m_e2*n*n)),this.m_baseA=a}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,i=t*this.m_ptStart.x+e*this.m_ptEnd.x,s=t*this.m_ptStart.y+e*this.m_ptEnd.y,n=t*this.m_ptStart.z+e*this.m_ptEnd.z,a=i*i+s*s,_=n/Math.sqrt(n*n+this.m_c1MinusE2*this.m_c1MinusE2*a);let r;return r=0===this.m_e2?2*_:_*(d(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*i-this.m_deltaX*s)/a*(r-this.m_baseA)}}}function ne(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:ae,changeSign:_e,assign:re,clone:he}}function ae(e,t,i,s){const n=.5*e;this.sin_phi=Math.sin(e);const a=t*this.sin_phi,_=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(n+i),this.sin_half_phi_pz=Math.sin(n+s),this.sin_half_asin_e_sin_phi_pf=Math.sin(_+i),this.sin_half_asin_e_sin_phi_pz=Math.sin(_+s),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function _e(){this.sin_phi=-this.sin_phi;let e=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=e,e=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=e,e=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=e,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function re(e){this.sin_phi=e.sin_phi,this.one_p_sin_phi=e.one_p_sin_phi,this.one_m_sin_phi=e.one_m_sin_phi,this.one_m_e_2_sin_2_phi=e.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=e.sin_half_phi_pf,this.sin_half_phi_pz=e.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=e.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=e.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=e.atanh_sin_phi,this.atanh_esin_phi=e.atanh_esin_phi,this.make_negative=e.make_negative}function he(){return{...this}}class oe{constructor(t,i,s){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new B,this.m_scaleToDegrees=new B,this.m_progressTracker=s,m(4!==i),this.m_curveType=i,this.m_inputSR=t,t&&0!==t.getCoordinateSystemType()||e(""),this.m_inputGCS=t.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,i=e.clone();if(i.dropAllAttributes(),e.hasNonLinearSegments()&&(i=(new P).execute(i,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const e=new F;i.queryEnvelope(e);const t=this.m_inputSR.getPannableExtent();if(!t.containsEnvelope(e)){const s=t.getCenterX()-e.getCenterX(),n=new B;n.setShiftCoords(s,0),i.applyTransformation(n),e.move(s,0);const a=new l;t.queryIntervalX(a);const _=new l;e.queryIntervalX(_),i=a.contains(_)?q(i,this.m_inputSR):(new C).foldInto360RangeGeodetic(i,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(i=(new A).execute(i,this.m_inputSR,!1,this.m_progressTracker),t=i.createInstance(),b(this.m_transformPCS2GCS,i,t,this.m_progressTracker)||(t=(new C).execute(i,this.m_transformPCS2GCS,this.m_progressTracker))):t=(new A).execute(i,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(1===this.m_curveType){const e=x();return this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.loxodromeArea(t)}const s=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),s.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const n=x();if(this.m_inputGCS.querySpheroidData(n),this.m_a=n.majorSemiAxis,this.m_b=n.minorSemiAxis,this.m_eSquared=n.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(t);{const e={stack:[],error:void 0,hasError:!1};try{const i=I.unit(9101),s=this.m_inputGCS.getPECoordSys(),n=j(e,s.cloneAlterUnits(i),!1);let a,_,r=this.executeClippedPolygonGeodeticArea(t,n,0),h=0;do{h++,a=this.executeClippedPolygonGeodeticArea(t,n,h),_=Math.abs(a-r),r=a}while(Math.abs(a)>1&&_>1e-8*Math.abs(a)&&h<7);return a}catch(t){e.error=t,e.hasError=!0}finally{X(e)}}}executeClippedPolygonGeodeticArea(e,t,i){const _={stack:[],error:void 0,hasError:!1};try{const r=new F;e.queryEnvelope(r);const h=j(_,this.getEqualAreaPCSInstance(t,r),!1),o=e.clone();v(h,o);const m=50,l=o.getImpl().getAttributeStreamRef(0),c=e.getImpl().getAttributeStreamRef(0),g=j(_,new D,!1),d=j(_,new D,!1),E=40,f=[0,0],P=p(ee,E),S=a(E,-1),A=ee(),y=ee();let x,R;const C=h;let T=o.calculateArea2D();const w=new n(0),N=.5*Math.PI,q=1e-10*Math.abs(T)+1e-6,b=e.getPathCount();let I,z,O,L;const $=new s,k=new s,J=new s,Y=new s,U=new s,X=new s;let B,H;for(z=e.getPathStart(0),I=0;I<b;I++,z=O)for(O=e.getPathEnd(I),l.queryPoint2D(O-1<<1,J),c.queryPoint2D(O-1<<1,$),Math.abs($.y)>N&&($.y=u(N,$.y)),L=z;L<O;L++,J.assign(Y),$.assign(k)){if(l.queryPoint2D(L<<1,Y),c.queryPoint2D(L<<1,k),Math.abs(k.y)>N&&(k.y=u(N,k.y)),B=s.distance(J,Y),B<m||0===$.y&&0===k.y)continue;G.geodeticDistance(this.m_a,this.m_eSquared,$.x,$.y,k.x,k.y,g,d,null,this.m_curveType);const e=g.val,t=d.val;for(A.setValues(0,J),y.setValues(1,Y),R=i,P[0].assign(y),S[0]=i,x=0;x>=0;){H=.5*(A.m_factor+y.m_factor),G.geodeticCoordinate(this.m_a,this.m_eSquared,$.x,$.y,e*H,t,g,d,this.m_curveType),U.x=g.val,U.y=d.val,f[0]=U.x,f[1]=U.y,M.geogToProj(C,1,f),X.x=f[0],X.y=f[1];const i=.5*-X.offset(A.m_p_PCS,y.m_p_PCS)*s.distance(A.m_p_PCS,y.m_p_PCS);if(w.pe(i),Math.abs(i)>q||Math.abs(i)>0&&R>0)y.setValues(H,X),x++,P[x].assign(y),Math.abs(i)<=q?(R--,S[x-1]=R,S[x]=R):(R=S[x-1],S[x]=R);else{if(x<=0)break;A.assign(y),x--,y.assign(P[x]),R=S[x]}}}return T+=w.getResult(),Math.abs(T)}catch(e){_.error=e,_.hasError=!0}finally{X(_)}}executeClippedPolygonGreatEllipticArea(e){const t=[],i=[],a=new s,_=new s,r=z(1,this.m_eSquared,new s(0,.5*Math.PI)),o=new n(0),m=new n(0),l=new n(0),p=new Y,g=new Y,d=new F;e.queryLooseEnvelope(d);let E=0;d.containsCoords(d.xmin,0)||(E=Math.abs(d.ymin)<Math.abs(d.ymax)?d.ymin:d.ymax);const f=new se(this.m_eSquared,p,g,E),P=this.m_a*this.m_a,S=e.getImpl().querySegmentIterator();for(S.stripAttributes();S.nextPath();)for(;S.hasNextSegment();){const e=S.nextSegment();a.assign(e.getStartXY()),_.assign(e.getEndXY()),_.x-a.x>Math.PI?a.x+=2*Math.PI:_.x-a.x<-Math.PI&&(_.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(e,t,i);for(let e of t)p.assign(z(this.m_a,this.m_eSquared,e.getStartXY())),g.assign(z(this.m_a,this.m_eSquared,e.getEndXY())),f.setSegmentEndPoints(p,g),this.adaptiveIntegrationWithRomberg(f,o);for(let e of i){let t=e.getStartXY(),i=e.getEndXY(),s=E;t.y<0&&(i=c(t,t=i),t.y=-t.y,i.y=-i.y,s=-s);const n=z(1,this.m_eSquared,t),a=z(1,this.m_eSquared,i),_=Math.min(t.y,i.y),o=O(this.m_eSquared,t.x,i.x,s,_);m.pe(o);const p=Math.abs(O(this.m_eSquared,t.x,i.x,_,h)),g=new Y;g.setSub(n,r);const d=new Y;d.setSub(a,r);const f=new Y;f.setCrossProductVector(g,d);let S=P*(p-.5*f.length());S=u(S,i.x-t.x),l.pe(S)}t.length=0,i.length=0}return l.getResult()+P*(.5*(1-this.m_eSquared)*o.getResult()+m.getResult())}getEqualAreaPCSInstance(e,t){const i=t.getCenterX();let s,n;const a=t.height();let _,r;(_=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?s=u(.5*Math.PI,t.getCenterY()):(s=t.getCenterY(),n=t.ymin+a*(2/3));const h=w("EqualAreaPCS"),o=e.toString();return r=_?I.fromString(T.PE_TYPE_PROJCS,`PROJCS["${h}", ${o}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${i}], PARAMETER["Latitude_of_Origin", ${s}], UNIT["Meter",1.0]]`):I.fromString(T.PE_TYPE_PROJCS,`PROJCS["${h}", ${o}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", 0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${i}],PARAMETER["Standard_Parallel_1", ${n}],PARAMETER["Latitude_of_Origin", ${s}],UNIT["Meter",1.0]]`),r}splitSegmentCrossingItegralThreshold(e,t,i){const n=100,a=400,_=z(this.m_a,this.m_eSquared,new s(0,h)),r=z(this.m_a,this.m_eSquared,new s(0,-h)),o=this.splitSegmentPassingThroughPole(e);for(let e of o){const h=e.getStartXY(),o=e.getEndXY(),m=z(this.m_a,this.m_eSquared,h),l=z(this.m_a,this.m_eSquared,o),p=new s,u=new Y;let c=Y.sqrDistance(_,m),g=Y.sqrDistance(m,l);if(c<=n){if(!(g>a)){i.push(new $({start:h,end:o}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(m.add(u.mul(20))),p.assign(L(this.m_a,this.m_eSquared,u)),i.push(new $({start:h,end:p})),h.assign(p)}if(m.assign(z(this.m_a,this.m_eSquared,h)),c=Y.sqrDistance(_,l),g=Y.sqrDistance(m,l),c<=n){if(!(g>a)){i.push(new $({start:h,end:o}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(l.sub(u.mul(20))),p.assign(L(this.m_a,this.m_eSquared,u)),i.push(new $({start:p,end:o})),o.assign(p)}if(m.assign(z(this.m_a,this.m_eSquared,h)),l.assign(z(this.m_a,this.m_eSquared,o)),c=Y.sqrDistance(r,m),g=Y.sqrDistance(m,l),c<=n){if(!(g>a)){i.push(new $({start:h,end:o}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(m.add(u.mul(20))),p.assign(L(this.m_a,this.m_eSquared,u)),i.push(new $({start:h,end:p})),h.assign(p)}if(m.assign(z(this.m_a,this.m_eSquared,h)),l.assign(z(this.m_a,this.m_eSquared,o)),c=Y.sqrDistance(r,l),g=Y.sqrDistance(m,l),c<=n){if(!(g>a)){i.push(new $({start:h,end:o}));continue}u.assign(l.sub(m)),u.normalizeThis(),u.assign(l.sub(u.mul(20))),p.assign(L(this.m_a,this.m_eSquared,u)),i.push(new $({start:p,end:o})),o.assign(p)}t.push(new $({start:h,end:o}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const i=[],n=new Y,a=new Y,_=new Y,r=new s,h=20,o=3.124139361,m=10,l=e.getStartXY(),p=e.getEndXY(),u=j(t,new D,!1);if(G.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,p.x,p.y,u,null,null,2),Math.abs(p.x-l.x)>o&&u.val>h){const e=new H(new s(0,90),l.divide(this.m_rpu),p.divide(this.m_rpu),this.m_inputGCS,2,2);let t=k(e.makeFunctor(),0,1,1e-10);if(t.second<=m&&t.first>0&&t.first<1)return n.assign(z(this.m_a,this.m_eSquared,l)),a.assign(z(this.m_a,this.m_eSquared,p)),g(n,a,t.first,_),r.assign(L(this.m_a,this.m_eSquared,_)),i.push(new $({start:l,end:r})),i.push(new $({start:r,end:p})),i;if(e.setPointDistFrom(new s(0,-90)),t=k(e.makeFunctor(),0,1,1e-10),t.second<=m&&t.first>0&&t.first<1)return n.assign(z(this.m_a,this.m_eSquared,l)),a.assign(z(this.m_a,this.m_eSquared,p)),g(n,a,t.first,_),r.assign(L(this.m_a,this.m_eSquared,_)),i.push(new $({start:l,end:r})),i.push(new $({start:r,end:p})),i}return i.push(new $({start:l,end:p})),i}catch(e){t.error=e,t.hasError=!0}finally{X(t)}}adaptiveIntegrationWithRomberg(e,t){const i=e.makeFunctor();let s=0,n=1,a=i(s),_=i(n);const r=1e-17,h=1e-14;let o=(s+n)/2,m=i(o),l=Math.abs(m-a),p=Math.abs(_-m),u=0;for(;u++<32&&(l/p<.1||p/l<.1);)l<p?(t.pe(R(5,s,o,h,r,i)),s=o,a=m):(t.pe(R(5,o,n,h,r,i)),n=o,_=m),o=(s+n)/2,m=Math.abs(i(o)),l=Math.abs(m-a),p=Math.abs(_-m);t.pe(R(5,s,n,h,r,i))}loxodromeAreaHemi(e,t,i,s,n){const a=i.clone(),_=n.clone();let r,h,o,m,l,p,u,c,g,f,P,S,A,y,x,R;return a.make_negative&&a.changeSign(),_.make_negative&&_.changeSign(),P=s-t,1===Math.abs(a.sin_phi)||1===Math.abs(_.sin_phi)?e.half_qp*P:a.sin_phi===_.sin_phi?(f=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+d(e.e*a.sin_phi))*P,f):(x=Math.log(_.sin_half_phi_pf*a.sin_half_phi_pz/(_.sin_half_phi_pz*a.sin_half_phi_pf)),R=Math.log(_.sin_half_asin_e_sin_phi_pf*a.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*a.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(l=0,r=.5*(x+_.sin_phi/_.one_m_e_2_sin_2_phi-a.sin_phi/a.one_m_e_2_sin_2_phi),h=0):(l=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/a.one_p_sin_phi)-e.e*R),r=(x-e.e*R)/e.one_m_e_2,h=(Math.log(_.one_m_e_2_sin_2_phi/a.one_m_e_2_sin_2_phi)+l/e.atanh_e_over_e)/e.one_m_e_2),o=-R*(a.atanh_esin_phi+_.atanh_esin_phi),m=1/a.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,p=E(_.one_m_sin_phi/e.one_p_e,e.e)-E(a.one_m_sin_phi/e.one_p_e,e.e),u=E(_.one_p_sin_phi/e.one_p_e,e.e)-E(a.one_p_sin_phi/e.one_p_e,e.e),c=E(a.one_m_sin_phi/-e.one_m_e,e.e)-E(_.one_m_sin_phi/-e.one_m_e,e.e),g=E(a.one_p_sin_phi/-e.one_m_e,e.e)-E(_.one_p_sin_phi/-e.one_m_e,e.e),f=.25/r*(h+o+m+l+.5*(p+u+c+g)),f+=e.half_qp,S=.5*e.one_m_e_2*a.sin_phi*(1/a.one_m_e_2_sin_2_phi+d(e.e*a.sin_phi)),A=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+d(e.e*_.sin_phi)),A<S&&(y=S,S=A,A=y),f<S&&(f=S),f>A&&(f=A),f*=P,f)}loxodromeArea(e){const t=Math.PI/180;let i=0;const n={e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN},a=ne(),_=ne();n.e=Math.sqrt(this.m_eSquared),n.one_p_e=1+n.e,n.one_m_e=1-n.e,n.one_m_e_2=1-this.m_eSquared,n.atanh_e_over_e=d(n.e),this.m_eSquared>=1?n.half_qp=1:n.half_qp=.5*(1+n.atanh_e_over_e*n.one_m_e_2),n.f=.25*Math.PI,n.z=.75*Math.PI,_.initialize(0,n.e,n.f,n.z);const r=e.getPathCount(),h=new s,o=new s,m=e.getImpl().getAttributeStreamRef(0);for(let s=0;s<r;s++){const r=e.getPathStart(s),l=e.getPathEnd(s);if(!(l-r<=1)){m.queryPoint2D(2*(l-1),h);for(let e=r;e<l;e++){m.queryPoint2D(2*e,o);const s=h.y*t,l=o.y*t;if(e===r?(a.initialize(s,n.e,n.f,n.z),a.make_negative=!1):a.assign(_),_.initialize(l,n.e,n.f,n.z),_.make_negative=!1,h.y*o.y<0){if(h.y>=90&&o.y<=-90||o.y>=90&&h.y<=-90)return Number.NaN;const e=ne();e.initialize(0,n.e,n.f,n.z),e.make_negative=!1;const r=a.atanh_sin_phi-n.e*a.atanh_esin_phi,m=_.atanh_sin_phi-n.e*_.atanh_esin_phi,l=(m*h.x-r*o.x)/(m-r);s<0?(a.make_negative=!0,i-=this.loxodromeAreaHemi(n,h.x*t,a,l*t,e),a.make_negative=!1,i+=this.loxodromeAreaHemi(n,l*t,e,o.x*t,_)):(i+=this.loxodromeAreaHemi(n,h.x*t,a,l*t,e),_.make_negative=!0,i-=this.loxodromeAreaHemi(n,l*t,e,o.x*t,_),_.make_negative=!1)}else h.y>=0?i+=this.loxodromeAreaHemi(n,h.x*t,a,o.x*t,_):(a.make_negative=!0,_.make_negative=!0,i-=this.loxodromeAreaHemi(n,h.x*t,a,o.x*t,_),a.make_negative=!1,_.make_negative=!1);h.assign(o)}}}return this.m_a*i*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===i.enumEnvelope){const t=new f;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=S(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class me{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}execute(e,i,s,n){return t(e),4===s?(new W).execute(e,i,n):new oe(i,s,n).calculate(e)}}export{me as OperatorGeodeticArea};
