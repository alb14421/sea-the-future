/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Accessor.js";import i from"../core/Error.js";import{L as n}from"./Logger.js";import{g as o}from"./MapUtils.js";import{createAbortError as s}from"../core/promiseUtils.js";import{parseWhereClause as r}from"../core/sql.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{subclass as p}from"../core/accessorSupport/decorators/subclass.js";import d from"../geometry/Extent.js";import l from"../geometry/Polygon.js";import{initializeProjection as m,project as c}from"./projectionUtils.js";import{w as h}from"./unitUtils.js";import{s as u,a as y,b as f,c as g,d as b}from"./constants2.js";import{fromJSON as w}from"../geometry/support/jsonUtils.js";import{b as T}from"./featureConversionUtils.js";import{O as I}from"./OptimizedFeature.js";import{u as N}from"./supportUtils.js";import{executeQueryStreaming as M}from"../rest/knowledgeGraphService.js";import E from"../rest/knowledgeGraph/GraphQueryStreaming.js";import D from"../rest/support/Query.js";class k{constructor(){this._featureLookup=new Map}static getInstance(){return k.instance||(k.instance=new k),k.instance}static resetInstance(){k.instance&&(k.instance=null)}deleteFromStore(e){e.forEach(e=>{this._featureLookup.delete(e)})}readFromStoreByList(e){const t=[];return e.forEach(e=>{const i=this.readFromStoreById(e);i&&t.push(i)}),t}readFromStoreById(e){return this._featureLookup.get(e)??null}writeToStore(e,t,i){const n=[];return e.forEach(e=>{if(!e?.id)return;e.properties||(e.properties=[]);let o,s=null;if(i&&e.properties[i]&&(s=T(e.properties[i])),"originId"in e&&"destinationId"in e&&(e.properties[u]=e.originId,e.properties[y]=e.destinationId),e.properties[t]=e.id,e.id&&this._featureLookup.has(e.id)&&this._featureLookup.get(e.id).attributes){const n=this._featureLookup.get(e.id),r=JSON.parse(JSON.stringify(Object.assign(n.attributes,e.properties)));i&&e.properties[i]&&(r[i]=w(e.properties[i])),o=new I(s?JSON.parse(JSON.stringify(s)):n?.geometry?JSON.parse(JSON.stringify(n.geometry)):null,r,null,e.properties[t])}else o=new I(s?JSON.parse(JSON.stringify(s)):null,e.properties,null,e.properties[t]);this._featureLookup.set(`${e.typeName?`${e.typeName}__${e.id}`:e.id}`,o),n.push(o)}),n}}let L=class extends t{constructor(e){super(e),this._processingCacheUpdatesLookup=new Map,this.knowledgeGraph=null,this.inclusionModeDefinition={generateAllSublayers:!0,namedTypeDefinitions:new Map},this.entityTypeNames=new Set,this.relationshipTypeNames=new Set,this.geographicLookup=new Map,this.sublayerCaches=new Map,this.nodeConnectionsLookup=new Map,this.relationshipConnectionsLookup=new Map,this.memberIdTypeLookup=new Map;const t=new Map;e.knowledgeGraph.dataModel.entityTypes?.forEach(i=>{i.name&&(t.set(i.name,"entity"),this._processingCacheUpdatesLookup.set(i.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.entityTypeNames.add(i.name),i.properties?.forEach(e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(i.name,{name:e.name??"",geometryType:e.geometryType})}))}),e.knowledgeGraph.dataModel.relationshipTypes?.forEach(i=>{i.name&&(t.set(i.name,"relationship"),this._processingCacheUpdatesLookup.set(i.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.relationshipTypeNames.add(i.name),i.properties?.forEach(e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(i.name,{name:e.name??"",geometryType:e.geometryType})}))}),e.inclusionModeDefinition?.namedTypeDefinitions.forEach((i,s)=>{if("entity"===t.get(s))this.entityTypeNames.add(s);else{if("relationship"!==t.get(s))return n.getLogger(this).warn(`A named type, ${s}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(s);this.relationshipTypeNames.add(s)}const r=new Map;i.members?.forEach(e=>{o(this.memberIdTypeLookup,e.id,()=>new Set).add(s);const t=this.getById(e.id);t&&r.set(e.id,t)}),this.sublayerCaches.set(s,r)})}addToLayer(e){e.forEach(({typeName:e,id:t})=>{if(!this.inclusionModeDefinition)throw new i("knowledge-graph:layer-data-manager","You cannot add to a layer's exclusion list if it was not created with an exclusion list originally");if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){const i=this.inclusionModeDefinition.namedTypeDefinitions.get(e);i.members||(i.members=new Map),i.members.set(t,{id:t}),o(this.memberIdTypeLookup,t,()=>new Set).add(e)}}else{const i=new Map;i.set(t,{id:t}),this.inclusionModeDefinition.namedTypeDefinitions.set(e,{useAllData:!1,members:i}),o(this.memberIdTypeLookup,t,()=>new Set).add(e)}})}getById(e){return k.getInstance().readFromStoreById(e)}async getData(e,t,i){if(t.objectType.name&&this.inclusionModeDefinition?.namedTypeDefinitions&&this.inclusionModeDefinition.namedTypeDefinitions.size>0&&!this.inclusionModeDefinition.namedTypeDefinitions.has(t.objectType.name))return[];let n;if(n=e||new D({where:"1=1",outFields:["*"]}),"link-chart"===t.parentCompositeLayer.type){const e=t.parentCompositeLayer,i=this._processingCacheUpdatesLookup.get(t.objectType.name??""),o=n.outFields;o&&1===o.length&&o[0]===f&&"1=1"===n.where||await Promise.all(i??[]);const s=this.sublayerCaches.has(t.objectType.name??"")?Array.from(this.sublayerCaches.get(t.objectType.name)?.values()):[],r=[];return s.forEach(i=>{if(this.relationshipTypeNames.has(t.objectType.name)){i.geometry=e.relationshipLinkChartDiagramLookup.get(i.attributes[t.objectIdField]);const n=this.memberIdTypeLookup.get(i.attributes[u]),o=this.memberIdTypeLookup.get(i.attributes[y]),s=this._isEndEntitySpatial(n,i,u),r=this._isEndEntitySpatial(o,i,y);i.attributes[g]=Number(s&&r)}else{i.geometry=e.entityLinkChartDiagramLookup.get(i.attributes[t.objectIdField]);const n=this.geographicLookup.get(t.objectType.name);n&&i.attributes[n.name]?i.attributes[g]=1:i.attributes[g]=0}i.attributes[b]=i.geometry,r.push(i)}),r}return this.retrieveDataFromService(n,t,i)}async getConnectedRecordIds(e,t,i){const n=[];let o="";const s=this._getNamedTypeIdMapFromNodeIds(e);if(t&&0!==t?.length){for(const e of t)o=o+e+"|";o=o.slice(0,-1)}const r={},a=[];for(const[e,i]of s){const n=`${e}_ids`;r[n]=i,t&&0!==t?.length?a.push(`MATCH (n:${e}) WHERE id(n) IN $${n} WITH n MATCH (n)-[r:${o}]-(m) RETURN id(r), type(r), id(m), labels(m)[0]`):a.push(`MATCH (n:${e}) WHERE id(n) IN $${n} WITH n MATCH (n)-[r]-(m) RETURN id(r), type(r), id(m), labels(m)[0]`)}if(!a.length)return n;const p=a.join(" UNION "),d=(await M(this.knowledgeGraph,new E({openCypherQuery:p,bindParameters:r}),{signal:i?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await d.read();if(e)break;for(let e=0;e<t.length;e++){const i=t[e];n.push({id:i[0],typeName:i[1]}),n.push({id:i[2],typeName:i[3]})}}return n}async getRelationshipsBetweenNodes(e,t,i){const n=this._getNamedTypeIdMapFromNodeIds(e);if(0===n.size)return[];const o={relationshipExclusionIds:t,possibleConnectionEntityIds:e},s=[];for(const[e,t]of n.entries()){const i=`${e}_ids`;o[i]=t,s.push(`MATCH (n:${e}) WHERE id(n) IN $${i} WITH n MATCH (n)-[r]->(m) WHERE id(m) IN $possibleConnectionEntityIds AND NOT id(r) IN $relationshipExclusionIds RETURN id(r), type(r)`)}const r=s.join(" UNION "),a=[],p=(await M(this.knowledgeGraph,new E({openCypherQuery:r,bindParameters:o}),{signal:i?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await p.read();if(e)break;for(let e=0;e<t.length;e++){const i=t[e];a.push({id:i[0],typeName:i[1]})}}return a}async getRelationshipsFromNodes(e,t,i,n){const o=this._getNamedTypeIdMapFromNodeIds(e);if(0===o.size||0===t.length)return[];const s={relationshipExclusionIds:i,possibleConnectionEntityIds:t},r=[];for(const[e,t]of o.entries()){const i=`${e}_ids`;s[i]=t,r.push(`MATCH (n:${e}) WHERE id(n) IN $${i} WITH n MATCH (n)-[r]-(m) WHERE id(m) IN $possibleConnectionEntityIds AND NOT id(r) IN $relationshipExclusionIds RETURN id(r), type(r)`)}const a=r.join(" UNION "),p=new Map,d=(await M(this.knowledgeGraph,new E({openCypherQuery:a,bindParameters:s}),{signal:n?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await d.read();if(e)break;for(let e=0;e<t.length;e++){const i=t[e];let n=p.get(i[1]);n||(n=new Set,p.set(i[1],n)),n.add(i[0])}}const l=[];for(const[e,t]of p)for(const i of t)l.push({id:i,typeName:e});return l}async refreshCacheContent(e,t,n,r=!0,a){const p=k.getInstance(),d=[],l=new Map,m=new Map;this.knowledgeGraph.dataModel.entityTypes?.forEach(e=>{e.name&&m.set(e.name,e)}),this.knowledgeGraph.dataModel.relationshipTypes?.forEach(e=>{e.name&&m.set(e.name,e)}),e||this.inclusionModeDefinition?e?e.forEach(e=>{if(this.memberIdTypeLookup.has(e))for(const t of this.memberIdTypeLookup.get(e))l.has(t)?l.get(t)?.push(e):l.set(t,[e])}):this.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e,t)=>{e.useAllData?l.set(t,null):e.members&&e.members.forEach(e=>{l.has(t)&&null!==l.get(t)?l.get(t)?.push(e.id):l.set(t,[e.id])})}):(this.knowledgeGraph.dataModel.entityTypes?.forEach(e=>{e.name&&l.set(e.name,null)}),this.knowledgeGraph.dataModel.entityTypes?.forEach(e=>{e.name&&l.set(e.name,null)}));for(const[e,s]of l){const l=new Set(s),c=new Promise((d,c)=>{(async()=>{const d=new Set,c=[];let h,u="",y=!1;if(t||m.get(e)?.properties?.forEach(e=>{e.name&&d.add(e.name)}),n&&this.geographicLookup.has(e)){const t=this.geographicLookup.get(e)?.name;t&&d.add(t)}if(this.entityTypeNames.has(e))u=`MATCH (n:${e}) ${s?"WHERE id(n) IN $ids ":""}return ID(n)`,d.forEach(e=>{u+=`, n.${e}`,c.push(e)});else{if(!this.relationshipTypeNames.has(e))throw new i("knowledge-graph:layer-data-manager",`The graph type of ${e} could not be determined. Was this type set in the KG data model and inclusion definition?`);y=!0,u=`MATCH ()-[n:${e}]->() ${s?"WHERE id(n) IN $ids ":""}return ID(n), id(startNode(n)), id(endNode(n))`,d.forEach(e=>{u+=`, n.${e}`,c.push(e)})}h=new E(s?{openCypherQuery:u,bindParameters:{ids:s}}:{openCypherQuery:u});const g=(await M(this.knowledgeGraph,h,{signal:a?.signal})).resultRowsStream.getReader();for(;;){const{done:t,value:i}=await g.read();if(t)break;const n=[];for(let e=0;e<i.length;e++){const t=i[e];let s=0,r=0;const a={properties:{}};for(a.id=t[s],s++,r++,y&&(a.originId=t[s],s++,r++,a.destinationId=t[s],s++,r++,o(this.nodeConnectionsLookup,a.originId,()=>new Set).add(a.id),o(this.nodeConnectionsLookup,a.destinationId,()=>new Set).add(a.id),o(this.relationshipConnectionsLookup,a.id,()=>[a.originId,a.destinationId]));s<t.length;s++)a.properties[c[s-r]]=t[s];l.delete(a.id),n.push(a)}const s=p.writeToStore(n,f,this.geographicLookup.get(e)?.name);this.sublayerCaches.has(e)||this.sublayerCaches.set(e,new Map),r&&!this.inclusionModeDefinition?.namedTypeDefinitions.has(e)&&this.inclusionModeDefinition?.namedTypeDefinitions.set(e,{useAllData:!1,members:new Map}),r&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(e).members&&(this.inclusionModeDefinition.namedTypeDefinitions.get(e).members=new Map);const a=this.sublayerCaches.get(e);s.forEach(t=>{a?.set(t.attributes[f],t),r&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(e).members.has(t.attributes[f])&&(this.inclusionModeDefinition?.namedTypeDefinitions.get(e).members.set(t.attributes[f],{id:t.attributes[f]}),o(this.memberIdTypeLookup,t.attributes[f],()=>new Set).add(e))})}const b=this.inclusionModeDefinition?.namedTypeDefinitions.get(e);if(b)for(const e of l)b.members?.delete(e)})().then(()=>{d(null)}).catch(e=>{"AbortError"===e.name?d(null):c(e)})});d.push(c),this._processingCacheUpdatesLookup.get(e)?.push(c)}if(await Promise.all(d),a?.signal?.aborted)throw s()}removeFromLayer(e){const t=new Set,i=new Set(e.map(e=>e.id));for(const i of e)t.add(i.typeName),1===this.memberIdTypeLookup.get(i.id)?.size?this.memberIdTypeLookup.delete(i.id):this.memberIdTypeLookup.get(i.id)?.delete(i.typeName),this.inclusionModeDefinition?.namedTypeDefinitions.forEach((e,t)=>{t===i.typeName&&e.members?.has(i.id)&&e.members.delete(i.id)});t.forEach(e=>{this.sublayerCaches.get(e)?.forEach((t,n)=>{i.has(n)&&this.sublayerCaches.get(e)?.delete(n)})})}async retrieveDataFromService(e,t,n){const o=k.getInstance(),s=new Set,a=[];let p,u="",y=[];const g="relationship"===t.graphType,b=this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData,w=t.parentCompositeLayer.sublayerIdsCache.get(t.objectType.name);let T=!b&&w?Array.from(w).sort():null;if(this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData)this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData&&null!=e.objectIds&&(T=e.objectIds);else if(null!=e.objectIds&&T&&T.length>0){const t=e.objectIds;e.objectIds=T.filter(e=>t.includes(e))}else if(null!=e.objectIds)T=e.objectIds;else{if(this.inclusionModeDefinition?.namedTypeDefinitions.has(t.objectType.name)&&(!this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members||this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members?.size<1))return e.objectIds=[],[];e.objectIds=T}if(null!=e.outFields){const i=e.outFields;i.includes("*")?t.fields.forEach(e=>{s.add(e.name)}):i.forEach(e=>{e!==f&&e!==t.geometryFieldName&&s.add(e)})}if(null!=e.geometry){const n=e.geometry;let o;const y=t.parentCompositeLayer.dataManager.knowledgeGraph.serviceDefinition,f=y?.spatialReference,b=y?.serviceCapabilities?.geometryCapabilities;let w=b?.geometryMaxBoundingRectangleSizeX,T=b?.geometryMaxBoundingRectangleSizeY;if("point"===n.type){let e=n;e.spatialReference?.isWGS84||(await m(e.spatialReference,h),e=c(e,h)),o=new d({spatialReference:h,xmin:e.x-1e-4,ymin:e.y-1e-4,xmax:e.x+1e-4,ymax:e.y+1e-4})}else n?.extent?.spatialReference&&!n.spatialReference?.isWGS84?(await m(n.extent.spatialReference,h),o=c(n.extent,h)):o=n.extent;if(w&&T&&f){if(4326!==f.wkid){const e=new d({spatialReference:f,xmax:w,ymax:T}),t=c(e,h);w=t.xmax,T=t.ymax}if(o.xmax-o.xmin>w)throw new i("knowledge-graph:layer-data-manager",`Extent x bounds should be within ${w}° latitude, limit exceeded`);if(o.ymax-o.ymin>T)throw new i("knowledge-graph:layer-data-manager",`Extent y bounds should be within ${T}° longitude, limit exceeded`)}if(null!=e.where&&"1=1"!==e.where){const i=await r(e.where.toUpperCase(),t.fieldsIndex);t.fields.forEach(e=>{i.fieldNames.includes(e.name)&&s.add(e.name)})}u=g?`Match ()-[n:${t.objectType.name}]->() WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n), id(startNode(r)), id(endNode(r))`:`Match (n:${t.objectType.name}) WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n)`,t.geometryFieldName&&s.add(t.geometryFieldName),s.forEach(e=>{u+=`, n.${e}`,a.push(e)}),p=new E({openCypherQuery:u,bindParameters:{param_filter_geom:new l({rings:N(o)})}})}else{let i="";if(null!=e.where&&"1=1"!==e.where){const n=await r(e.where,t.fieldsIndex);t.fields.forEach(e=>{n.fieldNames.includes(e.name)&&s.add(e.name)});const o=new Set(["column-reference","string","number","binary-expression"]),a=new Set(["=","<","<=","<>",">",">=","AND","OR","LIKE"]);let p=!1;const d=e=>{if("column-reference"===e.type)return`n.${e.column}`;if("string"===e.type)return`'${e.value}'`;if("number"===e.type)return`${e.value}`;if("binary-expression"===e.type&&o.has(e.left.type)&&o.has(e.right.type)&&a.has(e.operator))return`${d(e.left)} ${e.operator} ${d(e.right)}`;if("binary-expression"===e.type&&"LIKE"===e.operator){let t="";if("function"===e.left.type&&"column-reference"===e.left.args.value[0].type)t+=`lower(n.${e.left.args.value[0].column})`;else{if("column-reference"!==e.left.type)return p=!0,"";t+=`lower(n.${e.left.column})`}if(t+=" CONTAINS (","string"!==e.right.type)return p=!0,"";{let i=e.right.value;i.startsWith("%")&&(i=i.slice(1)),i.endsWith("%")&&(i=i.slice(0,-1)),t+=`'${i.toLowerCase()}')`}return t}return p=!0,""};i=d(n.parseTree),p&&(i="")}let n="";n=g?`Match ()-[n:${t.objectType.name}]->()`:`Match (n:${t.objectType.name})`;let o=!1;T&&(o=!0,n+=" WHERE ID(n) IN $ids"),i&&(n+=o?" AND":" WHERE",n+=` ${i}`),n+=" return ID(n)",g&&(n+=", id(startNode(n)), id(endNode(n))"),e.returnGeometry&&t.geometryFieldName&&s.add(t.geometryFieldName),s.forEach(e=>{n+=`, n.${e}`,a.push(e)}),p=new E(T?{openCypherQuery:n,bindParameters:{ids:T}}:{openCypherQuery:n})}const I=(await M(t.parentCompositeLayer.dataManager.knowledgeGraph,p,n)).resultRowsStream.getReader();for(;;){const{done:e,value:i}=await I.read();if(e)break;const n=[];for(let e=0;e<i.length;e++){const t=i[e];let o=0,s=0;const r={properties:{}};for(r.id=t[o],o++,s++,g&&(r.originId=t[o],o++,s++,r.destinationId=t[o],o++,s++);o<t.length;o++)r.properties[a[o-s]]=t[o];n.push(r)}y=y.concat(o.writeToStore(n,f,t.parentCompositeLayer.dataManager.geographicLookup.get(t.objectType.name)?.name))}return y}_isEndEntitySpatial(e,t,i){for(const n of e??[])if(this.entityTypeNames.has(n)){const e=this.geographicLookup.get(n),o=e&&this.sublayerCaches.get(n)?.get(t.attributes[i]);if(e&&o?.attributes[e.name])return!0}return!1}_getNamedTypeIdMapFromNodeIds(e){const t=new Map;return e.forEach(e=>{if(this.memberIdTypeLookup.has(e))for(const i of this.memberIdTypeLookup.get(e)){if(!this.entityTypeNames.has(i))return;t.has(i)?t.get(i)?.push(e):t.set(i,[e])}}),t}};e([a()],L.prototype,"knowledgeGraph",void 0),e([a()],L.prototype,"inclusionModeDefinition",void 0),e([a()],L.prototype,"entityTypeNames",void 0),e([a()],L.prototype,"relationshipTypeNames",void 0),e([a()],L.prototype,"geographicLookup",void 0),e([a()],L.prototype,"sublayerCaches",void 0),e([a()],L.prototype,"nodeConnectionsLookup",void 0),e([a()],L.prototype,"relationshipConnectionsLookup",void 0),e([a()],L.prototype,"memberIdTypeLookup",void 0),L=e([p("esri.layers.knowledgeGraph.KnowledgeGraphLayerDataManager")],L);export{L as K,k as S};
