/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{l as e,k as t,t as r}from"./vec3.js";import{a as s,i}from"./projectBuffer.js";import{p as n,x as o}from"./unitUtils.js";import{_ as a}from"./tslib.es6.js";import{EventedAccessor as c}from"../core/Evented.js";import{L as l}from"./Logger.js";import{property as p}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import{subclass as u}from"../core/accessorSupport/decorators/subclass.js";import{j as m}from"./mat4.js";import{c as f}from"./mat4f64.js";import{c as h}from"./vec3f64.js";import{p as d}from"./projectBoundingSphere.js";import{e as v,a as E}from"./aaBoundingRect.js";import{f as _}from"./sphere.js";import{E as g}from"../views/SceneView.js";import{E as x}from"./TextureCompressionTracker.js";import{I as j}from"./Intersector2.js";function R(t,r,a,c){const l=s(r,c);if(null==l)return!1;const p=l.source.spatialReferenceId,u=l.dest.spatialReferenceId;if(p===u&&0!==p||n(r,c))return a[0]=1,a[1]=1,a[2]=1,!0;if(1===p){const r=e(t),s=r/Math.sqrt(t[0]*t[0]+t[1]*t[1]),n=r/o.radius;if(3===u)return a[0]=s*n,a[1]=s*n,a[2]=1,!0;if(2===u||5===u){const e=i;return a[0]=e*s*n,a[1]=e*n,a[2]=1,!0}}else if(11===p){if(2===u||5===u)return a[0]=i,a[1]=i,a[2]=1,!0;if(3===u){const e=t[1]/o.radius;return a[0]=1,a[1]=1/Math.cos(e),a[2]=1,!0}}return!1}let y=class extends c{constructor(e){super(e),this._tmpEvent=new x,this._renderCoordsHelper=e.view.renderCoordsHelper,this._renderSR=this._renderCoordsHelper.spatialReference,this._layerElevationSource=e.layerElevationSource}initialize(){this._intersector=new j(this.view.state.viewingMode),this._intersector.options.store=0,this._intersector.options.normalRequired=!1,this._tmpEvent.context=this.intersectionHandler.isGround?"ground":"scene"}get spatialReference(){return this.view?.elevationProvider?.spatialReference}getElevation(e,r,s,i){const n=this._renderCoordsHelper,o=t(w,e,r,s);if(!n.toRenderCoords(o,i,o))return l.getLogger(this).error("could not project point to compute elevation"),null;const{layerElevationSource:a,_intersector:c,intersectionHandler:p}=this,u=a.fullExtent,m=null!=u&&Number.isFinite(u.xmin)&&Number.isFinite(u.xmax)&&Number.isFinite(u.ymin)&&Number.isFinite(u.ymax)&&Number.isFinite(u.zmin)&&Number.isFinite(u.zmax)?new g(u.zmin,u.zmax):a.elevationRange;if(null==m)return null;const f=a.elevationOffset,h=m.elevationRangeMin+f,d=m.elevationRangeMax+f,v=n.setAltitude(C,d,o),E=n.setAltitude(z,h,o);return c.reset(v,E,this.view.state.camera),p.intersect(c,null,v,E,null,!0),c.results.min.getIntersectionPoint(o)?n.getAltitude(o):null}getSphereElevationBounds(e,t){return d(e,t,b,this._renderSR),this._layerElevationSource.getElevationRange(b)}getRootElevationBounds(){const e=this.layerElevationSource.fullExtent;return e?.hasZ?new g(e.zmin,e.zmax):null}objectsChanged(e){this.spatialReference&&(this._computeLayerExtent(e,this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}objectChanged(e){this.spatialReference&&(this._computeObjectExtent(e,this._tmpEvent.extent),this._tmpEvent.spatialReference=this.spatialReference,this.emit("elevation-change",this._tmpEvent))}_computeObjectExtent(e,t){v(t),this._expandExtent(e,t)}_computeLayerExtent(e,t){v(t);for(const r of e)this._expandExtent(r,t)}_expandExtent(e,t){const s=this.spatialReference;if(null==s)return;if(null==e)return;m(S,e.quaternion),S[12]=e.center[0],S[13]=e.center[1],S[14]=e.center[2];const i=e.halfSize;for(let e=0;e<8;++e)w[0]=1&e?i[0]:-i[0],w[1]=2&e?i[1]:-i[1],w[2]=4&e?i[2]:-i[2],r(w,w,S),this._renderCoordsHelper.fromRenderCoords(w,w,s),E(t,w,t)}};a([p({constructOnly:!0})],y.prototype,"layerElevationSource",void 0),a([p({constructOnly:!0})],y.prototype,"intersectionHandler",void 0),a([p({constructOnly:!0})],y.prototype,"view",void 0),a([p()],y.prototype,"spatialReference",null),y=a([u("esri.views.3d.layers.i3s.LayerElevationProvider")],y);const S=f(),b=_(0,0,0,0),w=h(),C=h(),z=h();class H{constructor(e,t,r,s){this.toMapSpace=e,this.transform=t,this.obb=r,this.geometry=s}}class L{constructor(e,t){this.position=e,this.rotationScale=t,this.origin=void 0}}export{y as L,H as O,L as T,R as l};
