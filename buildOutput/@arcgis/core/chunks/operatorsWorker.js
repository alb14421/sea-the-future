/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{fromJSON as e}from"../geometry/support/jsonUtils.js";import"../geometry/Extent.js";import"./tslib.es6.js";import"./string.js";import"./object.js";import"../core/lang.js";import"../core/accessorSupport/decorators/property.js";import"./Logger.js";import"../config.js";import"./ensureType.js";import"./MapUtils.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./tracking.js";import"./Warning.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"./ObjectPool.js";import"./ObservableBase.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./events.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"./persistableUrlUtils.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"../geometry/Polyline.js";function t(e,t){let r;return{loaded:!1,load:()=>r??=t().then(t=>{o[e]={loaded:!0,execute:t}})}}function r(e){return null==e?null:e.toJSON()}const o={disjoint:t("disjoint",()=>import("./disjointOperator.js").then(e=>e.execute)),intersects:t("intersects",()=>import("./intersectsOperator.js").then(e=>e.execute)),touches:t("touches",()=>import("./touchesOperator.js").then(e=>e.execute)),crosses:t("crosses",()=>import("./crossesOperator.js").then(e=>e.execute)),within:t("within",()=>import("./withinOperator.js").then(e=>e.execute)),contains:t("contains",()=>import("./containsOperator.js").then(e=>e.execute)),overlaps:t("overlaps",()=>import("./overlapsOperator.js").then(e=>e.execute)),equals:t("equals",async()=>{const t=await import("../geometry/operators/equalsOperator.js").then(e=>e.e);return(r,o)=>t.execute(e(r),e(o))}),relate:t("relate",async()=>{const t=await import("../geometry/operators/relateOperator.js").then(e=>e.r);return(r,o,i)=>t.execute(e(r),e(o),i)}),intersection:t("intersection",()=>import("./intersectionOperator.js").then(e=>e.execute)),union:t("union",()=>import("./unionOperator.js").then(e=>e.executeMany)),difference:t("difference",async()=>{const t=await import("../geometry/operators/differenceOperator.js").then(e=>e.d);return(o,i)=>r(t.execute(e(o),e(i)))}),symmetricDifference:t("symmetricDifference",async()=>{const t=await import("../geometry/operators/symmetricDifferenceOperator.js").then(e=>e.s);return(o,i)=>r(t.execute(e(o),e(i)))}),clip:t("clip",async()=>{const t=await import("../geometry/operators/clipOperator.js").then(e=>e.c);return(o,i)=>r(t.execute(e(o),e(i)))}),cut:t("cut",async()=>{const t=await import("../geometry/operators/cutOperator.js").then(e=>e.c);return(o,i)=>t.execute(e(o),e(i)).map(e=>r(e))}),area:t("area",async()=>{const t=await import("../geometry/operators/areaOperator.js").then(e=>e.a),{convertFromSpatialReferenceUnit:r,toAreaUnit:o}=await import("./unitConversion.js");return(i,s)=>{const n=t.execute(e(i));return r(i.spatialReference,o(s),n)}}),geodeticArea:t("geodeticArea",async()=>{const t=await import("../geometry/operators/geodeticAreaOperator.js").then(e=>e.g),{convert:r,squareMeters:o,toAreaUnit:i}=await import("./unitConversion.js");return await t.load(),(s,n,a)=>{const p=t.execute(e(s),{curveType:a});return r(o,i(n),p)}}),length:t("length",async()=>{const e=await import("./lengthOperator.js"),{convertFromSpatialReferenceUnit:t,toLengthUnit:r}=await import("./unitConversion.js");return(o,i)=>{const s=e.execute(o);return t(o.spatialReference,r(i),s)}}),geodeticLength:t("geodeticLength",async()=>{const t=await import("../geometry/operators/geodeticLengthOperator.js").then(e=>e.g),{convert:r,meters:o,toLengthUnit:i}=await import("./unitConversion.js");return await t.load(),(s,n,a)=>{const p=t.execute(e(s),{curveType:a});return r(o,i(n),p)}}),distance:t("distance",async()=>{const t=await import("../geometry/operators/distanceOperator.js").then(e=>e.d),{convertFromSpatialReferenceUnit:r,toLengthUnit:o}=await import("./unitConversion.js");return(i,s,n)=>{const a=t.execute(e(i),e(s));return r(i.spatialReference,o(n),a)}}),densify:t("densify",async()=>{const t=await import("../geometry/operators/densifyOperator.js").then(e=>e.d),{convertToSpatialReferenceUnit:o,toLengthUnit:i}=await import("./unitConversion.js");return(s,n,a)=>(n=o(i(a),s.spatialReference,n),r(t.execute(e(s),n)))}),geodeticDensify:t("geodeticDensify",async()=>{const t=await import("../geometry/operators/geodeticDensifyOperator.js").then(e=>e.g),{convert:o,meters:i,toLengthUnit:s}=await import("./unitConversion.js");return await t.load(),(n,a,p,c)=>(a=o(s(p),i,a),r(t.execute(e(n),a,{curveType:c})))}),generalize:t("generalize",async()=>{const t=await import("../geometry/operators/generalizeOperator.js").then(e=>e.g),{convertToSpatialReferenceUnit:o,toLengthUnit:i}=await import("./unitConversion.js");return(s,n,a,p)=>(n=o(i(a),s.spatialReference,n),r(t.execute(e(s),n,p)))}),buffer:t("buffer",async()=>{const e=await import("./bufferOperator.js"),{convertToSpatialReferenceUnit:t,toLengthUnit:r}=await import("./unitConversion.js");return(o,i,s)=>(i=t(r(s),o.spatialReference,i),e.execute(o,i))}),geodesicBuffer:t("geodesicBuffer",async()=>{const e=await import("./geodesicBufferOperator.js"),{convert:t,meters:r,toLengthUnit:o}=await import("./unitConversion.js");return await e.load(),(i,s,n,a)=>(s=t(o(n),r,s),e.execute(i,s,{curveType:a}))}),offset:t("offset",async()=>{const e=await import("./offsetOperator.js"),{convertToSpatialReferenceUnit:t,toLengthUnit:r}=await import("./unitConversion.js");return(o,i,s,n)=>(i=t(r(s),o.spatialReference,i),e.execute(o,i,n))}),rotate:t("rotate",async()=>{const t=await import("../geometry/operators/affineTransformOperator.js"),{default:o}=await import("../geometry/operators/support/Transformation.js");return(i,s,n,a)=>{const p=(new o).rotate(s,n,a);return r(t.execute(e(i),p))}}),centroid:t("centroid",async()=>{const t=await import("../geometry/operators/centroidOperator.js").then(e=>e.c);return o=>r(t.execute(e(o)))}),labelPoint:t("labelPoint",async()=>{const t=await import("../geometry/operators/labelPointOperator.js").then(e=>e.l);return o=>r(t.execute(e(o)))}),simplify:t("simplify",()=>import("./simplifyOperator.js").then(e=>e.execute)),isSelfIntersecting:t("isSelfIntersecting",async()=>{const{NonSimpleResult:t}=await import("./OperatorDefinitions.js"),r=await import("../geometry/operators/simplifyOGCOperator.js"),o=new Set([5,6,7,10,11,12]);return i=>{const s=new t;return!r.isSimple(e(i),s)&&o.has(s.m_reason)}}),isSimple:t("isSimple",()=>import("./simplifyOperator.js").then(e=>e.isSimple)),convexHull:t("convexHull",()=>import("./convexHullOperator.js").then(e=>e.execute)),getNearestCoordinate:t("getNearestCoordinate",async()=>{const t=await import("../geometry/operators/proximityOperator.js").then(e=>e.p);return(o,i,s)=>{const n=t.getNearestCoordinate(e(o),e(i),s);return{...n,coordinate:r(n.coordinate)}}}),getNearestVertex:t("getNearestVertex",async()=>{const t=await import("../geometry/operators/proximityOperator.js").then(e=>e.p);return(o,i)=>{const s=t.getNearestVertex(e(o),e(i));return{...s,coordinate:r(s.coordinate)}}})};function i(e,t){const r=o[e];return r.loaded?r.execute.apply(void 0,t):r.load().then(()=>i(e,t))}export{i as invokeGeometryOp};
