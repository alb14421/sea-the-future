/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{b as e,c as t,h as s,d as r,e as i,B as n,a,f as u,g as h,i as d,j as o,k as f,l as c,n as l,o as p,p as _,q as m,s as F,t as y,u as w,v as E,w as g,x as b,y as v,z as T,A,C as L,D as N,E as B,F as M,G as j,H as I,I as U,J as x,K as C,L as D,M as z,N as G,O,P as S,Q as V,R as H}from"./BufferView.js";import{e as k}from"./types.js";import"../core/lang.js";import{D as R}from"./enums.js";import{V as $}from"./VertexElementDescriptor.js";import{b as P}from"./VertexAttributeLocations.js";function Y(e,t=0){const s=e.stride;return Array.from(e.fields.keys()).map(r=>{const i=e.fields.get(r),n=i.constructor.ElementCount,a=function(e){switch(e){case"u8":return R.UNSIGNED_BYTE;case"u16":return R.UNSIGNED_SHORT;case"u32":return R.UNSIGNED_INT;case"i8":return R.BYTE;case"i16":return R.SHORT;case"i32":return R.INT;case"f16":return R.HALF_FLOAT;case"f32":return R.FLOAT;default:throw new Error("BufferType not supported in WebGL")}}(i.constructor.ElementType),u=i.offset,h=i.optional?.glNormalized??!1;return new $(r,n,a,u,s,h,t)})}class q{constructor(e,t){this.layout=e,this.buffer="number"==typeof t?new ArrayBuffer(t*e.stride):t;for(const t of e.fields.keys()){const s=e.fields.get(t);this[t]=new s.constructor(this.buffer,s.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(e,t){const s=this[e];return s&&s.elementCount===t.ElementCount&&s.elementType===t.ElementType?s:null}slice(e,t){return new q(this.layout,this.buffer.slice(e*this.stride,t*this.stride))}copyFrom(e,t=0,s=0,r=e.count){const i=this.stride;if(i%4==0){const n=new Uint32Array(e.buffer,t*i,r*i/4);new Uint32Array(this.buffer,s*i,r*i/4).set(n)}else{const n=new Uint8Array(e.buffer,t*i,r*i);new Uint8Array(this.buffer,s*i,r*i).set(n)}return this}get cachedMemory(){return this.byteLength}dispose(){}}class J{constructor(e){this._stride=0,this._fields=new Map,e&&(this._stride=e.stride,e.fields.forEach(e=>{return this._fields.set(e[0],{...e[1],constructor:(t=e[1].constructor,Z.get(t))});var t}))}freeze(){return this}get locations(){return P(Y(this))}vec2f16(r,i){return this._appendField(r,s?e:t,i),this}vec2f(e,s){return this._appendField(e,t,s),this}vec2f64(e,t){return this._appendField(e,r,t),this}vec3f16(e,t){return this._appendField(e,s?i:n,t),this}vec3f(e,t){return this._appendField(e,n,t),this}vec3f64(e,t){return this._appendField(e,a,t),this}vec4f16(e,t){return this._appendField(e,s?u:h,t),this}vec4f(e,t){return this._appendField(e,h,t),this}vec4f64(e,t){return this._appendField(e,d,t),this}mat3f(e,t){return this._appendField(e,o,t),this}mat3f64(e,t){return this._appendField(e,f,t),this}mat4f(e,t){return this._appendField(e,c,t),this}mat4f64(e,t){return this._appendField(e,l,t),this}vec4u8(e,t){return this._appendField(e,p,t),this}f16(e,t){return this._appendField(e,s?_:m,t),this}f32(e,t){return this._appendField(e,m,t),this}f64(e,t){return this._appendField(e,F,t),this}u8(e,t){return this._appendField(e,y,t),this}u16(e,t){return this._appendField(e,w,t),this}i8(e,t){return this._appendField(e,E,t),this}vec2i8(e,t){return this._appendField(e,g,t),this}vec2i16(e,t){return this._appendField(e,b,t),this}vec2u8(e,t){return this._appendField(e,v,t),this}vec2u16(e,t){return this._appendField(e,T,t),this}vec4u16(e,t){return this._appendField(e,A,t),this}u32(e,t){return this._appendField(e,L,t),this}_appendField(e,t,s){this._fields.has(e)&&N(!1,`${e} already added to vertex buffer layout`);const r=t.ElementCount*k(t.ElementType),i=this._stride;this._fields.set(e,{constructor:t,size:r,offset:i,optional:s}),this._alignFields()}_alignFields(){let e=0,t=1;this._fields.forEach(s=>{const r=k(s.constructor.ElementType);e=Math.floor((e+r-1)/r)*r,s.offset=e,e+=s.size,t=Math.max(t,r)}),e=Math.floor((e+t-1)/t)*t,this._stride=e}createBuffer(e){return new q(this,e)}createView(e){return new q(this,e)}clone(){const e=new J;return e._stride=this._stride,e._fields=new Map,this._fields.forEach((t,s)=>e._fields.set(s,t)),e.BufferType=this.BufferType,e}get stride(){return this._stride}get fields(){return this._fields}}function K(){return new J}class Q{constructor(e){this.fields=new Array,e.fields.forEach((e,t)=>{const s={...e,constructor:X(e.constructor)};this.fields.push([t,s])}),this.stride=e.stride}}const W=[m,t,n,h,o,c,F,r,a,d,f,l,y,v,B,p,w,T,M,A,L,j,I,U,E,g,x,C,D,b,z,G,O,S,V,H];function X(e){return`${e.ElementType}_${e.ElementCount}`}const Z=new Map;W.forEach(e=>Z.set(X(e),e));export{J as I,Q as P,Y as g,K as n};
