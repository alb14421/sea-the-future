/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clone as t,i as n}from"../core/lang.js";import{c as e}from"./mathUtils.js";import{c as r}from"./screenUtils.js";import{project as a}from"./projectionUtils.js";import{a as l}from"./meshVertexSpaceUtils.js";import{h as s,c as o}from"./hydratedFeatures.js";import{b as c}from"./elevationInfoUtils.js";import{E as u}from"./EditGeometryOperations.js";function i(t,n){return t.events.on("drag",function(t,n){let e=null,r=null;return a=>{if("cancel"===a.action)return void(null!=r&&(r.execute({action:"cancel"}),e=null,r=null));const l={action:a.action,screenStart:a.start,screenEnd:a.screenPoint};"start"===a.action&&null==e&&(e=new M,r=new M,n(t,e,r,a.pointerType,l)),null!=e&&e.execute(l),"end"===a.action&&null!=e&&(e=null,r=null)}}(t,n))}function p(t,n){const e=[t.x,t.y,t.z??0],r=n,a=[Math.cos(r),Math.sin(r)],l=Math.sqrt(a[0]*a[0]+a[1]*a[1]);if(0===l)return null;a[0]/=l,a[1]/=l;const s=t=>{const n=(t.x-e[0])*a[0]+(t.y-e[1])*a[1];t.x=e[0]+n*a[0],t.y=e[1]+n*a[1]};return t=>(s(t.mapStart),s(t.mapEnd),{...t,axis:a})}function m(t){let n=null;return e=>{if("start"===e.action&&(n=function(t,n){const e=t.operations;if(!e)return null;const r=e.data.geometry,o=s(n);if(r.spatialReference.equals(o))return d(t,e,()=>{});if("mesh"!==r.type){const n=f(r,o);if(null==n)return null;const l=r.spatialReference;return d(t,u.fromGeometry(n,e.viewingMode),()=>{const t=a(r,l);e.trySetGeometry(t)})}if(l(r)){const n=f(r.origin,o);if(!n)return null;const l=r.spatialReference,s=u.fromGeometry(n,e.viewingMode);return d(t,e,()=>{const t=a(s.data.geometry,l),n=t.x-r.origin.x,o=t.y-r.origin.y,c=(t.z??0)-(r.origin.z??0);e.move(n,o,c)})}return null}(t,e.mapStart.spatialReference)),null==n)return null;const r=e.mapEnd.x-e.mapStart.x,o=e.mapEnd.y-e.mapStart.y,c=(e.mapEnd.z??0)-(e.mapStart.z??0);return n.move(r,o,c,e.action),{...e,translationX:r,translationY:o,translationZ:c}}}function f(t,n){return null==t?null:t.spatialReference.equals(n)?t.clone():a(t,n)}function d(t,n,e){let r=0,a=0,l=0;return{move:(s,o,c,u)=>{"start"===u&&(r=0,a=0,l=0);const i=s-r,p=o-a,m=c-l;n.move(i,p,m),r+=i,a+=p,l+=m,e(),"end"===u&&t.endInteraction?.()}}}function E(t,n=null,e){let r=null;const l=null==n||t.spatialReference?.equals(n)?t=>t:t=>null!=t?a(t,n):t,s={exclude:[],...e};return n=>{if("start"===n.action&&(r=l(t.toMap(n.screenStart,s))),null==r)return null;const e=l(t.toMap(n.screenEnd,s));return null!=e?{...n,mapStart:r,mapEnd:e}:null}}function x(t){const e=t.map(t=>m(t)).filter(n);return t=>{const n=t.mapEnd.x-t.mapStart.x,r=t.mapEnd.y-t.mapStart.y,a=t.mapEnd.z-t.mapStart.z;return e.forEach(n=>n(t)),{...t,translationX:n,translationY:r,translationZ:a}}}function y(n,e){const r=new Map;for(const a of e)r.set(a,t(n[a]));return t=>(r.forEach((t,e)=>{n[e]=t}),t)}function S(t){const n=t.operations?.createResetState();return t=>(n?.remove(),t)}function h(t){const n=t.map(t=>S(t)).filter(t=>null!=t);return t=>(n.forEach(n=>n(t)),t)}function z(){let t=0,n=0,e=0;return r=>{"start"===r.action&&(t=r.mapStart.x,n=r.mapStart.y,e=r.mapStart.z);const a=r.mapEnd.x-t,l=r.mapEnd.y-n,s=r.mapEnd.z-e;return t=r.mapEnd.x,n=r.mapEnd.y,e=r.mapEnd.z,{...r,mapDeltaX:a,mapDeltaY:l,mapDeltaZ:s,mapDeltaSpatialReference:r.mapStart.spatialReference}}}function g(){let t=0,n=0;return e=>{"start"===e.action&&(t=e.screenStart.x,n=e.screenStart.y);const r=e.screenEnd.x-t,a=e.screenEnd.y-n;return t=e.screenEnd.x,n=e.screenEnd.y,{...e,screenDeltaX:r,screenDeltaY:a}}}function v(t,n){let a=null,l=0,s=0;return o=>{if("start"===o.action&&(a=t.toScreen?.(n),null!=a&&(a.x<0||a.x>t.width||a.y<0||a.y>t.height?a=null:(l=o.screenStart.x-a.x,s=o.screenStart.y-a.y))),null==a)return null;const c=e(o.screenEnd.x-l,0,t.width),u=e(o.screenEnd.y-s,0,t.height),i=r(c,u);return o.screenStart=a,o.screenEnd=i,o}}const j=()=>{};class M{constructor(){this.execute=j}next(t,n=new M){return null!=t&&(this.execute=e=>{const r=t(e);null!=r&&n.execute(r)}),n}}function R(t,n,e=[]){if("2d"===t.type)return t=>t;let r=null;return a=>{"start"===a.action&&(r=t.toMap(a.screenStart,{exclude:e}),null!=r&&(r.z=c(r,t,n)));const l=t.toMap(a.screenEnd,{exclude:e});null!=l&&(l.z=c(l,t,n));const s=null!=r&&null!=l?{sceneStart:r,sceneEnd:l}:null;return{...a,scenePoints:s}}}function w(t,n,e){const r=n.elevationProvider.getElevation(t.x,t.y,t.z??0,t.spatialReference,"scene")??0,a=o(t);return a.z=r,a.hasZ=!0,a.z=c(a,n,e),a}function D(t,n){if("2d"===t.type)return t=>t;let e=null;return r=>{"start"===r.action&&(e=w(r.mapStart,t,n));const a=w(r.mapEnd,t,n),l=null!=e&&null!=a?{sceneStart:e,sceneEnd:a}:null;return{...r,scenePoints:l}}}export{M as E,R as a,v as b,i as c,m as d,p as e,g as f,y as g,z as h,x as i,h as j,D as k,S as r,E as s};
