/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{c as e,C as r}from"./Cyclical.js";import{c as t,a}from"./quantityUtils.js";import{p as n,c as s}from"./unitUtils.js";import{m as i}from"./vec2.js";import{c as o,U as c}from"./vec2f64.js";import{g as u,e as l,k as f}from"./vec3.js";import{c as p}from"./vec3f64.js";import{p as g}from"./projectVectorToVector.js";import{geodesicCompatibleSpatialReference as m,inverseGeodeticSolver as d,InverseGeodeticSolverResult as h,directGeodeticSolver as v}from"../geometry/support/geodesicUtils.js";function j(e,r){if(null==e||null==r)return;const t=b(e,r);return null!=t?a(t,"radians","geographic"):void 0}const b=(()=>{const e=p(),r=p();return(t,a)=>(f(e,t.x,t.y,t.z??0),f(r,a.x,a.y,a.z??0),y(e,r,t.spatialReference,a.spatialReference))})(),y=(()=>{const e=o(),r=p(),t=p();return(a,o,l,f)=>{if(u(a,o))return;const p=m(l),h=m(f);if(p&&h&&n(p,h)&&g(a,l,r,p)&&g(o,f,t,h)){const{azimuth:e}=d(V,r,t,p);return null!=e?s(e,"degrees","radians"):void 0}e[0]=o[0]-a[0],e[1]=o[1]-a[1];let v=i(c,e);return e[0]<0&&(v=k-v),v}})();function z(e,r,t,a="absolute"){if(r&&t)switch(a){case"absolute":return j(r,t);case"relative":return M(w(e,r,t),"relative");case"relative-bilateral":return M(w(e,r,t),"relative-bilateral")}}function w(e,r,t){if(!e||!r||!t)return;const n=b(e,r),s=b(r,t);return null!=n&&null!=s?a(s-n,"radians","geographic"):void 0}function M(e,r){if(null!=e)switch(r){case"absolute":return U(e);case"relative":{const r=T(e);let t=I.normalize(r,0,!0);return-180===t&&(t=180),a(t,"degrees","geographic")}case"relative-bilateral":{const r=T(e),t=Math.abs(I.normalize(r,0,!0));return a(t,"degrees","geographic")}}}function U(e){const r=T(e),t=q.normalize(r,0,!0);return a(t,"degrees","geographic")}const x=(()=>{const e=p();return(r,a,n,i,o,c="geodesic")=>{l(e,a);const u=T(o);if("geodesic"===c){const t=m(n);if(t&&g(e,n,e,t))return v(r,e,u,i,t),r[2]=a[2],!!g(r,t,r,n)}const p=t(u,"geographic","arithmetic"),d=s(p,"degrees","radians"),h=a[0]+i*Math.cos(d),j=a[1]+i*Math.sin(d),b=a[2];return f(r,h,j,b),!0}})();function T(e){if(null!=e)return t(R(e),e.rotationType,"geographic")}function C(e){if(null!=e)return t(R(e),e.rotationType,"arithmetic")}function R(e){return s(e.value,e.unit,"degrees")}const V=new h,k=2*Math.PI,q=e,I=new r(-180,180);export{T as a,U as b,M as c,j as d,z as e,C as g,x as p,y as r};
