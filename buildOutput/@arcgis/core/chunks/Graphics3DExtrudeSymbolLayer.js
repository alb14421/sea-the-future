/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clone as t}from"../core/lang.js";import e from"../core/Error.js";import{E as s}from"./unitUtils.js";import{e as n}from"./earcut.js";import{n as o}from"./mat3.js";import{c as i}from"./mat3f64.js";import{i as r,q as a}from"./mat4.js";import{c as l}from"./mat4f64.js";import{k as c,t as p,s as u,c as h,n as m,e as d,h as f}from"./vec3.js";import{O as g,c as y}from"./vec3f64.js";import{c as b}from"./computeTranslationToOriginAndRotation.js";import{c as _,v as x,x as w}from"./aaBoundingBox.js";import{n as S,d as v}from"./DoubleArray.js";import{a as P,n as j}from"./Indices.js";import{b as C}from"./vec32.js";import{m as E,a as D}from"./SnappingCandidate.js";import{b as A}from"./renderingInfoUtils.js";import{a as I,n as M,S as L}from"./ElevationContext.js";import{G as z,O as U,a as O,i as R}from"./TextureCompressionTracker.js";import{v as B,l as T}from"./graphicUtils.js";import V from"../geometry/Extent.js";import G from"../geometry/Polygon.js";import{l as F,r as H}from"./triangulationUtils.js";import{A as k}from"./orientedBoundingBox.js";import{G as N}from"./Matrix4PassUniform.js";import{e as q,b as W}from"./symbolColorUtils.js";import{d as Z}from"./debugFlags2.js";import{S as J}from"./ElevationProvider.js";import{p as K}from"./projectBuffer.js";import{d as Q}from"./RenderGeometry.js";import{a as X,c as Y}from"./Normals.js";import{O as $}from"./RibbonLineMaterial.js";import{D as tt}from"./DefaultMaterial.js";function et(t,e,s){const o=(e.length>0?e[0]:t.length/3)-1,i=F(t,o,s);if(2!==i){t=t.slice();for(let e=0;e<t.length;e+=3)t[e+i]=t[e+2]}return n(t,e,3)}function st(t){const e=[["position",new k(t.attributeData.position,t.indices,3,!0)]],s=P(t.indices.length);return null!=t.attributeData.colorFeature?e.push(["colorFeatureAttribute",new k([t.attributeData.colorFeature],s,1,!0)]):t.attributeData.color&&e.push(["color",new k(t.attributeData.color,s,4,!0)]),t.attributeData.uvMapSpace&&e.push(["uvMapSpace",new k(t.attributeData.uvMapSpace,t.indices,4,!0)]),t.attributeData.boundingRect&&e.push(["boundingRect",new k(t.attributeData.boundingRect,t.indices,9,!0)]),new N(t.material,e,t.mapPositions,0,t.attributeData.olidColor)}function nt(t,e=null){const s=[["position",new k(t.attributeData.position,t.indices,3,!0)],["uv0",new k(t.attributeData.uv0,t.indices,2,!0)]];return new N(t.material,s,t.mapPositions,0,e)}function ot(t){switch(t.type){case"extent":if(t instanceof V)return G.fromExtent(t);break;case"polygon":return t}return null}class it{constructor(t,e,s){this.renderData=t,this.layerViewUid=e,this.graphicUid=s,this.outGeometries=new Array}}function rt(t,e,s,n){const o=H(t.rings,!!t.hasZ&&"on-the-ground"!==n.mode,1,t.spatialReference),i=S(o.position.length),r=I(o.position,t.spatialReference,0,i,0,o.position,0,o.position.length/3,e,s,n),a=null!=r;return new dt(o.position,i,ct(o.polygons,o.position,i),lt(o.outlines,o.position,i),a,r)}function at(t,e){const s=H(t.rings,!1,1),n=K(s.position,t.spatialReference,0,s.position,e,0);for(let t=2;t<s.position.length;t+=3)s.position[t]=Q;return{position:s.position,polygons:ct(s.polygons,s.position),outlines:lt(s.outlines,s.position),projectionSuccess:n}}function lt(t,e,s=null){return t.filter(({count:t})=>t>1).map(({index:t,count:n})=>{const o=3*t,i=3*n;return null!=s?new ut(t,n,v(e,o,i),v(s,o,i)):new pt(t,n,v(e,o,i))})}function ct(t,e,s=null){const n=new Array;for(const{index:o,count:i,holeIndices:r,pathLengths:a}of t){if(i<=1)continue;const t=3*o,l=3*i,c=r.map(t=>t-o),p=null!=s?new ht(o,i,v(e,3*o,3*i),v(s,t,l),c,a):new mt(o,i,v(e,3*o,3*i),c,a);n.push(p)}return n}class pt{constructor(t,e,s){this.index=t,this.count=e,this.position=s}}class ut extends pt{constructor(t,e,s,n){super(t,e,s),this.mapPositions=n}}class ht extends ut{constructor(t,e,s,n,o,i){super(t,e,s,n),this.holeIndices=o,this.pathLengths=i}}class mt extends pt{constructor(t,e,s,n,o){super(t,e,s),this.holeIndices=n,this.pathLengths=o}}class dt{constructor(t,e,s,n,o,i){this.position=t,this.mapPositions=e,this.polygons=s,this.outlines=n,this.projectionSuccess=o,this.sampledElevation=i}}const ft=["polygon","extent"];class gt extends z{constructor(t,e,s,n){super(t,e,s,n,function(t){return 1===(t.material?.color?.a??0)}(e)),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=B(this._getSymbolSize());if(t)throw new e("graphics3dextrudesymbollayer:invalid-size",t)}const t=this.symbolLayer,s=t?.material,n=this.symbolLayer.material?.color?.a,o=this.needsDrivenTransparentPass||null!=n&&1!==n,i=s?.emissive,r=!this._hasDrivenColorOrOpacity&&(null==n||0===n),a={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,ambient:g,diffuse:g,opacity:r?0:1,layerOpacity:this._getLayerOpacity(),drivenOpacity:o,hasSymbolColors:!0,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:t.castShadows,emissiveStrength:i?.strength??0,emissiveSource:1,offsetTransparentBackfaces:!0,normalType:1},l=new tt(a,this._context),c=new tt({...a,cullFace:2},this._context);this._materials[0]=l,this._materials[1]=c,this._updateTransparentDepedentMaterialParameters()}destroy(){super.destroy(),this._materials.length=0}createGraphics3DGraphic(t){const e=t.graphic;if(!this._validateGeometry(e.geometry,ft,this.symbolLayer.type))return null;const s=this._getDrivenUInt8ColorWithNaNSupport(t.renderingInfo,this._materialColor,!1);q(s,s);const n=this.setGraphicElevationContext(e);return this._createAs3DShape(e,t.renderingInfo,s,n,e.uid)}layerOpacityChanged(t,e){const s=this._getLayerOpacity();this._materials[0]?.setParameters({layerOpacity:s}),this._materials[1]?.setParameters({layerOpacity:s}),this._updateTransparentDepedentMaterialParameters(),t?.forEach(t=>e(t)?.layerOpacityChanged(s,this._context.isAsync))}layerElevationInfoChanged(t,e){return this.updateGraphics3DGraphicElevationInfo(t,e,M)}slicePlaneEnabledChanged(t,e){return this._materials[0]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),this._materials[1]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),t?.forEach(t=>{const s=e(t);null!=s&&s.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)}),!0}physicalBasedRenderingChanged(){const t={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0};return this._materials[0]?.setParameters(t),this._materials[1]?.setParameters(t),!0}_getExtrusionSize(t){let e;return e=t.size&&this._drivenProperties.size?A(t.size,2)??0:this._getSymbolSize(),e/=this._context.renderCoordsHelper.unitInMeters,e}applyRendererDiff(t,e){return this._drivenPropertiesChanged(e)?0:1}async queryForSnapping(e,n,o,i){const r=this._getExtrusionSize(o)*this._context.renderCoordsHelper.unitInMeters/s(n),{objectId:a,target:l}=e,c=t(l);switch(c.z=(c.z??0)+r,e.type){case"edge":{const{start:s,end:n}=e,o=t(s),i=t(n);return o.z=(o.z??0)+r,i.z=(i.z??0)+r,[D(a,c,1/0,o,i)]}case"vertex":return[E(a,c,1/0),D(a,l,1/0,l,c)];default:return[]}}_getSymbolSize(){return this.symbolLayer.size??1}_createAs3DShape(t,e,s,u,h){const m=ot(t.geometry);if(null==m)return null;if(0===m.rings.length||!m.rings.some(t=>t.length>0))return this._logGeometryValidationWarnings(m.rings,"rings","ExtrudeSymbol3DLayer"),null;const d=rt(m,this._context.elevationProvider,this._context.renderCoordsHelper,u);this._logGeometryCreationWarnings(d,m.rings,"rings","ExtrudeSymbol3DLayer");const f=T(m);if(null==f)return null;const g=new Array,v=new Array,P=_(),E=l(),D=y(),A=1===this._context.renderCoordsHelper.viewingMode;A||this._context.renderCoordsHelper.worldUpAtPosition(null,D),b(m.spatialReference,[f.x,f.y,0],E,this._context.renderCoordsHelper.spatialReference);const I=l();r(I,E);const L=i();o(L,I);const{polygons:z,mapPositions:B,position:V}=d,G=new Map,F=this._materials[0];for(const t of z){const o=t.count;if(this._context.clippingExtent&&(x(t.mapPositions,P),!w(P,this._context.clippingExtent)))continue;const i=n(t.mapPositions,t.holeIndices,3);if(0===i.length)continue;const r=i.length,a=6*o,l=j(a+r),c=j(r),p=S(3*a),u=S(3*a),m=S(3*a),d=S(a);bt(V,B,i,t,p,m,u,d,l,c,this._getExtrusionSize(e),D,A),C(p,p,I);const f=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:h,layerViewUid:this._context.layerViewUid}),y=new Gt(p,m,X(u),d),b=yt(F,l,l.length-c.length,y,s,f),_=o,M=o,L=2*t.count,z=new Ft(_,M,L,r/3);At(b,z,E),G.set(b,z),g.push(b,yt(this._materials[1],c,0,y,s,f)),v.push(y.heights)}if(0===g.length)return null;const H=new $({geometries:g,layerViewUid:this._context.layerViewUid,graphicUid:h,isElevationSource:!0});H.transformation=E;const k=W(this.symbolLayer,{opacity:this._getLayerOpacity()}),N=k?new U(this._materials[0],k,this._context.slicePlaneEnabled):null,q=new O(this,H,null,(t,e,s,n,o)=>function(t,e,s,n,o,i,r){const u=t.stageObject,h=u.geometries,m=h.length,d="absolute-height"!==e.mode;let f=0;const g=u.transformation,y=a(l(),g);for(let t=0;t<m;t+=2){const e=h[t];if(!R(e))continue;const a=e.getMutableAttribute("position").data,l=i[t/2],m=new J(e.mapPositions),b=a.length/3;let _=!1,x=0;{let t=0;for(let e=0;e<b;e++){Dt[0]=a[t],Dt[1]=a[t+1],Dt[2]=a[t+2],n(m,Lt),d&&(x+=Lt.sampledElevation),Z.TESTS_DISABLE_OPTIMIZATIONS?(c(It,m.array[m.offset],m.array[m.offset+1],Lt.z+l[t/3]),null!=s&&o.toRenderCoords(It,s,It),p(It,It,y)):(c(It,a[t],a[t+1],a[t+2]),p(It,It,g),o.setAltitude(It,Lt.z+l[t/3]),p(It,It,y)),a[t]=It[0],a[t+1]=It[1],a[t+2]=It[2];const e=Ot/o.unitInMeters;(Math.abs(Dt[0]-a[t])>=e||Math.abs(Dt[1]-a[t+1])>=e||Math.abs(Dt[2]-a[t+2])>=e)&&(_=!0),m.offset+=3,t+=3}}if(_){const s=r.get(e);s&&At(e,s,g),u.geometryVertexAttributeUpdated(h[t],"normalCompressed"),e.invalidateBoundingInfo(),u.geometryVertexAttributeUpdated(h[t],"position"),h[t+1].invalidateBoundingInfo(),u.geometryVertexAttributeUpdated(h[t+1],"position")}f+=x/b}return f/m}(t,e,s,n,o,v,G),u,N);return q.alignedSampledElevation=d.sampledElevation,q.needsElevationUpdates=M(u.mode),q}get _materialColor(){return this.symbolLayer.material?.color}_updateTransparentDepedentMaterialParameters(){const t=this._materials[0];t&&t.setParameters({cullFace:t.transparent?0:2})}}function yt(t,e,s,n,o,i){const r=P(e.length),a=[["position",new k(n.positions,e,3,!0)],["normalCompressed",new k(n.normals,e,2,!0)],["symbolColor",new k(o,r,4,!0)]];return new N(t,a,n.elevation,0,i,s)}function bt(t,e,s,n,o,i,r,a,l,c,p,u,h){const f=s.length/3;let g=2*n.count;!function(t,e,s,n,o,i,r,a,l,c,p,u,h,f,g,y,b){d(Mt,y),l??=[],c??=[],p??=[];const _=g>0?1:-1;let x=3*s,w=0,S=3*w,v=n,P=3*v;for(let s=0;s<n;++s){const s=t[x],n=t[x+1],o=t[x+2];b&&(Mt[0]=s,Mt[1]=n,Mt[2]=o,m(Mt,Mt)),a[S+0]=s,a[S+1]=n,a[S+2]=o;const i=e[x+0],r=e[x+1],u=e[x+2];l[S+0]=i,l[S+1]=r,l[S+2]=u,c[S+0]=-_*Mt[0],c[S+1]=-_*Mt[1],c[S+2]=-_*Mt[2],p[w]=0,a[P+0]=s+g*Mt[0],a[P+1]=n+g*Mt[1],a[P+2]=o+g*Mt[2],l[P+0]=i,l[P+1]=r,l[P+2]=u,p[v]=g,S+=3,P+=3,x+=3,w+=1,v+=1}x=0,S=0,P=3*f;const j=g<0?Ut:zt,C=g<0?zt:Ut;for(let t=0;t<r;++t)h[S]=o[x+j[0]],h[S+1]=o[x+j[1]],h[S+2]=o[x+j[2]],u[P]=o[x+C[0]]+n,u[P+1]=o[x+C[1]]+n,u[P+2]=o[x+C[2]]+n,S+=3,P+=3,x+=3}(t,e,n.index,n.count,s,0,f,o,i,r,a,l,c,g,p,u,h);let y=0,b=2*n.count;g=0;const _=n.pathLengths[0];wt(o,i,a,r,y,_,n.count,b,l,g,p),b+=4*_,g+=2*_,y+=_;for(let t=1;t<n.pathLengths.length;++t){const e=n.pathLengths[t];wt(o,i,a,r,y,e,n.count,b,l,g,p),b+=4*e,g+=2*e,y+=e}}function _t(t,e,s,n,o,i,r){n[i]=n[r],r*=3,t[i*=3]=t[r],t[i+1]=t[r+1],t[i+2]=t[r+2],e[i]=e[r],e[i+1]=e[r+1],e[i+2]=e[r+2],s[i]=o[0],s[i+1]=o[1],s[i+2]=o[2]}const xt=y();function wt(t,e,s,n,o,i,r,a,l,c,p){e??=[],s??=[],n??=[];let u=o,h=o+1,m=o+r,d=o+r+1,f=a,g=a+1,y=a+2*i,b=a+2*i+1;p<0&&(u=o+r+1,d=o);let _=3*c;for(let a=0;a<i;++a)a===i-1&&(h=o,p>0?d=o+r:u=o+r),Et(t,u,h,m,xt),_t(t,e,n,s,xt,f,u),_t(t,e,n,s,xt,g,h),_t(t,e,n,s,xt,y,m),_t(t,e,n,s,xt,b,d),l[_]=f,l[_+1]=y,l[_+2]=b,l[_+3]=f,l[_+4]=b,l[_+5]=g,_+=6,u++,h++,m++,d++,f+=2,g+=2,y+=2,b+=2}const St=y(),vt=y(),Pt=y(),jt=y(),Ct=y();function Et(t,e,s,n,o){e*=3,s*=3,n*=3,c(St,t[e++],t[e++],t[e++]),c(vt,t[s++],t[s++],t[s++]),c(Pt,t[n++],t[n++],t[n++]),f(jt,vt,St),f(Ct,Pt,St),h(o,Ct,jt),m(o,o)}const Dt=y();function At(t,e,s){const n=t.getMutableAttribute("position"),o=t.getMutableAttribute("normalCompressed").data,{topVertexStart:i,topVertexCount:r,topFaceStart:a,topFaceCount:l}=e,d=n.data,f=r,g=t.attributes.get("position").indices,y=a+l,b=i+r,_=S(3*f);for(let t=0;t<f;++t){const e=3*t;_[e+0]=0,_[e+1]=0,_[e+2]=0}const x=Rt,w=Bt,v=Tt,P=Vt,j=Mt;for(let t=a;t<y;++t){const e=3*t;for(let t=0;t<3;++t){const n=g[e+t];P[t]=n;const o=3*n;c(It,d[o+0],d[o+1],d[o+2]),p(x[t],It,s)}u(w,x[1],x[0]),u(v,x[2],x[0]),h(j,w,v),m(j,j);for(let t=0;t<3;++t){const e=3*(P[t]-i);_[e+0]+=j[0],_[e+1]+=j[1],_[e+2]+=j[2]}}for(let t=i;t<b;++t){const e=3*(t-i),s=_[e+0],n=_[e+1],r=_[e+2],a=Math.sqrt(s*s+n*n+r*r);Y(o,t,s/a,n/a,r/a)}}const It=y(),Mt=y(),Lt=new L,zt=[0,2,1],Ut=[0,1,2],Ot=.01,Rt=[y(),y(),y()],Bt=y(),Tt=y(),Vt=[0,0,0];class Gt{constructor(t,e,s,n){this.positions=t,this.elevation=e,this.normals=s,this.heights=n}}class Ft{constructor(t,e,s,n){this.topVertexStart=t,this.topVertexCount=e,this.topFaceStart=s,this.topFaceCount=n}}export{gt as G,it as P,ot as a,st as b,et as c,at as d,bt as e,nt as f,rt as g};
