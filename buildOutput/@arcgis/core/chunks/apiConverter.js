/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{G as e,P as t}from"./Point2D.js";import"./Envelope2D.js";import{E as r,P as s}from"./Envelope.js";import{M as o,c as i,a as n}from"./ProjectionTransformation.js";import a from"../geometry/Extent.js";import m from"../geometry/Multipoint.js";import p from"../geometry/Point.js";import c from"../geometry/Polygon.js";import u from"../geometry/Polyline.js";import{fromGeometryToGXGeometry as l,toGeometry as j}from"./jsonConverter.js";import"./Transformation2D.js";import"./SimpleGeometryCursor.js";import"./tslib.es6.js";import"./OperatorDefinitions.js";import"./string.js";import"./object.js";import"../core/lang.js";import"../core/accessorSupport/decorators/property.js";import"./Logger.js";import"../config.js";import"./ensureType.js";import"./MapUtils.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./metadata.js";import"../core/Error.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./tracking.js";import"./Warning.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"./ObjectPool.js";import"./ObservableBase.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./events.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"./persistableUrlUtils.js";import"./writer.js";import"../geometry/support/webMercatorUtils.js";import"./zmUtils.js";import"../core/accessorSupport/decorators/cast.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";const f="_gxVersion";function g(e){return Array.isArray(e)?e[0].spatialReference:e.spatialReference}function h(e){switch(e.type){case"point":return C(e);case"multipoint":return x(e);case"polyline":return V(e);case"polygon":return M(e);case"extent":return y(e);default:throw new Error(`Unsupported geometry type: ${e.type}`)}}function y(e){if(!e.getCacheValue(f)){const t=new r;t.setCoords(e.xmin,e.ymin,e.xmax,e.ymax),e.hasM&&t.setInterval(2,0,e.mmin,e.mmax),e.hasZ&&t.setInterval(1,0,e.zmin,e.zmax),e.setCacheValue(f,t)}return e.getCacheValue(f)}function x(e){if(!e.getCacheValue(f)){const t=new o,r=new s,i=e.points,n=e.hasM,a=e.hasZ,m=a?3:2;for(let e=0,s=i.length;e<s;e++){const s=i[e];r.setXYCoords(s[0],s[1]),a&&r.setZ(s[2]??0),n&&r.setM(s[m]??NaN),t.add(r)}e.setCacheValue(f,t)}return e.getCacheValue(f)}function C(e){if(!e.getCacheValue(f)){const t=new s;t.setXYCoords(e.x,e.y),e.hasM&&t.setM(e.m),e.hasZ&&t.setZ(e.z),e.setCacheValue(f,t)}return e.getCacheValue(f)}function M(e){if(!e.getCacheValue(f)){const{curveRings:t,hasM:r,hasZ:s,rings:o}=e,i=l({curveRings:t,hasM:r,hasZ:s,rings:o});e.setCacheValue(f,i)}return e.getCacheValue(f)}function V(e){if(!e.getCacheValue(f)){const{curvePaths:t,hasM:r,hasZ:s,paths:o}=e,i=l({curvePaths:t,hasM:r,hasZ:s,paths:o});e.setCacheValue(f,i)}return e.getCacheValue(f)}function d(e){if(e.wkid)return i(e.wkid);const t=e.wkt2||e.wkt;return t?n(t):null}function w(t,r){if(t)switch(t.getGeometryType()){case e.enumPoint:return U(t,r);case e.enumEnvelope:return v(t,r);case e.enumMultiPoint:return P(t,r);case e.enumPolyline:return E(t,r);case e.enumPolygon:return Z(t,r)}return null}function v(e,t){if(e.isEmpty())return null;const r=new a({xmin:e.getXMin(),ymin:e.getYMin(),xmax:e.getXMax(),ymax:e.getYMax(),spatialReference:t}),s=e.getDescription();if(s.hasM()){const t=e.queryInterval(2,0);r.mmin=t.vmin,r.mmax=t.vmax}if(s.hasZ()){const t=e.queryInterval(1,0);r.zmin=t.vmin,r.zmax=t.vmax}return r.setCacheValue(f,e),r}function P(e,t){if(e.isEmpty())return null;const r=e.getDescription(),o=r.hasM(),i=r.hasZ(),n=[],a=new s;for(let t=0,r=e.getPointCount();t<r;t++){e.getPointByVal(t,a);const r=[a.getX(),a.getY()];i&&r.push(a.getZ()),o&&r.push(a.getM()),n.push(r)}const p=new m({hasM:o,hasZ:i,points:n,spatialReference:t});return p.setCacheValue(f,e),p}function U(e,r){if(e instanceof t)return new p({x:e.x,y:e.y,spatialReference:r});if(e.isEmpty())return null;const s=new p({x:e.getX(),y:e.getY(),spatialReference:r}),o=e.getDescription();return o.hasM()&&(s.m=e.getM()),o.hasZ()&&(s.z=e.getZ()),s.setCacheValue(f,e),s}function Z(e,t){if(e.isEmpty())return null;const r=c.fromJSON({spatialReference:t,...j(e,null)});return r.setCacheValue(f,e),r}function E(e,t){if(e.isEmpty())return null;const r=u.fromJSON({spatialReference:t,...j(e,null)});return r.setCacheValue(f,e),r}export{y as fromExtent,h as fromGeometry,x as fromMultipoint,C as fromPoint,M as fromPolygon,V as fromPolyline,d as fromSpatialReference,g as getSpatialReference,v as toExtent,w as toGeometry,P as toMultipoint,U as toPoint,Z as toPolygon,E as toPolyline};
