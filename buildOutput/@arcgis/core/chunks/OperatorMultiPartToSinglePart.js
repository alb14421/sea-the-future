/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{G as e}from"./SimpleGeometryCursor.js";import{d as t,E as s,k as r,v as n,n as o,w as a,P as i,C as m,x as l}from"./ProjectionTransformation.js";import{v as g,G as h,b as u,a as c}from"./Point2D.js";import{Envelope2D as p}from"./Envelope2D.js";import{i as P,b as y,P as _}from"./Envelope.js";class d{getOperatorType(){return 10700}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t,s,r=1){return new I(e,t,s,r)}}class I extends e{constructor(e,t,s,r){super(),this.m_progressTracker=s,this.m_inputGeoms=e,this.m_spatialReference=t,this.m_currentGeometry=null,this.m_singlePartIndex=-1,this.m_singlePartCount=-1,this.m_polygonStart=-1,this.m_index=-1,this.m_options=r}tock(){return!0}getRank(){return 1}next(){if(this.m_singlePartIndex===this.m_singlePartCount){const _=this.m_inputGeoms.next();if(null===_)return null;if(g(_),_.getGeometryType()===h.enumPolygon)if(1===this.m_options)this.m_currentGeometry=(new t).execute(_,this.m_spatialReference,!1,this.m_progressTracker);else if(2===this.m_options)if(_.getPathCount()<2)this.m_currentGeometry=_;else{const e=[0],t=_.getImpl().getIsSimple(0,e);if(P(t))this.m_currentGeometry=_;else{const e=new s,t=e.addGeometry(_);let l=null;if(e.hasCurves()){l=new m;const t=new p;_.queryEnvelope(t);const s=y(null,_,!0),o=r(s.total(),t);n(e,o,s.total(),12e3,null,l,null,this.m_progressTracker)}const g=e.createPathUserIndex();{let s=0;for(let r=e.getFirstPath(t);r!==o;r=e.getNextPath(r))e.setPathUserIndex(r,g,s++)}const h=a(e,t,this.m_progressTracker);u(h>=0);const c=[];for(let s=e.getFirstPath(t);s!==o;s=e.getNextPath(s))c.push(s);c.sort((t,s)=>Math.abs(e.getPathUserIndex(t,h))-Math.abs(e.getPathUserIndex(s,h)));const P=_,d=new i({vd:_.getDescription()});d.reserveParts(P.getPointCount(),P.getPathCount());for(let t=0,s=c.length;t<s;t++){const s=c[t],r=e.getPathUserIndex(s,g),n=P.calculateRingArea2D(r)>0,o=e.getPathUserIndex(s,h)>=0;d.addPath(P,r,n===o)}this.m_currentGeometry=d}}else c("");else this.m_currentGeometry=_;this.m_singlePartCount=(e=this.m_currentGeometry).isEmpty()?1:l(e),this.m_singlePartIndex=0,this.m_polygonStart=0,this.m_index=this.m_inputGeoms.getGeometryID()}var e;const _=this.getSingleGeometry(this.m_singlePartIndex,this.m_singlePartCount,this.m_polygonStart,this.m_currentGeometry);return _.getGeometryType()===h.enumPolygon&&(this.m_polygonStart+=_.getPathCount()),this.m_singlePartIndex++,_}getGeometryID(){return this.m_index}getSingleGeometry(e,t,s,r){let n=null;switch(r.getGeometryType()){case h.enumMultiPoint:n=new _({vd:r.getDescription()}),r.isEmpty()||r.getPointByVal(e,n);break;case h.enumPolyline:if(1===t)n=r;else{n=r.createInstance(),n.getImpl().addPath(r.getImpl(),e,!0);const t=[0],s=r.getImpl().getIsSimple(0,t);n.getImpl().setIsSimple(s,t[0],!0)}break;case h.enumPolygon:if(1===t)n=r;else{n=r.createInstance();const e=n.getImpl(),t=r.getImpl(),o=t.getPathFlagsStreamRef();let a=s;const i=t.getPathCount();do{e.addPath(t,a,!0),a++}while(a<i&&!(8&o.read(a)));e.getPathFlagsStreamRef().setBits(0,8);const m=[0],l=t.getIsSimple(0,m);e.setIsSimple(l,m[0],!0)}break;default:n=r}return n}}export{d as O};
