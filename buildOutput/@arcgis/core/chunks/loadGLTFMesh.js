/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import t from"../Color.js";import{d as e}from"./colorUtils.js";import o from"../request.js";import r from"../core/Error.js";import{g as s}from"./MapUtils.js";import{r as i,j as n}from"./mathUtils.js";import{n as a,f as m}from"./mat3.js";import{c as p}from"./mat3f64.js";import{f as l}from"./vec3f64.js";import{f as c}from"./vec4f64.js";import u from"../geometry/support/MeshComponent.js";import f from"../geometry/support/MeshMaterialMetallicRoughness.js";import j from"../geometry/support/MeshTexture.js";import g from"../geometry/support/MeshTextureTransform.js";import{M as d}from"./MeshVertexAttributes.js";import{s as x}from"./meshVertexSpaceUtils.js";import{g as y,o as T,A as h,E as v,B as b,F as w,c as U,a as M}from"./BufferView.js";import{c as S,d as C,e as B,l as A}from"./vec32.js";import{a as R,n as $,l as E}from"./vec42.js";import{e as V}from"./types.js";import"../core/lang.js";import{c as F}from"./vertexSpaceConversion.js";import{D as P}from"./DefaultLoadingContext.js";import{loadGLTF as O}from"./loader.js";import{c as L,n as k,f as q}from"./indexUtils.js";import{i as G}from"./resourceUtils3.js";import{f as I}from"./vec33.js";import"./ensureType.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"../core/promiseUtils.js";import"./handleUtils.js";import"./events.js";import"./maybe.js";import"./persistableUrlUtils.js";import"./tslib.es6.js";import"../core/Clonable.js";import"../core/Accessor.js";import"../core/Handles.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"./Warning.js";import"./get.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"../core/JSONSupport.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/MeshMaterial.js";import"./meshCloneUtils.js";import"./imageUtils.js";import"./reader.js";import"./writer.js";import"./meshProperties.js";import"./vec3.js";import"./common.js";import"../geometry/Point.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/support/MeshGeoreferencedVertexSpace.js";import"./enumeration.js";import"../geometry/support/MeshLocalVertexSpace.js";import"./vec2.js";import"./vec4.js";import"./vec2f64.js";import"./mat4.js";import"./mat4f64.js";import"./spatialReferenceEllipsoidUtils.js";import"./computeTranslationToOriginAndRotation.js";import"./projectBuffer.js";import"./geodesicConstants.js";import"./projectPointToVector.js";import"./projectionUtils.js";import"./SimpleObservable.js";import"../geometry/Extent.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./projectXYZToVector.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./asyncUtils.js";import"./Version.js";import"./quat.js";import"./quatf64.js";import"./enums.js";import"./Indices.js";function z(t,e,o,r,s,i){const n=t.typedBuffer,a=t.typedBufferStride,m=i?.count??t.count;let p=(i?.dstIndex??0)*a;for(let t=0;t<m;++t)n[p]=e,n[p+1]=o,n[p+2]=r,n[p+3]=s,p+=a}function D(t,e){return new t(new ArrayBuffer(e*t.ElementCount*V(t.ElementType)))}async function N(e,n,a){const m=new P(function(t){const e=t?.resolveFile;return e?{busy:!1,request:async(t,r,s)=>{const i=e?.(t)??t,n=2===r?"image":1===r||3===r?"array-buffer":"json";return(await o(i,{responseType:n,signal:s?.signal,timeout:0})).data}}:null}(a)),p=(await O(m,n,a,!0)).model,u=p.lods.shift(),h=new Map,v=new Map;p.textures.forEach((t,e)=>{return h.set(e,new j({data:(G((r=t).data),r.data),wrap:(o=r.parameters.wrap,{horizontal:W(o.s),vertical:W(o.t)})}));var o,r}),p.materials.forEach((e,o)=>v.set(o,function(e,o){const r=new t((a=e.color,m=e.opacity,c(X(a[0]),X(a[1]),X(a[2]),m))),s=e.emissiveFactor?new t(function(t){return l(X(t[0]),X(t[1]),X(t[2]))}(e.emissiveFactor)):null,n=t=>t?new g({scale:t.scale?[t.scale[0],t.scale[1]]:[1,1],rotation:i(t.rotation??0),offset:t.offset?[t.offset[0],t.offset[1]]:[0,0]}):null;var a,m;return new f({color:r,colorTexture:o.get(e.colorTexture),normalTexture:o.get(e.normalTexture),emissiveColor:s,emissiveTexture:o.get(e.emissiveTexture),occlusionTexture:o.get(e.occlusionTexture),alphaMode:Q(e.alphaMode),alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,metallic:e.metallicFactor,roughness:e.roughnessFactor,metallicRoughnessTexture:o.get(e.metallicRoughnessTexture),colorTextureTransform:n(e.colorTextureTransform),normalTextureTransform:n(e.normalTextureTransform),occlusionTextureTransform:n(e.occlusionTextureTransform),emissiveTextureTransform:n(e.emissiveTextureTransform),metallicRoughnessTextureTransform:n(e.metallicRoughnessTextureTransform)})}(e,h)));const w=function(t){let e=0;const o={color:!1,tangent:!1,normal:!1,texCoord0:!1},r=new Map,i=new Map,n=[];for(const a of t.parts){const{position:t,normal:m,color:p,tangent:l,texCoord0:c}=a.attributes,u=`\n      ${H(t,r)}/\n      ${H(m,r)}/\n      ${H(p,r)}/\n      ${H(l,r)}/\n      ${H(c,r)}/\n      ${J(a.transform)}\n    `;let f=!1;const j=s(i,u,()=>(f=!0,{start:e,length:t.count}));f&&(e+=t.count),m&&(o.normal=!0),p&&(o.color=!0),l&&(o.tangent=!0),c&&(o.texCoord0=!0),n.push({gltf:a,writeVertices:f,region:j})}return{vertexAttributes:{position:D(M,e),normal:o.normal?D(b,e):null,tangent:o.tangent?D(y,e):null,color:o.color?D(T,e):null,texCoord0:o.texCoord0?D(U,e):null},parts:n,components:[]}}(u);for(const t of w.parts)K(w,t,v);const{position:S,normal:C,tangent:B,color:A,texCoord0:R}=w.vertexAttributes,$=x(e,a),E=e.spatialReference.isGeographic?x(e):$,V=F({vertexAttributes:{position:S.typedBuffer,normal:C?.typedBuffer,tangent:B?.typedBuffer},vertexSpace:E,spatialReference:e.spatialReference},$,{allowBufferReuse:!0,sourceUnit:a?.unitConversionDisabled?void 0:"meters"});if(!V)throw new r("load-gltf-mesh:vertex-space-projection",`Failed to load mesh from glTF because we could not convert the vertex space from ${E.type} to ${$.type}`);return{transform:null,vertexSpace:$,components:w.components,spatialReference:e.spatialReference,vertexAttributes:new d({...V,color:A?.typedBuffer,uv:R?.typedBuffer})}}function H(t,e){if(null==t)return"-";const o=t.typedBuffer;return`${s(e,o.buffer,()=>e.size)}/${o.byteOffset}/${o.byteLength}`}function J(t){return null!=t?t.toString():"-"}function K(t,e,o){e.writeVertices&&function(t,e){const{position:o,normal:r,tangent:s,color:i,texCoord0:l}=t.vertexAttributes,c=e.region.start,{attributes:u,transform:f}=e.gltf,j=u.position.count;if(S(o.slice(c,j),u.position,f),null!=u.normal&&null!=r){const t=a(p(),f),e=r.slice(c,j);C(e,u.normal,t),n(t)&&B(e,e)}else null!=r&&I(r,0,0,1,{dstIndex:c,count:j});if(null!=u.tangent&&null!=s){const t=m(p(),f),e=s.slice(c,j);R(e,u.tangent,t),n(t)&&$(e,e)}else null!=s&&z(s,0,0,1,1,{dstIndex:c,count:j});if(null!=u.texCoord0&&null!=l?k(l.slice(c,j),u.texCoord0):null!=l&&q(l,0,0,{dstIndex:c,count:j}),null!=u.color&&null!=i){const t=u.color,e=i.slice(c,j);if(4===t.elementCount)t instanceof y?E(e,t,1,255):(t instanceof T||t instanceof h)&&E(e,t,1/255,255);else{z(e,255,255,255,255);const o=v.fromTypedArray(e.typedBuffer,e.typedBufferStride);t instanceof b?A(o,t,1,255):(t instanceof v||t instanceof w)&&A(o,t,1/255,255)}}else null!=i&&z(i.slice(c,j),255,255,255,255)}(t,e);const{indices:r,attributes:s,primitiveType:i,material:l}=e.gltf;let c=L(r||s.position.count,i);const f=e.region.start;if(f){const t=new Uint32Array(c);for(let e=0;e<c.length;e++)t[e]+=f;c=t}t.components.push(new u({name:e.gltf.name,faces:c,material:o.get(l),shading:s.normal?"source":"flat",trustSourceNormals:!0}))}function Q(t){switch(t){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function W(t){switch(t){case 33071:return"clamp";case 33648:return"mirror";case 10497:return"repeat"}}function X(t){return t**(1/e)*255}export{N as loadGLTFMesh};
