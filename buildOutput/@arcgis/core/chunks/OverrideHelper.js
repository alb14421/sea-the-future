/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../Color.js";import{i as r}from"./colorUtils2.js";import{clone as t}from"../core/lang.js";import s from"../layers/support/FieldsIndex.js";import{b as i}from"./ArcadeExpression.js";import{d as o,e as a,f as p,g as c,h as m,j as l,u as n}from"./utils6.js";import f from"./callExpressionWithFeature.js";import"./colorUtils.js";import"./mathUtils.js";import"./ensureType.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"./MapUtils.js";import"./vec4.js";import"./common.js";import"./vec4f64.js";import"../core/Error.js";import"./UnknownTimeZone.js";import"./datetime.js";import"./jsonUtils.js";import"../layers/support/fieldUtils.js";import"./SetUtils.js";import"../core/sql.js";import"./maybe.js";import"./guards.js";import"./constants.js";import"./timeZoneUtils.js";import"./TimeOnly.js";import"./enum.js";import"./locale.js";import"./handleUtils.js";import"../geometry/Extent.js";import"./tslib.es6.js";import"../core/accessorSupport/decorators/property.js";import"./get.js";import"./utils.js";import"./metadata.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./tracking.js";import"./Warning.js";import"../geometry/Geometry.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./ObjectPool.js";import"./ObservableBase.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./events.js";import"./SimpleTrackingTarget.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./persistableUrlUtils.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/support/jsonUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./defaultCIMValues.js";import"./quantizationUtils.js";const y=e=>{if(!e)return[0,0,0,0];const{r,g:t,b:s,a:i}=e;return[r,t,s,255*i]};class j{static findApplicableOverrides(e,r,t){if(e&&r){if(e.primitiveName){let s=!1;for(const r of t)if(r.primitiveName===e.primitiveName){s=!0;break}if(!s)for(const s of r)s.primitiveName===e.primitiveName&&t.push(s)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)j.findApplicableOverrides(s,r,t);if(e.symbolLayers)for(const s of e.symbolLayers)j.findApplicableOverrides(s,r,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const s of e.effects)j.findApplicableOverrides(s,r,t);if(e.markerPlacement&&j.findApplicableOverrides(e.markerPlacement,r,t),"CIMVectorMarker"===e.type){if(e.markerGraphics)for(const s of e.markerGraphics)j.findApplicableOverrides(s,r,t),j.findApplicableOverrides(s.symbol,r,t)}else"CIMCharacterMarker"===e.type?j.findApplicableOverrides(e.symbol,r,t):"CIMHatchFill"===e.type?j.findApplicableOverrides(e.lineSymbol,r,t):"CIMPictureMarker"===e.type&&j.findApplicableOverrides(e.animatedSymbolProperties,r,t)}}}static findEffectOverrides(e,r){if(!e)return null;if("CIMGeometricEffectDashes"===e.type&&o(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const t=a(e),s=e.primitiveName,i=[];for(const e of r)e.primitiveName===s&&i.push(a(e));return{type:"cim-effect-param",effect:t,overrides:p(i)}}static async resolveSymbolOverrides(e,r,i,o,a,p,m){if(!e?.symbol)return null;let{symbol:l,primitiveOverrides:n}=e;const f=!!n;if(!f&&!o)return l;l=t(l),n=t(n);let y=!0;if(r||(r={attributes:{}},y=!1),f){if(y||(n=n.filter(e=>!e.valueExpressionInfo?.expression.includes("$feature"))),m||(n=n.filter(e=>!e.valueExpressionInfo?.expression.includes("$view"))),n.length>0){const e=c(r.attributes),t={spatialReference:i,fields:e,geometryType:a};await j.createRenderExpressions(n,t),j.evaluateOverrides(n,r,a??"esriGeometryPoint",p,m,new s(e))}j.applyOverrides(l,n)}return o&&j.applyDictionaryTextOverrides(l,r,o,null),l}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const t=[];for(const s of e){const e=s.valueExpressionInfo;if(!e||j._expressionToRenderExpression.has(e.expression))continue;const o=i(e.expression,r.spatialReference);t.push(o),o.then(r=>j._expressionToRenderExpression.set(e.expression,r))}t.length>0&&await Promise.all(t)}static evaluateOverrides(e,t,s,i,o,a){const p={$view:{scale:o?.scale}};for(const o of e){o.value&&"object"==typeof o.value&&r(o.value)&&("Color"===o.propertyName||"StrokeColor"===o.propertyName)&&(o.value=y(o.value));const e=o.valueExpressionInfo;if(!e)continue;const c=j._expressionToRenderExpression.get(e.expression);c&&(o.value=f(c,t,p,s,a,i))}}static applyDictionaryTextOverrides(e,r,t,s,i="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const a of o)a&&"CIMVectorMarker"===a.type&&j.applyDictionaryTextOverrides(a,r,t,s,"CIMTextSymbol"===e.type?e.textCase:i)}break;case"CIMVectorMarker":{const i=e.markerGraphics;if(!i)return;for(const e of i)e&&j.applyDictionaryTextOverrides(e,r,t,s)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const a=m(o,t);e.textString=l(r,a,s,i)}}}}static applyOverrides(e,r,t,s){if(e.primitiveName)for(const i of r)if(i.primitiveName===e.primitiveName){const r=n(i.propertyName);if(s&&s.push({cim:e,nocapPropertyName:r,value:e[r]}),t){let r=!1;for(const s of t)s.primitiveName===e.primitiveName&&(r=!0);r||t.push(i)}null!=i.value&&(e[r]=i.value)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const i of e.effects)j.applyOverrides(i,r,t,s);if(e.symbolLayers)for(const i of e.symbolLayers)j.applyOverrides(i,r,t,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const i of e.effects)j.applyOverrides(i,r,t,s);if("CIMVectorMarker"===e.type&&e.markerGraphics)for(const i of e.markerGraphics)j.applyOverrides(i,r,t,s),j.applyOverrides(i.symbol,r,t,s)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const t of e)void 0!==t.value&&(r+=`${t.primitiveName}${t.propertyName}${JSON.stringify(t.value)}`);return r}static toValue(r,t){if("DashTemplate"===r)return t.split(" ").map(e=>Number(e));if("Color"===r){const r=new e(t).toRgba();return r[3]*=255,r}return t}}export{j as OverrideHelper};
