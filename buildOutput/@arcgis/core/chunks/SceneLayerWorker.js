/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{j as e}from"./mathUtils.js";import r from"../geometry/SpatialReference.js";import{e as t}from"./DoubleArray.js";import o from"../geometry/support/MeshGeoreferencedVertexSpace.js";import s from"../geometry/support/MeshLocalVertexSpace.js";import{t as i,n}from"./vec32.js";import{g as a}from"./assets.js";import{T as c,a as m}from"./I3SMeshWorkerHandle.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/lang.js";import"../core/Handles.js";import"./Logger.js";import"../config.js";import"./object.js";import"./string.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./Lifecycle.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./ensureType.js";import"./MapUtils.js";import"./Warning.js";import"../core/Error.js";import"./get.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/accessorSupport/decorators/property.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./events.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"../core/JSONSupport.js";import"./unitUtils.js";import"./jsonMap.js";import"./pe.js";import"./writer.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./jsonUtils.js";import"./persistableUrlUtils.js";import"../core/Clonable.js";import"./enumeration.js";import"./vec3f64.js";import"./colorUtils.js";import"./WorkerHandle.js";import"../core/workers/workers.js";import"../core/workers/Connection.js";import"./Queue.js";import"./SimpleObservable.js";import"../core/workers/RemoteClient.js";import"../intl.js";import"./date.js";import"./locale.js";import"./constants.js";import"./datetime.js";import"./number.js";import"./substitute.js";import"./messages.js";import"./projectionUtils.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./projectBuffer.js";import"./geodesicConstants.js";import"./projectXYZToVector.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"./projectVectorToVector.js";import"./projectPointToVector.js";import"./dehydratedPoint.js";let p,l,f;async function u(e){f=await x();const r=[e.geometryBuffer];return{result:U(f,e,r),transferList:r}}async function j(e){f=await x();const r=[e.geometryBuffer],{geometryBuffer:t}=e,o=t.byteLength,s=f._malloc(o),i=new Uint8Array(f.HEAPU8.buffer,s,o);i.set(new Uint8Array(t));const n=f.dracoDecompressPointCloudData(s,i.byteLength);if(f._free(s),n.error.length>0)throw new Error(`i3s.wasm: ${n.error}`);const a=n.featureIds?.length>0?n.featureIds.slice():null,c=n.positions.slice();return a&&r.push(a.buffer),r.push(c.buffer),{result:{positions:c,featureIds:a},transferList:r}}async function y(e){await x(),S(e);const r={buffer:e.buffer};return{result:r,transferList:[r.buffer]}}async function g(e){await x(),E(e)}async function d(e){f=await x(),f.setLegacySchema(e.context,e.jsonSchema)}async function b(e){const{localMatrix:i,origin:n,positions:a,vertexSpace:c}=e,m=r.fromJSON(e.inSpatialReference),p=r.fromJSON(e.outSpatialReference),l=i?t(i):void 0,f=t(n);let u;const[{projectBuffer:j},{initializeProjection:y}]=await Promise.all([import("./projectBuffer.js").then(e=>e.e),import("./projectionUtils.js")]);await y(m,p);const g=[0,0,0];if(!j(f,m,0,g,p,0))throw new Error("Failed to project");if("georeferenced"===c.type&&null==c.origin){if(u=new Float64Array(a.length),!j(a,m,0,u,p,0,u.length/3))throw new Error("Failed to project")}else{const e="georeferenced"===c.type?o.fromJSON(c):s.fromJSON(c),{projectMeshVertexPositions:r}=await import("./projectMeshVertexPositions.js"),t=r({vertexAttributes:{position:a},transform:l?{localMatrix:l}:void 0,vertexSpace:e,spatialReference:m},p);if(!t)throw new Error("Failed to project");u=t}const d=u.length,[b,h,w]=g;for(let e=0;e<d;e+=3)u[e]-=b,u[e+1]-=h,u[e+2]-=w;return{result:{projected:u,original:a,projectedOrigin:g},transferList:[u.buffer,a.buffer]}}async function h({normalMatrix:r,normals:t}){const o=new Float32Array(t.length);return i(o,t,r),e(r)&&n(o,o),{result:{transformed:o,original:t},transferList:[o.buffer,t.buffer]}}function w(e){L(e)}function E(e){if(!f)return;const r=e.modifications,t=f._malloc(8*r.length),o=new Float64Array(f.HEAPU8.buffer,t,r.length);for(let e=0;e<r.length;++e)o[e]=r[e];f.setModifications(e.context,t,r.length,e.isGeodetic),f._free(t)}function U(e,r,t){const{context:o,globalTrafo:s,mbs:i,obbData:n,elevationOffset:a,geometryBuffer:p,geometryDescriptor:l,indexToVertexProjector:f,vertexToRenderProjector:u}=r,j=e._malloc(p.byteLength),y=e._malloc(33*Float64Array.BYTES_PER_ELEMENT),g=new Uint8Array(e.HEAPU8.buffer,j,p.byteLength);g.set(new Uint8Array(p));const d=new Float64Array(e.HEAPU8.buffer,y,33);T(d,[NaN,NaN,NaN]);let b=d.byteOffset+3*d.BYTES_PER_ELEMENT,h=new Float64Array(d.buffer,b);T(h,s),b+=16*d.BYTES_PER_ELEMENT,h=new Float64Array(d.buffer,b),T(h,i),b+=4*d.BYTES_PER_ELEMENT,n&&(h=new Float64Array(d.buffer,b),T(h,n));const w=l,E={isDraco:!1,isLegacy:!1,color:r.layouts.some(e=>e.some(e=>"color"===e.name)),normal:r.needNormals&&r.layouts.some(e=>e.some(e=>"normalCompressed"===e.name)),uv0:r.layouts.some(e=>e.some(e=>"uv0"===e.name)),uvRegion:r.layouts.some(e=>e.some(e=>"uvRegion"===e.name)),featureIndex:w.featureIndex},U=e.process(o,!!r.obbData,j,g.byteLength,w,E,y,a,f,u,r.normalReferenceFrame);if(e._free(y),e._free(j),U.error.length>0)throw new Error(`i3s.wasm: ${U.error}`);if(U.discarded)return null;const A=U.componentOffsets.length>0?U.componentOffsets.slice():null,S=U.featureIds.length>0?U.featureIds.slice():null,L=U.anchorIds.length>0?Array.from(U.anchorIds):null,P=U.anchors.length>0?Array.from(U.anchors):null,x=U.interleavedVertedData.slice().buffer,_=1===U.indicesType?new Uint16Array(U.indices.buffer,U.indices.byteOffset,U.indices.byteLength/2).slice():new Uint32Array(U.indices.buffer,U.indices.byteOffset,U.indices.byteLength/4).slice(),M=U.positions.slice(),{buffer:v,byteOffset:N,byteLength:O}=U.positionIndices,B=1===U.positionIndicesType?new Uint16Array(v,N,O/2).slice():new Uint32Array(v,N,O/4).slice(),F=new c(r.layouts[0],x,_,U.hasColors,U.hasModifications,{data:M,indices:B});return S&&t.push(S.buffer),A&&t.push(A.buffer),t.push(x),t.push(_.buffer),t.push(M.buffer),t.push(B.buffer),new m(A,S,L,P,F,s,U.obb)}function A(e){return 0===e?0:1===e?1:2===e?2:3}function S(e){if(!f)return;const{context:r,buffer:t}=e,o=f._malloc(t.byteLength),s=t.byteLength/Float64Array.BYTES_PER_ELEMENT,i=new Float64Array(f.HEAPU8.buffer,o,s),n=new Float64Array(t);i.set(n),f.filterOBBs(r,o,s),n.set(i),f._free(o)}function L(e){f&&0===f.destroy(e)&&(f=null,l=null,p=null)}function T(e,r){for(let t=0;t<r.length;++t)e[t]=r[t]}async function P(){f||await x()}async function x(){return f||(f=await(l??=(p??=(async()=>{const e=await import("./i3s.js");return await e.default({locateFile:e=>a(`esri/libs/i3s/${e}`)})})(),p))),f}const _={transform:(e,r)=>f&&U(f,e,r),destroy:L};export{w as destroyContext,j as dracoDecompressPointCloudData,y as filterObbsForModifications,S as filterObbsForModificationsSync,P as initialize,A as interpretObbModificationResults,u as process,b as project,d as setLegacySchema,g as setModifications,E as setModificationsSync,_ as test,h as transformNormals};
