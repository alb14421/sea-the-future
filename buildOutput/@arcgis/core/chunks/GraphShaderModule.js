/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import"../core/lang.js";import{L as e}from"./Logger.js";import r from"../core/Error.js";import{f as n}from"./maybe.js";import{g as i}from"./object.js";import"./BufferObject.js";import"./FramebufferObject.js";import{P as s}from"./Program.js";import{a as o,T as a}from"./Texture.js";import{S as c}from"./ShaderBuilder.js";class u{constructor(){this.drawPhase=89}startup(){}shutdown(t){}}function h(t,e){const r=[];for(r.push(e);r.length;){const e=r.pop();if("object"==typeof e&&!t.has(e.uid)){t.add(e.uid);for(const t of e.children)r.push(t)}}}class d{constructor(){this.uid=d.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}static{this.NodeCount=0}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=t.split(" ").map((t,e)=>e>0?t.charAt(0).toUpperCase()+t.slice(1):t).join(""),this._debugName=t,this.isImplicit&&this.children[0]instanceof d&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}}function p(t){return"object"==typeof t?t.clone():t}class l extends d{constructor(){super(...arguments),this.shaderType="primitive-node"}}class f extends d{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new f(p(this.child));return this.cloneInto(t),t}}class y extends d{constructor(t,e,r){super(),this.property=t,this.target=e,this.returnType=r,this.shaderType="property-access-node"}get children(){const t=[this.target];return"string"!=typeof this.property&&t.push(this.property),t}clone(){const t=new y(this.property,p(this.target),this.returnType);return this.cloneInto(t),t}}class m extends d{constructor(t,e,r,n){super(),this.x=t,this.y=e,this.target=r,this.returnType=n,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new m(this.x,this.y,p(this.target),this.returnType);return this.cloneInto(t),t}}class g extends d{constructor(t,e,r){super(),this.condition=t,this.ifTrue=e,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=p(this.ifTrue),e=this.ifFalse?p(this.ifFalse):null,r=new g(this.condition,t,e);return this.cloneInto(r),r}}class b extends d{constructor(t,e,r,n){super(),this.captureList=t,this.returnType=e,this.generator=n,this.shaderType="block-node",r&&(this.subgraph=new f(r))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const e in this.captureList)t[e]=p(this.captureList[e]);const e=new b(t,this.returnType,this.subgraph?p(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(e),e}}class w extends d{constructor(t,e,r,n,i,s=!1){super(),this.token=t,this._children=e,this.isInfix=r,this.isPropertyAccess=n,this.returnType=i,this.isTernary=s,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new w(this.token,this._children.map(p),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}}var v,_,x,$,I,N,T,M,S,k,P,C,F,E;function j(t){return new Proxy(t,{get(e,r){if("constructor"===r)return new Proxy(e.constructor,{construct:(t,e,r)=>j(new t(...e))});if(r in e)return e[r];if("string"==typeof r){const e=function(t){const e=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of e)if(r.includes(t))return r.map(t=>ot[t]);throw new Error("Unable to find type family")}(t.type);return lt(t,r,e[r.length-1])}}})}function K(t){return new Proxy(t,{construct:(t,e,r)=>j(new t(...e))})}class U extends Error{}let D=class extends l{static{v=this}static{this.type="array"}constructor(t,e){super(),this.elementType=t,this.size=e,this.children=[],this.type="array"}clone(){const t=new v(this.elementType,this.size);return super.cloneInto(t),t}get(t,e){const r=new Z(t),n=null!=e?new Z(e):null;return null!=n?ft(this,r,n,function(t){switch(t.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return X;case"float":case"vec2":case"vec3":case"vec4":return V;case"int":case"ivec2":case"ivec3":case"ivec4":return Z;case"uint":case"uvec2":case"uvec3":case"uvec4":return q;default:throw new Error("Unable to handle type")}}(this.elementType.constructor)):lt(this,r,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,e,r){return function(t,e,r=0,n=t.size){const i=new Z(r).setMutable().setDebugName("FindIndexIterator"),s=e(t.get(i)).setDebugName("FindIndexPredicate"),o=vt({iter:i},Z,s,({out:t,iter:e,subgraph:r})=>`\n${t} = -1;\n\nfor (; ${e} < ${n}; ${e}++) {\n\n${r.body}\n\n  if (${r.varName}) {\n    ${t} = ${e};\n    break;\n  }\n\n}\n`).setDebugName("FindIndexBlock");return o}(this,t,e,r)}glslFindIndex(t,e,r){return function(t,e,r=0,n=t.size){const i=vt({array:t},Z,null,({out:t,array:i})=>`\n${t} = -1;\nfor (int i = ${r}; i < ${n}; i++) {\n  bool condition;\n  ${e({array:i,i:"i",out:"condition"})}\n  if (condition) {\n    ${t} = i;\n    break;\n  }\n}\n`).setDebugName("GlslFindIndexBlock");return i}(this,t,e,r)}static ofType(t,e){const r={construct:(r,n)=>new v(new t,e)};return new Proxy(v,r)}};D=v=t([function(t){return new Proxy(t,{construct:(t,e,r)=>{return n=new t(...e),new Proxy(n,{get(t,e){if(e in t)return t[e];if("string"==typeof e){const t=parseInt(e,10);if(!isNaN(t))return lt(n,`[${t}]`,n.elementType.constructor)}}});var n}})}],D);class O extends l{static{this.type="array-2d"}constructor(t,e,r,n=!1){super(),this.elementType=t,this.xSize=e,this.ySize=r,this.isRowMajor=n,this.children=[],this.type="array-2d"}clone(){const t=new O(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,e){return this.isRowMajor?this._getRowMajor(t,e):this._getColumnMajor(t,e)}_getColumnMajor(t,e){const r=new Z(t);return lt(this,new Z(e).add(r.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,e){const r=new Z(t),n=new Z(e);return lt(this,r.add(n.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,e,r,n=!1){return new Proxy(D,{construct:(i,s)=>new O(new t,e,r,n)})}}class B extends l{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}static{this.type="sampler2D"}clone(){const t=new B;return t.children=this.children.map(p),super.cloneInto(t),t}}class V extends l{static{this.type="float"}constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new V(p(this.children[0]));return super.cloneInto(t),t}multiply(t){return $t(this,"number"==typeof t?Q(t,V):t)}divide(t){return It(this,"number"==typeof t?Q(t,V):t)}add(t){return Nt(this,"number"==typeof t?Q(t,V):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,V):t)}}let A=class extends l{static{_=this}static{this.type="vec2"}constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(t=>null!=t)}clone(){const t=new _(p(this.children[0]),p(this.children[1]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",V)}get 1(){return lt(this,"[1]",V)}get 2(){throw new U}get 3(){throw new U}multiply(t){return $t(this,"number"==typeof t?Q(t,V):t)}divide(t){return It(this,"number"==typeof t?Q(t,V):t)}add(t){return Nt(this,"number"==typeof t?Q(t,V):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,V):t)}};A=_=t([K],A);let z=class extends l{static{x=this}static{this.type="vec3"}constructor(t,e,r){super(),this.type="vec3",this.children=[t,e,r].filter(t=>null!=t)}get 0(){return lt(this,"[0]",V)}get 1(){return lt(this,"[1]",V)}get 2(){return lt(this,"[2]",V)}get 3(){throw new U}clone(){const t=new x(p(this.children[0]),p(this.children[1]),p(this.children[2]));return super.cloneInto(t),t}multiply(t){return $t(this,"number"==typeof t?Q(t,V):t)}divide(t){return It(this,"number"==typeof t?Q(t,V):t)}add(t){return Nt(this,"number"==typeof t?Q(t,V):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,V):t)}};z=x=t([K],z);let L=class extends l{static{$=this}static{this.type="vec4"}constructor(t,e,r,n){super(),this.type="vec4",this.children=[t,e,r,n].filter(t=>null!=t)}clone(){const t=new $(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",V)}get 1(){return lt(this,"[1]",V)}get 2(){return lt(this,"[2]",V)}get 3(){return lt(this,"[3]",V)}multiply(t){return $t(this,"number"==typeof t?Q(t,V):t)}divide(t){return It(this,"number"==typeof t?Q(t,V):t)}add(t){return Nt(this,"number"==typeof t?Q(t,V):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,V):t)}};L=$=t([K],L);let q=class extends l{static{I=this}static{this.type="uint"}constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new I(p(this.children[0]));return super.cloneInto(t),t}multiply(t){return $t(this,Q(t,I))}add(t){return Nt(this,Q(t,I))}subtract(t){return Tt(this,Q(t,I))}divide(t){return It(this,Q(t,I))}};q=I=t([K],q);let R=class extends l{static{N=this}static{this.type="uvec2"}constructor(t,e){super(),this.type="uvec2",this.children=[t,e].filter(t=>null!=t)}clone(){const t=new N(p(this.children[0]),p(this.children[1]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",Z)}get 1(){return lt(this,"[1]",Z)}get 2(){throw new U}get 3(){throw new U}multiply(t){return $t(this,"number"==typeof t?Q(t,q):t)}divide(t){return It(this,"number"==typeof t?Q(t,q):t)}add(t){return Nt(this,"number"==typeof t?Q(t,q):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,q):t)}};R=N=t([K],R);let G=class extends l{static{T=this}static{this.type="uvec3"}constructor(t,e,r){super(),this.type="uvec3",this.children=[t,e,r].filter(t=>null!=t)}clone(){const t=new T(p(this.children[0]),p(this.children[1]),p(this.children[2]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",q)}get 1(){return lt(this,"[1]",q)}get 2(){return lt(this,"[2]",q)}get 3(){throw new U}multiply(t){return $t(this,"number"==typeof t?Q(t,q):t)}divide(t){return It(this,"number"==typeof t?Q(t,q):t)}add(t){return Nt(this,"number"==typeof t?Q(t,q):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,q):t)}};G=T=t([K],G);let H=class extends l{static{M=this}static{this.type="uvec4"}constructor(t,e,r,n){super(),this.type="uvec4",this.children=[t,e,r,n].filter(t=>null!=t)}clone(){const t=new M(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",q)}get 1(){return lt(this,"[1]",q)}get 2(){return lt(this,"[2]",q)}get 3(){return lt(this,"[3]",q)}multiply(t){return $t(this,"number"==typeof t?Q(t,q):t)}divide(t){return It(this,"number"==typeof t?Q(t,q):t)}add(t){return Nt(this,"number"==typeof t?Q(t,q):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,q):t)}};H=M=t([K],H);class X extends l{static{this.type="bool"}constructor(t){super(),this.type="bool",this.children=[t]}and(t){return zt(this,t)}or(t){return Vt(this,t)}xor(t){return At(this,t)}clone(){const t=new X(p(this.children[0]));return super.cloneInto(t),t}}let Y=class extends l{static{S=this}static{this.type="bvec2"}constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(t=>null!=t)}all(){return Gt(this)}any(){return Ht(this)}clone(){const t=new S(p(this.children[0]),p(this.children[1]));return super.cloneInto(t),t}};Y=S=t([K],Y);let J=class extends l{static{k=this}static{this.type="bvec3"}constructor(t,e,r){super(),this.type="bvec3",this.children=[t,e,r].filter(t=>null!=t)}all(){return Gt(this)}any(){return Ht(this)}clone(){const t=new k(p(this.children[0]),p(this.children[1]),p(this.children[2]));return super.cloneInto(t),t}};function Q(t,e){return"number"==typeof t?new e(t):t}J=k=t([K],J);let W=class extends l{static{P=this}static{this.type="bvec4"}constructor(t,e,r,n){super(),this.type="bvec4",this.children=[t,e,r,n].filter(t=>null!=t)}all(){return Gt(this)}any(){return Ht(this)}clone(){const t=new P(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]));return super.cloneInto(t),t}};W=P=t([K],W);class Z extends l{static{this.type="int"}constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return $t(this,Q(t,Z))}add(t){return Nt(this,Q(t,Z))}subtract(t){return Tt(this,Q(t,Z))}divide(t){return It(this,Q(t,Z))}clone(){const t=new Z(p(this.children[0]));return super.cloneInto(t),t}}let tt=class extends l{static{C=this}static{this.type="ivec2"}constructor(t,e){super(),this.type="ivec2",this.children=[t,e].filter(t=>null!=t)}clone(){const t=new C(p(this.children[0]),p(this.children[1]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",Z)}get 1(){return lt(this,"[1]",Z)}get 2(){throw new U}get 3(){throw new U}multiply(t){return $t(this,"number"==typeof t?Q(t,Z):t)}divide(t){return It(this,"number"==typeof t?Q(t,Z):t)}add(t){return Nt(this,"number"==typeof t?Q(t,Z):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,Z):t)}};tt=C=t([K],tt);let et=class extends l{static{F=this}static{this.type="ivec3"}constructor(t,e,r){super(),this.type="ivec3",this.children=[t,e,r].filter(t=>null!=t)}clone(){const t=new F(p(this.children[0]),p(this.children[1]),p(this.children[2]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",Z)}get 1(){return lt(this,"[1]",Z)}get 2(){return lt(this,"[2]",Z)}get 3(){throw new U}multiply(t){return $t(this,"number"==typeof t?Q(t,Z):t)}divide(t){return It(this,"number"==typeof t?Q(t,Z):t)}add(t){return Nt(this,"number"==typeof t?Q(t,Z):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,Z):t)}};et=F=t([K],et);let rt=class extends l{static{E=this}static{this.type="ivec4"}constructor(t,e,r,n){super(),this.type="ivec4",this.children=[t,e,r,n].filter(t=>null!=t)}clone(){const t=new E(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]));return super.cloneInto(t),t}get 0(){return lt(this,"[0]",Z)}get 1(){return lt(this,"[1]",Z)}get 2(){return lt(this,"[2]",Z)}get 3(){return lt(this,"[3]",Z)}multiply(t){return $t(this,"number"==typeof t?Q(t,Z):t)}divide(t){return It(this,"number"==typeof t?Q(t,Z):t)}add(t){return Nt(this,"number"==typeof t?Q(t,Z):t)}subtract(t){return Tt(this,"number"==typeof t?Q(t,Z):t)}};rt=E=t([K],rt);class nt extends l{static{this.type="mat2"}constructor(t,e,r,n){super(),this.type="mat2",this.children=[t,e,r,n]}clone(){const t=new nt(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]));return super.cloneInto(t),t}get(t,e){return ft(this,new Z(t),new Z(e),V)}multiply(t){return $t(this,t)}}class it extends l{static{this.type="mat3"}static identity(){return new it(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const e=we(t),r=te(t);return new it(r,e,0,wt(e),r,0,0,0,1)}constructor(t,e,r,n,i,s,o,a,c){super(),this.type="mat3",this.children=[t,e,r,n,i,s,o,a,c]}add(t){return Nt(this,t)}multiply(t){return $t(this,t)}get(t,e){return ft(this,new Z(t),new Z(e),V)}clone(){const t=new it(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]),p(this.children[4]),p(this.children[5]),p(this.children[6]),p(this.children[7]),p(this.children[8]));return super.cloneInto(t),t}}class st extends l{static{this.type="mat4"}static identity(){return new st(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,e,r,n,i,s,o,a,c,u,h,d,p,l,f,y){super(),this.type="mat4",this.children=[t,e,r,n,i,s,o,a,c,u,h,d,p,l,f,y]}static fromColumns(t,e,r,n){return new st(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w)}multiply(t){return $t(this,t)}get(t,e){return ft(this,new Z(t),new Z(e),V)}clone(){const t=new st(p(this.children[0]),p(this.children[1]),p(this.children[2]),p(this.children[3]),p(this.children[4]),p(this.children[5]),p(this.children[6]),p(this.children[7]),p(this.children[8]),p(this.children[9]),p(this.children[10]),p(this.children[11]),p(this.children[12]),p(this.children[13]),p(this.children[14]),p(this.children[15]));return super.cloneInto(t),t}}const ot={float:V,vec2:A,vec3:z,vec4:L,int:Z,ivec2:tt,ivec3:et,ivec4:rt,uint:q,uvec2:R,uvec3:G,uvec4:H,bool:X,bvec2:Y,bvec3:J,bvec4:W},at=(...t)=>new Z(...t),ct=(...t)=>new V(...t),ut=(...t)=>new A(...t),ht=(...t)=>new z(...t),dt=(...t)=>new L(...t),pt=(...t)=>new it(...t);function lt(t,e,r){const n=new r(new y(e,t,r));return n.isImplicit=!0,n}function ft(t,e,r,n){const i=new n(new m(e,r,t,n));return i.isImplicit=!0,i}function yt(t,e,r,n=null){if(n){const i=new n,s=new n(new w(t,[e,r],!0,!1,i));return s.isImplicit=!0,s}if("float"===e.type||"int"===e.type){const n=new r.constructor(new w(t,[e,r],!0,!1,r.constructor));return n.isImplicit=!0,n}if(("mat2"===e.type||"mat3"===e.type||"mat4"===e.type)&&"float"!==r.type){const n=new r.constructor(new w(t,[e,r],!0,!1,r.constructor));return n.isImplicit=!0,n}const i=new e.constructor(new w(t,[e,r],!0,!1,e.constructor));return i.isImplicit=!0,i}function mt(t,e,r=e.constructor){const n=new r(new w(t,[e],!1,!1,r));return n.isImplicit=!0,n}function gt(t,e,r,n=e.constructor){const i=new n(new w(t,[e,r],!1,!1,n));return i.isImplicit=!0,i}function bt(t,e,r,n,i=e.constructor){const s=new i(new w(t,[e,r,n],!1,!1,i));return s.isImplicit=!0,s}function wt(t){return $t(t,ct(-1))}function vt(t,e,r,n){return new e(new b(t,e,r,n))}function _t(t,e,r){const n="function"==typeof e?e():e,i="function"==typeof r?r():r,s=new n.constructor(new g(t,n,i));return s.isImplicit=!0,s}function xt(...t){const e=t.map(([t,e])=>"function"==typeof e?[t,e()]:[t,e]),r=e[0][1].constructor,n=e.findIndex(t=>!0===t[0]);if(-1===n)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=e.slice(0,n),s=e[n][1],o=new r(i.reduceRight((t,e)=>_t(e[0],e[1],t),s));return o.isImplicit=!0,o}function $t(t,e){return yt("*",t,e)}function It(t,e){return yt("/",t,e)}function Nt(t,e){return yt("+",t,e)}function Tt(t,e){return yt("-",t,e)}function Mt(t,e){return yt("%",t,e)}function St(t,e){return yt("<<",t,e)}function kt(t,e){return yt(">>",t,e)}function Pt(t,e){return yt("&",t,e)}function Ct(t,e){return yt("|",t,e)}function Ft(t,e){return yt("^",t,e)}function Et(t){return mt("~",t)}function jt(t,e){return yt("==",t,e,X)}function Kt(t,e){return yt("!=",t,e,X)}function Ut(t,e){return yt("<",t,e,X)}function Dt(t,e){return yt("<=",t,e,X)}function Ot(t,e){return yt(">",t,e,X)}function Bt(t,e){return yt(">=",t,e,X)}function Vt(...t){return t.length<=1?t[0]:t.slice(1).reduce((t,e)=>yt("||",t,e,X),t[0])}function At(...t){return t.length<=1?t[0]:t.slice(1).reduce((t,e)=>yt("^^",t,e,X),t[0])}function zt(...t){return t.length<=1?t[0]:t.slice(1).reduce((t,e)=>yt("&&",t,e,X),t[0])}function Lt(t){return mt("abs",t)}function qt(t){return mt("acos",t)}function Rt(t){return mt("acosh",t)}function Gt(t){return mt("all",t,X)}function Ht(t){return mt("any",t,X)}function Xt(t){return mt("asin",t)}function Yt(t){return mt("asinh",t)}function Jt(t,e){return null==e?mt("atan",t):gt("atan",t,e,t.constructor)}function Qt(t){return mt("atanh",t)}function Wt(t){return mt("ceil",t)}function Zt(t,e,r){return bt("clamp",t,e,r,t.constructor)}function te(t){return mt("cos",t)}function ee(t){return mt("cosh",t)}function re(t,e){return gt("distance",t,e,V)}function ne(t,e){return gt("dot",t,e,V)}function ie(t){return mt("exp",t)}function se(t){return mt("floor",t)}function oe(t){return mt("fract",t)}function ae(t){return mt("length",t,V)}function ce(t){return mt("log",t)}function ue(t){return mt("log2",t)}function he(t,e){return gt("max",t,e)}function de(t,e){return gt("min",t,e)}function pe(t,e,r){return bt("mix",t,e,r)}function le(t,e){return gt("mod",t,e)}function fe(t){return mt("normalize",t)}function ye(t){return"bool"===t.type?mt("!",t):mt("not",t)}function me(t,e){return gt("pow",t,e)}function ge(t){return mt("round",t)}function be(t){return mt("sign",t)}function we(t){return mt("sin",t)}function ve(t){return mt("sinh",t)}function _e(t,e,r){return bt("smoothstep",t,e,r)}function xe(t){return mt("sqrt",t)}function $e(t,e){return gt("step",t,e,e.constructor)}function Ie(t){return mt("tan",t)}function Ne(t){return mt("tanh",t)}function Te(t,e,r){return bt("texelFetch",t,e,r,L)}function Me(t,e){return gt("texture",t,e,L)}function Se(t,e){const{initialValue:r,xRange:n,yRange:i,callback:s}=e,[o,a]=n,[c,u]=i,h=new Z(0).setMutable().setDebugName("iterX"),d=new Z(0).setMutable().setDebugName("iterY"),p=r.setMutable().setDebugName("accumulator"),l=s(p,t.get(h,d),h,d).setDebugName("callback"),f=vt({iterX:h,iterY:d,accumulator:p},r.constructor,l,({out:t,iterX:e,iterY:r,accumulator:n,subgraph:i})=>`\nfor (${r} = ${c}; ${r} < ${u}; ${r}++) {\n  for (${e} = ${o}; ${e} < ${a}; ${e}++) {\n\n  ${i.body}\n\n  ${n} = ${i.varName};\n  }\n}\n${t} = ${n};\n`).setDebugName("reduce2DBody");return f}function ke(t,e,r){const n=e.split("\n");for(const e of n)if(e.trim().length){{let e="";null!=r&&(e+=`/*id:${r??"000"}*/   `),t.body+=e.padEnd(14)}t.body+=" ".repeat(t.indent)+e+"\n"}}class Pe{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let r="";return"boolean"!=typeof e&&"number"!=typeof e&&e.debugInfo.name&&(r=`${e.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,e,r=!1){if("number"==typeof e)return e.toString();if("boolean"==typeof e)return e.toString();let n=t.getEmit(e);if(n)return n;switch(e.shaderType){case"scope-node":n=this._writeScopeNode(t,e);break;case"primitive-node":n=this._writePrimitiveNode(t,e,r);break;case"function-node":n=this._writeFunctionNode(t,e);break;case"property-access-node":n=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":n=this._writePropertyAccess2DNode(t,e);break;case"text-node":n=e.text;break;case"block-node":n=this._writeBlockNode(t,e);break;case"condition-node":n=this._writeConditionNode(t,e)}return t.setEmit(e,n),n}_writeScopeNode(t,e){const r=new e.child.constructor;r.setDebugName(e.debugInfo.name);const n=this._write(t,r,!0);return ke(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,ke(t,`${n} = ${this._write(t,e.child)};`),t.indent-=2,ke(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),n}_writeConditionNode(t,e){const r=new e.ifTrue.constructor,n=this._write(t,r,!0);ke(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const i=t.createSubgraphContext(),s=this._write(i,e.ifTrue);if(t.body+=i.body,s&&ke(t,`${n} = ${s};`),t.indent-=2,ke(t,"}"),e.ifFalse){ke(t,"else {"),t.indent+=2;const r=t.createSubgraphContext(),i=this._write(r,e.ifFalse);t.body+=r.body,i&&ke(t,`${n} = ${i};`),t.indent-=2,ke(t,"}")}return n}_writeBlockNode(t,e){const{captureList:r,generator:n,returnType:i}=e,s={};for(const e in r){if(!r[e])continue;const n=this._write(t,r[e]);s[e]=n}const o=new i,a=this._write(t,o,!0);if(s.out=a,e.subgraph){const r=t.createSubgraphContext(),n=this._write(r,e.subgraph.child),i=r.body;s.subgraph={varName:n,body:i}}const c=n(s);return ke(t,"{\n"),t.indent+=2,ke(t,c),t.indent-=2,ke(t,"}\n"),a}_writePropertyAccessNode(t,e){const r=this._write(t,e.target);return"string"==typeof e.property&&e.property.includes("[")?`${r}${e.property}`:"string"!=typeof e.property?`${r}[${this._write(t,e.property)}]`:`${r}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const r=e.returnType.type;if(e.isInfix){const[n,i]=e.children.map(e=>this._write(t,e)),s=this._createVarName(t,e);return ke(t,`${r.padEnd(5)} ${s} = ${n} ${e.token} ${i};`,e.uid),s}const n=e.children.map(e=>this._write(t,e)).join(", "),i=this._createVarName(t,e);return ke(t,`${r.padEnd(5)} ${i} = ${e.token}(${n});`,e.uid),i}_writePrimitiveNode(t,e,r=!1){const n=t.getInput(e);if(n)return n.isUsed=!0,n.variableName;const i=1===e.children.length&&e.children[0]?.type===e.type;if(!e.isMutable&&(e.isImplicit||i))return this._write(t,e.children[0]);const s=this._createVarName(t,e);if(r)return ke(t,`${e.type.padEnd(5)} ${s};`,e.uid),s;const o=!e.debugInfo.name&&!e.isMutable;if(o&&"float"===e.type&&"number"==typeof e.children[0])return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(o&&"int"===e.type&&"number"==typeof e.children[0]&&Number.isInteger(e.children[0]))return e.children[0].toString();const a=e.children.map(e=>this._write(t,e)).join(", ");return"array"===e.type?(ke(t,`${e.type.padEnd(5)} ${s} = [${a}];`,e.uid),s):o?`${e.type}(${a})`:(ke(t,`${e.type.padEnd(5)} ${s} = ${e.type}(${a});`,e.uid),s)}}class Ce{constructor(t,e,r,n=[]){this.variableName=t,this.variableInputType=e,this.node=r,this.qualifiers=n,this.type="shader-input",this.isUsed=!1}clone(){return new Ce(this.variableName,this.variableInputType,p(this.node),[...this.qualifiers])}}class Fe{constructor(t,e,r,n=[]){this.outVariableName=t,this.outVariableType=e,this.node=r,this.qualifiers=n,this.type="shader-output"}clone(){const t=new Fe(this.outVariableName,this.outVariableType,p(this.node),[...this.qualifiers]);return t.variableName=this.variableName,t}}class Ee{static createVertex(t,e,r,n,i,s){const o=[];for(const e in t){const n=t[e],i=r.get(e);i?o.push(new Ce(i,"builtin",n)):o.push(new Ce("a_"+e,"in",n))}for(const t of n){const e=t.uniformHydrated;o.push(new Ce(t.uniformName,"uniform",e))}const a=[];for(const t in e){const r=e[t];if("glPosition"===t)a.push(new Fe("gl_Position","builtin",r));else if("glPointSize"===t)a.push(new Fe("gl_PointSize","builtin",r));else{const e=je(r),n=[];e&&n.push(e),a.push(new Fe("v_"+t,"out",r,n))}}return new Ee(o,a,i,s)}static createFragment(t,e,r,n,i,s){const o=[],a=Array.from(i.rootOutputNodes());for(const e in t){const n=t[e],i=r.get(e);if(i){o.push(new Ce(i,"builtin",n));continue}const s=a.find(t=>t.node===n);s&&o.push(new Ce(s.outVariableName,"in",n))}for(const t of n){const e=t.uniformHydrated;o.push(new Ce(t.uniformName,"uniform",e))}const c=[];for(const t in e){const n=e[t],i=r.get(t);switch(t){case"discard":c.push(new Fe(null,"discard",n));break;case"fragData0":c.push(new Fe("fragData0","fragData0",n));break;case"fragData1":c.push(new Fe("fragData1","fragData1",n));break;case"fragData2":c.push(new Fe("fragData2","fragData2",n));break;case"fragData3":c.push(new Fe("fragData3","fragData3",n));break;default:i?c.push(new Fe(i,"builtin",n)):c.push(new Fe(t,"out",n))}}return new Ee(o,c,s)}constructor(t,e,r,n){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const e of t)this._inputShaderTypesByNodeUid.set(e.node.uid,e);this._outputShaderTypes=e,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map(t=>"v_"+t.propertyKey)),this._usedInFragmentShader=n}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&"builtin"!==t.outVariableType&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,e){this._nodeEmitMap.set(t.uid,e)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const e of this._outputShaderTypes.values())t.push(e.node);for(;t.length;){const e=t.pop();"number"!=typeof e&&"boolean"!=typeof e&&t.push(...e.children.filter(Boolean)),yield e}}*nodesOfTypeOrFunction(){for(const t of this.nodes())"number"!=typeof t&&"boolean"!=typeof t&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new Ee([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this.rootOutputNodes()){const r="builtin"===e.outVariableType;if(!this.shouldPruneOutputNode(e))if(r)t.vertex.code.add(`// ${e.outVariableType.padEnd(7)} ${e.node.type.padEnd(9)} ${e.outVariableName};`);else{const r=[...e.qualifiers,e.outVariableType].join(" ");t.vertex.code.add(`${r.padEnd(10)} ${e.node.type.padEnd(9)} ${e.outVariableName};`)}}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const e of this.rootOutputNodes())this.shouldPruneOutputNode(e)||t.vertex.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let e=0;for(const r of this.rootOutputNodes())"builtin"===r.outVariableType?t.fragment.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.outputs.add(r.outVariableName,r.node.type,e++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const e of this.rootOutputNodes())"discard"===e.outVariableType?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${e.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.fragment.code.add("}")}_insertInputs(t,e){t[e].code.add("// INPUTS: "),t[e].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())if(r.isUsed&&"builtin"!==r.variableInputType)if("array"===r.node.type)t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`);else if("array-2d"===r.node.type)t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const n=[...r.qualifiers,r.variableInputType].join(" ");t[e].code.add(` ${n.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`)}}}function je(t){switch(t.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${t.type} is not a valid output type`)}}function Ke(t,e,r){const n=new o(e.width,e.height);return n.dataType=e.dataType,e.depth&&(n.depth=e.depth),e.flipped&&(n.flipped=e.flipped),e.hasMipmap&&(n.hasMipmap=e.hasMipmap),n.internalFormat=e.internalFormat,e.isImmutable&&(n.isImmutable=e.isImmutable),e.isOpaque&&(n.isOpaque=e.isOpaque),e.maxAnisotropy&&(n.maxAnisotropy=e.maxAnisotropy),n.pixelFormat=e.pixelFormat,e.preMultiplyAlpha&&(n.preMultiplyAlpha=e.preMultiplyAlpha),e.samplingMode&&(n.samplingMode=e.samplingMode),e.target&&(n.target=e.target),n.uniform=e.uniform,e.unpackAlignment&&(n.unpackAlignment=e.unpackAlignment),e.wrapMode&&(n.wrapMode=e.wrapMode),new a(t,n,r)}function Ue(t,n,i){const s=n.length;if(s!==i){const o=new r("Invalid Uniform",`Invalid length, expected ${i} but got ${s}`,{uniformName:t,values:n});e.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram").errorOnce(o)}}class De{constructor(t,e,r,n,i){this.vertexShader=t,this.fragmentShader=e,this._locations=r,this._uniformBindings=n,this._transformFeedbackBindings=i,this._vao=null,this._temporaryTextures=[]}destroy(){this._program=n(this._program),this.cleanupTemporaryTextures()}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const e=[];for(const t of this._transformFeedbackBindings??[]){const{index:r,propertyKey:n}=t;e[r]=`v_${n}`}this._program=new s(t,this.vertexShader,this.fragmentShader,this._locations,new Map,e)}const r=this._program;t.useProgram(r);for(const n of this._uniformBindings){const{shaderModulePath:s,uniformName:o,uniformType:a,uniformArrayLength:c}=n,u=i(s,e);if(null==u){if("sampler2D"===a)continue;throw new Error(`Failed to find uniform value for ${s}`)}switch("array"===a||"array-2d"===a?n.uniformArrayElementType:a){case"sampler2D":{const{unit:e,texture:n}=u;if(r.setUniform1i(o,e),"type"in n)t.bindTexture(n,e);else{const r=Ke(t,n.descriptor,n.data);t.bindTexture(r,e)}break}case"int":if(!c){r.setUniform1i(o,u);break}Ue(n.uniformName,u,c),r.setUniform1iv(o,u);break;case"float":if(!c){r.setUniform1f(o,u);break}Ue(n.uniformName,u,c),r.setUniform1fv(o,u);break;case"vec2":if(!c){r.setUniform2f(o,u[0],u[1]);break}Ue(n.uniformName,u,c),r.setUniform2fv(o,u.flat());break;case"vec3":if(!c){r.setUniform3f(o,u[0],u[1],u[2]);break}Ue(n.uniformName,u,c),r.setUniform3fv(o,u.flat());break;case"vec4":if(!c){r.setUniform4f(o,u[0],u[1],u[2],u[3]);break}Ue(n.uniformName,u,c),r.setUniform4fv(o,u.flat());break;case"mat3":r.setUniformMatrix3fv(o,u);break;case"mat4":r.setUniformMatrix4fv(o,u);break;default:throw new Error(`Unable to set uniform for type ${a}`)}}}}function Oe(t){return new t}function Be(t,e,r){const n=t.constructor[e]??[];t.constructor.hasOwnProperty(e)||Object.defineProperty(t.constructor,e,{value:n.slice()}),t.constructor[e].push(r)}function Ve(t,e){return(r,n)=>{Be(r,"locations",{typeCtor:e,propertyKey:n,parameterIndex:null,index:t})}}const Ae=t=>(e,r,n)=>{Be(e,"inputs",{inputCtor:t,propertyKey:r,parameterIndex:n})},ze=t=>(e,r)=>{Be(e,"uniforms",{typeCtor:t,propertyKey:r})},Le=t=>(e,r)=>{Be(e,"options",{typeCtor:t,propertyKey:r})},qe=(t,e)=>{Be(t,"defines",{propertyKey:e})},Re=(t,e)=>(r,n)=>{r.constructor.builtins.push({builtin:t,propertyKey:n,typeCtor:e})};class Ge{static{this.builtins=[]}}t([Re("gl_VertexID",Z)],Ge.prototype,"glVertexID",void 0);class He{}class Xe{static{this.builtins=[]}}t([Re("gl_FragCoord",L)],Xe.prototype,"glFragCoord",void 0),t([Re("gl_PointCoord",A)],Xe.prototype,"glPointCoord",void 0);class Ye{}t([(t,e)=>{Be(t,"builtins",{builtin:"gl_FragDepth",propertyKey:e})}],Ye.prototype,"glFragDepth",void 0);class Je{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class Qe{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=this._shaderModuleClass.inputs.findLast(t=>"vertex"===t.propertyKey&&0===t.parameterIndex);if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return this._shaderModuleClass.inputs.findLast(t=>"vertex"===t.propertyKey&&1===t.parameterIndex)}get fragmentInput(){const t=this._shaderModuleClass.inputs.findLast(t=>"fragment"===t.propertyKey);if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,r=new Set;for(const n of this.locations)r.has(n.index)?e.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:t}):(t.set(n.propertyKey,n.index),r.add(n.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map(([t,e])=>`${t}.${e}`).join("."),r=this.computeAttributes;this._locationInfo={stringHash:e,locations:t,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,n){try{const{vertex:i,fragment:s,uniformBindings:o}=this._generateShaders(t,e,r,n);return new De(i,s,this.renamedLocationsMap,o,this.transformFeedbackBindings)}catch(t){return new De("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find(e=>e.propertyKey===t);if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find(e=>e.propertyKey===t);if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,n){const i=Object.keys(t).map(e=>`${e}.${t[e]}`).join("."),s=Object.keys(r).map(t=>`${t}.${r[t]}`).join("."),o=Object.keys(n).map(t=>`${t}.${n[t]}`).join("."),a=Object.keys(e).filter(t=>this.optionPropertyKeys.has(t)&&e[t]).join(".");return`${this.type}.${i}.${s}.${o}.${a}`}_generateShaders(t,e,r,n){const i=[];this._setDefines(r),this._setOptionalUniforms(i,e),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(n),o=this._injectPackPrecisionFactor(s,t),a=this._hydrateComputeInput(),c=a&&this._injectComputePackPrecisionFactor(a,t),u=this.vertex(o,c),d=this._hydrateFragmentInput(u),p=this.fragment(d),l=new Set;for(const t in p)h(l,p[t]);const f=this._getVertexInputBuiltins(),y={};for(const[t,e]of Object.entries(s))y[t]=e;if(null!=a)for(const[t,e]of Object.entries(a))y[t]=e;const m=Ee.createVertex(y,u,f,i,this.transformFeedbackBindings,l);(new Pe).write(m);const g=this._getFragmentInputBuiltins(p);g.set("glPointCoord","gl_PointCoord");const b=Ee.createFragment(d,p,g,i,m,this.transformFeedbackBindings);(new Pe).write(b);const w=this._createShaderBuilder(m,b),v=w.generate("vertex"),_=w.generate("fragment");return this.logShader&&(console.log(v),console.log(_)),{vertex:v,fragment:_,uniformBindings:i}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options)e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new(0,e.typeCtor);for(const n of r._uniforms??[]){const i=Oe(n.typeCtor),s=`u_${e.propertyKey}_${n.propertyKey}`,o=i.type,a=[e.propertyKey,n.propertyKey].join(".");if("type"in n.typeCtor&&"array"===n.typeCtor.type){const e=i;t.push({shaderModulePath:a,uniformName:s,uniformType:o,uniformArrayLength:e.size,uniformArrayElementType:e.elementType.type,uniformHydrated:i})}else if("type"in n.typeCtor&&"array-2d"===n.typeCtor.type){const e=i;t.push({shaderModulePath:a,uniformName:s,uniformType:o,uniformArrayLength:e.size,uniformArrayElementType:e.elementType.type,uniformHydrated:i})}else t.push({shaderModulePath:a,uniformName:s,uniformType:o,uniformHydrated:i});r[n.propertyKey]=i}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce((e,r)=>!1===t[r.propertyKey]?e:{...e,[r.propertyKey]:Oe(r.typeCtor)},{});for(const{propertyKey:t,typeCtor:n}of e.builtins){const e=Oe(n);r[t]=e}return r}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce((t,e)=>({...t,[e.propertyKey]:Oe(e.typeCtor)}),{})}_injectPackPrecisionFactor(t,e){const r={};for(const n in t){const i=t[n],s=e[n];if(s){if("float"!==i.type&&"vec2"!==i.type&&"vec3"!==i.type&&"vec4"!==i.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[n]=i.divide(new V(s))}else r[n]=i}return r}_injectComputePackPrecisionFactor(t,e){const r={},n=new Map;for(const t in this.computeAttributes)for(const e of this.computeAttributes[t]??[])n.set(e,t);for(const i in t){const s=t[i],o=n.get(i);if(!o)continue;const a=e[o];if(a){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new V(a))}else r[i]=s}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:t,typeCtor:r}of Xe.builtins){const n=Oe(r);e[t]=n}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:n}of t.builtins)e.set(n,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const t of e.builtins??[])r.set(t.propertyKey,t.builtin);return r}_createShaderBuilder(t,e){const r=new c;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}}export{D as $,de as A,$e as B,xt as C,Dt as D,Ut as E,V as F,Qe as G,xe as H,Jt as I,me as J,ae as K,te as L,it as M,_e as N,Z as O,ge as P,Mt as Q,$t as R,B as S,u as T,Je as U,A as V,tt as W,Te as X,X as Y,at as Z,be as _,L as a,Le as a0,wt as a1,Kt as a2,Bt as a3,At as a4,Vt as a5,zt as a6,Ft as a7,Et as a8,kt as a9,De as aA,St as aa,Ct as ab,Pt as ac,Ne as ad,Ie as ae,ve as af,ee as ag,Qt as ah,Yt as ai,Xt as aj,Rt as ak,qt as al,Wt as am,ie as an,ue as ao,ce as ap,Se as aq,O as ar,vt as as,He as at,st as au,nt as av,re as aw,ye as ax,fe as ay,pt as az,ct as b,he as c,le as d,se as e,oe as f,Ot as g,ne as h,ut as i,jt as j,ht as k,z as l,pe as m,Ye as n,Ve as o,Ae as p,Ge as q,Xe as r,we as s,Me as t,ze as u,dt as v,qe as w,_t as x,Zt as y,Lt as z};
