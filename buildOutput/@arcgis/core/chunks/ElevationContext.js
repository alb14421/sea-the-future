/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{c as e}from"./mat4.js";import{c as t}from"./mat4f64.js";import{c as n}from"./vec3f64.js";import{c as r}from"./computeTranslationToOriginAndRotation.js";import{p as s}from"./projectBuffer.js";import{i as o}from"./dehydratedFeatureUtils.js";import{i,g as a}from"./ElevationProvider.js";import{g as u,a as l}from"./unitConversionUtils.js";import{L as f}from"./Logger.js";import{throwIfAborted as c}from"../core/promiseUtils.js";import{b as d}from"./hydratedFeatures.js";import{l as m}from"../layers/support/fieldUtils.js";function p(e,t,n,r,o,i,a,u,l,f,c){const d=_[c.mode];let m,p,h=0;if(s(e,t,n,r,l.spatialReference,o,u))return d?.requiresAlignment(c)?(h=d.applyElevationAlignmentBuffer(r,o,i,a,u,l,f,c),m=i,p=a):(m=r,p=o),s(m,l.spatialReference,p,i,f.spatialReference,a,u)?h:void 0}function h(e,t,n,r,s){const u=(o(e)?e.z:i(e)?e.array[e.offset+2]:e[2])||0;switch(n.mode){case"on-the-ground":{const n=a(t,e,"ground")??0;return s.verticalDistanceToGround=0,s.sampledElevation=n,void(s.z=n)}case"relative-to-ground":{const o=a(t,e,"ground")??0,i=n.geometryZWithOffset(u,r);return s.verticalDistanceToGround=i,s.sampledElevation=o,void(s.z=i+o)}case"relative-to-scene":{const o=a(t,e,"scene")??0,i=n.geometryZWithOffset(u,r);return s.verticalDistanceToGround=i,s.sampledElevation=o,void(s.z=i+o)}case"absolute-height":{const o=n.geometryZWithOffset(u,r),i=a(t,e,"ground")??0;return s.verticalDistanceToGround=o-i,s.sampledElevation=i,void(s.z=o)}default:return void(s.z=0)}}function g(e,t,n,r){return h(e,t,n,r,R),R.z}function v(e,t,n){return"on-the-ground"===t&&"on-the-ground"===n?e.staysOnTheGround:t===n||"on-the-ground"!==t&&"on-the-ground"!==n?null==t||null==n?e.definedChanged:1:e.onTheGroundChanged}function x(e){return"relative-to-ground"===e||"relative-to-scene"===e}function E(e){return"absolute-height"!==e}function U(t,n,s,o,i){h(n,s,i,o,R),I(t,R.verticalDistanceToGround);const a=R.sampledElevation,u=e(y,t.transformation);return C[0]=n.x,C[1]=n.y,C[2]=R.z,r(n.spatialReference,C,u,o.spatialReference)?t.transformation=u:console.warn("Could not locate symbol object properly, it might be misplaced"),a}function I(e,t){for(let n=0;n<e.geometries.length;++n){const r=e.geometries[n].getMutableAttribute("centerOffsetAndDistance");r&&r.data[3]!==t&&(r.data[3]=t,e.geometryVertexAttributeUpdated(e.geometries[n],"centerOffsetAndDistance"))}}class O{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}const _={"absolute-height":{applyElevationAlignmentBuffer:function(e,t,n,r,s,o,i,a){const u=a.calculateOffsetRenderUnits(i),l=a.featureExpressionInfoContext;t*=3,r*=3;for(let o=0;o<s;++o){const s=e[t],o=e[t+1],i=e[t+2];n[r]=s,n[r+1]=o,n[r+2]=null==l?i+u:u,t+=3,r+=3}return 0},requiresAlignment:function(e){const t=e.meterUnitOffset,n=e.featureExpressionInfoContext;return 0!==t||null!=n}},"on-the-ground":{applyElevationAlignmentBuffer:function(e,t,n,r,s,o){let i=0;const a=o.spatialReference;t*=3,r*=3;for(let u=0;u<s;++u){const s=e[t],u=e[t+1],l=e[t+2],f=o.getElevation(s,u,l,a,"ground")??0;i+=f,n[r]=s,n[r+1]=u,n[r+2]=f,t+=3,r+=3}return i/s},requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:function(e,t,n,r,s,o,i,a){let u=0;const l=a.calculateOffsetRenderUnits(i),f=a.featureExpressionInfoContext,c=o.spatialReference;t*=3,r*=3;for(let i=0;i<s;++i){const s=e[t],i=e[t+1],a=e[t+2],d=o.getElevation(s,i,a,c,"ground")??0;u+=d,n[r]=s,n[r+1]=i,n[r+2]=null==f?a+d+l:d+l,t+=3,r+=3}return u/s},requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:function(e,t,n,r,s,o,i,a){let u=0;const l=a.calculateOffsetRenderUnits(i),f=a.featureExpressionInfoContext,c=o.spatialReference;t*=3,r*=3;for(let i=0;i<s;++i){const s=e[t],i=e[t+1],a=e[t+2],d=o.getElevation(s,i,a,c,"scene")??0;u+=d,n[r]=s,n[r+1]=i,n[r+2]=null==f?a+d+l:d+l,t+=3,r+=3}return u/s},requiresAlignment:()=>!0}},y=t(),R=new O,C=n();function A(e){const t=e?.expression;if("string"==typeof t){const e=F(t);if(null!=e)return{cachedResult:e}}return null}async function b(e,t,n,r){const s=e?.expression;if("string"!=typeof s)return null;const o=F(s);if(null!=o)return{cachedResult:o};const i=await m();c(n);const a=i.arcadeUtils,u=a.createSyntaxTree(s);return a.dependsOnView(u)?(null!=r&&r.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:a.createFunction(u),context:a.createExecContext(null,{sr:t}),modules:i}}}function j(e,t,n){return e.arcadeUtils.createFeature(t.attributes,t.geometry,n)}function T(e,t){if(null!=e&&!D(e)){if(!t||!e.arcade)return void f.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils").errorOncePerTick("Arcade support required but not provided");const n=t;n._geometry&&(n._geometry=d(n._geometry)),e.arcade.modules.arcadeUtils.updateExecContext(e.arcade.context,t)}}function z(e,t=!1){let n=e?.featureExpressionInfo;const r=n?.expression;return t||"0"===r||(n=null),n??null}const w={cachedResult:0};function D(e){return null!=e.cachedResult}function F(e){return"0"===e?0:null}class G{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(e){this._unit=e,this._metersPerElevationInfoUnit=u(e)}get requiresSampledElevationInfo(){return"absolute-height"!==this.mode}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(e){this._meterUnitOffset=e,this._renderUnitOffset=0}set offsetElevationInfoUnits(e){this._meterUnitOffset=e*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(e){this._renderUnitOffset+=e}geometryZWithOffset(e,t){const n=this.calculateOffsetRenderUnits(t);return null!=this.featureExpressionInfoContext?n:e+n}calculateOffsetRenderUnits(e){let t=this._meterUnitOffset;const n=this.featureExpressionInfoContext;return null!=n&&(t+=function(e){if(null!=e){if(D(e))return e.cachedResult;const t=e.arcade;let n=t?.modules.arcadeUtils.executeFunction(t.func,t.context);return"number"!=typeof n&&(e.cachedResult=0,n=0),n}return 0}(n)*this._metersPerElevationInfoUnit),t/e.unitInMeters+this._renderUnitOffset}setFromElevationInfo(e){this.mode=e.mode,this.unit=l(e.unit)?e.unit:"meters",this.offsetElevationInfoUnits=e.offset??0}updateFeatureExpressionInfoContext(e,t,n){if(null==e)return void(this._featureExpressionInfoContext=null);const r=e?.arcade;var s;r&&null!=t&&null!=n?(this._featureExpressionInfoContext={cachedResult:(s=e).cachedResult,arcade:s.arcade?{func:s.arcade.func,context:s.arcade.modules.arcadeUtils.createExecContext(null,{sr:s.arcade.context.spatialReference}),modules:s.arcade.modules}:null},T(this._featureExpressionInfoContext,j(r.modules,t,n))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const t=new G;return null!=e&&t.setFromElevationInfo(e),t}}export{G as E,O as S,p as a,z as b,b as c,h as d,g as e,A as f,U as g,v as h,x as i,j,E as n,T as s,I as u,w as z};
