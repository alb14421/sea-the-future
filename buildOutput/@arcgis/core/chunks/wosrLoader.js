/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../request.js";import{r as t}from"./asyncUtils.js";import r from"../core/Error.js";import{L as s}from"./Logger.js";import{a as n}from"./memoryEstimations.js";import{N as a}from"./NestedMap.js";import{throwIfAbortError as o}from"../core/promiseUtils.js";import{V as i}from"./Version.js";import{a as u}from"./vec3f64.js";import{m as l,e as c}from"./aaBoundingBox.js";import{g as m}from"./Indices.js";import{r as p}from"./requestImageUtils.js";import{A as f}from"./orientedBoundingBox.js";import{T as d,G as y}from"./Matrix4PassUniform.js";import{D as g}from"./DefaultMaterial.js";const h=()=>s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class x{constructor(e,t,r){this.resource=e,this.textures=t,this.cachedMemory=r}}async function w(r,s){const a=await async function(r,s){const n=s?.streamDataRequester;if(n)return async function(e,r,s){const n=await t(r.request(e,0,s));return!0===n.ok?n.value:(o(n.error),void v(n.error.details.url))}(r,n,s);const a=await t(e(r,s));return!0===a.ok?a.value.data:(o(a.error),void v(a.error))}(r,s),i=await async function(e,t){const r=new Array;for(const s in e){const n=e[s],a=n.images[0].data;if(!a){h().warn("Externally referenced texture data is not yet supported");continue}const o=n.encoding+";base64,"+a,i="/textureDefinitions/"+s,u="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",l={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:1!==M(u)},c=t?.disableTextures?Promise.resolve(null):p(o,t);r.push(c.then(e=>({refId:i,image:e,parameters:l,alphaChannelUsage:u})))}const s=await Promise.all(r),n={};for(const e of s)n[e.refId]=e;return n}(a.textureDefinitions??{},s);let u=0;for(const e in i)if(i.hasOwnProperty(e)){const t=i[e];u+=t?.image?t.image.width*t.image.height*4:0}return new x(a,i,u+n(a))}function v(e){throw new r("",`Request for object resource failed: ${e}`)}function b(e){const t=e.params,r=t.topology;let s=!0;switch(t.vertexAttributes||(h().warn("Geometry must specify vertex attributes"),s=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t?.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(h().warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),s=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(h().warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),s=!1)):(h().warn(`Indexed geometry does not specify face indices for '${r}' attribute`),s=!1)}}else h().warn("Indexed geometries must specify faces"),s=!1;break}default:h().warn(`Unsupported topology '${r}'`),s=!1}e.params.material||(h().warn("Geometry requires material"),s=!1);const n=e.params.vertexAttributes;for(const e in n)n[e].values||(h().warn("Geometries with externally defined attributes are not yet supported"),s=!1);return s}function A(e,t){const r=new Array,s=new Array,n=new Array,o=new a,l=e.resource,c=i.parse(l.version||"1.0","wosr");U.validate(c);const p=l.model.name,h=l.model.geometries,x=l.materialDefinitions??{},w=e.textures;let v=0;const A=new Map;for(let e=0;e<h.length;e++){const a=h[e];if(!b(a))continue;const i=P(a),l=a.params.vertexAttributes,c=[],p=e=>{if("PerAttributeArray"===a.params.topology)return null;const t=a.params.faces;for(const r in t)if(r===e)return t[r].values;return null},j=l.position,U=j.values.length/j.valuesPerElement;for(const e in l){const t=l[e],r=t.values,s=p(e)??m(U);c.push([e,new f(r,s,t.valuesPerElement,!0)])}const I=i.texture,E=w&&w[I];if(E&&!A.has(I)){const{image:e,parameters:t}=E,r=new d(e,t);s.push(r),A.set(I,r)}const k=A.get(I),T=k?k.id:void 0,q=i.material;let B=o.get(q,I);if(null==B){const e=x[q.slice(q.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=E?M(E.alphaChannelUsage):void 0,s={ambient:u(e.diffuse),diffuse:u(e.diffuse),opacity:1-(e.transparency||0),textureAlphaMode:r,textureAlphaCutoff:.33,textureId:T,doubleSided:!0,cullFace:0,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:E?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(s,t.materialParameters),B=new g(s,t),o.set(q,I,B)}n.push(B);const D=new y(B,c);v+=c.find(e=>"position"===e[0])?.[1]?.indices.length??0,r.push(D)}return{engineResources:[{name:p,stageResources:{textures:s,materials:n,geometries:r},pivotOffset:l.model.pivotOffset,numberOfVertices:v,lodThreshold:null}],referenceBoundingBox:j(r)}}function j(e){const t=l();return e.forEach(e=>{const r=e.boundingInfo;null!=r&&(c(t,r.bbMin),c(t,r.bbMax))}),t}function M(e){switch(e){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;default:return 0}}function P(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const U=new i(1,2,"wosr");export{w as l,A as p};
