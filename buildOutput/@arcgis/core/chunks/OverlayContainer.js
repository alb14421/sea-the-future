/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{t}from"./common.js";import{b as e,m as s,c as o,e as i,r}from"./mat3.js";import{c as a}from"./mat3f32.js";import{f as n}from"./vec2f32.js";import{f as p}from"./vec3f32.js";import{normalizeMapX as d}from"../geometry/support/normalizeUtils.js";import{h as l}from"./unitUtils.js";import{g as h}from"./viewpointUtils.js";import{W as c}from"./WGLContainer.js";import{d as u}from"./maybe.js";import{M as f}from"./FeatureCommandQueue.js";import{s as m}from"./utils27.js";import{G as v,F as y,h as x,l as w,V as g,a as _,t as M,n as S,o as j,u as b,M as O,S as R,p as A,q as D,U as T,r as z,T as G}from"./GraphShaderModule.js";import{_ as U,c as I}from"./tslib.es6.js";import{a as P,D as W}from"./enums.js";import{V as C}from"./VertexElementDescriptor.js";class q extends D{}U([j(0,g)],q.prototype,"pos",void 0),U([j(1,g)],q.prototype,"uv",void 0);class B extends T{}U([b(O)],B.prototype,"dvs",void 0);class E extends T{}U([b(g)],E.prototype,"perspective",void 0),U([b(g)],E.prototype,"texSize",void 0),U([b(y)],E.prototype,"wrapAroundShift",void 0),U([b(y)],E.prototype,"opacity",void 0),U([b(R)],E.prototype,"texture",void 0);class F extends v{constructor(){super(...arguments),this.type="OverlayShader"}vertex(t){const e=t.uv.divide(this.config.texSize),s=new y(1).add(x(e,this.config.perspective)),o=new w(t.pos.add(new g(this.config.wrapAroundShift,0)),1),i=this.transform.dvs.multiply(o);return{uv:e,glPosition:new _(i.xy.multiply(s),0,s)}}fragment(t){const e=M(this.config.texture,t.uv).multiply(this.config.opacity),s=new S;return s.fragColor=e,s}}U([b(B)],F.prototype,"transform",void 0),U([b(E)],F.prototype,"config",void 0),U([I(0,A(q))],F.prototype,"vertex",null),U([I(0,A(class extends z{}))],F.prototype,"fragment",null);class L extends G{constructor(){super(...arguments),this.type=20,this._mesh=null,this.shaders={overlay:new F}}render(t,e){const{context:s,painter:o}=t,i=this._getMesh(t,e);o.setPipelineState(m);const{isWrapAround:r,wrapAroundShift:a}=e.config,n={...e.config,wrapAroundShift:0},p={shader:this.shaders.overlay,uniforms:{transform:e.transform,config:n},defines:null,optionalAttributes:null,useComputeBuffer:!1};o.setPipelineState({...m,stencil:{write:!1,test:{compare:514,op:{fail:7680,zFail:7680,zPass:7681},ref:0,mask:255}}}),o.submitDrawMeshUntyped(s,p,i),r&&(n.wrapAroundShift=a,o.submitDrawMeshUntyped(s,p,i))}shutdown(){u(this._mesh)}_getMesh(t,e){const{context:s}=t;if(this._mesh){const t=this._mesh.vertexBuffers.get("positions");if(!t)throw new Error("Buffer not found");t.setData(e.position)}else{const t=null!=e.index?e.index.length:e.position.length/2;this._mesh=new f(s,{vertex:{positions:{data:e.position,layout:[new C("pos",2,W.FLOAT,0,8)]},uvs:{data:e.tex,layout:[new C("uv",2,W.UNSIGNED_SHORT,0,4)]}},index:null!=e.index?{index:{data:e.index}}:void 0,groups:[{index:null!=e.index?"index":void 0,primitive:P.TRIANGLE_STRIP}],parts:[{group:0,start:0,count:t}]})}return this._mesh}}class N extends c{constructor(){super(...arguments),this._viewStateId=-1,this._dvsMat3=a(),this._overlayTechnique=new L}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const e of this.children)e.beforeRender(t)}doRender(t){if(1!==t.drawPhase||!this.visible)return;super.doRender(t);const e=this._overlayTechnique;for(const s of this.children)s.draw(t,e)}onDetach(){this._overlayTechnique.shutdown()}_updateMatrices(a){const{state:l}=a,{id:h,size:c,pixelRatio:u,resolution:f,rotation:m,viewpoint:v,displayMat3:y}=l;if(this._viewStateId===h)return;const x=t(m),w=u*c[0],g=u*c[1];this._localOrigin=v.targetGeometry.clone();const{x:_,y:M}=this._localOrigin,S=d(_,l.spatialReference);this._localOrigin.x=S,this._localOrigin.y=M;const j=f*w,b=f*g,O=e(this._dvsMat3);s(O,O,y),o(O,O,n(w/2,g/2)),i(O,O,p(w/j,-g/b,1)),r(O,O,-x),this._viewStateId=h}_updateOverlays(e,s){const{state:o}=e,{rotation:i,spatialReference:r,worldScreenWidth:a,size:n,viewpoint:p}=o,d=this._localOrigin;let c,u=0;const f=l(r);if(f&&r.isWrappable){const e=n[0],s=n[1],d=t(i),l=Math.abs(Math.cos(d)),m=Math.abs(Math.sin(d)),v=Math.round(e*l+s*m),[y,x]=f.valid,w=h(r),{x:g,y:_}=p.targetGeometry,M=[g,_],S=[0,0];o.toScreen(S,M);const j=[0,0];let b;b=v>a?.5*a:.5*v;const O=Math.floor((g+.5*w)/w),R=y+O*w,A=x+O*w,D=[S[0]+b,0];o.toMap(j,D),j[0]>A&&(u=w),D[0]=S[0]-b,o.toMap(j,D),j[0]<R&&(u=-w),c={worldWidth:w,xBounds:[y,x]}}for(const t of s)t.updateDrawCoords(d,u,o,c)}}export{N as O};
