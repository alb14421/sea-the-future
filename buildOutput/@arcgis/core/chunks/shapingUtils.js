/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{b as t,m as e,t as s,r as i}from"./mat2d.js";import{c as o,t as n}from"./mat2df32.js";import{t as r,s as a}from"./vec2.js";import{c as h}from"./vec2f32.js";import{L as c}from"./Logger.js";import{R as f}from"./Rect.js";import{B as l}from"./BoundingBox.js";function m(t){switch(t){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return["right","bottom"];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return["center","bottom"];case"above-right":case"esriServerPointLabelPlacementAboveRight":return["left","bottom"];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return["right","middle"];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return["center","middle"];case"center-right":case"esriServerPointLabelPlacementCenterRight":return["left","middle"];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return["right","top"];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return["center","top"];case"below-right":case"esriServerPointLabelPlacementBelowRight":return["left","top"];default:return console.debug(`Found invalid placement type ${t}`),["center","middle"]}}function d(t){switch(t){case 1:case"right":return-1;case 0:case"center":return 0;case-1:case"left":return 1;default:return console.debug(`Found invalid horizontal alignment ${t}`),0}}function g(t){switch(t){case 1:case"top":return 1;case 0:case"middle":return 0;case-1:case 2:case"baseline":case"bottom":return-1;default:return console.debug(`Found invalid vertical alignment ${t}`),0}}const u=Math.PI/180;class _{constructor(t,e,s,i){this._rotationT=o(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const n=s.rect,r=new Float32Array(8);t*=i,e*=i;const a=s.code?n.width*i:s.metrics.width,h=s.code?n.height*i:s.metrics.height;this.width=a,this.height=h,r[0]=t,r[1]=e,r[2]=t+a,r[3]=e,r[4]=t,r[5]=e+h,r[6]=t+a,r[7]=e+h,this._data=r,this._setTextureCoords(n),this._scale=i,this._mosaic=s,this.x=t,this.y=e,this.maxOffset=Math.max(t+a,e+h)}get mosaic(){return this._mosaic}set angle(e){this._angle=e,t(this._rotationT,-e),this._setOffsets()}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:t,width:s}=this._mosaic.metrics,i=s*this._scale,r=Math.abs(t)*this._scale,a=new Float32Array(8);a[0]=this.x,a[1]=this.y,a[2]=this.x+i,a[3]=this.y,a[4]=this.x,a[5]=this.y+r,a[6]=this.x+i,a[7]=this.y+r;const h=e(o(),this._rotationT,this._transform);n(a,a,h);let c=1/0,f=1/0,m=-1/0,d=-1/0;for(let t=0;t<4;t++){const e=a[2*t],s=a[2*t+1];c=Math.min(c,e),f=Math.min(f,s),m=Math.max(m,e),d=Math.max(d,s)}const g=m-c,u=d-f,_=c+g/2,b=f+u/2;this._bounds=new l(_,b,g,u)}return this._bounds}setTransform(t){this._transform=t,this._offsets=null}_setOffsets(){this._offsets||(this._offsets={topLeft:[0,0],topRight:[0,0],bottomLeft:[0,0],bottomRight:[0,0]});const t=e(o(),this._rotationT,this._transform);this._offsets.topLeft[0]=this._data[0],this._offsets.topLeft[1]=this._data[1],this._offsets.topRight[0]=this._data[2],this._offsets.topRight[1]=this._data[3],this._offsets.bottomLeft[0]=this._data[4],this._offsets.bottomLeft[1]=this._data[5],this._offsets.bottomRight[0]=this._data[6],this._offsets.bottomRight[1]=this._data[7],r(this._offsets.topLeft,this._offsets.topLeft,t),r(this._offsets.topRight,this._offsets.topRight,t),r(this._offsets.bottomLeft,this._offsets.bottomLeft,t),r(this._offsets.bottomRight,this._offsets.bottomRight,t)}_setTextureCoords({x:t,y:e,width:s,height:i}){this._texcoords={topLeft:[t,e],topRight:[t+s,e],bottomLeft:[t,e+i],bottomRight:[t+s,e+i]}}}const b=(t,e)=>({code:0,page:0,sdf:!0,rect:new f(0,0,11,8),textureBinding:e,metrics:{advance:0,height:4,width:t,left:0,top:0}});function p(t,e){return t.forEach(t=>r(t,t,e)),{topLeft:t[0],topRight:t[1],bottomLeft:t[2],bottomRight:t[3]}}class x{constructor(t,e,s){this._rotation=0,this._decorate(t,e,s),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=e.length>1,this._hasRotation=0!==s.angle,this._transform=this._createGlyphTransform(this.bounds,s),this._borderLineSizePx=s.borderLineSizePx,(s.borderLineSizePx||s.hasBackground)&&([this.bounds,this.textBox]=this.shapeBackground(this._transform));for(const e of t)e.setTransform(this._transform)}setRotation(s){if(0===s&&0===this._rotation)return;this._rotation=s;const i=this._transform,n=t(o(),s);e(i,n,i);for(const t of this.glyphs)t.setTransform(this._transform)}_decorate(t,e,s){if(!s.decoration||"none"===s.decoration||!t.length)return;const i=s.scale,o="underline"===s.decoration?26:16,n=t[0].textureBinding;for(const s of e){const e=s.startX*i,r=s.startY*i,a=(s.width+s.glyphWidthEnd)*i;t.push(new _(e,r+o*i,b(a,n),1))}}shapeBackground(t){const e=(1.5+(this._borderLineSizePx||0))/2,s=this._borderLineSizePx?e:0,{xmin:i,ymin:o,xmax:n,ymax:r,x:a,y:h,width:c,height:f}=this.bounds,m=[i-8,o-8],d=[n+8,o-8],g=[i-8,r+8],u=[n+8,r+8],_=p([[m[0]-e,m[1]-e],[d[0]+e,d[1]-e],[m[0]+s,m[1]+s],[d[0]-s,d[1]+s]],t),b=p([[g[0]+s,g[1]-s],[u[0]-s,u[1]-s],[g[0]-e,g[1]+e],[u[0]+e,u[1]+e]],t),x=p([[m[0]-e,m[1]-e],[m[0]+s,m[1]+s],[g[0]-e,g[1]+e],[g[0]+s,g[1]-s]],t),w=p([[d[0]-s,d[1]+s],[d[0]+e,d[1]-e],[u[0]-s,u[1]-s],[u[0]+e,u[1]+e]],t),L={main:p([m,d,g,u],t),top:_,bot:b,left:x,right:w};return[new l(a,h,c+2*e,f+2*e),L]}get boundsT(){const t=this.bounds,e=a(h(),t.x,t.y);if(r(e,e,this._transform),this._hasRotation){const s=Math.max(t.width,t.height);return new l(e[0],e[1],s,s)}return new l(e[0],e[1],t.width,t.height)}_createBounds(t){let e=1/0,s=1/0,i=0,o=0;for(const n of t)e=Math.min(e,n.xTopLeft),s=Math.min(s,n.yTopLeft),i=Math.max(i,n.xBottomRight),o=Math.max(o,n.yBottomRight);const n=i-e,r=o-s;return new l(e+n/2,s+r/2,n,r)}_createGlyphTransform(t,e){const n=u*e.angle,r=o(),c=h();return s(r,r,a(c,e.xOffset,-e.yOffset)),e.useCIMAngleBehavior?i(r,r,n):(s(r,r,a(c,t.x,t.y)),i(r,r,n),s(r,r,a(c,-t.x,-t.y))),r}}class w{constructor(t,e,s,i,o,n){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(e,s)),this.end=Math.max(0,Math.max(e,s)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=i,this.yMin=o,this.yMax=n}}const L=t=>10===t,y=t=>32===t;function v(t,e){const s=e.scale,i=new Array,{glyphs:o,isRightToLeft:n}=t,r=function(t,e,s){const i=new Array,o=1/s.scale,n=s.maxLineWidth*o,r=e?t.length-1:0,a=e?-1:t.length,h=e?-1:1;let c=r,f=0,l=0,m=c,d=m,g=0,u=1/0,_=0;for(;c!==a;){const{code:e,metrics:s}=t[c],o=Math.abs(s.top);if(L(e)||y(e)||(u=Math.min(u,o),_=Math.max(_,o+s.height)),L(e))c!==r&&(i.push(new w(t,m,c-h,f,u===1/0?0:u,_)),u=1/0,_=0),f=0,m=c+h,d=c+h,l=0;else if(y(e))d=c+h,l=0,g=s.advance,f+=s.advance;else if(f>n){if(d!==m){const e=d-2*h;f-=g,i.push(new w(t,m,e,f-l,u,_)),u=1/0,_=0,m=d,f=l}else i.push(new w(t,m,c-h,f,u,_)),u=1/0,_=0,m=c,d=c,f=0;f+=s.advance,l+=s.advance}else f+=s.advance,l+=s.advance;c+=h}const b=new w(t,m,c-h,f,u,_);return b.start>=0&&b.end<t.length&&i.push(b),i}(o,n,e),a=r.length?function(t,e){let s=0;for(let e=0;e<t.length;e++){const{width:i}=t[e];s=Math.max(i,s)}const i="underline"===e.decoration?4:0,o=t[0].yMin;return{x:0,y:o,height:t[t.length-1].yMax+e.lineHeight*(t.length-1)+i-o,width:s}}(r,e):{y:0,height:0},h=function(t){if(!t)return 0;switch(t){case"Left":case"left":return-1;case"Right":case"right":return 1;case"Justify":return c.getLogger("esri.views.2d.engine.webgl.alignmentUtils").warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."),0;case"Center":case"center":return 0}}(e.horizontalAlignment),f=function(t){if(!t)return 0;switch(t){case"Top":case"top":return 1;case"Center":case"middle":return 0;case"Baseline":case"baseline":return 2;case"Bottom":case"bottom":return-1}}(e.verticalAlignment),l=2===f?1:0,m=l?0:f-1,d=(1-l)*-a.y+m*(a.height/2)+-22*(l?1:0);for(let n=0;n<r.length;n++){const{start:a,end:c,width:f}=r[n];let l=-1*(h+1)*(f/2)-3;const m=(t.isRightToLeft?r.length-1-n:n)*e.lineHeight+d-3;r[n].startX=l,r[n].startY=m;for(let t=a;t<=c;t++){const e=o[t];if(L(e.code))continue;const n=new _(l+e.metrics.left,m-e.metrics.top,e,s);l+=e.metrics.advance,i.push(n)}}return new x(i,r,e)}export{g as a,m as b,d as g,v as s};
