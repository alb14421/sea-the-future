/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../Camera.js";import{C as t}from"./Cyclical.js";import{L as n}from"./Logger.js";import{e as r,r as a,h as i}from"./mathUtils.js";import{throwIfAborted as o}from"../core/promiseUtils.js";import{z as s,x as c,l,e as u}from"./vec3.js";import{c as f,b as m}from"./vec3f64.js";import{U as p}from"./unitUtils.js";import d from"../geometry/Point.js";import{project as h,projectWithZConversion as v}from"./projectionUtils.js";import g from"../geometry/SpatialReference.js";import{p as y,a as R}from"./projectPointToVector.js";import{p as w,a as x}from"./projectVectorToPoint.js";import{v as M,d as T,toRenderCamera as z}from"../views/3d/webgl.js";import{g as j}from"./earthUtils.js";import{g as S}from"./ElevationProvider.js";import{i as C}from"./spatialReferenceSupport.js";const b=()=>n.getLogger("esri.views.3d.support.cameraUtils"),P=96*39.37,A=f(),L=new t(-20037508.342788905,20037508.342788905),U=new t(-180,180);function H(e){return e.spatialReference??g.WGS84}function q(e,t,n,r,a){return M(e).headingTiltToDirectionUp(t,n,r,a)}function I(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper;return t/=r,n.width/2/n.pixelRatio/(P/t)/Math.tan(n.fovX/2)}function E(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper,a=t*Math.tan(n.fovX/2),i=n.width/2/n.pixelRatio;return P/(i/a)*r}function F(e,t,n,r){const a=r.levelAtScale(t),i=O(T(e,n.eye,n.viewForward,n.up).tilt),o=Math.max(a-i,0);return r.scaleAtLevel(o)}function G(e,t,n){const r=n.levelAtScale(e),a=O(t);return n.scaleAtLevel(r+a)}function O(e){return 2*((e>90?180-e:e)/90)**2}function X(e,t,n=0){const r=z(e,t);return r?function(e,t,n=0){const r=e.basemapTerrain?.tilingScheme;if(!r)return 0;const a=p(e.spatialReference).radius,i=2===e.state.viewingMode?t.eye[2]:l(t.eye)-a;return F(e,E(e,Math.abs(i-n)),t,r)}(e,r,n):0}function k(e,t,n,o,s){if(0===t)return 0;const u=c(n.eye,o),f=e.basemapTerrain?.tilingScheme;if(!f)return b().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),u;let m=u;const d=T(e,n.eye,n.viewForward,n.up),h=d.tilt>90;if(e.state.isLocal){const a=(I(e,G(t,d.tilt,f))-Math.abs(n.eye[2]-s[2]))/Math.cos(r(d.tilt));return m=h?m-a:m+a,m}let v=1/0,g=0,y=N(e,d.heading,d.tilt,o,u,1);if(!y)return m;const R=l(s);for(;v>1&&g<100;){const s=l(y.eye),u=h?180-y.tilt:y.tilt,w=r(u),x=Math.sin(w)*s,M=Math.cos(w)*s,T=I(e,G(t,y.tilt,f)),z=h?R-T:R+T,j=i(x/z),S=Math.cos(j)*z-M,C=c(y.eye,o);m=h?C-S:C+S,y=N(e,d.heading,d.tilt,o,m,1);const b=ue(e,y,a(n.fov));if(!y||!b)return m;const P=X(e,b,R-p(e.spatialReference).radius);v=Math.abs(t-P),++g}return m}async function D(e,t,n,r,a,i){return W(e,t,I(e,n),r,a,i)}function V(e,t,n,r,a,i){return ue(e,N(e,r.heading,r.tilt,t,n,a),r.fov,i)}async function W(e,t,n,r,a,i){const s=await Z(e,r.heading,r.tilt,t,n,a,i);return o(i),fe(e,s,r.fov,i)}function Y(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,A,e.spatialReference)&&e.elevationProvider&&(S(e.elevationProvider,A)??0)>A[2]-1)}function N(e,t,n,r,a,i){const o=r instanceof d?r:null,s=function(e,t){const n=f();if(null==t)return u(n,e.state.camera.center);if(t instanceof d){if(!y(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:a}=e;if(null==t.z&&null!=r&&null!=a){const r=S(a,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return u(n,t)}(e,r);return B(e,t,n,o,s,a,i)}async function Z(e,t,n,r,a,i,s){const c=r instanceof d?r:null,l=await async function(e,t,n){const r=f();if(null==t)return u(r,e.state.camera.center);if(t instanceof d){const{renderSpatialReference:a,basemapTerrain:i,elevationProvider:s}=e,c=t.spatialReference;if(await R(t,r,a,0,{signal:n}),o(n),null==t.z&&null!=i&&null!=s){const a=await s.queryElevation(t.x,t.y,t.z??0,c,"ground",n);o(n),null!=a&&e.renderCoordsHelper.setAltitude(r,a)}return r}return u(r,t)}(e,r,s);return o(s),J(e,t,n,c,l,a,i,s)}function B(e,t,n,r,a,i,o){if(null==a)return null;if(!r&&(r=new d({spatialReference:H(e)}),!w(a,e.renderSpatialReference,r)))return null;const s=K(e,t,n,a,i,o);if(Q(e,n,o)&&Y(e,s.eye)){const{tilt:o,mode:s}=$(e,n,a,i);return B(e,t,o,r,a,i,s)}return _(s,a)}async function J(e,t,n,r,a,i,s,c){r||(r=new d({spatialReference:H(e)}),await x(a,e.renderSpatialReference,r,{signal:c})||(r=null)),o(c);const l=K(e,t,n,a,i,s);if(Q(e,n,s)&&await async function(e,t,n){if(Y(e,t))return!0;const{elevationProvider:r,spatialReference:a,renderCoordsHelper:i}=e;if(null==r||!i.fromRenderCoords(t,A,a))return!1;const[s,c,l]=A,u=await r.queryElevation(s,c,l,a,"ground",n)??0;return o(n),u>l-1}(e,l.eye,c)){o(c);const{tilt:s,mode:l}=$(e,n,a,i);return J(e,t,s,r,a,i,l,c)}return _(l,a)}function K(e,t,n,r,a,i){const o=function(e,t,n,r,a,i){let o=0;return 1===i&&oe(e,r,a)?(t=0,o=function(e,t,n,r){const a=le(e,r,t,n);if(!e.state.constraints.tilt)return a;const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const o=i.min*(1-se)+i.max*se;return Math.min(a,o)}(e,a,n,r)):o=le(e,r,a,n),o=e.state.constraints.clampTilt(a,o),{heading:t,tilt:n=ce(e,r,a,o)}}(e,t,n,r,a=Math.max(a,e.state.constraints.minimumPoiDistance),i);return(0,M(e).eyeForCenterWithHeadingTilt)(r,a,o.heading,o.tilt)}function Q(e,t,n){const r=e.map.ground.navigationConstraint;return 1===n&&e.state.isGlobal&&t>0&&(null==r||"stay-above"===r.type)}function $(e,t,n,r){const a=ce(e,n,r,function(e,t,n,r){let a=le(e,r,t,n);if(!e.state.constraints.tilt)return a;const i=e.state.constraints.tilt(t);return a=Math.min(a,.5*Math.PI),i.min*(1-se)+a*se}(e,r,t,n));return{tilt:a,mode:t-a<1?0:1}}function _(e,t){return{...e,center:m(t)}}function ee(e,t){const{state:n,spatialReference:r}=e,a=t.spatialReference;return n.isGlobal&&C(a,1)||n.isLocal&&r.equals(a)}function te(e,t){let n,r,a;if(e.state.isGlobal){const e=new d(t.xmin,t.ymin,t.spatialReference),i=new d(t.xmax,t.ymax,t.spatialReference),o=t.spatialReference.isGeographic?U:L;n=new d({x:o.center(e.x,i.x),y:(i.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const s=p(t.spatialReference),c=j(n,e,i);r=c.lon,a=c.lat,o.diff(e.x,i.x)>o.range/2&&(r+=s.halfCircumference),r=Math.min(r,s.halfCircumference),a=Math.min(a,s.halfCircumference)}else{const i=e.renderSpatialReference??t.spatialReference;i.equals(t.spatialReference)||(t=h(t,i)),r=t.xmax-t.xmin,a=t.ymax-t.ymin;const o=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new d({x:t.xmin+.5*r,y:t.ymin+.5*a,z:o,spatialReference:i})}const i=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,o=e.state.camera,s=1/Math.tan(o.fovX/2),c=1/Math.tan(o.fovY/2),l=1/Math.tan(o.fov/2);return{center:n,distance:Math.max(.5*r*s,.5*a*c,.5*i*l)/1}}async function ne(e,t,n,r,a,i){const s=ee(e,t)?t:await v(t,e.spatialReference,{signal:i});o(i);const{center:c,distance:l}=te(e,s),u=await Z(e,n,r,c,l,a,i);return o(i),fe(e,u,e.camera.fov,i)}function re(e,t,n,r,a,i){let o;try{o=ee(e,t)?t:h(t,e.spatialReference)}catch(e){return null}const{center:s,distance:c}=te(e,o),l=N(e,n,r,s,c,a);return null==l?null:ue(e,l,e.camera.fov,i)}function ae(e,t,n){const r=e.renderSpatialReference,a=new d({spatialReference:H(e)});if(!w(n,r,a))return null;const i=Math.tan(t.fovX/2),o=Math.tan(t.fovY/2),c=s(t.eye,n),l=2*c*i*1,u=2*c*o*1;return M(e).toExtent(e,a,l,u)}function ie(e,t){return M(e).toArea(e,t)}function oe(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>8)return!0;const a=t,i=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return c(a,i)/(Math.tan(.5*e.state.camera.fov)*r)>5}const se=.7;function ce(e,t,n,r){return M(e).lookAtTiltToEyeTilt(r,t,n)}function le(e,t,n,r){return M(e).eyeTiltToLookAtTilt(r,t,n)}function ue(t,n,r,a){if(null==n)return null;const i=t.renderSpatialReference,o=new d({spatialReference:H(t)});return w(n.eye,i,o)?(a??=new e,a.position=o,a.heading=n.heading,a.tilt=n.tilt,a.fov=r,a):null}async function fe(t,n,r,a){const i=t.renderSpatialReference,s=new d({spatialReference:H(t)});return await x(n.eye,i,s,{signal:a}),o(a),new e(s,n.heading,n.tilt,r)}function me(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);b().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function pe(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);b().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}export{V as a,W as b,D as c,E as d,ne as e,re as f,H as g,q as h,ie as i,F as j,me as k,N as l,I as s,ae as t,k as v,pe as z};
