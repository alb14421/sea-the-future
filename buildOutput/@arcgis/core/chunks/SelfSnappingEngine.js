/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Accessor.js";import s from"../core/Collection.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{subclass as i}from"../core/accessorSupport/decorators/subclass.js";import{a as o,b as n}from"./Cyclical.js";import{v as a,a as p}from"./quantityUtils.js";import{c}from"./vec3f64.js";import{c as l}from"./elevationInfoUtils.js";import{d as m,a as h,m as d,e as g,f as j}from"./normalizedPoint.js";import{m as u}from"./unitUtils.js";import{u as f,q as v,d as x,g as y,k as S,j as w,l as V}from"./vec2.js";import{d as T}from"./Settings.js";import{f as L,h as P,p as U,V as _,s as E}from"./constraints.js";import{v as M,L as R,P as C,R as k,b}from"./SnappingManager.js";import{r as q,p as F}from"./angularMeasurementUtils.js";import{c as O}from"./vec2f64.js";import{p as D,a as I}from"./geometry2dUtils.js";import{a as G,h as H,k as N}from"./vec3.js";import"../core/Handles.js";import"./maybe.js";import"./get.js";import"./utils.js";import"./handleUtils.js";import"./Lifecycle.js";import"./metadata.js";import"./ObjectPool.js";import"./ObservableBase.js";import"./tracking.js";import"./watch.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"../core/Error.js";import"./object.js";import"../config.js";import"./string.js";import"./events.js";import"./SetUtils.js";import"./SimpleTrackingTarget.js";import"./ensureType.js";import"./MapUtils.js";import"./Warning.js";import"../core/Evented.js";import"./shared.js";import"./SimpleObservable.js";import"./jsonUtils.js";import"./mathUtils.js";import"./unitConversionUtils.js";import"./lengthUtils.js";import"./dehydratedPoint.js";import"./jsonMap.js";import"./pe.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./persistableUrlUtils.js";import"./common.js";import"../Color.js";import"./colorUtils.js";import"../core/JSONSupport.js";import"../core/reactiveUtils.js";import"../core/sql.js";import"./timeUtils.js";import"./date.js";import"./locale.js";import"./constants.js";import"./datetime.js";import"../rest/support/Query.js";import"../core/accessorSupport/decorators/cast.js";import"./enumeration.js";import"./writer.js";import"../geometry/Point.js";import"./reader.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/support/jsonUtils.js";import"../geometry/Extent.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./coordsUtils.js";import"./extentUtils.js";import"./boundsUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"./DataLayerSource.js";import"../layers/support/Field.js";import"./domains.js";import"../layers/support/CodedValueDomain.js";import"../layers/support/Domain.js";import"../layers/support/InheritedDomain.js";import"../layers/support/RangeDomain.js";import"./fieldType.js";import"./FullTextSearch.js";import"../core/Clonable.js";import"./spatialRelationships.js";import"../rest/support/StatisticDefinition.js";import"../time/TimeExtent.js";import"./InputManager.js";import"./Queue.js";import"./signal.js";import"./keybindings.js";import"./utils11.js";import"./Version2.js";import"./Version.js";import"./vec4.js";import"./vec4f64.js";import"./geodesicConstants.js";import"../geometry/support/geodesicUtils.js";import"./plane.js";import"./vector.js";import"./mat3f64.js";import"./mat4f64.js";import"./quatf64.js";import"./mathUtils2.js";import"./sphere.js";import"./mat4.js";import"./ray.js";import"./mat3.js";import"./asyncUtils.js";import"./projectionUtils.js";import"./projectBuffer.js";import"./projectXYZToVector.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";import"../views/interactive/snapping/SnappingOptions.js";import"../views/interactive/snapping/FeatureSnappingLayerSource.js";import"./RightAngleSnappingHint.js";import"./screenUtils.js";import"./geodesicLengthMeasurementUtils.js";import"./projectVectorToVector.js";import"./projectPointToVector.js";import"./spatialReferenceEllipsoidUtils.js";import"../geometry/operators/geodeticLengthOperator.js";import"./geodeticCurveType.js";import"./geodesicMeasurementUtils.js";class z{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=T.shortLineThreshold*T.shortLineThreshold}snap(e,t){return null!=t.vertexHandle?"vertex"!==t.vertexHandle.type?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(m(e.leftVertex.pos,this.view,t),m(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:s}){return 0===this.squaredShortLineThreshold||L(M(t,s,l,this.view),M(e,s,l,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:s}){const r=u(s);return f(h(e),h(t))*r<T.verticalLineThresholdMeters}squaredProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,s=e*t;return s*s}}class A extends z{constructor(e,t,s){super(e,t),this._geodesicLengthMeasurementUtils=s}snapNewVertex(e,t){const s=t.editGeometryOperations.data.parts[0],r=s.segments.length,i=[];if(r<1)return i;const{spatialReference:o}=t,n=M(e,o,l,this.view),{view:a}=this,p=s.segments[r-1];let c=p;do{if(this.edgeExceedsShortLineThreshold(c,t)){const s=P(c,a,t);this._processCandidateProposal(s.left,s.right,e,n,t,i)}c=c.leftVertex.leftSegment}while(c&&c!==p);return i}snapExistingVertex(e,t){const s=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2)return s;const{view:o}=this,{spatialReference:n}=t,a=M(e,n,l,o),p=r.leftSegment,c=r.rightSegment;p&&c&&this.edgeExceedsShortLineThreshold(p,t)&&this.edgeExceedsShortLineThreshold(c,t)&&this._processCandidateProposal(m(p.leftVertex.pos,o,t),m(c.rightVertex.pos,o,t),e,a,t,s);const h=i.segments[0];let d=h;do{if(d!==r.leftSegment&&d!==r.rightSegment&&this.edgeExceedsShortLineThreshold(d,t)){const r=P(d,o,t);this._processCandidateProposal(r.left,r.right,e,a,t,s)}d=d.rightVertex.rightSegment}while(d&&d!==h);return s}_processCandidateProposal(e,t,s,r,i,m){const{spatialReference:h,pointer:j}=i,u=c();!function(e,t,s,r,i,c){(function(e,t,s,r,{spatialReference:i},c){const l=q(t,s,i,i);if(null==l)return!1;const m=q(s,r,i,i);if(null==m)return!1;const h=c.geodesicDistance(s,r,i);if(null==h)return!1;const d=Math.abs(o.shortestSignedDiff(l,m))>Math.PI/2?n.normalize(l+Math.PI):l;return F(e,s,i,a(h,"meters"),p(d,"radians","geographic"),"geodesic"),e[2]=r[2],!0})(e,t,s,r,i,c)||function(e,t,s,r){U(t,{start:s,end:r,type:1},e),e[2]=t[2]}(e,r,t,s)}(u,e,t,s,i,this._geodesicLengthMeasurementUtils);const f=d(g(u));L(r,M(f,h,l,this.view))<this.squaredProximityThreshold(j)&&m.push(new R({lineStart:e,lineEnd:t,targetPoint:f,isDraped:"on-the-ground"===i.elevationInfo?.mode}))}}class B extends z{snapNewVertex(e,t){const s=t.editGeometryOperations.data.parts[0],r=s.segments.length,i=s.vertices.length,o=[];if(r<2)return o;const{view:n}=this,a=M(e,t.spatialReference,l,n),p=m(s.vertices[i-1].pos,n,t),c=m(s.vertices[0].pos,n,t),h=s.segments[r-1];let d=h;do{if(this.edgeExceedsShortLineThreshold(d,t)){const s=P(d,n,t);this._checkEdgeForParallelLines(s,p,e,a,t,o),this._checkEdgeForParallelLines(s,c,e,a,t,o)}d=d.leftVertex.leftSegment}while(d&&d!==h);return o}snapExistingVertex(e,t){const s=[],r=t.vertexHandle,i=r.part;if(i.segments.length<3)return s;const{view:o}=this,n=M(e,t.spatialReference,l,o),a=r.leftSegment,p=r.rightSegment,c=i.vertices[0],h=m(c.pos,o,t),d=i.vertices.length,g=i.vertices[d-1],j=m(g.pos,o,t),u=i.segments[0];let f=u;do{if(f!==a&&f!==p&&this.edgeExceedsShortLineThreshold(f,t)){const i=P(f,o,t);a&&this._checkEdgeForParallelLines(i,m(a.leftVertex.pos,o,t),e,n,t,s),p&&this._checkEdgeForParallelLines(i,m(p.rightVertex.pos,o,t),e,n,t,s),r===c?this._checkEdgeForParallelLines(i,j,e,n,t,s):r===g&&this._checkEdgeForParallelLines(i,h,e,n,t,s)}f=f.rightVertex.rightSegment}while(f&&f!==u);return s}_checkEdgeForParallelLines(e,t,s,r,i,o){const n=e.left,a=e.right;if(D(Q,h(t),h(n),h(a)),v(Q,h(t))<T.parallelLineThreshold)return;D(Q,h(s),h(n),h(a),h(t));const{spatialReference:p,pointer:c}=i,m=d(j(Q[0],Q[1],s[2]));if(L(r,M(m,p,l,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(m,t,i)||this.isVertical(n,a,i))return;if(function(e,t){const s=e.left,r=e.right;for(const i of t)if(D(Q,h(r),h(i.constraint.start),h(i.constraint.end),h(s)),v(Q,h(r))<T.parallelLineThreshold)return i.addReferenceLine(e),!0;return!1}(e,o))return;o.push(new C({referenceLine:e,lineStart:t,targetPoint:m,isDraped:"on-the-ground"===i.elevationInfo?.mode}))}}}const Q=O();class J extends z{constructor(e,t,s){super(e,t),this._geodesicLengthMeasurementUtils=s}snapNewVertex(e,t){const s=t.editGeometryOperations.data.parts[0],r=[];if(s.vertices.length<2)return r;const{view:i}=this,o=M(e,t.spatialReference,l,i),n=s.vertices.at(-1);this._checkForSnappingCandidate(1,r,n.leftSegment,n,n.leftSegment.leftVertex,e,o,t);const a=s.vertices[0];return this._checkForSnappingCandidate(2,r,a.rightSegment,a,a.rightSegment.rightVertex,e,o,t),r}snapExistingVertex(e,t){const s=[],r=t.vertexHandle;if(r.part.vertices.length<3)return s;const{view:i}=this,o=M(e,t.spatialReference,l,i),n=r.leftSegment,a=r.rightSegment;if(n?.leftVertex.leftSegment){const r=n.leftVertex.leftSegment;this._checkForSnappingCandidate(3,s,r,r.rightVertex,r.leftVertex,e,o,t)}if(a?.rightVertex.rightSegment){const r=a.rightVertex.rightSegment;this._checkForSnappingCandidate(3,s,r,r.leftVertex,r.rightVertex,e,o,t)}return s}_checkForSnappingCandidate(e,t,s,r,i,o,l,d){if(!this.edgeExceedsShortLineThreshold(s,d))return;const g=this.view,j=m(r.pos,g,d),u=m(i.pos,g,d);!function(e,t,s,r,i,o){(function(e,t,s,r,{spatialReference:i},o){const l=q(t,s,i,i);if(null==l)return!1;const m=q(s,r,i,i);if(null==m)return!1;const h=Math.sign(n.shortestSignedDiff(l,m))*Math.PI*.5,d=p(l+h,"radians","geographic"),g=c(),j=o.geodesicDistance(s,r,i);return null!=j&&(F(g,s,i,a(j,"meters"),d,"geodesic"),H(e,g,s),!0)})(e,t,s,r,i,o)||function(e,t,s){const r=x(W,h(s),h(t));N(e,r[1],-r[0],0)}(e,t,s)}(X,u,j,o,d,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,u,j,X,o,l,d)}_checkForSnappingCandidateAlongProjectedRay(e,t,s,r,i,o,n,a){const{spatialReference:p,pointer:m}=a,u=x(W,h(o),h(r)),f=y(i,u)/S(i),v=w(W,h(r),i,f),V=d(j(v[0],v[1],o[2]));if(L(n,M(V,p,l,this.view))>this.squaredProximityThreshold(m)||this.isVertical(V,r,a)||this.isVertical(r,s,a))return;const T=G(c(),r,i,Math.sign(f));t.push(new k({targetPoint:V,constraint:new _(r,g(T)),previousVertex:s,otherVertex:r,otherVertexType:1,selfSnappingType:e,isDraped:"on-the-ground"===a.elevationInfo?.mode}))}}const W=O(),X=c();class Y extends z{snapNewVertex(e,t){const s=t.editGeometryOperations.data.parts[0],r=[],i=s.vertices.length;if("polygon"!==t.editGeometryOperations.data.type||i<2)return r;const{view:o}=this,n=s.vertices[0],a=s.vertices[i-1],p=m(n.pos,o,t),c=m(a.pos,o,t);return this._processCandidateProposal(p,c,e,t,r),r}snapExistingVertex(e,t){const s=[],r=t.vertexHandle,i=r.part;if(i.segments.length<2)return s;if("polyline"===t.editGeometryOperations.data.type&&(0===r.index||r.index===i.vertices.length-1))return s;const{view:o}=this,n=m(r.leftSegment.leftVertex.pos,o,t),a=m(r.rightSegment.rightVertex.pos,o,t);return this._processCandidateProposal(n,a,e,t,s),s}_processCandidateProposal(e,t,s,r,i){if(!this.exceedsShortLineThreshold(e,t,r))return;const o=V(Z,h(e),h(t),.5),n=.5*f(h(e),h(t)),a=I(Z,h(s),o,n),p=d(j(a[0],a[1],s[2])),{spatialReference:c,pointer:m}=r,g=M(s,c,l,this.view);if(L(g,M(p,c,l,this.view))<this.squaredProximityThreshold(m)){if(this.isVertical(e,p,r)||this.isVertical(p,t,r))return;i.push(new b({targetPoint:p,point1:e,point2:t,isDraped:"on-the-ground"===r.elevationInfo?.mode}))}}}const Z=O();let K=class extends t{constructor(e){super(e),this.updating=!1,this._snappers=new s,this._domain=2}initialize(){this._snappers.push(new B(this.view,this.options),new A(this.view,this.options,this.geodesicLengthMeasurementUtils),new J(this.view,this.options,this.geodesicLengthMeasurementUtils),new Y(this.view,this.options))}set options(e){this._set("options",e);for(const t of this._snappers)t.options=e}async fetchCandidates(e,t,s){if(!(t&this._domain&&this.options.effectiveSelfEnabled))return[];const r=[];for(const t of this._snappers.items)for(const i of t.snap(e,s))r.push(i);return E(e,r),r}};e([r({readOnly:!0})],K.prototype,"updating",void 0),e([r({constructOnly:!0})],K.prototype,"view",void 0),e([r({constructOnly:!0})],K.prototype,"geodesicLengthMeasurementUtils",void 0),e([r()],K.prototype,"options",null),K=e([i("esri.views.interactive.snapping.SelfSnappingEngine")],K);export{K as SelfSnappingEngine};
