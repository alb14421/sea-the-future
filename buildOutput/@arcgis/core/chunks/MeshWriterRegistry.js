/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{p as e}from"./screenUtils.js";import{G as t}from"./labelPoint.js";import{m as s}from"./rasterizingUtils.js";import{e as i,f as r}from"./CIMSymbolHelper.js";import{D as o,s as n,p as a,E as c,F as l,b as h,a as u}from"./definitions.js";import{M as d,g as f,a as p,L as m,c as g,p as y,b as _,t as x,A as P,d as M,e as v,f as b,G as w,T as S,h as k,C as I,P as z,O as T,i as A,j as L,k as D,F as E}from"./TexturedLineMeshWriter.js";import{M as B,i as R}from"./UpdateTracking2D.js";import C from"../Color.js";import{a as F,g as W}from"./grouping.js";import{D as Y}from"./enums.js";import{g as O,h as G,i as N}from"./constants4.js";import{L as j}from"./TurboLine.js";import{m as X}from"./MapUtils.js";import{n as H}from"./string.js";import{b as V,t as U,c as Q,r as Z}from"./mat2d.js";import{c as q}from"./mat2df32.js";import{t as $,s as J,b as K,e as ee,i as te,a as se}from"./vec2.js";import{f as ie}from"./vec2f32.js";import{c as re}from"./vec2f64.js";import{h as oe,a as ne}from"./featureConversionUtils.js";import{O as ae}from"./OptimizedGeometry.js";import{B as ce}from"./BoundingBox.js";import{L as le,e as he}from"./utils30.js";import{c as ue}from"./mathUtils.js";import{s as de,g as fe,a as pe}from"./shapingUtils.js";import{o as me}from"./utils6.js";import{i as ge,clone as ye}from"../core/lang.js";import _e from"../core/Error.js";import{L as xe}from"./Logger.js";import{e as Pe}from"./ArcadeExpression.js";import{a as Me}from"./ComputedAttributeStorage.js";class ve{static getPlacement(e,t,s,r,o){const n=i(s);return n?(-1===t&&e.invertY(),n.execute(e,s,r,o)):null}}class be extends d{}function we(e){return e instanceof Se?e:"object"==typeof e&&"type"in e?Ae[e.type].hydrate(e):new ke(e)}class Se{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}}class ke extends Se{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,s,i]=this.value;return null!=i?R.vector4.encode([e,t||0,s||0,i]):R.vector3.encode([e,t||0,s||0])}return R.scalar.encode(this.value)}}class Ie extends Se{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new Ie(e,we(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof ke))return this;const[t,s,i,r]=e.value,o=this._config.translation.from[0],n=this._config.translation.from[1],a=this._config.rotation.from,c=this._config.scale.from;if(o===this._config.translation.to[0]&&n===this._config.translation.to[1]&&a===this._config.rotation.to&&c===this._config.scale.to){const e=i+a,l=r*c,h=Math.sin(i),u=Math.cos(i);return new ke([u*r*o-h*r*n+t,h*r*o+u*r*n+s,e,l])}return new Ie(this._config,e)}get instructions(){return R.animatedTransform.encode(this._config)}}class ze extends Se{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ze(e,we(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof ke))return this;const[t,s,i,r]=e.value,o=this._config.color.from[0],n=this._config.color.from[1],a=this._config.color.from[2];let c=this._config.color.from[3];const l=this._config.opacity.from;return o===this._config.color.to[0]&&n===this._config.color.to[1]&&a===this._config.color.to[2]&&c===this._config.color.to[3]&&l===this._config.opacity.to?(c*=l,new ke([t*o,s*n,i*a,r*c])):new ze(this._config,e)}get instructions(){return R.animatedColor.encode(this._config)}}class Te extends Se{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new Te(e,we(e.parent))}simplify(){const e=this._parent.simplify();return e instanceof ke?new Te(this._config,e):this}get instructions(){return R.animatedShift.encode(this._config)}}const Ae={AnimatedTransform:Ie,AnimatedColor:ze,AnimatedShift:Te};function Le(e){return Ee(e.map(e=>Re(e)).map(e=>we(e).simplify()))}function De(e){const t=[];return t.push(e.transform),t.push(e.fromColor),t.push(e.toColor),t.push(e.colorMix),t.push(e.toOpacity),t.push(e.opacityMix),e?.shift?t.push(e?.shift):t.push([1,1,1,1]),t}function Ee(e){const t=[],s=[];let i=0;for(const r of e){const o=[...r.encode(),...R.ret.encode()];t.push([i+e.length,0,0,0]),s.push(...o),i+=o.length}return[...t,...s]}async function Be(e,t){const s=e;let i;if("number"==typeof s||"string"==typeof s||"boolean"==typeof s)i=s;else if(Array.isArray(s))i=await Promise.all(s.map(e=>Be(e,t)));else if("object"==typeof s)if("valueExpressionInfo"in s){const{valueExpressionInfo:e}=s,{expression:r}=e;i={...s,computed:await t.createComputedField({expression:r})}}else{i={};for(const e in s)i[e]=await Be(s[e],t)}return i}function Re(e,t,s){const i=e;let r;if("number"==typeof i||"string"==typeof i||"boolean"==typeof i)r=i;else if(Array.isArray(i))r=i.map(e=>Re(e,t,s));else if("object"==typeof i)if("type"in i&&null!=i.type&&"Process"===i.type)switch(i.op){case"ArcadeColor":{const e=Re(i.value,t,s);Fe(Array.isArray(e)&&4===e.length),r=[e[0]/255,e[1]/255,e[2]/255,e[3]]}break;case"Transparency":{const e=Re(i.value,t,s);Fe("number"==typeof e),r=1-e/100}break;case"Divide":case"Multiply":case"Add":{const e=Re(i.left,t,s);Fe("number"==typeof e);const o=Re(i.right,t,s);switch(Fe("number"==typeof o),i.op){case"Divide":r=e/o;break;case"Multiply":r=e*o;break;case"Add":r=e+o}}break;case"Random":{const e=Re(i.seed,t,s),o=Re(i.min,t,s),n=Re(i.max,t,s),a=t.getObjectId(),c=F(a||0);r=o+W(c,e)*(n-o)}break;case"Cond":{const e=Re(i.condition,t,s),o=Re(i.ifTrue,t,s),n=Re(i.ifFalse,t,s);r=e?o:n}break;case"MatchWinding":{const e=Re(i.sign,t,s);let o=Re(i.angle,t,s);if(e>0)for(;o<0;)o+=2*Math.PI;else for(;o>0;)o-=2*Math.PI;r=o}}else if("computed"in i)r=function(e){if(!("computed"in e))return e;let i=e.computed.readWithDefault(t,s,[255*e.defaultValue[0],255*e.defaultValue[1],255*e.defaultValue[2],e.defaultValue[3]]);if("string"==typeof i){const e=C.fromString(i);e&&(i=[e.r,e.g,e.b,e.a])}return i}(i);else{r={};for(const e in i)r[e]=Re(i[e],t,s)}return r}function*Ce(e){const t=e;if(Array.isArray(t))for(const e of t)yield*Ce(e);else if("object"==typeof t)if("type"in t&&null!=t.type&&"Process"===t.type)switch(t.op){case"ArcadeColor":case"Transparency":yield*Ce(t.value);break;case"Divide":case"Multiply":case"Add":yield*Ce(t.left),yield*Ce(t.right);break;case"Random":yield*Ce(t.seed),yield*Ce(t.min),yield*Ce(t.max);break;case"Cond":yield*Ce(t.condition),yield*Ce(t.ifTrue),yield*Ce(t.ifFalse);break;case"MatchWinding":yield*Ce(t.sign),yield*Ce(t.angle)}else if("computed"in t)yield t.computed;else for(const e in t)yield*Ce(t[e])}function Fe(e){if(!e)throw new Error("Assertion failed.")}const We={type:Y.SHORT,count:2,packPrecisionFactor:o,pack:({scaleInfo:e},{tileInfo:t})=>p(e,t)},Ye={type:Y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:e})=>(Fe(e),e)},Oe={type:Y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},Ge={type:Y.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Ne={type:Y.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:e})=>e},je={type:Y.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},Xe={type:Y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]},He={type:Y.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:e,normalY:t})=>[e,t]},Ve={type:Y.UNSIGNED_BYTE,count:3,pack:"id"},Ue={type:Y.UNSIGNED_BYTE,count:1,pack:function(e){const{sprite:t,isMapAligned:s,colorLocked:i,scaleSymbolsProportionally:r,isStroke:o}=e;let n=0;return s&&(n|=f(B.bitset.isMapAligned)),i&&(n|=f(B.bitset.colorLocked)),t.sdf&&(n|=f(B.bitset.isSDF)),r&&(n|=f(B.bitset.scaleSymbolsProportionally)),o&&(n|=f(B.bitset.isStroke)),n}},Qe={type:Y.SHORT,count:2,pack:"position",packPrecisionFactor:1},Ze={marker:{type:Y.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:e})=>[[-.5*e[0],-.5*e[1]],[.5*e[0],-.5*e[1]],[-.5*e[0],.5*e[1]],[.5*e[0],.5*e[1]]]}},line:{type:Y.FLOAT,count:2,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t},{baseSize:s})=>[e*s/2,t*s/2]},fill:{type:Y.FLOAT,count:2,packTessellation:()=>[0,0]}},qe={marker:{type:Y.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:e,texXmin:t,texYmax:s,texYmin:i})=>[[t,i],[e,i],[t,s],[e,s]]}}},$e={type:Y.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+n,o=t.y+n;return[r+1,o+1,r+s-1,o+i-1]}},Je={type:Y.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:e,baseSize:t,referenceSize:s})=>[e.dataColumn,e.dataRow,t,s]},Ke={type:Y.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:e,pixelDimensions:t,baseSize:s,sprite:i,sizeRatio:r})=>{const o=Math.max(s*i.width/i.height,s),n=i.sdfDecodeCoeff*o*r;return[t[0],t[1],e,n]}},et={type:Y.BYTE,count:1,packTessellation:({angle:e})=>e};function tt(t){let{pixelDimensions:s,texelDimensions:i,baseSize:r,referenceSize:o,strokeWidth:n,sizeRatio:a}=t;if(s||(s=t.sprite.sdf?[0,0]:[t.sprite.width,t.sprite.height]),i||(i=t.sprite.sdf?[0,0]:s),null!=t.patternHeight){const e=t.patternHeight/s[1];s[1]*=e,s[0]*=e}-1===r&&(r=s[1]),r=e(r),o=e(o),n=e(n);const c=(t.sprite.sdfDecodeCoeff??1)*a;return{...t,pixelDimensions:s,texelDimensions:i,baseSize:r,referenceSize:o,strokeWidth:n,sdfDecodeCoeff:c}}class st extends be{get vertexSpec(){return{createComputedParams:tt,optionalAttributes:{zoomRange:We,value1Position2Value2:Ye,lineLength:Ne},attributes:{id:Ve,bitset:Ue,pos:Qe,offset:Ze.marker,uv:qe.marker,animationPointerAndBaseSizeAndReferenceSize:Je,sizing:Ke,angle:et}}}_write(e,t){const s=this.evaluatedMeshParams.sprite,{textureBinding:i}=s;e.recordStart(this.instanceId,this.attributeLayout,i);const r=t.getDisplayId();if(this.shift&&"esriGeometryPolyline"===t.geometryType)this._writeParticles(e,t);else if(null!=this.evaluatedMeshParams.placement)this._writePlacedMarkers(e,t);else if("esriGeometryPolygon"===t.geometryType){const s=t.readCentroidForDisplay();if(!s)return;const[i,o]=s.coords;this._writeQuad(e,r,i,o)}else if("esriGeometryPoint"===t.geometryType){const s=t.readXForDisplay(),i=t.readYForDisplay();this._writeQuad(e,r,s,i)}else{const s=t.readGeometryForDisplay();s&&s.forEachVertex((t,s)=>{this._writeQuad(e,r,t,s)})}e.recordEnd()}_writePlacedMarkers(i,r){const o=t.fromFeatureSetReaderCIM(r)?.clone();if(!o)return;const n=ve.getPlacement(o,-1,this.evaluatedMeshParams.placement,e(1),i.id);if(!n)return;const a=r.getDisplayId();let c=n.next(),l=null;for(;null!=c;){const e=c.tx,t=-c.ty;if(Math.abs(e)>s||Math.abs(t)>s){c=n.next();continue}const r=-c.getAngle();i.recordBounds(e,t,64,64),this.shift?l&&this._writeQuad(i,a,l[0],l[1],void 0,r):this._writeQuad(i,a,e,t,void 0,r),l=[e,t],c=n.next()}}_writeParticles(e,t){const s=t.getDisplayId(),i=t.readGeometryForDisplay();if(!i)return;const r=[];i.forEachVertex((e,t)=>{r.push([e,t])});const o=function(e){const t=[];let s=0;for(let i=1;i<e.length;i++){const r=e[i-1],o=e[i],n=o[0]-r[0],a=o[1]-r[1],c=Math.sqrt(n*n+a*a),l=n/c,h=a/c;t.push({a:{position:r,distance:s,direction:[l,h]},b:{position:o,distance:s+c,direction:[l,h]}}),s+=c}return t}(r);let n=0;for(let e=1;e<r.length;e++){const t=r[e][0]-r[e-1][0],s=r[e][1]-r[e-1][1],i=Math.sqrt(t*t+s*s);n+=i}const a=t=>{for(const i of o){const{a:r,b:o}=i;this._writeQuad(e,s,r.position[0],r.position[1],[r.distance-t,o.position[0],o.position[1],o.distance-t],this.evaluatedMeshParams.angleToLine?Math.atan2(r.direction[1],r.direction[0]):0,n,!0)}},{placement:c}=this.evaluatedMeshParams;if(!c||"placementTemplate"in c||"CIMMarkerPlacementOnVertices"===c.type){let e;if(c&&"CIMMarkerPlacementOnVertices"!==c.type)e=c.placementTemplate;else{e=[0];for(const t of o){const{a:s,b:i}=t,r=s.position[0]-i.position[0],o=s.position[1]-i.position[1],n=Math.sqrt(r*r+o*o);e.push(n)}}let t=-1*n;for(;t<2*n;)for(const s of e)t+=s,a(t)}else"CIMMarkerPlacementAtExtremities"===c.type?"JustBegin"===c.extremityPlacement?a(1):"JustEnd"===c.extremityPlacement?(a(n-1),a(-1)):"Both"===c.extremityPlacement&&(a(1),a(n-1)):"CIMMarkerPlacementOnLine"===c.type&&a(n/2)}_writeQuad(e,t,s,i,r,o=0,a=0,c=!1){const l=this.evaluatedMeshParams.sprite,{rect:h}=l,u=h.x+n,d=h.y+n,f=h.x+h.width-n,p=h.y+h.height-n,m=e.vertexCount();c||e.recordBounds(s,i,64,64);const g={texXmin:u,texYmin:d,texXmax:f,texYmax:p,value1Position2Value2:r,angle:o/O,lineLength:a};for(let r=0;r<4;r++)this._writeVertex(e,t,s,i,g);e.indexEnsureSize(6),e.indexWrite(m),e.indexWrite(m+1),e.indexWrite(m+2),e.indexWrite(m+1),e.indexWrite(m+3),e.indexWrite(m+2)}}class it extends st{constructor(){super(...arguments),this.shift=!1}}class rt extends st{constructor(){super(...arguments),this.shift=!0}}class ot extends be{_write(e,s,i){const r=i??t.fromFeatureSetReaderCIM(s);if(!r)return;const o=this.evaluatedMeshParams.sprite,{textureBinding:n}=o;e.recordStart(this.instanceId,this.attributeLayout,n);const a=s.getDisplayId();this._writePoly(e,a,r.asOptimized()),e.recordEnd()}}class nt extends ot{constructor(){super(...arguments),this.vertexSpec={createComputedParams:tt,attributes:{id:Ve,bitset:Ue,pos:Qe,offset:Ze.fill,tlbr:$e,animationPointerAndBaseSizeAndReferenceSize:Je,sizing:Ke},optionalAttributes:{zoomRange:We,value1Position2Value2:Oe,lineLength:Ge}}}_writePoly(e,t,s){const i=[];if(!x(i,s))return;const r=e.vertexCount();s.forEachVertex((s,i)=>{this._writeVertex(e,t,s,i)}),e.indexEnsureSize(i.length);for(const t of i)e.indexWrite(r+t)}}class at{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}}class ct extends ot{constructor(){super(...arguments),this.vertexSpec={createComputedParams:tt,attributes:{id:Ve,bitset:Ue,pos:Qe,offset:Ze.line,tlbr:$e,animationPointerAndBaseSizeAndReferenceSize:Je,sizing:Ke,accumulatedDistance:je,normal:He,segmentDirection:Xe},optionalAttributes:{zoomRange:We,value1Position2Value2:Oe,lineLength:Ne}},this._tessParams=new m,this._currentWrite=new at,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:65535,textured:!1},this._lineLength=0,this._lineTessellator=new j((e,t,s,i,r,o,n,a,c,l,h)=>this._writeTesselatedVertex(e,t,s,i,r,o,n,a,c,l,h,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(s,i,r){const o=g(t.fromOptimized(r,"esriGeometryPolyline"),64);if(null==o)return;const{_currentWrite:n,_tessellationOptions:a}=this,{baseSize:c,capType:l,joinType:h,miterLimit:u}=this.evaluatedMeshParams,d=e(.5*c);a.halfWidth=d,a.capType=y(l||"Round"),a.joinType=_(h||"Round"),a.miterLimit=u||2,n.out=s,n.id=i,n.vertexCount=0,n.indexCount=0,n.vertexFrom=s.vertexCount(),n.vertexBounds=1;for(const{line:e,start:t,pathLength:s}of o){a.initialDistance=t%65535,n.pathLength=s,this._lineLength=0;for(let t=1;t<e.length;t++){const s=e[t].x-e[t-1].x,i=e[t].y-e[t-1].y;this._lineLength+=Math.sqrt(s*s+i*i)}this._lineTessellator.tessellate(e,a,!1)}}_writeTesselatedVertex(e,t,s,i,r,o,n,a,c,l,h,u){const{out:d,id:f,vertexBounds:p,pathLength:m}=this._currentWrite;return this.hasEffects&&d.recordBounds(e,t,p,p),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=r,this._tessParams.directionY=o,this._tessParams.distance=h,this._tessParams.pathLength=m,this._tessParams.lineLength=u,this._writeVertex(d,f,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,s){const{out:i}=this._currentWrite;i.indexEnsureSize(3),i.indexWrite(e),i.indexWrite(t),i.indexWrite(s),this._currentWrite.indexCount+=3}}const lt={createComputedParams:e=>e,optionalAttributes:{},attributes:{id:{type:Y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:Y.UNSIGNED_BYTE,count:1},pos:{type:Y.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:Y.FLOAT,count:1,packTessellation:({inverseArea:e})=>e}}};class ht extends P{constructor(){super(...arguments),this.vertexSpec=lt}createTesselationParams(e){return{inverseArea:1/e.readGeometryArea()}}}const ut={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:Y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:Y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:Y.UNSIGNED_BYTE,count:1},offset:{type:Y.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};class dt extends d{constructor(){super(...arguments),this.vertexSpec=ut}_write(e,t){e.recordStart(this.instanceId,this.attributeLayout);const s=t.getDisplayId();if("esriGeometryPoint"===t.geometryType){const i=t.readXForDisplay(),r=t.readYForDisplay();this._writeQuad(e,s,i,r)}else if("esriGeometryMultipoint"===t.geometryType){const i=t.readGeometryForDisplay();i?.forEachVertex((t,i)=>{t>=0&&t<=512&&i>=0&&i<=512&&this._writeQuad(e,s,t,i)})}e.recordEnd()}_writeQuad(e,t,s,i){const r=e.vertexCount();this._writeVertex(e,t,s,i),e.indexWrite(r+0),e.indexWrite(r+1),e.indexWrite(r+2),e.indexWrite(r+1),e.indexWrite(r+3),e.indexWrite(r+2)}}function ft(e,t,s){return e[0]=t[0]-s[0],e[1]=t[1]-s[1],e}function pt(e,t){return Math.sqrt(e*e+t*t)}function mt(e){const t=pt(e[0],e[1]);e[0]/=t,e[1]/=t}function gt(e,t){return pt(e[0]-t[0],e[1]-t[1])}function yt(e){return e.length-1}function _t(e,t,s=1){let[i,r]=function(e,t){return e[t+1]}(e,t);return[i,r]=[Math.round(i),Math.round(r)],Math.sqrt(i*i+r*r)*s}class xt{constructor(e,t,s,i,r){this._segments=e,this._index=t,this._distance=s,this._xStart=i,this._yStart=r,this._done=!1}static create(e){return new xt(e,0,0,e[0][0],e[0][1])}clone(){return new xt(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(0===this._distance||1===e._distance)||e._index===this._index+1&&(1===this._distance||0===e._distance)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let s=Math.acos(t);return e>0&&(s=2*Math.PI-s),s}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<yt(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const s=this.backwardLength;if(e<=s)return this._distance=(s-e)/this.length,this;let i=this.backwardLength;for(;this.prev();){if(i+this.length>e)return this._seekBackwards(e-i);i+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let s=this.remainingLength;for(;this.next();){if(s+this.length>e)return this.seek(e-s,t);s+=this.length}return this._distance=1,t?this:null}}function Pt(e,t,s,i=!0){const r=function(e){let t=0;for(let s=0;s<yt(e);s++)t+=_t(e,s);return t}(e),o=xt.create(e),n=r/2;if(!i)return o.seek(n),void(o.x<a&&o.y<a&&o.x>=0&&o.y>=0&&s(o.clone(),0,n+0*t,r));const c=Math.max((r-t)/2,0),l=Math.floor(c/t),h=n-l*t;o.seek(h);for(let e=-l;e<=l;e++)o.x<a&&o.y<a&&o.x>=0&&o.y>=0&&s(o.clone(),e,n+e*t,r),o.seek(t)}function Mt(e,t){const s=t;for(let t=0;t<e.length;t++){let i=e[t];vt(i,s);const r=[];r.push(i[0]);for(let e=1;e<i.length;e++){const[t,s]=i[e-1],[o,n]=i[e],a=o-t,c=n-s;r.push([a,c])}e[t]=r,i=r}return e}function vt(e,t){const s=1e-6;if(t<=0)return;const i=e.length;if(i<3)return;const r=[];let o=0;r.push(0);for(let t=1;t<i;t++)o+=gt(e[t],e[t-1]),r.push(o);t=Math.min(t,.2*o);const n=[];n.push(e[0][0]),n.push(e[0][1]);const a=e[i-1][0],c=e[i-1][1],l=ft([0,0],e[0],e[1]);mt(l),e[0][0]+=t*l[0],e[0][1]+=t*l[1],ft(l,e[i-1],e[i-2]),mt(l),e[i-1][0]+=t*l[0],e[i-1][1]+=t*l[1];for(let e=1;e<i;e++)r[e]+=t;r[i-1]+=t;const h=.5*t;for(let o=1;o<i-1;o++){let a=0,c=0,l=0;for(let i=o-1;i>=0&&!(r[i+1]<r[o]-h);i--){const n=h+r[i+1]-r[o],u=r[i+1]-r[i],d=r[o]-r[i]<h?1:n/u;if(Math.abs(d)<s)break;const f=d*d,p=d*n-.5*f*u,m=d*u/t,g=e[i+1],y=e[i][0]-g[0],_=e[i][1]-g[1];a+=m/p*(g[0]*d*n+.5*f*(n*y-u*g[0])-f*d*u*y/3),c+=m/p*(g[1]*d*n+.5*f*(n*_-u*g[1])-f*d*u*_/3),l+=m}for(let n=o+1;n<i&&!(r[n-1]>r[o]+h);n++){const i=h-r[n-1]+r[o],u=r[n]-r[n-1],d=r[n]-r[o]<h?1:i/u;if(Math.abs(d)<s)break;const f=d*d,p=d*i-.5*f*u,m=d*u/t,g=e[n-1],y=e[n][0]-g[0],_=e[n][1]-g[1];a+=m/p*(g[0]*d*i+.5*f*(i*y-u*g[0])-f*d*u*y/3),c+=m/p*(g[1]*d*i+.5*f*(i*_-u*g[1])-f*d*u*_/3),l+=m}n.push(a/l),n.push(c/l)}n.push(a),n.push(c);for(let t=0,s=0;t<i;t++)e[t][0]=n[s++],e[t][1]=n[s++]}class bt{constructor(e){const{offsetX:t,offsetY:s,postAngle:i,fontSize:r,haloSize:o,outlineSize:n,scaleFactor:a,transforms:c}=e;if(this.offsetX=t,this.offsetY=s,this.postAngle=i,this.fontSize=Math.min(r,96),this.haloSize=o??0,this.outlineSize=n??0,this.transforms=c,c&&c.infos.length>1){const e=me(r,i,!1,t,s,c,!1);this.fontSize=Math.min(e.size,96);const o=e.size/r;this.haloSize*=o,this.outlineSize*=o,this.postAngle=e.rotation,this.offsetX=e.offsetX,this.offsetY=e.offsetY}a&&(this.fontSize*=a,this.offsetX*=a,this.offsetY*=a)}}const wt=28,St=[4,4],kt=[16,4],It={topLeft:kt,topRight:kt,bottomLeft:kt,bottomRight:kt},zt=[4,2],Tt=[4,6],At={topLeft:zt,topRight:zt,bottomLeft:Tt,bottomRight:Tt},Lt={topLeft:zt,topRight:Tt,bottomLeft:zt,bottomRight:Tt},Dt={topLeft:Tt,topRight:Tt,bottomLeft:St,bottomRight:St},Et={topLeft:St,topRight:St,bottomLeft:Tt,bottomRight:Tt},Bt={topLeft:Tt,topRight:St,bottomLeft:Tt,bottomRight:St},Rt={topLeft:St,topRight:Tt,bottomLeft:St,bottomRight:Tt},Ct={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:Y.UNSIGNED_SHORT,count:2,packPrecisionFactor:o,packTessellation:({minZoom:e,maxZoom:t})=>[e||0,t||wt]},clipAngle:{type:Y.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:e})=>Wt(e||0)},referenceSymbol:{type:Y.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,s)=>{const i=t.isLineLabel||!t.referenceBounds,r=fe(i?"center":s.horizontalAlignment),o=pe(i?"middle":s.verticalAlignment),{offsetX:n,offsetY:a,size:c}=i?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[e(n),-e(a),Math.round(e(c)),r+1<<2|o+1]}},visibility:{type:Y.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:Y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:Y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:Y.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:e,mapAligned:t})=>v([[G,e],[N,!!t]])},offset:{type:Y.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:e})=>{const{bottomLeft:t,bottomRight:s,topLeft:i,topRight:r}=e;return[i,r,t,s]}}},textureUV:{type:Y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:e})=>{const{bottomLeft:t,bottomRight:s,topLeft:i,topRight:r}=e;return[i,r,t,s]}}},color:{type:Y.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:e})=>e},fontAndReferenceSize:{type:Y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:s})=>[Math.round(e(t)),Math.round(e(s??t))]},outlineColor:{type:Y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>M(e)},haloColor:{type:Y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:e})=>M(e)},outlineAndHaloSize:{type:Y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:s})=>[Math.round(e(t)),Math.round(e(s))]}}};class Ft extends d{constructor(){super(...arguments),this.vertexSpec=Ct,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,t,s){super.ensurePacked(e,t,s),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new bt(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,t,s){const i=this._getShaping();if(!i)return;const r=t.getDisplayId();if(null!=this.evaluatedMeshParams.placement)return this._writePlacedTextMarkers(e,t,i,s);if(s?.nextPath())return s.nextPoint(),this._writeGlyphs(e,r,s.x,s.y,i,0);if("esriGeometryPolygon"===t.geometryType){const s=t.readCentroidForDisplay();if(!s)return;const[o,n]=s.coords;return this._writeGlyphs(e,r,o,n,i,0)}if("esriGeometryMultipoint"===t.geometryType){const s=t.readGeometryForDisplay();return void s?.forEachVertex((t,s)=>this._writeGlyphs(e,r,t,s,i,0))}const o=t.readXForDisplay(),n=t.readYForDisplay();return this._writeGlyphs(e,r,o,n,i,0)}_writePlacedTextMarkers(s,i,r,o){const n=o??t.fromFeatureSetReaderCIM(i);if(!n)return;const a=ve.getPlacement(n,-1,this.evaluatedMeshParams.placement,e(1),s.id);if(!a)return;const c=i.getDisplayId();let l=a.next();for(;null!=l;){const e=l.tx,t=-l.ty,i=-l.getAngle();this._writeGlyphs(s,c,e,t,r,i),l=a.next()}}_getShaping(t){const s=this._textMeshTransformProps,i=this.evaluatedMeshParams;if(!i.glyphs?.glyphs.length)return null;const r=e(s.fontSize),o=e(s.offsetX),n=e(s.offsetY),a=ue(e(i.lineWidth),l,c),d=h*ue(i.lineHeightRatio,.25,4);return de(i.glyphs,{scale:r/u,angle:s.postAngle,xOffset:o,yOffset:n,horizontalAlignment:i.horizontalAlignment,verticalAlignment:t||i.verticalAlignment,maxLineWidth:a,lineHeight:d,decoration:i.decoration,borderLineSizePx:e(i.boxBorderLineSize),hasBackground:!!i.boxBackgroundColor,useCIMAngleBehavior:i.useCIMAngleBehavior})}_writeGlyphs(t,s,i,r,o,n,a,c,l=!0){const h=this.evaluatedMeshParams,u=this._textMeshTransformProps,d=e(u.fontSize),f=u.haloSize,m=u.outlineSize,g=e(u.offsetX),y=e(u.offsetY),[_,x]=p(h.scaleInfo,this.getTileInfo());0!==n&&o.setRotation(n);const P=o.bounds,v=i+P.x+g,b=r+P.y-y,w=2*(h.minPixelBuffer?h.minPixelBuffer/d:1),S=Math.max(P.width,P.height)*w;o.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding),l&&t.recordBounds(v,b,S,S),this._writeTextBox(t,s,i,r,o.textBox,a,c),t.recordEnd());for(const e of o.glyphs){t.recordStart(this.instanceId,this.attributeLayout,e.textureBinding),l&&t.recordBounds(v,b,S,S);const{texcoords:o,offsets:n}=e;this._writeQuad(t,s,i,r,{texcoords:o,offsets:n,fontSize:d,haloSize:f,outlineSize:m,color:M(h.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:x,...c}),t.recordEnd()}0!==n&&o.setRotation(-n)}_writeTextBox(e,t,s,i,r,o,n){const a=this.evaluatedMeshParams,{fontSize:c,haloSize:l,outlineSize:h}=this._textMeshTransformProps,{boxBackgroundColor:u,boxBorderLineColor:d}=a,f={isBackground:!0,fontSize:c,haloSize:l,outlineSize:h,referenceBounds:o,...n};u&&(this._writeQuad(e,t,s,i,{texcoords:It,offsets:r.main,color:M(u),...f}),d||(this._writeQuad(e,t,s,i,{texcoords:Dt,offsets:r.top,color:M(u),...f}),this._writeQuad(e,t,s,i,{texcoords:Et,offsets:r.bot,color:M(u),...f}),this._writeQuad(e,t,s,i,{texcoords:Bt,offsets:r.left,color:M(u),...f}),this._writeQuad(e,t,s,i,{texcoords:Rt,offsets:r.right,color:M(u),...f}))),d&&(this._writeQuad(e,t,s,i,{texcoords:At,offsets:r.top,color:M(d),...f}),this._writeQuad(e,t,s,i,{texcoords:At,offsets:r.bot,color:M(d),...f}),this._writeQuad(e,t,s,i,{texcoords:Lt,offsets:r.left,color:M(d),...f}),this._writeQuad(e,t,s,i,{texcoords:Lt,offsets:r.right,color:M(d),...f}))}_writeQuad(e,t,s,i,r){const o=e.vertexCount();this._writeVertex(e,t,s,i,r),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const Wt=e=>Math.round(e*(254/360)),Yt=X(e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t});class Ot extends Ft{constructor(){super(...arguments),this._zoomLevel=0}_write(e,s,i,r){if(this._zoomLevel=r||0,null!=i)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(s.geometryType){case"esriGeometryPoint":{const t=s.readXForDisplay(),i=s.readYForDisplay();this._writePoint(e,t,i,0,s);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const t=s.readCentroidForDisplay();if(!t)return;const[i,r]=t.coords;this._writePoint(e,i,r,0,s);break}case"esriGeometryMultipoint":{let i=0;const r=t.fromFeatureSetReader(s);if(r?.nextPath())for(;r.nextPoint();)this._writePoint(e,r.x,r.y,i++,s);break}case"esriGeometryPolyline":this._writeLines(e,s)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return["center"===e?0:"right"===e?-1:1,"middle"===t?0:"bottom"===t?-1:1]}_createLineLabelMetric(e,t,s,i,r,o){const[n,a]=this._getMetricDir(),c=this.evaluatedMeshParams.scaleInfo?.maxScale??0,l=this.evaluatedMeshParams.scaleInfo?.minScale??0,h=this.evaluatedMeshParams.labelClassId;return new le(e,h,t,s,i,r,n,a,c,l,o)}_writePoint(e,t,s,i,r){if(t<0||t>a||s<0||s>a)return;const o=this._getShaping();if(!o)return;const n=r.getDisplayId(),c=this.evaluatedMeshParams.labelClassId,l=(h=r.getObjectId(),H(`${h}${i}`));var h;const u=function(e,t,s){return H(`${e}${t}${s}`)}(r.getObjectId(),c,i),[d,f]=this._getMetricDir(),p=this.evaluatedMeshParams.scaleInfo?.maxScale??0,m=this.evaluatedMeshParams.scaleInfo?.minScale??0,g=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new le(n,c,l,u,t,s,d,f,p,m,g)),this._writeGlyphs(e,n,t,s,o,0,g,void 0,!1),e.metricBoxWrite(o.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:s,verticalAlignment:i}=this.evaluatedMeshParams,r=this.evaluatedMeshParams.repeatLabelDistance||128,o=this._getShaping("middle");if(!o)return;const n=(e,t,s,i)=>this._placeSubdivGlyphs(e,t,s,i),a=(o.bounds.width+r)/2;this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:o,zoomRange:p(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement="bottom"===i?"above":"top"===i?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,n,a):this._writeCenterAlong(t,n,a)}_writeAboveAndBelowAlong(e,t,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:r}=this._current,o=r.bounds.halfHeight,n=e.readGeometryForDisplay();if(!n)return;const a=new ae;oe(a,n,!1,!1,"esriGeometryPolyline",1);const c=Gt(new ae,a,o),l=Gt(new ae,a,-o),h=ne(l,"esriGeometryPolyline",!1,!1),u=Mt(ne(c,"esriGeometryPolyline",!1,!1).paths,r.bounds.width),d=Mt(h.paths,r.bounds.width);this._current.offsetDirection="above";for(let e=0;e<u.length;e++)this._current.pathIndex=e,Pt(u[e],s,t,!!i);this._current.offsetDirection="below";for(let e=0;e<d.length;e++)this._current.pathIndex=e,Pt(d[e],s,t,!!i)}_writeCenterAlong(e,t,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:r}=this._current,o=Mt(e.readLegacyGeometryForDisplay().paths,r.bounds.width);for(let e=0;e<o.length;e++)this._current.pathIndex=e,Pt(o[e],s,t,!!i)}_placeSubdivGlyphs(e,t,s,i){const{allowOverrun:r,labelPosition:o,repeatLabelDistance:n}=this.evaluatedMeshParams,a=this._current.zoomRange[0],c=Yt(t),l=this._current.shaping.bounds.width/2,h=Math.sqrt(n||128)/2,u=Math.min(s,i-s),d=this._current.shaping.isMultiline?wt:Math.log2(u/(h+l/2)),f=0===t?d:Math.min(c,d),p=Math.max(a,this._zoomLevel+1-f),m=this._zoomLevel-p,g=this._current.shaping.bounds.width/2*2**m,y=function(e,t,s,i){return H(`${e}${t}${s*2**(wt-i)}`)}(this._current.objId,this._current.pathIndex,t,this._zoomLevel),_=function(e,t,s,i,r){return H(`${e}${r}${t}${s*2**(wt-i)}`)}(this._current.objId,this._current.pathIndex,t,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?0===t&&this._placeStraight(e,p,y,_):r&&m<0?this._placeStraightAlong(e,a,y,_):"parallel"===o?this._placeStraightAlong(e,p,y,_):"curved"===o&&this._placeCurved(e,p,g,y,_)}_placeStraight(e,t,s,i){const{out:r,id:o,shaping:n,referenceBounds:a}=this._current,{x:c,y:l}=e;r.metricStart(this._createLineLabelMetric(o,s,i,c,l)),r.metricBoxWrite(n.boundsT);const h=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360,d={clipAngle:h,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(r,o,c,l,n,0,a,d,!1);const f={clipAngle:u,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(r,o,c,l,n,0,a,f,!1),r.metricEnd()}_placeCurved(e,t,s,i,r){const{out:o,id:n}=this._current;o.metricStart(this._createLineLabelMetric(n,i,r,e.x,e.y));const a=e.clone(),c=e.angle*(180/Math.PI)%360,l=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(a,t,1,c),this._placeBack(e,a,t,s,1,c),this._placeForward(e,a,t,s,1,c)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(a,t,0,l),this._placeBack(e,a,t,s,0,l),this._placeForward(e,a,t,s,0,l)),o.metricEnd()}_placeStraightAlong(t,s,i,r){const{out:o,id:n,shaping:a,zoomRange:c,referenceBounds:l}=this._current,{boxBorderLineColor:h,boxBackgroundColor:u}=this.evaluatedMeshParams,d=t.clone(),f=t.angle*(180/Math.PI)%360,p=(t.angle*(180/Math.PI)+180)%360,m=a.glyphs.length>0&&!(!h&&!u);if(o.metricStart(this._createLineLabelMetric(n,i,r,t.x,t.y)),m){const i=Math.max(s,c[0],0),r=Math.min(wt,c[1]),h=V(q(),-t.angle),u={minZoom:i,maxZoom:r,clipAngle:f,mapAligned:!0,isLineLabel:!0},d=e(this.evaluatedMeshParams.offsetX),m=e(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const e=ie(d,-1*m),[s,i]=a.shapeBackground(U(q(),h,e));o.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(o,n,t.x,t.y,i,l,u),o.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const e=ie(d,m),[s,i]=a.shapeBackground(U(q(),h,e));u.clipAngle=p,o.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(o,n,t.x,t.y,i,l,u),o.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(d,s,1,f,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(d,s,0,p,!0),o.metricEnd()}_placeBack(e,t,s,i,r,o){const n=e.clone();let a=e.backwardLength+0;for(;n.prev()&&!(a>=i);)this._placeOnSegment(n,t,a,s,-1,r,o),a+=n.length+0}_placeForward(e,t,s,i,r,o){const n=e.clone();let a=e.remainingLength+0;for(;n.next()&&!(a>=i);)this._placeOnSegment(n,t,a,s,1,r,o),a+=n.length+0}_placeFirst(t,s,i,r,o=!1){const{out:n,id:a,shaping:c,zoomRange:l,referenceBounds:h}=this._current,u=c.glyphs,d=e(this.evaluatedMeshParams.offsetX),f=e(this.evaluatedMeshParams.offsetY),p=ie(d,f),m=V(q(),-t.angle);$(p,p,m);for(const e of u){const u=e.x>c.bounds.x?i:1-i,d=u*t.remainingLength+(1-u)*t.backwardLength,f=Math.abs(e.x+e.width/2-c.bounds.x),m=Math.max(0,this._zoomLevel+Math.log2(f/(d+0))),g=Math.max(s,o?0:m);if(e.maxZoom=Math.min(l[1],wt),e.angle=t.angle+(1-i)*Math.PI,e.minZoom=Math.max(l[0],g),this._writeLineGlyph(n,a,t.x,t.y,e,r,h,!0),(i||this._current.offsetDirection)&&this._isVisible(e.minZoom,e.maxZoom)){const t=new ce(e.bounds.x+p[0],e.bounds.y+p[1],e.bounds.width,e.bounds.height);n.metricBoxWrite(t)}}}_placeOnSegment(t,s,i,r,o,n,a){const{out:c,id:l,shaping:h,referenceBounds:u}=this._current,d=h.glyphs,f=t.dx/t.length,p=t.dy/t.length,m={x:t.x+i*-o*f,y:t.y+i*-o*p},g=e(this.evaluatedMeshParams.offsetX),y=e(this.evaluatedMeshParams.offsetY),_=ie(g,y),x=V(q(),-t.angle);$(_,_,x);for(const e of d){const s=e.x>h.bounds.x?n:1-n;if(!(s&&1===o||!s&&-1===o))continue;const d=Math.abs(e.x+e.width/2-h.bounds.x),f=Math.max(0,this._zoomLevel+Math.log2(d/i)-.1),p=Math.max(r,this._zoomLevel+Math.log2(d/(i+t.length+0)));if(0!==f&&(e.angle=t.angle+(1-n)*Math.PI,e.minZoom=p,e.maxZoom=f,this._writeLineGlyph(c,l,m.x,m.y,e,a,u,!0),(n||this._current.offsetDirection)&&this._isVisible(e.minZoom,e.maxZoom))){const t=new ce(e.bounds.x+_[0],e.bounds.y+_[1],e.bounds.width,e.bounds.height);c.metricBoxWrite(t)}}}_writeLineGlyph(e,t,s,i,r,o,n,c){if(s<0||s>a||i<0||i>a)return;e.recordStart(this.instanceId,this.attributeLayout,r.textureBinding);const{texcoords:l,offsets:h}=r,{fontSize:u,haloSize:d,outlineSize:f}=this._textMeshTransformProps;this._writeQuad(e,t,s,i,{texcoords:l,offsets:h,fontSize:u,haloSize:d,outlineSize:f,color:M(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:n,minZoom:Math.max(this._current.zoomRange[0],r.minZoom),maxZoom:Math.min(this._current.zoomRange[1],r.maxZoom),clipAngle:o,mapAligned:c,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*o)/o}_isVisible(e,t){let s=Math.max(this._current.zoomRange[0],e),i=Math.min(this._current.zoomRange[1],t);s=this._packedZoom(s),i=this._packedZoom(i);const r=this._packedZoom(this._zoomLevel);return s<=r&&r<=i}}function Gt(e,t,s){const{coords:i,lengths:r}=t,o=re(),n=re(),a=re(),c=re(),l=re(),h=re();let u=0;for(let t=0;t<r.length;t++){const d=r[t];for(let t=0;t<d;t++){const r=2*(t+u-1),f=2*(t+u),p=2*(t+u+1);t>0?J(o,i[r],i[r+1]):J(o,0,0),J(n,i[f],i[f+1]),t<d-1?J(a,i[p],i[p+1]):J(a,0,0),0===t?J(c,0,0):(K(c,n,o),ee(c,c),J(c,c[1],-c[0])),t===d-1?J(l,0,0):(K(l,a,n),ee(l,l),J(l,l[1],-l[0])),te(h,c,l),ee(h,h);const m=h[0]*l[0]+h[1]*l[1];0!==m&&se(h,h,m),se(h,h,s),e.coords.push(n[0]+h[0],n[1]+h[1])}e.lengths.push(d),u+=d}return e}class Nt{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(t){const s=new Nt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:i,width:r,height:o,angle:n,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:u}=t;return s.rawWidth=e(r),s.rawHeight=e(o),s.angle=n,s.alignment=a,s.outlineSize=e(c),s.referenceSize=e(l),s.overrideOutlineColor=u,s.offsetX=e(t.offsetX),s.offsetY=e(t.offsetY),"simple"!==i||h.sdf||(s.rawWidth=h.width,s.rawHeight=h.height),s._computeSize(t,!1),s}static fromComplexMeshParams(t){const s=new Nt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:i,transforms:r,size:o,scaleX:n,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:u,widthRatio:d,offsetX:f,offsetY:p,outlineSize:m,referenceSize:g,scaleFactor:y,sizeRatio:_,isAbsoluteAnchorPoint:x,rotateClockwise:P,scaleSymbolsProportionally:M,sprite:v}=t;if(r&&r.infos.length>0){const e=me(o,l,P,f,p,r);o=e.size,l=e.rotation,f=e.offsetX,p=e.offsetY,P=!1}y&&(o*=y,f*=y,p*=y);const b=n*(v.width/v.height);s.alignment=i,s.rawHeight=e(o),s.rawWidth=s.rawHeight*b,s.referenceSize=e(g),s.sizeRatio=_,s.sdfDecodeCoeff=(v.sdfDecodeCoeff??1)*_,s.angle=l,s.rotateClockwise=P,s.anchorX=a,s.anchorY=c,s.offsetX=e(f),s.offsetY=e(p),x&&o&&(v.sdf?s.anchorX=a/(o*d):s.anchorX=a/(o*b),s.anchorY=c/o);const w=M&&u?o/u:1;return s.outlineSize=0===m||isNaN(m)?0:e(m)*w,s.scaleSymbolsProportionally=M,s.colorLocked=h,s._computeSize(t,!0),s}constructor(e,t,s,i,r,o,n){this.sprite=e,this.color=t,this.outlineColor=s,this.minPixelBuffer=i,this.placement=r,this.scaleInfo=o,this.effects=n,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=0,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,t){const{sprite:s,hasSizeVV:i}=e,r=!!s.sdf,o=s.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,u=s.rect;let d=a*l,f=c*l,p=0,m=0;if(r){const e=1/(1-o);if(d*=e,f*=e,i)this.computedWidth=d,this.computedHeight=f;else{const e=t&&a>c?d:a,i=c,r=h+2;this.computedWidth=Math.min(e+r,d),this.computedHeight=Math.min(i+r,f);const o=Math.max(s.width,s.height)/Math.max(d,f);p=(this.computedWidth-d)*o,m=(this.computedHeight-f)*o}}else this.computedWidth=d*(u.width/s.width),this.computedHeight=f*(u.height/s.height),p=2*n,m=2*n;const g=u.x+n-p/2,y=u.y+n-m/2,_=g+s.width+p,x=y+s.height+m;this.texXmin=jt(g),this.texYmin=jt(y),this.texXmax=Xt(_),this.texYmax=Xt(x),this.computedWidth*=(this.texXmax-this.texXmin)/(_-g),this.computedHeight*=(this.texYmax-this.texYmin)/(x-y),this.anchorX*=d/this.computedWidth,this.anchorY*=f/this.computedHeight}}function jt(e,t=1e-7){const s=Math.ceil(e);return s-e<t?s:Math.floor(e)}function Xt(e,t=1e-7){const s=Math.floor(e);return e-s<t?s:Math.ceil(e)}const Ht=128/Math.PI,Vt={createComputedParams:e=>Nt.from(e),optionalAttributes:{zoomRange:{type:Y.SHORT,count:2,packPrecisionFactor:o,pack:({scaleInfo:e},{tileInfo:t})=>p(e,t)}},attributes:{pos:{type:Y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:Y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:Y.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:t,scaleSymbolsProportionally:s,overrideOutlineColor:i,colorLocked:r})=>{let o=0;return e.sdf&&(o|=f(B.bitset.isSDF)),1===t&&(o|=f(B.bitset.isMapAligned)),s&&(o|=f(B.bitset.scaleSymbolsProportionally)),i&&(o|=f(B.bitset.overrideOutlineColor)),r&&(o|=f(B.bitset.colorLocked)),o}},offset:{type:Y.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:e,computedWidth:t,computedHeight:s,anchorX:i,anchorY:r,offsetX:o,offsetY:n,rotateClockwise:a})=>{const c=function(e,t,s,i,r=!1){const o=q(),n=r?1:-1;return Q(o),(t||s)&&U(o,o,[t,-s]),i&&Z(o,o,.017453292519944444*n*-i),o}(0,o,n,-e,a),l=-(.5+i)*t,h=-(.5-r)*s,u=[l,h],d=[l+t,h],f=[l,h+s],p=[l+t,h+s];return $(u,u,c),$(d,d,c),$(f,f,c),$(p,p,c),[u,d,f,p]}}},textureUV:{type:Y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:e,texXmin:t,texYmax:s,texYmin:i})=>[[t,i],[e,i],[t,s],[e,s]]}},color:{type:Y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>M(e)},outlineColor:{type:Y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>M(e)},sizing:{type:Y.UNSIGNED_BYTE,count:4,pack:({rawWidth:e,rawHeight:t,outlineSize:s,referenceSize:i})=>{const r=Math.max(e,t);return[b(r,128),b(s,128),b(i,128),0]}},placementAngle:{type:Y.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:e})=>{return t=e*Ht,t%=256,Math.abs(t>=0?t:t+256);var t}},sdfDecodeCoeff:{type:Y.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:e})=>e}}};class Ut extends d{constructor(){super(...arguments),this.vertexSpec=Vt}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,t,i){const o=this.evaluatedMeshParams.sprite?.textureBinding,n=t.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,o);const a=this.evaluatedMeshParams.minPixelBuffer,c=Math.max(this.evaluatedMeshParams.computedWidth,a),l=Math.max(this.evaluatedMeshParams.computedHeight,a),h=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,u=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,d=this.evaluatedMeshParams.offsetX+h,f=-this.evaluatedMeshParams.offsetY+u;if(null!=this.evaluatedMeshParams.placement){let s=null;if(null!=i){const e=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(s=r(i,2*e,!1),null===s)return}this._writePlacedMarkers(e,t,s,c,l)}else if(i?.nextPath()){i.nextPoint();const t=i.x,s=i.y;e.recordBounds(t+d,s+f,c,l),this._writeQuad(e,n,t,s)}else if("esriGeometryPolygon"===t.geometryType){const s=t.readCentroidForDisplay();if(!s)return;const[i,r]=s.coords;e.recordBounds(i+d,r+f,c,l),this._writeQuad(e,n,i,r)}else if("esriGeometryPoint"===t.geometryType){const s=t.readXForDisplay(),i=t.readYForDisplay();e.recordBounds(s+d,i+f,c,l),this._writeQuad(e,n,s,i)}else{const i=t.readGeometryForDisplay();i?.forEachVertex((t,i)=>{e.recordBounds(t+d,i+f,c,l),Math.abs(t)>s||Math.abs(i)>s||this._writeQuad(e,n,t,i)})}e.recordEnd()}_writePlacedMarkers(i,r,o,n,a){const c=o??t.fromFeatureSetReaderCIM(r);if(!c)return;const l=ve.getPlacement(c,-1,this.evaluatedMeshParams.placement,e(1),i.id);if(!l)return;const h=r.getDisplayId();let u=l.next();const d=this.evaluatedMeshParams.offsetX,f=-this.evaluatedMeshParams.offsetY;for(;null!=u;){const e=u.tx,t=-u.ty;if(Math.abs(e)>s||Math.abs(t)>s){u=l.next();continue}const r=-u.getAngle();i.recordBounds(e+d,t+f,n,a),this._writeQuad(i,h,e,t,r),u=l.next()}}_writeQuad(e,t,s,i,r){const o=e.vertexCount(),n=null==r?null:{placementAngle:r};this._writeVertex(e,t,s,i,n),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}class Qt extends Me{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,s){return this._value}hasArcadeDependency(e){return!1}}const Zt=()=>xe.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function qt(e,t,s,i){const{defaultValue:r,valueExpressionInfo:o,value:n}=t;if(o){if("dictionary-template"===o.type)return{...t,computed:e.createDictionaryTemplateField(o,s),defaultValue:r};const{expression:n}=o,a=await e.createComputedField({expression:n},i);return a?{...t,computed:a,defaultValue:r}:null}return{...t,computed:new Qt(n),defaultValue:r}}async function $t(e,t,s){const{valueExpressionInfo:i}=t,r="dictionary-template"===i.type?e.createDictionaryTemplateField(i,s):await e.createComputedField({expression:i.expression});return r?{...t,computed:r}:null}function Jt(e){return"object"==typeof e&&null!=e&&(!(!("valueExpressionInfo"in e)||!e.valueExpressionInfo)||"type"in e&&"Process"===e.type&&"op"in e&&"Random"===e.op)}function Kt(e){if(Array.isArray(e))for(const t of e)if(Kt(t))return!0;if("object"==typeof e){if(Jt(e))return!0;for(const t in e)if(Kt(e[t]))return!0}return!1}class es{static async create(e,t,s,i){const r={},o=new Map,n=new Map,a=new Map,c=new Map,l=new Map,h=new Map;for(const u in s){const d=s[u];if(null!=d&&"object"==typeof d)if(Array.isArray(d)){if("object"==typeof d[0])throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);r[u]=d}else{if("valueExpressionInfo"in d){if(d.value){r[u]=d.value;continue}const t=await $t(e,d,i);if(!t){r[u]=d.defaultValue;continue}o.set(u,t),r[u]=null;continue}switch(d.type){case"cim-effect-infos":if(d.effectInfos.some(e=>e.overrides.length)){n.set(u,{effects:await Promise.all(d.effectInfos.map(async t=>{const s=t.overrides.map(t=>qt(e,t,i,!1));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(ge)}}))});break}r[u]=d.effectInfos.map(e=>e.effect);break;case"cim-marker-placement-param":d.overrides.length&&a.set(u,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map(t=>qt(e,t,i,!1)))).filter(ge)}),r[u]=d.placement;break;case"text-rasterization-param":{if(d.overrides.length){const t=d.overrides.map(t=>qt(e,t,i,d.useLegacyLabelEvaluationRules??!1));c.set(u,{compiledOverrides:(await Promise.all(t)).filter(ge),rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};r[u]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(d.overrides.length){const t=d.overrides.map(t=>qt(e,t,i,!1));c.set(u,{compiledOverrides:(await Promise.all(t)).filter(ge),rasterizationParam:d,objectIdToResourceId:new Map});continue}if("animated"===d.resource.type){c.set(u,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};r[u]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=d;if(Kt(t)){const s={compiledMarkerInfos:[]};await Promise.all(t.map(async t=>{const r={props:{}};for(const s in t)if(Jt(t[s])){const o=await $t(e,t[s],i);r.compiledExpressionMap||(r.compiledExpressionMap=new Map);const n=r.compiledExpressionMap;o&&n.set(s,o)}else r.props[s]=t[s];s.compiledMarkerInfos.push(r)})),l.set(u,s)}else r[u]={type:"cim-marker-transform-info",infos:t};break}case"animation-params":{const{params:s}=d,i=De(s);if(Kt(i)){const t=await Promise.all(i.map(t=>Be(t,e)));h.set(u,{params:t,propertyIdToResourceId:new Map,key:u})}else{const e=Le(i),s=await t.fetchResourceImmediate({type:"animation-info",resource:e});null!=s&&"sprite"===s.type&&(r[u]={dataRow:s.rect.y,dataColumn:s.rect.x})}break}default:r[u]=d}}else r[u]=d}return new es(s,r,o,n,a,c,l,h)}constructor(e,t,s,i,r,o,n,a){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=s,this._dynamicEffectProperties=i,this._dynamicPlacementProperties=r,this._dynamicAsyncProperties=o,this._dynamicTransformProperties=n,this._dynamicAsyncAnimations=a,this.evaluator=e=>e,this._arcadeDependencies=new Set;for(const e of this._expressions())Pe(this._arcadeDependencies,e)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,s){for(const i of this._dynamicAsyncProperties.values()){const r=ye(i.rasterizationParam.resource);"animated"===i.rasterizationParam.resource.type&&i.rasterizationParam.resource.randomizeStartTime&&(r.primitiveName="__RESERVED__PRIMITIVE__NAME__",r.startGroup=F(t.getObjectId()||0));for(const{primitiveName:e,propertyName:o,computed:n,defaultValue:a,valueExpressionInfo:c}of i.compiledOverrides)try{const c="animated"===i.rasterizationParam.resource.type?r.primitiveName:e;he(r,c,o,n,t,s,a)}catch(e){Zt().errorOnce(new _e("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:e,valueExpressionInfo:c}))}const o=e.enqueueRequest({type:"cim-rasterization-info",resource:r});i.objectIdToResourceId.set(t.getObjectId(),o)}for(const i of this._dynamicAsyncAnimations.values()){const r=Ee(i.params.map(e=>Re(e,t,s)).map(we).map(e=>e.simplify())),o=e.enqueueRequest({type:"animation-info",resource:r});i.propertyIdToResourceId.set(t.getObjectId()+"."+i.key,o)}}evaluateMeshParams(e,t,s){for(const[e,i]of this._dynamicProperties.entries())this._resolvedMeshParams[e]=i.computed.readWithDefault(t,s,i.defaultValue);for(const[e,i]of this._dynamicPlacementProperties.entries())for(const{computed:r,defaultValue:o,propertyName:n}of i.compiledOverrides){const a=r.readWithDefault(t,s,o);i.placementInfo.placement[n]=a,this._resolvedMeshParams[e]=i.placementInfo.placement}for(const[e,i]of this._dynamicEffectProperties.entries())for(const r of i.effects){for(const{computed:e,defaultValue:i,propertyName:o}of r.compiledOverrides){const n=e.readWithDefault(t,s,i);r.effect[o]=n}this._resolvedMeshParams[e]=i.effects.map(e=>e.effect)}for(const[e,i]of this._dynamicTransformProperties.entries()){const r={type:"cim-marker-transform-info",infos:[]};for(const e of i.compiledMarkerInfos){const i={...e.props};if(e.compiledExpressionMap)for(const[r,o]of e.compiledExpressionMap){const e=o.computed.readWithDefault(t,s,o.defaultValue);i[r]="number"==typeof e||"boolean"==typeof e?e:o.defaultValue}r.infos.push(i)}this._resolvedMeshParams[e]=r}for(const[s,i]of this._dynamicAsyncProperties.entries()){const r=i.objectIdToResourceId.get(t.getObjectId());if(null==r)continue;const o=e.getResource(r);this._resolvedMeshParams[s]=o}for(const[s,i]of this._dynamicAsyncAnimations.entries()){const r=i.propertyIdToResourceId.get(t.getObjectId()+"."+s);if(null==r)continue;const o=e.getResource(r);this._resolvedMeshParams[s]={dataRow:o.rect.y,dataColumn:o.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const e of t.compiledOverrides)yield e.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(null!=t.compiledExpressionMap)for(const e of t.compiledExpressionMap.values())yield e.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*Ce(t)}}const ts={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:Y.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:Y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:Y.UNSIGNED_BYTE,count:1,pack:e=>0},offset:{type:Y.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const s=e(t),i=-s/2,r=-s/2;return[[i,r],[i+s,r],[i,r+s],[i+s,r+s]]}}},texCoords:{type:Y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:Y.UNSIGNED_BYTE,count:2,pack:({size:e})=>[e,e]},referenceSize:{type:Y.UNSIGNED_BYTE,count:1,pack:({size:t})=>e(t)},zoomRange:{type:Y.UNSIGNED_BYTE,count:2,pack:({scaleInfo:e},{tileInfo:t})=>p(e,t)}}};class ss extends d{constructor(){super(...arguments),this.vertexSpec=ts}_write(t,s){const i=s.getDisplayId(),r=this.evaluatedMeshParams.minPixelBuffer,o=Math.max(e(this.evaluatedMeshParams.size),r);let n,a;if("esriGeometryPoint"===s.geometryType)n=s.readXForDisplay(),a=s.readYForDisplay();else{const e=s.readCentroidForDisplay();if(!e)return;n=e?.coords[0],a=e?.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(n,a,o,o);const c=t.vertexCount();this._writeVertex(t,i,n,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}class is{async createMeshWriter(e,t,s,i,r){const o=this._getMeshWriter(i.techniqueType),n=await es.create(e,t,i.inputParams,r),a=new o(i.id,n,i.optionalAttributes,s);return await a.loadDependencies(),a}_getMeshWriter(e){switch(e){case 9:return E;case 8:return ht;case 6:return D;case 21:return L;case 10:return A;case 19:return T;case 22:return z;case 7:return I;case 17:return Ut;case 23:return ss;case 25:return Ft;case 15:return k;case 26:return S;case 11:return w;case 13:return dt;case 14:return Ot;case 2:return it;case 3:return rt;case 0:return nt;case 1:return ct;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Qt as D,is as M};
