/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{a as e,b as t}from"./tslib.es6.js";import{a as n,G as s,u as o,t as r,P as i,p as a,b as c,r as m,f as l,m as u}from"./Point2D.js";import{m as g,a as f,c as y}from"./SideCalculator2D-BNwb5gvz.js";import{P as S,G as d,g as N,a8 as p,y as x,Q as h,a9 as A,aa as C,S as P,ab as w,ac as E,ad as _,ae as j,t as T,af as G,ag as D,H as I,I as v,ah as b,ai as R}from"./ProjectionTransformation.js";import{P as U,d as q}from"./Envelope.js";import{G as B}from"./SimpleGeometryCursor.js";import{O}from"./OperatorShapePreservingDensify.js";import"./Envelope2D.js";import"./Transformation2D.js";import"./OperatorDefinitions.js";import"./OperatorGeodeticDensifyByLength.js";class F{getOperatorType(){return 10501}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,m,l,u,j){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return g();if(Number.isNaN(l)&&(l=0),l>=0||n("maxDeviationMeters"),0===e.getDimension())return this.getNearestVertex(e,t,m);const T=e.getGeometryType();if(T===s.enumGeometryCollection){const n=e;let s=g();for(let e=0,o=n.getGeometryCount();e<o;++e){const o=n.getGeometry(e),r=this.getNearestCoordinate(o,t,m,l,u,j);if(!r.isEmpty()){if(0===r.m_distance)return r;r.m_distance>=s.m_distance||(s=r,s.m_geometryIndex=e)}}return s}if(T===s.enumEnvelope){const n=new S;return n.addEnvelope(e,!1),this.getNearestCoordinate(n,t,m,l,u,j)}o(T)||r("Operation is not implemented for this geometry type");const G=e;if((u||j)&&T===s.enumPolygon){const n=()=>{const e=f(t,-1,0);return e.m_bRightSide=!0,e};if(m.isPannable()){const s=(new d).foldInto360Range(new U(t),m);if(s.isEmpty())return g();const o=(new d).foldInto360Range(e,m);if(o.isEmpty())return g();if((new N).execute(o,s,m,null)&&u)return n()}else{const e=(new d).clipToSpatialReference(new U(t),m,null,1);if(e.isEmpty())return g();const s=p(G,m,0,null);if(s.isEmpty())return g();if((new N).execute(s,e,m,null)&&u)return n()}}const D=m!==m.getGCS()?m.getSRToGCSTransform():null,I=new i;if(D?(new d).transform(D,[t],1,[I],!1):I.assign(t),I.isNAN())return g();const v=Y(G,t,m,1);let b=v.m_distance;if(0===b)return v;Number.isNaN(b)?b=Number.POSITIVE_INFINITY:b*=1+1e-7;const R=m.getGCS(),B=R.getUnit().getUnitToBaseFactor(),F=I.clone();F.scale(B);const V=x();m.querySpheroidData(V);const M=h(V.majorSemiAxis,V.e2,F),L=A(V.majorSemiAxis,V.e2),z=new X(G.querySegmentIterator());0===l&&(l=.01);const H=V.majorSemiAxis*C(45),Q=(new O).executeMany(z,m,H,l,0,null),J=[];let K=-1;const W=new q,Z=new P;for(let t=Q.next();null!==t;t=Q.next()){if(t.isEmpty())continue;const n=Q.getGeometryID(),s=e.getPathIndexFromPointIndex(n);e.isClosedPath(s)&&G.getPathEnd(s);const o=t;for(let e=0,t=o.getPathCount();e<t;++e){J.length=0;for(let t=o.getPathStart(e),n=o.getPathEnd(e);t<n;++t)J.push(o.getXY(t));if(D&&(new d).transform(D,J,J.length,J,!1),J.length>3){const e=k(J,J.length,I,R,1);if(e.m_distance<b){b=e.m_distance,W.assign(h(V.majorSemiAxis,V.e2,e.m_coordinate.mul(B))),K=n;let t=e.m_vertexIndex;t+1===J.length&&(t-=1),o.getSegmentBuffer(t,Z,!0)}}J.forEach(e=>e.mulThis(B));const t=h(V.majorSemiAxis,V.e2,J[0]),s=new q;for(let e=1,r=J.length;e<r;++e){const r=h(V.majorSemiAxis,V.e2,J[e]);if(w(L,M,t,r,s)<b){const{second:s}=E(V.majorSemiAxis,V.e2,M,t,r,2,null);if(s<=b){const s=new q,{second:i}=E(V.majorSemiAxis,V.e2,M,t,r,0,s);i<b&&(b=i,W.assign(s),K=n,o.getSegmentBuffer(e-1,Z,!0))}}t.assign(r)}}}if(!Number.isFinite(b))return g();-1===K&&n("");const $=_(V.majorSemiAxis,V.e2,W);$.divThis(B);const ee=$.clone(),te=m!==m.getGCS()?m.getGCSToSRTransform():null;te&&(new d).transform(te,[$],1,[ee],!1),ee.isNAN()&&a("closestPoint2DSr.isNAN()"),c(!Z.empty());const ne=Z.get().getClosestCoordinate(ee,!1);ee.assign(Z.get().getCoord2D(ne)),D?(new d).transform(D,[ee],1,[$],!1):$.assign(ee),c(!$.isNAN());const se=this.getNearestVertex(new U($),I,m.getGCS()),oe=f(ee,K,se.m_distance);if(j&&e.getDimension()>0){const n=y(e,t,-1,-1),s=0!==n&&3!==n;oe.m_bRightSide=s}return oe}getNearestVertex(e,t,o){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return g();switch(e.getGeometryType()){case s.enumPoint:return V(e,t,o);case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return Y(e,t,o);default:r("")}}getNearestVertexPoint2D(e,t,n,s){return k(e,t,n,s)}getNearestVertices(o,a,c,u,g){if(a.isNAN()&&n("NAN xy coordinates are not allowed"),o.isEmpty())return[];switch(o.getGeometryType()){case s.enumPoint:{const e=V(o,a,c);if(!e.isEmpty()&&e.m_distance<u&&g>=1){const t=[];return t.push(e),t}return[]}case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return function(s,o,r,a,c){const u={stack:[],error:void 0,hasError:!1};try{0===r.getCoordinateSystemType()&&n("Cannot use local SR");let t=s.getAttributeStreamRef(0),g=s.getPointCount();const y=r.getGCS(),S=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(j(e,[o],1,[S],null),S.isNAN())return[];const n=(new d).execute(s,e,null);t=n.getAttributeStreamRef(0),g=n.getPointCount()}const N=y.getUnit().getUnitToBaseFactor(),p=m(g,0);for(let e=0;e<g;++e)p[e]=e;T(g,p);const A=x();y.querySpheroidData(A);const C=S.clone();C.scale(N);const P=h(A.majorSemiAxis,A.e2,C),w=[];let E=g;const _=new i,G=new i;for(let e=0;e<E;){if(t.queryPoint2D(2*p[e],_),_.isNAN())continue;G.assign(_),G.scale(N);const n=h(A.majorSemiAxis,A.e2,G);q.distance(n,P)>a?(p[E-1]=l(p[e],p[e]=p[E-1]),E--):e++}const D=(e,t)=>e.m_distance-t.m_distance,b=e(u,new I,!1);for(let e=0;e<E;e++)t.queryPoint2D(2*p[e],_),_.isNAN()||(v.geodeticDistance(A.majorSemiAxis,A.e2,C.x,C.y,_.x*N,_.y*N,b,null,null,R.PE_LINETYPE_GEODESIC),b.val<a&&w.push(f(_,p[e],b.val)));return w.sort(D),w.slice(0,c)}catch(e){u.error=e,u.hasError=!0}finally{t(u)}}(o,a,c,u,g);default:r("")}}}function V(s,o,r){const a={stack:[],error:void 0,hasError:!1};try{if(0===r.getCoordinateSystemType()&&n("Cannot use local SR"),1!==r.getCoordinateSystemType()){const e=new Array(2);e[0]=s.getXY(),e[1]=o.clone();const t=u(i,2);2!==b(r,e,2,t)&&n("Point cannot be projected to GCS");const a=r.getGCS(),c=V(new U(t[0]),t[1],a);return f(c.m_coordinate,0,c.m_distance)}const t=r.getUnit().getUnitToBaseFactor(),c=s.getXY();c.scale(t);const m=o.clone();m.scale(t);const l=x();r.querySpheroidData(l);const g=e(a,new I,!1);v.geodeticDistance(l.majorSemiAxis,l.e2,c.x,c.y,m.x,m.y,g,null,null,R.PE_LINETYPE_GEODESIC);const y=s.getXY();return f(y,0,g.val)}catch(e){a.error=e,a.hasError=!0}finally{t(a)}}function Y(s,o,r,a=0){0===r.getCoordinateSystemType()&&n("Cannot use local SR");let c=s.getAttributeStreamRef(0),u=s.getPointCount();const g=r.getGCS(),y=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(j(e,[o],1,[y],null),y.isNAN())return f(i.getNAN(),-1,Number.NaN);const t=(new d).execute(s,e,null);c=t.getAttributeStreamRef(0),u=t.getPointCount()}const S=g.getUnit().getUnitToBaseFactor(),N=m(u,0);for(let e=0;e<u;++e)N[e]=e;T(u,N);const p=x();g.querySpheroidData(p);const A=y.clone();A.scale(S);const C=h(p.majorSemiAxis,p.e2,A);let P=-1,w=Number.MAX_VALUE;const E=G(p.majorSemiAxis,p.e2);let _=u;const b=new i,R=new i;for(let e=0;e<_;){if(c.queryPoint2D(2*N[e],b),b.isNAN())continue;R.assign(b),R.scale(S);const t=h(p.majorSemiAxis,p.e2,R);if(q.distance(t,C)>w){N[_-1]=l(N[e],N[e]=N[_-1]),_--;continue}const n=D(E,t,C);n<w&&(P=N[e],w=n),e++}if(0!==p.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new I,!1);for(let e=0;e<_;e++){if(c.queryPoint2D(2*N[e],b),b.isNAN())continue;R.assign(b),R.scale(S);const n=h(p.majorSemiAxis,p.e2,R);q.distance(n,C)>w||(v.geodeticDistance(p.majorSemiAxis,p.e2,A.x,A.y,R.x,R.y,t,null,null,a),t.val<w&&(P=N[e],w=t.val))}}catch(e){n.error=e,n.hasError=!0}finally{t(n)}}const U=new i;return-1!==P&&U.assign(s.getXY(P)),f(U,P,w)}function k(s,o,r,a,c=0){0===a.getCoordinateSystemType()&&n("Cannot use local SR");const y=a.getGCS(),S=r.clone();if(1!==a.getCoordinateSystemType()){const e=a.getSRToGCSTransform();if(j(e,[r],1,[S],null),S.isNAN())return g();const t=u(i,o);j(e,s,o,t,null);const n=k(t,o,r,y,c);return n.isEmpty()?n:f(s[n.m_vertexIndex],n.m_vertexIndex,n.m_distance)}const d=y.getUnit().getUnitToBaseFactor(),N=m(o,0);for(let e=0;e<o;++e)N[e]=e;T(o,N);const p=x();y.querySpheroidData(p);const A=S.clone();A.scale(d);const C=h(p.majorSemiAxis,p.e2,A);let P=-1,w=Number.MAX_VALUE;const E=G(p.majorSemiAxis,p.e2);let _=o;for(let e=0;e<_;){const t=s[N[e]];if(t.isNAN())continue;const n=t.clone();n.scale(d);const o=h(p.majorSemiAxis,p.e2,n);if(q.distance(o,C)>w){N[_-1]=l(N[e],N[e]=N[_-1]),_--;continue}const r=D(E,o,C);r<w&&(P=N[e],w=r),e++}if(0!==p.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new I,!1);for(let e=0;e<_;e++){const n=s[N[e]];if(n.isNAN())continue;const o=n.clone();o.scale(d);const r=h(p.majorSemiAxis,p.e2,o);q.distance(r,C)>w||(v.geodeticDistance(p.majorSemiAxis,p.e2,A.x,A.y,o.x,o.y,t,null,null,c),t.val<w&&(P=N[e],w=t.val))}}catch(e){n.error=e,n.hasError=!0}finally{t(n)}}const b=new i;return-1!==P&&b.assign(s[P]),f(b,P,w)}class X extends B{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{F as OperatorProximityGeodesic};
