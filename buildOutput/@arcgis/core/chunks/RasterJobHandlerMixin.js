/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{property as r}from"../core/accessorSupport/decorators/property.js";import"../core/lang.js";import"./Logger.js";import{subclass as t}from"../core/accessorSupport/decorators/subclass.js";import o from"../core/Error.js";import{open as n}from"../core/workers/workers.js";import a from"../layers/support/PixelBlock.js";import{c as i}from"./vectorFieldUtils.js";import{n as s}from"./rasterRendererHelper.js";import{a as l}from"./dataUtils.js";class c{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await n("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=e.pixelBlock.getTransferableObject().pixelBlock,n=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:t,type:e.dataType},r);return n?new a(n):null}async convertPixelBlockToFeatures(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("convertPixelBlockToFeatures",{pixelBlock:e.pixelBlock.toJSON(),extent:e.extent.toJSON(),fieldNames:e.fieldNames,skipFactor:e.skipFactor,pixelIdOffset:e.pixelIdOffset,imageRowSize:e.imageRowSize},r),n=e.extent.spatialReference?.toJSON();return t.forEach(e=>e.geometry.spatialReference=n),t}computeStatisticsHistograms(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const{transferList:t,pixelBlock:n}=e.pixelBlock.getTransferableObject();return r?.transferPixelsToWorker&&(r={...r,transferList:t}),this._workerThread.invoke("computeStatisticsHistograms",{...e,pixelBlock:n},r)}async decode(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("decode",e,{...r,transferList:[e.data]});return t?new a(t):null}async symbolize(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=e.pixelBlock?.getTransferableObject().pixelBlock,n={extent:e.extent?.toJSON(),pixelBlock:t,simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},i=await this._workerThread.invoke("symbolize",n,r);return i?new a(i):null}async highlightPixels(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t={pixelBlock:e.pixelBlock?.toJSON(),renderedPixelBlock:e.renderedPixelBlock?.toJSON(),highlightOptions:e.highlightOptions},n=await this._workerThread.invoke("highlightPixels",t,r);e.renderedPixelBlock.pixels=n.pixels,e.renderedPixelBlock.mask=n.mask,e.renderedPixelBlock.maskIsAlpha=n.maskIsAlpha}async updateSymbolizer(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=e?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:e.toJSON(),histograms:t},r))}async updateRasterFunction(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");await Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:e.toJSON()},r))}async process(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("process",{extent:e.extent?.toJSON(),primaryPixelSizes:e.primaryPixelSizes?.map(e=>null!=e?e.toJSON():null),primaryPixelBlocks:e.primaryPixelBlocks.map(e=>e?.getTransferableObject().pixelBlock),primaryRasterIds:e.primaryRasterIds},r);return t?new a(t):null}async stretch(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const t={srcPixelBlock:e.pixelBlock.getTransferableObject().pixelBlock,stretchParams:e.stretchParams},n=await this._workerThread.invoke("stretch",t,r);return n?new a(n):null}async split(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const t={srcPixelBlock:e.pixelBlock.getTransferableObject().pixelBlock,tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel,useBilinear:e.useBilinear},n=await this._workerThread.invoke("split",t,r);return n&&n.forEach((e,r)=>{n.set(r,e?a.fromJSON(e):null)}),n}async clipTile(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const t=e.pixelBlock.getTransferableObject().pixelBlock,n={...e,pixelBlock:t},i=await this._workerThread.invoke("clipTile",n,r);return i?a.fromJSON(i):null}async estimateStatisticsHistograms(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const t={srcPixelBlock:e.pixelBlock.getTransferableObject().pixelBlock};return await this._workerThread.invoke("estimateStatisticsHistograms",t,r)}async mosaicAndTransform(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");if(!e?.srcPixelBlocks?.length)return{pixelBlock:null};const t=e.srcPixelBlocks.map(e=>e?.getTransferableObject()),n={...e,srcPixelBlocks:t.map(e=>e?.pixelBlock)};if(r?.transferPixelsToWorker){const e=t.flatMap(e=>e?.transferList).filter(e=>null!=e);r={...r,transferList:e}}const i=await this._workerThread.invoke("mosaicAndTransform",n,r);return{pixelBlock:i.pixelBlock?new a(i.pixelBlock):null,localNorthDirections:i.localNorthDirections}}async createFlowMesh(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t={buffer:e.flowData.data.buffer,maskBuffer:e.flowData.mask.buffer,width:e.flowData.width,height:e.flowData.height},{meshType:n,simulationSettings:a}=e,i=await this._workerThread.invoke("createFlowMesh",{meshType:n,flowData:t,simulationSettings:a},{...r,transferList:[t.buffer,t.maskBuffer]});return{vertexData:new Float32Array(i.vertexBuffer),indexData:new Uint32Array(i.indexBuffer)}}getProjectionOffsetGrid(e,r){if(!this._workerThread)throw new o("raster-jobhandler:no-connection","no available worker connection");const t=null!=e.datumTransformation?e.datumTransformation.steps.map(e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse})):null,n=null!=e.rasterTransform?e.rasterTransform.toJSON():null,a={projectedExtent:e.projectedExtent.toJSON(),srcBufferExtent:e.srcBufferExtent.toJSON(),pixelSize:e.pixelSize,hasWrapAround:e.hasWrapAround,spacing:e.spacing,datumTransformationSteps:t,rasterTransform:n,isAdaptive:e.isAdaptive,includeGCSGrid:e.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",a,r)}}const h=o=>{const n=o;let a=class extends n{constructor(){super(...arguments),this._rasterJobHandlerConfig={instance:null,refCount:0,connectionPromise:null}}get _rasterJobHandler(){return this._rasterJobHandlerConfig.instance}increaseRasterJobHandlerUsage(){this._rasterJobHandlerConfig.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandlerConfig.refCount--,this._rasterJobHandlerConfig.refCount<=0&&this._shutdownJobHandler()}async convertVectorFieldData(e,r,t){if(null==e)return null;const o=this._rasterJobHandler;return o?o.convertVectorFieldData({pixelBlock:e,dataType:r},t):i(e,r)}async createFlowMesh(e,r){const t=this._rasterJobHandler;return t?t.createFlowMesh(e,r):l(e.meshType,e.simulationSettings,e.flowData,null!=r.signal?r.signal:(new AbortController).signal)}_initJobHandler(){const{_rasterJobHandlerConfig:e}=this;if(e.connectionPromise)return e.connectionPromise;const r=new c;return e.connectionPromise=r.initialize().then(()=>{e.instance=r,this.notifyChange("_rasterJobHandler")},()=>{}),e.connectionPromise}_shutdownJobHandler(){const{_rasterJobHandlerConfig:e}=this;e.instance?.destroy(),e.instance=null,e.connectionPromise=null,e.refCount=0,this.notifyChange("_rasterJobHandler"),this._cachedRendererJson=void 0}async _updateSymbolizer(e,r,t,o){const n=this._rasterJobHandlerConfig.instance;if(!n)return;const a=s({...r.toJSON(),variableName:t});JSON.stringify(this._cachedRendererJson)!==JSON.stringify(a)&&(o&&(e.rasterInfo=o),e.rendererJSON=a,e.bind(),await n.updateSymbolizer(e),this._cachedRendererJson=r.toJSON())}async _symbolize(e,r){const{pixelData:t,bandIds:o,simpleStretchParams:n}=e,a=this._rasterJobHandler;if(a){const e=await a.symbolize({...t,simpleStretchParams:n,bandIds:o},r);return{extent:t.extent,pixelBlock:e}}const i=e.symbolizer.symbolize({...t,simpleStretchParams:n,bandIds:o});return{extent:t.extent,pixelBlock:i}}};return e([r({clonable:!1})],a.prototype,"_rasterJobHandler",null),e([r({clonable:!1})],a.prototype,"_cachedRendererJson",void 0),e([r({clonable:!1})],a.prototype,"_rasterJobHandlerConfig",void 0),a=e([t("esri.layers.mixins.RasterJobHandlerMixin")],a),a};export{h as R};
