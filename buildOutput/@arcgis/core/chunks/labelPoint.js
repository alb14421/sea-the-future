/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clone as t}from"../core/lang.js";import{c as e,r as s}from"../geometry/Polygon.js";import{isPolygon as i,isPolyline as n,isMultipoint as h,isExtent as r,isPoint as o}from"../geometry/support/jsonUtils.js";import{O as a}from"./OptimizedGeometry.js";import{c as p}from"./aaBoundingRect.js";import{d as u,e as _}from"./boundsUtils.js";import{p as c}from"./coordsUtils.js";import{s as l}from"../geometry/Extent.js";class d{static fromOptimized(t,e,s=!1,i=!1,n=1){return(new f).initialize(t,e,s,i,n)}static fromJSON(t,e=!1,s=!1){const[i,n]=y(t);return(new g).initialize(i,n,e,s,1)}static fromOptimizedCIM(t,e,s=!1,i=!1,n=1){return(new x).initialize(t,e,s,i,n)}static fromJSONCIM(t,e=!1,s=!1,i=1){const[n,h]=y(t);return(new P).initialize(n,h,e,s,i)}static fromFeatureSetReader(t){const e=t.readGeometryForDisplay(),s=t.geometryType;return e&&s?this.fromOptimized(e,s):null}static fromFeatureSetReaderCIM(t){const e=t.readGeometryForDisplay(),s=t.geometryType;return e&&s?this.fromOptimizedCIM(e,s):null}static createEmptyOptimized(t,e=!1,s=!1,i=1){return(new f).initialize(new a,t,e,s,i)}static createEmptyJSON(t,e=!1,s=!1){return(new g).initialize([],t,e,s,1)}static createEmptyOptimizedCIM(t,e=!1,s=!1,i=1){return(new x).initialize(new a,t,e,s,i)}static createEmptyJSONCIM(t,e=!1,s=!1,i=1){return(new P).initialize([],t,e,s,i)}asJSON(){const t=e(this);return"esriGeometryEnvelope"===this.geometryType?{xmin:t[0][0][0],ymin:t[0][0][1],xmax:t[0][2][0],ymax:t[0][2][1]}:"esriGeometryMultipoint"===this.geometryType?{points:t.flat()}:"esriGeometryPoint"===this.geometryType?{x:t[0][0][0],y:t[0][0][1]}:"esriGeometryPolygon"===this.geometryType?{rings:t}:{paths:t}}getCurrentRingArea(){if(this.pathSize<3)return 0;let t,e,s=0;if(this.seekPathStart(),!this.nextPoint())return 0;t=this.x,e=this.y;const i=t,n=e;for(;this.nextPoint();)s+=(t-this.x)*(e+this.y),t=this.x,e=this.y;return s+=(t-i)*(e+n),-.5*s}invertY(){this.yFactor*=-1}}class f extends d{constructor(){super(...arguments),this._end=-1}initialize(t,e,s,i,n){return this.hasZ=s,this.hasM=i,this.geometryType=e,this._stride=2+Number(s)+Number(i),this._geometry=t,this._pathIndex=-1,this._pathOffset=0,this._pointOffset=-this._stride,this._end=-1,this.yFactor=n,this}reset(){this.initialize(this._geometry,this.geometryType,this.hasZ,this.hasM,this.yFactor)}seekPath(t){if(t>=0&&t<this.totalSize){if(this._pathIndex<t)for(;this._pathIndex<t&&this.nextPath(););else if(this._pathIndex>t)for(;this._pathIndex>t&&this.prevPath(););return!0}return!1}seekPathStart(){this._pointOffset=this._pathOffset-this._stride}seekPathEnd(){this._pointOffset=this._end}seekInPath(t){const e=this._pathOffset+t*this._stride;return e>=0&&e<this._end&&(this._pointOffset=e,!0)}nextPoint(){return(this._pointOffset+=this._stride)<this._end}prevPoint(){return(this._pointOffset-=this._stride)>=this._pathOffset}nextPath(){return!(this.pathIndex>=this.totalSize-1||(this._pathIndex>=0&&(this._pathOffset+=this._stride*this.pathSize),this._pathIndex++,this._pointOffset=this._pathOffset-this._stride,this._end=this._pointOffset+this._stride+this._stride*this.pathSize,0))}prevPath(){return!(this.pathIndex<=0||(this._pathIndex--,this._end=this._pathOffset,this._pathOffset-=this._stride*this.pathSize,this._pointOffset=this._pathOffset-this._stride,0))}getCurrentPath(){const t=this._end,e=this._geometry.coords,s=this._pathOffset;return(new f).initialize(new a([this.pathSize],e.slice(s,t)),this.geometryType,this.hasZ,this.hasM,this.yFactor)}pathLength(){const t=this._end,e=this._stride,s=this._geometry.coords;let i=0;for(let n=this._pathOffset+e;n<t;n+=e){const t=s[n-e],h=s[n-e+1],r=s[n]-t,o=s[n+1]-h;i+=Math.sqrt(r*r+o*o)}return i}startPath(){this._geometry.lengths.push(0)}pushPath(t){this.startPath(),this.pushPoints(t)}pushPoint(t){for(let e=0;e<this._stride;++e)this._geometry.coords.push(t[e]);this._geometry.lengths[this.totalSize-1]++}pushXY(t,e){this._geometry.coords.push(t,e),this._geometry.lengths[this.totalSize-1]++}pushPoints(t){for(const e of t)for(let t=0;t<this._stride;++t)this._geometry.coords.push(e[t]);this._geometry.lengths[this.totalSize-1]+=t.length}pushCursor(t){const e=t.asOptimized();this._geometry.coords.push(...e.coords),this._geometry.lengths.push(...e.lengths)}asOptimized(){const t=this._geometry.clone();if(1!==this.yFactor)for(let e=1;e<t.coords.length;e+=this._stride)t.coords[e]*=this.yFactor;return"esriGeometryPoint"===this.geometryType&&(t.lengths.length=0),t}isClosed(){const t=this._geometry.coords,e=this._pathOffset,s=this._end-this._stride;for(let i=0;i<this._stride;i++)if(t[e+i]!==t[s+i])return!1;return!0}clone(){return(new f).initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._geometry.isPoint?1:this._geometry.lengths.reduce((t,e)=>t+e)}get pathSize(){const{lengths:t}=this._geometry;return this._geometry.isPoint?1:this._pathIndex<0||this._pathIndex>t.length-1?0:t[this._pathIndex]}get totalSize(){return this._geometry.isPoint?1:this._geometry.lengths.length}get x(){return this._geometry.coords[this._pointOffset]}set x(t){this._geometry.coords[this._pointOffset]=t}get y(){return this.yFactor*this._geometry.coords[this._pointOffset+1]}set y(t){this._geometry.coords[this._pointOffset+1]=this.yFactor*t}get z(){return this._geometry.coords[this._pointOffset+2]}set z(t){this._geometry.coords[this._pointOffset+2]=t}get m(){const t=this.hasZ?3:2;return this._geometry.coords[this._pointOffset+t]}set m(t){this._geometry.coords[this._pointOffset+3]=t}get pathIndex(){return this._pathIndex}get _coordIndex(){return this._pointOffset/this._stride}}function m(t){const e=[t.x,t.y];return t.z&&e.push(t.z),t.m&&e.push(t.m),e}function y(t){return i(t)?[t.rings,"esriGeometryPolygon"]:n(t)?[t.paths,"esriGeometryPolyline"]:h(t)?[[t.points],"esriGeometryMultipoint"]:r(t)?[[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]],"esriGeometryEnvelope"]:o(t)?[[[m(t)]],"esriGeometryPoint"]:[[],"esriGeometryPolyline"]}class g extends d{initialize(t,e,s,i,n){return this._paths=t,this.geometryType=e,this.hasZ=s,this.hasM=i,this._pathIndex=this._pointIndex=-1,this.yFactor=n,this._mIndex=this.hasZ?3:2,this}reset(){this._pathIndex=this._pointIndex=-1}seekPath(t){return this._pathIndex=t,this._pointIndex=-1,t>=0&&t<this.totalSize&&(this._currentPath=this._paths[t],!0)}seekPathStart(){this._pointIndex=-1}seekPathEnd(){this._pointIndex=this._currentPath.length}seekInPath(t){return t>=0&&t<this._currentPath.length&&(this._pointIndex=t,this._currentPoint=this._currentPath[this._pointIndex],!0)}nextPoint(){return this._currentPoint=this._currentPath[++this._pointIndex],this._pointIndex<this._currentPath.length}prevPoint(){return this._currentPoint=this._currentPath[--this._pointIndex],this._pointIndex>=0}nextPath(){return this._pointIndex=-1,this._currentPath=this._paths[++this._pathIndex],this._pathIndex<this.totalSize}prevPath(){return this.pathIndex>0&&(this._pointIndex=-1,this._pathIndex--,this._currentPath=this._paths[this._pathIndex],!0)}pathLength(){const t=this._currentPath.length,e=this._currentPath;let s=0;for(let i=1;i<t;i++){const t=e[i-1],n=e[i],h=t[0],r=t[1],o=n[0]-h,a=n[1]-r;s+=Math.sqrt(o*o+a*a)}return s}startPath(){this._paths.push([])}getCurrentPath(){return(new g).initialize([this._currentPath],this.geometryType,this.hasZ,this.hasM,this.yFactor)}pushPath(t){this._paths.push(t)}pushPoint(t){this._paths[this.totalSize-1].push(t)}pushXY(t,e){this._paths[this.totalSize-1].push([t,e])}pushPoints(t){this._paths[this.totalSize-1].push(...t)}pushCursor(t){const s=e(t);for(const t of s)this.pushPath(t)}asOptimized(){const t=new a;if("esriGeometryPoint"===this.geometryType)t.coords.push(...this._paths[0][0]),t.lengths.length=0;else for(const e of this._paths){for(const s of e)t.coords.push(s[0]),t.coords.push(s[1]*this.yFactor),this.hasZ&&t.coords.push(s[2]),this.hasM&&t.coords.push(s[this._mIndex]);t.lengths.push(e.length)}return t}isClosed(){const t=this._currentPath[0],e=this._currentPath[this._currentPath.length-1];for(let s=0;s<t.length;s++)if(t[s]!==e[s])return!1;return!0}clone(){return(new g).initialize(t(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}get totalPoints(){return this._paths.map(t=>t.length).reduce((t,e)=>t+e)}get pathSize(){return this._pathIndex<0||this._pathIndex>this.totalSize-1?-1:this._paths[this._pathIndex].length}get totalSize(){return this._paths.length}get x(){return this._currentPoint[0]}set x(t){this._currentPoint[0]=t}get y(){return this.yFactor*this._currentPoint[1]}set y(t){this._currentPoint[1]=this.yFactor*t}get z(){return this._currentPoint[2]}set z(t){this._currentPoint[2]=t}get m(){return this._currentPoint[this._mIndex]}set m(t){this._currentPoint[this._mIndex]=t}get pathIndex(){return this._pathIndex}}class x extends f{initialize(t,e,s,i,n){return super.initialize(t,e,s,i,n),this._controlPoints||(this._controlPoints=this._controlPoints=new Array(this.totalSize).fill(void 0).map(t=>new Set)),this}startPath(){super.startPath(),this._controlPoints.push(new Set)}clone(){const t=(new x).initialize(this._geometry.clone(),this.geometryType,this.hasZ,this.hasM,this.yFactor);return t._controlPoints=this._controlPoints,t}setControlPoint(){this._controlPoints[this.pathIndex].add(this._coordIndex)}getControlPoint(){return this._controlPoints[this.pathIndex].has(this._coordIndex)}setControlPointAt(t){this._controlPoints[this.pathIndex].add(t)}getControlPointAt(t){return this._controlPoints[this.pathIndex].has(t)}}class P extends g{initialize(t,e,s,i,n){return super.initialize(t,e,s,i,n)}clone(){return(new P).initialize(t(this._paths),this.geometryType,this.hasZ,this.hasM,this.yFactor)}setControlPoint(){this._paths[this.pathIndex][this._pointIndex][4]=1}getControlPoint(){return 1===this._paths[this.pathIndex][this._pointIndex][4]}setControlPointAt(t){this._paths[this.pathIndex][t][4]=1}getControlPointAt(t){return 1===this._paths[this.pathIndex][t][4]}}function N(t){if(0===t.totalSize)return null;const e=u(t);if(!e)return null;const i=4*(Math.abs(e[0])+Math.abs(e[2])+Math.abs(e[1])+Math.abs(e[3])+1)*222045e-19;let n=0,h=0;t.reset();for(let e=0;t.nextPath();e++){const s=t.getCurrentRingArea();s>h&&(h=s,n=e)}if(t.seekPath(n),0===t.pathSize)return null;t.seekPathStart();const r=_(t);if(Math.abs(h)<=2*i*i)return[(r[0]+r[2])/2,(r[1]+r[3])/2];t.seekPathStart();const o=s(t,p());if(null===o)return null;if(t.totalPoints<4)return o;const a=[[NaN,NaN],[NaN,NaN],[NaN,NaN],[NaN,NaN]],c=[NaN,NaN,NaN,NaN],l=[NaN,NaN,NaN,NaN];let d=!1,f=z(o,t,!0);0===f.distance&&(d=!0,a[0][0]=o[0],a[0][1]=o[1],f=z(o,t,!1)),c[0]=f.distance,l[0]=0;const m=[NaN,NaN];let y=!1,g=.25,x=-1,P=NaN;do{if(P=NaN,a[1]=O(t,G(r[0],r[2],g),0,e),isNaN(a[1][0])||isNaN(a[1][1])||(f=z(a[1],t,!1),P=f.distance),!isNaN(P)&&P>i&&I(a[1],t))y=!0,c[1]=P,l[1]=b(a[1],o);else if(!isNaN(P)&&P>x&&(x=P,m[0]=a[1][0],m[1]=a[1][1]),g-=.01,g<.1){if(!(x>=0))break;y=!0,c[1]=x,a[1][0]=m[0],a[1][1]=m[1],l[1]=b(a[1],o)}}while(!y);y=!1,g=.5,x=-1;let N=.01,S=1;do{if(P=NaN,a[2]=O(t,G(r[0],r[2],g),0,e),isNaN(a[2][0])||isNaN(a[2][1])||(f=z(a[2],t,!1),P=f.distance),!isNaN(P)&&P>i&&I(a[2],t))y=!0,c[2]=P,l[2]=b(a[2],o);else if(!isNaN(P)&&P>x)x=P,m[0]=a[2][0],m[1]=a[2][1];else if(P>x&&(x=P,m[0]=a[2][0],m[1]=a[2][1]),g=.5+N*S,N+=.01,S*=-1,g<.3||g>.7){if(!(x>=0))break;y=!0,c[2]=x,a[2][0]=m[0],a[2][1]=m[1],l[2]=b(a[2],o)}}while(!y);y=!1,g=.75,x=-1;do{if(P=NaN,a[3]=O(t,G(r[0],r[2],g),0,e),isNaN(a[3][0])||isNaN(a[3][1])||(f=z(a[3],t,!1),P=f.distance),!isNaN(P)&&P>i&&I(a[3],t))y=!0,c[3]=P,l[3]=b(a[3],o);else if(P>x&&(x=P,m[0]=a[3][0],m[1]=a[3][1]),g+=.01,g>.9){if(!(x>=0))break;y=!0,c[3]=x,a[3][0]=m[0],a[3][1]=m[1],l[3]=b(a[3],o)}}while(!y);const M=[0,1,2,3],w=d?0:1;let C;for(let t=w;t<4;t++)for(let t=w;t<3;t++){const e=l[t],s=l[t+1];Z(e,s)>0&&(C=M[t],M[t]=M[t+1],M[t+1]=C,l[t]=s,l[t+1]=e)}let F=w,k=0,T=0;for(let t=w;t<4;t++){switch(t){case 0:T=2*c[M[t]];break;case 1:T=1.66666666*c[M[t]];break;case 2:T=1.33333333*c[M[t]];break;case 3:T=c[M[t]]}T>k&&(k=T,F=M[t])}return a[F]}function I(t,e){let s,i,n,h,r=0;for(e.reset();e.nextPath()&&e.nextPoint();)for(s=e.x,i=e.y;e.nextPoint();s=n,i=h)n=e.x,h=e.y,i>t[1]!=h>t[1]&&((n-s)*(t[1]-i)-(h-i)*(t[0]-s)>0?r++:r--);return 0!==r}function z(t,e,s){if(s&&I(t,e))return{coord:t,distance:0};let i=1/0,n=0,h=0,r=[0,0],o=[0,0];const a=[0,0];for(e.reset();e.nextPath()&&e.nextPoint();)if(!(e.pathSize<2))for(r[0]=e.x,r[1]=e.y;e.nextPoint();r=o){o=[e.x,e.y],c(a,t,r,o);const s=b(t,a);s<i&&(i=s,n=a[0],h=a[1])}return{coord:[n,h],distance:Math.sqrt(i)}}function O(t,e,s,i){const n=[e,0];let h=1/0,r=1/0,o=!1,a=!1;const u=[[e,i[1]-1],[e,i[3]+1]],_=[0,0],c=[0,0],d=[0,0],f=[[0,0],[0,0]],m=p();for(t.reset();t.nextPath()&&t.nextPoint();)if(!(t.pathSize<2))for(f[0][0]=t.x,f[0][1]=t.y;t.nextPoint();f[0][0]=f[1][0],f[0][1]=f[1][1]){if(f[1][0]=t.x,f[1][1]=t.y,null===S(m,f))continue;if(c[0]=u[0][0],c[1]=u[0][1],d[0]=u[1][0],d[1]=u[1][1],0===k(m,c,d))continue;if(!l(u[0],u[1],f[0],f[1],_))continue;const e=_[1];h>r?e<h&&(h=e,o=!0):e<r&&(r=e,a=!0)}return o&&a?n[1]=(h+r)/2:n[0]=n[1]=NaN,n}function S(t,e){if(e.length<2)return null;t||(t=p());const[s,i]=e[0],[n,h]=e[1];return t[0]=Math.min(s,n),t[1]=Math.min(i,h),t[2]=Math.max(s,n),t[3]=Math.max(i,h),t}const M=1,w=4,C=3,F=12;function k(t,e,s){let i=T(e,t),n=T(s,t);const h=t[0],r=t[1],o=t[2],a=t[3];if(i&n)return 0;if(!(i|n))return 4;const p=(i?1:0)|(n?2:0);do{const p=s[0]-e[0],u=s[1]-e[1];if(p>u)i&C?(i&M?(e[1]+=u*(h-e[0])/p,e[0]=h):(e[1]+=u*(o-e[0])/p,e[0]=o),i=T(e,t)):n&C?(n&M?(s[1]+=u*(h-s[0])/p,s[0]=h):(s[1]+=u*(o-s[0])/p,s[0]=o),n=T(s,t)):i?(i&w?(e[0]+=p*(r-e[1])/u,e[1]=r):(e[0]+=p*(a-e[1])/u,e[1]=a),i=T(e,t)):(n&w?(s[0]+=p*(r-s[1])/u,s[1]=r):(s[0]+=p*(a-s[1])/u,s[1]=a),n=T(s,t));else if(i&F?(i&w?(e[0]+=p*(r-e[1])/u,e[1]=r):(e[0]+=p*(a-e[1])/u,e[1]=a),i=T(e,t)):n&F?(n&w?(s[0]+=p*(r-s[1])/u,s[1]=r):(s[0]+=p*(a-s[1])/u,s[1]=a),n=T(s,t)):i?(i&M?(e[1]+=u*(h-e[0])/p,e[0]=h):(e[1]+=u*(o-e[0])/p,e[0]=o),i=T(e,t)):(n&M?(s[1]+=u*(h-s[0])/p,s[0]=h):(s[1]+=u*(o-s[0])/p,s[0]=o),n=T(s,t)),i&n)return 0}while(i|n);return p}function T(t,e){return(t[0]<e[0]?1:0)|(t[0]>e[2]?1:0)<<1|(t[1]<e[1]?1:0)<<2|(t[1]>e[3]?1:0)<<3}function G(t,e,s){return t+(e-t)*s}function b(t,e){return(t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])}function Z(t,e){if(t<e)return-1;if(t>e)return 1;if(t===e)return 0;const s=isNaN(t),i=isNaN(e);return s<i?-1:s>i?1:0}export{d as G,N as g};
