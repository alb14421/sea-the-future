/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{S as e,P as r}from"./CameraSpace.glsl.js";import{N as t,B as a,_ as s,k as o,R as i,x as n,$ as c}from"./Matrix4PassUniform.js";import{R as u}from"./sdfPrimitives.js";import{T as l,F as m}from"./Emissions.glsl.js";import{g as d}from"./glsl.js";import{S as p}from"./ShaderBuilder.js";import{q as f}from"../core/lang.js";import{m as h,d as g,p as b,u as _}from"./renderState.js";import{_ as x}from"./tslib.es6.js";class y extends t{constructor(){super(...arguments),this.opacity=1}}const F=Object.freeze(Object.defineProperty({__proto__:null,CompositingPassParameters:y,build:function(r){const t=new p;t.include(e),t.fragment.uniforms.add(new l("tex",e=>e.texture)),r.hasOpacityFactor&&t.fragment.uniforms.add(new m("opacity",e=>e.opacity));const o=3===r.blitMode;return o&&(t.fragment.uniforms.add(new a("nearFar",e=>e.camera.nearFar)),t.fragment.include(s),t.fragment.include(u)),t.fragment.main.add(d`
    ${o?d`
          float normalizedLinearDepth = (-linearDepthFromTexture(tex, uv) - nearFar[0]) / (nearFar[1] - nearFar[0]);
          fragColor = float2rgba(normalizedLinearDepth);`:d`
          fragColor = texture(tex, uv) ${r.hasOpacityFactor?"* opacity":""};`}`),t}},Symbol.toStringTag,{value:"Module"}));class j extends o{constructor(e,t){super(e,t,new i(F,()=>Promise.resolve().then(()=>F)),r)}initializePipeline(e){switch(e.blitMode){case 0:case 3:return h({colorWrite:g});case 1:return h({blending:_,colorWrite:g});default:f(e.blitMode);case 2:case 4:return h({blending:b,colorWrite:g})}}}class v extends c{constructor(){super(...arguments),this.blitMode=0,this.hasOpacityFactor=!1}}x([n({count:4})],v.prototype,"blitMode",void 0),x([n()],v.prototype,"hasOpacityFactor",void 0);class w{constructor(e,r=0){this._techniques=e,this._parameters=new y,this._configuration=new v,this._configuration.blitMode=r,e.precompile(j,this._configuration)}blit(e,r,t,a){e.bindFramebuffer(t.fbo),e.setClearColor(0,0,0,1),e.clear(16384),this._parameters.texture=r.getTexture();const s=this._techniques.get(j,this._configuration);e.bindTechnique(s,a,this._parameters),e.screen.draw()}blend(e,r,t,a,s=1){this._configuration.hasOpacityFactor=s<1;const o=this._techniques.get(j,this._configuration);return!!o.compiled&&(e.bindFramebuffer(t.fbo),this._parameters.texture=r.getTexture(),this._parameters.opacity=s,e.bindTechnique(o,a,this._parameters),e.screen.draw(),!0)}}function M(e){e.code.add("\n  vec4 blendColorsPremultiplied(vec4 source, vec4 dest) {\n    float oneMinusSourceAlpha = 1.0 - source.a;\n    return source + dest * oneMinusSourceAlpha;\n  }\n  ")}function P(e,r){return e[0]=r[0]*r[3],e[1]=r[1]*r[3],e[2]=r[2]*r[3],e[3]=r[3],e}export{M as B,v as C,w as a,y as b,j as c,P as p};
