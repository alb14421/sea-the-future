// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../core/has","../core/Logger","../core/mathUtils","../core/ObjectStack","../core/libs/gl-matrix-2/math/mat4","../core/libs/gl-matrix-2/factories/mat4f64","./vec32","../core/libs/gl-matrix-2/factories/vec3f64","../geometry/support/aaBoundingRect","../geometry/support/lineSegment","../geometry/support/plane","../geometry/support/ray","../geometry/support/vector","../geometry/support/vectorStacks"],function(t,e,n,i,o,s,r,a,c,u,g,l,d,b,p){"use strict";const f=()=>n.getLogger("esri.views.3d.support.geometryUtils.boundedPlane"),m=class{constructor(){this.plane=l.create(),this.origin=c.create(),this.basis1=c.create(),this.basis2=c.create()}};function h(t=K){return{plane:l.create(t.plane),origin:c.clone(t.origin),basis1:c.clone(t.basis1),basis2:c.clone(t.basis2)}}function y(t,e,n){const i=$.get();return i.origin=t,i.basis1=e,i.basis2=n,i.plane=l.wrap(0,0,0,0),I(i),i}function P(t,e=h()){return S(t.origin,t.basis1,t.basis2,e)}function v(t,e){a.copy(e.origin,t.origin),a.copy(e.basis1,t.basis1),a.copy(e.basis2,t.basis2),l.copy(e.plane,t.plane)}function S(t,e,n,i=h()){return a.copy(i.origin,t),a.copy(i.basis1,e),a.copy(i.basis2,n),I(i),o=i,s="fromValues()",Math.abs(a.dot(o.basis1,o.basis2)/(a.length(o.basis1)*a.length(o.basis2)))>1e-6&&f().warn(s,"Provided basis vectors are not perpendicular"),Math.abs(a.dot(o.basis1,W(o)))>1e-6&&f().warn(s,"Basis vectors and plane normal are not perpendicular"),Math.abs(-a.dot(W(o),o.origin)-o.plane[3])>1e-6&&f().warn(s,"Plane offset is not consistent with plane origin"),i;var o,s}function I(t){l.fromVectorsAndPoint(t.basis2,t.basis1,t.origin,t.plane)}function j(t,e,n){t!==n&&P(t,n);const i=a.scale(p.sv3d.get(),W(t),e);return a.add(n.origin,n.origin,i),n.plane[3]-=e,n}function x(t,e,n){return N(e,n),j(n,F(t,t.origin),n),n}function M(t,e){const n=t.basis1[0],i=t.basis2[1],[o,s]=t.origin;return u.fromValues(o-n,s-i,o+n,s+i,e)}function N(t,e=h()){const n=(t[2]-t[0])/2,i=(t[3]-t[1])/2;return a.set(e.origin,t[0]+n,t[1]+i,0),a.set(e.basis1,n,0,0),a.set(e.basis2,0,i,0),l.fromValues(0,0,1,0,e.plane),e}function V(t,e,n){return!!l.intersectRay(t.plane,e,n)&&G(t,n)}function A(t,e,n){if(V(t,e,n))return n;const i=w(t,e,p.sv3d.get());return a.add(n,e.origin,a.scale(p.sv3d.get(),e.direction,a.distance(e.origin,i)/a.length(e.direction))),n}function w(t,e,n){const o=Q.get();J(t,e,o,Q.get());let s=Number.POSITIVE_INFINITY;for(const r of tt){const c=H(t,r,X.get()),u=p.sv3d.get();if(l.intersectLineSegment(o,c,u)){const t=a.direction(p.sv3d.get(),e.origin,u),o=Math.abs(i.acosClamped(a.dot(e.direction,t)));o<s&&(s=o,a.copy(n,u))}}return s===Number.POSITIVE_INFINITY?E(t,e,n):n}function C(t,e){return(e-t)/e}function E(t,e,n){if(V(t,e,n))return n;const i=Q.get(),o=Q.get();J(t,e,i,o);let s=Number.POSITIVE_INFINITY;for(const r of tt){const c=H(t,r,X.get()),u=p.sv3d.get();if(l.intersectLineSegmentClamp(i,c,u)){const t=d.distance2(e,u);if(!l.isPointInside(o,u))continue;t<s&&(s=t,a.copy(n,u))}}return T(t,e.origin)<s&&L(t,e.origin,n),n}function L(t,e,n){const i=l.projectPoint(t.plane,e,p.sv3d.get()),o=g.projectPointClamp(D(t,t.basis1),i,-1,1,p.sv3d.get()),s=g.projectPointClamp(D(t,t.basis2),i,-1,1,p.sv3d.get());return a.subtract(n,a.add(p.sv3d.get(),o,s),t.origin),n}function O(t,e,n){const{origin:i,basis1:o,basis2:s}=t,r=a.subtract(p.sv3d.get(),e,i),c=b.projectPointSignedLength(o,r),u=b.projectPointSignedLength(s,r),g=b.projectPointSignedLength(W(t),r);return a.set(n,c,u,g)}function T(t,e){const n=O(t,e,p.sv3d.get()),{basis1:i,basis2:o}=t,s=a.length(i),r=a.length(o),c=Math.max(Math.abs(n[0])-s,0),u=Math.max(Math.abs(n[1])-r,0),g=n[2];return c*c+u*u+g*g}function q(t,e){return Math.sqrt(T(t,e))}function R(t,e){let n=Number.NEGATIVE_INFINITY;for(const i of tt){const o=H(t,i,X.get()),s=g.distance2(o,e);s>n&&(n=s)}return Math.sqrt(n)}function _(t,e){return l.isPointInside(t.plane,e)&&G(t,e)}function k(t,e,n,i){return function(t,e,n){switch(e){case 0:a.copy(n,t.basis1),a.normalize(n,n);break;case 1:a.copy(n,t.basis2),a.normalize(n,n);break;case 2:a.copy(n,W(t))}return n}(t,n,i)}function F(t,e){const n=-t.plane[3];return b.projectPointSignedLength(W(t),e)-n}function B(t,e,n,i){const o=F(t,e),s=a.scale(Z,W(t),n-o);return a.add(i,e,s),i}function U(t,e){return a.exactEquals(t.basis1,e.basis1)&&a.exactEquals(t.basis2,e.basis2)&&a.exactEquals(t.origin,e.origin)}function Y(t,e,n){return t!==n&&P(t,n),s.invert(et,e),s.transpose(et,et),a.transformMat4(n.basis1,t.basis1,et),a.transformMat4(n.basis2,t.basis2,et),a.transformMat4(l.getNormal(n.plane),l.getNormal(t.plane),et),a.transformMat4(n.origin,t.origin,e),l.setOffsetFromPoint(n.plane,n.plane,n.origin),n}function z(t,e,n,i){return t!==i&&P(t,i),s.fromRotation(nt,e,n),a.transformMat4(i.basis1,t.basis1,nt),a.transformMat4(i.basis2,t.basis2,nt),I(i),i}function W(t){return l.getNormal(t.plane)}function G(t,e){const n=a.subtract(p.sv3d.get(),e,t.origin),i=a.squaredLength(t.basis1),o=a.squaredLength(t.basis2),s=a.dot(t.basis1,n),r=a.dot(t.basis2,n);return-s-i<0&&s-i<0&&-r-o<0&&r-o<0}function D(t,e){const n=X.get();return a.copy(n.origin,t.origin),a.copy(n.vector,e),n}function H(t,e,n){const{basis1:i,basis2:o,origin:s}=t,r=a.scale(p.sv3d.get(),i,e.origin[0]),c=a.scale(p.sv3d.get(),o,e.origin[1]);a.add(n.origin,r,c),a.add(n.origin,n.origin,s);const u=a.scale(p.sv3d.get(),i,e.direction[0]),g=a.scale(p.sv3d.get(),o,e.direction[1]);return a.scale(n.vector,a.add(u,u,g),2),n}function J(t,e,n,i){const o=W(t);l.fromVectorsAndPoint(o,e.direction,e.origin,n),l.fromVectorsAndPoint(l.getNormal(n),o,e.origin,i)}const K={plane:l.create(),origin:c.fromValues(0,0,0),basis1:c.fromValues(1,0,0),basis2:c.fromValues(0,1,0)},Q=new o.ObjectStack(l.create),X=new o.ObjectStack(g.create),Z=c.create(),$=new o.ObjectStack(()=>h()),tt=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],et=r.create(),nt=r.create(),it=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:m,altitudeAt:F,axisAt:k,cameraFrustumCoverage:C,closestPoint:E,closestPointOnSilhouette:w,copy:P,copyWithoutVerify:v,create:h,distance:q,distance2:T,distanceToSilhouette:R,elevate:j,equals:U,extrusionContainsPoint:_,fromAABoundingRect:N,fromValues:S,getExtent:M,intersectRay:V,intersectRayClosestSilhouette:A,normal:W,projectPoint:L,projectPointLocal:O,rotate:z,setAltitudeAt:B,setExtent:x,transform:Y,up:K,updateUnboundedPlane:I,wrap:y},Symbol.toStringTag,{value:"Module"}));t.BoundedPlaneClass=m,t.altitudeAt=F,t.axisAt=k,t.boundedPlane=it,t.cameraFrustumCoverage=C,t.closestPoint=E,t.closestPointOnSilhouette=w,t.copy=P,t.copyWithoutVerify=v,t.create=h,t.distance=q,t.distance2=T,t.distanceToSilhouette=R,t.elevate=j,t.equals=U,t.extrusionContainsPoint=_,t.fromAABoundingRect=N,t.fromValues=S,t.getExtent=M,t.intersectRay=V,t.intersectRayClosestSilhouette=A,t.normal=W,t.projectPoint=L,t.projectPointLocal=O,t.rotate=z,t.setAltitudeAt=B,t.setExtent=x,t.transform=Y,t.up=K,t.updateUnboundedPlane=I,t.wrap=y});