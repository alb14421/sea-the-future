// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./tslib.es6","./Geometry","./MultiPathImpl","./ProjectionTransformation","./Point2D","./Envelope2D","./Envelope"],function(e,t,n,i,r,s,o,m){"use strict";function a(){return{outPoint:new s.Point2D,index:-1,t:Number.NaN}}function u(e,t,n){return{outPoint:e.clone(),index:t,t:n}}function c(e,t,n,i){e.outPoint.assign(t),e.index=n,e.t=i}function y(e,t){e.outPoint.assign(t.outPoint),e.index=t.index,e.t=t.t}function h(e,t,n,i){e.index=n,e.t=i,t.queryCoord2D(e.t,e.outPoint)}function l(e,t){const n=a();y(n,e),y(e,t),y(t,n)}function p(e,t,i,s,o,m){if(e.getGeometryType()===n.GeometryType.enumPolygon){for(;s.nextPath();)if(s.hasNextSegment()){const t=s.nextSegment();if(0!==r.isPoint2DInPolygon2D(e,t.getEndXY(),0))return c(o,t.getEndXY(),-1,Number.NaN),c(m,t.getEndXY(),-1,Number.NaN),!0}s.resetToFirstPath()}if(t.getGeometryType()===n.GeometryType.enumPolygon){for(;i.nextPath();)if(i.hasNextSegment()){const e=i.nextSegment();if(0!==r.isPoint2DInPolygon2D(t,e.getEndXY(),0))return c(o,e.getEndXY(),-1,Number.NaN),c(m,e.getEndXY(),-1,Number.NaN),!0}i.resetToFirstPath()}return!1}function g(e){const t=e.getPathCount(),n=s.makePrimitiveArray(e.getSegmentCount(),0);let r=0;for(let i=0;i<t;++i){const t=r+e.getSegmentCountPath(i);for(let s=r,o=e.getPathStart(i);s<t;++s,++o)n[s]=o;r=t}return i.shuffle(e.getPointCount(),n),n}function D(e,t){return!!Number.isNaN(t)||e<=t}function _(e){const t=new i.Polygon;return t.addEnvelope(e,!1),t}e.DistanceCalculator=class{constructor(e,t){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=t,this.m_maxSqrDistance=e*e,this.m_maxDistance=e,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=e,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let e=Math.sqrt(this.m_maxSqrDistance);for(;e<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,e=Math.sqrt(this.m_maxSqrDistance)}}calculate(e,t,n,i){if((e.getGeometryType()!==m.Point.type||t.getGeometryType()!==m.Point.type)&&(this.m_env2DgeometryA=new o.Envelope2D,this.m_env2DgeometryB=new o.Envelope2D,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!D(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const r=u(new s.Point2D,s.indexTypeMax(),Number.NaN),a=u(new s.Point2D,s.indexTypeMax(),Number.NaN),c=this._ExecuteBruteForce(e,t,r,a);return D(c,this.m_maxDistance)?(null!==n&&y(n,r),null!==i&&y(i,a),c):Number.POSITIVE_INFINITY}isNear(e,t){if(this.m_bIsNearCalc=!0,e.isEmpty()||t.isEmpty())return!1;if(e===t)return!0;let n=!0;if(e.getGeometryType()!==m.Point.type&&e.getGeometryType()!==m.Envelope.type||t.getGeometryType()!==m.Point.type&&t.getGeometryType()!==m.Envelope.type||(n=!1),n){if(this.m_env2DgeometryA=new o.Envelope2D,this.m_env2DgeometryB=new o.Envelope2D,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const i=u(new s.Point2D,s.indexTypeMax(),Number.NaN),r=u(new s.Point2D,s.indexTypeMax(),Number.NaN);return this._ExecuteBruteForce(e,t,i,r)<=this.m_maxDistance}progress_(e=!1){}_ExecuteBruteForce(e,t,i,r){switch(e.getGeometryType()){case n.GeometryType.enumPoint:return this.distancePointGeometry(e,t,i,r);case n.GeometryType.enumMultiPoint:return this.distanceMultipointGeometry(e,t,i,r);case n.GeometryType.enumEnvelope:return this.distanceEnvelopeGeometry(e,t,i,r);case n.GeometryType.enumPolyline:case n.GeometryType.enumPolygon:return this.distanceMultipathGeometry(e,t,i,r);default:return Number.NaN}}distancePointGeometry(e,t,i,r){switch(t.getGeometryType()){case n.GeometryType.enumPoint:return this.distancePointPoint(e,t,i,r);case n.GeometryType.enumMultiPoint:return this.distancePointMultipoint(e,t,i,r);case n.GeometryType.enumPolyline:case n.GeometryType.enumPolygon:return this.distancePointMultipath(e,t,i,r);case n.GeometryType.enumEnvelope:return this.distancePointEnvelope(e,t,i,r);default:return Number.NaN}}distancePointPoint(e,t,n,i){const r=e.getXY(),o=t.getXY();return c(n,r,0,0),c(i,o,0,0),Math.sqrt(s.Point2D.sqrDistance(r,o))}distancePointMultipoint(e,t,n,i){const r=e.getXY();let o=this.m_maxSqrDistance,m=o,a=!1;const u=t.getPointCount(),y=new s.Point2D;for(let e=0;e<u;++e)if(t.queryXY(e,y),m=s.Point2D.sqrDistance(r,y),this.m_bIsNearCalc){if(m<=o)return 0}else if(!(m>o)&&(!a&&m===o||m<o)&&(o=m,c(n,r,0,0),c(i,y,e,0),a=!0,0===o))return 0;return a?Math.sqrt(o):Number.POSITIVE_INFINITY}distancePointMultipath(e,t,i,m){const a=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),u=e.getXY();if(!a&&t.getGeometryType()===n.GeometryType.enumPolygon&&0!==r.isPoint2DInPolygon2D(t,u,0))return c(i,u,0,0),c(m,u,-1,Number.NaN),0;t.getImpl().getAccelerators();let y=this.m_maxSqrDistance,h=y,l=-1;const p=new o.Envelope2D,g=t.querySegmentIterator();let D=!1;for(;g.nextPath();)for(;g.hasNextSegment();){const e=g.nextSegment();e.queryEnvelope(p);const t=p.sqrDistance(u);if(t>y)continue;if(!this.m_bIsNearCalc&&D&&t===y)continue;l=e.getClosestCoordinate(u,!1);const n=e.getCoord2D(l);if(h=s.Point2D.sqrDistance(u,n),this.m_bIsNearCalc){if(h<=y)return 0}else if(!(h>y)&&(!D||h<y)&&(y=h,c(i,u,0,0),c(m,n,g.getStartPointIndex(),l),D=!0,0===y))return 0}return D?Math.sqrt(y):Number.POSITIVE_INFINITY}distancePointEnvelope(e,t,n,i){const r=e.getXY();c(n,r,0,0),c(i,r,-1,Number.NaN);const s=t.asEnvelope2D();return s.contains(r)?0:Math.sqrt(s.sqrDistance(r,i.outPoint))}distanceMultipointGeometry(e,t,i,r){switch(t.getGeometryType()){case n.GeometryType.enumPoint:{this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const n=this.distancePointMultipoint(t,e,r,i);return this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),n}case n.GeometryType.enumMultiPoint:return this.distanceMultipointMultipoint(e,t,i,r,1,1);case n.GeometryType.enumPolyline:case n.GeometryType.enumPolygon:return this.distanceMultipointMultipath(e,t,i,r);case n.GeometryType.enumEnvelope:return this.distanceMultipointMultipath(e,_(t),i,r);default:return Number.NaN}}distanceMultipointMultipoint(e,n,i,r,o,m){const a={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&1===o&&1===m){const t=Math.trunc(s.snap(Math.sqrt(e.getPointCount())+1,1,s.intMax())),o=Math.trunc(s.snap(Math.sqrt(n.getPointCount())+1,1,s.intMax()));if((t>=4||o>=4)&&this.distanceMultipointMultipoint(e,n,i,r,t,o)<=this.m_maxSqrDistance)return 0}let u=this.m_maxSqrDistance;const y=[e],h=[n],p=this.swapGeometriesIfBGtA(y,h);p&&(this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),m=s.swap(o,o=m),l(i,r)),t.__addDisposableResource(a,s.makeScopedCall(()=>{l(i,r),this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!p),!1);const g=y[0].getImpl(),D=h[0].getImpl(),_=g.getPointCount(),v=D.getPointCount(),P=v>1;let N=!1;const f=new s.Point2D,I=new s.Point2D;for(let e=0;e<_;e+=o){if(g.queryXY(e,f),P){const e=this.m_env2DgeometryB.sqrDistance(f);if(this.m_bIsNearCalc){if(e>u)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(f)<=u)return 0}else if(e>=u)continue}for(let t=0;t<v;t+=m){D.queryXY(t,I);const n=s.Point2D.sqrDistance(f,I);if(this.m_bIsNearCalc){if(n<=u)return 0}else if(!(n>u||N&&n===u)&&(!N||n<u)&&(c(i,f,e,0),c(r,I,t,0),N=!0,u=n,0===u))return N?Math.sqrt(u):Number.POSITIVE_INFINITY}}return N?Math.sqrt(u):Number.POSITIVE_INFINITY}catch(e){a.error=e,a.hasError=!0}finally{t.__disposeResources(a)}}distanceMultipointMultipath(e,t,i,m){let a=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&t.getGeometryType()===n.GeometryType.enumPolygon;const u=t.querySegmentIterator();u.stripAttributes();const y=new o.Envelope2D,h=new s.Point2D;let l=this.m_maxSqrDistance;const p=e.getImpl(),g=p.getPointCount(),D=g>1;let _=!1;for(;u.nextPath();)for(;u.hasNextSegment();){const e=u.nextSegment();if(e.queryLooseEnvelope(y),D){const e=y.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(e>l)continue}else if(e>l||_&&e===l)continue}for(let n=0;n<g;n++){if(p.queryXY(n,h),a&&0!==r.isPoint2DInPolygon2D(t,h,0))return c(i,h,-1,Number.NaN),c(m,h,n,0),0;{const e=y.sqrDistance(h);if(this.m_bIsNearCalc){if(e>l)continue}else if(e>l)continue}const s=e.getClosestCoordinate(h,!1),o=e.getCoord2D(s);h.subThis(o);const g=h.sqrLength();if(this.m_bIsNearCalc){if(g<=l)return 0}else if(!(g>l)&&(!_||g<l)&&(l=g,c(i,p.getXY(n),n,0),c(m,o,u.getStartPointIndex(),s),_=!0,0===l))return 0}a=!1}return _?Math.sqrt(l):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(e,t,i,r){switch(t.getGeometryType()){case n.GeometryType.enumPoint:return this.distancePointEnvelope(t,e,r,i);case n.GeometryType.enumMultiPoint:{this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const n=this.distanceMultipointMultipath(t,_(e),r,i);return this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),n}case n.GeometryType.enumPolyline:case n.GeometryType.enumPolygon:return this.distanceMultipathMultipath(_(e),t,i,r);case n.GeometryType.enumEnvelope:return this.distanceEnvelopeEnvelope(e,t,i,r);default:return Number.NaN}}distanceEnvelopeEnvelope(e,t,n,i){n.t=Number.NaN,n.index=-1,i.t=Number.NaN,i.index=-1;const r=e.asEnvelope2D(),s=t.asEnvelope2D();return Math.sqrt(r.sqrDistanceEnvelope(s,n.outPoint,i.outPoint))}distanceMultipathGeometry(e,t,i,r){switch(t.getGeometryType()){case n.GeometryType.enumPoint:{this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const n=this.distancePointMultipath(t,e,r,i);return this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),n}case n.GeometryType.enumMultiPoint:{this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const n=this.distanceMultipointMultipath(t,e,r,i);return this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),n}case n.GeometryType.enumPolyline:case n.GeometryType.enumPolygon:return this.distanceMultipathMultipath(e,t,i,r);case n.GeometryType.enumEnvelope:return this.distanceMultipathMultipath(e,_(t),i,r);default:return Number.NaN}}distanceMultipathMultipath(e,n,r,m){const u={stack:[],error:void 0,hasError:!1};try{const c=[e],D=[n],_=this.swapGeometriesIfAGtB(c,D);_&&(this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),l(r,m)),t.__addDisposableResource(u,s.makeScopedCall(()=>{l(r,m),this.m_env2DgeometryB=s.swap(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!_),!1);const v=c[0],P=D[0],N=v.querySegmentIterator();N.stripAttributes();const f=P.querySegmentIterator();if(f.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const e=Math.trunc(s.snap(Math.sqrt(v.getPointCount())+1,1,s.intMax())),t=Math.trunc(s.snap(Math.sqrt(v.getPointCount())+1,1,s.intMax()));if(this.distanceMultipointMultipoint(v,P,r,m,e,t)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const e=a(),t=a();if(p(v,P,N,f,e,t))return y(r,e),y(m,t),0}const I=g(v),d=[],x=new i.SegmentBuffer,M=new o.Envelope2D,E=new o.Envelope2D,T=new o.Envelope2D;let q=this.m_maxSqrDistance,G=!0,b=!1;for(let e=0,t=I.length;e<t;++e){v.querySegment(I[e],x,!0);const t=x.get();if(t.queryEnvelope(M),!(M.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>q)){if(this.m_bIsNearCalc&&M.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=q)return 0;for(;f.nextPath();){if(this.progress_(),G)P.queryPathEnvelope(f.getPathIndex(),T),d[f.getPathIndex()]=T.clone();else if(M.sqrDistanceEnvelope(d[f.getPathIndex()],null,null)>q)continue;for(;f.hasNextSegment();){const n=f.nextSegment();if(n.queryEnvelope(E),M.sqrDistanceEnvelope(E,null,null)<=q){const i=!M.isIntersecting(E),s=[0],o=[0];let a=t.distance(n,i,s,o);if(a*=a,this.m_bIsNearCalc&&a<=this.m_maxSqrDistance)return 0;if(a<q||a===q&&I[e]<r.index){if(b=!0,h(r,t,I[e],s[0]),h(m,n,f.getStartPointIndex(),o[0]),0===a)return 0;q=a}}}}f.resetToFirstPath(),G=!1}}return b?Math.sqrt(q):Number.POSITIVE_INFINITY}catch(e){u.error=e,u.hasError=!0}finally{t.__disposeResources(u)}}swapGeometriesIfAGtB(e,t){return n.vertexCount(e[0])>n.vertexCount(t[0])&&(t[0]=s.swap(e[0],e[0]=t[0]),!0)}swapGeometriesIfBGtA(e,t){return this.swapGeometriesIfAGtB(t,e)}},e.makeOutput=a,e.shuffleMultipathSegments=g,e.weakIntersectionTest=p});