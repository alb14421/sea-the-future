// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./SimpleGeometryCursor","./Geometry","./Envelope2D","./ProjectionTransformation","./tslib.es6","./MultiPathImpl","./Envelope","./Transformation2D","./Point2D","./OperatorClip","./GeometryCleaner-BEJM7I4l","./OperatorDensify"],function(e,t,s,i,n,r,o,a,m,l,c,h,u){"use strict";class _{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){const t=new o.Polygon,s=new w(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferPolyline(e){const t=new w(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){const t=new T(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){const t=e.getXY();t.scale(this.m_rpu);let s=new o.Polygon;if(this.bufferPoint2D(t,!1,s)){const e=a.calculateToleranceFromGeometryForOpFromGeom(null,s,!0);s=n.planarSimplify(s,e,!0,!0,-1,this.m_progressTracker,0,!1)}return s=(new n.OperatorProject).foldInto360RangeGeodetic(s,this.m_gcs,2),s}processGnomonicBufferPiecesCursor(e,t){const s=t;let r=s.getGnomonic();const o=n.createLocal(n.create$5());let c=new n.ListeningGeometryCursor,h=(new n.OperatorUnion).executeMany(c,o,this.m_progressTracker,2);const u=l.makePrimitiveArray(6,!1),_=l.makeObjectArray(i.Envelope2D,6);this.initializeGrid(u,_);const d=[null,null,null,null,null,null],p=[null,null,null,null,null,null],f=[null,null,null,null,null,null];let g,P,y;for(;null!==(g=s.next());){if(P=s.getGnomonic(),P!==r){if(null!==r){let t=h.next();if(c=null,h=null,null!=t){const s=a.calculateToleranceFromGeometryForOpFromGeom(o,t,!0),i=a.adjustToleranceForTEClustering(s);t=r.unproject(t,i,this.m_progressTracker),this.putInGridCursors(e,t,o,!0,u,_,d,p,f)}}null!==P&&(c=new n.ListeningGeometryCursor,h=(new n.OperatorUnion).executeMany(c,o,this.m_progressTracker,2)),r=P}if(s.isRunningInGnomonic()){if(P.project(g),s.needsSimplify()){const e=a.calculateToleranceFromGeometryForOpFromGeom(null,g,!0);g=n.planarSimplify(g,e,!0,!0,-1,this.m_progressTracker,0,!1)}c.tick(C(g)),h.tock()}else this.putInGridCursors(e,g,o,!0,u,_,d,p,f)}let b=!1;for(let e=0;e<6;e++)if(null!=f[e]){b=!0;break}if(b){let t=!1;const i=[null,null,null,null,null,null];if(e){const n=s.m_densified;if(s.m_densified=null,null!==n){const s=new m.Transformation2D;s.scale(1/this.m_rpu,1/this.m_rpu),n.applyTransformation(s),this.m_distance>0?this.putInGridCursors(e,n,o,!1,u,_,d,p,f):(this.processInGrid(e,n,!1,u,_,d,i),t=!0)}}const l=new n.ListeningGeometryCursor,g=(new n.OperatorUnion).executeMany(l,this.m_gcs,this.m_progressTracker,2);if(null!==h){let t=h.next();c=null,h=null;const s=a.calculateToleranceFromGeometryForOpFromGeom(o,t,!0),i=a.adjustToleranceForTEClustering(s);t=r.unproject(t,i,this.m_progressTracker),this.putInGridCursors(e,t,o,!0,u,_,d,p,f)}for(let e=0;e<6;e++)if(null!=f[e]){let s=f[e].next();f[e]=null,p[e]=null,t&&null!==i[e]&&(s=(new n.OperatorDifference).execute(i[e],s,o,this.m_progressTracker));const r=a.calculateToleranceFromGeometryForOpFromGeom(o,s,!0),m=a.adjustToleranceForTEClustering(r);s=d[e].unproject(s,m,this.m_progressTracker),s=(new n.OperatorSimplify).execute(s,this.m_gcs,!0,this.m_progressTracker),l.tick(C(s)),g.tock()}y=g.next()}else{let t,i=!1;if(e){let e=s.m_densified;if(s.m_densified=null,null!==e){const s=new m.Transformation2D;s.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(s),P.project(e);const r=a.calculateToleranceFromGeometryForOpFromGeom(null,e,!0);e=n.planarSimplify(e,r,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(c.tick(C(e)),h.tock()):(t=e,i=!0)}}let l=h.next();c=null,h=null,i&&(l=(new n.OperatorDifference).execute(t,l,o,this.m_progressTracker));const u=a.calculateToleranceFromGeometryForOpFromGeom(o,l,!0),_=a.adjustToleranceForTEClustering(u);y=r.unproject(l,_,this.m_progressTracker),y=(new n.OperatorSimplify).execute(y,this.m_gcs,!0,this.m_progressTracker)}return y=(new n.OperatorProject).foldInto360RangeGeodetic(y,this.m_gcs,2),y}putInGridCursors(e,t,s,i,r,o,a,m,l){const c=[null,null,null,null,null,null];this.processInGrid(e,t,i,r,o,a,c);for(let e=0;e<6;e++)null!==c[e]&&(null===m[e]&&(m[e]=new n.ListeningGeometryCursor,l[e]=(new n.OperatorUnion).executeMany(m[e],s,this.m_progressTracker,2)),m[e].tick(C(c[e])),l[e].tock())}processInGrid(e,t,s,i,r,o,m){const h=.01,u=this.insertGeodeticPointsAlongGrid(t,r,h);for(let e=0;e<6;e++){if(i[e])continue;const _=r[e].clone();_.inflateCoords(h,h);const d=a.getMergedExtentEnv2D(t,_),p=a.calculateToleranceFromGeometryForOp(null,d,!1).total();let f=c.clip$1(u,_,p,Number.NaN,this.m_progressTracker);if(null!==f&&!f.isEmpty()){if(f===u&&(f=f.clone()),null===o[e]){const t=new l.Point2D;e<3?t.setCoords(0,1):t.setCoords(0,-1);const s=new l.Point2D;s.setAdd(r[e].getCenter(),t),o[e]=x(this.m_gcs,s)}o[e].project(f);const t=a.calculateToleranceFromGeometryForOpFromGeom(null,f,!0);f=n.planarSimplify(f,t,s,!0,-1,this.m_progressTracker,0,!1),m[e]=f}}}insertGeodeticPointsAlongGrid(e,t,s){const r=i.Envelope2D.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),a=n.foldInto360NoUnion(this.m_gcs,r,e,!0,this.m_progressTracker),m=new o.EditShape,l=m.addGeometry(a);return n.insertGeodeticPointsEditShape(m,l,this.m_gcs,0,2,!0,t[0].xmax+s),n.insertGeodeticPointsEditShape(m,l,this.m_gcs,0,2,!0,t[1].xmax+s),n.insertGeodeticPointsEditShape(m,l,this.m_gcs,0,2,!1,t[1].ymin+s),0!==s&&(n.insertGeodeticPointsEditShape(m,l,this.m_gcs,0,2,!0,t[0].xmax-s),n.insertGeodeticPointsEditShape(m,l,this.m_gcs,0,2,!0,t[1].xmax-s),n.insertGeodeticPointsEditShape(m,l,this.m_gcs,0,2,!1,t[1].ymin-s)),m.getGeometry(l)}initializeGrid(e,t){for(let t=0;t<6;t++)e[t]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,s,i,r,o){const a=e[0],m=e.at(-1),c=a.y<m.y?a.y:m.y,h=a.y>m.y?a.y:m.y,u=n.peMath.q(this.m_a,this.m_eSquared,c),_=n.peMath.q(this.m_a,this.m_eSquared,h);if(this.m_q90-(u+t+this.m_absDistance)>.001&&this.m_q90+(_-t-this.m_absDistance)>.001)return!1;const d=s-l.geometryHalfPi,P=i+l.geometryHalfPi,y=d-Math.PI,b=d+Math.PI,D=P+Math.PI,x=[Number.NaN],C=[Number.NaN],S=[Number.NaN],w=[Number.NaN];let T=!1;if(g(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,d,y,m,P,x,C),g(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,D,P,a,y,S,w),(P<x[0]&&x[0]<D||P<C[0]&&C[0]<D)&&(T=!0),T||(y<S[0]&&S[0]<d||y<w[0]&&w[0]<d)&&(T=!0),!T&&r)return!1;const v=[];for(let t=e.length-1;t>=0;t--)v.push(e[t]);o.setEmpty(),o.addPathPoint2D(null,0,!0);let G=0;G=p(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,d,P,r,G,o),G=f(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,P,D,this.m_cornerStep,r,G,o,x[0],C[0]),G=p(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,v,D,b,r,G,o),G=f(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,a,y,d,this.m_cornerStep,r,G,o,S[0],w[0]);let I=!1;return r||(I=this.checkAndPrepForPole(o)),T||I}bufferPoint2D(e,t,s){s.setEmpty(),s.addPathPoint2D(null,0,!0),f(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,0,s);let i=!1;return t||(i=this.checkAndPrepForPole(s)),i}checkAndPrepForPole(e){const t=this.checkAndPrepForPoleTouch(e),s=this.checkAndPrepForPoleWrap(e);return t||s}checkAndPrepForPoleTouch(e){const t=new i.Envelope2D;return e.queryEnvelope(t),!(!n.PE_EQ(t.ymax,this.m_gcs90)&&!n.PE_EQ(t.ymin,-this.m_gcs90)||(this.prepPoleTouch(e),0))}checkAndPrepForPoleWrap(e){const t=e.getXY(0),s=e.getXY(e.getPointCount()-1);return Math.abs(t.x-s.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){const t=new o.Polygon;t.insertPath2D(-1,null,0,0,!0);const s=e.getPathStart(0),i=e.getPathEnd(0),r=i-s;let a=-1;for(a=s;a<i;a++){const t=e.getXY(a),s=n.PE_EQ(t.y,this.m_gcs90),i=n.PE_EQ(t.y,-this.m_gcs90);if(!s&&!i)break}let m=a,c=!1,h=Number.NaN;do{const i=e.getXY(m),o=n.PE_EQ(i.y,this.m_gcs90),a=n.PE_EQ(i.y,-this.m_gcs90),u=s+(m+1-s)%r;if(o||a){let s=l.Point2D.construct(h,i.y);t.insertPoint2D(0,-1,s);const r=e.getXY(u),o=n.PE_EQ(r.y,this.m_gcs90),a=n.PE_EQ(r.y,-this.m_gcs90);o||a||(s=l.Point2D.construct(r.x,i.y),c?t.setXY(t.getPointCount()-1,s):t.insertPoint2D(0,-1,s)),c=!0}else t.insertPoint2D(0,-1,i),h=i.x,c=!1;m=u}while(m!==a);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){const t=new o.Polygon,s=new o.Polygon,r=new m.Transformation2D,h=e.getXY(e.getPathStart(0)),u=e.getXY(e.getPathEnd(0)-1),_=this.m_gcs360,d=this.m_gcs180,p=new i.Envelope2D;p.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const f=new i.Envelope2D;e.queryEnvelope(f);const g=Math.ceil(f.width()/_);let P,y;h.x>u.x?(P=-_,y=this.m_gcs90):(P=_,y=-this.m_gcs90),r.setShiftCoords(P,0),t.addPath(e,0,!0),s.add(t,!1);const b=new a.Point;for(let e=0;e<g;e++)s.applyTransformation(r),s.getPointByVal(0,b),t.lineToPoint(b),t.addSegmentsFromPath(s,0,0,s.getSegmentCount()-1,!1);const D=t.getXY(0),x=t.getXY(t.getPointCount()-1);D.y=y,x.y=y,t.lineTo(x);const C=new l.Point2D;for(C.setCoordsPoint2D(x),C.x-=.5*P;Math.abs(C.x-D.x)>d;)t.lineTo(C),C.x-=.5*P;t.lineTo(D);const S=p.getCenterX(),w=new i.Envelope2D;t.queryEnvelope(w);let T=0;const v=w.getCenter().x;v-S>d?T=-Math.ceil((v-S-d)/_):S-v>d&&(T=Math.ceil((S-v-d)/_)),0!==T&&(r.setShiftCoords(T*_,0),t.applyTransformation(r));const G=new o.EditShape,I=G.addGeometry(t);n.insertGeodeticPointsEditShape(G,I,this.m_gcs,0,2,!0,p.xmin),n.insertGeodeticPointsEditShape(G,I,this.m_gcs,0,2,!0,p.xmax);const E=G.getGeometry(I),M=a.getMergedExtentEnv2D(E,p);M.inflateCoords(0,1);const R=a.calculateToleranceFromGeometryForOp(null,M,!0).total(),A=c.clip$1(E,p,R,Number.NaN,this.m_progressTracker);e.setEmpty(),e.add(A,!1)}prepDoublePoleWrap(e){const t=this.m_gcs360,s=this.m_gcs180,r=new i.Envelope2D;r.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const h=r.getCenter().x,u=new i.Envelope2D;e.queryPathEnvelope(0,u);let _,d=0,p=u.getCenter().x;if(p-h>s?d=-Math.ceil((p-h-s)/t):h-p>s&&(d=Math.ceil((h-p-s)/t)),0!==d){const s=new m.Transformation2D;s.setShiftCoords(d*t,0),e.getImpl().applyTransformationToPath(s,0),e.queryPathEnvelope(0,u),p=u.getCenter().x}const f=new i.Envelope2D;r.containsExclusiveEnvelope(u)?(_=!1,f.setCoords({env2D:r})):(_=!0,f.setCoords({env2D:r}),f.xmin-=t,f.xmax+=t);let g=e.createInstance();g.addPathPoint2D(null,0,!0);const P=new l.Point2D;if(P.setCoords(f.xmin,f.ymin),g.insertPoint2D(0,-1,P),P.setCoords(f.xmin,f.ymax),g.insertPoint2D(0,-1,P),P.setCoords(.5*(f.xmin+f.xmax),f.ymax),g.insertPoint2D(0,-1,P),P.setCoords(f.xmax,f.ymax),g.insertPoint2D(0,-1,P),P.setCoords(f.xmax,f.ymin),g.insertPoint2D(0,-1,P),P.setCoords(.5*(f.xmin+f.xmax),f.ymin),g.insertPoint2D(0,-1,P),_){g.addPath(e,0,!0);const s=new m.Transformation2D;p<h?s.setShiftCoords(t,0):s.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(s,0),g.addPath(e,0,!0);const i=new o.EditShape,l=i.addGeometry(g);n.insertGeodeticPointsEditShape(i,l,this.m_gcs,0,2,!0,r.xmin),n.insertGeodeticPointsEditShape(i,l,this.m_gcs,0,2,!0,r.xmax),g=i.getGeometry(l);const u=a.getMergedExtentEnv2D(g,r);u.inflateCoords(0,1);const _=a.calculateToleranceFromGeometryForOp(null,u,!0).total();g=c.clip$1(g,r,_,Number.NaN,this.m_progressTracker)}else g.addPath(e,0,!0);e.setEmpty(),e.add(g,!1)}setMinCornerStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new l.Point2D;s.setCoords(0,10*this.m_rpu);const i=0;let o=45*this.m_rpu;const a=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),m=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),c=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),h=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),u=new l.Point2D,_=new l.Point2D,d=new l.Point2D,p=new l.Point2D;for(n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,i,a.at(0),a.at(1)),u.setCoords(a.at(0).val,a.at(1).val),n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,o,m.at(0),m.at(1)),_.setCoords(m.at(0).val,m.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const a=.5*(i+o);n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,a,c.at(0),c.at(1)),d.setCoords(c.at(0).val,c.at(1).val);const l=r.__addDisposableResource(e,new n.PeDoubleClass,!1),f=r.__addDisposableResource(e,new n.PeDoubleClass,!1);n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,u.x,u.y,_.x,_.y,l,f,null,2),n.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,u.x,u.y,.5*l.val,f.val,h.at(0),h.at(1),2),p.setCoords(h.at(0).val,h.at(1).val);const g=r.__addDisposableResource(e,new n.PeDoubleClass,!1);if(n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,d.x,d.y,p.x,p.y,g,null,null,2),g.val<=this.m_convergenceOffset)break;o*=.9,n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,o,m.at(0),m.at(1)),_.setCoords(m.at(0).val,m.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{r.__disposeResources(e)}}const f=o-i,g=2*Math.PI/Math.ceil(2*Math.PI/f);this.m_cornerStep=g}catch(t){e.error=t,e.hasError=!0}finally{r.__disposeResources(e)}}setMinSegmentStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new l.Point2D,i=new l.Point2D;s.setCoords(0,10*this.m_rpu),i.setCoords(10*this.m_rpu,10*this.m_rpu);const o=r.__addDisposableResource(e,new n.PeDoubleClass,!1),a=r.__addDisposableResource(e,new n.PeDoubleClass,!1),m=r.__addDisposableResource(e,new n.PeDoubleClass,!1);n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,i.x,i.y,m,o,a,this.m_curveType);const c=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),h=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),u=new l.Point2D,_=r.__addDisposableResource(e,new n.PeDoubleClass,!1),d=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),p=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),f=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),g=r.__addDisposableResource(e,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),P=new l.Point2D,y=new l.Point2D,b=new l.Point2D,D=new l.Point2D,x=0;let C=1;const S=o.val,w=a.val,T=S-.5*Math.PI,v=w+.5*Math.PI,G=m.val;for(n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,T,d.at(0),d.at(1)),P.setCoords(d.at(0).val,d.at(1).val),n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,t,v,p.at(0),p.at(1)),y.setCoords(p.at(0).val,p.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const o=.5*(x+C);n.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,o*G,S,c.at(0),c.at(1),this.m_curveType),u.setCoords(c.at(0).val,c.at(1).val),n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,u.x,u.y,null,null,_,this.m_curveType);const a=_.val+.5*Math.PI;n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,u.x,u.y,t,a,f.at(0),f.at(1)),b.setCoords(f.at(0).val,f.at(1).val);const m=r.__addDisposableResource(e,new n.PeDoubleClass,!1),l=r.__addDisposableResource(e,new n.PeDoubleClass,!1);n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,P.x,P.y,y.x,y.y,m,l,null,2),n.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,P.x,P.y,.5*m.val,l.val,g.at(0),g.at(1),2),D.setCoords(g.at(0).val,g.at(1).val);const d=r.__addDisposableResource(e,new n.PeDoubleClass,!1);if(n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,b.x,b.y,D.x,D.y,d,null,null,2),d.val<=this.m_convergenceOffset)break;{const e={stack:[],error:void 0,hasError:!1};try{C*=.9,n.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,C*G,S,h.at(0),h.at(1),this.m_curveType),i.setCoords(h.at(0).val,h.at(1).val);const o=r.__addDisposableResource(e,new n.PeDoubleClass,!1);n.peLineType.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,i.x,i.y,null,null,o,this.m_curveType);const a=o.val+.5*Math.PI;n.peLineType.geodesicCoordinate(this.m_a,this.m_eSquared,i.x,i.y,t,a,p.at(0),p.at(1)),y.setCoords(p.at(0).val,p.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{r.__disposeResources(e)}}}catch(t){e.error=t,e.hasError=!0}finally{r.__disposeResources(e)}}let I=C*G;I>1e5&&(I=1e5),this.m_segmentStep=I}catch(t){e.error=t,e.hasError=!0}finally{r.__disposeResources(e)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}}function d(e,t,r,m,c,h,d){if(e.isEmpty())return new o.Polygon({vd:e.getDescription()});let p=e;if(s.hasNonLinearSegments(p)){const e=10*t.getTolerance(0);p=(new u.OperatorDensify).execute(p,0,e,0,d,12e3)}const f=new _(d);f.m_sr=t,f.m_gcs=t.getGCS(),f.m_transform=n.createEx(t,f.m_gcs,null);const g=n.makeSpheroidData();f.m_gcs.querySpheroidData(g);const P=new i.Envelope2D;p.queryEnvelope(P),f.m_a=g.majorSemiAxis,f.m_eSquared=g.e2,f.m_rpu=f.m_gcs.getUnit().getUnitToBaseFactor(),f.m_gcs90=.5*Math.PI/f.m_rpu,f.m_gcs180=Math.PI/f.m_rpu,f.m_gcs360=2*Math.PI/f.m_rpu,f.m_gcs60=f.m_gcs360/6,f.m_q90=n.peMath.q90(f.m_a,f.m_eSquared),f.m_ellipticToGeodesicMaxRatio=.5*f.m_a*Math.PI/f.m_q90;const y=f.m_gcs.getTolerance(0);f.m_radTolerance=y*f.m_rpu,4===r?(f.m_curveType=2,f.m_bShapePreserving=!0):(f.m_curveType=r,f.m_bShapePreserving=!1),f.m_distance=m,f.m_absDistance=Math.abs(m),Number.isNaN(c)||c<=0?f.setConvergenceOffset():f.m_convergenceOffset=Math.max(c,.001),f.m_convergenceOffset/=h;let b,D=p.getGeometryType();if(s.isSegment(D)){const e=new o.Polyline({vd:p.getDescription()});e.addSegment(p,!0),b=e,D=s.GeometryType.enumPolyline}else if(D===s.GeometryType.enumEnvelope){const e=p,t=new i.Envelope2D;e.queryEnvelope(t);const n=a.adjustToleranceForTEClustering(a.calculateToleranceFromGeometryForOp(f.m_sr,P,!0));if(t.minDimension()<=n)if(0===t.maxDimension()){const t=new a.Point({vd:p.getDescription()});e.getCenter(t),b=t,D=s.GeometryType.enumPoint}else{const t=new o.Polyline({vd:p.getDescription()});t.addEnvelope(e,!1),b=t,D=s.GeometryType.enumPolyline}else{const t=new o.Polygon({vd:p.getDescription()});t.addEnvelope(e,!1),b=t,D=s.GeometryType.enumPolygon}}else b=p;if(f.setMinCornerStep(),s.isPoint(D)||f.setMinSegmentStep(),f.m_absDistance<=.5*f.m_convergenceOffset)return D!==s.GeometryType.enumPolygon?new o.Polygon({vd:b.getDescription()}):f.m_bShapePreserving?b:n.densify(b,f.m_sr,f.m_curveType,f.m_segmentStep,-1,d);if(f.m_distance<0&&D!==s.GeometryType.enumPolygon)return new o.Polygon({vd:b.getDescription()});if(f.m_bShapePreserving&&s.isMultiPath(D)){const e=n.densify(b,t,4,Number.NaN,f.m_convergenceOffset,d);b=(new n.OperatorProject).execute(e,f.m_transform,d)}else b=(new n.OperatorProject).execute(b,f.m_transform,d);if(b=n.clipGeometryFromTopAndBottom(b,f.m_gcs),b.isEmpty())return new o.Polygon({vd:b.getDescription()});!f.m_bShapePreserving&&s.isMultiPath(D)&&(b=n.normalizeMultiPathGcs(f.m_rpu,b)),b=function(e,t){const n=e.getGeometryType();let r;if(r=s.isMultiPath(n)?e.getPathCount():n===s.GeometryType.enumMultiPoint?e.getPointCount():1,1===r)return e;const o=[],a=[];for(let m=0;m<r;m++){o.push(m);const r=new l.Point2D;if(s.isMultiPath(n)){const t=new i.Envelope2D;e.queryPathEnvelope(m,t),r.assign(t.getCenter())}else r.assign(e.getXY(m));const c=t.toGeohash(r);a.push(c)}o.sort((e,t)=>a[e]<a[t]?-1:a[e]>a[t]?1:0);const m=e.createInstance();for(let t=0;t<r;t++){const i=o[t];s.isMultiPath(n)?m.addPath(e,i,!0):m.addPoints(e,i,i+1)}return m}(b,f.m_gcs);let x=new o.Polygon;switch(D){case s.GeometryType.enumPolygon:x=f.bufferPolygon(b);break;case s.GeometryType.enumPolyline:x=f.bufferPolyline(b);break;case s.GeometryType.enumMultiPoint:x=f.bufferMultiPoint(b);break;case s.GeometryType.enumPoint:x=f.bufferPoint(b);break;default:s.throwCorruptedGeometryException("")}const C=(new n.OperatorProject).execute(x,f.m_transform.getInverse(),d);return C.mergeVertexDescription(b.getDescription()),C}function p(e,t,s,i,o,a,m,c,h,u,_){const d={stack:[],error:void 0,hasError:!1};try{const p=new l.Point2D;p.setNAN(),h||_.getPointCount()>0&&(p.setCoordsPoint2D(_.getXY(_.getPointCount()-1)),p.scale(s));const f=r.__addDisposableResource(d,new n.PeDoubleClass,!1),g=r.__addDisposableResource(d,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),y=new l.Point2D,b=new l.Point2D,D=a.at(-1),x=1/s;for(let s=0;s<a.length;s++){const r=a[s];let l;0===s?l=m:s===a.length-1?l=c:(n.peLineType.geodeticDistance(e,t,D.x,D.y,r.x,r.y,null,null,f,o),l=f.val-.5*Math.PI),n.peLineType.geodesicCoordinate(e,t,r.x,r.y,i,l,g.at(0),g.at(1)),h?b.setCoords(g.at(0).val,g.at(1).val):(y.setCoords(g.at(0).val,g.at(1).val),u=P(r.x,y.x,p.x,u),b.setCoords(u+y.x,y.y),p.setCoordsPoint2D(b)),b.scale(x),_.insertPoint2D(0,-1,b)}return u}catch(e){d.error=e,d.hasError=!0}finally{r.__disposeResources(d)}}function f(e,t,s,i,o,a,m,c,h,u,_,d=Number.NaN,p=Number.NaN){const f={stack:[],error:void 0,hasError:!1};try{if(m-a<c)return u;const g=r.__addDisposableResource(f,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1),y=new l.Point2D,b=new l.Point2D,D=new l.Point2D;b.setNAN(),h||_.getPointCount()>0&&(b.setCoordsPoint2D(_.getXY(_.getPointCount()-1)),b.scale(s));let x=Math.ceil(a/c),C=x++*c;C===a&&(C=x++*c);let S=a;const w=1/s;for(;C<m+c&&(S<d&&d<C?(C=d,x--):S<p&&p<C&&(C=p,x--),!(C>=m));)n.peLineType.geodesicCoordinate(e,t,o.x,o.y,i,C,g.at(0),g.at(1)),h?D.setCoords(g.at(0).val,g.at(1).val):(y.setCoords(g.at(0).val,g.at(1).val),u=P(o.x,y.x,b.x,u),D.setCoords(u+y.x,y.y),b.setCoordsPoint2D(D)),D.scale(w),_.insertPoint2D(0,-1,D),S=C,C=x++*c;return u}catch(e){f.error=e,f.hasError=!0}finally{r.__disposeResources(f)}}function g(e,t,s,i,o,a,m,c,h,u,_){const d={stack:[],error:void 0,hasError:!1};try{const s=new l.Point2D,p=new l.Point2D,f=r.__addDisposableResource(d,new l.SimpleDisposableArray(new n.PeDoubleClass,new n.PeDoubleClass),!1);n.peLineType.geodesicCoordinate(e,t,o.x,o.y,i,a,f.at(0),f.at(1)),s.setCoords(f.at(0).val,f.at(1).val),n.peLineType.geodesicCoordinate(e,t,o.x,o.y,i,m,f.at(0),f.at(1)),p.setCoords(f.at(0).val,f.at(1).val);const g=r.__addDisposableResource(d,new n.PeDoubleClass,!1);for(n.peLineType.geodeticDistance(e,t,c.x,c.y,s.x,s.y,null,g,null,0),u[0]=g.val,n.peLineType.geodeticDistance(e,t,c.x,c.y,p.x,p.y,null,g,null,0),_[0]=g.val;u[0]<=_[0];)u[0]+=l.geometry2Pi;for(;u[0]>_[0];)u[0]-=l.geometry2Pi;for(;u[0]>=h;)u[0]-=l.geometry2Pi,_[0]-=l.geometry2Pi;for(;u[0]<h;)u[0]+=l.geometry2Pi,_[0]+=l.geometry2Pi}catch(e){d.error=e,d.hasError=!0}finally{r.__disposeResources(d)}}function P(e,t,s,i){if(Number.isNaN(s)){for(;i+t-e>Math.PI;)i-=l.geometry2Pi;for(;e-(i+t)>Math.PI;)i+=l.geometry2Pi;return i}return i+t-s>Math.PI?i-=l.geometry2Pi:s-(i+t)>Math.PI&&(i+=l.geometry2Pi),i}function y(e,t,s,i,o,a){const m={stack:[],error:void 0,hasError:!1};try{if(i>=a)return!1;const l=s[0],c=s.at(-1),h=r.__addDisposableResource(m,new n.PeDoubleClass,!1),u=r.__addDisposableResource(m,new n.PeDoubleClass,!1),_=r.__addDisposableResource(m,new n.PeDoubleClass,!1);n.peLineType.greatEllipticDistance(e,t,o.x,o.y,l.x,l.y,h,null,null),n.peLineType.greatEllipticDistance(e,t,o.x,o.y,c.x,c.y,u,null,null),n.peLineType.greatEllipticDistance(e,t,l.x,l.y,c.x,c.y,_,null,null);let d=Math.min(h.val,u.val)+_.val,p=d+i;if(p<a)return!0;const f=r.__addDisposableResource(m,new n.PeDoubleClass,!1);d=Math.max(h.val,u.val);for(let i=1;i<s.length-1;i++){const r=s[i];n.peLineType.greatEllipticDistance(e,t,o.x,o.y,r.x,r.y,f,null,null),f.val>d&&(d=f.val)}return p=d+i,p<a}catch(e){m.error=e,m.hasError=!0}finally{r.__disposeResources(m)}}function b(e,t,s,i,r,o,a,m){let c;if(i.length%2==0){const e=i.length>>1,t=i[e],s=i[e-1];c=l.Point2D.lerp(t,s,.5)}else c=i[i.length-1>>1].clone();const h=c.clone(),u=n.calculateTightRadiusInMeters(e,t,h,75/180*Math.PI);return!!y(e,t,i,r,h,u)&&(null!==o&&(o.setCoordsPoint2D(c),o.scale(1/s)),null!==a&&a.setCoordsPoint2D(h),null!==m&&(m[0]=u),!0)}function D(e,t,s,i,o,a){const m={stack:[],error:void 0,hasError:!1};try{if(i>=a)return!1;const l=r.__addDisposableResource(m,new n.PeDoubleClass,!1);return n.peLineType.greatEllipticDistance(e,t,o.x,o.y,s.x,s.y,l,null,null),l.val+i<a}catch(e){m.error=e,m.hasError=!0}finally{r.__disposeResources(m)}}function x(e,t){return new n.Gnomonic(e,t)}function C(e){return a.isAtLeastWeakSimpleGeom(e,0)||a.setWeakSimple(e,0),e}class S{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new l.Point2D,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class w extends S{constructor(e,t,s){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new o.Polygon,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=s,this.m_bNeedsSimplify=!0;const r=new i.Envelope2D;this.m_multiPath.queryEnvelope(r);const a=r.getCenter(),m=a.clone();m.scale(this.m_bufferer.m_rpu),this.m_gnomonic=x(this.m_bufferer.m_gcs,a),this.m_gnomonicCenterRad=m.clone(),this.m_minGnomonicRadius=n.calculateTightRadiusInMeters(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,m,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let s=0;const i=new l.Point2D,r=new l.Point2D;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){const e=this.m_segIter.nextSegment();if(i.setCoordsPoint2D(e.getStartXY()),r.setCoordsPoint2D(e.getEndXY()),i.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),n.checkStartForPoleTouch(i,r))i.x=r.x;else if(n.checkEndForPoleTouch(i,r))r.x=i.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),o=this.m_multiPath.getPathStart(s),a=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<o&&(e=this.m_multiPath.isClosedPath(s)?a-1:-1),t>a-1&&(t=this.m_multiPath.isClosedPath(s)?o:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),n.checkEndForPoleTouch(t,i)&&(i.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),n.checkStartForPoleTouch(r,e)&&(r.x=e.x)}}this.m_densifiedPoints.length=0;const a=n.geodeticDensifySegment(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,r,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===s)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(b(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(0===a||n.checkForWithinPole(i,r)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(i,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(a,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===t&&(t=new o.Polygon,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),s++}if(this.m_currentDensifiedDelta=[0],s>0){const e=this.m_segIter.getStartPointIndex(),o=this.m_segIter.getPathIndex();for(;s>0;){if(this.m_segIter.previousSegment(),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),r.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),i.scale(this.m_bufferer.m_rpu),r.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if(n.checkStartForPoleTouch(i,r))i.x=r.x;else if(n.checkEndForPoleTouch(i,r))r.x=i.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),o=this.m_multiPath.getPathStart(s),a=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<o&&(e=this.m_multiPath.isClosedPath(s)?a-1:-1),t>a-1&&(t=this.m_multiPath.isClosedPath(s)?o:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),n.checkEndForPoleTouch(t,i)&&(i.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),n.checkStartForPoleTouch(r,e)&&(r.x=e.x)}}this.m_densifiedPoints.length=0,n.geodeticDensifySegment(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,r,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),s--}return i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=f(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,i,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,o),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&y(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new l.Point2D,s=new l.Point2D,i=[0];return b(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,i)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=i[0],this.m_gnomonic=x(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){const t=this.m_densifiedPoints[0];let s=Number.NaN,i=this.m_startAzimuth[0]-l.geometryHalfPi;const n=this.m_endAzimuth[0]+l.geometryHalfPi;let r=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(s=this.m_lastAzimuth+l.geometryHalfPi,i=s+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(s=this.m_lastAzimuth+l.geometryHalfPi,i=s+Math.PI-(l.geometry2Pi-(this.m_startAzimuth[0]-this.m_lastAzimuth))),r=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI||this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let n=!1;if(Math.abs(i-s)<=.5*this.m_bufferer.m_cornerStep&&(r||(n=!0)),n){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){const t=new l.Point2D;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=l.geometry2Pi:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=l.geometry2Pi)}i=.5*(i+s)}else if(r){const s=new l.Point2D;s.setCoordsPoint2D(t),s.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,s)}else f(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],s,i,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,p(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,i,n,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}}class T extends S{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;const s=new i.Envelope2D;this.m_multiPoint.queryEnvelope(s);const r=s.getCenter(),o=r.clone();o.scale(this.m_bufferer.m_rpu),this.m_gnomonic=x(this.m_bufferer.m_gcs,r),this.m_gnomonicCenterRad=o.clone(),this.m_minGnomonicRadius=n.calculateTightRadiusInMeters(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,o,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(e));const t=new o.Polygon,s=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t);return this.m_bNeedsSimplify=s,t}isPointBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&D(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new l.Point2D,s=new l.Point2D,i=[0];return function(e,t,s,i,r,o,a,m){const l=n.calculateTightRadiusInMeters(e,t,i,75/180*Math.PI);return!!D(e,t,i,r,i,l)&&(null!==o&&(o.setCoordsPoint2D(i),o.scale(1/s)),null!==a&&a.setCoordsPoint2D(i),null!==m&&(m[0]=l),!0)}(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,i)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=i[0],this.m_gnomonic=x(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}}class v extends t.GeometryCursor{constructor(e,t,n,r,o,a,m,l){super(),this.m_currentUnionEnvelope2D=new i.Envelope2D,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=l,a&&s.throwNotImplementedException(""),t||s.throwInvalidArgumentException(""),0===t.getCoordinateSystemType()&&s.throwInvalidArgumentException(""),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=n,this.m_distances=r,this.m_convergenceOffset=o,this.m_bOutlineOnly=a,this.m_bUnion=m}next(){let e;for(;e=this.m_inputGeoms.next();)return s.throwIfMesh(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return function(e,t,i,n,r,o){n<Number.MAX_VALUE&&n>-Number.MAX_VALUE||s.throwInvalidArgumentException("Geodesic_bufferer.buffer - bad distance"),s.throwIfMesh(e);const a=h.clean(e),m=a.getGeometryType();if(s.isMultiVertex(m)){const e=a.getPointCount(),l=8e6;if(Math.abs(n)>l&&(e>50||m!==s.GeometryType.enumMultiPoint&&4===i&&e>2)){let e=a;const s=n>0?1:-1,m=7e6;let c=n,h=1;do{h++,c=(Math.abs(c)-m)*s}while(Math.abs(c)>l);c=n;for(let n=0;n<h-1;n++)e=d(e,t,i,m*s,r,h,o),c=(Math.abs(c)-m)*s;return e=d(e,t,i,c,r,h,o),e}}return d(a,t,i,n,r,1,o)}(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}}e.OperatorGeodesicBuffer=class{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,i,r,o,a,m){if(a){const a=new v(e,t,s,i,r,!1,o,m);return(new n.OperatorUnion).executeMany(a,t,m)}return new v(e,t,s,i,r,!1,o,m)}execute(e,i,n,r,o,a,m){const l=new t.SimpleGeometryCursor([e]),c=[r],h=this.executeMany(l,i,n,c,o,!1,a,m).next();return h||s.throwInternalErrorException("geodesic buffer null output"),h}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});