// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports"],function(e){"use strict";class t extends Error{constructor(e,t){super(t),this.m_AdditionalMessage=t,this.m_ErrorType=e,this.name="GeometryError"}what(){return function(e){switch(e){case 1:return"Unknown error";case 2:return"Corrupted geometry";case 3:return"Empty geometry";case 4:return"Math singularity";case 5:return"Buffer is too small";case 6:return"Invalid shape type";case 7:return"Projection out of supported range";case 8:return"Non simple geometry";case 9:return"Cannot calculate geodesic";case 10:return"Notation conversion";case 11:return"Missing grid file";case 12:return"Invalid call";case 13:return"Internal error";case 14:return"Not implemented";case 15:return"IO error";case 16:return"Invalid 3D";case 17:return"An ambiguous geography edge with antipodal points";case 18:return"Geocentric coordinates require ellipsoidal height";case 19:return"Geography cannot be projected into a gnomonic plane or a result of an operation cannot fit into a gnomonic plane";case 20:return"Geometry is too large to be exported in to a given format";case 22:return"Operation is canceled by the user";case 21:return"The operation, such as projection or geodetic computation, cannot be performed without pe-wasm loaded";default:return"unknown error"}}(this.m_ErrorType)}additionalMessage(){return this.m_AdditionalMessage?this.m_AdditionalMessage:""}code(){return this.m_ErrorType}}class n extends t{constructor(e){super(2,e),this.name="CorruptedGeometryError"}}class r extends t{constructor(e){super(3,e),this.name="EmptyGeometryError"}}class o extends t{constructor(e){super(4,e),this.name="MathSingularityError"}}class i extends t{constructor(e){super(21,e),this.name="ProjectionEngineNotLoadedError"}}class u extends t{constructor(e){super(8,e),this.name="NonSimpleGeometryError"}}var c;e.GeometryType=void 0,(c=e.GeometryType||(e.GeometryType={}))[c.enumUnknown=0]="enumUnknown",c[c.enumPoint=513]="enumPoint",c[c.enumLine=5122]="enumLine",c[c.enumBezier=5123]="enumBezier",c[c.enumEllipticArc=5124]="enumEllipticArc",c[c.enumEnvelope=3077]="enumEnvelope",c[c.enumMultiPoint=8710]="enumMultiPoint",c[c.enumPolyline=25607]="enumPolyline",c[c.enumPolygon=27656]="enumPolygon",c[c.enumMultipatch=40969]="enumMultipatch",c[c.enumGeometryCollection=3594]="enumGeometryCollection",c[c.enumRationalBezier2=5134]="enumRationalBezier2",c[c.enumBezier2=5135]="enumBezier2",c[c.enumRationalBezier23d=5392]="enumRationalBezier23d",c[c.enumGreatArc3d=5393]="enumGreatArc3d";const s=[0,0,1,1,1,2,0,1,2,3,-1,-1,-1,-1,1,1];function a(e){return!!(4096&e)}function m(e){return!!(8192&e)}function p(e){return!!(16384&e)}function l(e){return!!(32768&e)}function y(t){const n=t.getGeometryType();if(p(n))return t.hasNonLinearSegments();if(n===e.GeometryType.enumGeometryCollection){const e=t;for(let t=0,n=e.getGeometryCount();t<n;t++)if(y(e.getGeometry(t)))return!0;return!1}return!!a(n)&&n!==e.GeometryType.enumLine}function h(e){throw new Error(e)}function d(e){throw new t(14,e)}function w(e){throw new t(13,e)}function f(t){t===e.GeometryType.enumGeometryCollection&&h("Geometry_collection instances are not supported in this operation")}e.checkAndThrow=function(e,t){e||h(t)},e.geometryReleaseAssert=function(e,t){try{if(!e)throw new Error(t)}catch(e){throw e}},e.getDimensionFromType=function(e){return s[15&e]},e.hasNonLinearSegments=y,e.isArea=function(e){return!!(2048&e)},e.isLinear=function(e){return!!(1024&e)},e.isMesh=l,e.isMultiPath=p,e.isMultiVertex=m,e.isPoint=function(e){return!!(512&e)},e.isSegment=a,e.throwCorruptedGeometryException=function(e){throw new n(e)},e.throwEmptyGeometryException=function(e){throw new r(e)},e.throwIfCurves=function(e){e&&y(e)&&d("Operation does not support curves.")},e.throwIfGeometryCollection=function(e){f(e.getGeometryType())},e.throwIfGeometryCollectionType=f,e.throwIfMesh=function(e){e&&l(e.getGeometryType())&&d("Unsupported geometry type.")},e.throwInternalErrorException=w,e.throwInvalidArgumentException=h,e.throwInvalidCallException=function(e){throw new t(12,e)},e.throwInvalidGeometryTypeFor3DOps=function(){h("Geometry type is not supported for 3D operations.")},e.throwInvalidWkidException=function(e){h(`bad wkid: ${e}`)},e.throwInvalidWktException=function(e){let t="bad wkt: ";t+=e,t+="...",h(t)},e.throwLogicErrorException=function(e){throw new Error(e)},e.throwMathSingularityException=function(e){throw new o(e)},e.throwNonSimpleGeometryException=function(e){throw new u(e)},e.throwNotImplementedException=d,e.throwOutOfRangeException=function(e){throw new Error(e)},e.throwProjectionEngineNotLoadedException=function(e){throw new i(e)},e.vertexCount=function(t){const n=t.getGeometryType();return m(n)?t.getPointCount():t.isEmpty()?0:n===e.GeometryType.enumEnvelope?4:n===e.GeometryType.enumPoint?1:a(n)?2:void w("missing type")}});