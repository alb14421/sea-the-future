// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./tslib.es6","./Geometry","./SimpleGeometryCursor","./Envelope","./Point2D","./MultiPathImpl","./Envelope2D","./Transformation2D","./GeometryCleaner-BEJM7I4l","./ProjectionTransformation","./OperatorSimplifyOGC","./OperatorGeneralize"],function(e,t,s,i,n,r,o,m,a,h,l,c,u){"use strict";var f;function _(e,t,s,i,n,r){return{m_from:e.clone(),m_to:t.clone(),m_center:s.clone(),m_next:n,m_type:i}}function g(e,t,s,i,n){return{m_from:e.clone(),m_to:t.clone(),m_next:s,m_type:4,m_center:new r.Point2D}}!function(e){e[e.enumDummy=256]="enumDummy",e[e.enumLine=1]="enumLine",e[e.enumArc=2]="enumArc",e[e.enumMiter=8]="enumMiter",e[e.enumBevel=16]="enumBevel",e[e.enumJoinMask=26]="enumJoinMask",e[e.enumConnectionMask=27]="enumConnectionMask"}(f||(f={}));class d extends i.GeometryCursor{constructor(e,t,s,i,n,r,o,m,a,h){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=h,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=i,this.m_densifyDist=m,this.m_maxVertexInCompleteCircle=a,this.m_joins=n,this.m_caps=r,this.m_miterLimit=o}next(){const e=new n.Point;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(1===this.m_caps)return this.m_index=this.m_mp.getPointCount(),new o.Polygon({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(null===this.m_bufferedPolygon&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const s=new a.Transformation2D,i=e.getX()-this.m_x,n=e.getY()-this.m_y;s.setShiftCoords(i,n),t.applyTransformation(s)}return n.setWeakSimple(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class p extends i.GeometryCursor{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;const e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){const t=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(t)){let s=e.getXY(e.getPathEnd(t)-1);for(;this.m_currentPathIndex<e.getPathCount();){const t=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex))break;if(!t.equals(s))break;s=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(0===t&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const e=this.m_polyline;return this.m_polyline=null,e}const s=new o.Polyline({vd:this.m_polyline.getDescription()});s.addPath(this.m_polyline,t,!0);for(let i=t+1;i<this.m_currentPathIndex;i++)s.addSegmentsFromPath(this.m_polyline,i,0,e.getSegmentCountPath(i),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),s}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class P extends i.GeometryCursor{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(null===this.m_geometry&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){const e=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,e,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class y extends i.GeometryCursor{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){const e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){const t=this.m_index,i=e.calculateRingArea2D(this.m_index);for(s.geometryReleaseAssert(i>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let n;return n=0===t&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),n}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}function b(e){return n.setWeakSimple(e,0),e}function x(e,t){return!!e.isEmpty()||Math.min(e.width(),e.height())>t}function C(e,t,i,n,o,m,a,h){const l=e.getXY(i),c=e.getXY(n);if(l.equals(c))return-1;const u=.25*a,f=.25*a,_=new r.Point2D;_.setSub(c,l);const g=_.length(),d=g*g*.25,p=m*m-d;if(p<=d)return-1;const P=Math.sqrt(p);_.normalize();const y=_.clone();y.rightPerpendicularThis();const b=d/P,x=b<=f,C=r.Point2D.lerp(c,l,.5),D=y.clone(),w=b-u;D.scaleAddThis(Math.max(0,w),C),y.negate().scaleAddThis(P,C);const T=m-f,v=3.61*r.sqr(T),S=D.sub(l),I=D.sub(c);let E=!1,M=0;const A=r.makePrimitiveArray(64,0);s.geometryReleaseAssert(h===A.length);{for(let s=e.getPrevVertexEx(n,o);s!==i;){if(1===e.getUserIndex(s,t))return-1;if(e.getXY(s).equals(c)){const t=e.getPrevVertexEx(s,o);e.removeVertex(s,!1),s=t;continue}break}const m=new r.Point2D,a=l.clone();A[M++]=1;for(let s=e.getNextVertexEx(i,o);s!==n;){if(1===e.getUserIndex(s,t))return-1;const i=e.getXY(s);if(i.equals(a)){const t=e.getNextVertexEx(s,o);e.removeVertex(s,!1),s=t;continue}A[M++]=0;const n=new r.Point2D;if(n.setSub(i,l),n.dotProduct(y)<0)return 0;(r.Point2D.sqrDistance(i,l)>v||r.Point2D.sqrDistance(i,c)>v)&&(E=!0);let h=0;if(i.sub(l).crossProduct(S)>=0&&(h=1),i.sub(c).crossProduct(I)<=0&&(h|=2),0===h)return 0;A[M-1]=h,m.assign(a),a.assign(i),s=e.getNextVertexEx(s,o)}if(1===M)return 0;s.geometryReleaseAssert(M<A.length),A[M++]=2}let R=!0;for(let e=1,t=0;e<M;e++)if(A[e]!==A[e-1]&&(t++,R=t<3&&(1===t&&3===A[e]||2===t&&2===A[e]),!R))return 0;if(M>2&&R&&(3===M||!E)){let t=0,s=e.getNextVertexEx(i,o);for(x||(e.setXY(s,D),s=e.getNextVertexEx(s,o));s!==n;){const i=e.getNextVertexEx(s,o);e.removeVertex(s,!1),s=i,++t}return t}if(s.geometryReleaseAssert(3!==M),E&&M>3)return 0;const V=l.clone();let k=i;const B=l.clone();let X=1,Y=-1,G=k,F=0;for(M=1;G!==n;){G=e.getNextVertexEx(G,o);const t=A[M++];if(0===t){if(G===n)break;continue}const s=e.getXY(G);if(-1!==Y){if(Y&X&t&3){e.removeVertex(k,!0),F++,k=G,B.setCoordsPoint2D(s),X=t;continue}if(3===X&&0!==Y&&0!==t){if(B.setCoordsPoint2D(D),x||B.equals(V)){e.removeVertex(k,!0),F++,k=G,B.setCoordsPoint2D(s),X=t;continue}e.setXY(k,B)}}Y=X,V.setCoordsPoint2D(B),k=G,X=t,B.setCoordsPoint2D(s)}return F}function D(e,t,s,i){for(let n=0,r=e.getPathCount();n<r;n++){const r=e.getXY(e.getPathStart(n));r.x!==s.xmin&&r.x!==s.xmax&&t.addPath(e,n,i)}}e.Bufferer=class{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=s.GeometryType.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new n.CombinedTolerance(0,0),this.m_smallTolerance=new n.CombinedTolerance(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new o.Line,this.m_helperLine2=new o.Line,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=o.Densificator.constructDefault(e),this.m_progressTracker=e}buffer(e,t,i,a,l,c,u,f){if(e||s.throwInvalidArgumentException("Geometry.Bufferer.Impl.Buffer"),u<0&&s.throwInvalidArgumentException("Geometry.Bufferer.Impl.Buffer"),s.isMesh(e.getGeometryType())&&s.throwNotImplementedException("Unsupported geometry type."),e.isEmpty())return new o.Polygon({vd:e.getDescription()});if(this.m_joins=a,this.m_caps=l,this.m_bRoundBuffer=!1,this.m_miterLimit=c,this.m_originalGeomType=e.getGeometryType(),s.isArea(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_joins:s.isPoint(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_caps:s.isLinear(this.m_originalGeomType)&&(this.m_bRoundBuffer=0===this.m_joins&&0===this.m_caps),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=h.clean(e),this.m_geometry.isEmpty())return new o.Polygon({vd:e.getDescription()});const _=new m.Envelope2D;this.m_geometry.queryLooseEnvelope(_),t>0&&_.inflateCoords(t,t),this.m_tolerance=n.calculateToleranceFromGeometryForOp(i,_,!0),this.m_smallTolerance=n.calculateToleranceFromGeometryForOp(null,_,!0),f<=0&&(f=96),this.m_spatialReference=i,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=0!==this.m_absDistance?1/this.m_absDistance:0,Number.isNaN(u)||0===u?u=1e-5*this.m_absDistance:u>.5*this.m_absDistance&&(u=.5*this.m_absDistance),f<12&&(f=12);const g=Math.abs(t)*(1-Math.cos(Math.PI/f));if(g>u)u=g;else if(0!==t){const e=Math.PI/Math.acos(1-u/Math.abs(t));e<f-1&&(f=Math.trunc(e))<12&&(f=12,u=Math.abs(t)*(1-Math.cos(Math.PI/f)))}this.m_densifyDist=u,this.m_maxVertexInCompleteCircle=f,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&s.hasNonLinearSegments(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,0!==this.m_joins,r.intMax()));const d=this.bufferImpl();return this.m_geometry=null,d}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),s=.5*Math.PI/t;this.m_dA=s,this.m_circleTemplate=r.makeObjectArray(r.Point2D,4*t);const i=Math.cos(s),n=Math.sin(s),o=r.Point2D.construct(0,1);for(let e=0;e<t;e++)this.m_circleTemplate[e+0*t].setCoords(o.y,-o.x),this.m_circleTemplate[e+1*t].setCoords(-o.x,-o.y),this.m_circleTemplate[e+2*t].setCoords(-o.y,o.x),this.m_circleTemplate[e+3*t].setCoords(o.x,o.y),o.rotateReverse(i,n)}bufferImpl(){const e=this.m_geometry.getGeometryType();if(s.isSegment(e)){const e=new o.Polyline({vd:this.m_geometry.getDescription()});return e.addSegment(this.m_geometry,!0),this.m_geometry=e,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!s.isArea(e))return new o.Polygon({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const e=new m.Envelope2D;if(this.m_geometry.queryEnvelope(e),e.width()<=2*this.m_absDistance||e.height()<=2*this.m_absDistance)return new o.Polygon({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case s.GeometryType.enumPoint:return this.bufferPoint();case s.GeometryType.enumMultiPoint:return this.bufferMultiPoint();case s.GeometryType.enumPolyline:return this.bufferPolyline();case s.GeometryType.enumPolygon:return this.bufferPolygon();case s.GeometryType.enumEnvelope:return this.bufferEnvelope();default:s.throwInternalErrorException("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const e=new n.Point;this.m_geometry.getPointByVal(0,e);const t=new m.Envelope2D;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}const e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;const s=new p(e);let i,r;i=0===this.m_joins?(new u.OperatorGeneralize).executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,r=this.m_bRoundBuffer?(new c.OperatorSimplifyOGC).executeMany(i,null,!0,this.m_progressTracker):i;const a=new P(this,r,this.m_bFilter),h=(new l.OperatorUnion).executeMany(a,this.m_spatialReference,this.m_progressTracker,2),f=(new l.OperatorSimplify).executeMany(h,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==f?f:new o.Polygon({vd:t})}bufferPolygon(){if(0===this.m_distance)return this.m_geometry;this.generateCircleTemplate();const e=(new l.OperatorSimplify).execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;const t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return(new l.OperatorSimplify).execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){const e=new n.Point;this.m_geometry.getPointByVal(0,e);const t=new m.Envelope2D;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}const t=new y(this),s=(new l.OperatorUnion).executeMany(t,this.m_spatialReference,this.m_progressTracker,2),i=(new l.OperatorSimplify).executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==i?i:new o.Polygon({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){const i=e,r=i.getImpl();let a=new o.Polygon({vd:e.getDescription()});for(let h=t;h<s;h++){if(r.getPathSize(h)<1)continue;const t=r.calculateRingArea2D(h),s=new m.Envelope2D;if(r.queryPathEnvelope(h,s),this.m_distance>0)if(t>0)if(this.isDegeneratePath(r,h)){const e=new n.Point;r.getPointByVal(r.getPathStart(h),e),e.setXY(s.getCenter()),a.add(this.bufferDegeneratePath(e,!0),!1)}else{const t=new o.Polyline({vd:e.getDescription()}),s=t.getImpl();if(o.isPathConvex(this.m_geometry,h)){const e=this.bufferConvexPath(i,h);a.add(e,!1)}else{this.bufferClosedPath(this.m_geometry,h,s,this.m_bRoundBuffer,1);const e=this.bufferCleanup(t);a.add(e,!1)}}else{if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const t=new o.Polyline({vd:e.getDescription()}),i=t.getImpl();if(this.bufferClosedPath(this.m_geometry,h,i,this.m_bRoundBuffer,1),!t.isEmpty()){const e=s,n=Math.max(1,this.m_absDistance),r=e.clone();r.inflateCoords(n,n),i.addEnvelope(r,!1);const o=this.bufferCleanup(t);a.reserve(a.getPointCount()+o.getPointCount()-4),D(o,a,r,!0)}}else if(t>0){if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const t=new o.Polyline({vd:e.getDescription()}),i=t.getImpl();if(this.bufferClosedPath(this.m_geometry,h,i,this.m_bRoundBuffer,-1),!t.isEmpty()){const e=new m.Envelope2D;i.queryLooseEnvelope(e);const s=Math.max(1,this.m_absDistance),n=e.clone();n.inflateCoords(s,s),i.addEnvelope(n,!1),D(this.bufferCleanup(t),a,n,!0)}}else{const t=new o.Polyline({vd:e.getDescription()}),s=t.getImpl();this.bufferClosedPath(this.m_geometry,h,s,this.m_bRoundBuffer,-1);const i=this.bufferCleanup(t);for(let e=0,t=i.getPathCount();e<t;e++)a.addPath(i,e,!0)}}if(this.m_distance>0)return a.getPathCount()>1?this.bufferCleanup(a):b(a);{const e=new m.Envelope2D;if(a.queryLooseEnvelope(e),a.isEmpty())return b(a);{const t=Math.max(1,this.m_absDistance),s=e.clone();s.inflateCoords(t,t),a.addEnvelope(s,!1);const i=this.bufferCleanup(a);a=new o.Polygon;const n=new o.Polygon({vd:i.getDescription()});return D(i,n,s,!1),b(n)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){const t=new o.Polygon({vd:e.getDescription()});return 0===this.m_caps?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):2===this.m_caps?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){const s=new o.Polygon({vd:e.getDescription()});return t&&0===this.m_joins||!t&&0===this.m_caps?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||2!==this.m_caps?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){const e=new d(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return(new l.OperatorUnion).executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new o.Polygon({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(0===this.m_distance)e.addEnvelope(this.m_geometry,!1),x(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{const t=new n.Envelope;this.m_geometry.queryEnvelope(t),t.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(t,!1),x(t,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(1===this.m_joins){const t=new n.Envelope({copy:this.m_geometry});return t.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(t,!1),e}const t=this.m_geometry.clone();if(0===t.width()||0===t.height()){if(0===t.width()&&0===t.height()){const e=new n.Point({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,e),this.m_geometry=e,this.bufferImpl()}const e=new o.Polyline({vd:this.m_geometry.getDescription()}),s=new n.Point;return t.queryCornerByVal(0,s),e.startPathPoint(s),t.queryCornerByVal(2,s),e.lineToPoint(s),this.m_geometry=e,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();const i=e.hasAttribute(10),n=new o.Polygon({vd:e.getDescription()}),m=n.getImpl();n.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));const a=new r.Point2D,h=new r.Point2D,l=new r.Point2D,c=new r.Point2D(0,0),u=new r.Point2D,_=new r.Point2D,g=e.getImpl(),d=e.getPathSize(t),p=e.getPathStart(t);for(let n=0,r=e.getPathSize(t);n<r;n++){const e=g.getXY(p+n),t=g.getXY(p+(n+1)%d),r=g.getXY(p+(n+2)%d);u.setSub(t,e),0===u.length()&&s.throwInternalErrorException("");const o=i&&!!(1&g.getAttributeAsInt(10,(n+1)%d,0));u.normalize();const P=u.clone();u.leftPerpendicularThis(),u.scale(this.m_absDistance),a.setAdd(u,e),h.setAdd(u,t),0===n?m.startPath(a):m.lineTo(a),m.lineTo(h),_.setSub(r,t),0===_.length()&&s.throwInternalErrorException(""),_.normalize();const y=_.clone();_.leftPerpendicularThis(),_.scale(this.m_absDistance),l.setAdd(_,t);let b=f.enumArc;const x=o?0:this.m_joins;if(2===x)b=f.enumBevel;else if(1===x){const e=-P.crossProduct(y);c.setSub(P,y),c.scale(this.m_absDistance/e),c.length()<this.m_miterLimit*this.m_absDistance?(c.addThis(t),b=f.enumMiter):b=f.enumBevel}else c.assign(t);this.addJoin(b,m,c,h,l,!1,!1)}return b(n)}bufferPolylinePath(e,t,s){this.generateCircleTemplate();const i=e,r=i.getImpl();if(r.getPathSize(t)<1)return null;let a;if(a=this.m_bRoundBuffer?r.isClosedPathInXYPlane(t):r.isClosedPath(t),this.isDegeneratePath(r,t)&&this.m_distance>0){const e=new n.Point;r.getPointByVal(r.getPathStart(t),e);const s=new m.Envelope2D;return r.queryPathEnvelope(t,s),e.setXY(s.getCenter()),this.bufferDegeneratePath(e,a)}const h=new o.Polyline({vd:e.getDescription()});h.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*r.getPathSize(t));const l=h.getImpl();return a?2!==this.bufferClosedPath(i,t,l,s,1)&&this.bufferClosedPath(i,t,l,s,-1):this.bufferOpenPath(i,t,l,s),this.bufferCleanup(h)}progress_(){}bufferCleanup(e,t=!1){const s=t?this.m_tolerance:this.m_smallTolerance;return l.planarSimplify(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(0===this.m_densifyDist)return this.m_maxVertexInCompleteCircle;const e=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let t=4;return t=e<-1?4:2*Math.PI/Math.acos(e)+.5,t<4?t=4:t>this.m_maxVertexInCompleteCircle&&(t=this.m_maxVertexInCompleteCircle),Math.trunc(t)}addJoin(e,t,s,i,n,o,m){if(this.generateCircleTemplate(),o&&(t.startPath(i),o=!1),e===f.enumBevel)return void(m&&t.lineTo(n));if(e===f.enumMiter){const e=s.clone();return t.lineTo(e),void(m&&t.lineTo(n))}const a=new r.Point2D;a.setSub(i,s),a.scale(this.m_absDistanceReversed);const h=new r.Point2D;h.setSub(n,s),h.scale(this.m_absDistanceReversed);let l=Math.atan2(a.y,a.x)/this.m_dA;l<0&&(l=this.m_circleTemplate.length+l),l=this.m_circleTemplate.length-l;let c=Math.atan2(h.y,h.x)/this.m_dA;c<0&&(c=this.m_circleTemplate.length+c),c=this.m_circleTemplate.length-c,c<l&&(c+=this.m_circleTemplate.length);let u=Math.trunc(c),_=Math.ceil(l),g=this.m_circleTemplate[_%this.m_circleTemplate.length].clone();g.scaleAddThis(this.m_absDistance,s);const d=10*this.m_tolerance.total();g.sub(i).length()<d&&(_+=1),g=this.m_circleTemplate[u%this.m_circleTemplate.length].clone(),g.scaleAddThis(this.m_absDistance,s),g.sub(n).length()<d&&(u-=1);let p=u-_;p++;for(let e=0,i=_%this.m_circleTemplate.length;e<p;e++,i=(i+1)%this.m_circleTemplate.length)g=this.m_circleTemplate[i].clone(),g.scaleAddThis(this.m_absDistance,s),t.lineTo(g),this.progress_();m&&t.lineTo(n)}bufferClosedPath(e,t,s,i,n){const r=new o.EditShape,m=r.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(r,m,s,i,n)}bufferClosedPathImpl(e,i,m,h,l){const c=e.getFirstVertex(e.getFirstPath(i)),u=new n.Point;if(e.queryPoint(c,u),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(i)<2)return l<0?0:(this.m_bRoundBuffer&&this.addCircle(m,u),2);s.geometryReleaseAssert(e.getFirstPath(i)!==o.nullHandle),s.geometryReleaseAssert(e.getFirstVertex(e.getFirstPath(i))!==o.nullHandle);const d=e.getXY(e.getFirstVertex(e.getFirstPath(i))),p=new a.Transformation2D;if(p.setShift(d.negate()),e.applyTransformation(p),h){const n=function(e,s,i,n,m,a,h){const l=function(e,s,i,n,m,a,h){const l={stack:[],error:void 0,hasError:!1};try{const n=e.getFirstPath(s),c=e.createUserIndex(),u=()=>{e.removeUserIndex(c)};t.__addDisposableResource(l,r.makeScopedCall(u,!1),!1),function(e,t,s,i){let n=-1;const o=new r.Point2D,m=new r.Point2D,a=new r.Point2D;for(let s=0,r=e.getPathSize(i),h=e.getFirstVertex(i);s<r;++s){-1===n&&(e.queryXY(h,m),n=e.getPrevVertex(h),-1!==n&&(e.queryXY(n,o),a.setSub(m,o),a.normalize()));const s=e.getNextVertex(h);if(-1===s)break;const i=e.getXY(s),r=i.sub(m);r.normalize(),-1!==n&&r.dotProduct(a)<-.99&&Math.abs(r.crossProduct(a))<1e-7&&e.setUserIndex(h,t,1),n=h,h=s,o.assign(m),m.assign(i),a.assign(r)}}(e,c,0,n);for(let t=0;t<100;++t){if(0===e.getPathSize(n))return 1;let t=e.getFirstVertex(n),s=e.getPathSize(n);if(s<3)return 1;e.isClosedPath(n)||(s-=1);const r=64;let a=0,l=!1;for(let n=0;n<s&&t!==o.nullHandle;n++){let o=0,u=t;for(let a=1,l=Math.min(r,s-n);a<l;a++)if(u=e.getNextVertexEx(u,i),a>1){const n=C(e,c,t,u,i,m,h,r);if(-1===n)break;o+=n,s-=n}if(a+=o,l=o>0,l){const n=e.getPrevVertexEx(t,i);if(-1!==n){t=n,s++;continue}}t=e.getNextVertexEx(t,i)}if(0===a)break}return e.filterClosePoints(a,!1,!1,!1,-1),1}catch(e){l.error=e,l.hasError=!0}finally{t.__disposeResources(l)}}(e,s,i,0,m,a,h);return l}(e,i,l,0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if(s.geometryReleaseAssert(1===n),e.getPointCount(i)<2)return l<0?0:(this.addCircle(m,u),2)}const P=0!==this.m_joins&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const y=e.getFirstPath(i);let b=e.getFirstVertex(y),x=1===l?e.getPrevVertex(b):e.getNextVertex(b),D=1===l?e.getNextVertex(b):e.getPrevVertex(b),w=!0;const T=new r.Point2D,v=new r.Point2D,S=new r.Point2D,I=new r.Point2D,E=new r.Point2D,M=new r.Point2D,A=new r.Point2D,R=new r.Point2D,V=this.m_absDistance,k=e.getPathSize(y),B=new r.Point2D(0,0);for(let t=0;t<k;t++){v.assign(e.getXY(D)),w&&(T.assign(e.getXY(b)),S.assign(e.getXY(x)),M.setSub(T,S),M.normalize(),R.leftPerpendicularOther(M),R.scale(V),I.setAdd(R,T));const t=P&&!!(1&e.getAttributeAsDbl(10,b,0));E.setSub(v,T),E.normalize(),A.leftPerpendicularOther(E),A.scale(V);const s=new r.Point2D;s.setAdd(T,A);const i=M.crossProduct(E),n=M.dotProduct(E);if(i<0||n<0&&i<Math.abs(n)*Number.EPSILON*8){let e=!1;const n=t?0:this.m_joins;if(1===n){const t=-i;B.setSub(M,E),B.scale(this.m_absDistance/t),B.length()<this.m_miterLimit*this.m_absDistance&&(B.addThis(T),e=!0),this.m_bufferCommands.push(_(I,s,B,e?f.enumMiter:f.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(_(I,s,T,0===n?f.enumArc:f.enumBevel,this.m_bufferCommands.length+1))}else I.equals(s)||(this.m_bufferCommands.push(g(I,T,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(g(T,s,this.m_bufferCommands.length+1)));const o=new r.Point2D;o.setAdd(v,A),this.m_bufferCommands.push(_(s,o,T,f.enumLine,this.m_bufferCommands.length+1)),I.setCoordsPoint2D(o),R.setCoordsPoint2D(A),S.setCoordsPoint2D(T),T.setCoordsPoint2D(v),M.setCoordsPoint2D(E),x=b,b=D,w=!1,D=1===l?e.getNextVertex(b):e.getPrevVertex(b)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(m),p.setShift(d),m.applyTransformationToPath(p,m.getPathCount()-1),1}bufferOpenPath(e,t,i,m){if(this.m_bRoundBuffer){const s=new o.Polyline({vd:e.getDescription()});return s.addPath(e,t,!1),s.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(s,0,i,m,1)}let h=0;const l=new o.Polyline({vd:e.getDescription()}),c=new r.Point2D(0,0);{const s=new o.EditShape,r=s.addPathFromMultiPath(e,t,!1),m=s.getFirstVertex(s.getFirstPath(r)),a=new n.Point;if(s.queryPoint(m,a),c.assign(a.getXY()),s.filterClosePoints(0,!1,!1,!1,-1),s.getPointCount(r)<2)return this.m_bRoundBuffer&&this.addCircle(i,a),2;const u=s.getGeometry(s.getFirstGeometry());l.addPath(u,0,!1),h=l.getPointCount()-1,l.addSegmentsFromPath(u,0,0,u.getSegmentCountPath(0)-1,!1)}const u=new o.EditShape,d=u.addPathFromMultiPath(l,0,!0);s.geometryReleaseAssert(u.getFirstPath(d)!==o.nullHandle),s.geometryReleaseAssert(u.getFirstVertex(u.getFirstPath(d))!==o.nullHandle);const p=new a.Transformation2D;p.setShift(c.negate()),u.applyTransformation(p),this.m_bufferCommands.length=0;const P=u.getFirstPath(d),y=0!==this.m_joins&&u.getVertexDescription().hasAttribute(10);let b=u.getFirstVertex(P),x=u.getPrevVertex(b),C=u.getNextVertex(b),D=!0;const w=new r.Point2D,T=new r.Point2D,v=new r.Point2D,S=new r.Point2D,I=new r.Point2D,E=new r.Point2D,M=new r.Point2D,A=new r.Point2D,R=this.m_absDistance,V=u.getPathSize(P),k=new r.Point2D(0,0);for(let e=0;e<V;e++){let t=!1;0!==e&&e!==h||(t=!0),T.assign(u.getXY(C)),D&&(w.assign(u.getXY(b)),v.assign(u.getXY(x)),E.setSub(w,v),E.normalize(),A.leftPerpendicularOther(E),A.scale(R),S.setAdd(A,w));const s=y&&!!(1&u.getAttributeAsDbl(10,b,0));I.setSub(T,w),I.normalize(),M.leftPerpendicularOther(I),M.scale(R);const i=new r.Point2D;i.setAdd(w,M);const n=E.crossProduct(I),o=E.dotProduct(I);if(n<0||o<0&&n<Math.abs(o)*Number.EPSILON*8)if(t)if(0===this.m_caps)this.m_bufferCommands.push(_(S,i,w,f.enumArc,this.m_bufferCommands.length+1));else if(1===this.m_caps)this.m_bufferCommands.push(_(S,i,w,f.enumLine,this.m_bufferCommands.length+1));else{const e=I.mul(this.m_absDistance).negate(),t=e.clone();e.addThis(S),t.addThis(i),this.m_bufferCommands.push(_(S,e,w,f.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(_(e,t,w,f.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(_(t,i,w,f.enumLine,this.m_bufferCommands.length+1))}else{let e=!1;const t=s?0:this.m_joins;if(1===t){const t=-n;k.setSub(E,I),k.scale(this.m_absDistance/t),k.length()<this.m_miterLimit*this.m_absDistance&&(k.addThis(w),e=!0),this.m_bufferCommands.push(_(S,i,k,e?f.enumMiter:f.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(_(S,i,w,0===t?f.enumArc:f.enumBevel,this.m_bufferCommands.length+1))}else S.equals(i)||(this.m_bufferCommands.push(g(S,w,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(g(w,i,this.m_bufferCommands.length+1)));const m=new r.Point2D;m.setAdd(T,M),this.m_bufferCommands.push(_(i,m,w,f.enumLine,this.m_bufferCommands.length+1)),S.setCoordsPoint2D(m),A.setCoordsPoint2D(M),v.setCoordsPoint2D(w),w.setCoordsPoint2D(T),E.setCoordsPoint2D(I),x=b,b=C,D=!1,C=u.getNextVertex(b)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(i),p.setShift(c),i.applyTransformationToPath(p,i.getPathCount()-1),1}processBufferCommands(e){const t=this.cleanupBufferCommands();let s=!0,i=t+1;for(let n=t;i!==t;n=i){const t=this.m_bufferCommands[n];i=-1!==t.m_next?t.m_next:(n+1)%this.m_bufferCommands.length,t.m_type&&(s&&(e.startPath(t.m_from),s=!1),t.m_type&f.enumJoinMask?this.addJoin(t.m_type,e,t.m_center,t.m_from,t.m_to,!1,!0):e.lineTo(t.m_to))}}cleanupBufferCommands(){this.m_helperArray=r.makeObjectArray(r.Point2D,9);let e=0;for(let t=0,s=this.m_bufferCommands.length;t<s;){const s=this.m_bufferCommands[t];if(s.m_type&f.enumConnectionMask){e=t;break}t=s.m_next}let t=e+1;for(let s=e;t!==e;s=t){const e=this.m_bufferCommands[s];t=e.m_next;let i=1,n=null;for(;t!==s&&(n=this.m_bufferCommands[t],!(n.m_type&f.enumConnectionMask));)t=n.m_next,i++;1!==i&&(e.m_type&n.m_type)===f.enumLine&&(this.m_helperLine1.setStartXY(e.m_from),this.m_helperLine1.setEndXY(e.m_to),this.m_helperLine2.setStartXY(n.m_from),this.m_helperLine2.setEndXY(n.m_to),1===this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())&&(e.m_to.assign(this.m_helperArray[0]),n.m_from.assign(this.m_helperArray[0]),e.m_next=t))}return e}isDegeneratePath(e,t){if(1===e.getPathSize(t))return!0;if(0===this.m_joins&&0===this.m_caps){const s=new m.Envelope2D;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(0===this.m_joins&&0===this.m_caps){const t=new m.Envelope2D;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){const s=t.getXY();if(0!==this.m_circleTemplate.length){let t=this.m_circleTemplate[0].clone();t.scaleAddThis(this.m_absDistance,s),e.startPath(t);for(let i=1,n=this.m_circleTemplate.length;i<n;i++)t=this.m_circleTemplate[i].clone(),t.scaleAddThis(this.m_absDistance,s),e.lineTo(t);return}const i=this.m_circleTemplateSize,n=Math.trunc((i+3)/4),o=.5*Math.PI/n;e.reserve(4*n);const m=Math.cos(o),a=Math.sin(o);for(let t=3;t>=0;t--){const i=r.Point2D.construct(0,this.m_absDistance);switch(t){case 0:for(let t=0;t<n;t++)e.lineToCoords(i.x+s.x,i.y+s.y),i.rotateReverse(m,a);break;case 1:for(let t=0;t<n;t++)e.lineToCoords(-i.y+s.x,i.x+s.y),i.rotateReverse(m,a);break;case 2:for(let t=0;t<n;t++)e.lineToCoords(-i.x+s.x,-i.y+s.y),i.rotateReverse(m,a);break;default:e.startPathCoords(i.y+s.x,-i.x+s.y);for(let t=1;t<n;t++)i.rotateReverse(m,a),e.lineToCoords(i.y+s.x,-i.x+s.y)}this.progress_()}}addSquare(e,t){const s=new n.Envelope({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}});