// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./tslib.es6","./Geometry","./MultiPathImpl","./ProjectionTransformation","./Envelope","./Envelope2D","./Point2D","./Transformation2D","./Distance2DCalculator-CXhBP-8I","./OperatorShapePreservingDensify","./OperatorClip"],function(t,e,i,n,s,o,r,a,m,u,c,h){"use strict";class l{[Symbol.dispose](){this.m_peR1.destroy(),this.m_peR2.destroy(),this.m_peR3.destroy(),this.m_peR1=null,this.m_peR2=null,this.m_peR3=null}constructor(t,e,i){this.m_peR1=new s.PeDoubleClass,this.m_peR2=new s.PeDoubleClass,this.m_peR3=new s.PeDoubleClass,void 0!==t?this.reset(t,e,i):this.reset(1,0,1)}reset(t,e,i){this.m_a=t,this.m_e2=e,this.m_b=this.m_a*Math.sqrt(1-this.m_e2),this.m_unitToDegree=i,this.m_unitToRad=.017453292519943295*i,this.m_u180=180/this.m_unitToDegree,this.m_u360=360/this.m_unitToDegree}calculateBbox(t,e,i,n){const o=this.m_peR1,m=this.m_peR2,u=this.m_peR3;s.peLineType.geodeticDistance(this.m_a,this.m_e2,t*this.m_unitToRad,e*this.m_unitToRad,i*this.m_unitToRad,n*this.m_unitToRad,u,o,m,0);const c=Math.cos(o.val),h=Math.cos(m.val+3.141592653589793),l=e*this.m_unitToRad,p=s.peMath.phiToEta(this.m_e2,l),_=Math.sin(o.val)*Math.cos(p);let y=e;if(c*h<0){const t=c<0?-1:1,e=Math.acos(Math.abs(_))*t;y=s.peMath.etaToPhi(this.m_e2,e)/this.m_unitToRad}let d=a.fmod((i-t)*this.m_unitToRad,2*Math.PI);Math.abs(d)>Math.PI&&(d=d>0?d-2*Math.PI:d+2*Math.PI),d/=this.m_unitToRad,i=t+d;const P=new r.Envelope2D;return P.xmin=Math.min(t,i),P.xmax=Math.max(t,i),P.ymin=Math.min(e,n),P.ymin=Math.min(P.ymin,y),P.ymax=Math.max(e,n),P.ymax=Math.max(P.ymax,y),P}minDistanceGeodesic(t,e){const i=p(t),n=p(e);if(i&&n)return this.lowerDistanceGeodetic_(t.xmin,t.ymin,e.xmin,e.ymin);const s=this.normalizeGeodesic_(e,t);return function(t,e){return e.xmax<t.xmin||e.xmin>t.xmax||e.ymax<t.ymin||e.ymin>t.ymax}(t,s)?t.ymin>=s.ymax?this.minDistanceGeodesicUpDown_(t,s):s.ymin>=t.ymax?this.minDistanceGeodesicUpDown_(s,t):t.xmin>s.xmax?this.minDistanceGeodesicLeftRight_(s,t):this.minDistanceGeodesicLeftRight_(t,s):0}normalizeGeodesic_(t,e){const i=t.clone(),n=t.clone();let s=_(i,e);if(0===s)return i;for(;n.xmax>e.xmin;){n.xmin-=this.m_u360,n.xmax-=this.m_u360;const t=_(n,e);if(t<s&&(i.assign(n),s=t,0===s))return i}for(n.assign(t);n.xmin<e.xmax;){n.xmin+=this.m_u360,n.xmax+=this.m_u360;const t=_(n,e);if(t<s&&(i.assign(n),s=t,0===s))return i}return i}lowerDistanceGeodetic_(t,e,i,n){const o=this.m_peR1;{const r=this.m_b*this.m_b/this.m_a,a=s.peMath.phiToPhig(this.m_e2,this.m_unitToRad*e),m=s.peMath.phiToPhig(this.m_e2,this.m_unitToRad*n);s.peLineType.geodeticDistance(r,0,this.m_unitToRad*t,a,this.m_unitToRad*i,m,o,null,null,0)}return o.val}minDistanceGeodesicUpDown_(t,e){if(e.xmin<=t.xmin?e.xmax>=t.xmin:t.xmax>=e.xmin)return this.lowerDistanceGeodetic_(0,t.ymin,0,e.ymax);if(e.xmin>t.xmax){const i=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);if(e.xmax-t.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);return Math.min(i,n)}{const i=this.lowerDistanceGeodeticSegMeridional_(t.xmin,t.ymin,t.ymax,e.xmax,e.ymin,e.ymax);if(t.xmax-e.xmin<this.m_u180)return i;const n=this.lowerDistanceGeodeticSegMeridional_(t.xmax,t.ymin,t.ymax,e.xmin,e.ymin,e.ymax);return Math.min(i,n)}}minDistanceGeodesicLeftRight_(t,e){let i=Math.abs(t.xmax-e.xmin);for(;i>this.m_u180;)i-=this.m_u360;let n=Math.abs(t.xmin-e.xmax);for(;n>this.m_u180;)n-=this.m_u360;return Math.abs(i)<=Math.abs(n)?this.minDistanceGeodesicLeftRightNormalized_(t,e):this.minDistanceGeodesicLeftRightNormalized_(e,t)}minDistanceGeodesicLeftRightNormalized_(t,e){let i,n;return i=this.lowerDistanceGeodetic_(t.xmax,t.ymin,e.xmin,e.ymin),t.ymin>=e.ymin&&t.ymin<=e.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymin,e.xmin,e.ymin,e.ymax),i=Math.min(i,n)),e.ymin>=t.ymin&&e.ymin<=t.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymin,t.xmax,t.ymin,t.ymax),i=Math.min(i,n)),n=this.lowerDistanceGeodetic_(t.xmax,t.ymax,e.xmin,e.ymax),i=Math.min(i,n),t.ymax>=e.ymin&&t.ymax<=e.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(t.xmax,t.ymax,e.xmin,e.ymin,e.ymax),i=Math.min(i,n)),e.ymax>=t.ymin&&e.ymax<=t.ymax&&(n=this.lowerDistanceGeodeticPtMeridional_(e.xmin,e.ymax,t.xmax,t.ymin,t.ymax),i=Math.min(i,n)),i}lowerDistanceGeodeticSegMeridional_(t,e,i,n,s,o){let r=this.lowerDistanceGeodeticPtMeridional_(t,e,n,s,o);const a=this.lowerDistanceGeodeticPtMeridional_(t,i,n,s,o);let m=this.lowerDistanceGeodeticPtMeridional_(n,s,t,e,i);const u=this.lowerDistanceGeodeticPtMeridional_(n,o,t,e,i);return r=Math.min(r,a),m=Math.min(m,u),Math.min(r,m)}lowerDistanceGeodeticPtMeridional_(t,e,i,n,r){const m=this.m_b*this.m_b/this.m_a,u=s.peMath.phiToPhig(this.m_e2,this.m_unitToRad*e),c=s.peMath.phiToPhig(this.m_e2,this.m_unitToRad*n),h=s.peMath.phiToPhig(this.m_e2,this.m_unitToRad*r),l=this.m_peR1,p=this.m_peR2;s.peLineType.geodeticDistance(m,0,this.m_unitToRad*i,c,this.m_unitToRad*t,u,l,null,null,0),s.peLineType.geodeticDistance(m,0,this.m_unitToRad*i,h,this.m_unitToRad*t,u,p,null,null,0);const _=s.curvToCart(1,0,new a.Point2D(this.m_unitToRad*t,u)),y=s.curvToCart(1,0,new a.Point2D(this.m_unitToRad*i,c)),d=s.curvToCart(1,0,new a.Point2D(this.m_unitToRad*i,h));let P=new o.Point3D;P.setCrossProductVector(y,d);const g=y.dotProduct(d);if(P.length()<1.568e-10)return g>=0?Math.min(l.val,p.val):0;P=P.getUnitVector();let x=new o.Point3D;if(x.setCrossProductVector(P,_),x.length()<1.568e-10)return Math.min(l.val,p.val)-1e-5*m;x=x.getUnitVector();let D=_.sub(P.mul(_.dotProduct(P)));{const e=new o.Point3D;e.setCrossProductVector(y,D);const i=new o.Point3D;i.setCrossProductVector(D,d);let n=P.dotProduct(e)>0&&P.dotProduct(i)>0;if(n||(D.negateThis(),e.setCrossProductVector(y,D),i.setCrossProductVector(D,d),n=P.dotProduct(e)>0&&P.dotProduct(i)>0),n){D=D.getUnitVector();const e=s.cartToCurv(1,0,D),i=this.m_peR3;s.peLineType.geodeticDistance(m,0,this.m_unitToRad*t,u,e.x,e.y,i,null,null,0);const n=Math.min(l.val,p.val);return Math.min(n,i.val)}}return Math.min(l.val,p.val)}}function p(t){return t.xmin===t.xmax&&t.ymin===t.ymax}function _(t,e){let i,n=0;return i=t.xmin-e.xmax,i>n&&(n=i),i=e.xmin-t.xmax,i>n&&(n=i),n}class y{}function d(t){return{outPoint:void 0===t?new a.Point2D:t.clone()}}function P(t,e){t.outPoint.assign(e.outPoint)}function g(){return new r.Envelope2D}class x{constructor(t,e,i,n,r=0,m=4){this.m_ptDistFrom=new a.Point2D,this.m_segStartPt=new a.Point2D,this.m_segEndPt=new a.Point2D,this.m_geodeticLength=new s.PeDoubleClass,this.m_az12=new s.PeDoubleClass,this.m_minGeodeticDist=new s.PeDoubleClass,this.m_segStartPt3d=new o.Point3D,this.m_segEndPt3d=new o.Point3D,this.m_sr=n,this.m_distCurveType=r,this.m_segCurveType=m,this.m_inputGCS=this.m_sr.getGCS(),this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_bIsPannablePcs=2===this.m_sr.getCoordinateSystemType()&&this.m_sr.isPannable();const u=s.makeSpheroidData();this.m_inputGCS.querySpheroidData(u),this.m_a=u.majorSemiAxis,this.m_eSquared=u.e2,this.setPointDistFrom(t),this.setSegmentEndPoints(e,i)}setSegmentEndPoints(t,e){this.m_segStartPt.assign(t),this.m_segEndPt.assign(e),this.m_bIsPannablePcs||(this.m_segStartPt.mulThis(this.m_rpu),this.m_segEndPt.mulThis(this.m_rpu)),2===this.m_segCurveType&&(this.m_segStartPt3d.assign(s.curvToCart(this.m_a,this.m_eSquared,this.m_segStartPt)),this.m_segEndPt3d.assign(s.curvToCart(this.m_a,this.m_eSquared,this.m_segEndPt))),this.calculateAndUpdateSegmentLength()}setPointDistFrom(t){this.m_ptDistFrom.assign(t),this.m_ptDistFrom.scale(this.m_rpu)}setSegmentCurveType(t){this.m_segCurveType=t}setDistanceCurveType(t){this.m_distCurveType=t}makeFunctor(){return t=>{let n;switch(this.m_segCurveType){case 0:case 1:case 3:{const i={stack:[],error:void 0,hasError:!1};try{const o=e.__addDisposableResource(i,new s.PeDoubleClass,!1),r=e.__addDisposableResource(i,new s.PeDoubleClass,!1);s.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_geodeticLength.val*t,this.m_az12.val,o,r,this.m_segCurveType),n=new a.Point2D(o.val,r.val);break}catch(t){i.error=t,i.hasError=!0}finally{e.__disposeResources(i)}}case 2:{const e=o.Point3D.lerp(this.m_segStartPt3d,this.m_segEndPt3d,t);n=s.cartToCurv(this.m_a,this.m_eSquared,e);break}case 4:n=a.Point2D.lerp(this.m_segStartPt,this.m_segEndPt,t),this.m_bIsPannablePcs&&(s.PEProjToGeogCenterPoint2D(this.m_sr,0,[n],1),n.mulThis(this.m_rpu));break;default:i.throwInternalErrorException("Invalid curve type")}return s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,this.m_ptDistFrom.x,this.m_ptDistFrom.y,n.x,n.y,this.m_minGeodeticDist,null,null,this.m_distCurveType),this.m_minGeodeticDist.val}}calculateAndUpdateSegmentLength(){switch(this.m_segCurveType){case 0:case 2:case 1:case 3:s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,this.m_segStartPt.x,this.m_segStartPt.y,this.m_segEndPt.x,this.m_segEndPt.y,this.m_geodeticLength,this.m_az12,null,this.m_segCurveType);break;case 4:this.m_geodeticLength.val=a.Point2D.distance(this.m_segStartPt,this.m_segEndPt);break;default:i.throwInternalErrorException("Invalid curve type")}}[Symbol.dispose](){this.m_geodeticLength[Symbol.dispose](),this.m_az12[Symbol.dispose](),this.m_minGeodeticDist[Symbol.dispose]()}}function D(){return new y}class T{[Symbol.dispose](){this.m_envHelper[Symbol.dispose]()}constructor(t,e,i,n,o){this.m_boxGeomA=g(),this.m_boxGeomB=g(),this.m_envGeomA=new r.Envelope2D,this.m_envGeomB=new r.Envelope2D,this.m_progressCounter=0,this.m_transformPCS2GCS=null,this.m_segmentBoxesA=new Map,this.m_segmentBoxesB=new Map,this.m_boundaryPtsA=[],this.m_boundaryPtsB=[],this.m_scaleToRadians=new m.Transformation2D,this.m_scaleToDegrees=new m.Transformation2D,this.m_inputSR=t,this.m_distCurveType=e,this.m_progressTracker=i,this.m_maxDistance=n,this.m_maxDeviation=o,this.m_inputGCS=t.getGCS(),this.m_peGeogcs=this.m_inputGCS.getPECoordSys(),this.m_tolerance=0;const a=s.makeSpheroidData();this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_eSquared=a.e2,this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_envHelper=new l(this.m_a,this.m_eSquared,1),4===this.m_distCurveType&&(this.m_distCurveType=0),this.m_boxGeomA.setEmpty(),this.m_boxGeomB.setEmpty(),this.m_envGeomA.setEmpty(),this.m_envGeomB.setEmpty(),this.m_bIsPannablePcs=2===this.m_inputSR.getCoordinateSystemType()&&this.m_inputSR.isPannable()}progress(t=!1){}calculate(t,e,i,n){const s=d(),o=d();if(t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.checkGeometriesIntersect(t,e,s,o))return i&&P(i,s),n&&P(n,o),0;const r=this.prepareGeometry(t);if(r.isEmpty())return Number.NaN;const a=this.prepareGeometry(e);if(a.isEmpty())return Number.NaN;this.m_tolerance=this.computeTolerance(r,a);const m=this._ExecuteBruteForce(r,a,s,o);return m>=this.m_maxDistance?Number.NaN:(i&&(this.prepareOutput(s),P(i,s)),n&&(this.prepareOutput(o),P(n,o)),m)}createDistanceFunctor(t,e,i){const n=new x(t,e,i,this.m_inputSR,this.m_distCurveType);return this.m_bIsPannablePcs||1===this.m_inputSR.getCoordinateSystemType()||n.setSegmentCurveType(2),n}_NormalizeAndProject(t){if(this.m_inputSR.isPannable()&&(t=(new s.OperatorProject).foldInto360Range(t,this.m_inputSR)),2===this.m_inputSR.getCoordinateSystemType()){const e=s.createEx(this.m_inputSR,this.m_inputGCS,null);t=(new s.OperatorProject).execute(t,e,this.m_progressTracker)}return t}_ExecuteBruteForce(t,e,n,s){switch(t.getGeometryType()){case i.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointGeometry(t,e,n,s);case i.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticMultipointGeometry(t,e,n,s);case i.GeometryType.enumPolyline:case i.GeometryType.enumPolygon:case i.GeometryType.enumEnvelope:return this.calculateDistanceGeodeticMultipathGeometry(t,e,n,s);default:i.throwInvalidArgumentException("")}}calculateDistanceGeodeticPointGeometry(t,e,n,s){switch(e.getGeometryType()){case i.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointPoint(t,e,n,s);case i.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticPointMultipoint(t,e,n,s);case i.GeometryType.enumPolyline:case i.GeometryType.enumPolygon:return this.calculateDistanceGeodeticPointMultipath(t,e,n,s);default:i.throwInvalidArgumentException("")}}calculateDistanceGeodeticPointPoint(t,i,n,o){const r={stack:[],error:void 0,hasError:!1};try{const a=t.getXY();a.scale(this.m_rpu);const m=i.getXY();m.scale(this.m_rpu),n.outPoint.assign(a),o.outPoint.assign(m);const u=e.__addDisposableResource(r,new s.PeDoubleClass,!1);return s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,a.x,a.y,m.x,m.y,u,null,null,this.m_distCurveType),u.val}catch(t){r.error=t,r.hasError=!0}finally{e.__disposeResources(r)}}calculateDistanceGeodeticPointMultipoint(t,i,n,r){const m={stack:[],error:void 0,hasError:!1};try{this.computeEnvelopesAndBoxes(t,i);const u=this.estimateMinimumDistance(n,r);let c=u<this.m_maxDistance?u:this.m_maxDistance;const h=t.getXY();h.scale(this.m_rpu),n.outPoint.assign(h);const l=s.curvToCart(this.m_a,this.m_eSquared,h),p=new a.Point2D,_=i.getImpl(),y=e.__addDisposableResource(m,new s.PeDoubleClass,!1),d=_.getPointCount();for(let t=0;t<d;++t){_.queryXY(t,p),p.scale(this.m_rpu);const e=s.curvToCart(this.m_a,this.m_eSquared,p);if(!(o.Point3D.distance(l,e)>c)&&!(this.m_envHelper.minDistanceGeodesic(this.m_boxGeomA,this.m_boxGeomB)>c)&&(s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,p.x,p.y,y,null,null,this.m_distCurveType),y.val<c&&(c=y.val,r.outPoint=p,0===c)))return c}return c===this.m_maxDistance?Number.POSITIVE_INFINITY:c}catch(t){m.error=t,m.hasError=!0}finally{e.__disposeResources(m)}}calculateDistanceGeodeticPointMultipath(t,n,o,r){const m={stack:[],error:void 0,hasError:!1};try{const u=new a.Point2D,c=new a.Point2D;u.assign(t.getXY()),c.assign(t.getXY()),o.outPoint.assign(c.mul(this.m_rpu)),this.m_bIsPannablePcs&&s.PEGeogToProj(this.m_inputSR,[u],1,!1),this.computeEnvelopesAndBoxes(t,n);const h=this.estimateMinimumDistance(o,r);let l=h<this.m_maxDistance?h:this.m_maxDistance;const p=n.getImpl(),_=new a.Point2D(0,0),y=new a.Point2D(0,0),d=[1],P=this.canUseSpatialTree(t,n),x=D();P&&this.buildSpatialTree(x,n);const T=g();T.setCoords({xmin:c.x,ymin:c.y,xmax:c.x,ymax:c.y});const G=e.__addDisposableResource(m,this.createDistanceFunctor(c,_,y),!1),S=p.querySegmentIterator();if(S.stripAttributes(),P)i.geometryReleaseAssert(0);else for(;S.nextPath();)for(;S.hasNextSegment();){const t=S.nextSegment(),e=this.findOrComputeBoxSegment(S.getStartPointIndex(),t,this.m_segmentBoxesB);if(this.m_envHelper.minDistanceGeodesic(T,e)>l)continue;const i=this.calculateDistanceGeodeticPointSegment(u,c,t,d,G);if(i.second<l&&(this.updateOutputSegment(r,t,i.first),l=i.second,0===l))return 0}return l===this.m_maxDistance?Number.POSITIVE_INFINITY:l}catch(t){m.error=t,m.hasError=!0}finally{e.__disposeResources(m)}}calculateDistanceGeodeticMultipointGeometry(t,e,n,s){switch(e.getGeometryType()){case i.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointMultipoint(e,t,s,n);case i.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipoint(t,e,n,s);case i.GeometryType.enumPolyline:case i.GeometryType.enumPolygon:case i.GeometryType.enumEnvelope:return this.calculateDistanceGeodeticMultipointMultipath(t,e,n,s);default:i.throwInvalidArgumentException("")}}calculateDistanceGeodeticMultipointMultipoint(t,i,n,r){const m={stack:[],error:void 0,hasError:!1};try{const u=e.__addDisposableResource(m,new s.PeDoubleClass,!1);this.computeEnvelopesAndBoxes(t,i);const c=this.estimateMinimumDistance(n,r);let h=c<this.m_maxDistance?c:this.m_maxDistance;const l=new a.Point2D,p=new a.Point2D,_=t.getImpl(),y=i.getImpl(),d=g(),P=_.getPointCount(),x=y.getPointCount();for(let t=0;t<P;++t){if(l.assign(_.getXY(t)),d.setCoords({xmin:l.x,ymin:l.y,xmax:l.x,ymax:l.y}),this.m_envHelper.minDistanceGeodesic(d,this.m_boxGeomB)>h)continue;l.scale(this.m_rpu);const e=s.curvToCart(this.m_a,this.m_eSquared,l);for(let t=0;t<x;++t){p.assign(y.getXY(t)),p.scale(this.m_rpu);const i=s.curvToCart(this.m_a,this.m_eSquared,p);if(!(o.Point3D.distance(e,i)>=h)&&(s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,p.x,p.y,u,null,null,this.m_distCurveType),u.val<h&&(n.outPoint.assign(l),r.outPoint.assign(p),h=u.val,0===h)))return h}}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){m.error=t,m.hasError=!0}finally{e.__disposeResources(m)}}calculateDistanceGeodeticMultipointMultipath(t,n,o,r){const m={stack:[],error:void 0,hasError:!1};try{const u=n.getImpl().querySegmentIterator();u.stripAttributes(),this.computeEnvelopesAndBoxes(t,n);const c=this.estimateMinimumDistance(o,r);let h=c<this.m_maxDistance?c:this.m_maxDistance;const l=new a.Point2D,p=new a.Point2D(0,0),_=new a.Point2D(0,0),y=new a.Point2D(0,0),d=[0],P=g(),x=e.__addDisposableResource(m,this.createDistanceFunctor(p,_,y),!1),T=D(),G=this.canUseSpatialTree(t,n);G&&this.buildSpatialTree(T,n);const S=t.getPointCount();for(let e=0;e<S;++e)if(l.assign(t.getXY(e)),p.assign(t.getXY(e)),this.m_bIsPannablePcs&&s.PEGeogToProj(this.m_inputSR,[l],1,!1),P.setCoords({xmin:p.x,ymin:p.y,xmax:p.x,ymax:p.y}),!(this.m_envHelper.minDistanceGeodesic(P,this.m_boxGeomB)>h))if(x.setPointDistFrom(p),G)i.geometryReleaseAssert(0);else{for(;u.nextPath();)for(;u.hasNextSegment();){const t=u.nextSegment();if(this.m_envHelper.minDistanceGeodesic(P,this.findOrComputeBoxSegment(u.getStartPointIndex(),t,this.m_segmentBoxesB))>h)continue;const e=this.calculateDistanceGeodeticPointSegment(l,p,t,d,x);if(e.second<h&&(o.outPoint.assign(p.mul(this.m_rpu)),this.updateOutputSegment(r,t,e.first),h=e.second,0===h))return 0}u.resetToFirstPath()}return h===this.m_maxDistance?Number.POSITIVE_INFINITY:h}catch(t){m.error=t,m.hasError=!0}finally{e.__disposeResources(m)}}calculateDistanceGeodeticMultipathGeometry(t,e,n,s){switch(e.getGeometryType()){case i.GeometryType.enumPoint:return this.calculateDistanceGeodeticPointMultipath(e,t,s,n);case i.GeometryType.enumMultiPoint:return this.calculateDistanceGeodeticMultipointMultipath(e,t,s,n);case i.GeometryType.enumPolyline:case i.GeometryType.enumPolygon:case i.GeometryType.enumEnvelope:return this.calculateDistanceGeodeticMultipathMultipath(t,e,n,s);default:i.throwInvalidArgumentException("")}}calculateDistanceGeodeticMultipathMultipath(t,e,i,n){const s=[t],o=[e],r=this.swapGeometries(s,o),m=s[0],u=o[0];this.computeEnvelopesAndBoxes(s[0],o[0]);const c=this.estimateMinimumDistance(i,n),h=this.calculateDistanceGeodeticMultipathMultipath_(m,u,i,n,c);return r&&(n.outPoint=a.swap(i.outPoint,i.outPoint=n.outPoint)),h}calculateDistanceGeodeticMultipathMultipath_(t,o,r,m,c=Number.MAX_VALUE){const h={stack:[],error:void 0,hasError:!1};try{let l=c;const p=new a.Point2D(0,0),_=new a.Point2D,y=new a.Point2D(0,0),d=new a.Point2D,P=new a.Point2D(0,0),x=new a.Point2D,T=new a.Point2D,G=new a.Point2D,S=[new a.Point2D],v=[0],f=[0],b=g(),E=g(),w=e.__addDisposableResource(h,this.createDistanceFunctor(P,p,y),!1),M=D(),C=this.canUseSpatialTree(t,o);C&&this.buildSpatialTree(M,o);const R=o.querySegmentIterator();R.stripAttributes();const I=new n.SegmentBuffer,B=u.shuffleMultipathSegments(t);for(let e=0;e<B.length;++e){const n=B[e];t.getSegmentBuffer(n,I,!0);const o=I.get();if(b.assign(this.findOrComputeBoxSegment(n,o,this.m_segmentBoxesA)),C)i.geometryReleaseAssert(0);else{if(P.assign(o.getStartXY()),x.assign(o.getStartXY()),T.assign(o.getEndXY()),G.assign(o.getEndXY()),this.m_bIsPannablePcs&&(s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[x],1),s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[G],1)),this.m_envHelper.minDistanceGeodesic(b,this.m_boxGeomB)>l)continue;for(;R.nextPath();){for(;R.hasNextSegment();){const t=R.nextSegment();if(p.assign(t.getStartXY()),_.assign(t.getStartXY()),y.assign(t.getEndXY()),d.assign(t.getEndXY()),o.intersect(t,S,v,f,this.m_tolerance))return this.updateOutputSegment(r,o,v[0]),this.updateOutputSegment(m,t,f[0]),0;if(this.m_bIsPannablePcs&&(s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[_],1),s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[d],1)),E.assign(this.findOrComputeBoxPoint(R.getStartPointIndex(),_,d,this.m_segmentBoxesB)),this.m_envHelper.minDistanceGeodesic(b,E)>l)continue;w.setSegmentEndPoints(p,y),w.setPointDistFrom(x);let e=s.brentMinimization(w.makeFunctor(),0,1,1e-10);if(e.second<l&&(r.outPoint.assign(x.mul(this.m_rpu)),this.updateOutputSegment(m,t,e.first),l=e.second,0===l))break;if(w.setPointDistFrom(G),e=s.brentMinimization(w.makeFunctor(),0,1,1e-10),e.second<l&&(r.outPoint.assign(G.mul(this.m_rpu)),this.updateOutputSegment(m,t,e.first),l=e.second,0===l))break;if(w.setSegmentEndPoints(P,T),w.setPointDistFrom(_),e=s.brentMinimization(w.makeFunctor(),0,1,1e-10),e.second<l&&(this.updateOutputSegment(r,o,e.first),m.outPoint.assign(_.mul(this.m_rpu)),l=e.second,0===l))break;if(w.setPointDistFrom(d),e=s.brentMinimization(w.makeFunctor(),0,1,1e-10),e.second<l&&(this.updateOutputSegment(r,o,e.first),m.outPoint.assign(d.mul(this.m_rpu)),l=e.second,0===l))break}if(0===l)return 0}R.resetToFirstPath()}}return l===this.m_maxDistance?Number.POSITIVE_INFINITY:l}catch(t){h.error=t,h.hasError=!0}finally{e.__disposeResources(h)}}calculateDistanceGeodeticPointSegment(t,e,i,n,o){const r=i.getStartXY(),m=i.getEndXY();return i.intersectPoint(t,n,this.m_tolerance)?a.makePair(n[0],0):(o.setPointDistFrom(e),o.setSegmentEndPoints(r,m),s.brentMinimization(o.makeFunctor(),0,1,1e-10))}prepareGeometry(t){let e=t.clone();const n=t.getGeometryType();if(n===i.GeometryType.enumPoint||n===i.GeometryType.enumMultiPoint)return this._NormalizeAndProject(e);if(n===i.GeometryType.enumEnvelope&&(e=this.envelopeToPolygon(e)),this.m_inputSR.isPannable())return this.prepareGeometryPannable(e,4);if(2===this.m_inputSR.getCoordinateSystemType()){if(e=s.processWithPCSHorizon(e,this.m_inputSR,0,null),e.isEmpty())return e;e=(new c.OperatorShapePreservingDensify).execute(e,this.m_inputSR,5e4,this.m_maxDeviation/2,0,null);const t=this.m_inputSR.getSRToGCSTransform();return(new s.OperatorProject).execute(e,t,this.m_progressTracker)}const o=new r.Envelope2D;e.queryLooseEnvelope(o);const a=this.m_inputSR.getPannableExtent();if(o.ymin<a.ymin||o.ymax>a.ymax){const t=new r.Envelope2D(o.xmin-1,a.ymin,o.xmax+1,a.ymax);if(e=(new h.OperatorClip).execute(e,t,this.m_inputSR,this.m_progressTracker),e.isEmpty())return e}return o.width()>2*a.width()?(e=s.foldGeometry(e,-2*a.width(),2*a.width(),this.m_inputSR,!0,0,!0,this.m_progressTracker),e):e}prepareGeometryPannable(t,e){const i=new r.Envelope2D;t.queryEnvelope(i);const n=this.m_inputSR.getPannableExtent();if(n.containsEnvelope(i))return t;const o=new a.Envelope1D;n.queryIntervalX(o);const m=new a.Envelope1D;return i.queryIntervalX(m),o.contains(m)?s.clipGeometryFromTopAndBottom(t,this.m_inputSR):(new s.OperatorProject).foldInto360RangeGeodetic(t,this.m_inputSR,e)}prepareOutput(t){t.outPoint.scale(1/this.m_rpu),2===this.m_inputSR.getCoordinateSystemType()&&s.PEGeogToProj(this.m_inputSR,[t.outPoint],1,!1)}updateOutputSegment(t,e,i){e.queryCoord2D(i,t.outPoint),this.m_bIsPannablePcs&&s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[t.outPoint],1),t.outPoint.mulThis(this.m_rpu)}computeTolerance(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB);const i=new r.Envelope2D(this.m_envGeomA);return i.mergeEnvelope2D(this.m_envGeomB),o.calculateToleranceFromGeometryForRel(null,i)}envelopeToPolygon(t){const e=new n.Polygon;return e.addEnvelope(t,!1),e}computeEnvelopesAndBoxes(t,e){t.queryEnvelope(this.m_envGeomA),e.queryEnvelope(this.m_envGeomB),this.m_boxGeomA=this.computeBoxGeometry(t,this.m_boundaryPtsA,this.m_segmentBoxesA),this.m_boxGeomB=this.computeBoxGeometry(e,this.m_boundaryPtsB,this.m_segmentBoxesB)}computeBoxGeometry(t,e,n){switch(t.getGeometryType()){case i.GeometryType.enumPoint:return this.computeBoxPoint(t,e);case i.GeometryType.enumMultiPoint:return this.computeBoxMultiPoint(t,e);case i.GeometryType.enumPolyline:case i.GeometryType.enumPolygon:return this.computeBoxMultiPath(t,e,n);default:i.throwInternalErrorException("Invalid geometry type")}}computeBoxPoint(t,e){const i=t.getXY();e.length=0,e.push(i.mul(this.m_rpu));const n=g();return n.setCoords({xmin:i.x,ymin:i.y,xmax:i.x,ymax:i.y}),n}computeBoxMultiPoint(t,e){let i=!0;for(let n=0;n<t.getPointCount();++n){const s=t.getXY(n);if(i){e.length=0;for(let t=0;t<4;++t)e.push(s.clone());i=!1}s.x<e[0].x&&e[0].assign(s),s.y>e[1].y&&e[1].assign(s),s.x>e[2].x&&e[2].assign(s),s.y<e[3].y&&e[3].assign(s)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);const n=g();return t.queryEnvelope(n),n}computeBoxMultiPath(t,e,i){let n=!0;const o=g();o.setEmpty();const r=t.querySegmentIterator();for(r.stripAttributes();r.nextPath();)for(;r.hasNextSegment();){const t=r.nextSegment(),a=t.getStartXY(),m=t.getEndXY();if(this.m_bIsPannablePcs&&(s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[a],1),s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[m],1)),n){for(let t=0;t<4;++t)e.push(a.clone());n=!1}a.x<e[0].x&&e[0].assign(a),a.y>e[1].y&&e[1].assign(a),a.x>e[2].x&&e[2].assign(a),a.y<e[3].y&&e[3].assign(a),m.x<e[0].x&&e[0].assign(m),m.y>e[1].y&&e[1].assign(m),m.x>e[2].x&&e[2].assign(m),m.y<e[3].y&&e[3].assign(m);const u=this.findOrComputeBoxPoint(r.getStartPointIndex(),a,m,i);o.mergeEnvelope2D(u)}for(let t=0;t<e.length;++t)e[t].mulThis(this.m_rpu);return o}findOrComputeBoxSegment(t,e,i){if(!i.has(t)){let n=g();if(e.queryEnvelope(n),this.m_bIsPannablePcs){const t=a.Point2D.construct(n.xmin,n.ymin),e=a.Point2D.construct(n.xmax,n.ymax);s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[t],1),s.PEProjToGeogCenterPoint2D(this.m_inputSR,0,[e],1),n=this.m_envHelper.calculateBbox(t.x,t.y,e.x,e.y)}return i.set(t,n),n}return i.get(t)}findOrComputeBoxPoint(t,e,i,n){if(!n.has(t)){let s=g();return s.setCoords({xmin:e.x,ymin:e.y,xmax:i.x,ymax:i.y}),this.m_bIsPannablePcs&&(s=this.m_envHelper.calculateBbox(s.xmin,s.ymin,s.xmax,s.ymax)),n.set(t,s),s}return n.get(t)}estimateMinimumDistance(t,i){const n={stack:[],error:void 0,hasError:!1};try{const r=t=>s.curvToCart(this.m_a,this.m_eSquared,t),a=this.m_boundaryPtsA.map(r),m=this.m_boundaryPtsB.map(r);let u=Number.MAX_VALUE,c=0,h=0;for(let t=0;t<a.length;++t)for(let e=0;e<m.length;++e){const i=o.Point3D.distance(a[t],m[e]);i<u&&(u=i,c=t,h=e)}t.outPoint.assign(this.m_boundaryPtsA[c]),i.outPoint.assign(this.m_boundaryPtsB[h]);const l=e.__addDisposableResource(n,new s.PeDoubleClass,!1);return s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,this.m_boundaryPtsA[c].x,this.m_boundaryPtsA[c].y,this.m_boundaryPtsB[h].x,this.m_boundaryPtsB[h].y,l,null,null,this.m_distCurveType),l.val}catch(t){n.error=t,n.hasError=!0}finally{e.__disposeResources(n)}}swapGeometries(t,e){return i.vertexCount(t[0])>i.vertexCount(e[0])&&(e[0]=a.swap(t[0],t[0]=e[0]),this.m_envGeomB=a.swap(this.m_envGeomA,this.m_envGeomA=this.m_envGeomB),!0)}canUseSpatialTree(t,e){return!1}checkGeometriesIntersect(t,e,n,o){let r=t.getGeometryType(),a=e.getGeometryType();if(this.m_envGeomA.isIntersecting(this.m_envGeomB)){if(r===i.GeometryType.enumPoint&&2===e.getDimension()){const i=[0],r=[t.getXY()];if(s.testPointsInArea2D(e,r,1,this.m_tolerance,i),0!==i[0])return n.outPoint.assign(r[0]),o.outPoint.assign(r[0]),!0}else if(a===i.GeometryType.enumPoint&&2===t.getDimension()){const i=[2],r=[e.getXY()];if(s.testPointsInArea2D(t,r,1,this.m_tolerance,i),0!==i[0])return n.outPoint.assign(r[0]),o.outPoint.assign(r[0]),!0}if(r===i.GeometryType.enumMultiPoint&&2===e.getDimension())return this.multipointIntersectsArea(t,e,n,o);if(a===i.GeometryType.enumMultiPoint&&2===t.getDimension())return this.multipointIntersectsArea(e,t,o,n);let m,c,h=t,l=e;if(r===i.GeometryType.enumEnvelope&&(m=this.envelopeToPolygon(t),h=m,r=i.GeometryType.enumPolygon),a===i.GeometryType.enumEnvelope&&(c=this.envelopeToPolygon(e),l=c,a=i.GeometryType.enumPolygon),i.isMultiPath(r)&&i.isMultiPath(a)){const t=h.querySegmentIterator(),e=l.querySegmentIterator(),i=u.makeOutput(),s=u.makeOutput();if(u.weakIntersectionTest(h,l,t,e,i,s))return n.outPoint.assign(i.outPoint),o.outPoint.assign(i.outPoint),!0}}return!1}multipointIntersectsArea(t,e,i,n){const o=t.getPointCount();for(let r=0;r<o;++r){const o=[2],a=t.getXY(r);if(s.testPointsInArea2D(e,[a],1,this.m_tolerance,o),0!==o[0])return i.outPoint.assign(a),n.outPoint.assign(a),!0}return!1}getNearestNeighbourVisitor(t,e,n,s,o,r,a){return i.geometryReleaseAssert(0),{}}buildSpatialTree(t,e){i.geometryReleaseAssert(0)}}t.GeodeticDistanceCalculator=T,t.GeodeticDistanceFunctor=x,t.makeOutput=d});