// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./Geometry","./MultiPathImpl","./OperatorDensify","./ProjectionTransformation","./Point2D","./Envelope2D","./Envelope","./OperatorClip","./OperatorShapePreservingLength","./tslib.es6","./Transformation2D","./GeodeticDistanceCalculator-Ce-woMPw"],function(e,t,i,n,s,a,r,_,o,h,m,l,p){"use strict";class u{constructor(e,t,i,n,s=100){this.m_startPt=e.clone(),this.m_endPt=t.clone(),this.m_cE2=n,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=i.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=2===i.getCoordinateSystemType(),this.PEProjcs=i.getPECoordSys(),this.m_points=a.makePrimitiveArray(2*s,Number.NaN)}setSegmentEndPoints(e,t){this.m_startPt.assign(e),this.m_endPt.assign(t)}makeFunctor(){return e=>{const t=[0,0];t[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,t[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&s.peCSTransformations.projToGeogCenter(this.PEProjcs,1,t,0);const i=Math.sin(t[1]*this.m_cRpu);return 0===this.m_cE2?i:-Math.log((1-this.m_cE*i)/(1+this.m_cE*i))*this.m_c1By2e+i/(1-this.m_cE2*i*i)}}}function c(e,t,i,a,_){const o=(new n.OperatorDensify).execute(e,t,0,0,_);let h;h=a?(new s.OperatorProject).execute(o,a,_):o;const m=1===i.getUnit().getUnitToBaseFactor()?Math.PI/180:1,l=new r.Envelope2D;h.queryEnvelope(l);const p=new r.Envelope2D,u=new r.Envelope2D,c=new r.Envelope2D;p.setCoords({xmin:l.xmin,ymin:75*m,xmax:l.xmax,ymax:90*m}),u.setCoords({xmin:l.xmin,ymin:-60*m,xmax:l.xmax,ymax:75*m}),c.setCoords({xmin:l.xmin,ymin:-90*m,xmax:l.xmax,ymax:-60*m}),p.inflateCoords(.01*p.width(),0),u.inflateCoords(.01*u.width(),0),c.inflateCoords(.01*c.width(),0);let P=0;return P+=g(h,p,i,_),P+=g(h,u,i,_),P+=g(h,c,i,_),P}function g(e,i,n,_){const h=(new o.OperatorClip).execute(e,i,n,_);if(null!==h&&!h.isEmpty()){const e=new r.Envelope2D;h.queryEnvelope(e);const{first:i,second:o}=function(e,i){const n=function(e,i){const n=e.getUnit().getUnitToBaseFactor(),r=i.getCenter();r.scale(180*n/Math.PI);const _=new a.Point2D;_.x=0,_.y=0;let o=0;if(0===o){r.y>45?(_.y=a.geometryHalfPi,o=0):r.y<-45?(_.y=-a.geometryHalfPi,o=1):r.x>=45&&r.x<135?(_.x=a.geometryHalfPi,o=2):r.x>=135||r.x<-135?(_.x=a.geometryHalfPi,o=3):r.x<-45&&r.x>=-135?(_.x=-a.geometryHalfPi,o=4):(_.x=0,o=5);const e=n*Math.sqrt(a.sqr(i.xmin-i.xmax)+a.sqr(i.ymin-i.ymax)),t=_.clone(),s=i.getCenter();if(s.scale(n),o<2&&(t.x=s.x),a.Point2D.distance(t,s)+.5*e>a.geometryHalfPi)return null}const h=P[o];if(null!==h&&h.getGCS().equalHorizontal(e))return h;const m=e.getText(),l=_.x,p=_.y;let u=0,c=-1;6!==o?c=s.peDefs.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(t.geometryReleaseAssert(!1),u=0,c=s.peDefs.PE_PRJ_CYLINDRICAL_EQAREA);const g=s.getTempName("EqualAreaPCS");let d;c===s.peDefs.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?d=`PROJCS["${g}",${m},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:c===s.peDefs.PE_PRJ_CYLINDRICAL_EQAREA?d=`PROJCS["${g}",${m},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${l}],PARAMETER["Standard_Parallel_1",${u}],PARAMETER["Latitude_of_Origin",${p}],UNIT["Meter",1.0]]`:t.throwInternalErrorException("getEqualAreaPcsFixed");const E=s.createFromWKT$2(d);return P[o]&&P[o].destroy(),P[o]=E,E}(e,i);if(null!==n)return a.makePair(n,!1);const r=e.getText(),_=e.getUnit().getUnitToBaseFactor(),o=(i.xmin+i.width()/2)*_,h=(i.ymin+i.height()/2)*_;let m=0,l=0,p=-1;i.ymin*_>=75*Math.PI/180||i.ymax*_<=-60*Math.PI/180?p=s.peDefs.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:i.ymin>0||i.ymax<0?(m=(i.ymin+1/3*i.height())*_,l=(i.ymin+2/3*i.height())*_,p=s.peDefs.PE_PRJ_ALBERS):(m=(i.ymin+2/3*i.height())*_,p=s.peDefs.PE_PRJ_CYLINDRICAL_EQAREA);const u=s.getTempName("EqualAreaPCS");let c;return p===s.peDefs.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?c=`PROJCS["${u}",${r},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${o}],PARAMETER["Latitude_of_Origin",${h}],UNIT["Meter",1.0]]`:p===s.peDefs.PE_PRJ_ALBERS?c=`PROJCS["${u}",${r},PROJECTION["Albers"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${o}],PARAMETER["Standard_Parallel_1",${m}],PARAMETER["Standard_Parallel_2",${l}],PARAMETER["Latitude_of_Origin",${h}],UNIT["Meter",1.0]]`:p===s.peDefs.PE_PRJ_CYLINDRICAL_EQAREA?c=`PROJCS["${u}",${r},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing",0],PARAMETER["Central_Meridian",${o}],PARAMETER["Standard_Parallel_1",${m}],PARAMETER["Latitude_of_Origin",${h}],UNIT["Meter",1.0]]`:t.throwInternalErrorException("getEqualAreaPCSInstance"),a.makePair(s.createFromWKT$2(c),!0)}(n,e),m=s.createEx(n,i,null),l=(new s.OperatorProject).execute(h,m,_).calculateArea2D();return o&&i.destroy(),l}return 0}const P=[null,null,null,null,null,null,null];class d{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}execute(e,m,l){if(0===m.getCoordinateSystemType()&&t.throwInvalidArgumentException(""),e.isEmpty()||e.getDimension()<2)return 0;if(t.throwIfMesh(e),e.getGeometryType()===t.GeometryType.enumEnvelope){const t=new i.Polygon;return t.addEnvelope(e,!1),this.execute(t,m,l)}let p=e;e.getDescription().getAttributeCount()>1&&(p=e.clone(),p.dropAllAttributes());const g=(new n.OperatorDensify).execute(p,0,m.getTolerance(0),0,l);let P=null;const d=m.getGCS();d!==m&&(P=s.createEx(m,d));let E=(new s.OperatorSimplify).execute(g,m,!1,l);return E.isEmpty()?0:(E===e&&(E=e.clone()),m.isPannable()?function(e,t,n){const h=new r.Envelope2D;e.queryEnvelope(h);const m=_.calculateToleranceFromGeometryForOp(t,h,!0).total(),l=t.getPannableExtent();l.xmin=h.xmin-10*m,l.xmax=h.xmax+10*m;const p=(new o.OperatorClip).execute(e,l,t,n).getImpl().querySegmentIterator();p.stripAttributes();const c=s.makeSpheroidData();t.querySpheroidData(c);const g=c.e2,P=0===g?2:1,d=new a.Point2D(0,0),E=new a.Point2D(0,0),f=new a.KahanSummator(0),S=new u(d,E,t,g,100);for(;p.nextPath();)for(;p.hasNextSegment();){const e=p.nextSegment();d.assign(e.getStartXY()),E.assign(e.getEndXY()),S.setSegmentEndPoints(d,E);const t=i.integrateByRomberg(6,0,1,1e-12,1e-15,S.makeFunctor());f.pe((E.x-d.x)*t)}const y=c.majorSemiAxis;return P*y*y*(1-g)*Math.PI*f.getResult()/t.getPannableExtent().width()}(E,m,l):function(e,t,i,n,s){const r=function(e,t,i){const n=e.calculateLength2D(),s=(new h.OperatorShapePreservingLength).execute(e,t,i)/25e3,r=n/e.getSegmentCount()*2;let _=Math.min(r,n/s);return 0===_&&(_=1),a.makePair(_,n/_)}(e,t,s);let _=c(e,r.first,i,n,s),o=1,m=0,l=0;do{if(o++,r.first*=.5,r.first<50*t.getTolerance(0))return _;r.second*=2,l=c(e,r.first,i,n,s),m=Math.abs(l-_),_=l}while(Math.abs(_)>1&&m>1e-8*Math.abs(_)&&(r.second<65e3&&o<8||o<4));return l}(E,m,d,P,l))}}function E(){return{m_p_PCS:new a.Point2D,m_factor:Number.NaN,setValues:f,assign:S}}function f(e,t){this.m_factor=e,this.m_p_PCS.assign(t)}function S(e){this.m_factor=e.m_factor,this.m_p_PCS.assign(e.m_p_PCS)}class y{constructor(e,t,i,n){this.m_ptStart=new _.Point3D,this.m_ptEnd=new _.Point3D,this.m_ptStart.assign(t),this.m_ptEnd.assign(i),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const s=Math.sin(n);let r;r=0===this.m_e2?2*s:s*(a.atanhUOverU(this.m_e*s)+1/(1-this.m_e2*s*s)),this.m_baseA=r}setSegmentEndPoints(e,t){this.m_ptStart.assign(e),this.m_ptEnd.assign(t),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const t=1-e,i=t*this.m_ptStart.x+e*this.m_ptEnd.x,n=t*this.m_ptStart.y+e*this.m_ptEnd.y,s=t*this.m_ptStart.z+e*this.m_ptEnd.z,r=i*i+n*n,_=s/Math.sqrt(s*s+this.m_c1MinusE2*this.m_c1MinusE2*r);let o;return o=0===this.m_e2?2*_:_*(a.atanhUOverU(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*i-this.m_deltaX*n)/r*(o-this.m_baseA)}}}function A(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:T,changeSign:x,assign:R,clone:C}}function T(e,t,i,n){const s=.5*e;this.sin_phi=Math.sin(e);const a=t*this.sin_phi,r=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(s+i),this.sin_half_phi_pz=Math.sin(s+n),this.sin_half_asin_e_sin_phi_pf=Math.sin(r+i),this.sin_half_asin_e_sin_phi_pz=Math.sin(r+n),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function x(){this.sin_phi=-this.sin_phi;let e=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=e,e=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=e,e=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=e,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function R(e){this.sin_phi=e.sin_phi,this.one_p_sin_phi=e.one_p_sin_phi,this.one_m_sin_phi=e.one_m_sin_phi,this.one_m_e_2_sin_2_phi=e.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=e.sin_half_phi_pf,this.sin_half_phi_pz=e.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=e.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=e.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=e.atanh_sin_phi,this.atanh_esin_phi=e.atanh_esin_phi,this.make_negative=e.make_negative}function C(){return{...this}}class M{constructor(e,i,n){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new l.Transformation2D,this.m_scaleToDegrees=new l.Transformation2D,this.m_progressTracker=n,t.geometryReleaseAssert(4!==i),this.m_curveType=i,this.m_inputSR=e,e&&0!==e.getCoordinateSystemType()||t.throwInvalidArgumentException(""),this.m_inputGCS=e.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let t,i=e.clone();if(i.dropAllAttributes(),e.hasNonLinearSegments()&&(i=(new n.OperatorDensify).execute(i,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const e=new r.Envelope2D;i.queryEnvelope(e);const t=this.m_inputSR.getPannableExtent();if(!t.containsEnvelope(e)){const n=t.getCenterX()-e.getCenterX(),r=new l.Transformation2D;r.setShiftCoords(n,0),i.applyTransformation(r),e.move(n,0);const _=new a.Envelope1D;t.queryIntervalX(_);const o=new a.Envelope1D;e.queryIntervalX(o),i=_.contains(o)?s.clipGeometryFromTopAndBottom(i,this.m_inputSR):(new s.OperatorProject).foldInto360RangeGeodetic(i,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(i=(new s.OperatorSimplify).execute(i,this.m_inputSR,!1,this.m_progressTracker),t=i.createInstance(),s.projectMultiPathVerticesPCSToGCS(this.m_transformPCS2GCS,i,t,this.m_progressTracker)||(t=(new s.OperatorProject).execute(i,this.m_transformPCS2GCS,this.m_progressTracker))):t=(new s.OperatorSimplify).execute(i,this.m_inputGCS,!1,this.m_progressTracker),t.isEmpty())return 0;if(1===this.m_curveType){const e=s.makeSpheroidData();return this.m_inputGCS.querySpheroidData(e),this.m_a=e.majorSemiAxis,this.m_eSquared=e.e2,this.loxodromeArea(t)}const _=t.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),_.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const o=s.makeSpheroidData();if(this.m_inputGCS.querySpheroidData(o),this.m_a=o.majorSemiAxis,this.m_b=o.minorSemiAxis,this.m_eSquared=o.e2,2===this.m_curveType)return this.executeClippedPolygonGreatEllipticArea(t);{const e={stack:[],error:void 0,hasError:!1};try{const i=s.peFactory.unit(9101),n=this.m_inputGCS.getPECoordSys(),a=m.__addDisposableResource(e,n.cloneAlterUnits(i),!1);let r,_,o=this.executeClippedPolygonGeodeticArea(t,a,0),h=0;do{h++,r=this.executeClippedPolygonGeodeticArea(t,a,h),_=Math.abs(r-o),o=r}while(Math.abs(r)>1&&_>1e-8*Math.abs(r)&&h<7);return r}catch(t){e.error=t,e.hasError=!0}finally{m.__disposeResources(e)}}}executeClippedPolygonGeodeticArea(e,t,i){const n={stack:[],error:void 0,hasError:!1};try{const _=new r.Envelope2D;e.queryEnvelope(_);const o=m.__addDisposableResource(n,this.getEqualAreaPCSInstance(t,_),!1),h=e.clone();s.PEGeogToProjSimple(o,h);const l=50,p=h.getImpl().getAttributeStreamRef(0),u=e.getImpl().getAttributeStreamRef(0),c=m.__addDisposableResource(n,new s.PeDoubleClass,!1),g=m.__addDisposableResource(n,new s.PeDoubleClass,!1),P=40,d=[0,0],f=a.makeStructArray(E,P),S=a.makePrimitiveArray(P,-1),y=E(),A=E();let T,x;const R=o;let C=h.calculateArea2D();const M=new a.KahanSummator(0),D=.5*Math.PI,v=1e-10*Math.abs(C)+1e-6,w=e.getPathCount();let b,N,q,I;const O=new a.Point2D,L=new a.Point2D,z=new a.Point2D,G=new a.Point2D,k=new a.Point2D,F=new a.Point2D;let U,$;for(N=e.getPathStart(0),b=0;b<w;b++,N=q)for(q=e.getPathEnd(b),p.queryPoint2D(q-1<<1,z),u.queryPoint2D(q-1<<1,O),Math.abs(O.y)>D&&(O.y=a.copySign(D,O.y)),I=N;I<q;I++,z.assign(G),O.assign(L)){if(p.queryPoint2D(I<<1,G),u.queryPoint2D(I<<1,L),Math.abs(L.y)>D&&(L.y=a.copySign(D,L.y)),U=a.Point2D.distance(z,G),U<l||0===O.y&&0===L.y)continue;s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,O.x,O.y,L.x,L.y,c,g,null,this.m_curveType);const e=c.val,t=g.val;for(y.setValues(0,z),A.setValues(1,G),x=i,f[0].assign(A),S[0]=i,T=0;T>=0;){$=.5*(y.m_factor+A.m_factor),s.peLineType.geodeticCoordinate(this.m_a,this.m_eSquared,O.x,O.y,e*$,t,c,g,this.m_curveType),k.x=c.val,k.y=g.val,d[0]=k.x,d[1]=k.y,s.peCSTransformations.geogToProj(R,1,d),F.x=d[0],F.y=d[1];const i=.5*-F.offset(y.m_p_PCS,A.m_p_PCS)*a.Point2D.distance(y.m_p_PCS,A.m_p_PCS);if(M.pe(i),Math.abs(i)>v||Math.abs(i)>0&&x>0)A.setValues($,F),T++,f[T].assign(A),Math.abs(i)<=v?(x--,S[T-1]=x,S[T]=x):(x=S[T-1],S[T]=x);else{if(T<=0)break;y.assign(A),T--,A.assign(f[T]),x=S[T]}}}return C+=M.getResult(),Math.abs(C)}catch(e){n.error=e,n.hasError=!0}finally{m.__disposeResources(n)}}executeClippedPolygonGreatEllipticArea(e){const t=[],i=[],n=new a.Point2D,o=new a.Point2D,h=s.curvToCart(1,this.m_eSquared,new a.Point2D(0,.5*Math.PI)),m=new a.KahanSummator(0),l=new a.KahanSummator(0),p=new a.KahanSummator(0),u=new _.Point3D,c=new _.Point3D,g=new r.Envelope2D;e.queryLooseEnvelope(g);let P=0;g.containsCoords(g.xmin,0)||(P=Math.abs(g.ymin)<Math.abs(g.ymax)?g.ymin:g.ymax);const d=new y(this.m_eSquared,u,c,P),E=this.m_a*this.m_a,f=e.getImpl().querySegmentIterator();for(f.stripAttributes();f.nextPath();)for(;f.hasNextSegment();){const e=f.nextSegment();n.assign(e.getStartXY()),o.assign(e.getEndXY()),o.x-n.x>Math.PI?n.x+=2*Math.PI:o.x-n.x<-Math.PI&&(o.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(e,t,i);for(let e of t)u.assign(s.curvToCart(this.m_a,this.m_eSquared,e.getStartXY())),c.assign(s.curvToCart(this.m_a,this.m_eSquared,e.getEndXY())),d.setSegmentEndPoints(u,c),this.adaptiveIntegrationWithRomberg(d,m);for(let e of i){let t=e.getStartXY(),i=e.getEndXY(),n=P;t.y<0&&(i=a.swap(t,t=i),t.y=-t.y,i.y=-i.y,n=-n);const r=s.curvToCart(1,this.m_eSquared,t),o=s.curvToCart(1,this.m_eSquared,i),m=Math.min(t.y,i.y),u=s.areaBetweenParallelsAndMeridiansOfUnitSpheroid(this.m_eSquared,t.x,i.x,n,m);l.pe(u);const c=Math.abs(s.areaBetweenParallelsAndMeridiansOfUnitSpheroid(this.m_eSquared,t.x,i.x,m,a.geometryHalfPi)),g=new _.Point3D;g.setSub(r,h);const d=new _.Point3D;d.setSub(o,h);const f=new _.Point3D;f.setCrossProductVector(g,d);let S=E*(c-.5*f.length());S=a.copySign(S,i.x-t.x),p.pe(S)}t.length=0,i.length=0}return p.getResult()+E*(.5*(1-this.m_eSquared)*m.getResult()+l.getResult())}getEqualAreaPCSInstance(e,t){const i=t.getCenterX();let n,r;const _=t.height();let o,h;(o=t.ymin>45*Math.PI/180||t.ymax<45*-Math.PI/180)?n=a.copySign(.5*Math.PI,t.getCenterY()):(n=t.getCenterY(),r=t.ymin+_*(2/3));const m=s.getTempName("EqualAreaPCS"),l=e.toString();return h=o?s.peFactory.fromString(s.peDefs.PE_TYPE_PROJCS,`PROJCS["${m}", ${l}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${i}], PARAMETER["Latitude_of_Origin", ${n}], UNIT["Meter",1.0]]`):s.peFactory.fromString(s.peDefs.PE_TYPE_PROJCS,`PROJCS["${m}", ${l}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", 0],PARAMETER["False_Northing", 0],PARAMETER["Central_Meridian", ${i}],PARAMETER["Standard_Parallel_1", ${r}],PARAMETER["Latitude_of_Origin", ${n}],UNIT["Meter",1.0]]`),h}splitSegmentCrossingItegralThreshold(e,t,n){const r=100,o=400,h=s.curvToCart(this.m_a,this.m_eSquared,new a.Point2D(0,a.geometryHalfPi)),m=s.curvToCart(this.m_a,this.m_eSquared,new a.Point2D(0,-a.geometryHalfPi)),l=this.splitSegmentPassingThroughPole(e);for(let e of l){const l=e.getStartXY(),p=e.getEndXY(),u=s.curvToCart(this.m_a,this.m_eSquared,l),c=s.curvToCart(this.m_a,this.m_eSquared,p),g=new a.Point2D,P=new _.Point3D;let d=_.Point3D.sqrDistance(h,u),E=_.Point3D.sqrDistance(u,c);if(d<=r){if(!(E>o)){n.push(new i.Line({start:l,end:p}));continue}P.assign(c.sub(u)),P.normalizeThis(),P.assign(u.add(P.mul(20))),g.assign(s.cartToCurv(this.m_a,this.m_eSquared,P)),n.push(new i.Line({start:l,end:g})),l.assign(g)}if(u.assign(s.curvToCart(this.m_a,this.m_eSquared,l)),d=_.Point3D.sqrDistance(h,c),E=_.Point3D.sqrDistance(u,c),d<=r){if(!(E>o)){n.push(new i.Line({start:l,end:p}));continue}P.assign(c.sub(u)),P.normalizeThis(),P.assign(c.sub(P.mul(20))),g.assign(s.cartToCurv(this.m_a,this.m_eSquared,P)),n.push(new i.Line({start:g,end:p})),p.assign(g)}if(u.assign(s.curvToCart(this.m_a,this.m_eSquared,l)),c.assign(s.curvToCart(this.m_a,this.m_eSquared,p)),d=_.Point3D.sqrDistance(m,u),E=_.Point3D.sqrDistance(u,c),d<=r){if(!(E>o)){n.push(new i.Line({start:l,end:p}));continue}P.assign(c.sub(u)),P.normalizeThis(),P.assign(u.add(P.mul(20))),g.assign(s.cartToCurv(this.m_a,this.m_eSquared,P)),n.push(new i.Line({start:l,end:g})),l.assign(g)}if(u.assign(s.curvToCart(this.m_a,this.m_eSquared,l)),c.assign(s.curvToCart(this.m_a,this.m_eSquared,p)),d=_.Point3D.sqrDistance(m,c),E=_.Point3D.sqrDistance(u,c),d<=r){if(!(E>o)){n.push(new i.Line({start:l,end:p}));continue}P.assign(c.sub(u)),P.normalizeThis(),P.assign(c.sub(P.mul(20))),g.assign(s.cartToCurv(this.m_a,this.m_eSquared,P)),n.push(new i.Line({start:g,end:p})),p.assign(g)}t.push(new i.Line({start:l,end:p}))}}splitSegmentPassingThroughPole(e){const t={stack:[],error:void 0,hasError:!1};try{const n=[],r=new _.Point3D,o=new _.Point3D,h=new _.Point3D,l=new a.Point2D,u=20,c=3.124139361,g=10,P=e.getStartXY(),d=e.getEndXY(),E=m.__addDisposableResource(t,new s.PeDoubleClass,!1);if(s.peLineType.geodeticDistance(this.m_a,this.m_eSquared,P.x,P.y,d.x,d.y,E,null,null,2),Math.abs(d.x-P.x)>c&&E.val>u){const e=new p.GeodeticDistanceFunctor(new a.Point2D(0,90),P.divide(this.m_rpu),d.divide(this.m_rpu),this.m_inputGCS,2,2);let t=s.brentMinimization(e.makeFunctor(),0,1,1e-10);if(t.second<=g&&t.first>0&&t.first<1)return r.assign(s.curvToCart(this.m_a,this.m_eSquared,P)),o.assign(s.curvToCart(this.m_a,this.m_eSquared,d)),a.lerpPoint3D(r,o,t.first,h),l.assign(s.cartToCurv(this.m_a,this.m_eSquared,h)),n.push(new i.Line({start:P,end:l})),n.push(new i.Line({start:l,end:d})),n;if(e.setPointDistFrom(new a.Point2D(0,-90)),t=s.brentMinimization(e.makeFunctor(),0,1,1e-10),t.second<=g&&t.first>0&&t.first<1)return r.assign(s.curvToCart(this.m_a,this.m_eSquared,P)),o.assign(s.curvToCart(this.m_a,this.m_eSquared,d)),a.lerpPoint3D(r,o,t.first,h),l.assign(s.cartToCurv(this.m_a,this.m_eSquared,h)),n.push(new i.Line({start:P,end:l})),n.push(new i.Line({start:l,end:d})),n}return n.push(new i.Line({start:P,end:d})),n}catch(e){t.error=e,t.hasError=!0}finally{m.__disposeResources(t)}}adaptiveIntegrationWithRomberg(e,t){const n=e.makeFunctor();let s=0,a=1,r=n(s),_=n(a);const o=1e-17,h=1e-14;let m=(s+a)/2,l=n(m),p=Math.abs(l-r),u=Math.abs(_-l),c=0;for(;c++<32&&(p/u<.1||u/p<.1);)p<u?(t.pe(i.integrateByRomberg(5,s,m,h,o,n)),s=m,r=l):(t.pe(i.integrateByRomberg(5,m,a,h,o,n)),a=m,_=l),m=(s+a)/2,l=Math.abs(n(m)),p=Math.abs(l-r),u=Math.abs(_-l);t.pe(i.integrateByRomberg(5,s,a,h,o,n))}loxodromeAreaHemi(e,t,i,n,s){const r=i.clone(),_=s.clone();let o,h,m,l,p,u,c,g,P,d,E,f,S,y,A,T;return r.make_negative&&r.changeSign(),_.make_negative&&_.changeSign(),E=n-t,1===Math.abs(r.sin_phi)||1===Math.abs(_.sin_phi)?e.half_qp*E:r.sin_phi===_.sin_phi?(d=.5*e.one_m_e_2*r.sin_phi*(1/r.one_m_e_2_sin_2_phi+a.atanhUOverU(e.e*r.sin_phi))*E,d):(A=Math.log(_.sin_half_phi_pf*r.sin_half_phi_pz/(_.sin_half_phi_pz*r.sin_half_phi_pf)),T=Math.log(_.sin_half_asin_e_sin_phi_pf*r.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*r.sin_half_asin_e_sin_phi_pf)),1===this.m_eSquared?(p=0,o=.5*(A+_.sin_phi/_.one_m_e_2_sin_2_phi-r.sin_phi/r.one_m_e_2_sin_2_phi),h=0):(p=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/r.one_p_sin_phi)-e.e*T),o=(A-e.e*T)/e.one_m_e_2,h=(Math.log(_.one_m_e_2_sin_2_phi/r.one_m_e_2_sin_2_phi)+p/e.atanh_e_over_e)/e.one_m_e_2),m=-T*(r.atanh_esin_phi+_.atanh_esin_phi),l=1/r.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,u=a.dilogarithmEzOverE(_.one_m_sin_phi/e.one_p_e,e.e)-a.dilogarithmEzOverE(r.one_m_sin_phi/e.one_p_e,e.e),c=a.dilogarithmEzOverE(_.one_p_sin_phi/e.one_p_e,e.e)-a.dilogarithmEzOverE(r.one_p_sin_phi/e.one_p_e,e.e),g=a.dilogarithmEzOverE(r.one_m_sin_phi/-e.one_m_e,e.e)-a.dilogarithmEzOverE(_.one_m_sin_phi/-e.one_m_e,e.e),P=a.dilogarithmEzOverE(r.one_p_sin_phi/-e.one_m_e,e.e)-a.dilogarithmEzOverE(_.one_p_sin_phi/-e.one_m_e,e.e),d=.25/o*(h+m+l+p+.5*(u+c+g+P)),d+=e.half_qp,f=.5*e.one_m_e_2*r.sin_phi*(1/r.one_m_e_2_sin_2_phi+a.atanhUOverU(e.e*r.sin_phi)),S=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+a.atanhUOverU(e.e*_.sin_phi)),S<f&&(y=f,f=S,S=y),d<f&&(d=f),d>S&&(d=S),d*=E,d)}loxodromeArea(e){const t=Math.PI/180;let i=0;const n={e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN},s=A(),r=A();n.e=Math.sqrt(this.m_eSquared),n.one_p_e=1+n.e,n.one_m_e=1-n.e,n.one_m_e_2=1-this.m_eSquared,n.atanh_e_over_e=a.atanhUOverU(n.e),this.m_eSquared>=1?n.half_qp=1:n.half_qp=.5*(1+n.atanh_e_over_e*n.one_m_e_2),n.f=.25*Math.PI,n.z=.75*Math.PI,r.initialize(0,n.e,n.f,n.z);const _=e.getPathCount(),o=new a.Point2D,h=new a.Point2D,m=e.getImpl().getAttributeStreamRef(0);for(let a=0;a<_;a++){const _=e.getPathStart(a),l=e.getPathEnd(a);if(!(l-_<=1)){m.queryPoint2D(2*(l-1),o);for(let e=_;e<l;e++){m.queryPoint2D(2*e,h);const a=o.y*t,l=h.y*t;if(e===_?(s.initialize(a,n.e,n.f,n.z),s.make_negative=!1):s.assign(r),r.initialize(l,n.e,n.f,n.z),r.make_negative=!1,o.y*h.y<0){if(o.y>=90&&h.y<=-90||h.y>=90&&o.y<=-90)return Number.NaN;const e=A();e.initialize(0,n.e,n.f,n.z),e.make_negative=!1;const _=s.atanh_sin_phi-n.e*s.atanh_esin_phi,m=r.atanh_sin_phi-n.e*r.atanh_esin_phi,l=(m*o.x-_*h.x)/(m-_);a<0?(s.make_negative=!0,i-=this.loxodromeAreaHemi(n,o.x*t,s,l*t,e),s.make_negative=!1,i+=this.loxodromeAreaHemi(n,l*t,e,h.x*t,r)):(i+=this.loxodromeAreaHemi(n,o.x*t,s,l*t,e),r.make_negative=!0,i-=this.loxodromeAreaHemi(n,l*t,e,h.x*t,r),r.make_negative=!1)}else o.y>=0?i+=this.loxodromeAreaHemi(n,o.x*t,s,h.x*t,r):(s.make_negative=!0,r.make_negative=!0,i-=this.loxodromeAreaHemi(n,o.x*t,s,h.x*t,r),s.make_negative=!1,r.make_negative=!1);o.assign(h)}}}return this.m_a*i*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===t.GeometryType.enumEnvelope){const t=new i.Polygon;return t.addEnvelope(e,!1),this.calculate(t)}return this.m_inputSR!==this.m_inputGCS&&null===this.m_transformPCS2GCS&&(this.m_transformPCS2GCS=s.createEx(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}e.OperatorGeodeticArea=class{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,t,i){return!1}canAccelerateGeometry(e){return!1}execute(e,i,n,s){return t.throwIfMesh(e),4===n?(new d).execute(e,i,s):new M(i,n,s).calculate(e)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});