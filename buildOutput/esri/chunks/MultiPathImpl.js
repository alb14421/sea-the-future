// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./Geometry","./Envelope","./Point2D","./Envelope2D","./Transformation2D","./SimpleGeometryCursor"],function(t,e,s,n,i,r,o){"use strict";class a{constructor(){this.posStream=null,this.streams=null}get(t){return t>0?this.streams[t-1]:this.posStream}set(t,e){t>0?this.streams[t-1]=e:this.posStream=e}destroyAndSetSize(t){if(this.streams=null,t>1){this.streams=new Array(t-1);for(let e=0;e<t-1;++e)this.streams[e]=null}this.posStream=null}swap(t){[this.streams,t.streams]=[t.streams,this.streams],[this.posStream,t.posStream]=[t.posStream,this.posStream]}empty(){return null===this.posStream&&null===this.streams}}function m(t,e){let s=n.nextRand(t);const i=e.length/n.intMax();for(let t=0;t<e.length;++t){const t=Math.trunc(s*i);s=n.nextRand(s);const r=Math.trunc(s*i),o=e[t];e[t]=e[r],e[r]=o}}function h(t,e,s){if(!(s<=e))for(;e<s;)t[s]=n.swap(t[e],t[e]=t[s]),e++,s--}var u=s.VertexDescription;const l="can not assign an empty point to a vertex";class c{constructor(t){if(this.m_accelerators=null,void 0!==t&&t.move)this.m_description=t.move.m_description,t.move.m_description=s.getDefaultDescription2D(),this.m_vertexAttributes=t.move.m_vertexAttributes,t.move.m_vertexAttributes=new a,this.m_envelopeData=t.move.m_envelopeData,t.move.m_envelopeData=new s.EnvelopeData,this.m_pointCount=t.move.m_pointCount,this.m_reservedPointCount=t.move.m_reservedPointCount,this.m_flags=t.move.m_flags,this.m_bFillRule=t.move.m_bFillRule,this.m_bPathStarted=t.move.m_bPathStarted,this.m_bPolygon=t.move.m_bPolygon,this.m_simpleTolerance=t.move.m_simpleTolerance;else{const e=void 0!==t&&t.vd?t.vd:s.getDefaultDescription2D();this.m_description=e,this.m_vertexAttributes=new a,this.m_envelopeData=new s.EnvelopeData,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,void 0!==t&&t.copy&&t.copy.copyTo(this)}}equalsBase(t,s){if(!e.isMultiVertex(t.getGeometryType()))return!1;const n=t;if(this===n)return!0;if(!this.m_description.equals(n.getDescription()))return!1;if(this.isEmptyImpl()!==n.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const i=this.getPointCount();if(i!==n.getPointCount())return!1;for(let t=0;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),r=this.getAttributeStreamRef(e),o=n.getAttributeStreamRef(e),a=u.getComponentCount(e);if(!r.equals(o,0,i*a,s))return!1}if(s){if(!this.equalsImplTol(t,s))return!1}else if(!this.equalsImpl(t))return!1;return!0}transformAttribute(t,n,i,o,a){if(this.addAttribute(t),!this.isEmpty()&&(0!==i||1!==o)){if(0===t){const t=new r.Transformation2D;return 0===a?0===n?(t.setShiftCoords(i,0),t.scale(o,1)):1===n?(t.setShiftCoords(0,i),t.scale(1,o)):e.throwInvalidArgumentException(""):0===n?(t.setScaleCoords(1/o,1),t.shiftCoords(-i,0)):1===n?(t.setScaleCoords(1,1/o),t.shiftCoords(0,-i)):e.throwInvalidArgumentException(""),void this.applyTransformation(t)}!function(t,s,n,i,r){(s<0||n<0||i<1||s+i*(n-1)+1>t.size())&&e.throwInvalidArgumentException("Index out of bound");for(let e=s,o=s+i*(n-1)+1;e<o;e+=i)t.writeAsDbl(e,r(t.readAsDbl(e)))}(this.getAttributeStreamRef(t),n,this.getPointCount(),u.getComponentCount(t),s.applyShiftAndScale(i,o,a)),this.notifyModified()}}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescriptionImpl(t){const e=this.getDescription(),n=s.getMergedVertexDescription(e,t);this.assignVertexDescription(n)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=s.getMergedVertexDescriptionSemantics(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=s.removeSemanticsFromVertexDescription(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=s.getDefaultDescription2D();t!==this.m_description&&this.assignVertexDescription(t)}getAttributeStreamRef(t){this.throwIfEmpty(),this.m_description.hasAttribute(t)||e.throwInvalidArgumentException("AttributeStream : Geometry does not have the attribute");const s=this.m_description.getAttributeIndex(t);return this.m_vertexAttributes.get(s)}setAttributeStreamRef(t,s){s||e.throwInvalidArgumentException("stream"),s&&u.getPersistence(t)!==s.getPersistence()&&e.throwInvalidArgumentException(""),this.addAttribute(t);const n=this.m_description.getAttributeIndex(t);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(n,s),this.notifyModifiedFlags(2001)}notifyModifiedFlags(t){65535===t&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(t,!0),this.clearAccelerators(),32&t&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(t,e){const s=e;s.assignVertexDescription(this.m_description);for(let e=0;e<this.m_description.getAttributeCount();e++){const n=this.m_description.getSemantics(e);for(let i=0,r=u.getComponentCount(n);i<r;i++){const o=this.m_vertexAttributes.get(e).readAsDbl(r*t+i);s.setAttributeBasic(n,i,o)}}}setPointByValNoCurves(t,s){const n=s;n.isEmpty()&&e.throwInvalidArgumentException(l);const i=n.getDescription();i!==this.m_description&&this.mergeVertexDescription(i);const r=this.m_vertexAttributes.get(0);r.write(2*t,n.getX()),r.write(2*t+1,n.getY());for(let e=1,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),i=u.getComponentCount(s);for(let r=0;r<i;r++){const o=n.getAttributeAsDbl(s,r);this.m_vertexAttributes.get(e).writeAsDbl(t*i+r,o)}}this.notifyModifiedFlags(2001)}setPointByValFromArrayNoCurves(t,s,n,i){e.geometryReleaseAssert(0)}getPointByValAsArray(t,s,n,i){e.geometryReleaseAssert(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return 0===this.m_pointCount}getAttributeAsDbl(t,s,n){const i=u.getComponentCount(t);n>=i&&e.throwOutOfRangeException("");const r=this.m_description.getAttributeIndex(t);return r>=0?this.m_vertexAttributes.get(r).readAsDbl(s*i+n):u.getDefaultValue(t)}queryAttributeAsDbl(t,s,n,i){const r=u.getComponentCount(t);i<r&&e.throwOutOfRangeException("");const o=this.m_description.getAttributeIndex(t);if(o>=0){const t=s*r,e=this.m_vertexAttributes.get(o);for(let s=0;s<r;s++)n[s]=e.readAsDbl(t+s)}else{const e=u.getDefaultValue(t);for(let t=0;t<r;t++)n[t]=e}}getAttributeAsInt(t,e,s){return Math.trunc(this.getAttributeAsDbl(t,e,s))}queryAttributeAsInt(t,s,n,i){e.geometryReleaseAssert(0)}setAttributeNoCurves(t,s,n,i){const r=u.getComponentCount(t);n>=r&&e.throwOutOfRangeException(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(o).writeAsDbl(s*r+n,i)}setAttributeFromArrayNoCurves(t,s,n,i){(s<0||s>=this.m_pointCount)&&e.throwOutOfRangeException("");const r=u.getComponentCount(t);i<r&&e.throwOutOfRangeException(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001);const a=this.m_vertexAttributes.get(o);for(let t=0;t<r;++t)a.writeAsDbl(s*r+t,n[t])}getXY(t){return this.m_vertexAttributes.get(0).readPoint2D(2*t)}queryXY(t,e){return this.m_vertexAttributes.get(0).queryPoint2D(2*t,e)}setXYNoCurves(t,e){this.m_vertexAttributes.get(0).writePoint2D(2*t,e),this.notifyModifiedFlags(2001)}setXYCoordsNoCurves(t,e,s){const n=this.m_vertexAttributes.get(0);n.write(2*t,e),n.write(2*t+1,s),this.notifyModifiedFlags(2001)}getXYZ(t){const e=this.m_vertexAttributes.get(0),n=s.Point3D.getNAN();return n.x=e.read(2*t),n.y=e.read(2*t+1),this.m_description.hasAttribute(1)?n.z=this.m_vertexAttributes.get(1).read(t):n.z=u.getDefaultValue(1),n}setXYZNoCurves(t,e){this.addAttribute(1),this.notifyModifiedFlags(2001);const s=this.m_vertexAttributes.get(0);s.write(2*t,e.x),s.write(2*t+1,e.y),this.m_vertexAttributes.get(1).write(t,e.z)}queryEnvelope(t){t instanceof i.Envelope2D||t instanceof s.Envelope3D?this.updateEnvelope(t):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t))}queryLooseEnvelope(t){this.updateLooseEnvelope(t)}queryInterval(t,e){const s=n.Envelope1D.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,t,e,s)),s}setAttributeBasic(t,e,s){this.setAttributeImpl(t,e,s)}setAttributeImpl(t,e,s){if(this.addAttribute(t),this.isEmpty())return;let n=!1;const i=u.getComponentCount(t),r=this.getAttributeStreamRef(t),o=Number.isNaN(s);if(1===r.getPersistence()){const t=r;for(let r=e,a=this.m_pointCount*i;r<a;r+=i){const e=t.read(r);(o||e===s)&&Number.isNaN(e)||(t.write(r,s),n=!0)}}else for(let t=e,o=this.m_pointCount*i;t<o;t+=i)r.readAsDbl(t)!==s&&(r.writeAsDbl(t,s),n=!0);n&&this.notifyModifiedFlags(2001)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;let s=!1;const n=u.getComponentCount(t),i=this.getAttributeStreamRef(t);for(let t=0;t<n;t++)if(1===i.getPersistence()){const t=i;for(let i=0,r=this.m_pointCount*n;i<r;i++){const n=t.read(i);Number.isNaN(n)&&(t.write(i,e),s=!0)}}else for(let t=0,r=this.m_pointCount*n;t<r;t++){const n=i.readAsDbl(t);Number.isNaN(n)&&(i.writeAsDbl(t,e),s=!0)}s&&this.notifyModifiedFlags(2001)}calculateLength3D(t){return e.geometryReleaseAssert(0),0}setEnvelopeForImport(t){this.m_description.equals(t.getDescription())||e.throwInvalidArgumentException(""),this.m_envelopeData=new s.EnvelopeData({moveEnv:t}),this.setDirtyFlagProtected(192,!1)}copyTo(t){t.getGeometryType()!==this.getGeometryType()&&e.throwInvalidArgumentException(""),this!==t&&this.copyToUnchecked(t,!1)}queryCoordinates(t,s,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+s),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&e.throwInvalidArgumentException(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);for(let e=2*n,s=2*r,i=0;e<s;e+=2,i++)o.queryPoint2D(e,t[i]);return r}queryCoordinates3D(t,s,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+s),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&e.throwInvalidArgumentException(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const m=u.getDefaultValue(1),h=this.m_description.hasAttribute(1);h&&(a=this.getAttributeStreamRef(1));let l=0;for(let e=n;e<r;e++,l++)t[l].x=o.read(2*e),t[l].y=o.read(2*e+1),t[l].z=h?a.read(e):m;return r}clearAndSetDirtyFlagProtected(t,e){let s=0;const n=t&~e,i=e|n;s=this.m_flags,(s&i)!==e&&(this.m_flags=s&~n|e)}getIsSimple(t,e){e[0]=0;let s=-1;const n=this.m_flags,i=this.m_simpleTolerance;return 1&n||(s=(14&n)>>1,e[0]=i,i<t&&(s=-1)),s}setIsSimple(t,s,n=!1){if(2===t?e.geometryReleaseAssert(this.getGeometryType()===e.GeometryType.enumPolyline):1===t?e.geometryReleaseAssert(this.getGeometryType()===e.GeometryType.enumMultiPoint||this.getGeometryType()===e.GeometryType.enumPolyline):3===t&&e.geometryReleaseAssert(this.getGeometryType()===e.GeometryType.enumPolygon),-1===t)this.setDirtyFlagProtected(17,!0);else{let e=t<<1;n||(e|=16);const i=31;this.clearAndSetDirtyFlagProtected(i,e),this.m_simpleTolerance!==s&&(this.m_simpleTolerance=s)}}attributeStreamIsAllocated(t){this.throwIfEmpty();const e=this.m_description.getAttributeIndex(t);return e>=0&&null!==this.m_vertexAttributes.get(e)}capacity(){return-1===this.m_reservedPointCount&&0===this.m_pointCount?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(t,s=!1){s&&this.hasDirtyFlag(32)&&e.throwLogicErrorException("Cannot do shallow clone on unprepared geometry");const n=t,i=this.getGeometryType(),r=n.getGeometryType();e.geometryReleaseAssert(i===r||i===e.GeometryType.enumPolygon&&r===e.GeometryType.enumPolyline,"failure in copyToUnchcked"),n.clearAccelerators(),n.m_description=this.m_description,n.m_vertexAttributes.destroyAndSetSize(0),n.m_envelopeData.releaseAttributes();const o=this.m_description.getAttributeCount(),m=new a;if(!this.m_vertexAttributes.empty()){m.destroyAndSetSize(o);for(let t=0;t<o;t++)if(this.m_vertexAttributes.get(t))if(s)m.set(t,this.m_vertexAttributes.get(t));else{const e=u.getComponentCount(this.m_description.getSemantics(t));m.set(t,this.m_vertexAttributes.get(t).restrictedClone(this.getPointCount()*e))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,n.m_envelopeData),n.m_flags=this.m_flags,n.m_simpleTolerance=this.m_simpleTolerance,i!==r){const t=[Number.NaN];n.getIsSimple(0,t)>=3?n.setIsSimple(1,t[0]):n.setIsSimple(-1,0)}n.m_vertexAttributes.swap(m),m.destroyAndSetSize(0),n.m_pointCount=this.m_pointCount,n.hasDirtyFlag(32)||n.m_vertexAttributes.empty()?(e.geometryReleaseAssert(!s||0===n.m_pointCount),n.m_reservedPointCount=-1):n.m_reservedPointCount=n.m_pointCount;try{this.copyToImpl(n,s)}catch(t){throw n.setEmpty(),t}n.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(t,e){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const t=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=t}}interpolateTwoVertices(t,i,r,o){(t<0||t>=this.m_pointCount)&&e.throwOutOfRangeException(""),(i<0||i>=this.m_pointCount)&&e.throwOutOfRangeException(""),o.assignVertexDescription(this.m_description);const a=n.makePrimitiveArray(u.maxComponentCount(),Number.NaN),m=n.makePrimitiveArray(u.maxComponentCount(),Number.NaN),h=s.newOrdinateBuffer();let l=0;for(let o=0;o<this.m_description.getAttributeCount();o++){const c=this.m_description.getSemantics(o),g=u.getInterpolation(c),d=u.getComponentCount(c),p=u.getDefaultValue(c);this.queryAttributeAsDbl(c,t,a,d),this.queryAttributeAsDbl(c,i,m,d),e.geometryReleaseAssert(l+d<=s.OrdinateBufferLength),n.interpolateArray(g,a,m,h,l,d,r,p),l+=d}!function(t,e){const s=t.getDescription().getTotalComponentCount();t.setX(e[0]),t.setY(e[1]),n.memcpy(t.getAttributeArray(),e,0,2,s-2)}(o,h)}getShortestDistance(t,e){return n.Point2D.distance(this.getXY(t),this.getXY(e))}getShortestSqrDistance(t,e){return n.Point2D.sqrDistance(this.getXY(t),this.getXY(e))}resizeImpl(t){if(t<0&&e.throwInvalidArgumentException(),(t=Math.ceil(t))===this.m_pointCount)return;this.m_pointCount=t;const s=this.m_pointCount<=this.m_reservedPointCount?2001:4095;this.notifyModifiedFlags(s)}assignVertexDescriptionImpl(t){if(!this.m_vertexAttributes.empty()){const e=s.createAttributeMap();s.mapAttributes(t,this.m_description,e);const n=new a;n.destroyAndSetSize(t.getAttributeCount());for(let s=0;s<t.getAttributeCount();s++){const t=e[s];-1!==t?n.set(s,this.m_vertexAttributes.get(t)):this.m_reservedPointCount=-1}n.swap(this.m_vertexAttributes)}this.m_description=t,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(t){return 0!==(this.m_flags&t)}setDirtyFlagProtected(t,e){e?this.m_flags|=t:this.m_flags&=~t}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=-1;let t=Number.MAX_SAFE_INTEGER,e=0;e=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:Math.trunc((4*this.m_pointCount+2)/3);for(let n=0;n<this.m_description.getAttributeCount();n++){const i=this.m_description.getSemantics(n);let r=0;if(null!==this.m_vertexAttributes.get(n)){const t=u.getComponentCount(i);r=this.m_vertexAttributes.get(n).size()/t,r<this.m_pointCount&&(this.m_vertexAttributes.get(n).resize(e*t,u.getDefaultValue(i)),r=e)}else this.m_vertexAttributes.set(n,s.createAttributeStreamFromSemantics(i,e)),r=e;r<t&&(t=r)}this.m_reservedPointCount=t}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(t){if(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const e=this.updateXYImpl(t),i=new s.Envelope({vd:this.m_description});i.setEnvelope(e);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),s=u.getComponentCount(e),r=this.m_vertexAttributes.get(t);for(let t=0;t<s;t++){const o=new n.Envelope1D;o.setEmpty();for(let e=0;e<this.m_pointCount;e++){const n=r.readAsDbl(e*s+t);o.mergeCoordinate(n)}i.setIntervalEnvelope(e,t,o)}}(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128))&&(this.m_envelopeData=new s.EnvelopeData({moveEnv:i}),this.clearDirtyIntervalsFlag(t))}}updateXYImpl(t){const e=i.Envelope2D.constructEmpty(),s=this.m_vertexAttributes.get(0);return e.mergePointsInterleaved(s,0,this.m_pointCount),e}updateEnvelope3D(t){e.geometryReleaseAssert(0)}updateLooseEnvelope(t){this.updateAllDirtyIntervals(!1),t instanceof i.Envelope2D?t.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,t)}updateEnvelope(t){this.updateAllDirtyIntervals(!0),t.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(t){this.setDirtyFlagProtected(192,!1)}reserveImpl(t,n){if(t<0&&e.throwInvalidArgumentException(""),0===t)return;let i=t=Math.ceil(t);if(this.m_reservedPointCount<i){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),n?(null===this.m_vertexAttributes.get(0)&&this.m_vertexAttributes.set(0,s.createAttributeStreamUninitialized(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*i),i=this.m_vertexAttributes.get(0).size()>>1):null===this.m_vertexAttributes.get(0)?this.m_vertexAttributes.set(0,s.createAttributeStreamUninitialized(0,i)):this.m_vertexAttributes.get(0).resize(2*i);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),n=u.getComponentCount(e);null!==this.m_vertexAttributes.get(t)?this.m_vertexAttributes.get(t).resize(i*n):this.m_vertexAttributes.set(t,s.createAttributeStreamUninitialized(e,i))}this.reserveImplImpl(i,n),this.m_reservedPointCount=i}}reserveRounded(t){t<0&&e.throwInvalidArgumentException(),t=Math.ceil(t),this.reserveImpl(t,!0)}reserveImplImpl(t,e){}throwIfEmpty(){this.isEmptyImpl()&&e.throwEmptyGeometryException("")}}class g extends c{constructor(t){super(t),t&&(t.points?this.addPoints2D(t.points,t.pointsSize,0,-1):t.point&&this.add(t.point))}assignCopy(t){return t.copyTo(this),this}assignMove(t){return t.copyTo(this),t.setEmpty(),this}insertPoint2D(t,n){t>this.getPointCount()&&e.throwInvalidArgumentException("invalid point index"),t<0&&(t=this.getPointCount());const i=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let e=0,r=this.m_description.getAttributeCount();e<r;e++){const r=this.m_description.getSemantics(e),o=s.VertexDescription.getComponentCount(r);if(0===r)this.m_vertexAttributes.get(e).insert(o*t,n,o*i);else{const n=s.VertexDescription.getDefaultValue(r);this.m_vertexAttributes.get(e).insertRange(o*t,n,o,o*i)}}this.notifyModifiedFlags(2001)}insertPoint(t,n){n.isEmpty()&&e.throwInvalidArgumentException(l),t<0&&(t=this.getPointCount()),this.mergeVertexDescription(n.getDescription());const i=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let e=0,r=this.m_description.getAttributeCount();e<r;e++){const r=this.m_description.getSemantics(e),o=s.VertexDescription.getComponentCount(r);if(n.hasAttribute(r))this.m_vertexAttributes.get(e).insertAttributes(o*t,n,r,o*i);else{const n=s.VertexDescription.getDefaultValue(r);this.m_vertexAttributes.get(e).insertRange(o*t,n,o,o*i)}}this.notifyModifiedFlags(2001)}insertPoints(t,n,i){if((t>this.getPointCount()||i<0)&&e.throwOutOfRangeException(""),t<0&&(t=this.getPointCount()),0===i)return;const r=n[0].getDescription();this.mergeVertexDescription(r);const o=this.m_pointCount;this.resizeNoInit(this.m_pointCount+i);for(let e=0,a=this.m_description.getAttributeCount();e<a;e++){const a=this.m_description.getSemantics(e),m=s.VertexDescription.getComponentCount(a);if(this.m_vertexAttributes.get(e))if(r.hasAttribute(a))this.m_vertexAttributes.get(e).insertAttributesFromPoints(t*m,n,i,a,o*m);else{const n=s.VertexDescription.getDefaultValue(a);this.m_vertexAttributes.get(e).insertRange(m*t,n,m*i,m*o)}}this.notifyModifiedFlags(2001)}insertPoints2D(t,n,i){if((t>this.getPointCount()||i<0)&&e.throwInvalidArgumentException("invalid point index"),t<0&&(t=this.getPointCount()),0===i)return;const r=this.m_pointCount;this.resizeNoInit(this.m_pointCount+i);for(let e=0,o=this.m_description.getAttributeCount();e<o;e++){const o=this.m_description.getSemantics(e),a=s.VertexDescription.getComponentCount(o);if(this.m_vertexAttributes.get(e))if(0===o)this.m_vertexAttributes.get(e).insertRangeFromPoints(a*t,n,0,i,!0,a*r);else{const n=s.VertexDescription.getDefaultValue(o);this.m_vertexAttributes.get(e).insertRange(a*t,n,a,a*r)}}this.notifyModifiedFlags(2001)}removePoints(t,n){if((t<0||n<0||t+n>this.getPointCount())&&e.throwOutOfRangeException("remove_points"),0!==n){for(let e=0,i=this.m_description.getAttributeCount();e<i;e++)if(this.m_vertexAttributes.get(e)){const i=this.m_description.getSemantics(e),r=s.VertexDescription.getComponentCount(i);this.m_vertexAttributes.get(e).eraseRange(r*t,r*n,r*this.m_pointCount)}this.m_pointCount-=n,this.m_reservedPointCount>0&&(this.m_reservedPointCount-=n),this.notifyModifiedFlags(2001)}}removePoint(t){for(let e=0,n=this.m_description.getAttributeCount();e<n;e++)if(this.m_vertexAttributes.get(e)){const n=this.m_description.getSemantics(e),i=s.VertexDescription.getComponentCount(n);this.m_vertexAttributes.get(e).eraseRange(i*t,i,i*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return this.updateXYImpl(!0)}resizeNoInit(t){this.resizeImpl(t)}resizeAndInitNonPositionAttributes(t){const e=this.m_pointCount;if(this.resizeImpl(t),this.m_pointCount>e)for(let t=1,n=this.m_description.getAttributeCount();t<n;t++){const n=this.m_description.getSemantics(t),i=s.VertexDescription.getDefaultValue(n),r=s.VertexDescription.getComponentCount(n);this.m_vertexAttributes.get(t).insertRange(r*e,i,r*(this.m_pointCount-e),r*e)}}queryCoordinates3D(t,n,i,r){let o=r<0?this.m_pointCount:r;if(o=Math.min(o,i+n),(i<0||o<i||this.m_pointCount>0&&i>=this.m_pointCount)&&e.throwInvalidArgumentException(""),0===this.m_pointCount)return o;const a=this.getAttributeStreamRef(0);let m=null;const h=s.VertexDescription.getDefaultValue(1),u=this.m_description.hasAttribute(1);u&&(m=this.getAttributeStreamRef(1));let l=0;for(let e=i;e<o;e++,l++)t[l].x=a.read(2*e),t[l].y=a.read(2*e+1),t[l].z=u?m.read(e):h;return o}queryAttributeAsInt(t,s,n,i){e.geometryReleaseAssert(0)}add(t){t.isEmpty()&&e.throwInvalidArgumentException(l),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByValNoCurves(this.m_pointCount-1,t)}addXY(t,e){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const s=new n.Point2D(t,e);this.setXYNoCurves(this.m_pointCount-1,s)}addXYZ(t,e,n){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const i=new s.Point3D;i.setCoords(t,e,n),this.setXYZNoCurves(this.m_pointCount-1,i)}addPoint2D(t){this.addXY(t.x,t.y)}addPoint3D(t){this.addXYZ(t.x,t.y,t.z)}addPoints(t,n,i){this===t&&e.throwInvalidArgumentException("Multi_point_impl.add");const r=i<0?t.getPointCount():i;if((n<0||n>t.getPointCount()||r<n)&&e.throwInvalidArgumentException(""),n===r)return;const o=t.getDescription();this.mergeVertexDescription(o);const a=r-n,m=this.m_pointCount;this.resizeNoInit(this.m_pointCount+a);for(let e=0,i=this.m_description.getAttributeCount();e<i;e++){const i=this.m_description.getSemantics(e),r=s.VertexDescription.getComponentCount(i),h=this.getAttributeStreamRef(i);if(o.hasAttribute(i)){const e=t.getAttributeStreamRef(i);h.insertRangeFromStream(m*r,e,n*r,a*r,!0,1,m*r)}else{const t=s.VertexDescription.getDefaultValue(i);h.insertRange(m*r,t,a*r,m*r)}}}addPoints2D(t,s,n,i){let r=s;const o=i<0?r:i;if((r<0||n<0||n>r||o<n)&&e.throwInvalidArgumentException(""),n===o)return;r=o-n;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const m=this.getAttributeStreamRef(0);for(let e=0;e<r;++e)m.writePoint2D(2*(a+e),t[n+e]);this.notifyModifiedFlags(2001)}addPoints3D(t,s,i,r){let o=s;const a=r<0?o:r;if((o<0||i<0||i>o||a<i)&&e.throwInvalidArgumentException(""),this.addAttribute(1),i===a)return;o=a-i;const m=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+o);const h=this.getAttributeStreamRef(0),u=new n.Point2D;for(let e=0;e<o;e++)u.x=t[i+e].x,u.y=t[i+e].y,h.writePoint2D(2*(m+e),u);const l=this.getAttributeStreamRef(1);for(let e=0;e<o;e++)l.write(m+e,t[i+e].z);this.notifyModifiedFlags(2001)}setPointByVal(t,e){this.setPointByValNoCurves(t,e)}setXY(t,e){this.setXYNoCurves(t,e)}setXYCoords(t,e,s){this.setXYCoordsNoCurves(t,e,s)}setXYZ(t,e){this.setXYZNoCurves(t,e)}setAttribute(t,e,s,n){this.setAttributeNoCurves(t,e,s,n)}getGeometryType(){return e.GeometryType.enumMultiPoint}getDimension(){return 0}createInstance(){return new g({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(t){if(this.isEmpty())return;if(t.isIdentity())return;const s=this.m_vertexAttributes.get(0);1===t.m_TransformationType?s.applyTransformation(t,0,this.m_pointCount):e.throwNotImplementedException("3d xform not impl"),this.notifyModifiedFlags(2001)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,s){return t.getGeometryType()===e.GeometryType.enumMultiPoint&&this.equalsBase(t,s)}queryEnvelope(t){4===t.m_EnvelopeType?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t)):2===t.m_EnvelopeType?this.updateEnvelope(t):e.throwNotImplementedException("")}getImpl(){return this}getBoundary(){return null}reserve(t){this.reserveImpl(t)}clone(){const t=this.createInstance();return this.copyTo(t),t}swap(t){e.geometryReleaseAssert(0)}buildQuadTreeAccelerator(t){return!1}getHashCodeImpl(){return e.geometryReleaseAssert(0),0}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}copyToImpl(t,e){}}g.type=e.GeometryType.enumMultiPoint;class d{constructor(){this.m_EnvelopeType=5,this.envAabb=i.Envelope2D.constructEmpty(),this.envRot=i.Envelope2D.constructEmpty()}static constructEmpty(){return new d}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(t){this.envAabb.setCoords(t),this.envRot.setCoords({x:p(t),y:_(t)})}setFromPoints(t,e){this.setEmpty(),this.mergePoints(t,e)}mergeNe(t){this.envAabb.mergeNe(t),this.envRot.mergeNeCoords(p(t),_(t))}mergePoints(t,e){this.envAabb.mergePoints(t,e);for(let s=0;s<e;){if(!this.envRot.isEmpty()){for(let n=s;n<e;n++){const e=p(t[n]),s=_(t[n]);this.envRot.mergeNeCoords(e,s)}break}{const e=p(t[s]),n=_(t[s]);this.envRot.setCoords({x:e,y:n}),s++}}}isIntersectingPoint2D(t){return!(!this.envAabb.contains(t)||!this.envRot.containsCoords(p(t),_(t)))}isIntersectingW(t){return this.envAabb.isIntersecting(t.envAabb)&&this.envRot.isIntersecting(t.envRot)}containsW(t){return!(!this.envAabb.containsEnvelope(t.envAabb)||!this.envRot.containsEnvelope(t.envRot))}containsPoint2D(t){return this.isIntersectingPoint2D(t)}intersectW(t){const e=this.envAabb.intersect(t.envAabb),s=this.envRot.intersect(t.envRot);return e&&!s&&this.envAabb.setEmpty(),s&&!e&&this.envRot.setEmpty(),e&&s}inflate(t){this.envAabb.inflateCoords(t,t);const e=t*n.sqrt2();this.envRot.inflateCoords(e,e),e<0&&d.st_reduceEmpty(this)}static st_reduceEmpty(t){const e=t.envAabb.isEmpty(),s=t.envRot.isEmpty();e&&!s?t.envRot.setEmpty():s&&!e&&t.envAabb.setEmpty()}sqrMaxMinDistance(t){const e=this.envAabb.sqrMaxMinDistance(t),s=this.envRot.sqrMaxMinDistance(P(t))/2;return Math.max(e,s)}sqrMinDistance(t){const e=this.envAabb.sqrMinDistance(t),s=this.envRot.sqrMinDistance(P(t))/2;return Math.max(e,s)}sqrMaxDistance(t){const e=this.envAabb.sqrMaxDistance(t),s=this.envRot.sqrMaxDistance(P(t))/2;return Math.max(e,s)}getEnvelope2D(){return this.envAabb}getRotatedEnvelope2D(){return this.envRot}xyRot(t,e){const s=t.x-t.y,n=(i=t.x,r=t.y,i+r);var i,r;e.setCoords(s,n)}}function p(t){return t.x-t.y}function _(t){return t.x+t.y}function P(t){return new n.Point2D(p(t),_(t))}class f{constructor(){this.x=n.ECoordinate.getNAN(),this.y=n.ECoordinate.getNAN()}static getNAN(){return new f}static constructPoint2D(t){const e=new f;return e.x.set(t.x),e.y.set(t.y),e}static constructCoords(t,e){const s=new f;return s.x.set(t),s.y.set(e),s}static constructCoordsE(t,e){const s=new f;return s.setCoordsE(t,e),s}get 0(){return this.x.clone()}set 0(t){this.x.setE(t)}get 1(){return this.y.clone()}set 1(t){this.y.setE(t)}clone(){return(new f).setE(this)}scaleThis(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}setCoords(t,e){return this.x.set(t),this.y.set(e),this}setCoordsE(t,e){return this.x.setE(t),this.y.setE(e),this}set(t){return this.x.set(t.x),this.y.set(t.y),this}setE(t){return this.x.setE(t.x),this.y.setE(t.y),this}setWithEps(t,e){return this.x.setWithEps(t.x,e),this.y.setWithEps(t.y,e),this}getUnitVector(){const t=this.clone();return t.normalize(),t}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(t){const e=new f;return e.setCoordsE(this.x.mulE(t),this.y.mulE(t)),e}mul(t){const e=new f;return e.setCoordsE(this.x.mul(t),this.y.mul(t)),e}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mulThisE(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}divE(t){return this.clone().divThisE(t)}divThisE(t){return this.x.divThisE(t),this.y.divThisE(t),this}normalize(){const t=this.length();0===t.value()?(this.x=n.s_one.clone(),this.y=n.s_zero.clone()):(this.x.divThisE(t),this.y.divThisE(t))}addE(t){return this.clone().addThisE(t)}addThisE(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this}subE(t){return this.clone().subThisE(t)}subThisE(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this}static distance(t,e){return t.subE(e).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(t,e){const s=this.x.mulE(t).subThisE(this.y.mulE(e)),n=this.x.mulE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}rotateReverse(t,e){const s=this.x.mulE(t).addThisE(this.y.mulE(e)),n=this.x.negate().mulThisE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y))}crossProduct(t){return this.x.mulE(t.y).subE(this.y.mulE(t.x))}value(){return n.Point2D.construct(this.x.value(),this.y.value())}}class y{constructor(){this.a11=new n.ECoordinate(1),this.a12=new n.ECoordinate(0),this.a21=new n.ECoordinate(0),this.a22=new n.ECoordinate(1)}clone(){const t=new y;return t.a11.setE(this.a11),t.a12.setE(this.a12),t.a21.setE(this.a21),t.a22.setE(this.a22),t}assign(t){return this.a11.setE(t.a11),this.a12.setE(t.a12),this.a21.setE(t.a21),this.a22.setE(t.a22),this}mulThis(t){const e=this.a11.mulE(t.a11).addThisE(this.a12.mulE(t.a21)),s=this.a11.mulE(t.a12).addThisE(this.a12.mulE(t.a22)),n=this.a21.mulE(t.a11).addThisE(this.a22.mulE(t.a21)),i=this.a21.mulE(t.a12).addThisE(this.a22.mulE(t.a22));return this.a11=e,this.a12=s,this.a21=n,this.a22=i,this}mulLeftThis(t){const e=t.clone();return this.assign(e.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const t=this.det();if(0!==t.value()){const e=this.a22.divE(t),s=this.a12.negate().divThisE(t),n=this.a21.negate().divThisE(t),i=this.a11.divE(t);this.a11=e,this.a12=s,this.a21=n,this.a22=i}else this.setZero();return!t.isZero()}transposeThis(){return this.a21=n.swap(this.a12,this.a12=this.a21),this}eigenSymmetric(t,e){const s=this.a12.clone();s.addThisE(this.a21),s.mulThisByPower2(.5);let i=new n.ECoordinate(1),r=new n.ECoordinate(0);if(s.isZero())t[0].setE(this.a11),t[1].setE(this.a22);else{const e=new n.ECoordinate(1);if(this.a11.ne(this.a22)){const o=this.a11.subE(this.a22).divE(s);o.mulThisByPower2(.5);const a=o.sqr();e.setE(o),e.absThis(),e.subThisE(a.add(1).sqrtThis()),o.gt(n.s_zero)&&e.negateThis();const m=e.sqr().addThis(1).sqrtThis().invThis();r=e.mulE(m),i.setE(m);const h=e.mulE(s);t[0]=this.a11.addE(h),t[1]=this.a22.subE(h)}else i=new n.ECoordinate(1/Math.sqrt(2)),r=i.clone(),t[0]=this.a11.addE(s),t[1]=this.a22.subE(s)}e[0].x=i.toDouble(),e[0].y=r.toDouble(),e[1].x=r.negate().toDouble(),e[1].y=i.toDouble(),Math.abs(t[0].toDouble())>Math.abs(t[1].toDouble())&&(t[1]=n.swap(t[0],t[0]=t[1]),e[1]=n.swap(e[0],e[0]=e[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}class x{static constructPoint2D(t){return new x(n.MPValue.constructDouble(t.x),n.MPValue.constructDouble(t.y))}constructor(t,e){if(void 0===t)return this.x=(new n.MPValue).setNAN(),void(this.y=(new n.MPValue).setNAN());this.x=t.clone(),this.y=e.clone()}assignPoint2D(t){return this.x.setDouble(t.x),this.y.setDouble(t.y),this}setCoords(t,e){return this.x.setThis(t),this.y.setThis(e),this}asPoint2D(){return new n.Point2D(this.x.value(),this.y.value())}crossProduct(t){return this.x.mul(t.y).sub(this.y.mul(t.x))}leftPerpendicularThis(){const t=this.x.clone();this.x=this.y.clone().negate(),this.y=t}clone(){return new x(this.x,this.y)}dotProduct(t){return this.x.mul(t.x).add(this.y.mul(t.y))}add(t){return new x(this.x.add(t.x),this.y.add(t.y))}sub(t){return new x(this.x.sub(t.x),this.y.sub(t.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mul(t){return this.clone().mulThis(t)}subThis(t){return this.x.subThis(t.x),this.y.subThis(t.y),this}addThis(t){return this.x.addThis(t.x),this.y.addThis(t.y),this}}var D=s.VertexDescription;function v(t){let e=!1;for(let s=0;s<2;s++){const i=n.compareNoNANs(t[0][s],t[3][s]);i>0?(n.compareNoNANs(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),n.compareNoNANs(t[1][s],t[3][s])<0&&(t[1][s]=t[3][s],e=!0),n.compareNoNANs(t[0][s],t[2][s])<0&&(t[2][s]=t[0][s],e=!0),n.compareNoNANs(t[2][s],t[3][s])<0&&(t[2][s]=t[3][s],e=!0),n.compareNoNANs(t[1][s],t[2][s])<0&&(t[2][s]=t[1][s],e=!0)):i<0?(n.compareNoNANs(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),n.compareNoNANs(t[1][s],t[3][s])>0&&(t[1][s]=t[3][s],e=!0),n.compareNoNANs(t[0][s],t[2][s])>0&&(t[2][s]=t[0][s],e=!0),n.compareNoNANs(t[2][s],t[3][s])>0&&(t[2][s]=t[3][s],e=!0),n.compareNoNANs(t[1][s],t[2][s])>0&&(t[2][s]=t[1][s],e=!0)):t[1][s]===t[0][s]&&t[2][s]===t[0][s]||(t[1][s]=t[0][s],t[2][s]=t[0][s],e=!0)}return e}function E(t,e){const s=t.getStartXY();if(s.equals(e.getStartXY()))return!0;if(s.equals(e.getEndXY()))return!0;const n=t.getEndXY();return!!n.equals(e.getStartXY())||!!n.equals(e.getEndXY())}function C(t,e){let s=t.calculateLowerLength2D();return!(s>e)&&(!!t.isLine()||(s=t.calculateUpperLength2D(),s<=e||0!==e&&t.calculateLength2D()<=e))}function b(t,s,i,r,o,a,m,h){let u=t.calculateUpperLength2D(),l=s.calculateUpperLength2D(),c=t,g=s,d=!1;u>l&&(g=n.swap(c,c=g),r=n.swap(i,i=r),l=n.swap(u,u=l),d=!0);const p=0===i;{m[0]=p?1:0;const t=c.getCoord2D(m[0]);h[0]=g.getClosestCoordinate(t,!1);const e=g.getCoord2D(h[0]);if(n.Point2D.distance(t,e)<=o){const e=[.5,.75,.25,.1,.9];let s=!0;for(let i=0;i<e.length;i++)if(t.assign(c.getCoord2D(e[i])),!g.isCloserThanDistance(t,new n.Envelope1D(0,1),o)){s=!1;break}if(s)return d&&(h[0]=n.swap(m[0],m[0]=h[0])),1}}if(u<=3*o)return 0;let _=n.snap(Math.max(o/u,.1),0,.5),P=.01*o,f=0,y=0,x=_,D=-1,v=0,E=1/32;for(let t=0;;t++){e.geometryReleaseAssert(t<4095);const s=p?_:1-_,i=c.getCoord2D(s),u=g.getClosestCoordinate(i,!1);if(u===r)return v;const l=g.getCoord2D(u),C=n.Point2D.distance(i,l);if(0===t&&(D=C),C<=P?(E=.5,y=C,f=_):(x=_,D=C),Math.abs(y-D)>.1*P&&x-f>1e-16)_=n.lerp(f,x,E);else{if(m[v]=s,h[v]=u,d&&(h[v]=n.swap(m[v],m[v]=h[v])),1===a||1===v)return 1===v&&m[0]>m[1]&&(m[1]=n.swap(m[0],m[0]=m[1]),h[1]=n.swap(h[0],h[0]=h[1])),v+1;v++,f=x,y=D,x=.8,D=-1,_=.8,E=1/32,P=10*o,t=0}}}function A(t,e,s,i,r,o,a,m,h){if(n.isOneOf(s,0,1)&&n.isOneOf(i,0,1)&&0===n.Point2D.distance(t.getCoord2D(s),e.getCoord2D(i))){const h=1e-12,u=new f,l=n.doubleEps();if(t.queryDerivative(new n.ECoordinate(s,l),u),u.isTrueZero()){const e=1===s?-1e-12:h;t.queryDerivative(new n.ECoordinate(s,l).add(e),u)}1===s&&u.negateThis();const c=new f;if(e.queryDerivative(new n.ECoordinate(i,l),c),c.isTrueZero()){const t=1===s?-1e-12:h;e.queryDerivative(new n.ECoordinate(i,l).add(t),c)}1===i&&c.negateThis(),u.isZero()||u.normalize(),c.isZero()||c.normalize();const g=u.dotProduct(c),d=u.crossProduct(c);d.scaleError(3);const p=()=>{{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*r/Math.min(s,n),1e-10)}};if(g.ge(n.s_zero)&&(d.isZero()||Math.abs(d.value())<p()))return b(t,e,s,i,r,o,a,m)}return 0}function w(t,e){t.m_XStart=e.x,t.m_YStart=e.y}function S(t,e,s){t.m_XStart=e,t.m_YStart=s}function T(t,e){t.m_XEnd=e.x,t.m_YEnd=e.y}function I(t,e,s){t.m_XEnd=e,t.m_YEnd=s}function M(t,e){const n=new s.Point3D;return e?(n.x=t.m_XEnd,n.y=t.m_YEnd):(n.x=t.m_XStart,n.y=t.m_YStart),n.z=function(t,e){return t.m_description.hasZ()?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)]:D.getDefaultValue(1)}(t,e),n}function N(t,e,s){t.m_description.hasZ()||t.addAttribute(1),e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified()),t.m_attributes[(t.m_description.getTotalComponentCount()-2)*e]=s.z}function q(t,e,s){s.assignVertexDescription(t.m_description);const n=0===e?t.m_XStart:t.m_XEnd,i=0===e?t.m_YStart:t.m_YEnd;s.setXYCoords(n,i);for(let n=1;n<t.m_description.getAttributeCount();n++){const i=t.m_description.getSemantics(n);for(let n=0,r=D.getComponentCount(i);n<r;n++){const r=X(t,e,i,n);s.setAttributeBasic(i,n,r)}}}function Y(t,s,n){n.isEmpty()&&e.throwEmptyGeometryException(""),function(t,e,s){e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified())}(t,s,n.getXY());const i=n.getDescription();i!==t.m_description&&t.mergeVertexDescription(i);for(let e=1,r=i.getAttributeCount();e<r;e++){const r=i.getSemantics(e),o=D.getComponentCount(r);for(let e=0;e<o;e++)R(t,s,r,e,n.getAttributeAsDbl(r,e))}}function X(t,s,n,i){if((s<0||s>1)&&e.throwOutOfRangeException(""),0===n)return(i<0||i>=2)&&e.throwOutOfRangeException(""),0===s?0===i?t.m_XStart:t.m_YStart:0===i?t.m_XEnd:t.m_YEnd;const r=D.getComponentCount(n);(i<0||i>=r)&&e.throwOutOfRangeException("");const o=t.m_description.getAttributeIndex(n);return o>=0?t.m_attributes[s*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(o)-2+i]:D.getDefaultValue(n)}function R(t,s,n,i,r){if((s<0||s>1)&&e.throwOutOfRangeException(""),0===n)return 0===s?0===i?t.m_XStart=r:1===i?t.m_YStart=r:e.throwOutOfRangeException(""):1===s?0===i?t.m_XEnd=r:1===i?t.m_YEnd=r:e.throwOutOfRangeException(""):e.throwOutOfRangeException(""),void t.endPointModified();const o=D.getComponentCount(n);(i<0||i>=o)&&e.throwOutOfRangeException("");let a=t.m_description.getAttributeIndex(n);a<0&&(t.addAttribute(n),a=t.m_description.getAttributeIndex(n)),t.m_attributes[s*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(a)-2+i]=r}function F(t,s){if(t===s)return;s.isEmpty()&&e.throwEmptyGeometryException("");const n=s.getDescription();n!==t.m_description&&t.mergeVertexDescription(n);for(let e=1,i=n.getAttributeCount();e<i;e++){const i=n.getSemantics(e),r=D.getComponentCount(i);for(let e=0;e<r;e++){let n=X(s,0,i,e);R(t,0,i,e,n),n=X(s,1,i,e),R(t,1,i,e,n)}}}function V(t){return t.absNorm()*n.geomEpsFactor()}function k(t,e){return Math.max(t.absNorm(),e.absNorm())*n.geomEpsFactor()}function L(t,e,s){const i=new d;t.queryEnvelopeW(n.Envelope1D.unit(),i);const r=new d;return e.queryEnvelopeW(n.Envelope1D.unit(),r),r.inflate(s),!i.isIntersectingW(r)}function z(t,e,s){const i=n.cloneObjectArray(t,s),r=n.cloneObjectArray(e,s);i.sort((t,e)=>t.compare(e)),r.sort((t,e)=>t.compare(e));for(let t=0;t<3;t++){if(i[t].compare(r[t])<0)return-1;if(0!==i[t].compare(r[t]))return 1}return 0}var G=s.VertexDescription;class O{constructor(t){if(t.copy)this.m_XStart=t.copy.m_XStart,this.m_YStart=t.copy.m_YStart,this.m_XEnd=t.copy.m_XEnd,this.m_YEnd=t.copy.m_YEnd,this.m_description=t.copy.m_description,this.m_attributes=null,this.m_description&&this.m_description.getTotalComponentCount()-2&&(this.m_attributes=t.copy.m_attributes.slice());else{if(t.move)return this.m_description=t.move.m_description,t.move.m_description=null,this.m_attributes=t.move.m_attributes,t.move.m_attributes=null,this.m_XStart=t.move.m_XStart,this.m_YStart=t.move.m_YStart,this.m_XEnd=t.move.m_XEnd,void(this.m_YEnd=t.move.m_YEnd);if(void 0!==t.XStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_attributes=null,this.m_description=t.vd?t.vd:s.getDefaultDescription2D(),void(t.vd&&this.setDefaultAttributeValues());if(void 0!==t.ZStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_description=t.vd?t.vd:s.getDefaultDescription3D(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.ZEnd):this.m_attributes=[t.ZStart,t.ZEnd]);if(t.start)return this.m_XStart=t.start.x,this.m_YStart=t.start.y,this.m_XEnd=t.end.x,this.m_YEnd=t.end.y,this.m_attributes=null,void(this.m_description=s.getDefaultDescription2D());if(t.start3D)return this.m_XStart=t.start3D.x,this.m_YStart=t.start3D.y,this.m_XEnd=t.end3D.x,this.m_YEnd=t.end3D.y,this.m_description=t.vd?t.vd:s.getDefaultDescription3D(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.end3D.z):this.m_attributes=[t.start3D.z,t.end3D.z]);e.throwInternalErrorException("bad constructor params"),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(null===this.m_attributes&&(this.m_attributes=n.makePrimitiveArray(2*t,Number.NaN)),n.memcpy(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,t),n.memcpy(this.m_attributes,this.m_description.getDefaultPointAttributes(),t,2,t))}absNormXYZ(t){return e.throwNotImplementedException("not implemented"),0}queryWeights(t){}snapControlPoints3D(){return e.throwNotImplementedException("not implemented"),!1}setCoordsForIntersector3D(t,s,n){e.throwNotImplementedException("not implemented")}transformAttribute(t,s,n,i,r){e.throwNotImplementedException("")}mergeVertexDescriptionImpl(t){const e=this.getDescription(),n=s.getMergedVertexDescription(e,t);this.assignVertexDescription(n)}changeEndPoints(t,e){const s=t.getXY(),n=e.getXY();this.changeEndPoints2D(s,n);let i=t.getDescription();i!==this.getDescription()&&this.mergeVertexDescription(i),i=e.getDescription(),i!==this.getDescription()&&this.mergeVertexDescription(i);for(let s=1,n=i.getAttributeCount();s<n;s++){const n=i.getSemantics(s),r=G.getComponentCount(n);for(let s=0;s<r;s++)R(this,0,n,s,t.getAttributeAsDbl(n,s)),R(this,1,n,s,e.getAttributeAsDbl(n,s))}}getStartXY(){return new n.Point2D(this.m_XStart,this.m_YStart)}setStartXY(t){this.m_XStart=t.x,this.m_YStart=t.y,this.endPointModified()}setStartXYCoords(t,e){this.m_XStart=t,this.m_YStart=e,this.endPointModified()}getStartXYZ(){return M(this,0)}setStartXYZ(t){N(this,0,t)}setStartXYZCoords(t,e,n){N(this,0,s.Point3D.construct(t,e,n))}queryStart(t){q(this,0,t)}setStart(t){Y(this,0,t)}setStart2D(t){this.setStartXY(t)}getStartAttributeAsDbl(t,e){return X(this,0,t,e)}getStartAttributeAsInt(t,s){return e.geometryReleaseAssert(0),0}setStartAttribute(t,e,s){R(this,0,t,e,s)}setStartAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=G.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setStartAttribute(e,s,n)}}}setEndAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=G.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setEndAttribute(e,s,n)}}}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return e.geometryReleaseAssert(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return e.geometryReleaseAssert(0),0}getEndXY(){return new n.Point2D(this.m_XEnd,this.m_YEnd)}setEndXY(t){this.m_XEnd=t.x,this.m_YEnd=t.y,this.endPointModified()}setEndXYCoords(t,e){this.m_XEnd=t,this.m_YEnd=e,this.endPointModified()}getEndXYZ(){return M(this,1)}setEndXYZ(t){N(this,1,t)}setEndXYZCoords(t,e,n){N(this,1,s.Point3D.construct(t,e,n))}queryEnd(t){q(this,1,t)}setEnd(t){Y(this,1,t)}setEnd2D(t){this.setEndXY(t)}getEndAttributeAsDbl(t,e){return X(this,1,t,e)}getEndAttributeAsInt(t,s){return e.geometryReleaseAssert(0),Math.trunc(0)}setEndAttribute(t,e,s){R(this,1,t,e,s)}getDimension(){return 1}copyTo(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&e.throwInvalidArgumentException("");const s=t;s.assignVertexDescription(this.m_description),s.m_attributes&&n.memcpy(s.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),s.m_XStart=this.m_XStart,s.m_YStart=this.m_YStart,s.m_XEnd=this.m_XEnd,s.m_YEnd=this.m_YEnd,this.copyToImpl(s)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(t,e){const s=n.Envelope1D.constructEmpty();return s.vmin=X(this,0,t,e),s.vmax=s.vmin,s.mergeNeCoordinate(X(this,1,t,e)),s}calculateLength3D(t){return e.geometryReleaseAssert(0),0}getCoord3D(t){return e.geometryReleaseAssert(0),{}}getCoord2D(t){const e=n.Point2D.getNAN();return this.queryCoord2D(t,e),e}queryCoord3D(t,s){e.geometryReleaseAssert(0)}getCoordZ(t){return e.geometryReleaseAssert(0),0}queryCoord(t,e){e.assignVertexDescription(this.m_description),e.setXY(this.getCoord2D(t));for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),i=G.getComponentCount(n);for(let s=0;s<i;s++){const i=this.getAttributeAsDbl(t,n,s);e.setAttributeBasic(n,s,i)}}}isCloserThanDistance(t,e,s){const r=i.Envelope2D.constructEmpty();if(this.queryLooseEnvelopeOnInterval(e,r),r.distance(t)>s)return!1;const o=this.getClosestCoordinateOnInterval(t,e,s);return!Number.isNaN(o)&&n.Point2D.distance(t,this.getCoord2D(o))<=s}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const t=this.clone();return t.reverse(),t}reverse(){this.m_XEnd=n.swap(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=n.swap(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t);for(let t=0,s=G.getComponentCount(e);t<s;t++){const s=X(this,0,e,t);R(this,0,e,t,X(this,1,e,t)),R(this,1,e,t,s)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(t,s,i,r){if(!s&&this.isIntersecting(t,0,!1)){if(null!==i||null!==r){const s=n.makePrimitiveArray(9,Number.NaN),o=n.makePrimitiveArray(9,Number.NaN),a=this.intersect(t,null,s,o,0);e.geometryReleaseAssert(a<=9),0===a&&e.throwInternalErrorException(""),null!==i&&(i[0]=s[0]),null!==r&&(r[0]=o[0])}return 0}let o,a=Number.MAX_VALUE,m=-1,h=a;return o=this.getStartXY(),m=t.getClosestCoordinate(o,!1),o.subThis(t.getCoord2D(m)),h=o.length(),h<a&&(a=h,null!==r&&(r[0]=m),null!==i&&(i[0]=0)),o=this.getEndXY(),m=t.getClosestCoordinate(o,!1),o.subThis(t.getCoord2D(m)),h=o.length(),h<a&&(a=h,null!==r&&(r[0]=m),null!==i&&(i[0]=1)),o=t.getStartXY(),m=this.getClosestCoordinate(o,!1),o.subThis(this.getCoord2D(m)),h=o.length(),h<a&&(a=h,null!==i&&(i[0]=m),null!==r&&(r[0]=0)),o=t.getEndXY(),m=this.getClosestCoordinate(o,!1),o.subThis(this.getCoord2D(m)),h=o.length(),h<a&&(a=h,null!==i&&(i[0]=m),null!==r&&(r[0]=1)),a}calculateSubLengthFromStart(t){return this.tToLength(t)}calculateSubLength(t,e){return e===t?0:this.tToLength(e)-this.tToLength(t)}static recalculateParentT(t,e,s){return n.lerp(t,e,s)}moveTo(t){const e=this.isClosed(),s=new r.Transformation2D;s.setShift(t.sub(this.getStartXY())),this.applyTransformation(s),e?this.changeEndPoints2D(t,t):this.changeEndPoints2D(t,this.getEndXY())}moveTo3D(t){e.geometryReleaseAssert(0)}getDescription(){return this.m_description}assignVertexDescription(t){!function(t,e){const i=s.createAttributeMap();s.mapAttributes(e,t.m_description,i);let r=null;const o=e.getTotalComponentCount()-2,a=t.m_description?t.m_description.getTotalComponentCount()-2:0;if(o>0&&(r=n.makePrimitiveArray(2*o,Number.NaN),n.memcpy(r,e.getDefaultPointAttributes(),0,2,o),n.memcpy(r,e.getDefaultPointAttributes(),o,2,o),null!==t.m_description))for(let s=1;s<e.getAttributeCount();s++){const n=i[s];if(-1!==n){const i=t.m_description.getPointAttributeOffset(n)-2,m=e.getPointAttributeOffset(s)-2,h=D.getComponentCount(e.getSemantics(s));for(let e=0;e<h;++e)r[m]=t.m_attributes[i],r[o+m]=t.m_attributes[a+i]}}t.m_attributes=r,t.m_description=e}(this,t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=s.getMergedVertexDescriptionSemantics(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=s.removeSemanticsFromVertexDescription(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=s.getDefaultDescription2D();t!==this.m_description&&this.assignVertexDescription(t)}swap(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&e.throwInvalidArgumentException("wrong geometry type");const s=t;s.m_description=n.swap(this.m_description,this.m_description=s.m_description),s.m_XStart=n.swap(this.m_XStart,this.m_XStart=s.m_XStart),s.m_YStart=n.swap(this.m_YStart,this.m_YStart=s.m_YStart),s.m_XEnd=n.swap(this.m_XEnd,this.m_XEnd=s.m_XEnd),s.m_YEnd=n.swap(this.m_YEnd,this.m_YEnd=s.m_YEnd),s.m_attributes=n.swap(this.m_attributes,this.m_attributes=s.m_attributes),this.swapImpl(s)}equals(t,e){if(this.getGeometryType()!==t.getGeometryType())return!1;const s=void 0===e;s&&(e=0);const i=t;if(this===i)return!0;if(this.m_description!==i.m_description)return!1;if(Math.abs(this.m_XStart-i.m_XStart)>e||Math.abs(this.m_XEnd-i.m_XEnd)>e||Math.abs(this.m_YStart-i.m_YStart)>e||Math.abs(this.m_YEnd-i.m_YEnd)>e)return!1;for(let t=0,s=2*(this.m_description.getTotalComponentCount()-2);t<s;t++)if(!n.isEqualNonIEEETol(this.m_attributes[t],i.m_attributes[t],e))return!1;return s?this.equalsImpl(i):this.equalsImplTol(i,e)}getImpl(){return this}setAttributeBasic(t,s,n){if(this.addAttribute(t),0===t&&this.isCurve()){(s<0||s>1)&&e.throwInvalidArgumentException("");const t=new r.Transformation2D,i=0===s?n:0,o=1===s?n:0;t.setShiftCoords(i,o),0===s?t.xx=0:t.yy=0,this.applyTransformation(t)}else this.setStartAttribute(t,s,n),this.setEndAttribute(t,s,n)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;const s=G.getComponentCount(t);for(let n=0;n<s;n++){const s=this.getStartAttributeAsDbl(t,n);Number.isNaN(s)&&this.setStartAttribute(t,n,e);const i=this.getEndAttributeAsDbl(t,n);Number.isNaN(i)&&this.setEndAttribute(t,n,e)}}}O.s_maxMonotonicPartParams=8;class j extends o.GeometryCursor{constructor(t,e){super(),this.m_index=-1,this.gc=t,this.dim=e}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount())return null;if(this.m_index++,this.m_index===this.gc.getGeometryCount())return null;const t=this.gc.getGeometry(this.m_index);if(-1===this.dim||1<<t.getDimension()&this.dim)return t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class B{constructor(t){this.m_geoms=[],this.m_description=s.getDefaultDescription2D(),t&&(t.vd?this.m_description=t.vd:t.copy?t.copy.copyTo(this):e.throwInvalidArgumentException("constructor argument not recognized"))}getGeometryCount(){return this.m_geoms.length}reserve(t){}addGeometry(t){if(t.getGeometryType()===e.GeometryType.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else this.m_geoms.push(t.clone()),this.mergeVertexDescription(t.getDescription())}addCursor(t){for(let e=t.next();null!==e;e=t.next())this.addGeometry(e)}getGeometry(t){return(t<0||t>=this.m_geoms.length)&&e.throwInvalidArgumentException("Geometry_collection.get_geometry"),this.m_geoms[t]}modifiedElementIndex(t){this.mergeVertexDescription(this.getGeometry(t).getDescription())}modifiedElement(t){this.mergeVertexDescription(t.getDescription())}getGeometryType(){return e.GeometryType.enumGeometryCollection}getDimension(){let t=0;for(const e of this.m_geoms)t=Math.max(t,e.getDimension());return t}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}assignVertexDescriptionImpl(t){for(const e of this.m_geoms)e.assignVertexDescription(t);this.m_description=t}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=s.getMergedVertexDescriptionSemantics(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=s.removeSemanticsFromVertexDescription(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=s.getDefaultDescription2D();t!==this.m_description&&this.assignVertexDescription(t)}queryInterval(t,e){let s=new n.Envelope1D;const i=new n.Envelope1D;i.setEmpty();for(const n of this.m_geoms)s=n.queryInterval(t,e),i.merge(s);return i}queryEnvelope(t){if(4===t.m_EnvelopeType){const e=new s.Envelope;t.setEmpty(),t.assignVertexDescription(this.m_description);for(const s of this.m_geoms)s.queryEnvelope(e),t.merge(e)}else if(2===t.m_EnvelopeType){const e=new i.Envelope2D;t.setEmpty();for(const s of this.m_geoms)s.queryEnvelope(e),t.mergeEnvelope2D(e)}e.throwNotImplementedException("3d envelope case not implemented")}queryLooseEnvelope(t){if(2===t.m_EnvelopeType){const e=new i.Envelope2D;t.setEmpty();for(const s of this.m_geoms)s.queryLooseEnvelope(e),t.mergeEnvelope2D(e)}e.throwNotImplementedException("3d not impl")}isEmpty(){return 0===this.m_geoms.length}setEmpty(){this.m_geoms.length=0}applyTransformation(t){if(1===t.m_TransformationType)for(const e of this.m_geoms)e.applyTransformation(t);e.throwNotImplementedException("3d xform not impl")}transformAttribute(t,e,s,n,i){for(const r of this.m_geoms)r.transformAttribute(t,e,s,n,i)}createInstance(){return new B({vd:this.getDescription()})}copyTo(t){t.getGeometryType()!==e.GeometryType.enumGeometryCollection&&e.throwInvalidArgumentException("");const s=t;if(s!==this){s.m_geoms.length=0,s.assignVertexDescription(this.m_description);for(const t of this.m_geoms)s.m_geoms.push(t.clone())}}calculateArea2D(){const t=new n.KahanSummator(0);for(const e of this.m_geoms)t.pe(e.calculateArea2D());return t.getResult()}calculateLength2D(){const t=new n.KahanSummator(0);for(const e of this.m_geoms)t.pe(e.calculateLength2D());return t.getResult()}calculateLength3D(t){return e.geometryReleaseAssert(0),0}getBoundary(){const t=this.createInstance(),e=t;for(const t of this.m_geoms){const s=t.getBoundary();s&&e.m_geoms.push(s)}return t}clone(){return new B({copy:this})}equals(t,s){if(t===this)return!0;if(t.getGeometryType()!==e.GeometryType.enumGeometryCollection)return!1;const n=t;if(this.m_description!==n.m_description)return!1;if(this.m_geoms.length!==n.m_geoms.length)return!1;for(let t=0;t<this.m_geoms.length;++t)if(!this.m_geoms[t].equals(n.m_geoms[t],s))return!1;return!0}swap(t){t.getGeometryType()!==e.GeometryType.enumGeometryCollection&&e.throwInvalidArgumentException("");const s=t;s!==this&&(this.m_geoms=n.swap(s.m_geoms,s.m_geoms=this.m_geoms))}setAttributeBasic(t,e,s){for(const n of this.m_geoms)n.setAttributeBasic(t,e,s)}replaceNaNs(t,e){for(const s of this.m_geoms)s.replaceNaNs(t,e)}getImpl(){return this}mergeVertexDescriptionImpl(t){const e=this.getDescription(),n=s.getMergedVertexDescription(e,t);this.assignVertexDescription(n)}}B.type=e.GeometryType.enumGeometryCollection;class W extends O{constructor(t){super(t)}}class H extends W{isTrue3D(){return!0}constructor(t){super(t)}}function Z(t,e,s){U(e,t.getStartXY(),t.getEndXY(),s)}function U(t,e,s,i){n.lerpPoint2D(e,s,t,i)}function Q(t,e){return n.lerp(t.m_XStart,t.m_XEnd,e)}function $(t,e){return n.lerp(t.m_YStart,t.m_YEnd,e)}function K(t,e,s){e.value()<=.5?n.lerpLoPointE(2,f.constructPoint2D(t.getStartXY()),f.constructPoint2D(t.getEndXY()),e,s):n.lerpHiPointE(2,f.constructPoint2D(t.getStartXY()),f.constructPoint2D(t.getEndXY()),e,s)}function J(t,e,s){t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,t.afterCompletedModification()}function tt(t){if(t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart){t.m_XEnd=n.swap(t.m_XStart,t.m_XStart=t.m_XEnd),t.m_YEnd=n.swap(t.m_YStart,t.m_YStart=t.m_YEnd);for(let e=0,s=t.m_description.getTotalComponentCount()-2;e<s;e++)t.m_attributes[e+s]=n.swap(t.m_attributes[e],t.m_attributes[e]=t.m_attributes[e+s])}}function et(t,e,s,n){let i=0;if((t.m_XStart===e.m_XStart&&t.m_YStart===e.m_YStart||t.m_XStart===e.m_XEnd&&t.m_YStart===e.m_YEnd)&&(i++,!n))return 1;if(t.m_XEnd===e.m_XStart&&t.m_YEnd===e.m_YStart||t.m_XEnd===e.m_XEnd&&t.m_YEnd===e.m_YEnd){if(i++,2===i)return 2;if(!n)return 1}return e.isIntersectingPoint(t.getStartXY(),s,!0)||e.isIntersectingPoint(t.getEndXY(),s,!0)||t.isIntersectingPoint(e.getStartXY(),s,!0)||t.isIntersectingPoint(e.getEndXY(),s,!0)?4:n&&i?0:function(t,e){const s=it(t,e.m_XStart,e.m_YStart),n=it(t,e.m_XEnd,e.m_YEnd);if(s<0&&n<0||s>0&&n>0)return!1;const i=it(e,t.m_XStart,t.m_YStart),r=it(e,t.m_XEnd,t.m_YEnd);return!(i<0&&r<0||i>0&&r>0)&&(at(t)>at(e)?ot(t,e):ot(e,t))}(t,e)?4:0}function st(t,e,s,i,r,o,a,m){null!==i&&n.initializePrimitiveArray(i,2,Number.NaN),null!==r&&n.initializePrimitiveArray(r,2,Number.NaN),null!==s&&n.initializeObjectArray(s,n.Point2D,2);const h=function(t,e,s,i,r,o,a,m,h){const u=nt(t,e.getStartXY(),a,!1),l=nt(t,e.getEndXY(),a,!1),c=nt(e,t.getStartXY(),a,!1),g=nt(e,t.getEndXY(),a,!1);let d=0,p=0;if(!Number.isNaN(u)){let s=!1;m&&n.isOneOf(u,0,1)&&t.getCoord2D(u).isEqualPoint2D(e.getStartXY())&&(d++,s=!0),s||(r&&(r[p]=u),o&&(o[p]=0),i&&i[p].setCoords(e.m_XStart,e.m_YStart),p++)}if(!Number.isNaN(l)){let s=!1;m&&n.isOneOf(l,0,1)&&t.getCoord2D(l).isEqualPoint2D(e.getEndXY())&&(d++,s=!0),s||(2>p&&(r&&(r[p]=l),o&&(o[p]=1),i&&i[p].setCoords(e.m_XEnd,e.m_YEnd)),p++)}if(2!==p&&!Number.isNaN(c)&&!(0===u&&0===c||0===l&&1===c)){let s=!1;m&&n.isOneOf(c,0,1)&&e.getCoord2D(c).isEqualPoint2D(t.getStartXY())&&(d++,s=!0),s||(2>p&&(r&&(r[p]=0),o&&(o[p]=c),i&&i[p].setCoords(t.m_XStart,t.m_YStart)),p++)}if(2!==p&&!Number.isNaN(g)&&!(1===u&&0===g||1===l&&1===g)){let s=!1;m&&n.isOneOf(g,0,1)&&e.getCoord2D(g).isEqualPoint2D(t.getEndXY())&&(d++,s=!0),s||(2>p&&(r&&(r[p]=1),o&&(o[p]=g),i&&i[p].setCoords(e.m_XEnd,e.m_YEnd)),p++)}if(p>0)return h&&(o=n.swap(r,r=o)),2===p&&r&&r[0]>r[1]&&(r[1]=n.swap(r[0],r[0]=r[1]),o&&(o[1]=n.swap(o[0],o[0]=o[1])),i&&(i[1]=n.swap(i[0],i[0]=i[1]))),p;if(d>0)return 0;const _=function(t,e,s){const i=t.m_XEnd-t.m_XStart,r=t.m_YEnd-t.m_YStart,o=e.m_XEnd-e.m_XStart,a=e.m_YEnd-e.m_YStart,m=o*r-i*a;if(0===m)return n.Point2D.getNAN();const h=4*n.doubleEps()*(Math.abs(o*r)+Math.abs(i*a)),u=e.m_XStart-t.m_XStart,l=e.m_YStart-t.m_YStart,c=o*l-u*a,g=4*n.doubleEps()*(Math.abs(o*l)+Math.abs(u*a)),d=c/m,p=Math.abs(m),_=(g*p+h*Math.abs(c))/(m*m)+n.doubleEps()*Math.abs(d);if(d<-_||d>1+_)return n.Point2D.getNAN();const P=i*l-u*r,f=P/m,y=(4*n.doubleEps()*(Math.abs(i*l)+Math.abs(u*r))*p+h*Math.abs(P))/(m*m)+n.doubleEps()*Math.abs(f);if(f<-y||f>1+y)return n.Point2D.getNAN();let x=n.snap(d,0,1),D=n.snap(f,0,1);const v=n.Point2D.getNAN();Z(t,x,v);const E=n.Point2D.getNAN();if(Z(e,D,E),!s||n.Point2D.distance(v,E)>s){const i=n.Point2D.getNAN();n.lerpPoint2D(v,E,.5,i),x=t.getClosestCoordinate(i,!1),D=e.getClosestCoordinate(i,!1);const r=n.Point2D.getNAN();Z(t,x,r);const o=n.Point2D.getNAN();Z(e,D,o),r.subThis(o);const a=r.length(),m=(t.absNorm()+e.absNorm())*n.geomEpsFactor();if(a>Math.max(s,m))return n.Point2D.getNAN()}return new n.Point2D(x,D)}(t,e,a);return Number.isNaN(_.x)?0:(i&&(i[0]=t.getCoord2D(_.x)),r&&(r[0]=_.x),o&&(o[0]=_.y),1)}(t,e,0,s,i,r,o,a,m);return i&&(i.length=h),r&&(r.length=h),s&&(s.length=h),h}function nt(t,e,s,i){const r=n.Point2D.getNAN(),o=n.Point2D.getNAN();let a=!1;t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart?(r.setCoords(t.m_XEnd,t.m_YEnd),o.setCoords(t.m_XStart,t.m_YStart),a=!0):(r.setCoords(t.m_XStart,t.m_YStart),o.setCoords(t.m_XEnd,t.m_YEnd));const m=a?1:0,h=a?0:1,u=n.Point2D.getNAN();u.setSub(e,r);let l=u.length(),c=3*l*n.doubleEps();if(l<=Math.max(s,c))return i&&0===l?Number.NaN:m;if(u.setSub(e,o),l=u.length(),c=3*l*n.doubleEps(),l<=Math.max(s,c))return i&&0===l?Number.NaN:h;u.setCoords(o.x-r.x,o.y-r.y);const g=u.length();if(g>0){const t=1/g;u.scale(t);const i=n.Point2D.getNAN();i.setSub(e,r);const l=i.dotProduct(u),c=8*i.dotProductAbs(u)*n.doubleEps();u.leftPerpendicularThis();const d=i.dotProduct(u),p=8*i.dotProductAbs(u)*n.doubleEps(),_=Math.max(s,c);if(l<-_||l>g+_)return Number.NaN;const P=Math.max(s,p);if(Math.abs(d)<=P){let i=l*t;i=n.snap(i,0,1);const u=n.Point2D.getNAN();if(U(i,r,o,u),n.Point2D.distance(u,e)<=s){if(i<.5){if(n.Point2D.distance(u,r)<=s&&n.Point2D.distance(e,r)<=s)return m}else if(n.Point2D.distance(u,o)<=s&&n.Point2D.distance(e,o)<=s)return h;return a?1-i:i}}}return Number.NaN}function it(t,e,s){const i=n.Point2D.getNAN();i.setCoords(e,s),i.subThis(t.getStartXY());const r=n.Point2D.getNAN();r.setSub(t.getEndXY(),t.getStartXY());const o=r.crossProduct(i),a=4*n.doubleEps()*(Math.abs(r.x*i.y)+Math.abs(r.y*i.x));return o>a?-1:o<-a?1:0}function rt(t,e,s,i){const r=i?t.m_XStart:t.m_XEnd,o=i?t.m_YStart:t.m_YEnd,a=n.Point2D.getNAN();return a.x=e.getEndX()-r,a.y=e.getEndY()-o,!(s.dotProduct(a)>3*n.doubleEps()*s.dotProductAbs(a))||(a.x=e.getStartX()-r,a.y=e.getStartY()-o,s.dotProduct(a)<=3*n.doubleEps()*s.dotProductAbs(a))}function ot(t,e){const s=n.Point2D.getNAN();return s.x=t.m_XEnd-t.m_XStart,s.y=t.m_YEnd-t.m_YStart,!!rt(t,e,s,!1)&&(s.negateThis(),!!rt(t,e,s,!0))}function at(t){const e=t.m_XStart-t.m_XEnd,s=t.m_YStart-t.m_YEnd;return e*e+s*s}class mt{constructor(t){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=t.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=t.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),void 0!==t.pointIndex){(t.pointIndex<0||t.pointIndex>=t.parent.getPointCount())&&e.throwOutOfRangeException("");const s=t.parent.getPathIndexFromPointIndex(t.pointIndex);this.m_currentPathIndex=s,this.m_nextPathIndex=s+1,this.m_nextSegmentIndex=t.pointIndex-t.parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(void 0!==t.pathIndex){(t.pathIndex<0||t.pathIndex>=t.parent.getPathCount()||t.segmentIndex<0)&&e.throwOutOfRangeException("");const s=t.parent.isClosedPath(t.pathIndex)?0:1;t.segmentIndex>=t.parent.getPathSize(t.pathIndex)-s&&e.throwOutOfRangeException(""),this.m_nextSegmentIndex=t.segmentIndex,this.m_currentPathIndex=t.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount()||(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,0))}previousPath(){return 0!==this.m_nextPathIndex&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(t){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(t)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(t){(t<0||t>this.m_parent.getPathCount())&&e.throwOutOfRangeException(""),this.m_nextPathIndex=t,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return 0===this.m_currentSegmentIndex}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(t){this.m_parent!==t.m_parent&&e.throwInvalidCallException(""),this.m_currentSegmentIndex=t.m_currentSegmentIndex,this.m_nextSegmentIndex=t.m_nextSegmentIndex,this.m_currentPathIndex=t.m_currentPathIndex,this.m_nextPathIndex=t.m_nextPathIndex,this.m_segmentCount=t.m_segmentCount,this.m_bCirculator=t.m_bCirculator,this.m_pathBegin=t.m_pathBegin,this.m_bCurrentPathClosed=t.m_bCurrentPathClosed,this.m_bStripAttributes=t.m_bStripAttributes,this.m_description=t.m_description}resetToVertex(t,e){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const e=this.getPathBegin();if(t>=e&&t<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=t-e)}let s;s=e>=0&&e<this.m_parent.getPathCount()&&t>=this.m_parent.getPathStart(e)&&t<this.m_parent.getPathEnd(e)?e:this.m_parent.getPathIndexFromPointIndex(t),this.m_nextPathIndex=s+1,this.m_currentPathIndex=s,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=t-this.m_parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(s),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&e.throwOutOfRangeException("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(0===this.m_nextSegmentIndex&&e.throwOutOfRangeException(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let t=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||t===this.m_segmentCount)return null;const e=this.getPathBegin()+this.m_nextSegmentIndex;if(1!=(31&this.m_segFlagStream.read(e))){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,t++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&e.throwOutOfRangeException(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&e.throwOutOfRangeException(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){return null!==this.m_segFlagStream&&1!=(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(t){this.m_bCirculator=t}getImpl(){return this}}class ht{constructor(t){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,t&&t.copyTo(this)}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(t){t!==this&&(e.geometryReleaseAssert(t.uniqueUse()),t.m_quadTree=this.m_quadTree,t.m_quadTreeForPaths=this.m_quadTreeForPaths,t.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const t=new ht;return this.copyTo(t),t}uniqueUse(){return 1===this.m_refCount}addRef(){++this.m_refCount}release(){0===--this.m_refCount&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(t){e.geometryReleaseAssert(this.uniqueUse())}setQuadTree(t){e.geometryReleaseAssert(this.uniqueUse()),this.m_quadTree=t}setQuadTreeForPaths(t){e.geometryReleaseAssert(this.uniqueUse()),this.m_quadTreeForPaths=t}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}}function ut(t,e){return t.readPoint2D(e+4)}function lt(t){const s=t.getGeometryType();return s===e.GeometryType.enumEllipticArc?10:s===e.GeometryType.enumBezier?4:s===e.GeometryType.enumRationalBezier2?5:s===e.GeometryType.enumBezier2?2:void e.throwInternalErrorException("")}function ct(t){const e=31&t;return 4===e?10:2===e?4:8===e?5:16===e?2:0}function gt(t,e,s,i){const r=t.getPathStart(e),o=t.getPathEnd(e);if(o-r<3)return;const a=2*r,m=n.Point2D.getNAN();s.queryPoint2D(a,m);const h=m.x,u=m.y,l=n.Point2D.getNAN();s.queryPoint2D(a+2,l);const c=n.Point2D.getNAN();for(let t=a+4,e=2*o;t<e;t+=2)s.queryPoint2D(t,c),i.pe((c.x-m.x)*(l.y-u)),m.setCoordsPoint2D(l),l.setCoordsPoint2D(c);i.pe((h-m.x)*(l.y-u))}function dt(t,e,s){for(;e.hasNextSegment();){const t=e.nextCurve();if(null===t)break;s.pe(2*t.calculateArea2DHelper())}}var pt=s.VertexDescription;class _t{static toSegType(t){let s=0;switch(t){case e.GeometryType.enumLine:s=1;break;case e.GeometryType.enumBezier:s=2;break;case e.GeometryType.enumEllipticArc:s=4;break;case e.GeometryType.enumRationalBezier2:s=8;break;case e.GeometryType.enumBezier2:s=16;break;default:e.throwInternalErrorException("")}return s}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(t){return this.m_segmentFlags=t.m_segmentFlags,this.m_segmentParamIndex=t.m_segmentParamIndex,this.m_segmentParams=t.m_segmentParams,this.m_curveCount=t.m_curveCount,this.m_bezierCount=t.m_bezierCount,this.m_arcCount=t.m_arcCount,this.m_rbezier2Count=t.m_rbezier2Count,this.m_bezier2Count=t.m_bezier2Count,this.m_curveParamWritePoint=t.m_curveParamWritePoint,this}}class Pt extends c{constructor(t){super(t),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,t.move?(this.m_bPolygon=t.move.m_bPolygon,this.m_cachedLength2D=t.move.m_cachedLength2D,this.m_cachedArea2D=t.move.m_cachedArea2D,this.m_currentPathIndex=t.move.m_currentPathIndex,this.m_cachedRingAreas2D=t.move.m_cachedRingAreas2D,this.m_paths=t.move.m_paths,this.m_pathFlags=t.move.m_pathFlags,this.m_curveData=t.move.m_curveData,t.move.m_curveData=null,t.move.setEmpty()):(this.m_bPolygon=t.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?e.GeometryType.enumPolygon:e.GeometryType.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(t){e.geometryReleaseAssert(this.m_bPolygon);const s=this.getPathIndexFromPointIndex(t),n=this.getPathStart(s);if(n===t)return;const i=this.getPathEnd(s);(t>=i||t<n)&&e.throwInvalidArgumentException("change_ring_start_point");for(let e=0,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),r=pt.getComponentCount(s);this.m_vertexAttributes.get(e).rotate(n*r,t*r,i*r)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(n,t,i),this.m_curveData.m_segmentParamIndex.rotate(n,t,i))}setFillRule(t){this.m_bFillRule=1===t}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(t){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(t)))}isExteriorRing(t){return this.calculateRingArea2D(t)>0}calculateRingArea2D(t){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(t)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const t=this.getPathCount();if(0===t)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const e=new s.AttributeStreamOfDbl(t),i=new n.KahanSummator(0),r=new n.KahanSummator(0);if(0!==this.m_pointCount){const s=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const t=new mt({parent:this});for(t.stripAttributes();t.nextPath();){r.reset();const n=t.getPathIndex();gt(this,n,s,r),dt(0,t,r);const o=.5*r.getResult();i.add(o),e.write(n,o)}}else for(let n=0;n<t;n++){r.reset(),gt(this,n,s,r);const t=.5*r.getResult();i.add(t),e.write(n,t)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=i.getResult(),this.m_cachedRingAreas2D=e,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)8&this.m_pathFlags.read(s)&&t++;return t}getHashCodeImpl(){return e.geometryReleaseAssert(0),0}equalsImpl(t){const e=t,s=this.getPathCount();if(s!==e.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==e.hasNonLinearSegments())return!1;if(i){if(this.m_curveData.m_curveCount!==e.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==e.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(e.m_paths,0,s+1))return!1;if(this.m_bFillRule!==e.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(e.m_pathFlags,0,s))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(e.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let t=0,s=this.getPointCount();t<s;t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!Pt.isNonLinearSegmentFlag(s))continue;const i=this.m_curveData.m_segmentParamIndex.read(t),r=e.m_curveData.m_segmentParamIndex.read(t),o=ct(s);for(let t=0;t<o;t++){const s=this.m_curveData.m_segmentParams.read(i+t),o=e.m_curveData.m_segmentParams.read(r+t);if(!n.isEqualNonIEEE(s,o))return!1}}}return!0}equalsImplTol(t,e){const s=t,n=this.getPathCount();if(n!==s.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==s.hasNonLinearSegments())return!1;if(i){if(this.m_curveData.m_curveCount!==s.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==s.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(s.m_paths,0,n+1))return!1;if(this.m_bFillRule!==s.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(s.m_pathFlags,0,n))return!1;if(!i)return!0;if(!this.m_curveData.m_segmentFlags.equals(s.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const r=this.querySegmentIterator(),o=s.querySegmentIterator();for(;r.nextPath();){if(!o.nextPath())return!1;for(;r.hasNextSegment();){const t=r.nextCurve(),s=o.nextCurve();if(!(t&&s&&t.equals(s,e))){if(!t&&!s)break;return!1}}}return!0}reserveImplImpl(t,e){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(t,1),this.m_curveData.m_segmentParamIndex.resize(t,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=s.createIndexStream(1,0),this.m_pathFlags=s.createByteStream(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(t,e){const s=t;s.m_bPathStarted=!1,s.m_bFillRule=this.m_bFillRule,this.m_paths?s.m_paths=e?this.m_paths:this.m_paths.clone():s.m_paths=null,this.m_pathFlags?s.m_pathFlags=e?this.m_pathFlags:this.m_pathFlags.clone():s.m_pathFlags=null,this.m_curveData&&(s.m_curveData||(s.m_curveData=new _t),s.m_curveData.assignCopy(this.m_curveData),s.m_curveData.m_curveCount=0,s.updateCurveCounter(this.m_curveData.m_curveCount),e||(this.m_curveData.m_segmentParamIndex?s.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex.clone():s.m_curveData.m_segmentParamIndex=null,this.m_curveData.m_segmentFlags?s.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags.clone():s.m_curveData.m_segmentFlags=null,this.m_curveData.m_segmentParams?s.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams.clone():s.m_curveData.m_segmentParams=null)),s.hasDirtyFlag(512)||(s.m_cachedLength2D=this.m_cachedLength2D),s.m_cachedRingAreas2D=null,s.hasDirtyFlag(1024)||(s.m_cachedArea2D=this.m_cachedArea2D,null!==this.m_cachedRingAreas2D&&(s.m_cachedRingAreas2D=e?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const t=this.querySegmentIterator(),e=new n.KahanSummator(0);for(;t.nextPath();)for(;t.hasNextSegment();)e.add(t.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=e.getResult()),this.setDirtyFlagProtected(512,!1),e.getResult()}calculatePathLength2D(t){const e=this.querySegmentIteratorAtVertex(this.getPathStart(t)),s=new n.KahanSummator(0);for(;e.hasNextSegment();)s.add(e.nextSegment().calculateLength2D());return s.getResult()}calculateLength3D(t){return e.geometryReleaseAssert(0),0}calculatePathLength3D(t,s){return e.geometryReleaseAssert(0),0}copyTo(t){e.isMultiPath(t.getGeometryType())||e.throwInvalidArgumentException(""),this!==t&&super.copyTo(t)}swap(t){e.geometryReleaseAssert(0)}setPointByVal(t,e){this.setPointByValWithCurves(t,e)}setPointByValWithCurves(t,e){if(this.hasNonLinearSegments()){const s=e.getXY();if(this.setXYCoordsWithCurves(t,s.x,s.y),1===this.m_description.getAttributeCount())return}this.setPointByValNoCurves(t,e)}setXYCoordsWithCurves(t,e,s){if(this.hasNonLinearSegments()){const i=Pt.getPathIndexFromPointIndexImpl(this.m_paths,this.getPathCount(),t,this.m_currentPathIndex);this.m_currentPathIndex=i;const r=this.getPrevSegmentTypeFromPath(i,t),o=this.getNextSegmentType(t);if(1!==r||1!==o){let a=t-1;const m=new qr;1!==r&&(this.isClosedPath(i)&&t===this.getPathStart(i)&&(a=this.getPathEnd(i)-1),this.getSegmentBuffer(a,m,!0));const h=new qr;1!==o&&this.getSegmentBuffer(t,h,!0);const u=t+1;this.setXYCoordsNoCurves(t,e,s);const l=new n.Point2D(e,s);return 1!==r&&(m.get().changeEndPoints2D(m.get().getStartXY(),l),this.replaceSegmentImpl(a,t,m.get(),!0)),void(1!==o&&(h.get().changeEndPoints2D(l,h.get().getEndXY()),this.replaceSegmentImpl(t,u,h.get(),!0)))}}this.setXYCoordsNoCurves(t,e,s)}setXYZWithCurves(t,e){this.hasNonLinearSegments()?(this.setXYCoordsWithCurves(t,e.x,e.y),this.setAttributeNoCurves(1,t,0,e.z)):this.setXYZNoCurves(t,e)}setAttributeWithCurves(t,e,s,n){if(0===t&&this.hasNonLinearSegments()){const t=this.getXY(e);0===s?t.x=n:t.y=n,this.setXYCoordsWithCurves(e,t.x,t.y)}else this.setAttributeNoCurves(t,e,s,n)}setXY(t,e){this.setXYCoordsWithCurves(t,e.x,e.y)}setXYCoords(t,e,s){this.setXYCoordsWithCurves(t,e,s)}setXYZ(t,e){this.setXYZWithCurves(t,e)}setAttribute(t,e,s,n){this.setAttributeWithCurves(t,e,s,n)}setAttributeWithCurvesFromArray(t,s,n,i){if(0===t&&this.hasNonLinearSegments()){i<2&&e.throwOutOfRangeException("");const t=this.getXY(s);t.x=n[0],t.y=n[1],this.setXYCoordsWithCurves(s,t.x,t.y)}else this.setAttributeFromArrayNoCurves(t,s,n,i)}setAttributeFromArray(t,e,s,n){this.setAttributeWithCurvesFromArray(t,e,s,n)}hasNonLinearSegments(){return 0!==this.getCurveCount()}getSegmentCount(){let t=this.getPointCount();if(!this.m_bPolygon){t-=this.getPathCount();for(let e=0,s=this.getPathCount();e<s;e++)this.isClosedPath(e)&&t++}return t}getSegmentCountPath(t){let e=this.getPathSize(t);return!this.isClosedPath(t)&&e>0&&e--,e}add(t,s){this===t&&e.throwInvalidArgumentException("Multi_path_impl::add");for(let e=0,n=t.getPathCount();e<n;e++)this.addPath(t,e,!s)}addPath(t,e,s){this.insertPath(-1,t,e,s)}addPathPoint2D(t,e,s){this.insertPath2D(-1,t,0,e,s)}addPathMultiPoint(t,e,s,n){s<0&&(s=t.getPointCount()-e),this.insertPointsFromMultipoint(-1,0,t,e,s,n)}addSegmentsFromPath(t,s,n,i,r){if(this===t&&e.throwInvalidArgumentException("Multi_path_impl.add_segments_from_path"),r||0!==this.getPathCount()||(r=!0),s<0&&(s=t.getPathCount()-1),(s>=t.getPathCount()||n<0||i<0||n+i>t.getSegmentCountPath(s))&&e.throwOutOfRangeException("add_segments_from_path"),0===i)return;const o=t.getPathStart(s),a=t.isClosedPath(s)&&n+i===t.getSegmentCountPath(s);this.m_bPathStarted=!1,this.mergeVertexDescription(t.getDescription());let m=i;const h=o+n;let u=h+1;r&&(m++,u--),!r&&t.hasNonLinearSegments()&&1!==t.m_curveData.m_segmentFlags.read(h)&&(t.getXY(h).equals(this.getXY(this.m_pointCount-1))||e.throwInvalidArgumentException("add_segments_from_path: start point mismatch"));const l=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+m),this.verifyAllStreamsAfterSizeChange(),r){if(0===m)return;this.m_paths.add(this.m_pointCount);let e=t.m_pathFlags.read(s);this.m_bPolygon&&(e|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,e),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const c=a?m-1:m;for(let e=0,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),n=pt.getComponentCount(s),i=t.m_description.getAttributeIndex(s);if(c>0){if(i<0||!t.m_vertexAttributes.get(i)){const t=pt.getDefaultValue(s);this.m_vertexAttributes.get(e).insertRange(n*l,t,c*n,n*l),a&&this.m_vertexAttributes.get(e).insertRange(n*l+c*n,t,n,n*l);continue}this.m_vertexAttributes.get(e).insertRangeFromStream(n*l,t.m_vertexAttributes.get(i),n*u,c*n,!0,n,n*l)}a&&this.m_vertexAttributes.get(e).insertRangeFromStream(n*(l+c),t.m_vertexAttributes.get(i),n*o,n,!0,n,n*(l+c))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),t.hasNonLinearSegments()){let e=0;for(let s=0,n=h;s<i;s++)e+=ct(t.m_curveData.m_segmentFlags.read(n)),n++;if(e>0){this.initSegmentData(e);let s=h,n=l-(r?0:1),o=0;for(let e=0;e<i;e++){const e=t.m_curveData.m_segmentFlags.read(s);if(this.m_curveData.m_segmentFlags.write(n,e),Pt.isNonLinearSegmentFlag(e)){o++;let i=t.m_curveData.m_segmentParamIndex.read(s);const r=ct(e);this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint);for(let e=0;e<r;e++){const e=t.m_curveData.m_segmentParams.read(i);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,e),this.m_curveData.m_curveParamWritePoint++,i++}this.incCurveType(e,1)}else this.m_curveData.m_segmentParamIndex.write(n,-1);n++,s++}this.modifyCurveCounter(o)}}if(a){const t=this.getPathCount()-1,e=this.getPathStart(t),s=this.getPathEnd(t)-1,n=this.getXY(e),i=this.getXY(s);n.isEqualPoint2D(i)&&(--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let t=0,e=this.getPathCount();t<e;t++)this.reversePath(t)}reversePath(t){t>=this.getPathCount()&&e.throwInvalidArgumentException("");const s=this.getPathSize(t);if(0===s)return;const n=this.getPathStart(t),i=this.isClosedPath(t);if(this.hasNonLinearSegments()){let t=n;const e=new this.m_segmentBufferCTor;let r=!1;for(let n=0;n<s;n++,t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!Pt.isNonLinearSegmentFlag(s))continue;r=!0,this.querySegment(t,e,!0),e.get().reverse();const n=this.m_curveData.m_segmentParamIndex.read(t);e.get().writeInBufferStream(this.m_curveData.m_segmentParams,n)}if(r){const t=i?0:1;this.m_curveData.m_segmentFlags.reverseRange(n,s-t,1),this.m_curveData.m_segmentParamIndex.reverseRange(n,s-t,1)}}const r=i?1:0;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),i=pt.getComponentCount(e);this.m_vertexAttributes.get(t).reverseRange(i*(n+r),i*(s-r),i)}const o=6&this.m_pathFlags.read(t);if(o){let e=0;4&o&&(e|=2),2&o&&(e|=4),this.m_pathFlags.clearBits(t,6),this.m_pathFlags.setBits(t,e)}this.notifyModifiedFlags(1233)}removePath(t){const s=this.getPathCount();t<0&&(t=s-1),t>=s&&e.throwInvalidArgumentException("");const n=this.getPathStart(t),i=this.getPathSize(t);for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=pt.getComponentCount(e);this.m_vertexAttributes.get(t).eraseRange(s*n,s*i,s*this.m_pointCount)}if(this.hasNonLinearSegments()){let t=0;for(let e=n,s=n+i;e<s;e++){const s=this.m_curveData.m_segmentFlags.read(e);Pt.isNonLinearSegmentFlag(s)&&(this.incCurveType(s,-1),t++)}this.modifyCurveCounter(-t),this.m_curveData.m_segmentFlags.eraseRange(n,i,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(n,i,this.m_pointCount)}for(let e=t+1;e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e-1,t-i)}if(this.m_pathFlags)for(let e=t+1;e<=s;e++){const t=this.m_pathFlags.read(e);this.m_pathFlags.write(e-1,t)}this.m_paths.resize(s),this.m_pathFlags.resize(s),this.m_pointCount-=i,this.m_reservedPointCount-=i,t===s-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(t,n,i,r){this===n&&e.throwInvalidArgumentException("Multi_path_impl::insert_path");const o=this.getPathCount();if(!r&&n.hasNonLinearSegmentsPath(i))return t=this.insertPath(t,n,i,!0),this.reversePath(t),t;i>=n.getPathCount()&&e.throwInvalidArgumentException(""),t>o&&e.throwInvalidArgumentException(""),t<0&&(t=o),i<0&&(i=n.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(n.getDescription());const a=n.getPathStart(i),m=n.getPathSize(i);if(0===m)return this.insertPath2D(t,null,0,0,!0);const h=this.m_pointCount,u=n.isClosedPath(i)&&!r?1:0;this.resizeImpl(this.m_pointCount+m),this.verifyAllStreamsAfterSizeChange();const l=t<o?this.getPathStart(t):h;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=n.getDescription().getAttributeIndex(e),i=pt.getComponentCount(e);if(s>=0&&n.m_vertexAttributes.get(s))0!==u&&this.m_vertexAttributes.get(t).insertRangeFromStream(l*i,n.m_vertexAttributes.get(s),i*a,i,!0,i,i*h),this.m_vertexAttributes.get(t).insertRangeFromStream((l+u)*i,n.m_vertexAttributes.get(s),i*(a+u),i*(m-u),r,i,i*(h+u));else{const s=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(l*i,s,i*m,i*h)}}const c=h+m;this.m_paths.add(c);for(let e=o;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+m)}this.m_pathFlags.add(0);for(let e=o-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let g=n.getPathFlagsStreamRef().read(i);if(g&=-9,this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),n.hasNonLinearSegments()){this.initSegmentData(0);let t=a,e=0;for(let s=0;s<m;s++)e+=ct(n.m_curveData.m_segmentFlags.read(t)),t++;if(e>0){null===this.m_curveData.m_segmentFlags?(this.m_curveData.m_segmentFlags=s.createByteStream(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=s.createIndexStream(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(l,1,m,h),this.m_curveData.m_segmentParamIndex.insertRange(l,-1,m,h)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+e):this.m_curveData.m_segmentParams=s.createDoubleStream(e),t=a;let i=l,r=0;for(let e=0;e<m;e++){const e=n.m_curveData.m_segmentFlags.read(t);if(Pt.isNonLinearSegmentFlag(e)){this.m_curveData.m_segmentFlags.write(i,e),this.m_curveData.m_segmentParamIndex.write(i,this.m_curveData.m_curveParamWritePoint);const s=ct(e);let o=n.m_curveData.m_segmentParamIndex.read(t);for(let t=0;t<s;t++){const t=n.m_curveData.m_segmentParams.read(o);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,t),this.m_curveData.m_curveParamWritePoint++,o++}r++,this.incCurveType(e,1)}t++,i++}this.modifyCurveCounter(r)}}return this.notifyModifiedFlags(2001),t}insertPath2D(t,s,n,i,r){const o=this.getPathCount();(t>o||n<0)&&e.throwInvalidArgumentException(""),t<0&&(t=o),this.m_bPathStarted=!1;const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+i),0===i&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const m=t<o?this.getPathStart(t):a;if(s)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*m,s,n,i,r,2*a);else{const t=pt.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*m,t,2*i,2*a)}for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=pt.getComponentCount(e),n=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(m*s,n,s*i,s*a)}this.m_paths.add(this.m_pointCount);for(let e=o;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+i)}this.m_pathFlags.add(0);for(let e=o-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}return this.m_bPolygon&&this.m_pathFlags.write(t,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(m,1,i,a),this.m_curveData.m_segmentParamIndex.insertRange(m,-1,i,a)),this.notifyModifiedFlags(2001),t}insertPathFromMultipoint(t,s,n,i,r){const o=s.getImpl(),a=this.getPathCount();(t>a||n<0)&&e.throwInvalidArgumentException("");const m=i<0?o.getPointCount()-n:i;if(m>o.getPointCount()&&e.throwInvalidArgumentException(""),n>=o.getPointCount()&&e.throwInvalidArgumentException("pointsOffset"),t<0&&(t=a),this.m_bPathStarted=!1,this.mergeVertexDescription(o.getDescription()),0===m)return void this.insertPath2D(t,null,0,0,!0);const h=this.m_pointCount,u=n;this.resizeImpl(this.m_pointCount+m),this.verifyAllStreamsAfterSizeChange();const l=t<a?this.getPathStart(t):h;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=o.getDescription().getAttributeIndex(e),n=pt.getComponentCount(e);if(s>=0){const s=o.getAttributeStreamRef(e);this.m_vertexAttributes.get(t).insertRangeFromStream(l*n,s,n*u,n*m,r,n,n*h)}else{const s=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(l*n,s,n*m,n*h)}}const c=h+m;this.m_paths.add(c);for(let e=a;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+m)}this.m_pathFlags.add(0);for(let e=a-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let g=0;this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),this.notifyModifiedFlags(2001)}insertPoints(t,s,n,i,r,o,a){if(this===n&&e.throwInvalidArgumentException("Multi_path_impl.insert_points"),t<0&&(t=this.getPathCount()),i<0&&(i=n.getPathCount()-1),(t>this.getPathCount()||s>=0&&s>this.getPathSize(t)||i>=n.getPathCount()||o>n.getPathSize(i))&&e.throwOutOfRangeException(""),!o)return;if(this.mergeVertexDescription(n.m_description),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);let t=n.m_pathFlags.read(i);t&=-9,this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}s<0&&(s=this.getPathSize(t));const m=this.m_pointCount;this.resizeImpl(this.m_pointCount+o),this.verifyAllStreamsAfterSizeChange();const h=this.getPathStart(t),u=h+s;o<0&&(o=n.getPathSize(i));const l=n.getPathStart(i),c=l+o;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),i=pt.getComponentCount(e),g=n.m_description.getAttributeIndex(e);if(g<0||!n.m_vertexAttributes.get(g)){const s=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(i*u,s,c*i,i*m);continue}this.m_vertexAttributes.get(t)?.insertRangeFromStream(i*(h+s),n.m_vertexAttributes.get(g),i*(l+r),o*i,a,i,i*m)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h+s,1,o,m),this.m_curveData.m_segmentParamIndex.insertRange(h+s,-1,o,m),s>0&&this.isNonLinearSegment(h+s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h+s-1),-1),this.m_curveData.m_segmentFlags.write(h+s-1,1),this.m_curveData.m_segmentParamIndex.write(h+s-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,s=this.getPathCount();e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e,t+o)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(t,s,n,i,r,o){if(t<0&&(t=this.getPathCount()),(t>this.getPathCount()||s>this.getPathSize(t)||i<0)&&e.throwOutOfRangeException(""),!r)return;t===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_bPolygon?this.m_pathFlags.add(1):this.m_pathFlags.add(0)),s<0&&(s=this.getPathSize(t));const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const m=this.getPathStart(t);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(m+s),n,i,r,o,2*a);for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),n=pt.getComponentCount(e),i=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange((m+s)*n,i,n*r,n*a)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(m+s,1,r,a),this.m_curveData.m_segmentParamIndex.insertRange(m+s,-1,r,a),s>0&&this.isNonLinearSegment(m+s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(m+s-1),-1),this.m_curveData.m_segmentFlags.write(m+s-1,1),this.m_curveData.m_segmentParamIndex.write(m+s-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,s=this.getPathCount();e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+r);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(t,s,n,i,r,o){const a=n.getImpl(),m=this.getPathCount();t<0&&(t=this.getPathCount());const h=a.getPointCount();if((i<0||i>h)&&e.throwOutOfRangeException(""),(r<0||i+r>h)&&(r=h-i),s<0&&(s=t<m?this.getPathSize(t):0),(t>m||t<m&&s>this.getPathSize(t)||t===m&&s>0||r<0)&&e.throwOutOfRangeException(""),!r)return;if(this.mergeVertexDescription(a.getDescription()),t===m){this.m_paths.add(this.m_pointCount);const t=0;this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}s<0&&(s=this.getPathSize(t));const u=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const l=this.getPathStart(t),c=l+s,g=0+r;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),n=pt.getComponentCount(e);if(a.getDescription().getAttributeIndex(e)<0){const s=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(n*c,s,g*n,n*u);continue}const m=a.getAttributeStreamRef(e);this.m_vertexAttributes.get(t).insertRangeFromStream(n*(l+s),m,n*(0+i),r*n,o,n,n*u)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(l+s,1,r,u),this.m_curveData.m_segmentParamIndex.insertRange(l+s,-1,r,u),s>0&&this.isNonLinearSegment(l+s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(l+s-1),-1),this.m_curveData.m_segmentFlags.write(l+s-1,1),this.m_curveData.m_segmentParamIndex.write(l+s-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,s=this.getPathCount();e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e,t+r)}this.notifyModifiedFlags(2001)}insertPoint2D(t,s,n){const i=this.getPathCount();t<0&&(t=i),(t>i||t<i&&s>this.getPathSize(t))&&e.throwOutOfRangeException(""),t===i&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=s<0?this.getPathSize(t)+o:s+o,m=this.m_vertexAttributes.get(0);if(a===r)this.m_paths.write(t+1,r+1),m.writePoint2D(2*a,n);else{m.insert(2*a,n,2*r);for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=pt.getComponentCount(e),n=pt.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(s*a,n,s,s*r)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=i;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(t,s,n){const i=this.getPathCount();t<0&&(t=i),(t>i||t<i&&s>this.getPathSize(t))&&e.throwOutOfRangeException(""),t===i&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=s<0?this.getPathSize(t)+o:s+o;if(a===r)this.m_paths.write(t+1,r+1),this.setPointByValNoCurves(a,n);else{const e=n.getDescription();this.m_description!==e&&this.mergeVertexDescription(e);for(let t=0,s=this.m_description.getAttributeCount();t<s;t++){const s=this.m_description.getSemantics(t),i=pt.getComponentCount(s);if(e.hasAttribute(s))this.m_vertexAttributes.get(t).insertAttributes(i*a,n,s,i*r);else{const e=pt.getDefaultValue(s);this.m_vertexAttributes.get(t).insertRange(i*a,e,i,i*r)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=i;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(t,s){const n=this.getPathCount();t<0&&(t=n-1),(t>=n||s>=this.getPathSize(t))&&e.throwOutOfRangeException("Multi_path.remove_point");const i=this.getPathStart(t),r=this.isClosedPath(t);s<0&&(s=this.getPathSize(t)-1),s<0&&e.throwOutOfRangeException("Multi_path.remove_point");const o=i+s;for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=pt.getComponentCount(e);this.m_vertexAttributes.get(t).eraseRange(s*o,s,s*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let e=0;if(o>i&&this.isNonLinearSegment(o-1))e+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(o-1),-1),this.m_curveData.m_segmentFlags.write(o-1,1),this.m_curveData.m_segmentParamIndex.write(o-1,-1);else{const s=this.getPathEnd(t);r&&i+1<s&&this.isNonLinearSegment(s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(s-1),-1),this.m_curveData.m_segmentFlags.write(s-1,1),this.m_curveData.m_segmentParamIndex.write(s-1,-1),e+=1)}this.isNonLinearSegment(o)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(o),-1),e+=1),e>0&&this.modifyCurveCounter(-e),this.m_curveData.m_segmentFlags.eraseRange(o,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(o,1,this.m_pointCount)}for(let e=n;e>=t+1;e--){const t=this.m_paths.read(e);this.m_paths.write(e,t-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(t){let e;e=t<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(t),this.removePointFromPath(e,t-this.getPathStart(e))}getNextSegmentType(t){return this.hasNonLinearSegments()?this.m_curveData.m_segmentFlags.read(t):1}getPrevSegmentTypeFromPath(t,s){if(!this.hasNonLinearSegments())return 1;const n=this.getPathStart(t);if(s>n)return this.m_curveData.m_segmentFlags.read(s-1);if(s===n){if(this.isClosedPath(t)){const e=this.getPathEnd(t);return this.m_curveData.m_segmentFlags.read(e-1)}return 1}e.throwInternalErrorException("")}getNumberOfCurves(t){if(!this.hasNonLinearSegments())return 0;let e=0;for(let s=this.getPathStart(t),n=this.getPathEnd(t);s<n;s++)Pt.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s))&&++e;return e}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(t){return this.m_paths.read(t+1)-this.m_paths.read(t)}getPathStart(t){return this.m_paths.read(t)}getPathEnd(t){return this.m_paths.read(t+1)}getPathIndexFromPointIndex(t,e=-1){-1===e&&(e=this.m_currentPathIndex);const s=this.getPathCount(),n=Pt.getPathIndexFromPointIndexImpl(this.m_paths,s,t,e);return this.m_currentPathIndex=n,n}startPathCoords(t,e){this.startPathPoint(new s.Point({x:t,y:e}))}startPath(t){this.startPathPoint(new s.Point({pt:t}))}startPath3D(t){this.startPathPoint(new s.Point({x:t.x,y:t.y,z:t.z}))}startPath3DCoords(t,e,n){this.startPathPoint(new s.Point({x:t,y:e,z:n}))}startPathPoint(t){t.isEmpty()&&e.throwInvalidArgumentException("");const n=t.getDescription();let i;if(this.m_description!==n){this.mergeVertexDescription(n);const e=new s.Point({vd:this.m_description});t.copyCommonAttributesTo(e),i=e}else i=t;this.m_bPathStarted?this.setPointByValNoCurves(this.m_pointCount-1,i):(this.insertPoint(-1,-1,i),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=s.createIndexStream(2),this.m_paths.write(0,0),this.m_pathFlags=s.createByteStream(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){null!==this.m_paths?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(t){0!==this.m_pointCount||this.m_bPathStarted||this.startPathCoords(0,0);const e=this.m_pointCount,s=this.m_paths.size()-1,n=e+t;this.m_paths.write(s,n),this.resizeImpl(n),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const t=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);1!==t&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(t,-1))}}lineToCoords(t,e){if(this.beforeNewSegment(1),1===this.m_description.getAttributeCount())this.setXYCoordsNoCurves(this.m_pointCount-1,t,e);else{const n=s.newOrdinateBuffer(),i=new s.Point({vd:this.m_description,attribBuffer:n,initDefaultValues:!0});i.setXYCoords(t,e),this.setPointByValNoCurves(this.m_pointCount-1,i)}this.finishLineTo()}lineTo(t){this.lineToCoords(t.x,t.y)}lineTo3D(t){this.beforeNewSegment(1);const e=s.getMergedVertexDescription(this.m_description,s.getDefaultDescription3D()),n=s.newOrdinateBuffer(),i=new s.Point({vd:e,attribBuffer:n,initDefaultValues:!0});i.setXYZ(t),this.setPointByValNoCurves(this.m_pointCount-1,i),this.finishLineTo()}lineTo3DCoords(t,e,n){this.lineTo3D(new s.Point3D(t,e,n))}lineToPoint(t){if(this.beforeNewSegment(1),this.m_description===t.getDescription())this.setPointByValNoCurves(this.m_pointCount-1,t);else{this.mergeVertexDescription(t.getDescription());const e=s.newOrdinateBuffer(),n=new s.Point({vd:this.m_description,attribBuffer:e,initDefaultValues:!1});t.copyCommonAttributesTo(n),this.setPointByValNoCurves(this.m_pointCount-1,n)}this.finishLineTo()}openPathAndDuplicateStartVertex(t){this.m_bPolygon&&e.throwInternalErrorException("");const s=this.getPathCount();if(t>s&&e.throwInvalidArgumentException(""),!this.isClosedPath(t))return;this.m_pathFlags||e.throwInternalErrorException("");const n=this.m_pointCount,i=this.getPathStart(t),r=this.getPathEnd(t);if(r-i!==0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=pt.getComponentCount(e);this.m_vertexAttributes.get(t).insertRangeFromStream(s*r,this.m_vertexAttributes.get(t),s*i,s,!0,1,s*n)}for(let e=s;e>t;e--){const t=this.m_paths.read(e);this.m_paths.write(e,t+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(r,1,1,n),this.m_curveData.m_segmentParamIndex.insertRange(r,-1,1,n)),this.m_pathFlags.clearBits(t,1)}}openPath(t){this.m_bPolygon&&e.throwInternalErrorException(""),t>this.getPathCount()&&e.throwInvalidArgumentException(""),this.m_pathFlags||e.throwInternalErrorException(""),this.m_pathFlags.clearBits(t,1)}isStrongPathStart(t){return!!(2&this.m_pathFlags.read(t))}setStrongPathStart(t,e){e?this.m_pathFlags.setBits(t,2):this.m_pathFlags.clearBits(t,2)}isStrongPathEnd(t){return!!(4&this.m_pathFlags.read(t))}setStrongPathEnd(t,e){e?this.m_pathFlags.setBits(t,4):this.m_pathFlags.clearBits(t,4)}clearStrongPathEnds(){for(let t=0,e=this.getPathCount();t<e;++t)this.m_pathFlags.clearBits(t,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&e.throwInternalErrorException(""),this.isEmpty())return;this.m_pathFlags||e.throwInternalErrorException("");let t=0;const n=this.getPathCount();for(let e=0;e<n;e++)this.isClosedPath(e)&&(this.getPathSize(e)>0?t++:this.m_pathFlags.clearBits(e,1));if(0===t)return;const i=this.hasNonLinearSegments();let r=0;const o=this.getPathCount(),a=this.m_description.getAttributeCount(),m=new Array(a);let h=null,u=null;for(let e=0;e<o;++e){const n=this.getPathStart(e),o=this.getPathSize(e),l=this.isClosedPath(e);if(o>0){const e=n+r;for(let i=0;i<a;i++)if(this.m_vertexAttributes.get(i)){const r=this.m_description.getSemantics(i),a=pt.getComponentCount(r);if(!m[i]){const e=a*(this.m_pointCount+t),n=s.createAttributeStreamUninitialized(r,e);m[i]=n}m[i].writeRange(e*a,o*a,this.m_vertexAttributes.get(i),n*a,!0,1),l&&m[i].writeRange((e+o)*a,a,this.m_vertexAttributes.get(i),n*a,!0,1)}if(i){if(null===h){const e=this.m_pointCount+t;h=s.createByteStream(e),u=s.createIndexStream(e)}h.writeRange(e,o,this.m_curveData.m_segmentFlags,n,!0,1),u.writeRange(e,o,this.m_curveData.m_segmentParamIndex,n,!0,1),l&&(h.write(e+o,1),u.write(e+o,-1))}}this.m_paths.write(e,n+r),l&&(this.m_pathFlags.clearBits(e,1),++r)}this.m_paths.write(o,this.m_pointCount+t),this.m_pathFlags.clearBits(o,1);for(let t=0;t<a;t++)this.m_vertexAttributes.get(t)&&this.m_vertexAttributes.set(t,m[t]);i&&(this.m_curveData.m_segmentFlags=h,this.m_curveData.m_segmentParamIndex=u),this.m_pointCount+=t,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(t){void 0===t&&(t=this.getPathCount()-1),this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&e.throwInvalidArgumentException("close_path_with_line"),t===this.getPathCount()-1&&(this.m_bPathStarted=!1);const s=this.m_pathFlags.read(t);if(1&s||this.m_pathFlags.write(t,1|s),this.m_curveData&&this.m_curveData.m_segmentFlags){const e=this.getPathEnd(t)-1,s=this.m_curveData.m_segmentFlags.read(e);1!==s&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(s,-1),this.modifyCurveCounter(-1))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(t){this.closePathWithSegment(this.getPathCount()-1,t)}closePathWithSegment(t,s){if(this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&e.throwInvalidArgumentException("close_path_with_line"),s.getEndXY().equals(this.getXY(this.getPathStart(t)))||e.throwInvalidArgumentException("close_path_with_segment: end point mismatch"),t===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(s,!1),--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount);else{this.mergeVertexDescription(s.getDescription());const n=s.getStartXY(),i=this.getPathEnd(t)-1;n.equals(this.getXY(i))||e.throwInvalidArgumentException("close_path_with_segment: start point mismatch");const r=s.getGeometryType();if(r===e.GeometryType.enumLine)return void this.closePathWithLine(t);{const t=lt(s);this.initSegmentData(t);const e=_t.toSegType(r),n=this.m_curveData.m_segmentFlags.read(i);if(n!==e)this.m_curveData.m_segmentParamIndex.write(i,this.m_curveData.m_curveParamWritePoint),s.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=t,this.incCurveType(e,1),1!==n?this.incCurveType(n,-1):this.modifyCurveCounter(1);else{const t=this.m_curveData.m_segmentParamIndex.read(i);s.writeInBufferStream(this.m_curveData.m_segmentParams,t)}this.m_curveData.m_segmentFlags.write(i,e)}}const n=this.m_pathFlags.read(t);1&n||this.m_pathFlags.write(t,1|n),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let t=!1;for(let e=0,s=this.m_paths.size()-1;e<s;e++){if(this.isClosedPath(e))continue;const s=this.m_pathFlags.read(e);this.m_pathFlags.write(e,1|s),t=!0}t&&this.notifyModifiedFlags(512)}isClosedPath(t){return!!(1&this.m_pathFlags.read(t))}isClosedPathInXYPlane(t){if(this.isClosedPath(t))return!0;const e=this.getPathStart(t),s=this.getPathEnd(t)-1;if(e>s)return!1;const n=this.getXY(e),i=this.getXY(s);return n.isEqualPoint2D(i)}isClosedPathIn3D(t){return e.geometryReleaseAssert(0),!1}hasNonLinearSegmentsPath(t){if(!this.hasNonLinearSegments())return!1;for(let e=this.getPathStart(t),s=this.getPathEnd(t);e<s;e++)if(Pt.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e)))return!0;return!1}isNonLinearSegment(t){return!(1&this.getSegmentFlags(t))}addEnvelope(t,e){if(t.isEmpty())return;const n=0===this.m_pointCount;if(t instanceof i.Envelope2D)this.startPathCoords(t.xmin,t.ymin),e?(this.lineToCoords(t.xmax,t.ymin),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmin,t.ymax)):(this.lineToCoords(t.xmin,t.ymax),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmax,t.ymin));else{const n=t.getDescription(),i=s.newOrdinateBuffer(),r=new s.Point({vd:n,attribBuffer:i,initDefaultValues:!1});for(let s=0,n=4;s<n;s++){const i=e?n-s-1:s;t.queryCornerByVal(i,r),0===s?this.startPathPoint(r):this.lineToPoint(r)}}this.closePathWithLine(),this.m_bPathStarted=!1,n&&!e&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(t.width(),t.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(t,n){if(t.isClosed()||e.throwInvalidArgumentException("add_path_from_closedSegment: segment must be closed"),n){const e=t.getReversed(),n=new s.Point;e.queryStart(n),this.startPathPoint(n),this.closeLastPathWithSegment(e)}else{const e=new s.Point;t.queryStart(e),this.startPathPoint(e),this.closeLastPathWithSegment(t)}}addSegment_(t,n){const i=t.getDescription();this.mergeVertexDescription(i);const r=s.newOrdinateBuffer(),o=new s.Point({vd:i,attribBuffer:r,initDefaultValues:!1}),a=t.getGeometryType();if(a===e.GeometryType.enumLine)(n||this.isEmptyImpl())&&(t.queryStart(o),this.startPathPoint(o)),t.queryEnd(o),this.lineToPoint(o);else{let i=!1;if((n||this.isEmptyImpl())&&(i=!0),i||t.getStartXY().equals(this.getXY(this.m_pointCount-1))||e.throwInvalidArgumentException("add_segment: start point mismatch"),i&&(t.queryStart(o),this.startPathPoint(o)),this.beforeNewSegment(1),t.queryEnd(o),o.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,o);else{const t=s.newOrdinateBuffer(),e=new s.Point({vd:this.m_description,attribBuffer:t,initDefaultValues:!1});o.copyCommonAttributesTo(e),this.setPointByVal(this.m_pointCount-1,e)}const r=lt(t);this.initSegmentData(r),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),t.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=r;const m=_t.toSegType(a);this.incCurveType(m,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,m)}}addSegment(t,e,s){s?e?this.addPathFromClosedSegment(t,!1):this.closeLastPathWithSegment(t):this.addSegment_(t,e)}interpolateAttributesRange(t,s,n,i){for(let s=t;s<n-1;s++)this.isClosedPath(s)&&e.throwInvalidArgumentException("cannot interpolate across closed paths");const r=this.m_description.getAttributeCount();if(1===r)return;const o=this.calculateSubLength2D(t,s,n,i);if(0!==o)for(let e=1;e<r;e++){const r=this.m_description.getSemantics(e);this.interpolateAttributesSemanticsImpl(r,t,s,n,i,o)}}interpolateAttributesSemantics(t,s,n,i,r){if(0===t)return;this.hasAttribute(t)||e.throwInvalidArgumentException("does not have the given attribute"),2===pt.getInterpolation(t)&&e.throwInvalidArgumentException("angular interpolation");for(let t=s;t<i-1;t++)this.isClosedPath(t)&&e.throwInvalidArgumentException("cannot interpolate across closed paths");const o=this.calculateSubLength2D(s,n,i,r);0!==o&&this.interpolateAttributesSemanticsImpl(t,s,n,i,r,o)}interpolateAttributesPath(t,e,s){const n=this.m_description.getAttributeCount();if(1===n)return;if(e===s)return;const i=this.calculatePathSubLength2D(t,e,s);for(let r=1;r<n;r++){const n=this.m_description.getSemantics(r);this.interpolateAttributesSemanticsPathImpl(n,t,e,s,i)}}interpolateAttributesSemanticsPath(t,s,n,i){if(0===t)return;this.hasAttribute(t)||e.throwInvalidArgumentException("does not have the given attribute"),2===pt.getInterpolation(t)&&e.throwInvalidArgumentException("angular interpolation");const r=this.calculatePathSubLength2D(s,n,i);0!==r&&this.interpolateAttributesSemanticsPathImpl(t,s,n,i,r)}interpolateAttributesSemanticsImpl(t,e,s,i,r,o){const a=this.querySegmentIterator(),m=this.getPathStart(e)+s,h=this.getPathStart(i)+r,u=pt.getComponentCount(t),l=n.makePrimitiveArray(pt.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,m,l,u);const c=n.makePrimitiveArray(pt.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,c,u);const g=n.makePrimitiveArray(pt.maxComponentCount(),Number.NaN);n.memcpy(g,l,0,0,u);let d=0;const p=pt.getDefaultValue(t),_=pt.getInterpolation(t);a.resetToVertex(m,e);do{if(a.hasNextSegment()){if(a.nextSegment(),a.getStartPointIndex()===h)return;this.setAttributeFromArray(t,a.getStartPointIndex(),g,u),a.previousSegment();do{const e=a.nextSegment();if(a.getEndPointIndex()===h)return;d+=e.calculateLength2D();const s=d/o;n.interpolateArray(_,l,c,g,0,u,s,p),a.isClosingSegment()||this.setAttributeFromArray(t,a.getEndPointIndex(),g,u)}while(a.hasNextSegment())}}while(a.nextPath())}interpolateAttributesSemanticsPathImpl(t,s,i,r,o){e.geometryReleaseAssert(0!==t);const a=this.querySegmentIterator(),m=pt.getInterpolation(t),h=this.getPathStart(s)+i,u=this.getPathStart(s)+r;if(u===h)return;const l=pt.getComponentCount(t),c=n.makePrimitiveArray(pt.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,c,l);const g=n.makePrimitiveArray(pt.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,u,g,l);const d=new n.KahanSummator(0);a.resetToVertex(h,s),a.setCirculator(this.isClosedPath(s));const p=pt.getDefaultValue(t),_=n.makePrimitiveArray(pt.maxComponentCount(),Number.NaN);n.memcpy(_,c,0,0,l);const P=0===o;let f=.5;do{const e=a.nextSegment();if(this.setAttributeFromArrayNoCurves(t,a.getStartPointIndex(),_,l),!P){const t=e.calculateLength2D();d.pe(t),f=d.getResult()/o}n.interpolateArray(m,c,g,_,0,l,f,p)}while(a.getEndPointIndex()!==u)}querySegment(t,s,n){const i=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(i);r>=this.getSegmentCountPath(i)&&e.throwInvalidArgumentException("get_segment"),this.getSegmentFromPath(i,r,s,n)}getSegment(t,e){const s=new this.m_segmentBufferCTor;return this.getSegmentBuffer(t,s,e),s.releaseSegment()}getSegmentType(t){const s=this.getPathIndexFromPointIndex(t),n=t-this.getPathStart(s);return n>=this.getSegmentCountPath(s)&&e.throwInvalidArgumentException("get_segment"),this.getSegmentTypeFromPath(s,n)}getSegmentFromPath(t,n,i,r){const o=this.getPathStart(t)+n,a=this.getSegmentFlagsStreamRef();let m=1;switch(a&&(m=31&a.read(o)),m){case 1:i.createLine();break;case 2:i.createCubicBezier();break;case 4:i.createEllipticArc();break;case 8:i.createQuadraticRationalBezier();break;case 16:i.createQuadraticBezier();break;default:e.throwInternalErrorException("")}const h=i.get();let u,l=null;if(r?(l=s.getDefaultDescription2D(),h.assignVertexDescription(l)):h.assignVertexDescription(this.m_description),u=o===this.getPathEnd(t)-1&&this.isClosedPath(t)?this.getPathStart(t):o+1,w(h,this.getXY(o)),T(h,this.getXY(u)),!r)for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=pt.getComponentCount(e);for(let t=0;t<s;t++){const s=this.getAttributeAsDbl(e,o,t);h.setStartAttribute(e,t,s);const n=this.getAttributeAsDbl(e,u,t);h.setEndAttribute(e,t,n)}}if(Pt.isNonLinearSegmentFlag(m)){const t=this.m_curveData.m_segmentParamIndex.read(o);h.readFromBufferStream(this.m_curveData.m_segmentParams,t)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments())return!1;if(0===this.m_curveData.m_arcCount)return!1;let t=!1;for(let e=0,s=this.getPointCount();e<s;e++)if(4===this.m_curveData.m_segmentFlags.read(e)){const s=this.m_curveData.m_segmentParamIndex.read(e);ut(this.m_curveData.m_segmentParams,s).isNAN()&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),t=!0)}return t&&this.checkCompactSegmentParams(),t}queryPointAlongPath(t,s,i,r=!1){const o={iSegment:-1},a=r?o:{tSegment:0};if(i.setEmpty(),this.isEmpty())return o;if((t<0||t>=this.getPathCount())&&e.throwInvalidArgumentException("query_point_along_path"),s<0)return o;const m=this.getPathSize(t);if(0===m)return o;if(1===m)return this.getPointByVal(this.getPathStart(t),i),a.tSegment=0,o.iSegment=this.getPathStart(t),o;const h=this.querySegmentIteratorAtVertex(this.getPathStart(t)),u=new n.KahanSummator(0);for(;h.hasNextSegment();){const t=h.nextSegment(),e=t.calculateLength2D(),n=u.getResult();if(u.add(e),u.getResult()>=s){let r=s-n;r>e&&(r=e);const m=t.lengthToT(r);return t.queryCoord(m,i),a.tSegment=m,o.iSegment=h.getStartPointIndex(),o}}if(this.isClosedPath(t)){const e=this.getPathStart(t);return this.getPointByVal(e,i),a.tSegment=1,o.iSegment=this.getPathEnd(t)-1,o}{const e=this.getPathEnd(t)-1;return this.getPointByVal(e,i),this.getPathSize(t)>1?(a.tSegment=1,o.iSegment=this.getPathEnd(t)-2,o):(a.tSegment=0,o.iSegment=this.getPathStart(t),o)}}queryPointsAlongPath(t,s,i,r,o,a){{let t=0;for(let n=0;n<s;++n)r&&r[n].setEmpty(),o&&(o[n]=-1),a&&(a[n]=0),t>i[n]&&e.throwInvalidArgumentException("query_points_along"),t=i[n]}const m=this.getPathSize(t);if(0===s||0===m)return 0;if(1===m){const e=this.getPathStart(t);return r&&this.getPointByVal(e,r[0]),a&&(a[0]=0),o&&(o[0]=e),1}const h=this.getPathStart(t),u=new n.KahanSummator(0),l=this.querySegmentIteratorAtVertex(h);let c=0,g=0,d=i[c];for(;l.hasNextSegment();){const t=l.nextSegment(),e=t.calculateLength2D(),n=u.getResult();for(u.add(e);u.getResult()>=d;){let m=d-n;m>e&&(m=e);const h=t.lengthToT(m);if(r&&t.queryCoord(h,r[g]),a&&(a[g]=h),o&&(o[g]=l.getStartPointIndex()),g++,c++,d=i[c],c===s)return g}}if(this.isClosedPath(t)){const e=this.getPathStart(t),s=0;r&&this.getPointByVal(e,r[g]),a&&(a[g]=s),o&&(o[g]=e),g++}else if(this.getPathSize(t)>1){const e=this.getPathEnd(t)-2,s=1;r&&this.getPointByVal(e+1,r[g]),a&&(a[g]=s),o&&(o[g]=e),g++}return g}queryPointsAlong(t,s,i,r,o){{let n=0;for(let a=0;a<t;++a)i&&i[a].setEmpty(),r&&(r[a]=-1),o&&(o[a]=0),n>s[a]&&e.throwInvalidArgumentException("query_points_along"),n=s[a]}if(0===t)return 0;const a=new n.KahanSummator(0),m=this.querySegmentIterator();let h=-1,u=0,l=0,c=s[u];for(;m.nextPath();)for(;m.hasNextSegment();){h=m.getPathIndex();const e=m.nextSegment(),n=e.calculateLength2D(),g=a.getResult();for(a.add(n);a.getResult()>=c;){let a=c-g;a>n&&(a=n);const h=e.lengthToT(a);if(i&&e.queryCoord(h,i[l]),o&&(o[l]=h),r&&(r[l]=m.getStartPointIndex()),l++,u++,c=s[u],u===t)return l}}if(h<0)return 0;if(this.isClosedPath(h)){const t=this.getPathStart(h),e=0;i&&this.getPointByVal(t,i[l]),o&&(o[l]=e),r&&(r[l]=t),l++}else if(this.getPathSize(h)>1){const t=this.getPathEnd(h)-2,e=1;i&&this.getPointByVal(t+1,i[l]),o&&(o[l]=e),r&&(r[l]=t),l++}return l}querySegmentIterator(){return new mt({parent:this})}querySegmentIteratorAtVertex(t){return new mt({parent:this,pointIndex:t})}queryPathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!0)}queryLoosePathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!1)}queryPathEnvelopeImpl(t,n,r){if(n instanceof s.Envelope&&e.geometryReleaseAssert(0,"not implemented for Envelope"),n instanceof s.Envelope3D&&e.geometryReleaseAssert(0,"not implemented for Envelope3D"),(t>=this.getPathCount()||t<0)&&e.throwInvalidArgumentException(""),this.isEmpty())return void n.setEmpty();const o=this.getAttributeStreamRef(0),a=i.Envelope2D.constructEmpty();a.setEmpty();for(let s=2*this.getPathStart(t),n=2*this.getPathEnd(t);s<n;){const t=n-s;e.geometryReleaseAssert(!(1&t)),a.mergePointsInterleaved(o,s/2,t/2),s+=t}if(n.setCoords({env2D:a}),this.hasNonLinearSegmentsPath(t)){const s=this.querySegmentIterator();if(s.resetToPath(t),s.nextPath())for(;s.hasNextSegment();){const t=s.nextCurve();if(!t)break;{const e=i.Envelope2D.constructEmpty();r?t.queryEnvelope(e):t.queryLooseEnvelope(e),n.mergeEnvelope2D(e)}}else e.geometryReleaseAssert(0)}}checkCompactSegmentParams(){if(!this.m_curveData||null===this.m_curveData.m_segmentParams)return!1;if(this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const t=ct(4)*this.m_curveData.m_arcCount+ct(2)*this.m_curveData.m_bezierCount+ct(8)*this.m_curveData.m_rbezier2Count+ct(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*t>>1,10)?(this.forceCompactSegmentParams(),!0):(0===this.m_pointCount&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let t=0;for(let e=0,s=this.getPointCount();e<s;e++){const s=this.m_curveData.m_segmentFlags.read(e);Pt.isNonLinearSegmentFlag(s)&&(t+=ct(s))}const e=s.createDoubleStream(t);let n=0;for(let t=0,s=this.getPointCount();t<s;t++){const s=this.m_curveData.m_segmentFlags.read(t);if(Pt.isNonLinearSegmentFlag(s)){let i=this.m_curveData.m_segmentParamIndex.read(t);this.m_curveData.m_segmentParamIndex.write(t,n);const r=ct(s);for(let t=0;t<r;t++)e.write(n,this.m_curveData.m_segmentParams.read(i)),n++,i++}}this.m_curveData.m_segmentParams=e,this.m_curveData.m_curveParamWritePoint=n}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(t){this.applyTransformationToPath(t,-1)}applyTransformation3D(t){e.geometryReleaseAssert(0)}getImpl(){return this}reserve(t){this.reserveImpl(t),t>0&&!this.m_paths&&(this.m_paths=s.createIndexStream(0),this.m_pathFlags=s.createByteStream(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0))}reserveParts(t,e){this.reserveImpl(t),e>0&&(this.m_paths?(this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1)):(this.m_paths=s.createIndexStream(0),this.m_pathFlags=s.createByteStream(0),this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0)))}clone(){const t=this.createInstance();return this.copyTo(t),t}queryLimitedSegmentIterator(t){return new ft(this,t)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(t){this.m_paths=t}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),null!=this.m_curveData?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(t){this.m_pathFlags=t}getSegmentIndexStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParams:null}setSegmentData(t,e,s,n){this.m_curveData||(this.m_curveData=new _t),this.m_curveData.m_segmentFlags=s,this.m_curveData.m_segmentParams=e,this.m_curveData.m_segmentParamIndex=t,this.m_curveData.m_curveParamWritePoint=n}static getPathIndexFromPointIndexImpl(t,s,n,i){if(i>=0&&i<s){if(n>=t.read(i)){if(n<t.read(i+1))return i;i++}else i--;if(i>=0&&i<s&&n>=t.read(i)&&n<t.read(i+1))return i}if(s<5){for(let e=0;e<s;e++)if(n<t.read(e+1))return e;e.throwCorruptedGeometryException("")}let r=0,o=s-1;for(;o>r;){const e=r+(o-r>>1);if(n<t.read(e))o=e-1;else{if(!(n>=t.read(e+1)))return e;r=e+1}}return r}getHighestPointIndex(t){e.geometryReleaseAssert(t>=0&&t<this.getPathCount());const s=this.getAttributeStreamRef(0),i=this.getPathEnd(t),r=this.getPathStart(t);let o=-1;const a=new n.Point2D;a.y=Number.NEGATIVE_INFINITY,a.x=Number.NEGATIVE_INFINITY;for(let t=r+0;t<i;t++){const e=s.readPoint2D(2*t);-1===a.compare(e)&&(o=t,a.setCoordsPoint2D(e))}return o}applyTransformationToPath(t,s){if(s>=this.getPathCount()&&e.throwInvalidArgumentException("apply_transformation"),this.isEmpty())return;if(t.isIdentity())return;const i=this.m_vertexAttributes.get(0);if(!(s<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(s))){let e,n;return s<0?(e=0,n=this.m_pointCount):(e=this.getPathStart(s),n=this.getPathEnd(s)),i.applyTransformation(t,2*e,n-e),void this.notifyModifiedFlags(2001)}const r=new this.m_segmentBufferCTor,o=this.getPathCount();let a=s<0?0:s;do{const e=this.getPathStart(a),o=this.getPathEnd(a),m=this.isClosedPath(a),h=i.readPoint2D(2*e);if(!this.hasNonLinearSegmentsPath(a)){i.applyTransformation(t,2*e,o-e);continue}const u=n.Point2D.getNAN();for(let s=e;s<o;++s){if(1!=(31&this.m_curveData.m_segmentFlags.read(s))){const n=m&&s+1===o;n&&i.writePoint2D(2*e,h),this.getSegmentBuffer(s,r,!0),r.get().applyTransformation(t);const a=this.m_curveData.m_segmentParamIndex.read(s);r.get().writeInBufferStream(this.m_curveData.m_segmentParams,a),i.writePoint2D(2*s,r.get().getStartXY()),n&&i.writePoint2D(2*e,r.get().getEndXY());continue}const n=2*s;i.queryPoint2D(n,u),t.transformInPlace(u),i.writePoint2D(n,u)}if(a===s)break}while(++a<o);this.notifyModifiedFlags(2001)}calculateSubLength2D(t,s,n,i){const r=this.getPathStart(t)+s,o=this.getPathStart(n)+i;(o<r||r<0||o>this.getPointCount()-1)&&e.throwInvalidCallException("");const a=this.querySegmentIterator();let m=0;a.resetToVertex(r,t);do{for(;a.hasNextSegment();){const t=a.nextSegment();if(a.getStartPointIndex()===o)break;m+=t.calculateLength2D()}if(a.getStartPointIndex()===o)break}while(a.nextPath());return m}calculatePathSubLength2D(t,s,n){const i=this.getPathStart(t)+s,r=this.getPathStart(t)+n;(i<0||r>this.getPointCount()-1)&&e.throwInvalidCallException("");const o=this.querySegmentIterator();if(i>r&&(this.isClosedPath(t)||e.throwInvalidArgumentException("cannot iterate across an open path"),o.setCirculator(!0)),i===r)return 0;let a=0,m=0;o.resetToVertex(i,t);do{m+=a,a=o.nextSegment().calculateLength2D()}while(o.getStartPointIndex()!==r);return m}calculateEnvelope2D(t){return this.updateXYImpl(t)}updateXYImpl(t){const e=super.updateXYImpl(t);if(this.hasNonLinearSegments()){const s=i.Envelope2D.constructEmpty(),n=this.querySegmentIterator();for(;n.nextPath();)for(;n.hasNextSegment();){const i=n.nextCurve();if(!i)break;t?i.queryEnvelope(s):i.queryLooseEnvelope(s),e.mergeEnvelope2D(s)}}return e}notifyModifiedAllImpl(){null!==this.m_paths&&this.m_paths.size()?this.m_pointCount=this.m_paths.read(this.m_paths.size()-1):this.m_pointCount=0}setDirtyOGCFlags(t){this.setDirtyFlagProtected(16,t)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(t){this.setDirtyFlagProtected(1024,t)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(t){return!(1&t)}addAndExplicitlyOpenAllPaths(t,s){this===t&&e.throwInvalidArgumentException("Multi_path_impl::add");let n=this.getPathCount();for(let e=0,i=t.getPathCount();e<i;e++)this.addPath(t,e,!s),this.openPathAndDuplicateStartVertex(n),n++}getSegmentFlags(t){return null!==this.m_curveData&&null!==this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.read(t):1}getSegmentBuffer(t,s,n){const i=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(i);r>=this.getSegmentCountPath(i)&&e.throwInvalidArgumentException("getSegmentBuffer"),this.getSegmentFromPath(i,r,s,n)}getSegmentTypeFromPath(t,s){const n=this.getPathStart(t)+s,i=this.getSegmentFlagsStreamRef();let r=1;switch(i&&(r=31&i.read(n)),r){case 1:return e.GeometryType.enumLine;case 2:return e.GeometryType.enumBezier;case 4:return e.GeometryType.enumEllipticArc;case 8:return e.GeometryType.enumRationalBezier2;case 16:return e.GeometryType.enumBezier2;default:e.throwInternalErrorException("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let t=!1;for(let s=0,i=this.getPathCount();s<i;s++){const i=this.getPathStart(s),r=this.getPathEnd(s),o=r-i;for(let s=i;s<r;s++){const r=31&this.m_curveData.m_segmentFlags.read(s);if(1===r)continue;2!==r&&e.throwNotImplementedException("ensure_xy_monotone_segments");const a=(s-i+1)%o+i,m=this.m_curveData.m_segmentParamIndex.read(s),h=n.makeObjectArray(n.Point2D,4);h[0]=this.getXY(s),h[3]=this.getXY(a),h[1].x=this.m_curveData.m_segmentParams.read(m),h[1].y=this.m_curveData.m_segmentParams.read(m+1),h[2].x=this.m_curveData.m_segmentParams.read(m+2),h[2].y=this.m_curveData.m_segmentParams.read(m+3),v(h)&&(t=!0,this.m_curveData.m_segmentParams.write(m,h[1].x),this.m_curveData.m_segmentParams.write(m+1,h[1].y),this.m_curveData.m_segmentParams.write(m+2,h[2].x),this.m_curveData.m_segmentParams.write(m+3,h[2].y))}}return t&&this.notifyModifiedFlags(2001),t}buildRasterizedGeometryAccelerator(t,e){return!1}buildQuadTreeAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new ht),null!==this.m_accelerators.getQuadTree())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const e=s.buildQuadTree(this);return this.m_accelerators.setQuadTree(e),!0}buildQuadTreeForPathsAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new ht),null!==this.m_accelerators.getQuadTreeForPaths())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const e=s.buildQuadTreeForPaths(this);return this.m_accelerators.setQuadTreeForPaths(e),!0}updateCurveCounter(t){this.modifyCurveCounter(t-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&(Pt.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(t){t&&(this.m_curveData||(this.m_curveData=new _t),Pt.st_totalCurveCount+=t,this.m_curveData.m_curveCount+=t)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(t,e){this.m_curveData||(this.m_curveData=new _t),2&t?this.m_curveData.m_bezierCount+=e:4&t?this.m_curveData.m_arcCount+=e:8&t?this.m_curveData.m_rbezier2Count+=e:16&t&&(this.m_curveData.m_bezier2Count+=e)}getCurveWritePoint(){return null!==this.m_curveData?this.m_curveData.m_curveParamWritePoint:0}initSegmentData(t){null===this.m_curveData&&(this.m_curveData=new _t);const e=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;null===this.m_curveData.m_segmentParamIndex&&(this.m_curveData.m_segmentFlags=s.createByteStream(e,1),this.m_curveData.m_segmentParamIndex=s.createIndexStream(e,-1));const n=this.m_curveData.m_curveParamWritePoint+t;null===this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams=s.createDoubleStream(n):n!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(n,0),this.m_curveData.m_segmentFlags.size()<e&&(this.m_curveData.m_segmentFlags.resize(e,1),this.m_curveData.m_segmentParamIndex.resize(e,-1))}updateCurveWritePoint(t){null===this.m_curveData&&(this.m_curveData=new _t),this.m_curveData.m_curveParamWritePoint=t}updateOGCFlagsHelper(){const t=this.getPathCount();if(0===t)return;const e=this.m_pathFlags;let s=0;for(let i=0;i<t;i++){const t=this.m_cachedRingAreas2D.read(i);0===s&&(s=n.sign(t)),t*s>0||0===s?e.setBits(i,8):e.clearBits(i,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(t,s,n){(t<0||t>=this.getPointCount())&&e.throwInvalidArgumentException("Multi_path_impl.replace_segment"),e.geometryReleaseAssert(s.isCurve());const i=this.getPathIndexFromPointIndex(t),r=this.getPathStart(i),o=(t-r+1)%this.getPathSize(i)+r;{const n=this.getXY(t),i=this.getXY(o),r=!n.isEqualPoint2D(s.getStartXY())||!i.isEqualPoint2D(s.getEndXY());e.geometryReleaseAssert(!r)}this.replaceSegmentImpl(t,o,s,n)}replaceSegmentImpl(t,i,r,o){const a=r.getDescription();this.mergeVertexDescription(a);const m=n.makePrimitiveArray(32,Number.NaN),h=new s.Point({vd:a,attribBuffer:m,initDefaultValues:!1}),u=null===this.m_curveData?1:31&this.m_curveData.m_segmentFlags.read(t),l=ct(u),c=lt(r);let g,d=!1;l>=c?(e.geometryReleaseAssert(null!==this.m_curveData),d=!0,g=this.m_curveData.m_segmentParamIndex.read(t)):(this.initSegmentData(c),d=!1,g=this.m_curveData.m_curveParamWritePoint);const p=r.getGeometryType(),_=_t.toSegType(p);o||(r.queryStart(h),this.setPointByValNoCurves(t,h),r.queryEnd(h),this.setPointByValNoCurves(i,h)),this.m_curveData.m_segmentParamIndex.write(t,1!==_?g:-1),this.m_curveData.m_segmentFlags.write(t,_),1!==_&&r.writeInBufferStream(this.m_curveData.m_segmentParams,g),d||(this.m_curveData.m_curveParamWritePoint+=c),u!==_&&(this.incCurveType(u,-1),this.incCurveType(_,1),this.modifyCurveCounter(1===u?1:-1))}setAttributeImpl(t,s,n){if(this.addAttribute(t),!this.isEmpty())if(this.hasNonLinearSegments()&&0===t){(s<0||s>1)&&e.throwInvalidArgumentException("");const t=new r.Transformation2D,i=0===s?n:0,o=0===s?0:1;t.setShiftCoords(i,o),0===s?t.xx=0:t.yy=0,this.applyTransformation(t)}else super.setAttributeImpl(t,s,n)}}Pt.st_totalCurveCount=0;class ft{constructor(t,e){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new i.Envelope2D(e),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=t}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const t=this.m_parent.getAccelerators();t&&(this.m_quadTree=t.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const t=this.m_qtIter.next();if(-1===t)return null;const e=this.m_quadTree.getElement(t);return(e!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(e,this.m_segIter.getPathIndex()),this.m_prevIndex=e),this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const t=this.m_segIter.nextSegment(),e=i.Envelope2D.constructEmpty();if(t.queryLooseEnvelope(e),!e.isIntersecting(this.m_extentOfInterest))continue;return t}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}}class yt extends Pt{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!1}),this.m_segmentBufferCTor=qr):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=qr,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=qr):t.start?(super({vd:t.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=qr,this.startPathPoint(t.start),this.lineToPoint(t.end)):t.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=qr,this.addPathPoint2D(t.path,t.pointCount,t.bForward)):e.throwInternalErrorException("bad constructor arg"):(super({bPolygon:!1}),this.m_segmentBufferCTor=qr)}getBoundary(){return Dt(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}assignMove(t){return t.copyTo(this),this}getGeometryType(){return yt.type}getDimension(){return 1}createInstance(){return new yt({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}yt.type=e.GeometryType.enumPolyline;var xt=e.GeometryType;function Dt(t,n){const i=t.getGeometryType();if(i===xt.enumPolygon){const e=new yt({vd:t.getDescription()});return t.isEmpty()||t.copyToUnchecked(e),e}if(i===xt.enumPolyline)return vt(t.getImpl(),0,!1).boundary;if(i===xt.enumEnvelope){const e=new yt({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(e.isSegment(i)){const e=new g({vd:t.getDescription()});if(!t.isEmpty()&&!t.isClosed()){const n=new s.Point;e.reserve(2),t.queryStart(n),e.add(n),t.queryEnd(n),e.add(n)}return e}if(i===xt.enumGeometryCollection){const e=t;let s=null;for(let i=0,r=e.getGeometryCount();i<r;i++){const r=Dt(e.getGeometry(i),n);if(null!==r){null===s&&(s=t.createInstance());const e=r;s.addGeometry(e)}}return s}if(e.isPoint(i))return new s.Point({vd:t.getDescription()});e.throwNotImplementedException("")}function vt(t,e,i){const r=!1,o=t;let a=null;if(i||(a=new g({vd:o.getDescription()})),!o.isEmpty()){const t=new s.AttributeStreamOfInt32(0);for(let e=0,s=o.getPathCount();e<s;e++)if(o.getPathSize(e)>0&&!o.isClosedPathInXYPlane(e)){const s=o.getPathStart(e);t.add(s);const n=o.getPathEnd(e)-1;t.add(n)}if(t.size()>0){const e=new s.BucketSort,r=o.getAttributeStreamRef(0),m={userSort(t,e,s){const i=n.Point2D.getNAN(),o=n.Point2D.getNAN();s.sort(t,e,(t,e)=>(r.queryPoint2D(2*t,i),r.queryPoint2D(2*e,o),i.compare(o)))},getValue:t=>r.read(2*t+1)};e.sort(t,0,t.size(),m);let h=r.readPoint2D(2*t.read(0)),u=0,l=1;const c=new s.Point;for(let e=1,s=t.size();e<s;e++){const s=r.readPoint2D(2*t.read(e));if(s.isEqualPoint2D(h))t.read(u)>t.read(e)?(t.write(u,n.indexTypeMax()),u=e):t.write(e,n.indexTypeMax()),l++;else{if(1&l){if(i)return{bNotEmpty:!0,boundary:new g({})}}else t.write(u,n.indexTypeMax());h=s,u=e,l=1}}if(1&l){if(i)return{bNotEmpty:!0,boundary:new g({})}}else t.write(u,n.indexTypeMax());if(!i){t.sort(0,t.size());for(let e=0,s=t.size();e<s&&t.read(e)!==n.indexTypeMax();e++)o.getPointByVal(t.read(e),c),a.add(c)}}}return i?{bNotEmpty:r,boundary:new g({})}:{bNotEmpty:r,boundary:a}}function Et(t,s,i,r){const o=4*n.doubleEps()*(Math.abs(s.vmin)+Math.abs(s.vmax)),a=n.doubleEps();if(1===t.getMaxDerivative()){e.geometryReleaseAssert(i>0);const a=wt(t,0,s,n.doubleEps(),o);return r[0]=a.root,a.cRoots}let m,h=[];const u=new n.Envelope1D(s.vmin-o,s.vmax+o);h.push(new n.Point2D(u.vmin,u.vmax));let l=0;for(let e=t.getMaxDerivative()-1;e>=0;e--){m=h,h=[];for(let u=0,c=m.length;u<c;u++){if(m[u][0]<m[u][1]){let c,g,d;if(e===t.getMaxDerivative()-1?({root:c,funcAtRoot:g,cRoots:d}=wt(t,e,n.Envelope1D.construct(m[u][0],m[u][1]),a,.5*o)):({root:c,funcAtRoot:g,cRoots:d}=St(t,e,n.Envelope1D.construct(m[u][0],m[u][1]),0,.5*o)),1===d){if(0===e)l<i&&(m[u][0]<=s.vmin&&m[u][1]>=s.vmin&&c!==s.vmin&&0===t.getValue(0,s.vmin)&&(c=s.vmin),m[u][0]<=s.vmax&&m[u][1]>=s.vmax&&c!==s.vmax&&0===t.getValue(0,s.vmax)&&(c=s.vmax),r[l]=s.snapClip(c),l>0?r[l]-r[l-1]>o&&l++:l++);else{const t=n.Point2D.getNAN();t[0]=m[u][0],t[1]=c,h.push(t);const e=n.Point2D.getNAN();e[0]=c,e[1]=m[u][1],h.push(e)}continue}}h.push(m[u])}}return l}function Ct(t,e,s,i,r,o){const a=n.makeObjectArray(n.ECoordinate,2),m=Mt(new n.ECoordinate(t),new n.ECoordinate(e),new n.ECoordinate(s),i,r,a);return o[0]=a[0].value(),o[1]=a[1].value(),m}function bt(t,e,s,i,r,o,a){const m=n.makeObjectArray(n.ECoordinate,3),h=Nt(new n.ECoordinate(t),new n.ECoordinate(e),new n.ECoordinate(s),new n.ECoordinate(i),r,o,m);return a[0]=m[0].value(),a[1]=m[1].value(),a[2]=m[2].value(),h}function At(t,e,s,i,r,o,a,m){return function(t,e,s,i,r,o,a,m){const h=n.makePrimitiveArray(s*s,Number.NaN);h.fill(0),n.memcpy(m,i,0,0,s);const u=n.makePrimitiveArray(s,Number.NaN),l=n.makePrimitiveArray(s,Number.NaN),c=n.makePrimitiveArray(s,Number.NaN);let g=t(m,s,e),d=0;for(d=0;d<100;d++){const i=g;for(let t=0;t<s;++t)l[t]=m[t];if(d%s===0){h.fill(0);for(let t=0;t<s;t++)h[t*s+t]=1}let a=0,p=0;for(let n=0;n<s;++n){for(let t=0;t<s;++t)u[t]=h[n*s+t];const i=g;g=Tt(t,e,m,u,r,o,s);const l=i-g;l>a&&(p=n,a=l)}for(let t=0;t<s;t++)u[t]=m[t]-l[t],c[t]=m[t]+(m[t]-l[t]);const _=t(c,s,e);if(_<i&&2*(i-2*g+_)*n.sqr(i-g-a)<n.sqr(i-_)*a){g=Tt(t,e,m,u,r,o,s);for(let t=0;t<s;++t)h[p*s+t]=h[(s-1)*s+t],h[(s-1)*s+t]=u[t]}if(i<=g)return t(m,s,e)}return g}(t,e,s,i,r,o,0,m)}function wt(t,s,i,r,o){const a={root:0,funcAtRoot:0,cRoots:0};let m=i.vmin,h=i.vmax,u=0,l=Number.MAX_VALUE,c=t.getValue(s,m),g=t.getValue(s,h),d=0,p=0,_=0;if(c>=0&&g>=0||c<=0&&g<=0)return Math.abs(c)<Math.abs(g)?(a.funcAtRoot=c,a.root=m,a.cRoots=0===c?1:0,a):(a.funcAtRoot=g,a.root=h,a.cRoots=0===g?1:0,a);Math.abs(c)<Math.abs(g)&&(h=n.swap(m,m=h),g=n.swap(c,c=g)),u=m,d=c;let P=!0,f=0;for(;0!==g&&Math.abs(m-h)>r*Math.abs(h)+o;f++){let i=f>64;if(!i){p=c!==d&&g!==d?m*g*d/((c-g)*(c-d))+h*c*d/((g-c)*(g-d))+u*c*g/((d-c)*(d-g)):h-g*(h-m)/(g-c);const t=(3*m+h)/4;if(i=!(p>t&&p<h||p>h&&p<t),!i){const t=r*Math.abs(h)+o;if(P){const e=Math.abs(h-u);i=Math.abs(p-h)>=.5*e||e<t}else{const e=Math.abs(u-l);i=Math.abs(p-h)>=.5*e||e<t}}}if(i?(p=(m+h)/2,P=!0):P=!1,_=t.getValue(s,p),0===_)return a.root=p,a.funcAtRoot=_,a.cRoots=1,a;if(!i){const e=m-p,i=p-h;if(Math.abs(e)>10*Math.abs(i)){let e=h+3*i;for(let i=0;i<2;i++){const i=t.getValue(s,e);n.sign(c)*n.sign(i)>0?(m=e,c=i):e=n.lerp(m,h,.75)}}else if(Math.abs(i)>10*Math.abs(e)){let i=m-3*e;for(let e=0;e<2;++e){const e=t.getValue(s,i);n.sign(g)*n.sign(e)>0?(h=i,g=e):i=n.lerp(m,h,.25)}}}l=u,u=h,d=g,n.sign(c)*n.sign(_)<0?(h=p,g=_):(m=p,c=_),Math.abs(c)<Math.abs(g)&&(h=n.swap(m,m=h),g=n.swap(c,c=g)),128===f&&e.throwInternalErrorException("Root_finder iterations exceeded")}return a.root=h,a.funcAtRoot=g,a.cRoots=1,a}function St(t,s,i,r,o){const a={root:0,funcAtRoot:0,cRoots:0};let m=i.vmin,h=t.getValue(s,m),u=i.vmax,l=t.getValue(s,u);if(h>=0&&l>=0||h<=0&&l<=0)return Math.abs(h)<Math.abs(l)?(a.funcAtRoot=h,a.root=m,a.cRoots=0===h?1:0,a):(a.funcAtRoot=l,a.root=u,a.cRoots=0===l?1:0,a);l<0&&(l=n.swap(h,h=l),u=n.swap(m,m=u));let c=.5*(m+u),g=Math.abs(u-m),d=g,p=t.getValue(s,c),_=t.getValue(s+1,c),P=4,f=1,y=0,x=0,D=1,v=0;for(;++v<100;){let e;v>32||0===_||2===D&&y>1||1===D&&P<4?(D=1,f>1&&f--):(D=2,x>1&&Math.abs(2*p)>Math.abs(g*_)&&f++),g=d;let n=!1;if(1===D)do{if(x>2){const t=16*Math.abs(g);if(.5*Math.abs(m-u)>t){const s=Math.min(m,u),n=Math.max(m,u);if(c===s){e=c,c=s+t,d=c-e;break}if(c===n){e=c,c=n-t,d=c-e;break}}}d=.5*(u-m),e=c,c=m+d,n=m===c||u===c}while(0);else for(;;){d=f*p/_,e=c,c-=d,n=c===e;const t=Math.min(m,u),s=Math.max(m,u);if(c<t){if(f>1){c=e,f--;continue}d=e-t,c=t}else if(c>s){if(f>1){c=e,f--;continue}d=e-s,c=s}break}if(n||Math.abs(d)<o){e!==c&&(p=t.getValue(s,c));break}p=t.getValue(s,c),_=t.getValue(s+1,c);const i=m,r=u;p<0?(h=p,m=c):(l=p,u=c),2===D&&(m===i&&u===r||x>1&&Math.abs(d)>=.5001*Math.abs(g))?y++:y=0,1===D?(P++,x=0):(P=0,x++)}return 100===v&&e.throwInternalErrorException("Root_finder iterations exceeded"),a.root=c,a.funcAtRoot=p,a.cRoots=1,a}function Tt(t,e,s,i,r,o,a){const m=i.slice(0,a);let h=0;for(let t=0;t<a;t++)h+=i[t]*i[t];if(h=Math.sqrt(h),h>0)for(let t=0;t<a;t++)m[t]/=h;let u=Number.NEGATIVE_INFINITY,l=Number.POSITIVE_INFINITY;{const t=n.makePrimitiveArray(a,0);for(let e=0;e<a;e++)t[e]=e;t.sort((t,e)=>{const s=Math.abs(m[t]),n=Math.abs(m[e]);return s<n?-1:s>n?1:0});for(let e=0;e<a;e++){const i=t[e];if(0===m[i])continue;let a=(r[i]-s[i])/m[i],h=(o[i]-s[i])/m[i];h<a&&(h=n.swap(a,a=h)),a>u&&(u=a),h<l&&(l=h)}}let c=0;const g=(Math.abs(u)+Math.abs(l))*n.doubleEps()*100,d=n.makePrimitiveArray(a,Number.NaN),p=m.slice();function _(n,i){for(let t=0,e=a;t<e;t++)d[t]=s[t]+n*p[t];return t(d,a,e)}g>0&&(c=function(t,e,s,i,r,o){return function(t,e,s,i,r,o){const a=n.goldenRatio();let m=0,h=t(m,e),u=s,l=r,c=t(u,e),g=t(l,e);h>c&&(h=c,m=u),h>g&&(h=g,m=l);let d=u,p=l,_=c,P=g;_>P&&(_=n.swap(P,P=_),p=n.swap(d,d=p));let f=m-d,y=d-p;const x=.5*Math.min(o,l-u),D=2*x;let v,E=0;for(v=0;v<100&&!(l-u<=D);++v){const s=u+.5*(l-u);let n=E>0;if(!n&&Math.abs(y)<=x&&(n=!0,E=3),!n){const t=m-d,e=m-p,s=t*(h-P);let i=e*(h-_),r=e*i-t*s;i=2*(i-s),i>0&&(r=-r),i=Math.abs(i),0===i||Math.abs(r)>=Math.abs(i*y/2)||r<=i*(u-m)||r>=i*(l-m)?(n=!0,E=3):(y=f,f=r/i)}n&&(y=m>=s?u-m:l-m,f=a*y,E--);let i=m+f;i<u+x?i=u+x:i>l-x&&(i=l-x);const r=t(i,e);r<h?(i>=m?(u=m,c=h):(l=m,g=h),p=d,d=m,m=i,P=_,_=h,h=r):(i<m?(u=i,c=r):(l=i,g=r),r<=_||d===m?(p=d,d=i,P=_,_=r):(r<=P||p===m||p===d)&&(p=i,P=r))}return m}(t,null,s,0,r,o)}(_,0,u,0,l,g));const P=_(c);for(let t=0,e=a;t<e;t++)s[t]=n.snap(d[t],r[t],o[t]);return P}function It(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setE(e.clone().negateThis().divThisE(t)),s.containsCoordinate(n.value())?1:0)}function Mt(t,e,s,i,r,o){if(0===t.value())return r?(o[0].set(1),i.containsCoordinate(o[0].value())?1:0):It(e,s,i,o[0]);if(r){let e=2;return o[0].set(1),o[1].setE(s).divThisE(t),o[1].eq(o[0])&&(o[1].set(1),e=1),i.containsCoordinate(o[1].value())||(e=1),i.containsCoordinate(o[0].value())||(e--,o[0].setE(o[1])),2===e&&o[0].value()>o[1].value()&&(o[1]=n.swap(o[0],o[0]=o[1])),e}const a=e.clone().sqrThis().subThisE(t.clone().mulThisE(s).mulThisE(n.s_four));if(a.lt(n.s_zero))return 0;const m=new n.ECoordinate(e.value()>=0?1:-1),h=a.clone().sqrtThis(),u=new n.ECoordinate(-.5).mulThisE(e.clone().addThisE(m.clone().mulThisE(h)));let l=0;o[0].setE(u.divE(t));const c=new n.ECoordinate(o[0].value()),g=new n.ECoordinate(t.value()).mulE(c).addE(new n.ECoordinate(e.value()).mulE(c).addE(new n.ECoordinate(s.value())));return g.isZero()||kt(o[0],t,e,s,o[0]),i.containsCoordinate(o[0].value())&&l++,0!==h.value()&&0!==u.value()?(o[l].assign(s.divE(u)),c.set(o[l].value()),g.assign(new n.ECoordinate(t.value()).mulE(c).addE(new n.ECoordinate(e.value()).mulE(c).addE(new n.ECoordinate(s.value())))),g.isZero()||kt(o[l],t,e,s,o[l]),i.containsCoordinate(o[l].value())&&l++,2===l&&o[0].value()>o[1].value()&&(o[1]=n.swap(o[0],o[0]=o[1])),l):l}function Nt(t,s,i,r,o,a,m){if(0===t.value())return Mt(s,i,r,o,a,m);if(a){let e=1;m[0].set(1);const i=m.slice(e),a=Mt(t,s.addE(t),r.negate(),o,!1,i);if(a>0){e+=a;for(let t=1;t<e;t++)m[t].eq(n.s_one)&&(m[e-1]=n.swap(m[t],m[t]=m[e-1]),e--)}const h=m.slice(0,e);h.sort((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0);for(let t=0;t<e;++t)m[t]=h[t];return e}return function(t,s,i,r,o,a){const m=n.makeObjectArray(n.ECoordinate,3);let h=0;const u=s.negate().divThisE(t.clone().mulThis(3));o.containsCoordinate(u.value())&&(m[0].setE(u),h=1);const l=n.makeObjectArray(n.ECoordinate,2),c=Mt(t.mul(3),s.mul(2),i,o,!1,l);if(c<0)return r.isZero()?-1:0;for(let t=0;t<c;t++)o.containsCoordinate(l[t].value())&&m[h++].setE(l[t]);n.sortRange(m,0,h,(t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0);const g=n.makeObjectArray(n.ECoordinate,5);g[0].set(o.vmin);for(let t=0;t<h;t++)g[1+t].setE(m[t]);g[1+h].set(o.vmax);const d=h+2;let p=1,_=0;{const e=g[0].clone();if(t.clone().mulThisE(e).addThisE(s).mulThisE(e).addThisE(i).mulThisE(e).addThisE(r).isZero()){const n=Yt(t,s,i,r);e.setError(n.estimateError(e.value())),a[_]=e,_++,p++}}for(let n=p;n<d;n++){const m=g[n].clone(),h=t.clone().mulThisE(m).addThisE(s).mulThisE(m).addThisE(i).mulThisE(m).addThisE(r).isZero();if(h||!g[n].eq(g[n-1])){if(h||Ft(g[n-1].value(),g[n].value(),g[n-1].clone().addThisE(g[n]).divThisByPower2(2),t,s,i,r,m)){if(_>0&&m.eq(a[_-1]))continue;if(_>=3&&e.throwInternalErrorException("cubic_polynomial_solver_too_many_roots"),h){const e=Yt(t,s,i,r);m.setError(e.estimateError(m.value()))}a[_]=m,_++}if(g[n].value()===o.vmax)break;h&&n++}}return _}(t,s,i,r,o,m)}function qt(t,s,i,r,o,a){return(a<s||s<0)&&e.throwInvalidArgumentException("nth_degree_real_roots"),function(t,e,s,i,r){const o=new Xt(t,e,s,n.doubleEps());let a=0;if(2===o.truePower)a=Mt(t[2],t[1],t[0],s,i,r);else if(1===o.truePower)a=It(t[1],t[0],s,r[0]);else{if(0===o.truePower)return t[0].value()?0:-1;{const t=[];t.length=e,a=Et(o,s,e,t);for(let e=0;e<a;e++)r[e].set(t[e])}}for(let t=0;t<a;t++)r[t].setError(o.getError(r[t].value()));return a}(t,s,i,r,o)}function Yt(t,e,s,n){return{coef0:t.clone(),coef1:e.clone(),coef2:s.clone(),coef3:n.clone(),calcF(t){return this.coef0.clone().mulThis(t).addThisE(this.coef1).mulThis(t).addThisE(this.coef2).mulThis(t).addThisE(this.coef3)},calcDF(t){return this.coef0.clone().mulThis(3).mulThis(t).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t).addThisE(this.coef2)},estimateError(t){const e=Math.abs(t),s=((this.coef0.eps()*e+this.coef1.eps())*e+this.coef2.eps())*e+this.coef3.eps()+this.calcF(t).eps(),n=this.coef0.clone().mulThis(t).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t).addThisE(this.coef2);if(n.isZero()){const e=this.coef0.clone().mulThis(t).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(e.isZero()){const t=this.coef0.clone().mulThis(6);return Math.pow(6*s/Math.abs(t.value()),1/3)}return Math.sqrt(2*s/Math.abs(e.value()))}return s/Math.abs(n.value())}}}class Xt{updateCoefs(t){if(this.lastDeriv1===t)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===t)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let e;1===this.lastUsed?(e=this.derivCoefs2,this.lastDeriv2=t,this.lastUsed=2):(e=this.derivCoefs1,this.lastDeriv1=t,this.lastUsed=1),e.length=0;for(let s=0,n=this.truePower-t;s<=n;++s){e.push(this.coefs[s+t].clone());let n=s+t,i=n--;for(let e=1;e<t;e++)i*=n--;e[s].mulThis(i)}this.curCoefs=e}constructor(t,e,s,n){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=t,this.power=e,this.truePower=0;for(let t=e;t>=1;t--)if(0!==this.coefs[t].value()){this.truePower=t;break}}getMaxDerivative(){return this.truePower+1}getValue(t,e){let s=this.coefs;0===t?s=this.coefs:(this.updateCoefs(t),s=this.curCoefs);const i=new n.KahanSummator(0);let r=1;for(let n=0,o=this.truePower-t;n<=o;++n)i.pe(r*s[n].value()),r*=e;return i.getResult()}getError(t){const e=Math.abs(t),s=new n.KahanSummator(0),i=new n.ECoordinate(1),r=new n.ECoordinate(0);for(let t=0,n=this.power;t<=n;++t)r.addThisE(this.coefs[t].mulE(i)),s.pe(i.value()*this.coefs[t].eps()),i.mulThis(e);s.pe(r.eps());let o=1;for(let e=1;e<=this.truePower;++e){o*=e,this.updateCoefs(e);const i=new n.ECoordinate(1),r=new n.ECoordinate(0);for(let s=0,n=this.truePower-e;s<=n;++s)r.addThisE(this.curCoefs[s].mulE(i)),i.mulThis(t);if(!r.isZero())return Math.pow(o*s.getResult()/Math.abs(r.value()),1/e)}return 0}}function Rt(t,e,s,i,r,o){let a=t,m=e,h=m-a;if(!o){let s=i.calcF(t).value(),r=i.calcF(e).value();if((s>0||s>r)&&(m=n.swap(a,a=m),r=n.swap(s,s=r)),s>=0||r<=0)return!1}let u,l=!1,c=s,g=0;for(;g<100;g++){const t=i.calcF(c);if(u=i.calcDF(c),u.isZero())return!1;if(!t.value()||g>3&&t.isZero()){l=!0;break}o||(t.value()<0?a=c:m=c);const e=t.value()/u.value(),s=c-e;o||(s>=a&&s<=m||s>=m&&s<=a)&&Math.abs(e)<=.5*h?(c=s,h=Math.abs(e)):(h=Math.abs(.5*(m-a)),c=.5*(a+m))}return!!l&&(r.set(c,i.estimateError(c)),!0)}function Ft(t,e,s,n,i,r,o,a){return Rt(t,e,s.value(),Yt(n,i,r,o),a,!1)}class Vt{constructor(t,e,s){this.coefs=n.makeObjectArray(n.ECoordinate,3),this.coefs[0].setE(t),this.coefs[1].setE(e),this.coefs[2].setE(s)}calcF(t){const e=new n.ECoordinate(t);return this.coefs[0].mulE(e).addE(this.coefs[1]).mulE(e).addE(this.coefs[2])}calcDF(t){const e=new n.ECoordinate(t);return n.ECoordinate.st_mulByPower2(this.coefs[0],2).mulE(e).addE(this.coefs[1])}estimateError(t){const e=Math.abs(t),s=(this.coefs[0].eps()*e+this.coefs[1].eps())*e+this.coefs[2].eps()+this.calcF(t).eps(),i=new n.ECoordinate(2).mulE(this.coefs[0]).mul(t).addE(this.coefs[1]);if(i.isZero()){const t=this.coefs[0].value();return Math.sqrt(s/Math.abs(t))}return s/Math.abs(i.value())}}function kt(t,e,s,n,i){return Rt(0,0,t.value(),new Vt(e,s,n),i,!0)}var Lt=s.VertexDescription;class zt extends W{constructor(t){return void 0===t||n.isOnlyProperty(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new n.Point2D(0,0),void(this.m_weights=[1,0,1])):(t.fromPoint&&t.weight?t={fromPoint:t.fromPoint,controlPoint1:t.controlPoint1,toPoint:t.toPoint,weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weight?t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weights&&(t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:t.weights[0],weight1:t.weights[1],weight2:t.weights[2]}),t.fromPoint&&t.weight0?(super({start:t.fromPoint,end:t.toPoint}),(t.weight0<=0||t.weight1<0||t.weight2<=0)&&e.throwInvalidArgumentException("weights"),this.m_cp=t.controlPoint1.clone(),void(this.m_weights=[t.weight0,t.weight1,t.weight2])):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone(),void(this.m_weights=t.copy.m_weights.slice())):t.move?(super(t),this.m_cp=t.move.m_cp.clone(),void(this.m_weights=t.move.m_weights.slice())):void e.throwNotImplementedException("unexpected constructor param"))}getBoundary(){return Dt(this)}assignMove(t){return this}assignCopy(t){return t.copyTo(this),this}construct(t,e,s,n){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,1,n,1),vn(this)}constructWeights(t,e,s,n,i,r){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,n,i,r),vn(this)}constructArray(t,e){this.construct(t[0],t[1],t[2],e)}constructArrayWeights(t,e){this.dropAllAttributes(),this.setCpsAndWeightsArray(t,e),vn(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return e.GeometryType.enumRationalBezier2}queryEnvelope(t){if(t instanceof i.Envelope2D){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=Xn(this);if(null!==e){const s=new n.Point2D;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[],s=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(s),Cn(s,this.m_weights,e);const i=new n.Point2D;for(const s of e)this.queryCoord2D(s,i),t.mergeNe(i)}}}applyTransformation(t){if(t instanceof r.Transformation2D){const e=n.makeObjectArray(n.Point2D,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}}createInstance(){return new zt({vd:this.m_description})}calculateLength2D(){return bn(this,1,!1)}calculateLowerLength2D(){return n.Point2D.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return this.m_weights[1]>0?n.Point2D.distance(this.getStartXY(),this.m_cp)+n.Point2D.distance(this.getEndXY(),this.m_cp):n.Point2D.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(t,e){return this.queryCoord2DExtension(t,e,!0)}queryCoord2DE(t,e){!function(t,e,s){const i=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(i);const r=[0,0,0];t.queryWeights(r),function(t,e,s,i){if(0===s.value())return void i.setE(t[0]);if(1===s.value())return void i.setE(t[2]);const r=[t[0].x.mulE(e[0]),t[1].x.mulE(e[1]),t[2].x.mulE(e[2])],o=[t[0].y.mulE(e[0]),t[1].y.mulE(e[1]),t[2].y.mulE(e[2])],a=[e[0].clone(),e[1].clone(),e[2].clone()],m=new n.ECoordinate,h=new n.ECoordinate,u=new n.ECoordinate;if(s.value()<=.5){const t=n.lerpLoE(r[0],r[1],s),e=n.lerpLoE(r[1],r[2],s);m.setE(n.lerpLoE(t,e,s));const i=n.lerpLoE(o[0],o[1],s),l=n.lerpLoE(o[1],o[2],s);h.setE(n.lerpLoE(i,l,s));const c=n.lerpLoE(a[0],a[1],s),g=n.lerpLoE(a[1],a[2],s);u.setE(n.lerpLoE(c,g,s))}else{const t=n.lerpHiE(r[0],r[1],s),e=n.lerpHiE(r[1],r[2],s);m.setE(n.lerpHiE(t,e,s));const i=n.lerpHiE(o[0],o[1],s),l=n.lerpHiE(o[1],o[2],s);h.setE(n.lerpHiE(i,l,s));const c=n.lerpHiE(a[0],a[1],s),g=n.lerpHiE(a[1],a[2],s);u.setE(n.lerpHiE(c,g,s))}m.divThisE(u),h.divThisE(u);const l=new n.Point2D(m.value(),h.value());li([t[0].value(),t[1].value(),t[2].value()],l),i.x.set(l.x,m.eps()),i.y.set(l.y,h.eps())}([f.constructPoint2D(i[0]),f.constructPoint2D(i[1]),f.constructPoint2D(i[2])],[new n.ECoordinate(r[0]),new n.ECoordinate(r[1]),new n.ECoordinate(r[2])],e,s)}(this,t,e)}queryCoord2DExtension(t,e,s){if(s){if(t<0)return void Z(new Nr({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),t,e);if(t>1)return void Z(new Nr({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),t-1,e)}const i=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(i),ii(i,this.m_weights,t,e)}getCoordX(t){const e=new n.Point2D;return this.queryCoord2DExtension(t,e,!0),e.x}getCoordY(t){const e=new n.Point2D;return this.queryCoord2DExtension(t,e,!0),e.y}cut(t,e,s){const n=new qr;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=Lt.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=Lt.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,s){!function(t,s,i){const r=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(r);const o=n.makePrimitiveArray(3,Number.NaN);t.queryWeights(o),function(t,s,i,r){i.value()<0&&i.set(0,i.eps()),i.value()>1&&i.set(1,i.eps());const o=n.makeObjectArray(f,4);(function(t,s,i,r,o){const a=[f.constructPoint2D(t[0]),f.constructPoint2D(t[1]),f.constructPoint2D(t[2])];a[2].subThisE(a[0]),a[1].subThisE(a[0]),a[0].setCoords(0,0),function(t,s,i,r,o){e.geometryReleaseAssert(!0);const a=[t[0].clone(),t[1].clone(),t[2].clone()];if(!a[0].isZero()){for(let t=1;t<3;++t)a[t].subThisE(a[0]);a[0]=f.constructCoords(0,0)}const m=Tn(a,s,0,r),h=function(t,e,s){if(s.toDouble()<=.5){const e=n.lerpLoE(t[0],t[1],s),i=n.lerpLoE(t[1],t[2],s);return n.lerpLoE(e,i,s)}{const e=n.lerpHiE(t[0],t[1],s),i=n.lerpHiE(t[1],t[2],s);return n.lerpHiE(e,i,s)}}(s,0,r),u=m.divE(h);o[0].setE(u);const l=[s[1].mulE(s[0]),s[2].mulE(s[0]).mul(.5),s[1].mulE(s[2])],c=Tn([t[1].subE(t[0]),t[2].subE(t[0]),t[2].subE(t[1])],l,0,r).mul(2),g=h.sqr(),d=c.divE(g);o[1].setE(d)}(a,[new n.ECoordinate(s[0]),new n.ECoordinate(s[1]),new n.ECoordinate(s[2])],0,r,o)})(t,s,0,i,o),r.setE(o[1])}(r,o,s,i)}(this,t,s)}cutBezierIgnoreAttributes(t,s,i){(t<0||s>1||t>s)&&e.throwInvalidArgumentException("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const r=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(r);const o=[0,0,0];Bn(r,this.m_weights,t,s,r,o),i.setControlPointsAndWeights(r,o)}splitBezierIgnoreAttributes(t,e,s){}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const i=this.calculateLength2D(),r=i>0?this.tToLength(t)/i:0,o=Lt.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),m=this.getEndAttributeAsDbl(e,s);return n.interpolate(o,a,m,r,Lt.getDefaultValue(e))}getClosestCoordinate(t,e){return Fn(this,t,n.Envelope1D.unit(),e,-1)}getClosestCoordinateOnInterval(t,e,s=-1){return Fn(this,t,0,!1,s)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,s){t.length<2&&e.throwInvalidArgumentException("");const n=En(this);let i=0;if(2===n.specialPointsCount())return 0;e.geometryReleaseAssert(t.length>=n.specialPointsCount()-1);for(let e=1,r=n.specialPointsCount();e<r;++e)this.queryCut(n.specialPoints[e-1],n.specialPoints[e],t[i],s),i++;for(let e=0;e<i;++e)Gn(t[e].get());return i}intersectionWithAxis2D(t,e,s,i){s&&(s.length=9),i&&(i.length=9);const r=new Array(3),o=n.makeObjectArray(n.ECoordinate,2),a=new n.Envelope1D(0,1);let m=0;const h=n.makeObjectArray(n.Point2D,3);if(this.queryControlPoints(h),t){if(r[0]=new n.ECoordinate(h[0].y).sub(e).mul(this.m_weights[0]),r[1]=new n.ECoordinate(h[1].y).sub(e).mul(this.m_weights[1]),r[2]=r[0].subE(r[1].mul(2)).addE(new n.ECoordinate(h[2].y).sub(e).mul(this.m_weights[2])),r[1]=r[1].subE(r[0]).mulThisByPower2(2),m=Mt(r[2],r[1],r[0],a,!1,o),s)for(let t=0;t<m;t++)s[t]=this.getCoordX(o[t].value())}else if(r[0]=new n.ECoordinate(h[0].x).sub(e).mul(this.m_weights[0]),r[1]=new n.ECoordinate(h[1].x).sub(e).mul(this.m_weights[1]),r[2]=r[0].subE(r[1].mul(2)).addE(new n.ECoordinate(h[2].x).sub(e).mul(this.m_weights[2])),r[1]=r[1].subE(r[0]).mulThisByPower2(2),m=Mt(r[2],r[1],r[0],a,!1,o),s)for(let t=0;t<m;t++)s[t]=this.getCoordY(o[t].value());if(i)for(let t=0;t<m;t++)i[t]=o[t].value();else s&&n.sortRange(s,0,m,n.standardNumericCompare);return m}intersectionOfYMonotonicWithAxisX(t,s){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?s:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const n=[Number.NaN,Number.NaN],i=this.intersectionWithAxis2D(!0,t,n,null);return e.geometryReleaseAssert(2!==i),-1===i?s:n[0]}isCurve(){return!0}isDegenerate(t){return C(this,t)}isDegenerate3D(t,e){return!1}queryLooseEnvelope(t){if(t instanceof i.Envelope2D)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY())}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=i.Envelope2D.constructEmpty();this.queryEnvelope(t);const s=n.Envelope1D.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(s),Bn(s,this.m_weights,t.vmin,t.vmax,s,[0,0,0]),e.setFromPoints(s,3)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return bn(this,t,!0)}lengthToT(t){const s=function(t,s){const i=bn(t,1,!1);if(s<=0)return s;if(s>=i)return s-i+1;const r=[0];return 1!==Et(new Nn(t,s),n.Envelope1D.unit(),1,r)&&e.throwInternalErrorException(""),r[0]}(this,t);return s}calculateWeightedAreaCentroid2D(t){const s=function(t){const s=n.makeObjectArray(n.Point2D,3),i=[0,0,0];return t.queryControlPoints(s),t.queryWeights(i),function(t,s){const i=oi(s);if(1===i){const e=n.makeObjectArray(n.Point2D,3);Ge(t,e);const s=e[2].clone(),i=e[1].clone(),r=new n.Point2D,o=s.y*i.x-s.x*i.y;return r.x=-(4*s.x+5*i.x)*o/60,r.y=-(4*s.y+5*i.y)*o/60,r}if(0===i)return new n.Point2D(0,0);e.geometryReleaseAssert(i>0);const r=t[1].sub(t[0]),o=t[2].sub(t[0]);if(i<1){const t=Math.sqrt(1-i),e=Math.sqrt(1+i),s=(r.y*o.x-r.x*o.y)*i/Math.pow(t*e,5)/12,n=Math.atan2(t,e),a=i*t*e,m=i*i,h=r.mul(2*(2+m)),u=o.mul(2*m-5),l=h.add(u).mul(a),c=o.sub(r.mul(2*m)).mul(6*n);return l.add(c).mul(s)}{const t=Math.sqrt(i-1),e=Math.sqrt(i+1),s=(r.y*o.x-r.x*o.y)*i/Math.pow(t*e,5)/12,n=Math.atanh(t/e),a=i*t*e,m=i*i,h=r.mul(4).sub(o.mul(5)),u=r.add(o).mul(2*m),l=h.add(u).mul(a),c=o.sub(r.mul(2*m)).mul(6*n);return l.add(c).mul(s)}}(s,i)}(this),i=qn(this);return s.x+=(this.getStartX()-t.x)*i,s.y+=(this.getStartY()-t.y)*i,s}calculateWeightedCentroid2D(){const t=new n.Point2D;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){if(0===t.m_weights[1])return!0;const e=n.Point2D.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,s,i){void 0===i&&(i=s,s=0);const r=new n.Point2D;if(s<0||i>1)return r.setNAN(),r;if(s>i&&e.throwInvalidArgumentException("calculate_sub_weighted_centroid"),s===i||t.isDegenerate(0))return r.setCoords(0,0),r;const o=En(t),a=Yn(t),m=a/t.calculateUpperLength2D();let h=s,u=0;for(let t=1,e=o.specialPointsCount();t<e;t++)if(s<o.specialPoints[t]){u=t-1;break}r.setCoords(0,0);for(let e=u+1,s=o.specialPointsCount();e<s;e++){const s=Math.min(o.specialPoints[e],i),n=Dn(t,h,s,m,a);if(r.addThis(n),h=s,i<=o.specialPoints[e])break}return r.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryWeights(t){for(let e=0;e<3;++e)t[e]=this.m_weights[e]}queryCoord2DMP(t,e){const s=n.makeObjectArray(n.Point2D,3);return this.queryControlPoints(s),function(t,e,s,i){const r=s.lte(n.s_half)?n.MPValue.lerpLo:n.MPValue.lerpHi,[o,a,m]=[e.map((e,s)=>t[s].x.mul(e)),e.map((e,s)=>t[s].y.mul(e)),e].map(([t,e,n])=>r(r(t,e,s),r(e,n,s),s)),h=new n.Point2D(o.divThis(m).value(),a.divThis(m).value());li(t.map(t=>t.asPoint2D()),h),i.x=n.MPValue.constructDouble(h.x),i.y=n.MPValue.constructDouble(h.y)}(s.map(t=>x.constructPoint2D(t)),this.m_weights.map(t=>n.MPValue.constructDouble(t)),n.MPValue.constructDouble(t),e)}setWeights(t){}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),3}setControlPointsAndWeights(t,e){this.setCpsAndWeightsArray(t,e),this.afterCompletedModification()}getTangent(t){const e=n.makeObjectArray(n.Point2D,3);return this.queryControlPoints(e),Mn(e,this.m_weights,t)}getDerivative(t){const e=n.snap(t,0,1),s=n.makeObjectArray(n.Point2D,4);return An(this,1,e,s),s[1]}getCurvature(t){const e=n.makeObjectArray(n.Point2D,4);An(this,2,t,e);const s=e[1].sqrLength();return 0===s?Number.NaN:(e[1].divThis(Math.sqrt(s)),e[1].crossProduct(e[2])/s)}isIntersecting(t,e,s){return!1}isIntersectingPoint(t,e,s){return!1}isIntersectingPoint3D(t,e,s,n,i=1){return!1}isMonotoneQuickAndDirty(){const t=n.makeObjectArray(n.Point2D,3);return this.queryControlPoints(t),zn(t)}getMonotonicPartParams(t,s){const n=En(this),i=n.specialPointsCount();if(!s)return n.specialPointsCount();t<i&&e.throwInvalidArgumentException("");for(let t=0;t<i;t++)s[t]=n.specialPoints[t];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=n.swap(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=n.swap(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=n.swap(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=n.swap(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(t){const e=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(e);const s=e[2].sub(e[0]),i=s.length();if(n.Point2D.distance(e[0],e[1])+n.Point2D.distance(e[2],e[1])-i>t)return!1;const r=t,o=e[1].clone();return o.subThis(e[0]),!(Math.abs(o.crossProduct(s))/i>r)}copyIgnoreAttributes(t){const e=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(e);const s=[0,0,0];this.queryWeights(s),t.setControlPointsAndWeights(e,s)}calculateArea2DHelper(){return qn(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(t){return e.geometryReleaseAssert(0),0}queryEnvelopeW(t,e){kn(this,t,e)}setSegmentFromCoordsForStitcher(t,e){const s=[0,0,0];this.queryWeights(s),this.constructWeights(t[0],this.getControlPoint1(),t[e-1],s[0],s[1],s[2])}writeInBufferStream(t,e){const s=new Float64Array(5);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,s[2]=this.m_weights[0],s[3]=this.m_weights[1],s[4]=this.m_weights[2],t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(5);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_weights[0]=s[2],this.m_weights[1]=s[3],this.m_weights[2]=s[4],this.m_cachedValues=null}snapControlPoints(t){const e=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(e);const s=n.Point2D.sqrDistance(e[1],e[0]),i=n.Point2D.sqrDistance(e[1],e[2]);let r=e[0].clone(),o=s;s>i&&(r=e[2].clone(),o=i);let a=!1;return o<=t&&0!==o&&(a=!0,this.setControlPoint1(r)),a}needsSnapControlPoints(t){if(!t)return!1;const e=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(e);const s=n.Point2D.sqrDistance(e[1],e[0]),i=n.Point2D.sqrDistance(e[1],e[2]);e[0].clone();let r=s;return s>i&&(e[2].clone(),r=i),r<=t&&0!==r}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return Gn(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,i){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const o=!!i&&t.isMonotoneQuickAndDirty(),a=new r.Transformation2D,m=n.makeObjectArray(n.Point2D,3);m[0].setCoords(t.m_XStart,t.m_YStart),m[2].setCoords(t.m_XEnd,t.m_YEnd);const h=new n.Point2D;h.setSub(m[2],m[0]),h.leftPerpendicularThis(),m[1].setAdd(m[0],h);const u=n.makeObjectArray(n.Point2D,3);u[0].setCoordsPoint2D(e),u[2].setCoordsPoint2D(s),h.setSub(u[2],u[0]),h.leftPerpendicularThis(),u[1].setAdd(u[0],h),a.setFromTwoTriangles(m,u)?a.transformInPlace(t.m_cp):n.lerpPoint2D(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),o&&Gn(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),e.m_weights[0]=this.m_weights[0],e.m_weights[1]=this.m_weights[1],e.m_weights[2]=this.m_weights[2],Rn(e,Xn(this))}reverseImpl(){this.m_weights[2]=n.swap(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(t){const e=t;if(!this.m_cp.equals(e.m_cp))return!1;for(let t=0;t<3;t++)if(this.m_weights[t]!==e.m_weights[t])return!1;return!0}equalsImplTol(t,e){const i=t;if(!this.m_cp.isEqualPoint2D(i.m_cp,e))return!1;const r=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(r);const o=n.makeObjectArray(n.Point2D,3);i.queryControlPoints(o);const a=[i.m_weights[0],i.m_weights[1],i.m_weights[2]];for(let t=0;t<3;t++){const n=new s.Point3D;n.setCoordsPoint2DZ(r[t].mul(this.m_weights[t]),this.m_weights[t]);const i=new s.Point3D;if(i.setCoordsPoint2DZ(o[t].mul(a[t]),a[t]),!n.isEqual(i,e))return!1}return!0}swapImpl(t){const e=t;var s;e.m_cp=n.swap(this.m_cp,this.m_cp=e.m_cp),e.m_weights=n.swap(this.m_weights,this.m_weights=e.m_weights),(s=e).m_cachedValues=n.swap(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){vn(this)}intersect(t,e,s,n,i){return wr(!1,this,t,e,s,n,i)}intersectPoint(t,s,i){return function(t,s,i,r){const o=new d;if(kn(t,n.Envelope1D.unit(),o),o.inflate(r),!o.isIntersectingPoint2D(s))return 0;const a=En(t);let m=0;const h=[];let u=a.specialPoints[0];for(let n=1,i=a.specialPoints.length;n<i;++n){const i=a.specialPoints[n],r=xn(t,s,u,i);if(0===h.length)h.push(r);else if(r.t===r.tmin)e.geometryReleaseAssert(h.at(-1).d<=r.d),h.at(-1).tmax=r.tmax;else if(h.at(-1).t===h.at(-1).tmax){e.geometryReleaseAssert(h.at(-1).d>=r.d);const t=h.at(-1).tmin;h[h.length-1]=r,h.at(-1).tmin=t}else h.push(r);u=i}for(const t of h)if(t.d<=r){const e=t.t;i?(i[m]=e,m++):m++}return m}(this,t,s,i)}endPointModified(){vn(this)}clearEndPointModified(){}setCpsAndWeights(t,s,n,i,r,o){(i<=0||o<=0||r<0)&&e.throwInvalidArgumentException("weights"),(t.isNAN()||s.isNAN()||n.isNAN())&&e.throwInvalidArgumentException("NAN control points in bezier are not supported"),this.setStartXY(t),this.m_cp.assign(s),this.m_weights[0]=i,this.m_weights[1]=r,this.m_weights[2]=o,this.setEndXY(n)}setCpsAndWeightsArray(t,e){this.setCpsAndWeights(t[0],t[1],t[2],e[0],e[1],e[2])}}zt.type=e.GeometryType.enumRationalBezier2;var Gt=s.VertexDescription;class Ot extends W{constructor(t){void 0===t||n.isOnlyProperty(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new n.Point2D(0,0)):t.from?(super({XStart:t.from.x,YStart:t.from.y,XEnd:t.to.x,YEnd:t.to.y,...t.vd}),this.m_cp=t.cp.clone()):t.points?(super({XStart:t.points[0].x,YStart:t.points[0].y,XEnd:t.points[2].x,YEnd:t.points[2].y,...t.vd}),this.m_cp=t.points[1].clone()):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone()):e.throwInternalErrorException("unexpected constructor args")}getBoundary(){return Dt(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}construct(t,e,s){this.setStartXY(t),this.m_cp.assign(e),this.setEndXY(s),_e(this)}constructPoints(t){this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),_e(this)}getGeometryType(){return e.GeometryType.enumBezier2}queryEnvelope(t){if(2===t.m_EnvelopeType){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=we(this);if(null!==e){const s=new n.Point2D;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[];fe(this,e);const s=new n.Point2D;for(const n of e)this.queryCoord2D(n,s),t.mergeNe(s)}return}e.throwNotImplementedException("env type not impl")}applyTransformation(t){if(1===t.m_TransformationType){const e=n.makeObjectArray(n.Point2D,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}e.geometryReleaseAssert(0)}createInstance(){return new Ot({vd:this.m_description})}calculateLength2D(){return ye(this,1,!1)}calculateLowerLength2D(){return n.Point2D.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return n.Point2D.distance(this.getStartXY(),this.m_cp)+n.Point2D.distance(this.getEndXY(),this.m_cp)}queryCoord2D(t,e){this.queryCoord2DExtended(t,e,!1)}queryCoord2DExtended(t,e,s){const i=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(i),je(i,t,e,s)}queryCoord2DE(t,e){!function(t,e,s){const i=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(i),function(t,e,s){if(e.value()<=.5){const i=f.constructPoint2D(t[1]),r=new f;n.lerpLoPointE(2,f.constructPoint2D(t[0]),i,e,r);const o=new f;n.lerpLoPointE(2,i,f.constructPoint2D(t[2]),e,o);const a=new f;n.lerpLoPointE(2,r,o,e,a),s.setE(a)}else{const i=f.constructPoint2D(t[1]),r=new f;n.lerpHiPointE(2,f.constructPoint2D(t[0]),i,e,r);const o=new f;n.lerpHiPointE(2,i,f.constructPoint2D(t[2]),e,o);const a=new f;n.lerpHiPointE(2,r,o,e,a),s.setE(a)}}(i,e,s)}(this,t,e)}queryCoord2DMP(t,s){e.geometryReleaseAssert(!1,"bernstein polynomials not ported")}getCoordX(t){if(t<0||t>1){const e=new n.Point2D;return this.queryCoord2DExtended(t,e,!0),e.x}if(t<=.5){const e=n.lerpLo(this.getStartX(),this.m_cp.x,t),s=n.lerpLo(this.m_cp.x,this.getEndX(),t);return n.lerpLo(e,s,t)}{const e=n.lerpHi(this.getStartX(),this.m_cp.x,t),s=n.lerpHi(this.m_cp.x,this.getEndX(),t);return n.lerpHi(e,s,t)}}getCoordY(t){if(t<0||t>1){const e=new n.Point2D;return this.queryCoord2DExtended(t,e,!0),e.y}if(t<=.5){const e=n.lerpLo(this.getStartX(),this.m_cp.x,t),s=n.lerpLo(this.m_cp.x,this.getEndX(),t);return n.lerpLo(e,s,t)}{const e=n.lerpHi(this.getStartY(),this.m_cp.y,t),s=n.lerpHi(this.m_cp.y,this.getEndY(),t);return n.lerpHi(e,s,t)}}cut(t,e,s){const n=new qr;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=Gt.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=Gt.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){!function(t,e,s){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i),function(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(function(t,e,s){{const e=f.constructPoint2D(t[1]).subE(f.constructPoint2D(t[0])),i=new n.ECoordinate(1).subE(s),r=f.constructPoint2D(t[2]).subE(f.constructPoint2D(t[1])),o=e.mulE(i).addE(r.mulE(s));return o.mulThisE(new n.ECoordinate(2)),o}}(t,0,e))}(i,e,s)}(this,t,e)}cutBezierIgnoreAttributes(t,s,i){if((t<0||s>1||t>s)&&e.throwInvalidArgumentException("Quadratic_bezier.cut_bezier_ignore_attributes"),0===t&&1===s)return i.setStartXY(this.getStartXY()),i.m_cp.assign(this.m_cp),void i.setEndXY(this.getEndXY());const r=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(r),Re(r,t,s,r),i.constructPoints(r)}splitBezierIgnoreAttributes(t,s,n){e.geometryReleaseAssert(0)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const i=this.calculateLength2D(),r=i>0?this.tToLength(t)/i:0,o=Gt.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),m=this.getEndAttributeAsDbl(e,s);return n.interpolate(o,a,m,r,Gt.getDefaultValue(e))}getClosestCoordinate(t,e){return Te(this,t,n.Envelope1D.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return Te(this,t,e,!1)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,s){t.length<2&&e.throwInvalidArgumentException("");const n=Pe(this);let i=0;if(2===n.specialPointsCount())return 0;e.geometryReleaseAssert(t.length>=n.specialPointsCount()-1);for(let e=1,r=n.specialPointsCount();e<r;++e)this.queryCut(n.specialPoints[e-1],n.specialPoints[e],t[i],s),i++;for(let e=0;e<i;++e)qe(t[e].get());return i}intersectionWithAxis2D(t,e,s,i){const r=n.makeObjectArray(n.ECoordinate,3),o=n.makeObjectArray(n.ECoordinate,2),a=new n.Envelope1D(0,1);let m=0;if(t){if(r[0]=new n.ECoordinate(this.getStartY()).sub(e),r[1]=new n.ECoordinate(this.m_cp.y).subE(new n.ECoordinate(this.getStartY())).mulThisByPower2(2),r[2]=new n.ECoordinate(this.getStartY()).add(this.getEndY()).subE(new n.ECoordinate(this.m_cp.y).mulThisByPower2(2)),m=Mt(r[2],r[1],r[0],a,!1,o),s)for(let t=0;t<m;t++)s[t]=this.getCoordX(o[t].value())}else if(r[0]=new n.ECoordinate(this.getStartX()).sub(e),r[1]=new n.ECoordinate(this.m_cp.x).subE(new n.ECoordinate(this.getStartX())).mulThisByPower2(2),r[2]=new n.ECoordinate(this.getStartX()).add(this.getEndX()).subE(new n.ECoordinate(this.m_cp.x).mulThisByPower2(2)),m=Mt(r[2],r[1],r[0],a,!1,o),s)for(let t=0;t<m;t++)s[t]=this.getCoordY(o[t].value());if(i)for(let t=0;t<m;t++)i[t]=o[t].value();else s&&n.numericSortRange(s,m);return m}intersectionOfYMonotonicWithAxisX(t,s){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?s:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const n=[0,0],i=this.intersectionWithAxis2D(!0,t,n,null);return e.geometryReleaseAssert(2!==i),-1===i?s:n[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(t){return C(this,t)}isDegenerate3D(t,s){return e.geometryReleaseAssert(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords(this.getStartXY()),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY());e.geometryReleaseAssert(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=new i.Envelope2D;this.queryEnvelope(t);const s=new n.Envelope1D;return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(s),Re(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return ye(this,t,!0)}lengthToT(t){const s=function(t,s){const i=ye(t,1,!1);if(s<=0)return s;if(s>=i)return s-i+1;const r=[0];return 1!==Et(new de(t,s),n.Envelope1D.unit(),1,r)&&e.throwInternalErrorException(""),r[0]}(this,t);return s}calculateWeightedAreaCentroid2D(t){const e=n.makeObjectArray(n.Point2D,3);!function(t,e,s=!1){const i=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(i),Ge(i,e,s)}(this,e);const s=e[2],i=e[1],r=new n.Point2D,o=s.y*i.x-s.x*i.y;r.x=-(4*s.x+5*i.x)*o/60,r.y=-(4*s.y+5*i.y)*o/60;const a=be(this);return r.x+=(e[0].x-t.x)*a,r.y+=(e[0].y-t.y)*a,r}calculateWeightedCentroid2D(){const t=new n.Point2D;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){const e=n.Point2D.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,s,i){void 0===i&&(i=s,s=0);const r=new n.Point2D;if(s<0||i>1)return r.setNAN(),r;if(s>i&&e.throwInvalidArgumentException("calculate_sub_weighted_centroid"),s===i||t.isDegenerate(0))return r.setCoords(0,0),r;const o=Pe(t),a=V(t),m=Math.min(a/t.calculateUpperLength2D(),1e-7);let h=s,u=0;for(let t=1,e=o.specialPointsCount();t<e;t++)if(s<o.specialPoints[t]){u=t-1;break}r.setCoords(0,0);for(let e=u+1,s=o.specialPointsCount();e<s;e++){const s=Math.min(o.specialPoints[e],i),n=pe(t,h,s,m,a);if(r.addThis(n),h=s,i<=o.specialPoints[e])break}return r.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),3}setControlPoints(t){for(let s=0;s<3;s++)t[s].isNAN()&&e.throwInvalidArgumentException("NaN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp.setCoordsPoint2D(t[1]),this.m_XEnd=t[2].x,this.m_YEnd=t[2].y,this.afterCompletedModification()}getTangent(t){const e=n.snap(t,0,1);let s=Ee(this,1,e);return s.isZero()&&(s=Ee(this,2,e),1===e&&s.negateThis()),s}getDerivative(t){return Ee(this,1,n.snap(t,0,1))}getCurvature(t){const e=Ee(this,1,t),s=Ee(this,2,t),n=e.sqrLength();return 0===n?Number.NaN:(e.divThis(Math.sqrt(n)),e.crossProduct(s)/n)}isIntersecting(t,e,s){return 0!==Er(!1,this,t,e,s)}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;const r=new i.Envelope2D;if(this.queryLooseEnvelope(r),r.inflateCoords(e,e),!r.contains(t))return!1;const o=this.getClosestCoordinate(t,!1),a=new n.Point2D;return this.queryCoord2D(o,a),n.Point2D.distance(a,t)<=e}isIntersectingPoint3D(t,s,n,i,r=1){return e.geometryReleaseAssert(0),!1}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(t,s){const n=Pe(this),i=n.specialPointsCount();if(!s)return n.specialPointsCount();t<i&&e.throwInvalidArgumentException("");for(let t=0;t<i;t++)s[t]=n.specialPoints[t];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){n.swap(this.m_XStart,this.m_XStart=this.m_XEnd),n.swap(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=n.swap(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isDegenerateToLineHelper(t){const e=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(e);const s=e[2].sub(e[0]),i=s.length();if(n.Point2D.distance(e[0],e[1])+n.Point2D.distance(e[2],e[1])-i>t)return!1;const r=t,o=e[1].clone();return o.subThis(e[0]),!(Math.abs(o.crossProduct(s))/i>r)}copyIgnoreAttributes(t){const e=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return be(this)}absNorm(){return(t=this).getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp.norm(1);var t}queryEnvelopeW(t,e){const s=n.makeObjectArray(n.Point2D,3);this.queryControlPoints(s),Me(s,t,e)}setSegmentFromCoordsForStitcher(t,e){this.construct(t[0],this.getControlPoint1(),t[e-1])}snapControlPoints(t){return function(t,e){const s=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(s);const i=n.Point2D.sqrDistance(s[1],s[0]),r=n.Point2D.sqrDistance(s[1],s[2]);let o=s[0].clone(),a=i;i>r&&(o=s[2].clone(),a=r);let m=!1;return a<=e&&0!==a&&(m=!0,t.setControlPoint1(o)),m}(this,t)}writeInBufferStream(t,e){const s=new Float64Array(2);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(2);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_cachedValues=null}needsSnapControlPoints(t){return function(t,e){if(!e)return!1;const s=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(s);const i=n.Point2D.sqrDistance(s[1],s[0]),r=n.Point2D.sqrDistance(s[1],s[2]);s[0].clone();let o=i;return i>r&&(s[2].clone(),o=r),o<=e&&0!==o}(this,t)}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return qe(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,i){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const o=!!i&&t.isMonotoneQuickAndDirty(),a=new r.Transformation2D,m=n.makeObjectArray(n.Point2D,3);m[0].setCoords(t.m_XStart,t.m_YStart),m[2].setCoords(t.m_XEnd,t.m_YEnd);const h=new n.Point2D;h.setSub(m[2],m[0]),h.leftPerpendicularThis(),m[1].setAdd(m[0],h);const u=n.makeObjectArray(n.Point2D,3);u[0].setCoordsPoint2D(e),u[2].setCoordsPoint2D(s),h.setSub(u[2],u[0]),h.leftPerpendicularThis(),u[1].setAdd(u[0],h),a.setFromTwoTriangles(m,u)?a.transformInPlace(t.m_cp):n.lerpPoint2D(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),o&&qe(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),Se(e,we(this))}reverseImpl(){}equalsImplTol(t,e){const s=t;return!!this.m_cp.isEqualPoint2D(s.m_cp,e)}equalsImpl(t){const e=t;return!!this.m_cp.equals(e.m_cp)}swapImpl(t){const e=t;var s;e.m_cp=n.swap(this.m_cp,this.m_cp=e.m_cp),(s=e).m_cachedValues=n.swap(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){_e(this)}intersect(t,e,s,n,i){return wr(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return function(t,e,s,i,r){const o=new d;if(function(t,e,s){const i=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(i),Me(i,e,s)}(t,n.Envelope1D.unit(),o),o.inflate(r),!o.isIntersectingPoint2D(e))return 0;const a=new n.Point2D,m=Te(t,e,n.Envelope1D.unit(),!1);return t.queryCoord2D(m,a),n.Point2D.distance(a,e)<=r?(i&&(i[0]=m),1):0}(this,t,e.length,e,s)}endPointModified(){_e(this)}clearEndPointModified(){}}Ot.type=e.GeometryType.enumBezier2;class jt{constructor(t){return t.coefsT?(this.m_zeroCtor=t.zeroCtor,this.m_elements=t.coefsT.map(t=>t.clone()),e.geometryReleaseAssert(this.m_elements.length===t.power+1),void this.updatePower()):t.coef0?(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[t.coef0.clone()])):t.copy?(this.m_zeroCtor=t.copy.m_zeroCtor,void(this.m_elements=t.copy.m_elements.map(t=>t.clone()))):(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(t,e){return this.m_elements=t.map(t=>t.clone()),this.updatePower(),this}construct0(t){return this.m_elements.length=0,this.m_elements.push(t.clone()),this.updatePower(),this}assignCopy(t){return this.m_elements=t.m_elements.map(t=>t.clone()),this.updatePower(),this}assignMove(t){return this.m_elements=t.m_elements,t.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(t){this.m_elements.push(t.clone())}scaleRangeToUnitInterval(t,e){const s=e;s.subThis(t);const i=this.power();for(let e=0;e<=i;e++){const r=new this.m_zeroCtor;for(let s=e;s<=i;s++){const i=this.m_elements[s];i.mulDoubleThis(n.choose(s,e));const o=t.pow(s-e);i.mulThis(o),r.addThis(i)}const o=s.pow(e);r.mulThis(o),this.m_elements[e]=r}}fmSubThis(t,s){return e.geometryReleaseAssert(0),this}addThis(t){const e=Math.min(this.power(),t.power());for(let s=0;s<=e;++s)this.m_elements[s].addThis(t.m_elements[s]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n];return this.updatePower(),this}add0(t){return this.m_elements[0].addThis(t),this.updatePower(),this}addNumber0(t){return e.geometryReleaseAssert(0),this}sub(t){const e=Math.min(this.power(),t.power());for(let s=0;s<=e;++s)this.m_elements[s].subThis(t.m_elements[s]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0(t){return e.geometryReleaseAssert(0),this}subNumber0(t){return e.geometryReleaseAssert(0),this}subShifted(t,e){const s=this.power(),n=t.power()+e,i=Math.min(this.power(),n);let r=0;for(let s=e;s<=i;++s)this.m_elements[s].subThis(t.m_elements[r]),r++;if(n<=s)return this.updatePower(),this;this.m_elements.length=n+1;for(let t=s+1;t<this.m_elements.length;++t)this.m_elements[t]=new this.m_zeroCtor;for(let e=i+1;e<=n;++e)this.m_elements[e].subThis(t.m_elements[r++]);return this.updatePower(),this}subShiftedWithCoef(t,e,s){const n=this.power(),i=t.power()+s,r=Math.min(this.power(),i);let o=0;for(let n=s;n<=r;++n)this.m_elements[n].fmSubThis(t.m_elements[o],e),o++;if(i<=n)return this.updatePower(),this;this.m_elements.length=i+1;for(let t=n+1;t<this.m_elements.length;++t)this.m_elements[t]=new this.m_zeroCtor;for(let s=r+1;s<=i;++s)this.m_elements[s].fmSubThis(t.m_elements[o++],e);return this.updatePower(),this}mulThis(t){if(this.constructor===t.constructor){const e=t,s=[];for(let t=0,n=this.power();t<=n;t++)for(let n=0,i=e.power();n<=i;n++){const i=this.m_elements[t].clone();i.mulThis(e.m_elements[n]),t+n<s.length?s[t+n].addThis(i):s.push(i)}this.m_elements=s}else for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulElementThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulDoubleThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulDoubleThis(t);return this.updatePower(),this}mulNumber0(t){return e.geometryReleaseAssert(0),this}mulBigint0(t){return e.geometryReleaseAssert(0),this}mulBigIntThis(t){return e.geometryReleaseAssert(0),this}mulInt320(t){return e.geometryReleaseAssert(0),this}div0(t){return e.geometryReleaseAssert(0),this}absThis(){return e.geometryReleaseAssert(0),this}div(t,e,s){if(this.power()<t.power())return s.assignCopy(this),void e.setZero();s.setZero(),e.setZero();const i=t.getElement(t.power()),r=this.clone();let o=r.power();const a=r.power()-t.power();let m=a;for(e.m_elements=n.makeObjectArray(e.m_zeroCtor,a+1);;){if(o<t.power()){s.assignMove(r);break}if(o===r.power()){const s=r.getElement(r.power());s.divThis(i),r.subShiftedWithCoef(t,s,r.power()-t.power()),e.m_elements[m]=s.clone()}m--,o--}s.updatePower(),e.updatePower()}divThis(t){return e.geometryReleaseAssert(0),this}subThis(t){const e=Math.min(this.power(),t.power());for(let s=0;s<=e;++s)this.m_elements[s].subThis(t.m_elements[s]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0This(t){return this.m_elements[0].subThis(t),this.updatePower(),this}subFrom(t,s){e.geometryReleaseAssert(0)}isZero(){return 0===this.power()&&this.m_elements[0].isZero()}negateThis(){for(let t=this.m_elements.length-1;t>=0;t--)this.m_elements[t].negateThis();return this}getElement(t){return this.m_elements[t].clone()}setElement(t,e){return this.m_elements[t]=e.clone(),this}evaluate(t){const e=this.power(),s=this.m_elements[e].clone();for(let n=e-1;n>=0;--n)s.mulThis(t),s.addThis(this.m_elements[n]);return s}equals(t){if(this===t)return!0;if(this.power()!==t.power())return!1;for(let e=this.m_elements.length-1;e>=0;e--)if(!this.m_elements[e].equals(t.m_elements[e]))return!1;return!0}updatePower(){for(let t=this.m_elements.length-1;t>0&&this.m_elements[t].isZero();t--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(t){if(this.power()<t)return this.clone().setZero();if(0===t)return this.clone();const e=new this.constructor({coefsT:this.m_elements.slice(t),power:this.power()-t});for(let s=t,n=this.power();s<=n;s++){let n=BigInt(s);for(let e=s-1,i=s-t;e>i;--e)n*=BigInt(e);e.m_elements[s-t].mulBigIntThis(n)}return e.updatePower(),e}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let t=1,e=this.power();t<=e;t++)this.m_elements[t].mulThis(n.MPValue.constructInt32(t+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(t){for(let e=this.power();e>=0;--e)this.m_elements[e].limitPrecisionThis(t);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce((t,e)=>{const s=e.hiBitIndex();return t<s?s:t},0)}shiftRight(t){return this.m_elements.splice(0,t),this.updatePower(),this}evaluateDerivative(t){const e=this.power(),s=this.m_elements[e];s.mulDoubleThis(e);for(let n=e-1;n>=1;--n){s.mulThis(t);const e=this.m_elements[n];e.mulDoubleThis(n),s.addThis(e)}return s}static evaluateCoefs(t,e,s){const n=t.power();s.construct0(t.getElement(0).evaluate(e));for(let i=1;i<=n;++i)s.addElement(t.getElement(i).evaluate(e));s.updatePower()}}class Bt extends jt{constructor(t){super(void 0===t?{zeroCtor:n.MPValue}:{...t,zeroCtor:n.MPValue})}clone(){return new Bt({copy:this})}absEvaluate(t){const e=this.power(),s=this.m_elements[e].clone();s.absThis();const n=t.clone();n.absThis();for(let t=e-1;t>=0;--t)s.mulThis(n),s.addThis(this.m_elements[t].abs());return s}}class Wt extends jt{constructor(t){super(void 0===t?{zeroCtor:Bt}:{...t,zeroCtor:Bt})}clone(){return new Wt({copy:this})}constructFromMPValues(t,e){this.m_elements.length=0;for(let s=0;s<=e;++s)this.m_elements.push(new Bt({coef0:t[s]}));return this.updatePower(),this}}function Ht(t,s,i,r,o,a,m,h,u,l,c,g,d,p,_,P,f,y,x,D=!1){const v={polypoly1:new Wt,polypoly2:new Wt,polyX2:new Bt,polyY2:new Bt,polyX2Deriv:new Bt,polyY2Deriv:new Bt,polypolyX1:new Wt,polypolyY1:new Wt,polypolyX1Deriv:new Wt,polypolyY1Deriv:new Wt,lazyPolypolyD1:new Wt,lazyPolypolyD1Deriv:new Wt,lazyPolyD2:new Bt,lazyPolyD2Deriv:null,polypoly11:new Wt,polypoly12:new Wt,tempPp:new Wt,tempPp1:new Wt,tempPp2:new Wt,tempP:new Bt,tempP1:new Bt,tempP2:new Bt};v.polyX2.construct(m,h),v.polyY2.construct(u,l),v.polypolyX1.constructFromMPValues(t,s),v.polypolyY1.constructFromMPValues(i,r),v.polypoly11.assignCopy(v.polypolyX1),v.polypoly12.assignCopy(v.polypolyY1),c&&(v.lazyPolyD2.construct(c,g),v.polypoly11.mulElementThis(v.lazyPolyD2),v.polypoly12.mulElementThis(v.lazyPolyD2)),o?(v.lazyPolypolyD1.constructFromMPValues(o,a),v.lazyPolypolyD1Deriv=new Wt({copy:v.lazyPolypolyD1}),v.lazyPolypolyD1Deriv.derivative1This(),v.tempPp.assignCopy(v.lazyPolypolyD1),v.tempPp.mulElementThis(v.polyX2),v.polypoly11.subThis(v.tempPp),v.tempPp.assignCopy(v.lazyPolypolyD1),v.tempPp.mulElementThis(v.polyY2),v.polypoly12.subThis(v.tempPp)):(v.polypoly11.sub0This(v.polyX2),v.polypoly12.sub0This(v.polyY2)),v.polypolyX1Deriv.assignCopy(v.polypolyX1),v.polypolyX1Deriv.derivative1This(),v.polypolyY1Deriv.assignCopy(v.polypolyY1),v.polypolyY1Deriv.derivative1This(),o&&(v.polypolyX1Deriv.mulThis(v.lazyPolypolyD1),v.tempPp2.assignCopy(v.lazyPolypolyD1Deriv),v.tempPp2.mulThis(v.polypolyX1),v.polypolyX1Deriv.subThis(v.tempPp2),v.polypolyY1Deriv.mulThis(v.lazyPolypolyD1),v.tempPp2.assignCopy(v.lazyPolypolyD1Deriv),v.tempPp2.mulThis(v.polypolyY1),v.polypolyY1Deriv.subThis(v.tempPp2)),v.polyX2Deriv.assignCopy(v.polyX2),v.polyX2Deriv.derivative1This(),v.polyY2Deriv.assignCopy(v.polyY2),v.polyY2Deriv.derivative1This(),c&&(e.geometryReleaseAssert(null===v.lazyPolyD2Deriv),v.lazyPolyD2Deriv=new Bt({copy:v.lazyPolyD2}),v.lazyPolyD2Deriv.derivative1This(),v.polyX2Deriv.mulThis(v.lazyPolyD2),v.tempP1.assignCopy(v.lazyPolyD2Deriv),v.tempP1.mulThis(v.polyX2),v.polyX2Deriv.subThis(v.tempP1),v.polyY2Deriv.mulThis(v.lazyPolyD2),v.tempP1.assignCopy(v.lazyPolyD2Deriv),v.tempP1.mulThis(v.polyY2),v.polyY2Deriv.subThis(v.tempP1)),v.polypoly1.assignCopy(v.polypoly11),v.polypoly1.mulElementThis(v.polyX2Deriv),v.tempPp.assignCopy(v.polypoly12),v.tempPp.mulElementThis(v.polyY2Deriv),v.polypoly1.addThis(v.tempPp),v.polypoly2.assignCopy(v.polypolyX1Deriv),v.polypoly2.mulElementThis(v.polyY2Deriv),v.tempPp.assignCopy(v.polypolyY1Deriv),v.tempPp.mulElementThis(v.polyX2Deriv),v.polypoly2.subThis(v.tempPp);let E=[];const C=[];f||(f=[]),P||(P=[]),ee(v.polypoly11,v.polypoly12,v.tempP);const b=n.s_one$1.ldexp(-59).toDouble(),A=[];let w=se(v.tempP,0,_,b,64,A,y,y);if(w<0)return-1;for(let t=0;t<w;t++){const s=v.tempP1,i=v.tempP2;Bt.evaluateCoefs(v.polypoly11,A[t],s);const r=n.constructBernsteinCoefficientsFromStandardForm(s.m_elements,s.power()+1);r.sort((t,e)=>t.compare(e)),Bt.evaluateCoefs(v.polypoly12,A[t],i);const o=n.constructBernsteinCoefficientsFromStandardForm(i.m_elements,i.power()+1);o.sort((t,e)=>t.compare(e));const a=r[0],m=r.at(-1),h=o[0],u=o.at(-1);m.subThis(a),u.subThis(h);const l=m.subThis(u).GEZ(),c=58,g=[];let d;if(d=se(l?s:i,0,p,n.s_one$1.ldexp(-59).toDouble(),c,g,y,y),d<0&&e.throwInternalErrorException("mp_curve_proximity"),d>0){const r=l?i:s;for(let s=0;s<d;s++){let i;if(l){const e=v.tempP;Bt.evaluateCoefs(v.polypoly12,A[t].addDouble(Number.EPSILON),e),i=e.evaluate(g[s])}else{const e=v.tempP;Bt.evaluateCoefs(v.polypoly11,A[t].addDouble(Number.EPSILON),e),i=e.evaluate(g[s])}const o=r.evaluateDerivative(g[s]).abs().mulDoubleThis(Number.EPSILON),a=r.evaluate(g[s]);o.addThis(i.sub(a).absThis()),o.ldexpThis(3),a.absThis(),a.lt(o)?C.push(n.makePair(g[s].toDouble(),A[t].toDouble())):e.geometryReleaseAssert(a.gte(o))}}}w=C.length,ee(v.polypoly1,v.polypoly2,v.tempP);const S=[];let T=se(v.tempP,0,_,b,64,S);T<0&&(T=0);for(let t=0;t<T;t++){Bt.evaluateCoefs(v.polypoly1,S[t],v.tempP1);const e=[];let s=se(v.tempP1,0,p,b,64,e);if(0!==s)if(Bt.evaluateCoefs(v.polypoly2,S[t],v.tempP2),s<0){if(s=se(v.tempP2,0,p,b,64,e),s<0)continue;for(let i=0;i<s;i++)E.push(n.makePair(e[i].toDouble(),S[t].toDouble()))}else{const i=v.tempP2.absEvaluate(n.s_one$1);i.mulThis(n.MPValue.constructDouble(1e-12));for(let r=0;r<s;r++){const s=v.tempP2.evaluate(e[r]);s.absThis(),s.lt(i)&&E.push(n.makePair(e[r].toDouble(),S[t].toDouble()))}}}if(T=E.length,0===w&&0===T)return 0;E=E.concat(C),E.sort((t,e)=>D?n.standardNumericCompare(t.second,e.second):n.standardNumericCompare(t.first,e.first));const I=n.unique(E,(t,e)=>t.first===e.first&&t.second===e.second);E=E.slice(0,I),P.length=0,f.length=0;for(const t of E)P.push(t.first),f.push(t.second);return e.geometryReleaseAssert(P.length===f.length),f.length}function Zt(t,e,s,i,r,o,a,m,h,u,l,c,g){const d={polyIntersect:new Bt,polyX1:new Bt,polyY1:new Bt,polyX1Deriv:new Bt,polyY1Deriv:new Bt,lazyPolyD1:new Bt,lazyPolyD1Deriv:new Bt,tempP:new Bt,tempP1:new Bt,tempP2:new Bt,polypoly1Proximity:new Wt,polypoly2Proximity:new Wt};d.polyX1.construct(t,e),d.polyY1.construct(s,i),d.polyX1Deriv.assignCopy(d.polyX1),d.polyX1Deriv.derivative1This(),d.polyY1Deriv.assignCopy(d.polyY1),d.polyY1Deriv.derivative1This(),d.polyIntersect.assignCopy(d.polyX1),d.polyIntersect.mulThis(d.polyX1),d.polyIntersect.mulElementThis(a[0]),d.tempP.assignCopy(d.polyY1),d.tempP.mulThis(d.polyY1),d.tempP.mulElementThis(a[1]),d.polyIntersect.addThis(d.tempP),r?(d.lazyPolyD1.construct(r,o),d.tempP.assignCopy(d.lazyPolyD1),d.tempP.mulThis(d.lazyPolyD1),d.tempP.mulElementThis(a[2]),d.polyIntersect.addThis(d.tempP)):d.polyIntersect.add0(a[2]);{const r=a[0].clone(),o=r.clone();o.sqrThis();const m=a[1].clone(),h=m.clone();h.sqrThis();const u=a[2].clone(),l=r.clone();l.subThis(m),d.polyX1.construct(t,e),d.polyX1Deriv.assignCopy(d.polyX1),d.polyX1Deriv.derivative1This(),d.polyY1.construct(s,i),d.polyY1Deriv.assignCopy(d.polyY1),d.polyY1Deriv.derivative1This(),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(d.polyX1),d.tempP.mulElementThis(h),d.tempP.mulElementThis(u),d.polypoly1Proximity.construct0(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(m.mul(l).mul(u).ldexpThis(1)),d.polypoly1Proximity.addElement(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(d.polyX1),d.tempP.mulElementThis(r.mul(h)),d.tempP1.assignCopy(d.polyY1),d.tempP1.mulThis(d.polyY1),d.tempP1.mulElementThis(o.mul(m)),d.tempP.addThis(d.tempP1),d.tempP.add0(l.mul(l).mul(u)),d.polypoly1Proximity.addElement(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulElementThis(l.mul(r).mul(m).ldexpThis(1)),d.polypoly1Proximity.addElement(d.tempP),d.tempP.construct0(r.mul(l).mul(l)),d.polypoly1Proximity.addElement(d.tempP),d.polypoly1Proximity.updatePower(),d.tempP.construct0(n.s_zero$1),d.polypoly2Proximity.construct0(d.tempP),d.tempP.assignCopy(d.polyX1),d.tempP.mulThis(d.polyX1Deriv),d.tempP1.assignCopy(d.polyY1),d.tempP1.mulThis(d.polyY1Deriv),d.tempP.addThis(d.tempP1),d.tempP.mulElementThis(r.mul(m)),d.polypoly2Proximity.addElement(d.tempP),d.tempP.assignCopy(d.polyX1Deriv),d.tempP.mulElementThis(l.mul(r)),d.polypoly2Proximity.addElement(d.tempP),d.polypoly2Proximity.updatePower()}const p=[],_=[];null===l&&(l=[]);let P=2*d.polyIntersect.power()+58;const f=.5*Number.EPSILON,y=[],x=se(d.polyIntersect,0,h,f,P,y,c,c);if(x<0)return-1;for(const t of y)_.push(t.toDouble());ee(d.polypoly1Proximity,d.polypoly2Proximity,d.tempP),P=2*d.tempP.power()+58,y.length=0;let D=se(d.tempP,0,h,f,P,y);if(D<0&&(D=0),0===x&&0===D)return 0;for(const t of y)p.push(t.toDouble());const v=p.concat(_);l.length=v.length,n.memcpy(l,v,0,0,v.length),n.numericSort(l);const E=n.unique(l,(t,e)=>0===n.standardNumericCompare(t,e));return l.length=E,l.length}function Ut(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setThis(e),n.negateThis(),n.divThis(t),s.isEmpty()||s.containsCoordinate(n.value())?1:0)}function Qt(t,e,s,i,r,o,a){if(t.isZero())return o?(a[0].setInt32(1),r.containsCoordinate(1)?1:0):Ut(e,s,r,a[0]);if(o){let e=2;return a[0].setInt32(1),s.equals(t)?(a[1].setInt32(1),e=1):a[1].setThis(s.div(t)),r.containsCoordinate(a[1].value())||(e=1),r.containsCoordinate(a[0].value())||(e--,a[0].setThis(a[1])),2===e&&a[0].value()>a[1].value()&&(a[1]=n.swap(a[0],a[0]=a[1])),e}const m=e.clone();m.sqrThis();const h=t.clone();if(h.mulThis(s).ldexpThis(2).negateThis().addThis(m),h.LZ())return 0;const u=i+2,l=n.MPValue.sqrt(h,u),c=l.clone();e.LZ()&&c.negateThis(),c.addThis(e).limitPrecisionThis(u).ldexpThis(-1).negateThis();let g=0;return a[0].setThis(c).divThis(n.MPValue.constructAssign(t,u)).limitPrecisionThis(i),(r.isEmpty()||r.containsCoordinate(a[0].value()))&&g++,l.isZero()||c.isZero()||(a[g].setThis(s).divThis(c).limitPrecisionThis(i),(r.isEmpty()||r.containsCoordinate(a[g].value()))&&g++,2===g&&a[0].gt(a[1])&&(a[1]=n.swap(a[0],a[0]=a[1]))),g}function $t(t,s,i,r,o,a,m,h){if(t.isZero())return Qt(s,i,r,o,a,m,h);const u=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=n.swap(h[t],h[t]=h[s-1]),s--);e=s}return n.sortRange(h,0,e,(t,e)=>t.compare(e)),e};if(r.isZero()){let e=0;return a.containsCoordinate(0)&&(h[0].setInt32(0),e=1),u(Qt(t,s,i,o,a,m,h.slice(1)),e)}if(m){let e=0;a.containsCoordinate(1)&&(h[0].setInt32(1),e=1);const n=s.add(t),i=r.negate(),m=t.add(n).add(i).isZero();return u(Qt(t,n,i,o,a,m,h.slice(e)),e)}const l=new n.MPValue,c=new n.MPValue,g=new n.MPValue,d=s.clone();if(d.isZero())c.setThis(i),c.divThis(t),g.setThis(r),g.divThis(t);else{d.divThis(t).divDoubleThis(3).negateThis();const e=s.clone();e.sqrThis();const n=t.clone();n.sqrThis(),c.setThis(t),c.mulThis(i).mulDoubleThis(3).subThis(e).divThis(n).divDoubleThis(3),g.setThis(e),g.mulThis(s),g.ldexpThis(1),l.setThis(t),l.mulThis(s).mulThis(i).mulDoubleThis(9),g.subThis(l),l.setThis(n),l.mulThis(r).mulDoubleThis(27),g.addThis(l),g.divThis(n).divThis(t).divDoubleThis(27)}if(c.isZero()){const t=g.clone();return t.negateThis(),t.isZero()?(h[0].setThis(d),he(a,o,h,1)):(h[0].setThis(n.MPValue.cubicRoot(t,o).add(d)),he(a,o,h,1))}const p=g.clone();if(p.sqrThis().ldexpThis(-2),l.setThis(c.clone()),l.sqrThis().mulThis(c).divDoubleThis(27),p.addThis(l),p.isZero())return h[0].setThis(g),h[0].mulDoubleThis(3).divThis(c),h[1].setThis(h[0]),h[1].negateThis(),h[1].ldexpThis(-1),h[0].addThis(d),h[1].addThis(d),he(a,o,h,2);if(p.GZ())return p.setThis(n.MPValue.sqrt(p,o+8)),l.setThis(g),l.ldexpThis(-1).negateThis(),l.addThis(p),h[0].setThis(n.MPValue.cubicRoot(l,o+8)),l.setThis(g),l.ldexpThis(-1).negateThis(),l.subThis(p),h[0].addThis(n.MPValue.cubicRoot(l,o+8)),h[0].addThis(d),he(a,o,h,1);l.setThis(c),l.divDoubleThis(3).negateThis(),e.geometryReleaseAssert(l.GEZ());const _=n.MPValue.sqrt(l,o+8),P=_.clone();P.negateThis(),P.addThis(d),_.addThis(d);const f=n.MPValue.constructDouble(a.isEmpty()?-Number.MAX_VALUE:a.vmin),y=n.MPValue.constructDouble(a.isEmpty()?Number.MAX_VALUE:a.vmax),x=new Bt({zeroCtor:n.MPValue});x.construct0(r),x.addElement(i),x.addElement(s),x.addElement(t);const D=new Bt({copy:x});D.derivative1This();let v=0;const E=n.makeObjectArray(n.MPValue,4);E[v++].setThis(f),P.gt(f)&&P.lt(y)&&E[v++].setThis(P),_.gt(f)&&_.lt(y)&&E[v++].setThis(_),E[v++].setThis(y);const C=3*o;let b=52,A=Number.EPSILON;for(;b<C;)2*b<=C?(A*=A,b*=2):(A*=Number.EPSILON,b+=52);b+=2;let w=0,S=!1;for(let t=1;t<v;t++)if(re(x,D,E[t-1],E[t],A,b,h[0])){w=1,S=t+1<v;break}if(!w)return 0;if(S){const t=new Bt({zeroCtor:n.MPValue,coef0:h[0]});t.negateThis(),t.addElement(n.s_one$1);const s=new Bt({zeroCtor:n.MPValue}),i=new Bt({zeroCtor:n.MPValue});x.div(t,s,i),e.geometryReleaseAssert(2===s.power()),e.geometryReleaseAssert(0===i.power());const r=Qt(s.getElement(2),s.getElement(1),s.getElement(0),o,a,!1,h.slice(1));e.geometryReleaseAssert(r>=0&&r<=2),w+=r}return he(a,o,h,w)}function Kt(t,e,s,i,r,o,a,m,h){if(t.isZero())return $t(e,s,i,r,o,a,m,h);const u=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=n.swap(h[t],h[t]=h[s-1]),s--);e=s}return n.sortRange(h,0,e,(t,e)=>t.compare(e)),e};if(r.isZero()){let n=0;return a.containsCoordinate(0)&&(h[0].setInt32(0),n=1),u($t(t,e,s,i,o,a,m,h.slice(n)),n)}const l=new Bt({zeroCtor:n.MPValue,coef0:r});if(l.addElement(i),l.addElement(s),l.addElement(e),l.addElement(t),m){let t=0;a.containsCoordinate(1)&&(h[0].setInt32(1),t=1);const e=new Bt({zeroCtor:n.MPValue,coef0:n.MPValue.constructInt32(-1)});e.addElement(n.MPValue.constructInt32(1));const s=new Bt({zeroCtor:n.MPValue}),i=new Bt({zeroCtor:n.MPValue});return l.div(e,s,i),u($t(3===s.power()?s.getElement(3):n.s_zero$1.clone(),s.power()>=2?s.getElement(2):n.s_zero$1.clone(),s.power()>=1?s.getElement(1):n.s_zero$1.clone(),s.getElement(0),o,a,s.evaluate(n.s_one$1).isZero(),h.slice(t)),t)}if(l.getElement(0).isZero()){let t=0;for(a.containsCoordinate(0)&&(t=1,h[0].setDouble(0));l.getElement(0).isZero()&&l.power()>0;)l.shiftRight(1);const e=$t(3===l.power()?l.getElement(3):n.s_zero$1.clone(),l.power()>=2?l.getElement(2):n.s_zero$1.clone(),l.power()>=1?l.getElement(1):n.s_zero$1.clone(),l.getElement(0),o,a,!1,h.slice(t));return e>0&&(t+=e),n.sortRange(h,0,t,(t,e)=>t.compare(e)),t}let c=52,g=Number.EPSILON;for(;c<o;)2*c<=o?(g*=g,c*=2):(g*=Number.EPSILON,c+=52);c+=2;const d=me(l),p=n.MPValue.constructDouble(Math.max(Math.abs(a.vmax),Math.abs(a.vmin)));return g=(d.lt(p)?d:p).mul(n.MPValue.constructDouble(g)).toDouble(),ae(l,a,g,c,m,0,h,4)}function Jt(t,e){let s=t,i=e;i.power()>s.power()&&(i=n.swap(s,s=i));const r=s.power()-i.power(),o=new Bt({copy:s.getElement(s.power())});s.mulThis(i.getElement(i.power()));for(let t=0,e=s.power();t<e;t++)if(t>=r){const e=new Bt({copy:i.getElement(t-r)});e.mulThis(o);const n=s.getElement(t).sub(e);s.setElement(t,n)}s.setElement(s.power(),s.getElement(s.power()).setZero()),s.updatePower(),te(s)}function te(t){let e=0;for(;e<t.power()&&t.getElement(e).isZero();)e++;return e>0&&(t.shiftRight(e),!0)}function ee(t,e,s){const n=t.clone(),i=e.clone();for(te(n),te(i);0!==n.power()||0!==i.power();)Jt(n,i);s.assignMove(n.getElement(0))}function se(t,e,s,i,r,o,a=!1,m=!1){o.length=0;const h=t.power(),u=n.makeObjectArray(n.MPValue,2*h+4),l=function(t,e,s,i,r,o,a){if(0===t.power())return t.isZero()?-1:0;const m=t.evaluate(n.MPValue.constructInt32(1)).isZero();if(1===t.power()){const s=Ut(t.getElement(1),t.getElement(0),e,o.at(0));return o[0].limitPrecisionThis(i),1!==s?0:(o[0].limitPrecisionThis(i),1)}return 2===t.power()?Qt(t.getElement(2),t.getElement(1),t.getElement(0),i,e,m,o):3===t.power()?$t(t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),i,e,m,o):4===t.power()?Kt(t.getElement(4),t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),i,e,m,o):ae(t,e,s,i,m,0,o,a)}(t,s||n.Envelope1D.unit(),i,r,0,u,u.length);if(l>0){o.length=0;for(let t=0;t<l;t++){const e=u[t];t>0&&e.lte(o.at(-1))||o.push(e.clone())}return o.length}return l}function ne(t,s,n){if(e.geometryReleaseAssert(n>=1),0===t.power())return t.isZero()?-1:0;const i=t.getElement(0);return i.negateThis(),i.divThis(t.getElement(1)),s[0].setThis(i),1}function ie(t,s,i,r){if(t.power()<2)return ne(t,i,r);e.geometryReleaseAssert(r>=1);let o=t.getElement(1);o.mulThis(t.getElement(1));const a=t.getElement(0);if(a.mulThis(t.getElement(2)),a.ldexpThis(2),o.subThis(a),o.LZ())return 0;if(o.isZero()){const e=t.getElement(1);return e.negateThis(),e.divThis(t.getElement(2)),e.ldexpThis(-1),e.limitPrecisionThis(s),i[0].setThis(e),1}e.geometryReleaseAssert(r>=2),o=n.MPValue.sqrt(o,s+8);const m=t.getElement(1);m.negateThis();const h=m.clone();h.subThis(o),h.divThis(t.getElement(2)),h.ldexpThis(-1),h.limitPrecisionThis(s);const u=m.clone();return u.addThis(o),u.divThis(t.getElement(2)),u.ldexpThis(-1),u.limitPrecisionThis(s),h.lt(u)?(i[0].setThis(h),i[1].setThis(u)):(i[1].setThis(h),i[0].setThis(u)),2}function re(t,s,i,r,o,a,m){let h=i.clone(),u=r.clone();h.limitPrecisionThis(a),u.limitPrecisionThis(a);let l=t.evaluate(h);l.limitPrecisionThis(a+2);let c=t.evaluate(u);if(c.limitPrecisionThis(a+2),l.GEZ()&&c.GEZ()||l.LEZ()&&c.LEZ())return l.absLessAbs(c)?(m=h,l.isZero()):(m=u,c.isZero());const g=c.LZ();g&&(c=n.swap(l,l=c),u=n.swap(h,h=u));const d=g?u:h,p=g?h:u,_=h.add(u).ldexpThis(-1);_.limitPrecisionThis(a);const P=u.sub(h);P.limitPrecisionThis(a),P.absThis();const f=P.clone();let y=t.evaluate(_),x=s.evaluate(_);const D=new Bt({copy:t}),v=new Bt({copy:s});{const e=Math.max(t.hiBitIndex(),s.hiBitIndex()),i=n.s_one$1.clone();i.ldexpThis(-(a+2));for(let n=64;n<e;){D.limitPrecisionThis(n),v.limitPrecisionThis(n);const r=D.evaluate(_),o=v.evaluate(_),a=r.sub(y),m=o.sub(x);if(a.divThis(y).absThis().lt(i)&&(x.isZero()||m.divThis(x).absThis().lt(i)))break;D.assignCopy(t),v.assignCopy(s),n=Math.min(n+64,e)}y.limitPrecisionThis(a+2),x.limitPrecisionThis(a+2)}let E=4,C=1,b=0,A=0,w=1;const S=n.MPValue.constructDouble(.25*o),T=n.MPValue.constructDouble(.5001);let I=0;for(;++I<300;){if(I>32&&b>0||x.isZero()||2===w&&b>1||1===w&&E<4)w=1,C>1&&C--;else if(w=2,A>1){const t=P.mul(x);t.absThis(),t.ldexpThis(-3),t.absLessAbs(y)&&C++}P.setThis(f);const t=new n.MPValue;let e=!1;if(1===w)do{if(A>2){const e=P.clone();if(e.absThis(),e.ldexpThis(4),p.sub(d).ldexpThis(-1).gt(e)){if(_.equals(d)){t.setThis(_),_.setThis(d.add(e)),_.limitPrecisionThis(a),f.setThis(_.sub(t));break}if(_.equals(p)){t.setThis(_),_.setThis(p.sub(e)),_.limitPrecisionThis(a),f.setThis(_.sub(t));break}}}f.setThis(u.sub(h)),f.ldexpThis(-1),f.limitPrecisionThis(a),t.setThis(_),_.setThis(h.add(f)),_.limitPrecisionThis(a),_.lt(d)?_.setThis(d):_.gt(p)&&_.setThis(p),e=h.equals(_)||u.equals(_)}while(0);else for(;;){if(f.setThis(y.div(x)),f.limitPrecisionThis(a),1!==C&&f.mulDoubleThis(C),t.setThis(_),_.subThis(f),_.limitPrecisionThis(a),e=_.equals(t),_.lt(d)){if(C>1){_.setThis(t),C--;continue}f.setThis(t.sub(d)),_.setThis(d)}else if(_.gt(p)){if(C>1){_.setThis(t),C--;continue}f.setThis(t.sub(p)),_.setThis(p)}break}if(e||f.absLessAbs(S)){t.equals(_)||(y=D.evaluate(_),y.limitPrecisionThis(a+2));break}y=D.evaluate(_),y.limitPrecisionThis(a+2),x=v.evaluate(_),x.limitPrecisionThis(a+2);const s=h.clone(),i=u.clone();y.LZ()?(l.setThis(y),h.setThis(_)):(c.setThis(y),u.setThis(_)),2===w&&(h.equals(s)&&u.equals(i)||A>1&&!f.absLessAbs(T.mul(P)))?b++:b=0,1===w?(E++,A=0):(E=0,A++)}return I>=300&&e.throwInternalErrorException("Root_finder iterations exceeded"),m.setThis(_),!0}function oe(t,e,s,i,r){const o=t.evaluate(s);if(o.isZero())return!0;const a=n.MPValue.constructDouble(.5*i),m=s.clone();m.subThis(a);const h=t.evaluate(m),u=s.clone();u.addThis(a);const l=t.evaluate(u);if(h.LZ()&&l.GZ()||h.GZ()&&l.LZ())return!0;if(o.GZ()?h.LEZ()||l.LEZ():h.GEZ()||l.GEZ())return!0;const c=h.LEZ()&&l.LEZ(),g=h.GEZ()&&l.GEZ();let d=!1;return c?o.gt(h)&&o.gt(l)&&(d=!0):g&&o.lt(h)&&o.lt(l)&&(d=!0),!!d&&o.absThis().lt(n.MPValue.constructDouble(1e-17))}function ae(t,s,i,r,o,a,m,h){e.geometryReleaseAssert(i>0),e.geometryReleaseAssert(h>=t.power());const u=m,l=[];let c=[];const g=new Bt({zeroCtor:t.m_zeroCtor}),d=new Bt({zeroCtor:t.m_zeroCtor}),p=new Bt({zeroCtor:t.m_zeroCtor}),_=n.MPValue.constructDouble(i),P=n.MPValue.constructDouble(s.vmin),f=n.MPValue.constructDouble(s.vmax),y=P.sub(_),x=f.add(_),D=me(t),v=D.clone();if(v.negateThis(),y.lt(v))y.setThis(v.sub(_));else if(y.gt(D))return 0;if(x.gt(D))x.setThis(D.add(_));else if(x.lt(v))return 0;let E=t,C=null;if(o){const e=new Bt({coef0:n.MPValue.constructInt32(-1)});e.addElement(n.s_one$1),C=new Bt,E=C;const s=new Bt,i=new Bt;for(t.div(e,s,i),C.assignCopy(s);E.evaluate(n.s_one$1).isZero();)E.div(e,s,i),C.assignCopy(s)}let b=!1;if(E.power()>0&&E.getElement(0).isZero())for(b=!0,C||(C=new Bt({copy:E}),E=C);E.getElement(0).isZero();)C.shiftRight(1);let A=r+2*E.power()+2,w=i/Math.pow(2,E.power()+2),S=A;if(n.s_zero$1.gt(y)&&n.s_zero$1.lt(x))for(let t=0,e=E.power();t<e;t++)if(E.getElement(t).isZero()){l.push(n.s_zero$1.clone());break}for(let t=E.power()-1;t>0;t--)if(w*=2,A-=2,S-=2,E.power()-t!==1){if(E.power()-t===2){d.assignMove(E.derivative(t));const s=ie(d,A,u,h);e.geometryReleaseAssert(s>=0&&s<=2);for(let t=0;t<s;t++)u[t].gt(y)&&u[t].lt(x)&&!u[t].isZero()&&l.push(u[t].clone());if(l.length>1&&l.sort((t,e)=>t.compare(e)),l.length>0){let t=l[0].sub(_);t.limitPrecisionThis(S),c.push(n.makePair(y.clone(),t));let e=1===l.length?x.clone():l[1].sub(_);t=l[0].add(_),t.limitPrecisionThis(S),e.limitPrecisionThis(S),c.push(n.makePair(t,e)),l.length>1&&(e=2===l.length?x.clone():l[2].sub(_),e.limitPrecisionThis(S),t=l[1].add(_),t.limitPrecisionThis(S),c.push(n.makePair(t,e)),l.length>2&&(t=l[2].add(_),t.limitPrecisionThis(S),c.push(n.makePair(t,x.clone()))))}else c.push(n.makePair(y.clone(),x.clone()));g.assignCopy(d),p.assignMove(E.derivative(t-1));continue}{d.assignMove(p),p.assignMove(E.derivative(t-1));let e=[];for(let t=0,s=c.length;t<s;++t)if(c[t].first.lte(c[t].second)){const s=new n.MPValue;if(re(d,g,c[t].first,c[t].second,w,A,s)){l.push(s);let i=s.sub(_);i.limitPrecisionThis(S),e.push(n.makePair(c[t].first,i)),i=s.add(_),i.limitPrecisionThis(S),e.push(n.makePair(i,c[t].second))}else e.push(c[t])}c=e,e=[],g.assignMove(d)}}else d.assignMove(E.derivative(t)),1===ne(d,u,h)&&(u[0].gt(y)&&u[0].lt(x)&&!u[0].isZero()&&l.push(u[0].clone()),g.assignMove(d),p.assignMove(E.derivative(t-1)));l.sort((t,e)=>t.compare(e)),0===c.length&&(g.assignMove(E.derivative(E.power())),g.isZero()||c.push(n.makePair(y.clone(),x.clone())));let T=0,I=0,M=0;const N=new n.MPValue;for(;;){if(I<c.length){if(c[I].first.gt(c[I].second)){I++;continue}let t=!1;if(M<l.length&&l[M].lt(c[I].first)&&(t=!0),!t){re(E,g,c[I].first,c[I].second,i,r,N)&&(N.lt(P)?u[T++].setThis(P):N.gt(f)?u[T++].setThis(f):u[T++].setThis(N)),I++;continue}}if(!(M<l.length))break;0!==M&&l[M-1].equals(l[M])||oe(E,0,l[M],i)&&(N.setThis(l[M]),N.lt(P)?N.setThis(P):N.gt(f)&&N.setThis(f),0!==T&&u[T].equals(N)||u[T++].setThis(N)),M++}return b&&n.s_zero$1.gt(y)&&n.s_zero$1.lt(x)&&(u[T++].setThis(n.s_zero$1),n.sortRange(u,0,T,(t,e)=>t.compare(e))),o&&n.s_one$1.gt(y)&&n.s_one$1.lt(x)&&(u[T++].setThis(n.s_one$1),n.sortRange(u,0,T,(t,e)=>t.compare(e))),T}function me(t){const e=t.getElement(t.power());e.limitPrecisionThis(53),e.absThis();const s=n.s_zero$1.clone();for(let e=0,n=t.power();e<n;e++){const n=t.getElement(e);n.limitPrecisionThis(53),n.gt(s)&&s.setThis(n)}return s.divThis(e),s.addThis(n.s_one$1),s.mulThis(n.MPValue.constructDouble(1+100*Number.EPSILON)),s}function he(t,e,s,i){let r=i;if(!t.isEmpty()){r=0;for(let e=0;e<i;++e)t.containsCoordinate(s[e].value())&&(r!==e&&s[r].setThis(s[e]),r++)}r>1&&(s[0].gt(s[1])&&(s[1]=n.swap(s[0],s[0]=s[1])),r>2&&(s[0].gt(s[2])&&(s[2]=n.swap(s[0],s[0]=s[2])),s[1].gt(s[2])&&(s[2]=n.swap(s[1],s[1]=s[2]))));for(let t=0;t<r;++t)s[t].limitPrecisionThis(e);return r}function ue(t,s,i,r,o,a){return function(t,s,i,r,o,a){if(i<s&&e.throwInvalidArgumentException("xTo < xFrom"),i===s)return 0;const m=[0];let h=Number.MAX_VALUE;const u=[Number.MAX_VALUE];let l=0;const c=n.makePrimitiveArray(33,Number.NaN),g=n.makePrimitiveArray(33,Number.NaN),d=[0];c[0]=1;let p=0,_=0;for(let n=0;n<32;n++){if(l=le(s,i,r,0===n,l,d),g[n]=l,n+1>=t){ce(n+1-t,t,c,g,0,m,u)||e.throwInternalErrorException("polynomial_interpolation");const s=o*Math.abs(m[0])+a,i=Math.abs(h-m[0]);if(i<=s&&Math.abs(u[0])<=s){if(p++,p>1&&(i<=.1*_||0===_||p>2))return m[0]}else p=0;_=i,h=m[0]}g[n+1]=g[n],c[n+1]=.25*c[n]}return m[0]}(t,s,i,a,r,o)}function le(t,e,s,i,r,o){let a=r;if(i)return o[0]=1,a=.5*(e-t)*(s(t)+s(e)),a;const m=o[0],h=(e-t)/m,u=t,l=new n.KahanSummator(0);for(let t=1;t<=o[0];++t){const e=(t-.5)*h;l.add(s(u+e))}return a=.5*(a+(e-t)*l.getResult()/m),o[0]*=2,a}function ce(t,e,s,i,r,o,a){let m=0,h=Math.abs(r-s[t]);const u=n.makePrimitiveArray(e,Number.NaN),l=n.makePrimitiveArray(e,Number.NaN);for(let n=0;n<e;++n){const e=Math.abs(r-s[t+n]);e<h&&(m=n,h=e),u[n]=i[t+n],l[n]=i[t+n]}let c=0,g=0,d=0;o[0]=i[t+m],m--;for(let n=1;n<e;n++){for(let i=0;i<e-n;i++){if(g=s[t+i]-r,d=s[t+i+n]-r,c=g-d,0===c)return!1;const e=(u[i+1]-l[i])/c;u[i]=g*e,l[i]=d*e}if(2*(m+1)<e-n){const t=m+1;a[0]=u[t]}else{const t=m;a[0]=l[t],m--}o[0]+=a[0]}return!0}class ge{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}let de=class{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-ye(this.b,e,!1):0}getError(t){return e.geometryReleaseAssert(0),0}};function pe(t,e,s,i,r){let o=!0;const a=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(a);let m=o?0:1,h=a[1][m]-a[0][m],u=a[2][m]-a[0][m];const l=ue(5,e,s,i,r,t=>{let e;if(t<=.5){const s=n.lerpLo(0,h,t),i=n.lerpLo(h,u,t);e=n.lerpLo(s,i,t)}else{const s=n.lerpHi(0,h,t),i=n.lerpHi(h,u,t);e=n.lerpHi(s,i,t)}return e*Ce(a,1,t).length()});o=!1,m=o?0:1,h=a[1][m]-a[0][m],u=a[2][m]-a[0][m];const c=ue(5,e,s,i,r,t=>{let e;if(t<=.5){const s=n.lerpLo(0,h,t),i=n.lerpLo(h,u,t);e=n.lerpLo(s,i,t)}else{const s=n.lerpHi(0,h,t),i=n.lerpHi(h,u,t);e=n.lerpHi(s,i,t)}return e*Ce(a,1,t).length()});return new n.Point2D(l,c)}function _e(t){t.m_cachedValues=null}function Pe(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new ge;return fe(t,e.specialPoints),Se(t,e),e}function fe(t,e){const s=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(s);const i=n.makeObjectArray(n.ECoordinate,8);i[0].set(0);let r=1;{const t=n.makeObjectArray(n.ECoordinate,3);!function(t,e,s=!1){const i=new n.ECoordinate(t[1][0]).subE(new n.ECoordinate(t[0][0]));e[1]=i.mul(2),e[2]=new n.ECoordinate(t[2][0]).subE(new n.ECoordinate(t[1][0])).subE(i),s?e[0].set(0):e[0].set(t[0][0])}(s,t,!1);const e=n.makeObjectArray(n.ECoordinate,2),o=new n.Envelope1D(0,1);let a=It(t[2].mul(2),t[1],o,e[0]);a<0&&(a=0);for(let t=0;t<a;t++)n.isOneOf(e[t].value(),0,1)||(i[r]=e[t],r++)}{const t=n.makeObjectArray(n.ECoordinate,3);!function(t,e,s=!1){const i=new n.ECoordinate(t[1][1]).subE(new n.ECoordinate(t[0][1]));e[1]=i.mul(2),e[2]=new n.ECoordinate(t[2][1]).subE(new n.ECoordinate(t[1][1])).subE(i),s?e[0].set(0):e[0].set(t[0][1])}(s,t,!1);const e=n.makeObjectArray(n.ECoordinate,2),o=new n.Envelope1D(0,1);let a=It(t[2].mul(2),t[1],o,e[0]);a<0&&(a=0);for(let t=0;t<a;t++)n.isOneOf(e[t].value(),0,1)||(i[r]=e[t],r++)}if(i[r].set(1),r++,r>2){n.sortRange(i,0,r,(t,e)=>t.value()-e.value());let t=0,e=i[0].value(),s=1;for(let n=1;n<r;n++)i[n].eq(i[n-1])?(e+=i[n].value(),s++):(s>1&&(e/=s,i[t].set(e)),t++,i[t]=i[n],e=i[n].value(),s=1);t++,r=t}i[0].set(0),i[r-1].set(1),e.length=r;for(let t=0;t<r;t++)e[t]=i[t].value()}function ye(t,e,s){const i=n.makeObjectArray(n.Point2D,3);return t.queryControlPoints(i),xe(i,e,s)}function xe(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+xe(t,1,!1)}if(1===e)return De(t);const i=n.makeObjectArray(n.Point2D,3);return Xe(t,e,i,null),De(i)}function De(t){if(t[0].equals(t[1]))return n.Point2D.distance(t[2],t[0]);if(t[1].equals(t[2]))return n.Point2D.distance(t[0],t[2]);const e=n.Point2D.distance(t[0],t[1])+n.Point2D.distance(t[2],t[1]),s=n.Point2D.distance(t[0],t[2]);if(e-s<=e*Number.EPSILON)return s;const i=n.makeObjectArray(n.Point2D,3);Ge(t,i,!0);const r=4*(n.sqr(i[2].x)+n.sqr(i[2].y)),o=2*(i[2].x*i[1].x+i[2].y*i[1].y),a=n.sqr(i[1].x)+n.sqr(i[1].y);if(1e-14*(Math.abs(o)+Math.abs(a))>=Math.abs(r))return 1e-14*Math.abs(a)>=Math.abs(o)?1*Math.sqrt(a):2/(3*o)*(Math.pow(1*o+a,1.5)-Math.pow(a,1.5));const m=o/r,h=a/r,u=h-m*m,l=1+m;if(0===u)return m>=0&&l>=0||m<=0&&l<=0?Math.abs(.5*Math.sqrt(r)*(l*l-m*m)):.5*Math.sqrt(r)*(l*l+m*m);const c=Math.sqrt(u+l*l),g=Math.sqrt(h);return.5*Math.sqrt(r)*(l*c-m*g+u*Math.log(Math.abs((l+c)/(m+g))))}function ve(t,e){const s=n.snap(e,0,1);let i=Ce(t,1,s);return i.isZero()&&(i=Ce(t,2,s)),i}function Ee(t,e,s){const i=n.makeObjectArray(n.Point2D,3);return t.queryControlPoints(i),Ce(i,e,s)}function Ce(t,e,s){if(1===e){const e=t[1].sub(t[0]).mul(1-s).add(t[2].sub(t[1]).mul(s));return e.mulThis(2),e}return 2===e?t[2].sub(t[1]).sub(t[1].sub(t[0]).mul(2)):n.Point2D.construct(0,0)}function be(t){const e=n.makeObjectArray(n.Point2D,3);return t.queryControlPoints(e),Ae(e)}function Ae(t){return-t[1].sub(t[0]).crossProduct(t[2].sub(t[0]))/3}function we(t){return t.m_cachedValues}function Se(t,e){t.m_cachedValues=e}function Te(t,s,i,r,o){e.checkAndThrow(n.Envelope1D.unit().contains(i),"QuadraticBezierHelper::getClosestCoordinateSegment");const a=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(a);let m=Number.MAX_VALUE;const h=[0],u=Ie(a,s,h);if(i.containsCoordinate(h[0]))m=n.Point2D.distance(s,u);else{h[0]=i.vmin,je(a,h[0],u),m=n.Point2D.distance(u,s);const t=new n.Point2D;je(a,i.vmax,t);const e=n.Point2D.distance(t,s);m>e&&(u.setCoordsPoint2D(t),h[0]=i.vmax,m=e)}if(!r)return h[0];if(i.vmin<=0){const e=new n.Point2D;t.queryCoord2DExtended(-1,e,!0);const r=new n.Point2D;t.queryCoord2D(i.vmin,r);const o=new Nr({start:e,end:r}),a=o.getClosestCoordinate(s,!0);if(a<1){const t=o.getCoord2D(a),e=n.Point2D.distance(t,s);e<m&&(m=e,h[0]=a-1,u.assign(t))}}if(i.vmin>=1){const e=new n.Point2D;t.queryCoord2DExtended(2,e,!0);const r=new n.Point2D;t.queryCoord2D(i.vmax,r);const o=new Nr({start:r,end:e}),a=o.getClosestCoordinate(s,!0);if(a>0){const t=o.getCoord2D(a),e=n.Point2D.distance(t,s);e<m&&(m=e,h[0]=1+a,u.assign(t))}}return h[0]}function Ie(t,e,s){const i=t[2].sub(t[1]).sub(t[1].sub(t[0])),r=t[1].sub(t[0]),o=t[0].sub(e),a=o.dotProduct(r),m=o.dotProduct(i)+2*r.dotProduct(r),h=3*r.dotProduct(i),u=i.dotProduct(i),l=n.makePrimitiveArray(3,Number.NaN),c=bt(u,h,m,a,n.Envelope1D.unit(),!1,l),g=t[0].clone();let d=0,p=n.Point2D.sqrDistance(t[0],e),_=n.Point2D.sqrDistance(t[2],e);_<p&&(d=1,g.assign(t[2]),p=_);for(let s=0;s<c;s++){const i=new n.Point2D;je(t,l[s],i),_=n.Point2D.sqrDistance(i,e),_<p&&(p=_,g.assign(i),d=l[s])}return s&&(s[0]=d),g}function Me(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,3);const i=n.makeObjectArray(n.Point2D,3);Re(t,e.vmin,e.vmax,i),s.setFromPoints(i,3)}function Ne(t,e,s){s.setEmpty();const i=[];i.push(new n.Envelope1D(0,1));const r=.5*Math.max(e.width(),e.height());for(;i.length;){const o=i.at(-1);i.pop();const a=new d;if(Me(t,o,a),a.isIntersectingW(e)){const t=Math.max(a.width(),a.height());if(e.containsW(a)||t<=r||o.width()<1e-12)s.merge(o);else{const t=o.getCenter();i.push(n.Envelope1D.construct(o.vmin,t)),i.push(n.Envelope1D.construct(t,o.vmax))}}}}function qe(t){const e=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(e);const s=Ye(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function Ye(t){let e=!1;for(let s=0;s<2;s++){const i=n.compareNoNANs(t[0][s],t[2][s]);i>0?(n.compareNoNANs(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),n.compareNoNANs(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):i<0?(n.compareNoNANs(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),n.compareNoNANs(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function Xe(t,e,s,i){(new n.Point2D).setCoordsPoint2D(t[0]),(new n.Point2D).setCoordsPoint2D(t[1]),(new n.Point2D).setCoordsPoint2D(t[2]);const r=new n.Point2D,o=new n.Point2D,a=new n.Point2D;if(n.lerpPoint2D(t[0],t[1],e,r),n.lerpPoint2D(t[1],t[2],e,o),n.lerpPoint2D(r,o,e,a),s&&(s[0].assign(t[0]),s[1].assign(r),s[2].assign(a)),i){const e=t[2];i[0].assign(a),i[1].assign(o),i[2].assign(e)}}function Re(t,e,s,i){if(e===s){const s=new n.Point2D;return je(t,e,s),i[0]=s,i[1]=s,void(i[2]=s)}const r=n.makeObjectArray(n.Point2D,3);Xe(t,s,r,null),Xe(r,e/s,null,r),je(t,e,r[0]),je(t,s,r[2]),i[0].setCoordsPoint2D(r[0]),i[1].setCoordsPoint2D(r[1]),i[2].setCoordsPoint2D(r[2])}function Fe(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==ke(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Ve(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==Le(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function ke(t,s,i,r,o,a,m,h,u,l){if(null!=o&&(o.length=0),null!==a&&(a.length=0),null!==r&&(r.length=0),i.isDegenerate(0)){const t=[0,0],e=s.intersectPoint(i.getStartXY(),t,m);if(e>0){if(null!==o)for(let s=0;s<e;s++)o.push(t[s]);if(null!==a)for(let t=0;t<e;t++)a.push(0);if(null!==r)for(let i=0;i<e;i++){const e=new n.Point2D;s.queryCoord2D(t[i],e),r.push(e)}}return e}const c=k(s,i);if(m=Math.max(m,c),s.isDegenerateToLineHelper(c)){const t=new Nr({start:s.getStartXY(),end:s.getEndXY()}),e=st(t,i,r,o,a,m,h,l);if(o)for(let n=0;n<e;++n){const e=t.getCoord2D(o[n]);o[n]=s.getClosestCoordinate(e,!1)}return e}if(L(s,i,m))return 0;const g=x.constructPoint2D(i.getStartXY()),d=x.constructPoint2D(i.getEndXY()).sub(g),p=d.clone();p.leftPerpendicularThis();const _=x.constructPoint2D(s.m_cp).sub(x.constructPoint2D(s.getStartXY())),P=x.constructPoint2D(s.getEndXY()).sub(x.constructPoint2D(s.m_cp));let f=_.dotProduct(p).toDouble(),y=P.sub(_).dotProduct(p).toDouble();const D=n.makePrimitiveArray(12,Number.NaN),v=n.makePrimitiveArray(12,Number.NaN);let E=function(t,e,s,i){const r=new n.ECoordinate,o=It(new n.ECoordinate(t),new n.ECoordinate(e),s,r);return i[0]=r.value(),o}(y,f,n.Envelope1D.unit(),D);E<0&&(D[0]=0,D[1]=1,E=2);let C,b=0;for(let t=0,e=b;t<E;++t){const r=s.getCoord2D(D[t+e]);v[b]=i.getClosestCoordinate(r,!1),n.Point2D.distance(r,i.getCoord2D(v[b]))<=m&&(D[b]=D[t+e],b++)}const A=n.makeObjectArray(n.Point2D,3);s.queryControlPoints(A);{const t=n.makeObjectArray(x,3);if(Oe(A,t,!1),t[0]=t[0].sub(g),d.x.abs().gte(d.y.abs())){const e=d.y.div(d.x);y=t[2].y.sub(t[2].x.mul(e)).toDouble(),f=t[1].y.sub(t[1].x.mul(e)).toDouble(),C=t[0].y.sub(t[0].x.mul(e)).toDouble()}else{const e=d.x.div(d.y);y=t[2].x.sub(t[2].y.mul(e)).toDouble(),f=t[1].x.sub(t[1].y.mul(e)).toDouble(),C=t[0].x.sub(t[0].y.mul(e)).toDouble()}}const w=s.getEndXY().equals(i.getStartXY())||s.getEndXY().equals(i.getEndXY()),S=[0,0];E=Ct(y,f,C,n.Envelope1D.unit(),w,S);for(let t=0,e=b;t<E;++t){D[t+e]=S[t];const r=s.getCoord2D(D[t+e]);v[b]=i.getClosestCoordinate(r,!1),n.Point2D.distance(r,i.getCoord2D(v[b]))<=m&&(D[b]=D[t+e],b++)}e.geometryReleaseAssert(b<D.length+4),E=s.intersectPoint(i.getStartXY(),S,m);for(let t=0;t<E;t++)D[b]=S[t],v[b++]=0;E=s.intersectPoint(i.getEndXY(),S,m);for(let t=0;t<E;t++)D[b]=S[t],v[b++]=1;E=i.intersectPoint(s.getStartXY(),S,m);for(let t=0;t<E;t++)v[b]=S[t],D[b++]=0;E=i.intersectPoint(s.getEndXY(),S,m);for(let t=0;t<E;t++)v[b]=S[t],D[b++]=0;return 0===b?0:Tr(t,s,i,D,v,b,r,o,a,m,h,0,l)}function Le(t,e,s,i,o,a,m,h,u,l){if($i(s))return ke(t,e,new Nr({start:s.getStartXY(),end:s.getEndXY()}),i,o,a,m,h,0,l);const c=k(e,s);if(L(e,s,m=Math.max(m,c)))return 0;const g=[],d=[],p=n.makeObjectArray(n.Point2D,3);{e.queryControlPoints(p);const t=n.makeObjectArray(n.Point2D,3),i=new r.Transformation2D;s.canonicToWorldTransformation(i);const o=new r.Transformation2D;o.setInvert(i),o.transformPoints2D(p,3,t);const a=n.makeObjectArray(x,3);Oe(t,a);const u=[a[0].x,a[1].x,a[2].x],l=[a[0].y,a[1].y,a[2].y],c=n.makeObjectArray(n.MPValue,3);c[0].setDouble(s.getSemiMinorAxis()),c[0].sqrThis(),c[1].setDouble(s.getSemiMajorAxis()),c[1].sqrThis(),c[2]=c[0],c[2].mul(c[1]),c[2].negate();const _=Zt(u,2,l,2,null,0,c,0,n.Envelope1D.unit(),n.Envelope1D.unit(),g,h);if(_>0){let t=0;for(let i=0;i<_;i++){const r=new n.Point2D;e.queryCoord2D(g[i],r);const o=s.getClosestCoordinate(r,!1),a=new n.Point2D;s.queryCoord2D(o,a),n.Point2D.distance(r,a)<=m&&(g[t]=g[i],d.push(o),t++)}g.length=t}}const _=[0,1];for(let t=0;t<2;t++){const e=0===t?s.getStartXY():s.getEndXY(),i=[0];Ie(p,e,i);const r=new n.Point2D;je(p,i[0],r),n.Point2D.distance(e,r)<=m&&(g.push(i[0]),d.push(_[t]))}for(let t=0;t<2;t++){const e=[0,2];{const i=s.getClosestCoordinate(p[e[t]],!1),r=new n.Point2D;s.queryCoord2D(i,r),n.Point2D.distance(p[e[t]],r)<=m&&(g.push(_[t]),d.push(i))}}return Tr(t,e,s,g,d,g.length,i,o,a,m,h,0,l)}function ze(t,e,s,i,r,o,a,m,h,u){const l=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(l);const c=n.makeObjectArray(n.Point2D,3);if(s.queryControlPoints(c),z(l,c,3)<0)return ze(t,s,e,i,o,r,a,m,h,!u);const g=k(e,s);if(L(e,s,a=Math.max(a,g)))return 0;if(function(t,e,s,i,r,o,a,m,h){const u=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(u);const l=n.makeObjectArray(n.Point2D,3);if(e.queryControlPoints(l),u[0].equals(l[0])){if(u[1].equals(l[1])&&u[2].equals(l[2]))return s&&(s.length=0,s.push(u[0]),s.push(u[2])),i&&(i.length=0,i.push(0),i.push(1)),r&&(r.length=0,r.push(0),r.push(1)),!0;if(!u[0].equals(l[2]))return!1}return!!(u[0].equals(l[2])&&u[1].equals(l[1])&&u[2].equals(l[0]))&&(i&&(i.length=0,i.push(0),i.push(1),h&&(i[1]=n.swap(i[0],i[0]=i[1]))),r&&(r.length=0,r.push(1),r.push(0),h&&(r[1]=n.swap(r[0],r[0]=r[1]))),s&&(s.length=0,s.push(u[0]),s.push(u[2]),h&&(s[1]=n.swap(s[0],s[0]=s[1]))),!0)}(e,s,i,r,o,0,0,0,u))return 2;const p=new n.Envelope1D(0,1),_=new n.Envelope1D(0,1);{const t=new d;Me(l,n.Envelope1D.unit(),t);const e=new d;Me(c,n.Envelope1D.unit(),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Ne(l,t,p),Ne(c,t,_),p.isEmpty()||_.isEmpty())return 0;Re(l,p.vmin,p.vmax,l),Re(c,_.vmin,_.vmax,c)}}const P=Ir(l,2,c,2,a);if(0===P)return 0;const f=[],y=[];if(-1===P){const t=n.makeObjectArray(x,3);Oe(l,t);const e=[t[0].x,t[1].x,t[2].x],s=[t[0].y,t[1].y,t[2].y],i=n.makeObjectArray(x,3);Oe(c,i);const r=Ht(e,2,s,2,null,0,[i[0].x,i[1].x,i[2].x],2,[i[0].y,i[1].y,i[2].y],2,null,0,0,n.Envelope1D.unit(),n.Envelope1D.unit(),f,y,u,0,u);if(r>0){let t=0;for(let e=0;e<r;e++){const s=new n.Point2D,i=new n.Point2D;je(c,y[e],i),je(l,f[e],s),n.Point2D.distance(s,i)<=a&&(f[t]=f[e],y[t]=y[e],t++)}f.length=t,y.length=t}}for(let t=0;t<2;t++){const e=0===t?l:c,s=0===t?c:l;for(let i=0;i<2;i++){const r=0===i?0:2,o=[0];Ie(s,e[r],o);const m=new n.Point2D;je(s,o[0],m),n.Point2D.distance(e[r],m)<=a&&(0===t?(f.push(0===r?0:1),y.push(o[0])):(y.push(0===r?0:1),f.push(o[0])))}}if(0===f.length)return 0;if(!p.equalsRange(0,1))for(let t=0;t<f.length;++t)f[t]=Ot.recalculateParentT(p.vmin,p.vmax,f[t]);if(!_.equalsRange(0,1))for(let t=0;t<y.length;++t)y[t]=Ot.recalculateParentT(_.vmin,_.vmax,y[t]);return Tr(t,e,s,f,y,f.length,i,r,o,a,m,0,u)}function Ge(t,e,s=!1){const n=t[1].sub(t[0]);e[1].assign(n.mul(2)),e[2].assign(t[2].sub(t[1]).sub(n)),s?e[0].setCoords(0,0):e[0].assign(t[0])}function Oe(t,e,s=!1){const i=x.constructPoint2D(t[1]),r=i.sub(x.constructPoint2D(t[0]));e[1]=r.mul(n.MPValue.constructInt32(2)),e[2]=x.constructPoint2D(t[2]).sub(i).sub(r),e[0]=s?new x(n.s_zero$1,n.s_zero$1):x.constructPoint2D(t[0])}function je(t,e,s,i){if(i){if(e<0)return void Z(new Nr({start:t[0],end:t[0].add(ve(t,0).getUnitVector())}),e,s);if(e>1)return void Z(new Nr({start:t[2],end:t[2].add(ve(t,1).getUnitVector())}),e-1,s)}if(e<=.5){const i=t[1].clone(),r=new n.Point2D;n.lerpPointLo(2,t[0],i,e,r);const o=new n.Point2D;n.lerpPointLo(2,i,t[2],e,o);const a=new n.Point2D;n.lerpPointLo(2,r,o,e,a),s.assign(a)}else{const i=t[1].clone(),r=new n.Point2D;n.lerpPointHi(2,t[0],i,e,r);const o=new n.Point2D;n.lerpPointHi(2,i,t[2],e,o);const a=new n.Point2D;n.lerpPointHi(2,r,o,e,a),s.assign(a)}}function Be(t,e){let s=1;t[1].isEqualPoint2D(t[0])&&(s=2,t[2].isEqualPoint2D(t[0])&&(s=3));let i=2;t[2].isEqualPoint2D(t[3])&&(i=1,t[1].isEqualPoint2D(t[3])&&(i=0)),e[0].assign(t[0]),e[2].assign(t[3]);const r=n.Point2D.intersectLinesAtOnePoint(t[0],t[s],t[i],t[3]),o=new n.Point2D;n.lerpPoint2D(t[0],t[3],.5,o);const a=new n.Point2D;zs(t,.5,a);const m=new n.Point2D;e[1].assign(r),je(e,.5,m);const h=new n.Point2D;e[1].assign(o),je(e,.5,h);const u=n.Point2D.sqrDistance(a,m),l=n.Point2D.sqrDistance(a,h);return u<l?(e[1].setCoordsPoint2D(r),Math.sqrt(u)):(e[1].setCoordsPoint2D(o),Math.sqrt(l))}function We(t,e,s){s[0].assign(t[0]),s[1].assign(t[1]),s[2].assign(t[2]);const i=new n.Point2D;ii(t,e,.5,i);const r=new n.Point2D;je(s,.5,r);const o=n.Point2D.sqrDistance(i,r);return Math.sqrt(o)}const He=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],Ze=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],Ue=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],Qe=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],$e=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],Ke=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function Je(t,e,s,i){const r=.5*(i-s),o=s+r,a=new n.KahanSummator(0);for(let s=0,i=Math.trunc(t/2);s<i;++s){let i,m;switch(t){case 4:i=He[s][0],m=He[s][1];break;case 8:i=Ze[s][0],m=Ze[s][1];break;case 16:i=Ue[s][0],m=Ue[s][1];break;case 32:i=Qe[s][0],m=Qe[s][1];break;case 64:i=$e[s][0],m=$e[s][1];break;case 128:i=Ke[s][0],m=Ke[s][1];break;default:throw new Error("Quadrature_integral: invalid n")}const h=n.fma(-.5,i,o),u=n.fma(r,i,o);a.pe(e(h)*m),a.pe(e(u)*m)}return a.getResult()*r}class ts extends Pt{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!0}),this.m_segmentBufferCTor=qr):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=qr,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=qr):t.envelope?e.throwNotImplementedException("envelope constructor not impl"):e.throwInternalErrorException("bad arg to polygon constructor"):(super({bPolygon:!0}),this.m_segmentBufferCTor=qr)}assignMove(t){return t.copyTo(this),this}assignCopy(t){return t.copyTo(this),this}getBoundary(){return Dt(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return ts.type}getDimension(){return 2}createInstance(){return new ts({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}ts.type=e.GeometryType.enumPolygon;var es=s.VertexDescription;const ss=-1;class ns{constructor(t){this.m_shape=t}userSort(t,e,s){this.m_shape.sortVerticesSimpleByYHelper(s,t,e)}getValue(t){return this.m_shape.getY(t)}}class is{constructor(t){!function(t){return void 0!==t.parent}(t)?(this.m_parent=t.copy.m_parent,this.m_geometry=t.copy.m_geometry,this.m_path=t.copy.m_path,this.m_vertex=t.copy.m_vertex,this.m_index=t.copy.m_index,this.m_bSkipMultiPoints=t.copy.m_bSkipMultiPoints,this.m_firstVertex=t.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=t.copy.m_selection,this.m_bOneGeom=t.copy.m_bOneGeom):(this.m_parent=t.parent,this.m_geometry=t.geometry,this.m_path=t.path,this.m_vertex=t.vertex,this.m_firstVertex=t.firstVertex,this.m_index=t.selection?0:t.index,this.m_bSkipMultiPoints=t.bSkipMultiPoints,this.m_selection=t.selection,this.m_bOneGeom=t.bOneGeom,this.m_bFirst=!0)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==ss;){for(;this.m_path!==ss;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==ss)return this.m_vertex;if(this.m_bOneGeom)return ss;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===ss)break;this.m_bSkipMultiPoints&&!e.isMultiPath(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return ss}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const t=this.m_parent.m_selectedVertices[this.m_index++];if(t!==ss&&(this.m_path=this.m_parent.getPathFromVertex(t),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),t}return ss}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==ss?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==ss&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):ss}currentGeometry(){return this.m_geometry}currentPath(){return this.m_path}static create_(t,e,s,n,i,r,o,a,m){return new is({parent:t,geometry:e,path:s,vertex:n,firstVertex:i,index:r,bSkipMultiPoints:o,selection:a,bOneGeom:m})}}class rs{constructor(t){this.parentage=t}equals(t){return this.parentage===t.parentage}}class os{setPrevPath(t,e){this.m_pathIndexList.setField(t,1,e)}setNextPath(t,e){this.m_pathIndexList.setField(t,2,e)}setPathFlags(t,e){this.m_pathIndexList.setField(t,6,e)}getPathFlags(t){return this.m_pathIndexList.getField(t,6)}setPathGeometry(t,e){this.m_pathIndexList.setField(t,7,e)}getPathIndex(t){return this.m_pathIndexList.getField(t,0)}setNextGeometry(t,e){this.m_geometryIndexList.setField(t,1,e)}setPrevGeometry(t,e){this.m_geometryIndexList.setField(t,0,e)}getGeometryIndex(t){return this.m_geometryIndexList.getField(t,7)}setFirstPath(t,e){this.m_geometryIndexList.setField(t,3,e)}setLastPath(t,e){this.m_geometryIndexList.setField(t,4,e)}newGeometry(t){const e=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(e,2,t),this.m_geometryIndexList.setField(e,5,0),this.m_geometryIndexList.setField(e,6,0),this.m_geometryIndexList.setField(e,7,this.m_geometryIndexList.elementToIndex(e)),e}freeGeometry(t){this.m_geometryIndexList.deleteElement(t)}newPath(t){const e=this.m_pathIndexList.newElement(),s=this.m_pathIndexList.elementToIndex(e);if(this.m_pathIndexList.setField(e,0,s),this.m_pathIndexList.setField(e,3,0),this.m_pathIndexList.setField(e,6,0),this.setPathGeometry(e,t),s>=this.m_pathAreas.length){const t=Math.trunc(s<16?16:3*s/2);this.m_pathAreas.length=t,this.m_pathLengths.length=t}return this.m_pathAreas[s]=0,this.m_pathLengths[s]=0,this.m_pathCount++,e}freePath(t){this.m_pathIndexList.deleteElement(t),this.m_pathCount--}newVertex(t){const e=this.m_vertexIndexList.newElement(),s=t>=0?t:this.m_vertexIndexList.elementToIndex(e);if(this.m_vertexIndexList.setField(e,0,s),t<0){if(s>=this.m_vertices.getPointCount()){const t=Math.trunc(s<16?16:3*s/2);this.m_vertices.reserveRounded(t),this.m_vertices.resizeNoInit(t),null!==this.m_segments&&(this.m_segments.length=t),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[s]=null)}return this.m_pointCount++,e}freeVertex(t){this.unselect(t);const e=this.getVertexIndex(t);this.m_vertexIndexList.deleteElement(t),this.m_pointCount--;for(let t=0,s=this.m_indices.length;t<s;t++){if(t===this.m_selectionIndex)continue;const s=this.m_indices[t];null!==s&&s.size()>e&&s.write(e,-1)}this.m_weights&&this.m_weights.size()>e&&this.m_weights.write(e,1),this.m_ranks&&this.m_ranks.size()>e&&this.m_ranks.write(e,1),this.m_segmentWeights&&this.m_segmentWeights.size()>e&&this.m_segmentWeights.write(e,1),this.m_segmentRanks&&this.m_segmentRanks.size()>e&&this.m_segmentRanks.write(e,1),this.m_segments&&this.setSegmentToIndex(e,null)}insertVertex_(t,e,s,n){this.m_hasForceSetEnvelope=0;const i=e!==ss?this.getPrevVertex(e):this.getLastVertex(t),r=i!==ss?this.getNextVertex(i):ss,o=this.newVertex(null===s?this.m_pointCount:-1),a=this.getVertexIndex(o);null!==s&&this.m_vertices.setPointByValNoCurves(a,s),this.setPathToVertex(o,t),this.setNextVertex(o,r),this.setPrevVertex(o,i),r!==ss&&this.setPrevVertex(r,o),i!==ss&&this.setNextVertex(i,o);const m=this.isClosedPath(t),h=this.getFirstVertex(t);e===ss&&this.setLastVertex(t,o),e===h&&(m&&n&&h!==ss||this.setFirstVertex(t,o)),m&&r===ss&&(this.setNextVertex(o,o),this.setPrevVertex(o,o)),this.setPathSize(t,this.getPathSize(t)+1);const u=this.getGeometryFromPath(t);return this.setGeometryVertexCount(u,this.getPointCount(u)+1),o}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new s.Point({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPoint(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return this.appendMultiPoint(s,t,e),s}addPoint_(t,s){const n=this.createGeometry(e.GeometryType.enumMultiPoint,t.getDescription());return this.appendPoint(n,t,s),n}appendMultiPath_(t,e){if(e.isEmpty())return;const s=e.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+s.getPointCount()),this.m_verticesMp.addPoints(e,0,s.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const n=null!==this.m_segments||null!==s.getSegmentFlagsStreamRef();this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+s.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+s.getPathCount());for(let e=0,i=s.getPathCount();e<i;e++){if(0===s.getPathSize(e))continue;const i=this.insertPath(t,ss);this.setClosedPath(i,s.isClosedPath(e));for(let t=s.getPathStart(e),r=s.getPathEnd(e);t<r;t++){const e=this.insertVertex_(i,ss,null,!1);if(n){const n=this.getVertexIndex(e);if(1&s.getSegmentFlags(t))this.setSegmentToIndex(n,null);else{const e=new qr;s.querySegment(t,e,!0),this.setSegmentToIndex(n,e.releaseSegment())}}}s.isStrongPathStart(e)&&this.setStrongPathStart(i,!0),s.isStrongPathEnd(e)&&this.setStrongPathEnd(i,!0)}}addMultiPath(t,s){const n=this.createGeometry(t.getGeometryType(),t.getDescription());return t.getGeometryType()===e.GeometryType.enumPolygon&&this.setFillRule(n,t.getFillRule()),this.appendMultiPath(n,t,s),n}appendMultiPathPolyline(t,e,s){const n=e.getImpl(),r=null!==this.m_segments||null!==n.getSegmentFlagsStreamRef(),o=new i.Envelope2D;e.queryEnvelope(o);{const i=s.clone();let o=n.getPointCount();const a=n.getAccelerators();if(a&&a.getQuadTree()&&(o=a.getQuadTree().getIntersectionCount(i,0,n.getPointCount()+1)),o<e.getPointCount()){if(0===o)return;const s=n.queryLimitedSegmentIterator(i);let a=-1,m=-100,h=-1,u=0,l=-1,c=ss,g=!1,d=s.nextSegment();if(null!==d)for(;;d=s.nextSegment()){let i=null===d;const o=null!==d?s.getPathIndex():a,p=null!==d?s.getStartPointIndex():m;if(i||(a===o&&m+1===p?u++:i=!0),i){if(-1!==l){let t=-1,s=-1;if(u===h){this.setClosedPath(c,g);const i=n.getPathEnd(a);this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i-l),this.m_verticesMp.addPoints(e,l,i),s=n.getPathSize(a),t=i-1}else if(!g||m+1<n.getPathEnd(a))this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+m+2-l),this.m_verticesMp.addPoints(e,l,m+2),s=m-l+2,t=m;else{this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+m+2-l),this.m_verticesMp?.addPoints(e,l,m+1),t=m,s=m-l+1;const i=n.getPathStart(a);this.m_verticesMp.addPoints(e,i,i+1),s+=1}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);for(let e=0,i=l;e<s;e++,i++){const e=this.insertVertex_(c,ss,null,!1);if(r){const s=this.getVertexIndex(e);if(1&n.getSegmentFlags(i)||i>t)this.setSegmentToIndex(s,null);else{const t=new qr;n.getSegmentBuffer(i,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(null===d)break;u=1,l=p,a!==o?(c=this.insertPath(t,ss),this.setClosedPath(c,!1),h=n.getSegmentCountPath(o),g=n.isClosedPath(o),a=o):c=this.insertPath(t,ss)}m=p}return}}this.appendMultiPath_(t,e)}appendMultiPathPolygon(t,s,r){const o=s.getImpl(),a=null!==this.m_segments||null!==o.getSegmentFlagsStreamRef(),m=i.Envelope2D.constructEmpty();s.queryEnvelope(m),e.geometryReleaseAssert(r.isIntersecting(m)&&!r.containsEnvelope(m));let h=i.Envelope2D.construct(Number.NEGATIVE_INFINITY,r.ymin,Number.POSITIVE_INFINITY,r.ymax),u=i.Envelope2D.construct(r.xmin,Number.NEGATIVE_INFINITY,r.xmax,Number.POSITIVE_INFINITY);const l=o.getAccelerators();if(l&&l.getQuadTree()){const t=l.getQuadTree(),e=t.getIntersectionCount(h,0,0);e>t.getIntersectionCount(u,0,e+1)&&(u=n.swap(h,h=u))}else h.height()>u.width()&&(u=n.swap(h,h=u));const c=[],g=o.queryLimitedSegmentIterator(h);let d=-1,p=-100,_=-1,P=0,f=-1,y=-1,x=ss,D=!0,v=g.nextSegment();if(null!==v)for(;;v=g.nextSegment()){let r=null===v;const m=null!==v?g.getPathIndex():d,h=null!==v?g.getStartPointIndex():p;if(r||(m===d?p+1===h?P++:r=!0:(r=d>=0,d<0&&(d=m,_=o.getSegmentCountPath(d),f=h,x=ss,P=1))),r){if(0!==c.length||_!==P){0!==c.length&&c[0].first===f||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(s,f,f+1),-1===y&&(y=f),x===ss&&(x=this.insertPath(t,ss),this.setClosedPath(x,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(x,ss,null,!1));for(const{first:n,second:i}of c){-1===y&&(y=n);let r=-1,m=-1;const h=n+i-1;if(i===_){const t=h+1;m=t-n,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+m),this.m_verticesMp.addPoints(s,n,t),r=h,e.geometryReleaseAssert(1===c.length)}else if(h+1<o.getPathEnd(d)){const t=h+2;m=t-n,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+m),this.m_verticesMp.addPoints(s,n,t),r=h}else{const t=o.getPathStart(d),e=t!==y?1:0,i=h+1;m=i-n+e,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(i-n)+e),this.m_verticesMp.addPoints(s,n,i),r=h,e>0&&this.m_verticesMp?.addPoints(s,t,t+1)}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),x===ss&&(x=this.insertPath(t,ss),this.setClosedPath(x,!0));for(let t=0,e=n;t<m;t++,e++){const t=this.insertVertex_(x,ss,null,!1);if(a){const s=this.getVertexIndex(t);if(1&o.getSegmentFlags(e)||e>r)this.setSegmentToIndex(s,null);else{const t=new qr;o.getSegmentBuffer(e,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(0===c.length||c.at(-1).first+c.at(-1).second!==f+P){let t=f+P;t===s.getPathEnd(d)&&(t=s.getPathStart(d)),y!==t&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(s,t,t+1),this.insertVertex_(x,ss,null,!1))}}c.length=0,D=!0,m!==d&&(d=m,_=o.getSegmentCountPath(d),x=ss,y=-1),f=h,P=1}if(!v)break;{const t=i.Envelope2D.constructEmpty();v.queryLooseEnvelope(t),u.isIntersecting(t)?(D?c.push(n.makePair(h,1)):c.at(-1).second++,D=!1):D=!0}p=h}}appendMultiPath(t,s,n){if(void 0===n)return void this.appendMultiPath_(t,s);if(s.isEmpty())return;const r=s.getGeometryType()===e.GeometryType.enumPolygon,o=i.Envelope2D.constructEmpty();s.queryEnvelope(o),n.isIntersecting(o)&&(!n.containsEnvelope(o)&&s.getPointCount()>10?r?this.appendMultiPathPolygon(t,s,n):this.appendMultiPathPolyline(t,s,n):this.appendMultiPath_(t,s))}appendPoint(t,e,s){if(e.isEmpty())return;if(void 0!==s&&!s.contains(e.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(e),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const n=this.insertPath(t,ss);this.insertVertex_(n,ss,null,!1)}appendMultiPoint_(t,e){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+e.getPointCount()),this.m_verticesMp.addPoints(e,0,e.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+e.getPointCount());const s=this.insertPath(t,ss);for(let t=0,n=e.getPointCount();t<n;t++)this.insertVertex_(s,ss,null,!1)}appendMultiPoint(t,e,s){if(void 0===s)return void this.appendMultiPoint_(t,e);const n=e.getAttributeStreamRef(0);let i=0;for(let t=0,r=e.getPointCount();t<r;t++){const e=n.readPoint2D(2*t);s.contains(e)&&i++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i);let r=-1,o=-1,a=0;for(let t=0,i=e.getPointCount();t<i;t++){const i=n.readPoint2D(2*t);s.contains(i)?(-1===r&&(r=t,o=t),o++):r>=0&&(this.m_verticesMp.addPoints(e,r,o-r),r=-1,a++)}if(r>0&&(this.m_verticesMp.addPoints(e,r,o-r),a++),!a)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+i);const m=this.insertPath(t,ss);for(let t=0,i=e.getPointCount();t<i;t++){const e=n.readPoint2D(2*t);s.contains(e)&&this.insertVertex_(m,ss,null,!1)}}splitSegmentForward(t,s,n,i,r){const o=this.getNextVertex(t);o===ss&&e.throwInvalidArgumentException("Edit_shape.split_segment_forward_");const a=this.getHelperPoint(),m=this.getPathFromVertex(t);let h=t;const u=this.hasSegmentParentage();for(let t=0,i=s.getResultSegmentCount(n);t<i;t++){const l=this.getVertexIndex(h),c=this.getNextVertex(h),g=s.getResultSegment(n,t);let d=null;if(g.getGeometryType()!==e.GeometryType.enumLine&&(d=g.clone(),d.dropAllAttributes()),0===t&&(g.queryStart(a),this.setSegmentToIndex(l,null),this.setPointEx(h,a,s.getResultSegmentStartPointRank(n,t),s.getResultSegmentStartPointWeight(n,t),r)),this.setSegmentRank(h,s.getResultSegmentInteriorRank(n,t)),this.setSegmentWeight(h,s.getResultSegmentInteriorWeight(n,t)),u){const e=s.getResultSegmentSegmentParentage(n,t),i=s.getResultSegmentStartPointIsBreak(n,t);this.setSegmentParentageAndBreak(h,e,i)}if(g.queryEnd(a),t<i-1){this.setSegmentToIndex(l,d);const e=this.insertVertex(m,c,a);this.setWeight(e,s.getResultSegmentEndPointWeight(n,t)),this.setRank(e,s.getResultSegmentEndPointRank(n,t)),this.select(e),h=e}else{this.setPointEx(o,a,s.getResultSegmentEndPointRank(n,t),s.getResultSegmentEndPointWeight(n,t),r);const e=s.getResultSegmentEndPointIsBreak(n,t);this.setSegmentParentageBreakVertex(o,e),this.setSegmentToIndex(l,d)}}}splitSegmentBackward(t,s,n,i,r){const o=this.getNextVertex(t);o===ss&&e.throwInvalidArgumentException("Edit_shape.split_segment_backward_");const a=this.getHelperPoint(),m=this.getPathFromVertex(t);let h=t;const u=this.hasSegmentParentage();for(let t=0,i=s.getResultSegmentCount(n);t<i;t++){const l=i-t-1,c=this.getVertexIndex(h),g=this.getNextVertex(h),d=s.getResultSegment(n,l);let p=null;if(d.getGeometryType()!==e.GeometryType.enumLine&&(p=d.clone(),p.reverse(),p.dropAllAttributes()),0===t&&(d.queryEnd(a),this.setSegmentToIndex(c,null),this.setPointEx(h,a,s.getResultSegmentEndPointRank(n,l),s.getResultSegmentEndPointWeight(n,l),r),this.setSegmentParentageAndBreak(h,s.getResultSegmentSegmentParentage(n,l),s.getResultSegmentEndPointIsBreak(n,l))),d.getGeometryType()===e.GeometryType.enumLine?this.setSegmentToIndex(c,null):this.setSegmentToIndex(c,p),this.setSegmentRank(h,s.getResultSegmentInteriorRank(n,l)),this.setSegmentWeight(h,s.getResultSegmentInteriorWeight(n,l)),d.queryStart(a),t<i-1){const t=this.insertVertex(m,g,a);this.setWeight(t,s.getResultSegmentStartPointWeight(n,l)),this.setRank(t,s.getResultSegmentStartPointRank(n,l)),this.select(t),h=t,u&&this.setSegmentParentageAndBreak(t,s.getResultSegmentSegmentParentage(n,l),s.getResultSegmentEndPointIsBreak(n,l))}else this.setPointEx(o,a,s.getResultSegmentStartPointRank(n,l),s.getResultSegmentStartPointWeight(n,l),r)}}selected_(t){return this.getUserIndex(t,this.m_selectionIndex)>=0}allocateIndex(t=!0){if(this.m_deletedIndices.length){const e=this.m_deletedIndices.pop();return t&&e.setRange(-1,0,e.size()),e}return t?s.createIndexStream(0,-1):s.createIndexStream(0)}recycleUserIndex(t){this.m_deletedIndices.push(t)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const t=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),t}return s.createIndexStream(0)}recyclePathUserIndex(t){this.m_deletedPathIndices.push(t)}peelALoop_(t,e,s){const i=this.getNextVertex(t),r=this.getNextVertex(e),o=this.getVertexIndex(t),a=this.getVertexIndex(e);if(this.setNextVertex(t,r),this.setPrevVertex(r,t),this.setNextVertex(e,i),this.setPrevVertex(i,e),this.m_segments){const t=this.getSegmentFromIndex(o),e=this.getSegmentFromIndex(a);this.setSegmentToIndex(a,null),this.setSegmentToIndex(o,e),this.setSegmentToIndex(a,t)}if(this.hasSegmentParentage()){let s=this.getSegmentParentage(e),i=this.getSegmentParentage(t);-1===s&&-1===i||(i=n.swap(s,s=i),this.setSegmentParentageAndBreak(t,i),this.setSegmentParentageAndBreak(e,s))}if(s){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e),n=[!1],o=this.insertClosedPath(s,ss,i,this.getFirstVertex(e),n);n[0]&&this.setFirstVertex(e,r);let a=this.getPathSize(e);return a-=this.getPathSize(o),this.setPathSize(e,a),o}return ss}sortVerticesSimpleByYHelper(t,e,s){t.sort(e,s,(t,e)=>{let s=this.compareVerticesSimpleY(t,e);if(0===s){const n=this.getPathInternalIndexFromVertex(t),i=this.getPathInternalIndexFromVertex(e);s=n<i?-1:n>i?1:0}return s})}sortVerticesSimpleByYHelper3D(t,s,n){e.geometryReleaseAssert(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=s.Envelope3D.constructEmpty(),this.m_hasForceSetEnvelope=0,this.m_workPoint2D=n.Point2D.getNAN(),this.m_workPoint2_2D=n.Point2D.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=ss,this.m_lastGeometry=ss,this.m_vertexIndexList=new s.StridedIndexTypeCollection(5),this.m_pathIndexList=new s.StridedIndexTypeCollection(8),this.m_geometryIndexList=new s.StridedIndexTypeCollection(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new s.BucketSort,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(t){if(0!==this.m_hasForceSetEnvelope)return new i.Envelope2D(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const e=this.hasCurves(),s=i.Envelope2D.constructEmpty(),n=this.queryVertexIterator();let r=!0;for(let t=n.next();t!==ss;t=n.next()){if(r?s.merge(this.getXY(t)):s.mergeNe(this.getXY(t)),e){const e=this.getSegment(t);if(null!==e){const t=i.Envelope2D.constructEmpty();e.queryLooseEnvelope(t),s.mergeEnvelope2D(t)}}r=!1}return s}getEnvelope3D(t){return e.geometryReleaseAssert(0),s.Envelope3D.constructEmpty()}forceSetEnvelope2D(t){this.m_hasForceSetEnvelope=1,this.m_forceSetEnvelope.setCoords(t.xmin,t.ymin,0,t.xmax,t.ymax,0)}forceSetEnvelope3D(t){e.geometryReleaseAssert(0)}forgetForceSetEnvelope(){this.m_hasForceSetEnvelope=0}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(t,s){const n=t.getGeometryType();if(e.isMultiPath(n))return this.addMultiPath(t,s);if(n===e.GeometryType.enumMultiPoint)return this.addMultiPoint(t,s);if(n===e.GeometryType.enumPoint)return this.addPoint_(t,s);if(n===e.GeometryType.enumEnvelope){const e=new ts;return e.addEnvelope(t,!1),this.addMultiPath(e,s)}e.throwInvalidArgumentException("")}appendGeometry(t,s){this.mergeVertexDescription(s.getDescription());const n=s.getGeometryType();e.isMultiPath(n)?this.appendMultiPath(t,s):n!==e.GeometryType.enumMultiPoint?e.throwInvalidArgumentException(""):this.appendMultiPoint(t,s)}assignRankToGeometryVertices(t,e){e<1&&(e=1);const s=this.queryVertexIterator();for(let t=s.next();t!==ss;t=s.next())this.setRank(t,e),this.setSegmentRank(t,e)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(e.GeometryType.enumUnknown)}collapseGeometriesToFirst(t){this.dbgVerifyVertexCounts();let s=ss,n=-1,i=-1;for(let r=this.getFirstGeometry();r!==ss;){if(t===e.GeometryType.enumUnknown||this.getGeometryType(r)===t){if(s===ss){s=r,n=this.getPathCount(s),i=this.getPointCount(s),r=this.getNextGeometry(r);continue}for(let t=this.getFirstPath(r);t!==ss;t=this.getNextPath(t))this.setPathGeometry(t,s);n+=this.getPathCount(r),i+=this.getPointCount(r);const t=this.getLastPath(s),e=this.getFirstPath(r);t!==ss?this.setNextPath(t,e):this.setFirstPath(s,e),e!==ss&&(this.setPrevPath(e,t),this.setLastPath(s,this.getLastPath(r))),this.setFirstPath(r,ss),this.setLastPath(r,ss);const o=r;r=this.getNextGeometry(r),this.setGeometryVertexCount(o,0),this.removeGeometry(o);continue}r=this.getNextGeometry(r)}return s!==ss&&(this.setGeometryVertexCount(s,i),this.setGeometryPathCount(s,n),this.dbgVerifyVertexCounts()),s}setFillRule(t,e){let s=this.m_geometryIndexList.getField(t,2);s&=-134217729,s|=1===e?134217728:0,this.m_geometryIndexList.setField(t,2,s)}getFillRule(t){return 134217728&this.m_geometryIndexList.getField(t,2)?1:0}setGeometryModified(t,e){let s=this.m_geometryIndexList.getField(t,2);!!(67108864&s)!==e&&(s&=-67108865,s|=e?67108864:0,this.m_geometryIndexList.setField(t,2,s))}getGeometryModified(t){return!!(67108864&this.m_geometryIndexList.getField(t,2))}setGeometryModifiedWithVertex(t,e){const s=this.getPathFromVertex(t),n=this.getGeometryFromPath(s);this.setGeometryModified(n,e)}getGeometryModifiedWithVertex(t){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e);return this.getGeometryModified(s)}swapGeometry(t,e){const s=this.getFirstPath(t),n=this.getFirstPath(e),i=this.getLastPath(t),r=this.getLastPath(e);for(let s=this.getFirstPath(t);s!==ss;s=this.getNextPath(s))this.setPathGeometry(s,e);for(let s=this.getFirstPath(e);s!==ss;s=this.getNextPath(s))this.setPathGeometry(s,t);this.setFirstPath(t,n),this.setFirstPath(e,s),this.setLastPath(t,r),this.setLastPath(e,i);const o=this.getPointCount(t),a=this.getPathCount(t),m=this.getPointCount(e),h=this.getPathCount(e);this.setGeometryVertexCount(t,m),this.setGeometryVertexCount(e,o),this.setGeometryPathCount(t,h),this.setGeometryPathCount(e,a);const u=this.m_geometryIndexList.getField(t,2),l=this.m_geometryIndexList.getField(e,2);this.m_geometryIndexList.setField(t,2,l),this.m_geometryIndexList.setField(e,2,u)}addPathFromMultiPath(t,s,n){const i=this.createGeometry(n?e.GeometryType.enumPolygon:e.GeometryType.enumPolyline,t.getDescription()),r=t.getImpl();if(t.getPathSize(s)<2)return i;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+t.getPathSize(s)),this.m_verticesMp.addPoints(t,t.getPathStart(s),r.getPathEnd(s)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const o=this.insertPath(i,ss);this.setClosedPath(o,r.isClosedPath(s)||n);const a=null!==this.m_segments||null!==r.getSegmentFlagsStreamRef();for(let t=r.getPathStart(s),e=r.getPathEnd(s);t<e;t++){const e=this.insertVertex_(o,ss,null,!1);if(a){const s=this.getVertexIndex(e);if(1&r.getSegmentFlags(t))this.setSegmentToIndex(s,null);else{const e=new qr;r.querySegment(t,e,!0),this.setSegmentToIndex(s,e.releaseSegment())}}}return r.isStrongPathStart(s)&&this.setStrongPathStart(o,!0),r.isStrongPathEnd(s)&&this.setStrongPathEnd(o,!0),i}getGeometry(t){const n=this.getGeometryType(t),i=function(t,n){let i,r=n,o=null;switch(r||(o=e.isMesh(t)?s.getDefaultDescription3D():s.getDefaultDescription2D(),r=o),t){case e.GeometryType.enumPoint:i=new s.Point({vd:r});break;case e.GeometryType.enumLine:i=new Nr({vd:r});break;case e.GeometryType.enumBezier:i=new pn({vd:r});break;case e.GeometryType.enumEllipticArc:i=new Di({vd:r});break;case e.GeometryType.enumRationalBezier2:i=new zt({vd:r});break;case e.GeometryType.enumBezier2:i=new Ot({vd:r});break;case e.GeometryType.enumEnvelope:i=new s.Envelope({vd:r});break;case e.GeometryType.enumMultiPoint:i=new g({vd:r});break;case e.GeometryType.enumPolyline:i=new yt({vd:r});break;case e.GeometryType.enumPolygon:i=new ts({vd:r});break;case e.GeometryType.enumMultipatch:e.throwNotImplementedException("multipatch not impl");break;case e.GeometryType.enumGeometryCollection:i=new B({vd:r});break;default:e.throwInvalidArgumentException("Geometry.create")}return i}(n,this.m_verticesMp.getDescription()),r=this.getPointCount(t);if(0===r)return i;if(e.isMultiPath(n)){const e=i.getImpl(),n=this.getPathCount(t),o=s.createIndexStream(n+1),a=s.createByteStream(n+1,0),m=i.getDescription(),h=this.hasCurves();for(let i=0,h=m.getAttributeCount();i<h;i++){const h=m.getSemantics(i),u=es.getComponentCount(h),l=s.createAttributeStreamFromSemantics(h,r),c=this.m_vertices.getAttributeStreamRef(h);let g=0,d=0,p=0;for(let e=this.getFirstPath(t);e!==ss;e=this.getNextPath(e)){let t=0;this.isClosedPath(e)&&(t|=1),this.isExterior(e)&&(t|=8),this.isStrongPathStart(e)&&(t|=2),this.isStrongPathEnd(e)&&(t|=4),t&&a.setBits(d,t);const s=this.getPathSize(e);if(o.write(d++,p),p+=s,0===h){const t=c,s=l;let n;for(let i=this.getFirstVertex(e);g<p;i=this.getNextVertex(i),g++){const e=this.getVertexIndex(i);n=t.readPoint2D(2*e),s.writePoint2D(2*g,n)}}else for(let t=this.getFirstVertex(e);g<p;t=this.getNextVertex(t),g++){const e=this.getVertexIndex(t);for(let t=0;t<u;t++){const s=c.readAsDbl(e*u+t);l.writeAsDbl(g*u+t,s)}}}e.setAttributeStreamRef(h,l),o.write(n,r)}if(e.setPathFlagsStreamRef(a),e.setPathStreamRef(o),e.notifyModifiedFlags(65535),h){let s=0,n=0;for(let i=this.getFirstPath(t);i!==ss;i=this.getNextPath(i)){s+=this.getPathSize(i);for(let t=this.getFirstVertex(i);n<s;t=this.getNextVertex(t)){const s=this.getSegment(t);null!==s&&s.isCurve()&&e.replaceSegment(n,s,!0),n++}}}}else if(n===e.GeometryType.enumMultiPoint){const e=i.getImpl(),s=i.getDescription();e.reserve(r),e.resizeNoInit(r);for(let n=0,i=s.getAttributeCount();n<i;n++){const i=s.getSemantics(n),r=es.getComponentCount(i),o=e.getAttributeStreamRef(i),a=this.m_vertices.getAttributeStreamRef(i);let m=0;const h=this.getFirstPath(t),u=this.getPathSize(h);for(let t=this.getFirstVertex(h);m<u;t=this.getNextVertex(t),m++){const e=this.getVertexIndex(t);for(let t=0;t<r;t++){const s=a.readAsDbl(e*r+t);o.writeAsDbl(m*r+t,s)}}e.setAttributeStreamRef(i,o)}e.notifyModifiedFlags(65535)}else e.throwInternalErrorException("getGeometry");return i}queryPointGeometryOnly(t,s){this.getGeometryType(t)!==e.GeometryType.enumMultiPoint&&e.throwInvalidArgumentException("get_point_geometry_only");const n=this.getPointCount(t);if(n>1&&e.throwInvalidArgumentException("get_point_geometry_only"),0===n)return s.assignVertexDescription(this.m_vertexDescription),void s.setEmpty();const i=this.getFirstPath(t),r=this.getFirstVertex(i);this.queryPoint(r,s)}removeGeometry(t){for(let e=this.getFirstPath(t);e!==ss;e=this.removePath(e));const e=this.getPrevGeometry(t),s=this.getNextGeometry(t);return e!==ss?this.setNextGeometry(e,s):this.m_firstGeometry=s,s!==ss?this.setPrevGeometry(s,e):this.m_lastGeometry=e,this.freeGeometry(t),s}createGeometry(t,e){void 0===e&&(e=s.getDefaultDescription2D());const n=this.newGeometry(t);return this.m_vertices||(this.m_verticesMp=new g({vd:e}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(e),this.m_firstGeometry===ss?(this.m_firstGeometry=n,this.m_lastGeometry=n):(this.setPrevGeometry(n,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,n),this.m_lastGeometry=n),n}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(t){return this.m_geometryIndexList.getField(t,1)}getPrevGeometry(t){return this.m_geometryIndexList.getField(t,0)}getGeometryType(t){return 16777215&this.m_geometryIndexList.getField(t,2)}setGeometryUserIndex(t,e,s){const n=this.m_geometryIndices[e],i=this.getGeometryIndex(t);i>=n.size()&&n.resize(Math.max(1.25*i,16),-1),n.write(i,s)}getGeometryUserIndex(t,e){const s=this.getGeometryIndex(t),n=this.m_geometryIndices[e];return s<n.size()?n.read(s):-1}createGeometryUserIndex(){for(let t=0;t<this.m_geometryIndices.length;t++)if(null===this.m_geometryIndices[t])return this.m_geometryIndices[t]=s.createIndexStream(0),t;this.m_geometryIndices.push(s.createIndexStream(0));const t=this.m_geometryIndices.length-1;return e.geometryReleaseAssert(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}removeGeometryUserIndex(t){for(this.m_geometryIndices[t]=null;this.m_geometryIndices.length>0&&null===this.m_geometryIndices.at(-1);)this.m_geometryIndices.pop()}getFirstPath(t){return this.m_geometryIndexList.getField(t,3)}getLastPath(t){return this.m_geometryIndexList.getField(t,4)}hasPointFeatures(){for(let t=this.getFirstGeometry();t!==ss;t=this.getNextGeometry(t))if(!e.isMultiPath(this.getGeometryType(t)))return!0;return!1}getPointCount(t){return this.m_geometryIndexList.getField(t,5)}getPathCount(t){return this.m_geometryIndexList.getField(t,6)}filterClosePoints(t,s,i,r,o){const a=t*t;let m=0;const h=this.hasCurves(),u=this.hasSegmentParentage(),l=!0;for(let t=o===ss?this.getFirstGeometry():o;t!==ss;t=o===ss?this.getNextGeometry(t):ss){const o=this.getGeometryType(t);if(!e.isMultiPath(o))continue;if(i&&o!==e.GeometryType.enumPolygon)continue;const c=this.getGeometryType(t)===e.GeometryType.enumPolygon;let g=this.getGeometryModified(t);for(let i=this.getFirstPath(t);i!==ss;){let o=0;for(let s=this.getFirstVertex(i);o<Math.trunc(this.getPathSize(i)/2);){const c=this.getNextVertex(s);if(c===ss)break;const d=this.getXY(s),p=this.getXY(c);let _=n.Point2D.sqrDistance(d,p),P=!0;do{if(_<=a){if(h){const t=this.getSegment(s);if(null!==t){const e=t.calculateLength2D();if(_=e*e,_>a)break}}if(0===_?0===m&&(m=-1):m=1,c!==this.getLastVertex(i)){const n=u&&(this.getSegmentParentageBreakVertex(s)||this.getSegmentParentageBreakVertex(c));if(this.transferAllDataToTheVertex(c,s,l),this.removeVertex(c,!1),r&&!g&&(this.setGeometryModified(t,!0),g=!0),u&&s!==c){this.setSegmentParentageBreakVertex(s,n);const t=this.getNextVertex(s);e.geometryReleaseAssert(t!==ss),this.isDiscontinuousSegmentParentage(t)&&this.setSegmentParentageBreakVertex(t,!0)}}P=!1}}while(0);P&&(s=this.getNextVertex(s)),o++}let d=this.getFirstVertex(i);for(let s=this.isClosedPath(i)?d:this.getLastVertex(i);this.getPathSize(i)>0;){const o=this.getPrevVertex(s);if(o===ss)break;{const c=this.getXY(o),p=this.getXY(s);let _=n.Point2D.sqrDistance(c,p),P=!0;do{if(_<=a){if(h){const t=this.getSegment(o);if(null!==t){const e=t.calculateLength2D();if(_=e*e,_>a)break}}if(0===_?0===m&&(m=-1):m=1,u){e.geometryReleaseAssert(this.m_segmentParentageIndex>=0);const t=this.getUserIndex(s,this.m_segmentParentageIndex);this.transferAllDataToTheVertex(o,s,l),this.setUserIndex(s,this.m_segmentParentageIndex,t)}else this.transferAllDataToTheVertex(o,s,l);const n=u&&(this.getSegmentParentageBreakVertex(s)||this.getSegmentParentageBreakVertex(o));this.removeVertex(o,!0),r&&!g&&(this.setGeometryModified(t,!0),g=!0),u&&o!==s&&(n||this.isDiscontinuousSegmentParentage(s))&&this.setSegmentParentageBreakVertex(s,!0),d===o&&(d=this.getFirstVertex(i)),P=!1}}while(0);if(P&&(s=this.getPrevVertex(s),s===d))break}}const p=this.getPathSize(i);let _=s&&p<(c?3:2);_&&c&&2===p&&h&&(_=!this.pathHasCurves(i)),_?(i=this.removePath(i),0===m&&(m=-1),r&&!g&&(this.setGeometryModified(t,!0),g=!0)):i=this.getNextPath(i)}}return m}filterClosePoints3D(t,s,n,i,r,o){return e.geometryReleaseAssert(0),0}hasDegenerateSegments(t){for(let s=this.getFirstGeometry();s!==ss;s=this.getNextGeometry(s))if(e.isMultiPath(this.getGeometryType(s)))for(let e=this.getFirstPath(s);e!==ss;){const s=this.getPathSize(e);if(0===s)return!0;let n=this.getFirstVertex(e);for(let e=0;e<s;e++){const e=this.getNextVertex(n);if(e===ss)break;const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);let r=0;if(null!==i){if(r=i.calculateLowerLength2D(),r<=t){if(r=i.calculateUpperLength2D(),r<=t)return!0;if(r=i.calculateLength2D(),r<=t)return!0}}else{const n=this.getVertexIndex(e);if(r=this.m_vertices.getShortestDistance(s,n),r<=t)return!0}n=e}e=this.getNextPath(e)}return!1}hasDegenerateSegments3D(t,s){return e.geometryReleaseAssert(0),!1}transferAllDataToTheVertex(t,e,s=!1){const n=this.getVertexIndex(t),i=this.getVertexIndex(e);if(s){let t=1,e=1;if(this.m_ranks&&(t=this.getRankWithIndex(n),e=this.getRankWithIndex(i)),t>e&&this.setRankWithIndex(i,t),t>=e&&this.m_weights){const s=this.getWeightWithIndex(n),r=this.getWeightWithIndex(i);(t>e||s>r)&&this.setWeightWithIndex(i,s)}}else{if(this.m_weights){const t=this.getWeightWithIndex(n);this.setWeightWithIndex(i,t)}if(this.m_ranks){const t=this.getRankWithIndex(n);this.setRankWithIndex(i,t)}}if(this.m_segmentWeights){const t=this.getSegmentWeightWithIndex(n);this.setSegmentWeightWithIndex(i,t)}if(this.m_segmentRanks){const t=this.getSegmentRankWithIndex(n);this.setSegmentRankWithIndex(i,t)}for(let s=0,n=this.m_indices.length;s<n;s++)if(s!==this.m_selectionIndex&&null!==this.m_indices[s]){const n=this.getUserIndex(t,s);this.setUserIndex(e,s,n)}const r=this.selected(t);r!==this.selected(e)&&(r?this.select(e):this.unselect(e))}splitSegmentAxisAware(t,s,n,i,r){let o=0;const a=this.getNextVertex(t);a===ss&&e.throwInvalidArgumentException("");const m=this.getVertexIndex(t),h=this.getVertexIndex(a),u=this.getSegmentFromIndex(m);let l=this.m_vertices.getShortestDistance(m,h);const c=this.getPathFromVertex(t),g=this.m_bHasAttributes;g&&u&&(l=u.calculateLength2D());const d=this.getSegmentParentage(t),p=this.getHelperPoint();if(u){let t=0,e=0,r=ss;for(let _=0;_<n;_++){const n=s[_];if(t<n&&n<1){const s=u.cut(t,n);if(null!==i&&(_>0&&s.setStartXY(i[_-1]),s.setEndXY(i[_]),s.normalizeAfterEndpointChange(),e=_),g){const t=l>0?u.calculateSubLengthFromStart(n)/l:0;this.m_vertices.interpolateTwoVertices(m,h,t,p)}p.setXY(s.getEndXY()),r=this.insertVertex(c,a,p),o++;const P=this.getPrevVertex(r),f=this.getVertexIndex(P);this.setSegmentToIndex(f,s),-1!==d&&this.setSegmentParentageAndBreak(r,d,!1),t=n}}if(r!==ss){const s=u.cut(t,1);null!==i&&(s.setStartXY(i[e]),s.normalizeAfterEndpointChange());const n=this.getVertexIndex(r);this.setSegmentToIndex(n,s)}}else{let t=0;for(let e=0;e<n;e++){const n=s[e];if(t<n&&n<1){this.m_vertices.interpolateTwoVertices(m,h,n,p);const t=this.insertVertex(c,a,p);o++,-1!==d&&this.setSegmentParentageAndBreak(t,d,!1)}t=n}}return o}splitSegment(t,e,s,n=null){return this.splitSegmentAxisAware(t,e,s,n,-1)}snapControlPoints(t,s,n){this.getNextVertex(t)===ss&&e.throwInvalidArgumentException("");let i=t,r=!1;for(let t=0;t<s;++t){const t=this.getVertexIndex(i),e=this.getSegmentFromIndex(t);if(e){const t=e.snapControlPoints(n);r||=t}i=this.getNextVertex(i)}return r}snapControlPointsOnSelection(t){if(!this.hasCurves())return!1;let e=0;const s=this.queryVertexIteratorOnSelection();for(let n=s.next();n!==ss;n=s.next()){const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);i&&(e|=i.snapControlPoints(t)?1:0)}return 0!==e}calculateSubLength2D(t,s,n){return e.geometryReleaseAssert(0),0}setPoint(t,e,s){if(this.setPointOnly(t,e),null!==this.m_segments){const n=this.getVertexIndex(t),i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXY(e.getXY()),i.normalizeAfterEndpointChange(),s&&i.ensureXYMonotone());const r=this.getPrevVertex(t);if(r!==ss){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!==n&&(n.setEndXY(e.getXY()),n.normalizeAfterEndpointChange(),s&&n.ensureXYMonotone())}}}setPointEx(t,e,s,n,i){this.setPoint(t,e,i);const r=this.getVertexIndex(t);this.setWeightWithIndex(r,n),this.setRankWithIndex(r,s)}setPointOnly(t,e){const s=this.getVertexIndex(t);this.m_vertices.setPointByValNoCurves(s,e)}setPointOnlyEx(t,s,n,i){e.geometryReleaseAssert(0)}queryPoint(t,e){const s=this.getVertexIndex(t);this.m_vertices.getPointByVal(s,e)}setXY(t,e){this.setXYCoords(t,e.x,e.y)}setXYCoords(t,e,s){const n=this.getVertexIndex(t);if(this.m_vertices?.setXYCoordsNoCurves(n,e,s),null!==this.m_segments){const i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXYCoords(e,s),i.normalizeAfterEndpointChange());const r=this.getPrevVertex(t);if(r!==ss){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!=n&&(n.setEndXYCoords(e,s),n.normalizeAfterEndpointChange())}}}setXYMonotonic(t,e,s){const i=this.getVertexIndex(t);if(this.m_vertices.setXYCoordsNoCurves(i,e,s),null!==this.m_segments){const r=this.getSegmentFromIndex(i);if(null!==r){const t=r.getEndXY();r.setCoordsForIntersector(new n.Point2D(e,s),t,!1),r.ensureXYMonotone()}const o=this.getPrevVertex(t);if(o!==ss){const t=this.getVertexIndex(o),i=this.getSegmentFromIndex(t);if(null!==i){const t=i.getStartXY();i.setCoordsForIntersector(t,new n.Point2D(e,s),!1),i.ensureXYMonotone()}}}}setXYMonotonicPoint2D(t,e){this.setXYMonotonic(t,e.x,e.y)}queryXY(t,e){const s=this.getVertexIndex(t);return this.m_vertices.queryXY(s,e)}getXY(t){const e=this.getVertexIndex(t);return this.m_vertices.getXY(e)}getXYWithIndex(t){return this.m_xyStream.readPoint2D(2*t)}static setSegDefault(t,s,n){e.geometryReleaseAssert(0)}setXYZ(t,s,n){e.geometryReleaseAssert(0)}setXYZCoords(t,s,n,i){e.geometryReleaseAssert(0)}queryXYZ(t,s){e.geometryReleaseAssert(0)}getXYZ(t){return e.geometryReleaseAssert(0),s.Point3D.getNAN()}getXYZWithIndex(t){return e.geometryReleaseAssert(0),s.Point3D.getNAN()}mergeVertexDescription(t){this.m_verticesMp.mergeVertexDescription(t),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(t){e.geometryReleaseAssert(0)}getAttributeAsDbl(t,e,s){return this.m_vertices.getAttributeAsDbl(t,this.getVertexIndex(e),s)}queryAttributeAsDbl(t,s,n,i){e.geometryReleaseAssert(0)}setAttribute(t,s,n,i){e.geometryReleaseAssert(0)}setAttributeInt(t,s,n,i){e.geometryReleaseAssert(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(t){return e.geometryReleaseAssert(0),0}getVertexIndex(t){return this.m_vertexIndexList.getField(t,0)}getY(t){const e=this.getVertexIndex(t);return this.m_vertices.queryXY(e,this.m_workPoint2D),this.m_workPoint2D.y}getX(t){return this.getXY(t).x}isEqualXY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(t,e){return this.queryXY(t,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(e)}isEqualXYZPoint3D(t,s){return e.geometryReleaseAssert(0),!1}setWeight(t,e){e<1&&(e=1);const n=1===e;if(null==this.m_weights){if(n)return;this.m_weights=s.createDoubleStream(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_weights.size()){if(n)return;this.m_weights.resize(i+1,1)}this.m_weights.write(i,e)}setWeightWithIndex(t,e){e<1&&(e=1);const n=1===e;if(null===this.m_weights){if(n)return;this.m_weights=s.createDoubleStream(this.m_vertices.getPointCount(),1)}if(t>=this.m_weights.size()){if(n)return;this.m_weights.resize(t+1,1)}this.m_weights.write(t,e)}getWeight(t){if(null===this.m_weights)return 1;const e=this.getVertexIndex(t);return e>=this.m_weights.size()?1:this.m_weights.read(e)}getWeightWithIndex(t){return null===this.m_weights||t>=this.m_weights.size()?1:this.m_weights.read(t)}getRank(t){if(null===this.m_ranks)return 1;const e=this.getVertexIndex(t);return e>=this.m_ranks.size()?1:this.m_ranks.read(e)}getRankWithIndex(t){return null===this.m_ranks||t>=this.m_ranks.size()?1:this.m_ranks.read(t)}setRank(t,e){e<1&&(e=1);const n=1===e;if(null===this.m_ranks){if(n)return;this.m_ranks=s.createIndexStream(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_ranks.size()){if(n)return;this.m_ranks.resize(i+1,1)}this.m_ranks.write(i,e)}setRankWithIndex(t,e){e<1&&(e=1);const n=1===e;if(null===this.m_ranks){if(n)return;this.m_ranks=s.createIndexStream(this.m_vertices.getPointCount(),1)}if(t>=this.m_ranks.size()){if(n)return;this.m_ranks.resize(t+1,1)}this.m_ranks.write(t,e)}setSegmentWeight(t,e){e<1&&(e=1);const n=1===e;if(null===this.m_segmentWeights){if(n)return;this.m_segmentWeights=s.createDoubleStream(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_segmentWeights.size()){if(n)return;this.m_segmentWeights.resize(i+1,1)}this.m_segmentWeights.write(i,e)}setSegmentWeightWithIndex(t,e){e<1&&(e=1);const n=1===e;if(null==this.m_segmentWeights){if(n)return;this.m_segmentWeights=s.createDoubleStream(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentWeights.size()){if(n)return;this.m_segmentWeights.resize(t+1,1)}this.m_segmentWeights.write(t,e)}getSegmentWeight(t){if(null===this.m_segmentWeights)return 1;const e=this.getVertexIndex(t);return e>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(e)}getSegmentWeightWithIndex(t){return null==this.m_segmentWeights||t>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(t)}getSegmentRank(t){if(null===this.m_segmentRanks)return os.st_defaultRank;const e=this.getVertexIndex(t);return e>=this.m_segmentRanks.size()?os.st_defaultRank:this.m_segmentRanks.read(e)}getSegmentRankWithIndex(t){return null===this.m_segmentRanks||t>=this.m_segmentRanks.size()?1:this.m_segmentRanks.read(t)}setSegmentRank(t,e){e<1&&(e=1);const n=1===e;if(null===this.m_segmentRanks){if(n)return;this.m_segmentRanks=s.createIndexStream(this.m_vertices.getPointCount(),1)}const i=this.getVertexIndex(t);if(i>=this.m_segmentRanks.size()){if(n)return;this.m_segmentRanks.resize(i+1,1)}this.m_segmentRanks.write(i,e)}setSegmentRankWithIndex(t,e){e<1&&(e=1);const n=1===e;if(null===this.m_segmentRanks){if(n)return;this.m_segmentRanks=s.createIndexStream(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentRanks.size()){if(n)return;this.m_segmentRanks.resize(t+1,1)}this.m_segmentRanks.write(t,e)}removeWeights(){this.m_weights=null,this.m_segmentWeights=null}removeRanks(){this.m_ranks=null,this.m_segmentRanks=null}setUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);if(n.size()<=i){if(-1===s)return;n.resize(this.m_vertices.getPointCount(),-1)}n.write(i,s)}getUserIndex(t,e){const s=this.getVertexIndex(t),n=this.m_indices[e];return s<n.size()?n.read(s):-1}addToUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);n.size()<=i&&n.resize(this.m_vertices.getPointCount(),-1);const r=n.read(i);n.write(i,r+s)}createUserIndex(){for(let t=0;t<this.m_indices.length;t++)if(null===this.m_indices[t])return this.m_indices[t]=this.allocateIndex(),t;this.m_indices.push(this.allocateIndex());const t=this.m_indices.length-1;return e.geometryReleaseAssert(t>=0&&t<=n.intMax()),t}createUserIndexUninitialized(){for(let t=0;t<this.m_indices.length;t++)if(null===this.m_indices[t])return this.m_indices[t]=this.allocateIndex(!1),t;this.m_indices.push(this.allocateIndex(!1));const t=this.m_indices.length-1;return e.geometryReleaseAssert(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillUserIndexForGeometry(t,e,s){const n=this.m_indices[e],i=n.size();for(let e=this.getFirstPath(t);e!==ss;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let r=0,o=this.getPathSize(e);r<o;r++,t=this.getNextVertex(t)){const e=this.getVertexIndex(t);e<i&&n.write(e,s)}}}fillUserIndexForSelection(t,s){e.geometryReleaseAssert(0)}removeUserIndex(t){for(this.recycleUserIndex(this.m_indices[t]),this.m_indices[t]=null;this.m_indices.length>0&&null===this.m_indices[this.m_indices.length-1];)this.m_indices.pop()}replaceCurveWithLine(t){if(null!==this.m_segments){const e=this.getVertexIndex(t);this.setSegmentToIndex(e,null)}}queryLineConnector(t,e,n=!1){const i=this.getNextVertex(t);if(i===ss)return!1;if(!this.m_bHasAttributes||n){const s=this.getXY(t);e.setStartXY(s);const n=this.getXY(i);e.setEndXY(n)}else{const n=new s.Point({vd:this.getVertexDescription()});this.queryPoint(t,n),e.setStart(n),this.queryPoint(i,n),e.setEnd(n)}return!0}queryLineConnector3D(t,s,n=!1){return e.geometryReleaseAssert(0),!1}hasCurves(){return null!==this.m_segments}geometryHasCurves(t){return e.geometryReleaseAssert(0),!1}pathHasCurves(t){if(!this.hasCurves())return!1;const s=this.getFirstVertex(t);if(s===ss)return!1;const n=this.getPathSize(t);let i=s;for(let t=0;t<n;t++,i=this.getNextVertex(i)){const t=this.getSegment(i);if(null!==t&&t.getGeometryType()!==e.GeometryType.enumLine)return!0}return!1}insertPath(t,s){let n=ss;s!==ss?(t!==this.getGeometryFromPath(s)&&e.throwInvalidArgumentException(""),n=this.getPrevPath(s)):n=this.getLastPath(t);const i=this.newPath(t);return s!==ss&&this.setPrevPath(s,i),this.setNextPath(i,s),this.setPrevPath(i,n),n!==ss?this.setNextPath(n,i):this.setFirstPath(t,i),s===ss&&this.setLastPath(t,i),this.setGeometryPathCount(t,this.getPathCount(t)+1),i}removePath(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);return e!==ss?this.setNextPath(e,s):this.setFirstPath(n,s),s!==ss?this.setPrevPath(s,e):this.setLastPath(n,e),this.clearPath(t),this.setGeometryPathCount(n,this.getPathCount(n)-1),this.freePath(t),s}clearPath(t){const e=this.getFirstVertex(t);if(e!==ss){let s=e;for(let e=0,n=this.getPathSize(t);e<n;e++){const t=s;s=this.getNextVertex(s),this.freeVertex(t)}const n=this.getGeometryFromPath(t);this.setGeometryVertexCount(n,this.getPointCount(n)-this.getPathSize(t))}this.setPathSize(t,0)}getNextPath(t){return this.m_pathIndexList.getField(t,2)}getPrevPath(t){return this.m_pathIndexList.getField(t,1)}getPathSize(t){return this.m_pathIndexList.getField(t,3)}isClosedPath(t){return!!(1&this.getPathFlags(t))}setClosedPath(t,e){if(this.isClosedPath(t)===e)return;if(this.getPathSize(t)>0){const s=this.getFirstVertex(t),n=this.getLastVertex(t);if(e){this.setNextVertex(n,s),this.setPrevVertex(s,n);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}else{this.setNextVertex(n,ss),this.setPrevVertex(s,ss);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}}const s=(1|this.getPathFlags(t))-1;this.setPathFlags(t,s|(e?1:0))}closeAllPaths(t){e.geometryReleaseAssert(0)}isStrongPathStart(t){return!!(8&this.getPathFlags(t))}isStrongPathEnd(t){return!!(16&this.getPathFlags(t))}setStrongPathStart(t,e){const s=(8|this.getPathFlags(t))-8;this.setPathFlags(t,s|(e?8:0))}setStrongPathEnd(t,e){const s=(16|this.getPathFlags(t))-16;this.setPathFlags(t,s|(e?16:0))}getGeometryFromPath(t){return this.m_pathIndexList.getField(t,7)}isExterior(t){return!!(2&this.getPathFlags(t))}setExterior(t,e){const s=(2|this.getPathFlags(t))-2;this.setPathFlags(t,s|(e?2:0))}getRingArea(t){if(this.isRingAreaValid(t))return this.m_pathAreas[this.getPathIndex(t)];const s=this.getFirstVertex(t);if(s===ss)return 0;const i=this.getXY(s),r=new n.KahanSummator(0),o=this.getPathSize(t);if(o>2){const t=i.clone(),e=t.x,a=t.y;let m=this.getNextVertex(s);const h=this.getXY(m);m=this.getNextVertex(m);const u=n.Point2D.getNAN();for(let e=2;e<o;e++,m=this.getNextVertex(m))this.queryXY(m,u),r.pe((u.x-t.x)*(h.y-a)),t.setCoordsPoint2D(h),h.setCoordsPoint2D(u);r.pe((e-t.x)*(h.y-a))}if(this.hasCurves()){let t=s;for(let s=0;s<o;s++,t=this.getNextVertex(t)){const s=this.getSegment(t);if(null===s||s.getGeometryType()===e.GeometryType.enumLine)continue;const n=2*s.calculateArea2DHelper();r.pe(n)}}this.setRingAreaValid(t,!0);const a=.5*r.getResult();return this.m_pathAreas[this.getPathIndex(t)]=a,a}getPathIndexInternal(t){return this.getPathIndex(t)}getPathInternalIndexFromVertex(t){return this.getPathIndex(this.getPathFromVertex(t))}setPathUserIndex(t,e,s){const n=this.m_pathindices[e],i=this.getPathIndex(t);n.size()<this.m_pathAreas.length&&n.resize(this.m_pathAreas.length,-1),n.write(i,s)}getPathUserIndex(t,e){const s=this.getPathIndex(t),n=this.m_pathindices[e];return s<n.size()?n.read(s):-1}createPathUserIndex(){for(let t=0;t<this.m_pathindices.length;t++)if(null===this.m_pathindices[t])return this.m_pathindices[t]=this.allocatePathIndex(),t;this.m_pathindices.push(this.allocatePathIndex());const t=this.m_pathindices.length-1;return e.geometryReleaseAssert(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillPathUserIndexForGeometry(t,e,s){const n=this.m_pathindices[e],i=n.size();for(let e=this.getFirstPath(t);e!==ss;e=this.getNextPath(e)){const t=this.getPathIndex(e);t<i&&n.write(t,s)}}removePathUserIndex(t){for(this.recyclePathUserIndex(this.m_pathindices[t]),this.m_pathindices[t]=null;this.m_pathindices.length>0&&null===this.m_pathindices.at(-1);)this.m_pathindices.pop()}movePath(t,s,n){if(n===ss&&e.throwInvalidArgumentException(""),s===n)return;const i=this.getNextPath(n);let r=this.getPrevPath(n);const o=this.getGeometryFromPath(n);r===ss?this.setFirstPath(o,i):this.setNextPath(r,i),i===ss?this.setLastPath(o,r):this.setPrevPath(i,r),this.setGeometryVertexCount(o,this.getPointCount(o)-this.getPathSize(n)),this.setGeometryPathCount(o,this.getPathCount(o)-1),r=s===ss?this.getLastPath(t):this.getPrevPath(s),this.setPrevPath(n,r),this.setNextPath(n,s),s===ss?this.setLastPath(t,n):this.setPrevPath(s,n),r===ss?this.setFirstPath(t,n):this.setNextPath(r,n),this.setGeometryVertexCount(t,this.getPointCount(t)+this.getPathSize(n)),this.setGeometryPathCount(t,this.getPathCount(t)+1),this.setPathGeometry(n,t)}addVertex(t,e){return this.m_vertices.getPointByVal(this.getVertexIndex(e),this.getHelperPoint()),this.insertVertex_(t,ss,this.getHelperPoint(),!1)}insertVertex(t,e,s){return this.insertVertex_(t,e,s,!0)}removeVertex(t,e){const s=this.getPathFromVertex(t),n=this.getPrevVertex(t),i=this.getNextVertex(t);n!==ss&&this.setNextVertex(n,i);const r=this.getPathSize(s);if(t===this.getFirstVertex(s)&&this.setFirstVertex(s,r>1?i:ss),i!==ss&&this.setPrevVertex(i,n),t===this.getLastVertex(s)&&this.setLastVertex(s,r>1?n:ss),this.hasCurves()&&n!==ss&&i!==ss){const s=this.getVertexIndex(t),r=this.getVertexIndex(n),o=this.getVertexIndex(i);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(s,null)}else{const t=this.getSegmentFromIndex(s);if(this.setSegmentToIndex(s,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}this.setPathSize(s,r-1);const o=this.getGeometryFromPath(s);return this.setGeometryVertexCount(o,this.getPointCount(o)-1),this.freeVertex(t),i}removeVertices(t,s){e.geometryReleaseAssert(t!==s);const n=this.getPathFromVertex(t),i=this.getPrevVertex(t),r=this.getPrevVertex(s);i!==ss&&this.setNextVertex(i,s);let o=this.getPathSize(n);const a=this.getVertexIndex(t);this.setSegmentToIndex(a,null),this.setPrevVertex(s,i),this.setPrevVertex(t,ss),this.setNextVertex(r,ss);let m=0,h=t;const u=this.getFirstVertex(n);let l=!1;for(;;){const t=this.getNextVertex(h);if(l||=u===h,this.freeVertex(h),m++,h===r)break;h=t}o-=m,l&&this.setFirstVertex(n,o>0?s:ss),this.setPathSize(n,o);const c=this.getGeometryFromPath(n);this.setGeometryVertexCount(c,this.getPointCount(c)-m)}getFirstVertex(t){return this.m_pathIndexList.getField(t,4)}getLastVertex(t){return this.m_pathIndexList.getField(t,5)}getNextVertex(t){return this.m_vertexIndexList.getField(t,2)}getPrevVertex(t){return this.m_vertexIndexList.getField(t,1)}getNextVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,2):this.m_vertexIndexList.getField(t,1)}getPrevVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,1):this.m_vertexIndexList.getField(t,2)}getPathFromVertex(t){return this.m_vertexIndexList.getField(t,3)}addPoint(t,e){return this.insertVertex_(t,ss,e,!1)}getGeometryFromVertex(t){return this.getGeometryFromPath(this.getPathFromVertex(t))}replaceNaNs(t,s){this.m_vertexDescription.hasAttribute(t)||e.throwInternalErrorException(""),this.m_vertices.replaceNaNs(t,s)}removeNaNVertices(){for(let t=this.getFirstGeometry();t!==ss;t=this.getNextGeometry(t))for(let e=this.getFirstPath(t);e!==ss;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let s=0,n=this.getPathSize(e);s<n;s++)t=this.getXY(t).isFinite()?this.getNextVertex(t):this.removeVertex(t,!0)}}queryVertexIterator(t=-1){return this.queryVertexIteratorEx(!1,t)}queryVertexIteratorEx(t,s=-1){let n=ss,i=ss,r=ss,o=ss,a=0,m=!1;for(n=s!==ss?s:this.getFirstGeometry();n!==ss;n=this.getNextGeometry(n))if(!t||e.isMultiPath(this.getGeometryType(n))){for(i=this.getFirstPath(n);i!==ss;i=this.getNextPath(i))if(r=this.getFirstVertex(i),o=r,a=0,r!==ss){m=!0;break}if(m||s!==ss)break}return m||(n=ss),is.create_(this,n,i,r,o,a,t,!1,s!==ss)}queryVertexIteratorOnSelection(t=-1){return this.m_selection?is.create_(this,t,ss,ss,ss,-1,!1,!0,t!==ss):this.queryVertexIteratorEx(!1,t)}hasSelection(){return this.m_selection}createEmptySelection(){e.geometryReleaseAssert(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(t){return!!this.selected(t)||(this.setUserIndex(t,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(t),this.m_selectedCount++,!1)}unselect(t){if(!this.m_selection)return;const e=this.getUserIndex(t,this.m_selectionIndex);e>=0&&(this.m_selectedVertices[e]=ss,this.setUserIndex(t,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(t){return!this.m_selection||this.selected_(t)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(t,s){return e.geometryReleaseAssert(0),!1}peelALoop(t,e){this.peelALoop_(t,e,!1)}peelALoopIntoAPath(t,e){return this.peelALoop_(t,e,!0)}applyTransformation(t){if(this.m_verticesMp.applyTransformation(t),null!==this.m_segments)for(let e=0,s=this.m_segments.length;e<s;e++)this.m_segments[e]&&this.m_segments[e].applyTransformation(t)}setGeometryType(t,e){this.m_geometryIndexList.setField(t,2,e)}splitSegmentWithIntersector(t,e,s,n,i){n?this.splitSegmentForward(t,e,s,!0,i):this.splitSegmentBackward(t,e,s,!0,i)}setPrevVertex(t,e){this.m_vertexIndexList.setField(t,1,e)}setNextVertex(t,e){this.m_vertexIndexList.setField(t,2,e)}setPathToVertex(t,e){this.m_vertexIndexList.setField(t,3,e)}setPathSize(t,e){this.m_pathIndexList.setField(t,3,e)}setFirstVertex(t,e){this.m_pathIndexList.setField(t,4,e)}setLastVertex(t,e){this.m_pathIndexList.setField(t,5,e)}getSegment(t){if(null!=this.m_segments){const e=this.getVertexIndex(t);return this.getSegmentFromIndex(e)}return null}isCurve(t){if(null===this.m_segments)return!1;const e=this.getVertexIndex(t);return this.m_segments.length>e&&null!==this.m_segments[e]}querySegment(t,e,s=!0,n=!1){const i=this.getNextVertex(t);if(i===ss)return!1;const r=this.getSegment(t);if(!r)return!s&&(this.queryLineConnector(t,e.createLine(),n),!0);if(e.copyFrom(r,!0),n)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const s=this.getHelperPoint();this.queryPoint(t,s),e.get().setStart(s),this.queryPoint(i,s),e.get().setEnd(s)}return!0}getSegmentFromIndex(t){return(null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null)||null}getAndClearSegmentFromIndex(t){return(null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null)||null}setSegmentToIndex(t,e){if(this.m_hasForceSetEnvelope=0,null===this.m_segments){if(!e)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}t>=this.m_segments.length&&(this.m_segments.length=t+1),this.m_segments[t]=e}setGeometryPathCount(t,e){this.m_geometryIndexList.setField(t,6,e)}setGeometryVertexCount(t,e){this.m_geometryIndexList.setField(t,5,e)}ringParentageCheckInternal(t,s){return e.geometryReleaseAssert(0),!1}reverseRingInternal(t){const e=this.hasCurves(),s=this.hasSegmentParentage();let n=null,i=-1,r=t;if(e){const t=this.getVertexIndex(r);n=this.getAndClearSegmentFromIndex(t)}s&&(i=this.getSegmentParentage(r));do{const t=this.getPrevVertex(r),o=this.getNextVertex(r);if(this.setNextVertex(r,t),this.setPrevVertex(r,o),e){const t=this.getVertexIndex(o),e=this.getSegmentFromIndex(t);n&&n.reverse(),this.setSegmentToIndex(t,n),n=e}if(s){const t=this.getSegmentParentage(o);this.setSegmentParentagePreserveBreak(o,i),i=t}r=o}while(r!==t);this.dbgVerifyIntegrity(t)}setTotalPointCount(t){this.m_pointCount=t}removePathOnly(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);e!==ss?this.setNextPath(e,s):this.setFirstPath(n,s),s!==ss?this.setPrevPath(s,e):this.setLastPath(n,e),this.setFirstVertex(t,ss),this.setLastVertex(t,ss),this.freePath(t)}insertClosedPath(t,e,s,n,i){const r=this.insertPath(t,ss);let o=0,a=s;for(i[0]=!1;;){a===n&&(i[0]=!0),this.setPathToVertex(a,r),o++;const t=this.getNextVertex(a);if(t===s)break;a=t}return this.setClosedPath(r,!0),this.setPathSize(r,o),i[0]&&(s=n),this.setFirstVertex(r,s),this.setLastVertex(r,this.getPrevVertex(s)),this.setRingAreaValid(r,!1),r}findVertex2D(t,s){return e.geometryReleaseAssert(0),0}findVertex3D(t,s,n){return e.geometryReleaseAssert(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(t){}dbgVerifyIntegrity(t,e=!0){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(t,e){}getNextNthVertex(t,e){if(0===e)return t;let s=t;for(let t=0;t<e;++t)if(s=e>0?this.getNextVertex(s):this.getPrevVertex(s),s===ss)return ss;return s}removeVertexInternal(t,e){const s=this.getPrevVertex(t),n=this.getNextVertex(t);if(s!==ss&&this.setNextVertex(s,n),n!==ss&&this.setPrevVertex(n,s),this.hasCurves()&&s!==ss&&n!==ss){const i=this.getVertexIndex(t),r=this.getVertexIndex(s),o=this.getVertexIndex(n);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(i,null)}else{const t=this.getSegmentFromIndex(i);if(this.setSegmentToIndex(i,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}return this.freeVertex(t),n}isRingAreaValid(t){return!!(4&this.getPathFlags(t))}setRingAreaValid(t,e){const s=(4|this.getPathFlags(t))-4;this.setPathFlags(t,s|(e?4:0))}compareVerticesSimpleY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(t,e){return this.getXYZ(t).compare(this.getXYZ(e))}compareVerticesSimpleX(t,e){return this.getXY(t).compareX(this.getXY(e))}sortVerticesSimpleByYHeapMerge(t,s){e.geometryReleaseAssert(0)}sortVerticesSimpleByY(t,e,s){this.m_bucketSort.sort(t,e,s,new ns(this))}sortVerticesSimpleByX(t,s,n){e.geometryReleaseAssert(0)}sortVerticesSimpleByY3D(t,s,n){e.geometryReleaseAssert(0)}snapVertexForPoleClipping(t,e){const s=this.getPrevVertex(t);s!==ss&&this.replaceCurveWithLine(s),this.getNextVertex(t)!==ss&&this.replaceCurveWithLine(t);const i=new n.Point2D;this.queryXY(t,i),i.y=e,this.setXY(t,i)}setSegmentParentageAndBreak(t,s,i=!0){if(-1===this.m_segmentParentageIndex){if(-1===s)return;this.m_segmentParentageIndex=this.createUserIndex()}s>=0&&(e.geometryReleaseAssert(s<=n.indexTypeMax()>>1),s<<=1,s|=i?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,s)}setSegmentParentagePreserveBreak(t,s){if(e.geometryReleaseAssert(s>=-1),-1===this.m_segmentParentageIndex){if(-1===s)return;this.m_segmentParentageIndex=this.createUserIndex()}s>=0&&(e.geometryReleaseAssert(s<=n.indexTypeMax()>>1),s<<=1,s|=this.getSegmentParentageBreakVertex(t)?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,s)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0?e:e>>1}getOriginalSegmentInfo(t){if(-1!==this.m_segmentParentageIndex){const e=this.getSegmentParentage(t);return new rs(e)}return new rs(-1)}setSegmentParentageBreakVertex(t,e){if(-1===this.m_segmentParentageIndex)return;let s=this.getUserIndex(t,this.m_segmentParentageIndex);s<0||!!(1&s)!==e&&(e?s|=1:s&=n.indexTypeMax()>>1<<1,this.setUserIndex(t,this.m_segmentParentageIndex,s))}getSegmentParentageBreakVertex(t){if(-1===this.m_segmentParentageIndex)return!0;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0||!!(1&e)}isDiscontinuousSegmentParentage(t){const e=this.getPrevVertex(t);return e!==ss&&this.getSegmentParentage(e)!==this.getSegmentParentage(t)}setCurveStitcherPointer(t){this.m_curveStitcher=t}hasSegmentParentage(){return-1!==this.m_segmentParentageIndex}deleteSegmentParentage(){-1!==this.m_segmentParentageIndex&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}}function as(t,e,n,i=!1){if(e<=262144)return function(t,e,n,i){const r=new s.AttributeStreamOfInt32(0);for(let t=0;t<e;t++)r.add(t);const o={userSort(e,s,n){n.sort(e,s,(e,s)=>t[e].compareX(t[s]))},getValue:e=>t[e].x};i||s.BucketSort.sortEx(r,0,e,o);let a=0;t:for(let s=0;s<e;++s){const e=r.read(s);for(;a>=2;){const i=n[a-2],o=n[a-1];if(t[o].equals(t[e])){r.write(s,-1);continue t}if(!(us(t[i],t[o],t[e])>=0)){o===r.read(s-1)&&r.write(s-1,-1);break}a--}n[a++]=e,2===a&&t[e].equals(t[n[0]])&&(r.write(1,-1),a--)}const m=a+1;t:for(let s=e-2;s>=0;--s){const e=r.read(s);if(!(e<0)){for(;a>=m;){const s=n[a-2],i=n[a-1];if(t[i].equals(t[e]))continue t;if(!(ls(t[s],t[i],t[e])>=0))break;a--}if(0!==s){const s=n[a-1];n[a++]=e,t[e].equals(t[s])&&a--}}}return a>1&&t[n[0]].equals(t[n[a-1]])&&a--,a}(t,e,n,i);const r=new hs({points:t,n:e});let o=1;const a=t[0];for(;o<e&&t[o].equals(a);)o++;if(r.m_treeHull.addElement(0),o<e){r.m_treeHull.addBiggestElement(o);for(let s=o+1;s<e;s++){const e=t[s],n=r.treeHull(e);-1!==n&&r.m_treeHull.setElement(n,s)}}let m=0;for(let t=r.m_treeHull.getFirst();-1!==t;t=r.m_treeHull.getNext(t))n[m++]=r.m_treeHull.getElement(t);return m}os.st_defaultRank=1;class ms{constructor(t){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,e.geometryReleaseAssert(0),this.m_convexHull=t,this.m_function=this.done_}next(){return e.geometryReleaseAssert(0),!1}get_vertex_handle_p(){return e.geometryReleaseAssert(0),0}get_vertex_handle_q(){return e.geometryReleaseAssert(0),0}get_current_support(){return e.geometryReleaseAssert(0),0}getNext(t){return e.geometryReleaseAssert(0),0}getPrev(t){return e.geometryReleaseAssert(0),0}intialize_(){return e.geometryReleaseAssert(0),!1}increment_(){return e.geometryReleaseAssert(0),!1}increment_q_(){return e.geometryReleaseAssert(0),!1}increment_p_(){return e.geometryReleaseAssert(0),!1}parallel_edge_with_q_support_(){return e.geometryReleaseAssert(0),!1}parallel_edge_with_p_support_(){return e.geometryReleaseAssert(0),!1}done_(){return e.geometryReleaseAssert(0),!1}}class hs{nullGetXY(t){return e.throwInternalErrorException("m_getXY is null"),{}}nullDeleteNode(t){e.throwInternalErrorException("m_deleteNode is null")}constructor(t){return this.m_treeHull=new s.Treap,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,t?t.stream?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_stream=t.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=ss,void(this.m_pathHandle=ss)):t.points?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_points=t.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=ss,void(this.m_pathHandle=ss)):void e.throwInvalidCallException("unrecognized constructor parameter"):(this.m_treeHull.setCapacity(20),this.m_shape=new os,this.m_geometryHandle=this.m_shape.createGeometry(e.GeometryType.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,ss),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(t){return this.m_shape.getXY(t)}getXYStream(t){return this.m_stream.readPoint2D(t<<1)}getXYPoints(t){return e.geometryReleaseAssert(0),new n.Point2D}deleteNodeShape(t){const e=this.m_treeHull.getElement(t);this.m_treeHull.deleteNode(t),this.m_shape.removeVertex(e,!1)}deleteNodeStream(t){this.m_treeHull.deleteNode(t)}deleteNodePoints(t){e.geometryReleaseAssert(0)}addGeometry(t){if(t.isEmpty())return;const s=t.getGeometryType();if(s===e.GeometryType.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else e.isMultiVertex(s)?this.addMultiVertexGeometry(t):e.isSegment(s)?this.addSegment(t,!1):s===e.GeometryType.enumEnvelope?this.addEnvelope(t):s===e.GeometryType.enumPoint?this.addPoint(t):e.throwInvalidArgumentException("Convex_hull: geometry not supported")}getBoundingGeometry(){const t=new s.Point,e=this.m_treeHull.getFirst(),n=new ts({vd:this.m_shape.getVertexDescription()});if(0===this.m_treeHull.size())return n;n.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(e),t),n.startPathPoint(t);for(let s=this.m_treeHull.getNext(e);-1!==s;s=this.m_treeHull.getNext(s))this.m_shape.queryPoint(this.m_treeHull.getElement(s),t),n.lineToPoint(t);return n}getAntipodalPairsIterator(){return e.geometryReleaseAssert(0),new ms(this)}getXY(t){return e.geometryReleaseAssert(0),new n.Point2D}getXYWithIndex(t){return e.geometryReleaseAssert(0),new n.Point2D}getFirst(){return e.geometryReleaseAssert(0),0}getLast(){return e.geometryReleaseAssert(0),0}getNext(t){return e.geometryReleaseAssert(0),0}getPrev(t){return e.geometryReleaseAssert(0),0}getVertexIndex(t){return e.geometryReleaseAssert(0),0}getPointCount(){return e.geometryReleaseAssert(0),0}addMultiVertexGeometry(t){const i=new s.Point,r=t.getImpl(),o=new n.Point2D;for(let e=0;e<t.getPointCount();e++){r.queryXY(e,o);const s=this.addPoint2D(o);if(-1!==s){t.getPointByVal(e,i);const n=this.m_shape.addPoint(this.m_pathHandle,i);this.m_treeHull.setElement(s,n)}}if(e.isMultiPath(t.getGeometryType())){const e=t;if(e.hasNonLinearSegments()){const t=e.querySegmentIterator();for(;t.nextPath();)for(;t.hasNextSegment();){const e=t.nextCurve();null!==e&&this.addSegment(e,!0)}}}}addEnvelope(t){const e=new s.Point;for(let s=0;s<4;s++){const i=new n.Point2D;t.queryCorner(s,i);const r=this.addPoint2D(i);if(-1!==r){t.queryCornerByVal(s,e);const n=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,n)}}}static querySegmentControlPoints(t,i,r){const o=t.getGeometryType();if(e.geometryReleaseAssert(o!==e.GeometryType.enumLine),o===e.GeometryType.enumEllipticArc){const e=t,r=60*Math.PI/180,o=Math.abs(e.getSweepAngle());if(o>r){const t=Math.min(6,Math.ceil(o/r)),a=1/t,m=new qr;e.queryStart(i[0]);let h=1;for(let r=0;r<t;r++){e.queryCut(r*a,(r+1)*a,m);const o=n.makeObjectArray(n.Point2D,3);lr(m.get(),o);const u=n.Point2D.calculateLength(o,3),l=n.Point2D.calculateLength(o,2),c=u>0?l/u:.5;r<t-1?m.get().queryEnd(i[h+1]):e.queryEnd(i[h+1]),s.Point.lerp(i[h-1],i[h+1],c,i[h]),i[h].setXY(o[1]),h+=2}return h}{const e=n.makeObjectArray(n.Point2D,3);lr(t,e);const r=n.Point2D.calculateLength(e,3);t.queryStart(i[0]),t.queryEnd(i[2]);const o=n.Point2D.calculateLength(e,2),a=r>0?o/r:.5;return s.Point.lerp(i[0],i[2],a,i[1]),i[1].setXY(e[1]),3}}if(o===e.GeometryType.enumBezier){const e=t,r=n.makeObjectArray(n.Point2D,4);e.queryControlPoints(r);const o=n.Point2D.calculateLength(r,4),a=n.Point2D.calculateLength(r,2),m=n.Point2D.calculateLength(r,3);t.queryStart(i[0]),t.queryEnd(i[3]);const h=o>0?a/o:.5;s.Point.lerp(i[0],i[3],h,i[1]),i[1].setXY(r[1]);const u=o>0?m/o:.5;return s.Point.lerp(i[0],i[3],u,i[2]),i[2].setXY(r[2]),4}if(o===e.GeometryType.enumBezier2){const e=t,r=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(r);const o=n.Point2D.calculateLength(r,3);t.queryStart(i[0]),t.queryEnd(i[2]);const a=n.Point2D.calculateLength(r,2),m=o>0?a/o:.5;return s.Point.lerp(i[0],i[2],m,i[1]),i[1].setXY(r[1]),3}if(o===e.GeometryType.enumRationalBezier2){const e=t,r=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(r);const o=n.Point2D.calculateLength(r,3);t.queryStart(i[0]),t.queryEnd(i[2]);const a=n.Point2D.calculateLength(r,2),m=o>0?a/o:.5;return s.Point.lerp(i[0],i[2],m,i[1]),i[1].setXY(r[1]),3}e.throwInvalidArgumentException("Convex_hull: segment type not supported")}addSegment(t,e){if(!e){const e=new s.Point,n=t.getStartXY(),i=this.addPoint2D(n);if(-1!==i){t.queryStart(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(i,s)}const r=t.getEndXY(),o=this.addPoint2D(r);if(-1!==o){t.queryEnd(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(o,s)}}if(t.isCurve()){const e=n.makeObjectArray(s.Point,13);for(let s=1,n=hs.querySegmentControlPoints(t,e,e.length)-1;s<n;++s){const t=e[s].getXY(),n=this.addPoint2D(t);if(-1!==n){const t=this.m_shape.addPoint(this.m_pathHandle,e[s]);this.m_treeHull.setElement(n,t)}}}}addPoint(t){const e=t.getXY(),s=this.addPoint2D(e);if(-1!==s){const e=this.m_shape.addPoint(this.m_pathHandle,t);this.m_treeHull.setElement(s,e)}}addPoint2D(t){let e=-1;if(0===this.m_treeHull.size())return e=this.m_treeHull.addElement(-4),e;if(1===this.m_treeHull.size()){const s=this.m_treeHull.getElement(this.m_treeHull.getFirst()),n=this.m_shape.getXY(s);return t.equals(n)||(e=this.m_treeHull.addBiggestElement(-5)),e}return e=this.treeHull(t),e}treeHull(t){let e=-1;do{const s=this.m_treeHull.getFirst(),i=this.m_treeHull.getLast(),r=this.m_treeHull.getElement(s),o=this.m_treeHull.getElement(i),a=this.m_getXY(r),m=this.m_getXY(o),h=n.Point2D.orientationRobust(m,t,a);if(cs(h)){e=this.m_treeHull.addBiggestElement(-1);const n=this.treeHullWalkBackward(t,i,s);n!==s&&this.treeHullWalkForward(t,s,this.m_treeHull.getPrev(n));break}if(gs(h)){let r=this.m_treeHull.getRoot(),o=this.m_treeHull.getFirst(),m=this.m_treeHull.getLast(),h=-1,u=-1,l=-1;for(;o!==this.m_treeHull.getPrev(m);){u=this.m_treeHull.getElement(r);const e=this.m_getXY(u);gs(n.Point2D.orientationRobust(e,t,a))?(m=r,r=this.m_treeHull.getLeft(r)):(o=r,r=this.m_treeHull.getRight(r))}r=m,h=o,u=this.m_treeHull.getElement(r),l=this.m_treeHull.getElement(h);const c=this.m_getXY(u),g=this.m_getXY(l);if(h!==s&&!cs(n.Point2D.orientationRobust(g,t,c)))break;e=this.m_treeHull.addElementAtPosition(h,r,-2,!0,!1),this.treeHullWalkForward(t,r,i),this.treeHullWalkBackward(t,h,s);break}{const n=ds(t,m,a);if(-1===n){const n=this.m_treeHull.getPrev(i);this.m_treeHull.deleteNode(i),e=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(t,n,s)}else if(1===n){const n=this.m_treeHull.getNext(s);this.m_treeHull.deleteNode(s),e=this.m_treeHull.addElementAtPosition(-1,n,-3,!0,!1),this.treeHullWalkForward(t,n,i)}break}}while(0);return e}treeHullWalkForward(t,e,s){if(e===s)return s;let i=e,r=this.m_treeHull.getElement(i),o=this.m_treeHull.getNext(i);const a=this.m_getXY(r);for(;i!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(o),s=this.m_getXY(e);if(cs(n.Point2D.orientationRobust(s,t,a)))break;const m=i;i=o,r=e,a.assign(s),o=this.m_treeHull.getNext(i),this.m_deleteNode(m)}return i}treeHullWalkBackward(t,e,s){if(e===s)return s;let i=e,r=this.m_treeHull.getElement(i),o=this.m_treeHull.getPrev(i);const a=this.m_getXY(r);for(;i!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(o),s=this.m_getXY(e);if(cs(n.Point2D.orientationRobust(a,t,s)))break;const m=i;i=o,r=e,a.assign(s),o=this.m_treeHull.getPrev(i),this.m_deleteNode(m)}return i}}function us(t,e,s){const i=e.sub(t),r=s.sub(e);if(0===i.x)return r.x>0?-1:0;if(0===i.y)return r.y>0?1:r.y<0?-1:0;const o=i.crossProduct(r),a=4*Number.EPSILON*(Math.abs(r.x*i.y)+Math.abs(r.y*i.x));return o>a?1:o<-a?-1:n.Point2D.orientationRobust(t,e,s)}function ls(t,e,s){const i=e.sub(t),r=s.sub(e);if(0===i.x)return r.x<0?-1:0;if(0===i.y)return r.y>0?-1:r.y<0?1:0;const o=i.crossProduct(r),a=4*Number.EPSILON*(Math.abs(r.x*i.y)+Math.abs(r.y*i.x));return o>a?1:o<-a?-1:n.Point2D.orientationRobust(t,e,s)}function cs(t){return t<0}function gs(t){return t>0}function ds(t,e,s){let n=-1;n=e.y===s.y?0:e.x===s.x?1:Math.abs(e.x-s.x)>=Math.abs(e.y-s.y)?0:1;let i=-1;return i=e[n]<s[n]?t[n]<e[n]?-1:s[n]<t[n]?1:0:e[n]<t[n]?-1:t[n]<s[n]?1:0,i}function ps(t){return(t=t.clone()).divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t}function _s(t,e,s){t.inc(e,0)===s&&t.set(e,0,0),t.inc(e,1)===s&&t.set(e,1,0)}function Ps(t,s,i,r,o){switch(o){case 0:break;case 1:s.rightPerpendicularThis(),t.rightPerpendicularThis();break;case 2:s.negateThis(),t.negateThis();break;case 3:s.leftPerpendicularThis(),t.leftPerpendicularThis();break;default:e.throwInvalidArgumentException("")}return n.Point2D.orientationRobustEx(t,s,i,r)}class fs{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}}function ys(t){var e;return e=t.calculateUpperLength2D(),256*n.doubleEps()*e}function xs(t,e,s=!1){e[1].setCoords(t.m_cp[0].x-t.getStartX(),t.m_cp[0].y-t.getStartY()),e[1].mulThis(3),e[2].setCoords(t.m_cp[1].x-t.m_cp[0].x,t.m_cp[1].y-t.m_cp[0].y),e[2].mulThis(3),e[3]=t.getEndXY().sub(t.getStartXY()),e[3].subThis(e[2]),e[2].subThis(e[1]),s?e[0].setCoords(0,0):e[0]=t.getStartXY()}function Ds(t,e,s){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i),Es(i,e,s)}function vs(t,e,s){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i),Cs(i,e,s)}function Es(t,e,s){let n=t[1].x;n-=t[0].x,n*=3;let i=t[2].x;i-=t[1].x,i*=3;let r=t[3].x;r-=t[0].x,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].x)}function Cs(t,e,s){let n=t[1].y;n-=t[0].y,n*=3;let i=t[2].y;i-=t[1].y,i*=3;let r=t[3].y;r-=t[0].y,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].y)}function bs(t,e,s=!1){const i=n.makeObjectArray(x,4);i[0].assignPoint2D(t[0]),i[1].assignPoint2D(t[1]),i[2].assignPoint2D(t[2]),i[3].assignPoint2D(t[3]),e[1].setCoords(i[1].x.sub(i[0].x),i[1].y.sub(i[0].y)),e[1].mulThis(n.MPValue.constructInt32(3)),e[2].setCoords(i[2].x.sub(i[1].x),i[2].y.sub(i[1].y)),e[2].mulThis(n.MPValue.constructInt32(3)),e[3]=i[3].sub(i[0]),e[3]=e[3].sub(e[2]),e[2]=e[2].sub(e[1]),s?e[0].setCoords(n.s_zero$1,n.s_zero$1):e[0]=i[0].clone()}function As(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+As(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=ws(t);if(n&&!Number.isNaN(i.length)&&!Number.isNaN(i.length))return i.length;const r=ys(t),o=r/t.calculateUpperLength2D();let a=0,m=0;for(let s=1,n=i.specialPointsCount();s<n;s++){const n=i.specialPoints[s];if(a+=ln(t,m,Math.min(e,n),o,r),e<=n)break;m=n}return n&&(i.length=a),a}function ws(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new fs,s=n.makeObjectArray(n.ECoordinate,8),i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i);const r=on(i,s);e.specialPoints=[];for(let t=0;t<r;t++)e.specialPoints.push(s[t].value());return Ts(t,e),e}function Ss(t){let e=null;return e=t.m_cachedValues,e}function Ts(t,e){t.m_cachedValues=e}function Is(t){t.m_cachedValues=null}function Ms(t,e,s,i){const r=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(r);const o=n.makePrimitiveArray(18,NaN),a=Et(new en(r,e,NaN),n.Envelope1D.construct(s,i),18,o),m=new n.Point2D;t.queryCoord2D(s,m);let h=s,u=n.Point2D.distance(m,e);const l=new n.Point2D;t.queryCoord2D(i,l);const c=n.Point2D.distance(l,e);c<u&&(u=c,h=i,m.assign(l));for(let s=0;s<a;s++){t.queryCoord2D(o[s],l);const i=n.Point2D.distance(l,e);i<u&&(u=i,h=o[s],m.assign(l))}return function(t,e,s,n,i){return{tmin:t,tmax:e,t:s,d:n,pt:i.clone()}}(s,i,h,u,m)}function Ns(t,s){const i=n.makeObjectArray(n.ECoordinate,4);Ds(t,i,!0);const r=n.makeObjectArray(n.ECoordinate,4);vs(t,r,!0);const o=i[3].clone(),a=i[2].clone(),m=i[1].clone(),h=r[3].clone(),u=r[2].clone(),l=r[1].clone(),c=a.mulE(m).addE(u.mulE(l)).mul(4),g=a.mulE(a).mul(8).addE(o.mulE(m).mul(12)).addE(u.mulE(u).mul(8).addE(h.mulE(l).mul(12))),d=o.mulE(a).addE(h.mulE(u)).mul(36),p=o.mulE(o).addE(h.mulE(h)).mul(36),_=n.makeObjectArray(n.ECoordinate,3),P=Nt(p,d,g,c,new n.Envelope1D(0,1),!1,_);if(e.geometryReleaseAssert(P<=3),P>0){const e=Ys(t,1,0).sqrLength(),n=Ys(t,1,1).sqrLength();let i=e;s.set(0),i<n&&(i=n,s.set(1));for(let e=0;e<P;e++){const n=Ys(t,1,_[e].value()).sqrLength();n<i&&(i=n,s=_[e])}}}function qs(t,e,s){const i=new n.Point2D;return function(t,e,s,n){if(1===e){const e=1-s,i=e*e,r=s*s,o=t[1].sub(t[0]),a=t[2].sub(t[1]),m=t[3].sub(t[2]),h=o.mul(i).add(a.mul(2*e*s)).add(m.mul(r));n.assign(h.mul(3))}else if(2===e){const e=1-s,i=t[2].sub(t[1]).sub(t[1].sub(t[0])),r=t[3].sub(t[2]).sub(t[2].sub(t[1])),o=i.mul(e).add(r.mul(s));n.assign(o.mul(6))}else if(3===e){const e=t[2].sub(t[1]),s=t[3].sub(e.mul(3)).sub(t[0]);n.assign(s.mul(6))}else n.setCoords(0,0)}(t,e,s,i),i}function Ys(t,e,s){const i=n.makeObjectArray(n.Point2D,4);return t.queryControlPoints(i),qs(i,e,s)}function Xs(t){const e=t.m_cp[0].sub(t.getStartXY()),s=t.m_cp[1].sub(t.m_cp[0]),n=t.getEndXY().sub(t.getStartXY());return e.mulThis(3),s.mulThis(3),n.subThis(s),s.subThis(e),(3*n.x*(2*s.y+5*e.y)-3*n.y*(2*s.x+5*e.x)+10*(s.x*e.y-s.y*e.x))/60}function Rs(t){const e=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(e);const s=Fs(e);return s&&(t.m_cp[0].setCoordsPoint2D(e[1]),t.m_cp[1].setCoordsPoint2D(e[2]),t.afterCompletedModification()),s}function Fs(t){return v(t)}function Vs(t,e,s){const i=new n.Point2D,r=new n.Point2D,o=new n.Point2D,a=new n.Point2D,m=new n.Point2D;e<=.5?(n.lerpPointLo(2,t[0],t[1],e,i),n.lerpPointLo(2,t[1],t[2],e,r),n.lerpPointLo(2,t[2],t[3],e,o),n.lerpPointLo(2,i,r,e,a),n.lerpPointLo(2,r,o,e,m),n.lerpPointLo(2,a,m,e,s)):(n.lerpPointHi(2,t[0],t[1],e,i),n.lerpPointHi(2,t[1],t[2],e,r),n.lerpPointHi(2,t[2],t[3],e,o),n.lerpPointHi(2,i,r,e,a),n.lerpPointHi(2,r,o,e,m),n.lerpPointHi(2,a,m,e,s))}function ks(t,s,i,r){e.geometryReleaseAssert(s>=0&&s<=1);const o=new n.Point2D,a=new n.Point2D,m=new n.Point2D,h=new n.Point2D,u=new n.Point2D,l=new n.Point2D;s<=.5?(n.lerpPointLo(2,t[0],t[1],s,o),n.lerpPointLo(2,t[1],t[2],s,a),n.lerpPointLo(2,t[2],t[3],s,m),n.lerpPointLo(2,o,a,s,h),n.lerpPointLo(2,a,m,s,u),n.lerpPointLo(2,h,u,s,l)):(n.lerpPointHi(2,t[0],t[1],s,o),n.lerpPointHi(2,t[1],t[2],s,a),n.lerpPointHi(2,t[2],t[3],s,m),n.lerpPointHi(2,o,a,s,h),n.lerpPointHi(2,a,m,s,u),n.lerpPointHi(2,h,u,s,l));const c=t[3].clone();i&&(i[0].assign(t[0]),i[1].assign(o),i[2].assign(h),i[3].assign(l)),r&&(r[0].assign(l),r[1].assign(u),r[2].assign(m),r[3].assign(c))}function Ls(t,s,i,r){if(e.geometryReleaseAssert(s>=0&&i<=1&&s<=i),s===i){const e=new n.Point2D;return zs(t,s,e),r[0].assign(e),r[1].assign(e),r[2].assign(e),void r[3].assign(e)}if(0===s&&1===i){for(let e=0;e<4;++e)r[e].assign(t[e]);return}const o=n.makeObjectArray(n.Point2D,4);ks(t,i,o,null),ks(o,i>0?s/i:0,null,o),zs(t,s,o[0]),zs(t,i,o[3]),r[0].setCoordsPoint2D(o[0]),r[1].setCoordsPoint2D(o[1]),r[2].setCoordsPoint2D(o[2]),r[3].setCoordsPoint2D(o[3])}function zs(t,e,s,i){if(i){if(e<0)return void Z(new Nr({start:t[0],end:t[0].add(Gs(t,0).getUnitVector())}),e,s);if(e>1)return void Z(new Nr({start:t[3],end:t[3].add(Gs(t,1).getUnitVector())}),e-1,s)}if(e<=.5){const i=new n.Point2D;n.lerpPointLo(2,t[0],t[1],e,i);const r=new n.Point2D;n.lerpPointLo(2,t[1],t[2],e,r);const o=new n.Point2D;n.lerpPointLo(2,t[2],t[3],e,o);const a=new n.Point2D;n.lerpPointLo(2,i,r,e,a);const m=new n.Point2D;n.lerpPointLo(2,r,o,e,m),n.lerpPointLo(2,a,m,e,s)}else{const i=new n.Point2D;n.lerpPointHi(2,t[0],t[1],e,i);const r=new n.Point2D;n.lerpPointHi(2,t[1],t[2],e,r);const o=new n.Point2D;n.lerpPointHi(2,t[2],t[3],e,o);const a=new n.Point2D;n.lerpPointHi(2,i,r,e,a);const m=new n.Point2D;n.lerpPointHi(2,r,o,e,m),n.lerpPointHi(2,a,m,e,s)}}function Gs(t,e){const s=n.snap(e,0,1);let i=qs(t,1,s);return i.isZero()&&(i=qs(t,2,s),i.isZero()?i=qs(t,3,s):1===s&&i.negateThis()),i}function Os(t,e,s){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i),function(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(function(t,e,s){const i=[f.constructPoint2D(t[0]),f.constructPoint2D(t[1]),f.constructPoint2D(t[2]),f.constructPoint2D(t[3])],r=new f;return function(t,e,s,i){{const e=n.s_one.subE(s),r=e.sqr(),o=s.sqr(),a=t[1].subE(t[0]).mulE(r).addE(t[2].subE(t[1]).mulE(new n.ECoordinate(2).mulE(e).mulE(s))).addE(t[3].subE(t[2]).mulE(o));i.setE(a.mulE(new n.ECoordinate(3)))}}(i,0,s,r),r}(t,0,e))}(i,e,s)}function js(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==Zs(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function Bs(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==Us(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function Ws(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==$s(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function Hs(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==Ks(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Zs(t,e,s,i,r,o,a,m,h,u){if(null!==r&&(r.length=0),null!=o&&(o.length=0),null!==i&&(i.length=0),s.isDegenerate(0)){const t=[0,0,0],m=e.intersectPoint(s.getStartXY(),t,a);if(m>0){if(null!==r)for(let e=0;e<m;e++)r.push(t[e]);if(null!==o)for(let t=0;t<m;t++)o.push(0);if(null!=i)for(let s=0;s<m;s++){const r=new n.Point2D;e.queryCoord2D(t[s],r),i.push(r)}}return m}const l=k(e,s);if(L(e,s,a=Math.max(a,l)))return 0;const c=n.makeObjectArray(n.Point2D,4);xs(e,c);const g=s.getEndXY();g.subThis(s.getStartXY());const d=g.clone();d.leftPerpendicularThis();let p=3*c[3].dotProduct(d),_=2*c[2].dotProduct(d),P=c[1].dotProduct(d);const f=n.makePrimitiveArray(15,Number.NaN),y=n.makePrimitiveArray(15,Number.NaN);let x=Ct(p,_,P,n.Envelope1D.unit(),!1,f);x<0&&(f[0]=0,f[1]=1,x=2);let D,v=0;for(let t=0,i=v;t<x;++t){const r=e.getCoord2D(f[t+i]);y[v]=s.getClosestCoordinate(r,!1),n.Point2D.distance(r,s.getCoord2D(y[v]))<=a&&(f[v]=f[t+i],v++)}if(c[0].subThis(s.getStartXY()),Math.abs(g.x)>=Math.abs(g.y)){const t=g.y/g.x;p=c[3].y-c[3].x*t,_=c[2].y-c[2].x*t,P=c[1].y-c[1].x*t,D=c[0].y-c[0].x*t}else{const t=g.x/g.y;p=c[3].x-c[3].y*t,_=c[2].x-c[2].y*t,P=c[1].x-c[1].y*t,D=c[0].x-c[0].y*t}const E=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),C=[0,0,0];x=bt(p,_,P,D,n.Envelope1D.unit(),E,C);for(let t=0,i=v;t<x;++t){f[t+i]=C[t];const r=e.getCoord2D(f[t+i]);y[v]=s.getClosestCoordinate(r,!1),n.Point2D.distance(r,s.getCoord2D(y[v]))<=a&&(f[v]=f[t+i],v++)}x=e.intersectPoint(s.getStartXY(),C,a);for(let t=0;t<x;t++)f[v]=C[t],y[v++]=0;x=e.intersectPoint(s.getEndXY(),C,a);for(let t=0;t<x;t++)f[v]=C[t],y[v++]=1;return 0!==s.intersectPoint(e.getStartXY(),C,a)&&(y[v]=C[0],f[v++]=0),0!==s.intersectPoint(e.getEndXY(),C,a)&&(y[v]=C[0],f[v++]=1),0===v?0:Tr(t,e,s,f,y,v,i,r,o,a,m,0,u)}function Us(t,e,s,i,o,a,m,h,u,l){if($i(s))return Zs(t,e,new Nr({start:s.getStartXY(),end:s.getEndXY()}),i,o,a,m,h,0,l);const c=k(e,s);if(L(e,s,m=Math.max(m,c)))return 0;const g=[],d=[],p=[],_=n.makeObjectArray(n.Point2D,4);{e.queryControlPoints(_);const t=n.makeObjectArray(n.Point2D,4),i=new r.Transformation2D;s.canonicToWorldTransformation(i);const o=new r.Transformation2D;o.setInvert(i),o.transformPoints2D(_,4,t);const a=n.makeObjectArray(x,4);bs(t,a);const u=[a[0].x,a[1].x,a[2].x,a[3].x],l=[a[0].y,a[1].y,a[2].y,a[3].y],c=n.makeObjectArray(n.MPValue,3);c[0].setDouble(s.getSemiMinorAxis()),c[0].sqrThis(),c[1].setDouble(s.getSemiMajorAxis()),c[1].sqrThis(),c[2].setThis(c[0]),c[2].mulThis(c[1]),c[2].negateThis();const P=Zt(u,3,l,3,null,0,c,0,n.Envelope1D.unit(),n.Envelope1D.unit(),d,h);if(P>0){let t=0;for(let i=0;i<P;i++){const r=new n.Point2D;e.queryCoord2D(d[i],r);const o=s.getClosestCoordinate(r,!1),a=new n.Point2D;s.queryCoord2D(o,a),n.Point2D.distance(r,a)<=m&&(g.push(r.clone()),d[t]=d[i],p.push(o),t++)}d.length=t,g.length=t}}const P=[0,1];for(let t=0;t<2;t++){const e=0===t?s.getStartXY():s.getEndXY(),i=[0];sn(_,e,n.Envelope1D.unit(),!1,-1,1,i);const r=new n.Point2D;zs(_,i[0],r),n.Point2D.distance(e,r)<=m&&(d.push(i[0]),p.push(P[t]),g.push(r.clone()))}for(let t=0;t<2;t++){const e=[0,3];{const i=s.getClosestCoordinate(_[e[t]],!1),r=new n.Point2D;s.queryCoord2D(i,r),n.Point2D.distance(_[e[t]],r)<=m&&(d.push(P[t]),p.push(i),g.push(r.clone()))}}return Tr(t,e,s,d,p,d.length,i,o,a,m,h,0,l)}function Qs(t,s,i,r,o,a,m,h,u,l){const c=n.makeObjectArray(n.Point2D,4);s.queryControlPoints(c);const g=n.makeObjectArray(n.Point2D,4);if(i.queryControlPoints(g),z(c,g,4)<0)return Qs(t,i,s,r,a,o,m,h,u,!l);const p=k(s,i);if(L(s,i,m=Math.max(m,p)))return 0;if(function(t,e,s,i,r,o,a,m,h){const u=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(u);const l=n.makeObjectArray(n.Point2D,4);if(e.queryControlPoints(l),u[0].equals(l[0])){if(u[1].equals(l[1])&&u[2].equals(l[2])&&u[3].equals(l[3]))return s&&(s.length=0,s.push(u[0]),s.push(u[3])),i&&(i.length=0,i.push(0),i.push(1)),r&&(r.length=0,r.push(0),r.push(1)),!0;if(!u[0].equals(l[3]))return!1}return!!(u[0].equals(l[3])&&u[1].equals(l[2])&&u[2].equals(l[1])&&u[3].equals(l[0]))&&(i&&(i.length=0,i.push(0),i.push(1),h&&(i[1]=n.swap(i[0],i[0]=i[1]))),r&&(r.length=0,r.push(1),r.push(0),h&&(r[1]=n.swap(r[0],r[0]=r[1]))),s&&(s.length=0,s.push(u[0]),s.push(u[3]),h&&(s[1]=n.swap(s[0],s[0]=s[1]))),!0)}(s,i,r,o,a,0,0,0,l))return 2;const _=new n.Envelope1D(0,1),P=new n.Envelope1D(0,1);{const t=new d;tn(c,new n.Envelope1D(0,1),t);const e=new d;tn(g,new n.Envelope1D(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*m),e.inflate(3*m),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(mn(c,t,_),_.isEmpty())return 0;if(mn(g,t,P),P.isEmpty())return 0;Ls(c,_.vmin,_.vmax,c),Ls(g,P.vmin,P.vmax,g)}}const f=Ir(c,3,g,3,m);if(0===f)return 0;const y=[],D=[],v=[];let E=!1;if(-1===f){const t=n.makeObjectArray(x,4);bs(c,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],i=n.makeObjectArray(x,4);bs(g,i);const r=[],o=[],a=Ht(e,3,s,3,null,0,[i[0].x,i[1].x,i[2].x,i[3].x],3,[i[0].y,i[1].y,i[2].y,i[3].y],3,null,0,0,n.Envelope1D.unit(),n.Envelope1D.unit(),r,o,u);if(a>0)for(let t=0;t<a;t++){const e=new n.Point2D;zs(g,o[t],e);const s=new n.Point2D;zs(c,r[t],s),n.Point2D.distance(s,e)<=m&&(y.push(s.clone()),v.push(o[t]),D.push(r[t]))}else-1===a&&(E=!0)}for(let t=0;t<2;t++){const e=0===t?c:g,s=0===t?g:c;for(let i=0;i<2;i++){const r=0===i?0:3,o=[0];sn(s,e[r],n.Envelope1D.unit(),!1,-1,1,o);const a=new n.Point2D;zs(s,o[0],a),n.Point2D.distance(e[r],a)<=m&&(0===t?(D.push(0===r?0:1),v.push(o[0])):(v.push(0===r?0:1),D.push(o[0])),y.push(a.clone()))}}if(0===D.length&&E){const t=s.calculateUpperLength2D()>i.calculateUpperLength2D();{const r=[0,0];if(2===rn(t?s:i,r,!0)&&(e.geometryReleaseAssert(n.Envelope1D.unit().containsCoordinate(r[0])),!n.Envelope1D.unit().containsCoordinate(r[1]))){const e=new n.Point2D;zs(t?c:g,r[0],e);const s=[0,0];1===sn(t?g:c,e,n.Envelope1D.unit(),!1,-1,2,s)&&(y.push(e.clone()),D.push(t?r[0]:s[0]),v.push(t?s[0]:r[0]))}}}if(0===D.length)return 0;if(!_.equalsRange(0,1))for(let t=0;t<D.length;++t)D[t]=pn.recalculateParentT(_.vmin,_.vmax,D[t]);if(!P.equalsRange(0,1))for(let t=0;t<v.length;++t)v[t]=pn.recalculateParentT(P.vmin,P.vmax,v[t]);return Tr(t,s,i,D,v,D.length,r,o,a,m,h,0,l)}function $s(t,s,i,r,o,a,m,h,u,l){const c=k(s,i);if(i.isDegenerateToLineHelper(c)){const e=new Nr({start:i.getStartXY(),end:i.getEndXY()}),n=Zs(t,s,e,r,o,a,m,h,0,l);if(a)for(let t=0;t<n;++t){const s=e.getCoord2D(a[t]);a[t]=i.getClosestCoordinate(s,!1)}return n}if(L(s,i,m=Math.max(m,c)))return 0;const g=n.makeObjectArray(n.Point2D,4);s.queryControlPoints(g);const p=n.makeObjectArray(n.Point2D,3);i.queryControlPoints(p);const _=new n.Envelope1D(0,1),P=new n.Envelope1D(0,1),f=[0,0,0];i.queryWeights(f);const y=[1,oi(f),1];{const t=new d;tn(g,new n.Envelope1D(0,1),t);const e=new d;Ln(p,y,new n.Envelope1D(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*m),e.inflate(3*m),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(mn(g,t,_),_.isEmpty())return 0;if(ri(p,y,t,P),P.isEmpty())return 0;Ls(g,_.vmin,_.vmax,g),Bn(p,y,P.vmin,P.vmax,p,y)}}const D=Ir(g,3,p,2,m);if(0===D)return 0;const v=[],E=[],C=[];if(-1===D){const t=n.makeObjectArray(x,4);bs(g,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],i=n.makeObjectArray(n.MPValue,3),r=n.makeObjectArray(n.MPValue,3),o=n.makeObjectArray(n.MPValue,3);ti(p,y,i,r,o);const a=[],h=[],l=Ht(i,2,r,2,o,2,e,3,s,3,null,0,0,n.Envelope1D.unit(),n.Envelope1D.unit(),h,a,u);if(l>0)for(let t=0;t<l;t++){const e=new n.Point2D;zs(g,a[t],e);const s=new n.Point2D;ii(p,y,h[t],s),n.Point2D.distance(e,s)<=m&&(v.push(e.clone()),E.push(a[t]),C.push(h[t]))}}for(let t=0;t<2;t++){let s,i;0===t?(s=g,i=p):(i=g,s=p);for(let r=0;r<2;r++){const o=0===r?0:s.length-1,a=[0],h=new n.Point2D;if(0===t){const t=Vn(i,y,s[o],n.Envelope1D.unit(),!1,-1,1,a);e.geometryReleaseAssert(1===t),ii(i,y,a[0],h)}else{const t=sn(i,s[o],n.Envelope1D.unit(),!1,-1,1,a);e.geometryReleaseAssert(1===t),zs(i,a[0],h)}n.Point2D.distance(s[o],h)<=m&&(0===t?(E.push(0===o?0:1),C.push(a[0])):(C.push(0===o?0:1),E.push(a[0])),v.push(h.clone()))}}if(0===E.length)return 0;if(!_.equalsRange(0,1))for(let t=0;t<E.length;++t)E[t]=pn.recalculateParentT(_.vmin,_.vmax,E[t]);if(!P.equalsRange(0,1))for(let t=0;t<C.length;++t)C[t]=zt.recalculateParentT(P.vmin,P.vmax,C[t]);for(let t=0;t<C.length;++t)C[t]=ai(f,C[t]);return Tr(t,s,i,E,C,E.length,r,o,a,m,h,0,l)}function Ks(t,s,i,r,o,a,m,h,u,l){const c=k(s,i);if(L(s,i,m=Math.max(m,c)))return 0;const g=n.makeObjectArray(n.Point2D,4);s.queryControlPoints(g);const d=n.makeObjectArray(n.Point2D,3);i.queryControlPoints(d);const p=Ir(g,3,d,2,m);if(0===p)return 0;const _=[],P=[],f=[];if(-1===p){const t=n.makeObjectArray(x,4);bs(g,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],r=[t[0].y,t[1].y,t[2].y,t[3].y],o=n.makeObjectArray(x,3);Oe(d,o);const a=Ht([o[0].x,o[1].x,o[2].x],2,[o[0].y,o[1].y,o[2].y],2,null,0,e,3,r,3,null,0,0,n.Envelope1D.unit(),n.Envelope1D.unit(),f,P,h);if(a>0){let t=0;for(let e=0;e<a;e++){const r=new n.Point2D;s.queryCoord2D(P[e],r);const o=new n.Point2D;i.queryCoord2D(f[e],o),n.Point2D.distance(r,o)<=m&&(_.push(r.clone()),P[t]=P[e],f[t]=f[e],t++)}P.length=t,_.length=t}}for(let t=0;t<2;t++){let s,i;0===t?(s=g,i=d):(i=g,s=d);for(let r=0;r<2;r++){const o=0===r?0:s.length-1,a=[0],h=new n.Point2D;if(0===t)Ie(i,s[o],a),je(i,a[0],h);else{const t=sn(i,s[o],n.Envelope1D.unit(),!1,-1,1,a);e.geometryReleaseAssert(1===t),zs(i,a[0],h)}n.Point2D.distance(s[o],h)<=m&&(0===t?(P.push(0===o?0:1),f.push(a[0])):(f.push(0===o?0:1),P.push(a[0])),_.push(h.clone()))}}return Tr(t,s,i,P,f,P.length,r,o,a,m,h,0,l)}function Js(t,e,s){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i),tn(i,e,s)}function tn(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,4);const i=n.makeObjectArray(n.Point2D,4);Ls(t,e.vmin,e.vmax,i),s.setFromPoints(i,4)}let en=class{constructor(t,e,s){this.dbgCounter=0,this.controlPoints=t,this.point=e.clone(),this.maxDistance=s}getMaxDerivative(){return 6}getValue(t,e){switch(t){case 0:{const t=new n.Point2D;zs(this.controlPoints,e,t);const s=qs(this.controlPoints,1,e);return 2*t.sub(this.point).dotProduct(s)}case 1:{const t=new n.Point2D;zs(this.controlPoints,e,t);const s=qs(this.controlPoints,1,e),i=qs(this.controlPoints,2,e);return 2*(t.sub(this.point).dotProduct(i)+s.dotProduct(s))}case 2:{const t=new n.Point2D;zs(this.controlPoints,e,t);const s=qs(this.controlPoints,1,e),i=qs(this.controlPoints,2,e),r=qs(this.controlPoints,3,e);return 2*(t.sub(this.point).dotProduct(r)+3*s.dotProduct(i))}case 3:{const t=qs(this.controlPoints,1,e),s=qs(this.controlPoints,2,e),n=qs(this.controlPoints,3,e);return 2*(4*t.dotProduct(n)+3*s.sqrLength())}case 4:{const t=qs(this.controlPoints,2,e),s=qs(this.controlPoints,3,e);return 10*t.dotProduct(s)*2}case 5:{const t=qs(this.controlPoints,3,e);return 10*t.dotProduct(t)*2}default:return 0}}getError(t){return 0}isInterestingInterval(t,e){if(t>=0&&e<=1){const s=n.makeObjectArray(n.Point2D,4);Ls(this.controlPoints,t,e,s);const i=new d;if(i.setFromPoints(s,4),Math.sqrt(i.sqrMinDistance(this.point))>this.maxDistance)return!1}return!0}};function sn(t,i,r,o,a,m,h){e.checkAndThrow(n.Envelope1D.unit().contains(r)&&m>0,"getClosestCoordinate"),(a<0||Number.isNaN(a))&&(a=Number.MAX_VALUE);const u=[],l=new n.Point2D;zs(t,r.vmin,l);let c=n.Point2D.distance(l,i);if(c<=a&&u.push(new n.Point2D(r.vmin,c)),r.vmin!==r.vmax&&(zs(t,r.vmax,l),c=n.Point2D.distance(l,i),c<=a&&u.push(new n.Point2D(r.vmax,c))),r.width()>0){const e=n.makePrimitiveArray(18,Number.NaN),s=Et(new en(t,i,a),r,18,e);for(let r=0;r<s;r++)zs(t,e[r],l),c=n.Point2D.distance(l,i),c>a||u.push(new n.Point2D(e[r],c))}if(o){e.geometryReleaseAssert(r.equals(n.Envelope1D.unit()));{zs(t,-1,l,!0);const e=new n.Point2D;zs(t,0,e);const s=new Nr({start:l,end:e}),r=s.getClosestCoordinate(i,!0);r<1&&(l.assign(s.getCoord2D(r)),c=n.Point2D.distance(l,i),c<=a&&u.push(new n.Point2D(r-1,c)))}{zs(t,2,l,!0);const e=new n.Point2D;zs(t,r.vmax,e);const s=new Nr({start:e,end:l}),o=s.getClosestCoordinate(i,!0);o>0&&(l.assign(s.getCoord2D(o)),c=n.Point2D.distance(l,i),c<=a&&u.push(new n.Point2D(1+o,c)))}}if(!u.length)return 0;u.sort((t,e)=>t.compare(e));let g=0;const d=u[0].x;if(h[g++]=d,g<m){const e=s.calculateToleranceFromPointsForOps(t,4,!1).total(),i=u[0].y;for(let t=1,s=u.length;t<s;t++)if(u[t].y>i+e){u.length=t;break}u.sort((t,e)=>n.standardNumericCompare(t.x,e.x)),g=0,h[g++]=u[0].x;for(let t=1,e=u.length;t<e;t++)u[t].x!==h[g-1]&&g<m&&(h[g++]=u[t].x)}return g}function nn(t,e,s,i,r,o,a){const m=n.makeObjectArray(n.Point2D,4);return t.queryControlPoints(m),sn(m,e,s,i,r,o,a)}function rn(t,e,s=!1){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i);const r=n.makeObjectArray(x,4);let o,a,m;bs(i,r,!0);const h=r[3].x.isZero(),u=r[3].y.isZero();if(h||u)if(h&&!u){if(r[2].x.isZero())return 0;o=r[1].x.div(r[2].x).negate(),a=r[2].y.div(r[3].y),m=r[1].y.div(r[3].y)}else{if(h||!u)return 0;if(r[2].y.isZero())return 0;o=r[1].y.div(r[2].y).negate(),a=r[2].x.div(r[3].x),m=r[1].x.div(r[3].x)}else{r[2].x.divThis(r[3].x),r[1].x.divThis(r[3].x),r[2].y.divThis(r[3].y),r[1].y.divThis(r[3].y);const t=r[2].x.sub(r[2].y);if(t.isZero())return 0;o=r[1].x.sub(r[1].y).div(t).negate(),a=r[2].x.clone(),m=r[1].x.clone()}if(!s&&o.abs().value()>2)return 0;const l=[0,0],c=t.getStartXY().equals(t.getEndXY()),g=Ct(1,-o.toDouble(),o.add(a).mul(o).add(m).toDouble(),n.Envelope1D.unit(),c,l);if(0===g)return 0;if(l[0]>=0&&l[0]<=1){const t=o.toDouble()-l[0];if(s||t>=0&&t<=1)return e[0]=l[0],e[1]=t,e[0]>e[1]&&(e[1]=n.swap(e[0],e[0]=e[1])),2}if(2===g&&l[1]>=0&&l[1]<=1){const t=o.toDouble()-l[1];if(s||t>=0&&t<=1)return e[0]=l[1],e[1]=t,e[0]>e[1]&&(e[1]=n.swap(e[0],e[0]=e[1])),2}return 0}function on(t,s){s[0].set(0);let i=1;const r=n.makeObjectArray(n.ECoordinate,4);Es(t,r,!0);const o=n.makeObjectArray(n.ECoordinate,4);Cs(t,o,!0);{const t=r[3].mul(3),e=r[2].mul(2),o=r[1].clone(),a=n.makeObjectArray(n.ECoordinate,2);let m=Mt(t,e,o,new n.Envelope1D(0,1),!1,a);m<0&&(m=0);for(let t=0;t<m;t++)n.isOneOf(a[t].value(),0,1)||(s[i]=a[t],i++)}{const t=o[3].mul(3),e=o[2].mul(2),r=o[1].clone(),a=n.makeObjectArray(n.ECoordinate,2);let m=Mt(t,e,r,new n.Envelope1D(0,1),!1,a);m<0&&(m=0);for(let t=0;t<m;t++)n.isOneOf(a[t].value(),0,1)||(s[i]=a[t],i++)}const a=function(t,e,s){const i=t[1].mulE(e[2]).subThisE(t[2].mulE(e[1])),r=t[1].mulE(e[3]).subThisE(t[3].mulE(e[1])).mulThis(3),o=t[2].mulE(e[3]).subThisE(t[3].mulE(e[2])).mulThis(3),a=n.makeObjectArray(n.ECoordinate,2);let m=Mt(o,r,i,new n.Envelope1D(0,1),!1,a);m<0&&(m=0);let h=0;for(let t=0;t<m;t++)n.isOneOf(a[t].value(),0,1)||(s[h].setE(a[t]),h++);return h}(r,o,s.slice(i));if(i+=a,s[i].set(1),i++,i>2){n.sortRange(s,0,i,(t,e)=>{const s=t.value(),n=e.value();return s<n?-1:s>n?1:0});let e=0;const r=s[0].clone();let o=0;const a=((m=t)[0].norm(1)+m[1].norm(1)+m[2].norm(1)+m[3].norm(1))*n.doubleEps(),h=new n.Point2D;Vs(t,s[0].value(),h);for(let m=1;m<i;m++){const i=new n.Point2D;if(Vs(t,s[m].value(),i),s[m].eq(r)||i.isEqualPoint2D(h,a)){if(0!==e){if(0===s[m].eps())r.setE(s[m]),o=0;else if(0!==o){const t=n.sqr(1/s[m].eps()),e=1/o,i=t+e;r.set((s[m].value()*t+r.value()*e)/i),o=1/i,r.setError(Math.sqrt(o))}s[e].setE(r),Vs(t,r.value(),h)}}else e++,s[e].setE(s[m]),r.setE(s[m]),Vs(t,r.value(),h),o=n.sqr(s[m].eps())}e++,i=e}var m;return 1===i&&(i=2,s[1].set(1)),e.geometryReleaseAssert(0===s[0].value()),e.geometryReleaseAssert(1===s[i-1].value()),i}function an(t,e,s,i){const r=n.makeObjectArray(n.Point2D,s);for(let t=0;t<s;++t)r[t]=new n.Point2D(t/(s-1),0);const o=(t,e,s,i)=>{const r=new n.ECoordinate(e.x).subE(new n.ECoordinate(t.x)).divE(new n.ECoordinate(e.y).subE(new n.ECoordinate(t.y))).mulE(new n.ECoordinate(s).subE(new n.ECoordinate(t.y))).addE(new n.ECoordinate(t.x));if(r.eps()>.1){const i=(e.x-t.x)/(e.y-t.y)*(s-t.y)+t.x;r.set(i,n.doubleEps())}if(r.lt(new n.ECoordinate(0))||r.gt(new n.ECoordinate(1)))return!1;let o=r.value()-r.eps();o=n.snap(o,0,1);let a=r.value()+r.eps();return a=n.snap(a,0,1),i.mergeCoordinate(o),i.mergeCoordinate(a),!0},a=[];{const e=(t,e)=>{a.length=s;const i=as(r,s,a,!0),m=new n.Envelope1D;m.setEmpty();const h=s=>s.y<t?-1:s.y>e?1:0;let u=r[a[0]],l=h(u);0===l&&m.mergeCoordinate(u.x);for(let s=1;s<=i;++s){const n=r[a[s%i]],c=h(n);0===c&&m.mergeCoordinate(n.x);let g=0;c!==l&&(g=c*l===0?1===c||1===l?2:1:3,1&g&&o(u,n,t,m),2&g&&o(u,n,e,m)),u=n,l=c}return m};for(let e=0;e<s;++e)r[e].y=t[e].x;const m=e(i.xmin,i.xmax);if(m.isEmpty())return new n.Envelope1D(m);for(let e=0;e<s;++e)r[e].y=t[e].y;const h=e(i.ymin,i.ymax);return m.intersect(new n.Envelope1D(h)),new n.Envelope1D(m)}}function mn(t,e,s){s.setEmpty(),s.merge(function(t,e,s,i){const r=an(t,0,4,i.getEnvelope2D());if(r.isEmpty())return new n.Envelope1D(r);const o=n.makeObjectArray(n.Point2D,4);for(let e=0;e<4;++e)i.xyRot(t[e],o[e]);const a=an(o,0,4,i.getRotatedEnvelope2D());return r.intersect(new n.Envelope1D(a)),new n.Envelope1D(r)}(t,0,0,e))}class hn{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-As(this.b,e,!1):0}getError(t){return 0}}function un(t,s,i,r,o,a,m){for(;;){const h=n.Point2D.distance(s[0],s[3]),u=n.Point2D.distance(s[0],s[1])+n.Point2D.distance(s[1],s[2])+n.Point2D.distance(s[2],s[3]);if(u-h<=r+i*u)return t+n.lerp(h,u,.5);const l=t=>qs(s,1,t).length();{e.geometryReleaseAssert(m<12);let h=l(0),c=l(1);o[0]+=2,h>c&&(c=n.swap(h,h=c),s[3]=n.swap(s[0],s[0]=s[3]),s[2]=n.swap(s[1],s[1]=s[2]));let g=h/(h+c),d=1,p=u;for(;g<1/32&&p>=32*(r+i*p);){d/=4;const t=l(d);o[0]++,g=h/(t+h);const e=new n.Point2D;if(zs(s,.5*d,e),p=n.Point2D.distance(e,s[0]),p<=r){const t=new n.Point2D;zs(s,d,t),p+=n.Point2D.distance(t,e)}}if(1!==d){const e=n.makeObjectArray(n.Point2D,4);ks(s,d,s,e),t=un(t,e,i,r,o,0,m+1),a++,m++;continue}}const c=8;o[0]+=c;const g=Je(c,l,0,1),d=16;o[0]+=d;const p=Je(d,l,0,1);let _=Math.abs(g-p)>r+i*u;if(!_)return t+p;if(a<3){const e=n.makeObjectArray(n.Point2D,4);ks(s,.5,s,e),t=un(t,e,i,r,o,a+1,m+1),a++,m++;continue}const P=32;o[0]+=P;const f=Je(P,l,0,1);if(_=Math.abs(p-f)>r+i*u,!_)return t+f;const y=64;o[0]+=y;const x=Je(y,l,0,1);if(_=Math.abs(f-x)>r+i*u,!_)return t+x;const D=128;o[0]+=D;const v=Je(D,l,0,1);return _=Math.abs(x-v)>r+i*u,t+v}}function ln(t,e,s,i,r){if(s===e)return 0;const o=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(o);const a=n.makeObjectArray(n.Point2D,4);return Ls(o,e,s,a),un(0,a,i,r,[0],0,0)}function cn(t,e,s,i,r){let o=!0;const a=ue(5,e,s,i,r,e=>{const s=Ys(t,1,e);return(o?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()});o=!1;const m=ue(5,e,s,i,r,e=>{const s=Ys(t,1,e);return(o?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()});return new n.Point2D(a,m)}function gn(t,s,i,r,o,a,m,h,u,l,c,g){e.geometryReleaseAssert(l+2===g);let d=0,p=0,_=0,P=0,f=0,y=0,x=0;const D=(t,e)=>{const s=1-e,m=i.mul(n.cube(s)),h=r.mul(3*e*s*s),u=o.mul(3*e*e*s),l=a.mul(n.cube(e));return m.add(h).add(u).add(l).sub(c[t]).sqrLength()};for(let e=1,s=g-1;e<s;e++){let s=u[e-1];if(t){e>2?(s=n.snap(2*u[e-2]-u[e-3],0,1),u[e-1]=s):2===e&&(s=n.snap(2*u[e-2],0,1),u[e-1]=s);const t=(t,e,s)=>{let m=-1;for(let h=0;!(Math.abs(e-m)<1e-12)&&10!==h;h++){const h=e*e,u=1-e,l=u*u,g=l*u,d=i.x-2*r.x+o.x,p=i.x-3*r.x+3*o.x-a.x,_=i.y-2*r.y+o.y,P=i.y-3*r.y+3*o.y-a.y,f=i.x-r.x-2*d*e+p*h,y=-c[t].x+i.x*g+e*(3*r.x*l+e*(3*o.x*u+a.x*e)),x=i.y-r.y-2*_*e+P*h,D=-c[t].y+i.y*g+e*(3*r.y*l+e*(3*o.y*u+a.y*e)),v=-6*(f*y+x*D),E=6*(3*n.sqr(f)-(-2*d+2*p*e)*y)+6*(3*n.sqr(x)-(-2*_+2*P*e)*D);if(m=e,0===E)break;{const t=e-v/E;e=n.snap(t,s,1)}}return m};{const s=D(e,u[e-1]);let n=t(e,u[e-1],0),i=D(e,n);if(1.01*s<i){const s=e>1?u[e-2]:0,r=t(e,.3*(u[e-1]-s)+s,0),o=D(e,r);o<i&&(i=o,n=r)}s>i&&(u[e-1]=n)}}const m=u[e-1],h=m*m,l=h*m,g=1-m,v=g*g,E=v*g;d+=3*h*v*v,p+=3*l*E,_+=3*h*h*v;const C=-(E*i.x+l*a.x-c[e].x);P+=C*m*v,f+=C*h*g;const b=-(E*i.y+l*a.y-c[e].y);y+=b*m*v,x+=b*h*g}if(s){const t=d*_-p*p;Math.abs(t)>=1e-12*(Math.abs(d*_)+Math.abs(p*p))+1e-10?(m||(r.x=(P*_-f*p)/t,r.y=(y*_-x*p)/t),h||(o.x=(d*f-p*P)/t,o.y=(d*x-p*y)/t)):(n.lerpPoint2D(i,a,.3,r),n.lerpPoint2D(i,a,.6,o))}let v=0;for(let t=1,e=g-1;t<e;t++)v+=D(t,u[t-1]);return v}var dn=s.VertexDescription;class pn extends W{constructor(t){t&&t.cp?(super({start:t.cp[0],end:t.cp[3],vd:t.vd}),this.m_cp=n.makeObjectArray(n.Point2D,2),this.m_cp[0].assign(t.cp[1]),this.m_cp[1].assign(t.cp[2])):void 0===t||n.isOnlyProperty(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=n.makeObjectArray(n.Point2D,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):t.from?(super({start:t.from,end:t.to,vd:t.vd}),this.m_cp=n.makeObjectArray(n.Point2D,2),this.m_cp[0].assign(t.cp1),this.m_cp[1].assign(t.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:t.vd}),e.throwInternalErrorException("unrecognized constructor params"),this.m_cp=n.makeObjectArray(n.Point2D,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return Dt(this)}construct(t,e,s,n){this.m_XStart=t.x,this.m_YStart=t.y,this.m_XEnd=n.x,this.m_YEnd=n.y,this.m_cp[0].assign(e),this.m_cp[1].assign(s),this.afterCompletedModification()}constructPoints(t){this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.afterCompletedModification()}constructFromQuadratic(t){const e=n.makeObjectArray(n.Point2D,4);var s,i;s=t,(i=e)[0].assign(s[0]),i[3].assign(s[2]),n.lerpPoint2D(s[0],s[1],2/3,i[1]),n.lerpPoint2D(s[1],s[2],1/3,i[2]),this.constructPoints(e)}constructFromQuadraticSegment(t){this.dropAllAttributes(),this.assignVertexDescription(t.getDescription()),this.m_XStart=t.getStartX(),this.m_YStart=t.getStartY(),this.m_XEnd=t.getEndX(),this.m_YEnd=t.getEndY(),n.lerpPoint(2,t.getStartXY(),t.getControlPoint1(),2/3,this.m_cp[0]),n.lerpPoint(2,t.getControlPoint1(),t.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),F(this,t)}getGeometryType(){return e.GeometryType.enumBezier}queryEnvelope(t){if(2!==t.m_EnvelopeType)return void e.geometryReleaseAssert(0);if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp[0])&&t.contains(this.m_cp[1]))return;const s=Ss(this);if(null!==s){const e=new n.Point2D;for(const n of s.specialPoints)this.queryCoord2D(n,e),t.mergeNe(e);return}const i=n.makeObjectArray(n.ECoordinate,8),r=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(r);const o=on(r,i),a=new n.Point2D;for(let e=1;e<o-1;e++)this.queryCoord2D(i[e].value(),a),t.mergeNe(a)}applyTransformation(t){if(1===t.m_TransformationType){const e=n.makeObjectArray(n.Point2D,4);return this.queryControlPoints(e),t.transformPoints2D(e,4,e),this.setStartXY(e[0]),this.m_cp[0].assign(e[1]),this.m_cp[1].assign(e[2]),this.setEndXY(e[3]),void Is(this)}e.geometryReleaseAssert(0)}createInstance(){return new pn({vd:this.m_description})}calculateLength2D(){return As(this,1,!1)}calculateLowerLength2D(){return n.Point2D.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return n.Point2D.distance(this.getStartXY(),this.m_cp[0])+n.Point2D.distance(this.m_cp[0],this.m_cp[1])+n.Point2D.distance(this.getEndXY(),this.m_cp[1])}queryCoord2D(t,e){return this.queryCoord2DExtends(t,e,!0)}queryCoord2DMP(t,s){e.geometryReleaseAssert(0)}queryCoord2DExtends(t,e,s){const i=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(i),zs(i,t,e,s)}queryCoord2DE(t,e){!function(t,e,s){const i=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(i),function(t,e,s){if(e.value()<=.5){const i=new f;n.lerpLoPointE(2,f.constructPoint2D(t[0]),f.constructPoint2D(t[1]),e,i);const r=new f;n.lerpLoPointE(2,f.constructPoint2D(t[1]),f.constructPoint2D(t[2]),e,r);const o=new f;n.lerpLoPointE(2,f.constructPoint2D(t[2]),f.constructPoint2D(t[3]),e,o);const a=new f;n.lerpLoPointE(2,i,r,e,a);const m=new f;n.lerpLoPointE(2,r,o,e,m),n.lerpLoPointE(2,a,m,e,s)}else{const i=new f;n.lerpHiPointE(2,f.constructPoint2D(t[0]),f.constructPoint2D(t[1]),e,i);const r=new f;n.lerpHiPointE(2,f.constructPoint2D(t[1]),f.constructPoint2D(t[2]),e,r);const o=new f;n.lerpHiPointE(2,f.constructPoint2D(t[2]),f.constructPoint2D(t[3]),e,o);const a=new f;n.lerpHiPointE(2,i,r,e,a);const m=new f;n.lerpHiPointE(2,r,o,e,m),n.lerpHiPointE(2,a,m,e,s)}}(i,e,s)}(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new n.Point2D;return this.queryCoord2DExtends(t,e,!0),e.x}const e=n.lerp(this.getStartX(),this.m_cp[0].x,t),s=n.lerp(this.m_cp[0].x,this.m_cp[1].x,t),i=n.lerp(this.m_cp[1].x,this.getEndX(),t),r=n.lerp(e,s,t),o=n.lerp(s,i,t);return n.lerp(r,o,t)}getCoordY(t){if(t<0||t>1){const e=new n.Point2D;return this.queryCoord2DExtends(t,e,!0),e.y}const e=n.lerp(this.getStartY(),this.m_cp[0].y,t),s=n.lerp(this.m_cp[0].y,this.m_cp[1].y,t),i=n.lerp(this.m_cp[1].y,this.getEndY(),t),r=n.lerp(e,s,t),o=n.lerp(s,i,t);return n.lerp(r,o,t)}cut(t,e,s){const n=new qr;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createCubicBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=dn.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=dn.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){Os(this,t,e)}cutBezierIgnoreAttributes(t,s,i){(t<0||s>1||t>s)&&e.throwInvalidArgumentException("Cubic_bezier.cut_bezier_ignore_attributes");const r=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(r);const o=n.makeObjectArray(n.Point2D,4);Ls(r,t,s,o),i.setControlPoints(o)}splitBezierIgnoreAttributes(t,s,i){this===s&&this===i&&e.throwInvalidArgumentException("Cubic_bezier.split_bezier_ignore_attributes");const r=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(r);const o=n.makeObjectArray(n.Point2D,4),a=n.makeObjectArray(n.Point2D,4);ks(r,t,o,a),s&&s.setControlPoints(o),i&&i.setControlPoints(a)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const i=this.getStartAttributeAsDbl(e,s),r=this.getEndAttributeAsDbl(e,s),o=this.calculateLength2D(),a=o>0?this.tToLength(t)/o:0,m=dn.getInterpolation(e);return n.interpolate(m,i,r,a,dn.getDefaultValue(e))}getClosestCoordinate(t,e){const s=[Number.NaN];return nn(this,t,n.Envelope1D.unit(),e,-1,1,s),s[0]}getClosestCoordinateOnInterval(t,e,s=-1){const n=[Number.NaN];return 0===nn(this,t,e,!1,s,1,n)?Number.NaN:n[0]}getYMonotonicParts(t,e=!1){return this.getMonotonicParts(t,e)}getMonotonicParts(t,s){t.length<2&&e.throwInvalidArgumentException("");const n=ws(this);if(2===n.specialPointsCount()&&this.isMonotoneQuickAndDirty())return 0;let i=0;e.geometryReleaseAssert(t.length>=n.specialPointsCount()-1);for(let e=1,r=n.specialPointsCount();e<r;++e)this.queryCut(n.specialPoints[e-1],n.specialPoints[e],t[i],s),i++;for(let e=0;e<i;++e)Rs(t[e].get());return i}intersectionWithAxis2D(t,e,s,i){const r=n.makeObjectArray(n.Point2D,4);return this.queryControlPoints(r),function(t,e,s,i,r){const o=n.makeObjectArray(n.ECoordinate,4),a=n.makeObjectArray(n.ECoordinate,3),m=new n.Envelope1D(0,1);let h=0;if(e){if(Cs(t,o,!1),h=Nt(o[3],o[2],o[1],o[0].sub(s),m,!1,a),i)for(let e=0;e<h;e++){const s=new n.Point2D;zs(t,a[e].value(),s),i[e]=s.x}}else if(Es(t,o,!1),h=Nt(o[3],o[2],o[1],o[0].sub(s),m,!1,a),i)for(let e=0;e<h;e++){const s=new n.Point2D;zs(t,a[e].value(),s),i[e]=s.y}if(r)for(let t=0;t<h;t++)r[t]=a[t].value();else i&&n.sortRange(i,0,h,n.standardNumericCompare);return h}(r,t,e,s,i)}intersectionOfYMonotonicWithAxisX(t,s){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?s:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const n=[0,0],i=this.intersectionWithAxis2D(!0,t,n,null);return e.geometryReleaseAssert(2!==i),-1===i?s:n[0]}isCurve(){return!0}isDegenerate(t){return C(this,t)}isDegenerate3D(t,s){return e.geometryReleaseAssert(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp[0]),t.mergeNe(this.m_cp[1]),void t.mergeNe(this.getEndXY());e.geometryReleaseAssert(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=i.Envelope2D.constructEmpty();this.queryEnvelope(t);const s=n.Envelope1D.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(s),Ls(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),n=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),i=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),r=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp[0].setCoordsPoint2D(t):n&&this.m_cp[0].setCoordsPoint2D(e),r?this.m_cp[1].setCoordsPoint2D(e):i&&this.m_cp[1].setCoordsPoint2D(t),this.normalizeAfterEndpointChange()}tToLength(t){return As(this,t,!0)}lengthToT(t){const s=function(t,s){const i=As(t,1,!1);if(s<=0)return s;if(s>=i)return s-i+1;const r=[0];return 1!==Et(new hn(t,s),n.Envelope1D.unit(),1,r)&&e.throwInternalErrorException(""),r[0]}(this,t);return s}calculateWeightedAreaCentroid2D(t){const e=n.makeObjectArray(n.Point2D,4);xs(this,e);const s=e[3],i=e[2],r=e[1],o=new n.Point2D;o.x=(5*s.x*s.x*(7*i.y+16*r.y)+s.x*(-35*s.y*i.x+40*i.x*i.y-80*s.y*r.x+140*i.x*r.y+112*r.x*r.y)-2*(s.y*(20*i.x*i.x+70*i.x*r.x+56*r.x*r.x)-7*(4*i.x+5*r.x)*(-i.y*r.x+i.x*r.y)))/840,o.y=(-5*s.y*s.y*(7*i.x+16*r.x)+s.y*(5*s.x*(7*i.y+16*r.y)-4*(10*i.x*i.y+35*i.y*r.x+28*r.x*r.y))+2*(-7*(4*i.y+5*r.y)*(i.y*r.x-i.x*r.y)+s.x*(20*i.y*i.y+70*i.y*r.y+56*r.y*r.y)))/840;const a=Xs(this);return o.x+=(e[0].x-t.x)*a,o.y+=(e[0].y-t.y)*a,o}calculateWeightedCentroid2D(){const t=new n.Point2D;return this.isDegenerate(0)?(t.setCoords(0,0),t):function(t){const e=n.Point2D.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(function(t,s,i){void 0===i&&(i=s,s=0);const r=new n.Point2D;if(s<0||i>1)return r.setNAN(),r;if(s>i&&e.throwInvalidArgumentException("calculate_sub_weightedCentroid"),s===i||t.isDegenerate(0))return r.setCoords(0,0),r;const o=ws(t),a=ys(t),m=a/t.calculateUpperLength2D();let h=s,u=0;for(let t=1,e=o.specialPointsCount();t<e;t++)if(s<o.specialPoints[t]){u=t-1;break}r.setCoords(0,0);for(let e=u+1,s=o.specialPointsCount();e<s;e++){const s=Math.min(o.specialPoints[e],i),n=cn(t,h,s,m,a);if(r.addThis(n),h=s,i<=o.specialPoints[e])break}return r.add(t.getStartXY().mul(t.calculateLength2D()))}(this,1)),t)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(t){this.m_cp[0].setCoordsPoint2D(t),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(t){this.m_cp[1].setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp[0]),t[2].assign(this.m_cp[1]),t[3].assign(this.getEndXY())}queryControlPointsHelper(t){return this.queryControlPoints(t),4}setControlPoints(t){for(let s=0;s<4;s++)t[s].isNAN()&&e.throwInvalidArgumentException("NAN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp[0].setCoordsPoint2D(t[1]),this.m_cp[1].setCoordsPoint2D(t[2]),this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.afterCompletedModification()}getTangent(t){const e=n.makeObjectArray(n.Point2D,4);return this.queryControlPoints(e),Gs(e,t)}getDerivative(t){const e=n.makeObjectArray(n.Point2D,4);return this.queryControlPoints(e),qs(e,1,t)}getCurvature(t){const e=Ys(this,1,t),s=Ys(this,2,t),n=e.sqrLength();return 0===n?Number.NaN:(e.divThis(Math.sqrt(n)),e.crossProduct(s)/n)}isIntersectingPoint(t,e,s){if(s&&(t.equals(this.getStartXY())||t.equals(this.getEndXY())))return!1;const r=new i.Envelope2D;if(this.queryLooseEnvelope(r),r.inflateCoords(e,e),!r.contains(t))return!1;const o=this.getClosestCoordinate(t,!1),a=new n.Point2D;return this.queryCoord2D(o,a),n.Point2D.distance(a,t)<=e}isIntersectingPoint3D(t,s,n,i,r=1){return e.geometryReleaseAssert(0),!1}isMonotoneQuickAndDirty(){const t=n.makeObjectArray(n.Point2D,4);return this.queryControlPoints(t),function(t){return function(t){const e=n.compareNoNANs(t[0].y,t[1].y),s=n.compareNoNANs(t[1].y,t[2].y),i=n.compareNoNANs(t[2].y,t[3].y);if(e>=0&&s>=0&&i>=0||e<=0&&s<=0&&i<=0){const e=n.compareNoNANs(t[0].x,t[1].x),s=n.compareNoNANs(t[1].x,t[2].x),i=n.compareNoNANs(t[2].x,t[3].x);if(e>=0&&s>=0&&i>=0||e<=0&&s<=0&&i<=0)return!0}return!1}(t)}(t)}getMonotonicPartParams(t,s){const n=ws(this),i=n.specialPointsCount();if(e.geometryReleaseAssert(O.s_maxMonotonicPartParams>=i),!s)return n.specialPointsCount();t<i&&e.throwInvalidArgumentException("");for(let t=0;t<i;t++)s[t]=n.specialPoints[t];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=n.swap(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=n.swap(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=n.swap(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cp[1]=n.swap(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const t=new n.ECoordinate;return Ns(this,t),t.value()}isLine(){return!1}isDegenerateToLineHelper(t){const e=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(e);const s=e[3].sub(e[0]),i=s.length();if(n.Point2D.distance(e[0],e[1])+n.Point2D.distance(e[2],e[1])+n.Point2D.distance(e[2],e[3])-i>t)return!1;const r=t;let o=e[1].clone();o.subThis(e[0]);let a=Math.abs(o.crossProduct(s))/i;return!(a>r||(o=e[2].clone(),o.subThis(e[1]),a=Math.abs(o.crossProduct(s))/i,a>r))}copyIgnoreAttributes(t){const e=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return Xs(this)}absNorm(){return(t=this).getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp[0].norm(1)+t.m_cp[1].norm(1);var t}queryEnvelopeW(t,e){Js(this,t,e)}setSegmentFromCoordsForStitcher(t,s){!function(t,s,i){if(e.geometryReleaseAssert(i>=2),2===i){const e=new n.Point2D;n.lerpPoint2D(s[0],s[i-1],1/3,e);const r=new n.Point2D;return n.lerpPoint2D(s[0],s[i-1],2/3,r),void t.construct(s[0],e,r,s[i-1])}const r=s[0],o=s[i-1],a=[0,0],m=nn(t,r,n.Envelope1D.unit(),!1,Number.NaN,2,a),h=[0,0],u=nn(t,o,n.Envelope1D.unit(),!1,Number.NaN,2,h),l=[];for(let e=0;e<m;e++)for(let m=0;m<u;m++){const u=a[e],c=h[m],g=u>c,d=(e,a)=>{const m=n.makePrimitiveArray(i-2,Number.NaN),h=()=>{let t=0;for(let e=1,r=i-1;e<r;e++){t+=n.Point2D.distance(s[e-1],s[e]);const i=t;m[e-1]=i}t+=n.Point2D.distance(s[i-2],s[i-1]),g&&m.reverse();for(let e=1,s=i-1;e<s;e++)m[e-1]/=t,g&&(m[e-1]=1-m[e-1])};let l=!1,d=!1;{const s=new qr;g?(t.queryCut(c,u,s,!0),e.assign(s.get().getControlPoint2()),a.assign(s.get().getControlPoint1())):(t.queryCut(u,c,s,!0),e.assign(s.get().getControlPoint1()),a.assign(s.get().getControlPoint2())),r.equals(e)&&(l=!0),o.equals(a)&&(d=!0)}h();let p=Number.MAX_VALUE;const _=e.clone(),P=a.clone();for(let t=0;t<5;t++)p=gn(!0,!1,r,_,P,o,l,d,m,i-2,s,i);for(let t=0;t<30;t++){const t=_.clone();P.clone();const e=gn(!0,!0,r,_,P,o,l,d,m,i-2,s,i);if(p<=e&&t.equals(_)&&t.equals(P))break;p=e}h();let f=!1,y=Number.MAX_VALUE;const x=e.clone(),D=a.clone();for(let t=0;t<30;t++){const t=x.clone();D.clone();const e=gn(f,!0,r,x,D,o,l,d,m,i-2,s,i);if(y<=e&&t.equals(x)&&t.equals(D))break;f=!0,y=e}return y<p?(e.assign(x),a.assign(D)):(e.assign(_),a.assign(P),y=p),y},p=new n.Point2D,_=new n.Point2D,P=[d(p,_),n.Point2D.distance(r,p)+n.Point2D.distance(p,_)+n.Point2D.distance(_,o),p.x,p.y,_.x,_.y];l.splice(l.length,0,...P)}let c=l[0],g=l[1],d=0;for(let t=6;t<l.length;t+=6)l[t]<c&&(c=l[t],g=l[t+1],d=t);let p=d;for(let t=0;t<l.length;t+=6)t!==d&&l[t+1]<g&&Math.abs(c-l[t])<10*c&&(g=l[t+1],p=t);t.construct(r,new n.Point2D(l[p+2],l[p+3]),new n.Point2D(l[p+4],l[p+5]),o)}(this,t,s)}writeInBufferStream(t,e){const s=new Float64Array(4);return this.writeInBuffer_(s),t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}writeInBuffer_(t){return t[0]=this.m_cp[0].x,t[1]=this.m_cp[0].y,t[2]=this.m_cp[1].x,t[3]=this.m_cp[1].y,4}readFromBufferStream(t,e){const s=new Float64Array(4);t.queryRange(e,s.length,s,!0,1),this.readFromBuffer_(s)}readFromBuffer_(t){this.m_cp=n.makeObjectArray(n.Point2D,2),this.m_cp[0].x=t[0],this.m_cp[0].y=t[1],this.m_cp[1].x=t[2],this.m_cp[1].y=t[3],this.m_cachedValues=null}snapControlPoints(t){const e=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(e);const s=(e,s,i)=>{let r=!1;return n.Point2D.sqrDistance(e,i)<=t&&(r=!e.equals(i),e.setCoordsPoint2D(i),n.Point2D.sqrDistance(s,i)<=t&&(r||=!s.equals(i),s.setCoordsPoint2D(i))),r},i=s(e[1],e[2],e[0]),r=s(e[2],e[1],e[3]);return(i||r)&&this.setControlPoints(e),i||r}needsSnapControlPoints(t){if(!t)return!1;const e=n.makeObjectArray(n.Point2D,4);this.queryControlPoints(e);const s=(e,s,i)=>{let r=!1;return n.Point2D.sqrDistance(e,i)<=t&&(r=!e.equals(i),e.setCoordsPoint2D(i),n.Point2D.sqrDistance(s,i)<=t&&(r||=!s.equals(i),s.setCoordsPoint2D(i))),r},i=s(e[1],e[2],e[0]),r=s(e[2],e[1],e[3]);return i||r}calculateSpecialPointsForCracking(t,e){return function(t,e,s){s.length=0;{const e=new n.ECoordinate;Ns(t,e);const i=new f;if(Os(t,e,i),i.isZero())return e.isZero()||e.eq(new n.ECoordinate(1))?0:(s.push(e.value()),1)}const i=n.makeObjectArray(n.ECoordinate,4);Ds(t,i,!0);const r=n.makeObjectArray(n.ECoordinate,4);vs(t,r,!0);const o=n.makeObjectArray(n.ECoordinate,6),a=i[3].negate().mulE(r[1]).addE(i[2].mulE(r[2]).mul(2)).addE(i[1].mulE(r[3])),m=i[3].negate().mulE(r[1]).subE(i[2].mulE(r[2]).mul(2)).addE(i[1].mulE(r[3])),h=i[2].mulE(i[2]).subE(r[2].mulE(r[2]));o[0]=r[1].mulE(r[1]).mulE(a).addE(i[1].mulE(i[1]).mulE(m)).addE(i[1].mulE(r[1]).mulE(h).mul(2)).mul(6),o[1]=i[2].mulE(r[1]).subE(i[1].mulE(r[2])).mulE(i[2].mulE(i[2]).addE(i[1].mulE(i[3]).mul(2)).addE(r[2].mulE(r[2])).addE(r[1].mulE(r[3]).mul(2))).mul(24);const u=i[1].mulE(r[2]).mulE(r[2]).mulE(r[3]),l=i[2].mulE(i[2]).mulE(i[3]).mulE(r[1]).subE(u).mul(156),c=i[3].mulE(r[1]).subE(i[1].mulE(r[3])),g=i[3].mulE(r[1]).subE(i[1].mulE(r[3])),d=i[1].mulE(i[3]).mulE(g).addE(r[1].mulE(r[3]).mulE(c)).mul(72),p=r[1].mulE(r[3]).subE(i[1].mulE(i[3])),_=i[2].mulE(r[2]).mulE(p).mul(120),P=i[1].mulE(i[2]).mulE(i[2]).mulE(r[3]),y=i[3].mulE(r[1]).mulE(r[2]).mulE(r[2]).subE(P).mul(36);o[2]=l.addE(d).addE(_).addE(y);const x=i[2].mulE(i[3]).mulE(i[3]).mulE(r[1]).subE(i[1].mulE(r[2]).mulE(r[3]).mulE(r[3])).mul(360),D=i[2].mulE(r[2]).mulE(i[2].mulE(i[3]).subE(r[2].mulE(r[3]))).addE(i[3].mulE(r[2]).mulE(r[2]).mulE(r[2])).subE(i[2].mulE(i[2]).mulE(i[2]).mulE(r[3])).mul(24),v=i[2].mulE(r[1]).mulE(r[3]).mulE(r[3]).subE(i[1].mulE(i[3]).mulE(i[3]).mulE(r[2])).mul(72),E=i[3].mulE(r[3]).mulE(r[1].mulE(r[2]).subE(i[1].mulE(i[2]))).mul(288);o[3]=x.addE(D).addE(v).addE(E),o[4]=r[3].mulE(r[3]).addE(i[3].mulE(i[3])).mulE(i[3].mulE(r[1]).subE(i[1].mulE(r[3]))).mul(270).addE(i[3].mulE(r[2]).subE(i[2].mulE(r[3]))).mulE(i[2].mulE(i[3]).addE(r[2].mulE(r[3]))).mul(180),o[5]=i[3].mulE(r[2]).subE(i[2].mulE(r[3])).mulE(i[3].mulE(i[3]).addE(r[3].mulE(r[3]))).mul(216);const C=n.makeObjectArray(n.ECoordinate,5),b=qt(o,5,new n.Envelope1D(0,1),!1,C,5);if(b>0){let i=Math.abs(t.getCurvature(0)),r=0;const o=Math.abs(t.getCurvature(1));(o>i||!Number.isFinite(o))&&(r=1);for(let e=0;e<b;e++){const s=Math.abs(t.getCurvature(C[e].value()));t.getCoord2D(C[e].value()),(s>i||!Number.isFinite(s))&&(i=s,r=C[e].value())}if((!Number.isFinite(i)||1/i<e)&&!n.isOneOf(r,0,1)){const e=t.getCoord2D(r);if(!e.equals(t.getStartXY())&&!e.equals(t.getEndXY()))return s.push(r),1}}if(!t.isClosed()){const e=[0,0],n=rn(t,e,!1);for(let t=0;t<n;t++)e[t]>0&&e[t]<1&&s.push(e[t]);return s.length}return 0}(this,t,e)}ensureXYMonotone(){return Rs(this)}setCoordsForIntersector(t,e,s){!function(t,e,s,i){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const o=!!i&&t.isMonotoneQuickAndDirty(),a=new r.Transformation2D,m=n.makeObjectArray(n.Point2D,3);m[0].setCoords(t.m_XStart,t.m_YStart),m[2].setCoords(t.m_XEnd,t.m_YEnd);const h=new n.Point2D;h.setSub(m[2],m[0]),h.leftPerpendicularThis(),m[1].setAdd(m[0],h);const u=n.makeObjectArray(n.Point2D,3);u[0].setCoordsPoint2D(e),u[2].setCoordsPoint2D(s),h.setSub(u[2],u[0]),h.leftPerpendicularThis(),u[1].setAdd(u[0],h),a.setFromTwoTriangles(m,u)?a.transformPoints2D(t.m_cp,2,t.m_cp):(n.lerpPoint2D(e,s,1/3,t.m_cp[0]),n.lerpPoint2D(e,s,2/3,t.m_cp[1])),t.changeEndPoints2D(e,s),o&&Rs(t)}(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp[0].assign(this.m_cp[0]),e.m_cp[1].assign(this.m_cp[1]),Ts(e,Ss(this))}reverseImpl(){this.m_cp[1]=n.swap(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(t){const e=t;return!!this.m_cp[0].equals(e.m_cp[0])&&!!this.m_cp[1].equals(e.m_cp[1])}equalsImplTol(t,e){const s=t;return!!this.m_cp[0].isEqualPoint2D(s.m_cp[0],e)&&!!this.m_cp[1].isEqualPoint2D(s.m_cp[1],e)}swapImpl(t){const e=t;var s;e.m_cp[0]=n.swap(this.m_cp[0],this.m_cp[0]=e.m_cp[0]),e.m_cp[1]=n.swap(this.m_cp[1],this.m_cp[1]=e.m_cp[1]),(s=e).m_cachedValues=n.swap(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){Is(this)}isIntersecting(t,e,s){return 0!==Er(!1,this,t,e,s)}intersect(t,e,s,n,i){return wr(!1,this,t,e,s,n,i)}intersectPoint(t,s,i){return function(t,s,i,r){const o=new d;if(Js(t,n.Envelope1D.unit(),o),o.inflate(r),!o.isIntersectingPoint2D(s))return 0;const a=ws(t);let m=0,h=a.specialPoints[0];const u=[];for(let n=1,i=a.specialPoints.length;n<i;++n){const i=a.specialPoints[n],r=Ms(t,s,h,i);if(0===u.length)u.push(r);else if(r.t===r.tmin)e.geometryReleaseAssert(u.at(-1).d<=r.d),u.at(-1).tmax=r.tmax;else if(u.at(-1).t===u.at(-1).tmax){e.geometryReleaseAssert(u.at(-1).d>=r.d);const t=u.at(-1).tmin;u[u.length-1]=r,u.at(-1).tmin=t}else u.push(r);h=i}for(const t of u)if(t.d<=r){const s=t.t;i?(m>=i.length&&e.throwOutOfRangeException(""),i[m]=s,m++):m++}return m}(this,t,s,i)}endPointModified(){Is(this)}clearEndPointModified(){}}pn.type=e.GeometryType.enumBezier;class _n{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}function Pn(t,s,i,r,o,a,m,h){for(;;){const u=n.Point2D.distance(s[0],s[2]),l=n.Point2D.distance(s[0],s[1])+n.Point2D.distance(s[1],s[2]);if(l-u<=o+r*l)return t+n.lerp(u,l,.5);const c=n.makeObjectArray(n.Point2D,4),g=t=>(wn(s,i,1,t,c),c[1].length());if(0===m&&h<8){e.geometryReleaseAssert(h<8);let u=g(0),c=g(1);a[0]+=2,u>c&&(c=n.swap(u,u=c),s[2]=n.swap(s[0],s[0]=s[2]),i[2]=n.swap(i[0],i[0]=i[2]));let d=u/(u+c),p=1,_=l;for(;d<1/32&&_>=o+r*_;){p/=4;const t=g(p);a[0]++,d=u/(t+u);const e=new n.Point2D;if(ii(s,i,.5*p,e),_=n.Point2D.distance(e,s[0]),_<=o){const t=new n.Point2D;ii(s,i,p,t),_+=n.Point2D.distance(t,e)}}if(1!==p){const e=n.makeObjectArray(n.Point2D,3),u=[0,0,0];jn(s,i,p,s,i,e,u),t=Pn(t,e,u,r,o,a,0,h+1),m++,h++;continue}}let d=!1;const p=8;a[0]+=p;const _=Je(p,g,0,1),P=16;a[0]+=P;const f=Je(P,g,0,1);if(d=Math.abs(_-f)>o+r*l,!d)return t+f;if(m<8&&h<9){const e=n.makeObjectArray(n.Point2D,3),u=[0,0,0];jn(s,i,.5,s,i,e,u),t=Pn(t,e,u,r,o,a,m+1,h+1),m++,h++;continue}const y=32;a[0]+=y;const x=Je(y,g,0,1);if(d=Math.abs(f-x)>o+r*l,!d)return t+x;const D=64;a[0]+=D;const v=Je(D,g,0,1);if(d=Math.abs(x-v)>o+r*l,!d)return t+v;const E=128;a[0]+=E;const C=Je(E,g,0,1);return d=Math.abs(v-C)>o+r*l,t+C}}function fn(t,e,s,i,r){if(s===e)return 0;const o=n.makeObjectArray(n.Point2D,3),a=[0,0,0];t.queryControlPoints(o),t.queryWeights(a);const m=[0,0,0],h=n.makeObjectArray(n.Point2D,3);return Bn(o,a,e,s,h,m),Pn(0,h,m,i,r,[0],0,0)}class yn{constructor(t,e,s){this.controlPoints=n.cloneObjectArray(t,3),this.weights=[0,0,0],n.memcpy(this.weights,e,0,0,3),this.point=s.clone()}getMaxDerivative(){return 3}getValue(t,e){if(0===t){const t=new n.Point2D;ii(this.controlPoints,this.weights,e,t);const s=n.makeObjectArray(n.Point2D,4);return wn(this.controlPoints,this.weights,1,e,s),2*t.sub(this.point).dotProduct(s[1])}if(1===t){const t=new n.Point2D;ii(this.controlPoints,this.weights,e,t);const s=n.makeObjectArray(n.Point2D,4);return wn(this.controlPoints,this.weights,2,e,s),2*(t.sub(this.point).dotProduct(s[2])+s[1].dotProduct(s[1]))}if(2===t){const t=new n.Point2D;ii(this.controlPoints,this.weights,e,t);const s=n.makeObjectArray(n.Point2D,4);return wn(this.controlPoints,this.weights,3,e,s),2*(t.sub(this.point).dotProduct(s[3])+3*s[1].dotProduct(s[2]))}return 0}getError(t){return e.geometryReleaseAssert(0),0}}function xn(t,e,s,i){const r={tmin:0,tmax:0,t:0,d:0,pt:n.Point2D.getNAN().clone()},o=n.makePrimitiveArray(18,Number.NaN),a=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(a),a[2].subThis(e),a[1].subThis(e),a[0].subThis(e);const m=[0,0,0];t.queryWeights(m);const h=[1,oi(m),1],u=mi(m,s),l=mi(m,i),c=Et(new yn(a,h,new n.Point2D(0,0)),n.Envelope1D.construct(u,l),18,o);ii(a,h,u,r.pt),r.t=u,r.d=n.Point2D.distance(r.pt,new n.Point2D(0,0));const g=new n.Point2D;ii(a,h,l,g);const d=n.Point2D.distance(g,new n.Point2D(0,0));d<r.d&&(r.d=d,r.t=l,r.pt.assign(g));for(let t=0;t<c;t++){ii(a,h,o[t],g);const e=n.Point2D.distance(g,new n.Point2D(0,0));e<r.d&&(r.d=e,r.t=ai(m,o[t]),r.pt.assign(g))}return r}function Dn(t,e,s,i,r){let o=!0;const a=n.makeObjectArray(n.Point2D,4),m=ue(5,e,s,i,r,e=>(An(t,1,e,a),(o?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*a[1].length()));o=!1;const h=ue(5,e,s,i,r,e=>(An(t,1,e,a),(o?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*a[1].length()));return new n.Point2D(m,h)}function vn(t){t.m_cachedValues=null}function En(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new _n,s=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(s);const i=[0,0,0];return t.queryWeights(i),Cn(s,i,e.specialPoints),Rn(t,e),e}function Cn(t,e,s){if(0===e[1])return s.length=0,s.push(0),void s.push(1);const i=n.makeObjectArray(n.ECoordinate,8);i[0].set(0);let r=1;{const s=new n.ECoordinate(t[1].x).subThis(t[0].x).mulThis(e[1]).mulThis(e[0]),o=new n.ECoordinate(t[2].x).subThis(t[0].x).mulThis(e[2]).mulThis(e[0]),a=s.subE(o).addThisE(new n.ECoordinate(t[2].x).subThis(t[1].x).mulThis(e[2]).mulThis(e[1]));o.subThisE(s.mul(2));const m=n.makeObjectArray(n.ECoordinate,2);let h=Mt(a,o,s,new n.Envelope1D(0,1),!1,m);h<0&&(h=0);for(let t=0;t<h;t++)n.isOneOf(m[t].value(),0,1)||(i[r]=m[t],r++)}{const s=new n.ECoordinate(t[1].y).subThis(t[0].y).mulThis(e[1]).mulThis(e[0]),o=new n.ECoordinate(t[2].y).subThis(t[0].y).mulThis(e[2]).mulThis(e[0]),a=s.subE(o).addThisE(new n.ECoordinate(t[2].y).subThis(t[1].y).mulThis(e[2]).mulThis(e[1]));o.subThisE(s.mul(2));const m=n.makeObjectArray(n.ECoordinate,2);let h=Mt(a,o,s,new n.Envelope1D(0,1),!1,m);h<0&&(h=0);for(let t=0;t<h;t++)n.isOneOf(m[t].value(),0,1)||(i[r]=m[t],r++)}if(i[r].set(1),r++,r>2){n.sortRange(i,0,r,(t,e)=>n.standardNumericCompare(t.value(),e.value()));let t=0,e=i[0].value(),s=1;for(let n=1;n<r;n++)i[n].eq(i[n-1])?(e+=i[n].value(),s++):(s>1&&(e/=s,i[t].set(e)),t++,i[t]=i[n],e=i[n].value(),s=1);t++,r=t}i[0].set(0),i[r-1].set(1),s.length=r;for(let t=0;t<r;t++)s[t]=i[t].value()}function bn(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+bn(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=En(t);if(n&&!Number.isNaN(i.length))return i.length;const r=Yn(t),o=r/t.calculateUpperLength2D();let a=0,m=0;for(let s=1,n=i.specialPointsCount();s<n;s++){const n=i.specialPoints[s];if(a+=fn(t,m,Math.min(e,n),o,r),e<=n)break;m=n}return n&&(i.length=a),a}function An(t,e,s,i){const r=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(r);const o=[0,0,0];t.queryWeights(o),wn(r,o,e,s,i)}function wn(t,s,i,r,o){const a=[t[0],t[1],t[2]],m=[s[0],s[1],s[2]],h=n.makeObjectArray(n.Point2D,4);!function(t,s,n,i,r){e.geometryReleaseAssert(n>0);const o=[t[0].clone(),t[1].clone(),t[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThis(o[0]);o[0].setCoords(0,0)}const a=Sn(o,s,0,i),m=In(s,0,i),h=a.divide(m);if(r[0].assign(h),0===n)return;const u=[s[1]*s[0],s[2]*s[0]*.5,s[1]*s[2]],l=[t[1].sub(t[0]),t[2].sub(t[0]),t[2].sub(t[1])],c=m*m,g=Sn(l,u,0,i).mul(2).divide(c);if(r[1].assign(g),1===n)return;const d=In(s,1,i),p=2*m*d,_=Sn(l,u,1,i).mul(2).sub(g.mul(p)).divide(c);if(r[2].assign(_),2===n)return;const P=Sn(l,u,2,i).mul(2),f=2*(d*d+m*In(s,2,i)),y=P.sub(_.mul(p).mul(2)).sub(g.mul(f)).divide(c);r[3].assign(y),3!==n&&e.throwInternalErrorException("")}(a,m,i,r,h);for(let t=0;t<=i;t++)o[t].setCoords(h[t].x,h[t].y)}function Sn(t,s,i,r){if(0===i){if(r<=.5){const e=new n.Point2D;n.lerpPointLo(2,t[0].mul(s[0]),t[1].mul(s[1]),r,e);const i=new n.Point2D;n.lerpPointLo(2,t[1].mul(s[1]),t[2].mul(s[2]),r,i);const o=new n.Point2D;return n.lerpPointLo(2,e,i,r,o),o}{const e=new n.Point2D;n.lerpPointHi(2,t[0].mul(s[0]),t[1].mul(s[1]),r,e);const i=new n.Point2D;n.lerpPointHi(2,t[1].mul(s[1]),t[2].mul(s[2]),r,i);const o=new n.Point2D;return n.lerpPointHi(2,e,i,r,o),o}}if(1===i){const e=t[1].mul(s[1]),n=e.sub(t[0].mul(s[0])).mul(1-r).add(t[2].mul(s[2]).sub(e).mul(r));return n.mulThis(2),n}if(2===i){const e=t[1].mul(s[1]),n=t[2].mul(s[2]).sub(e).sub(e.sub(t[0].mul(s[0])));return n.mulThis(2),n}e.throwInternalErrorException("")}function Tn(t,e,s,i){if(i.toDouble()<=.5){const s=new f;n.lerpLoPointE(2,t[0].mulE(e[0]),t[1].mulE(e[1]),i,s);const r=new f;n.lerpLoPointE(2,t[1].mulE(e[1]),t[2].mulE(e[2]),i,r);const o=new f;return n.lerpLoPointE(2,s,r,i,o),o}{const s=new f;n.lerpHiPointE(2,t[0].mulE(e[0]),t[1].mulE(e[1]),i,s);const r=new f;n.lerpHiPointE(2,t[1].mulE(e[1]),t[2].mulE(e[2]),i,r);const o=new f;return n.lerpHiPointE(2,s,r,i,o),o}}function In(t,s,i){if(0===s){const e=n.lerp(t[0],t[1],i),s=n.lerp(t[1],t[2],i);return n.lerp(e,s,i)}return 1===s?2*((1-i)*(t[1]-t[0])+(t[2]-t[1])*i):2===s?2*(t[2]-t[1]-(t[1]-t[0])):void e.throwInternalErrorException("")}function Mn(t,e,s){const i=n.snap(s,0,1),r=n.makeObjectArray(n.Point2D,4);if(wn(t,e,3,i,r),r[1].isZero()){if(r[2].isZero())return r[3];{const t=r[2].clone();return 1===i&&t.negateThis(),t}}return r[1]}class Nn{constructor(t,e){this.len=0,this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-bn(this.b,e,!1):0}getError(t){return e.geometryReleaseAssert(0),0}}function qn(t){const s=n.makeObjectArray(n.Point2D,3),i=[0,0,0];return t.queryControlPoints(s),t.queryWeights(i),function(t,s){const i=oi(s);if(1===i)return Ae(t);if(0===i)return 0;const r=[new n.Point2D(0,0),t[1].sub(t[0]),t[2].sub(t[0])],o=r[1].crossProduct(r[2]);if(i<1){e.geometryReleaseAssert(i>0);const t=1-i;let s;if(t<.01)s=-1/3+t*(2/15+t*(3/35+t*(16/315+t*(20/693+t*(16/1001+t*(56/6435))))));else{const e=t*(1+i),r=Math.atan2(Math.sqrt(t),Math.sqrt(1+i));s=i*(.5*i-n.rsqrt(e)*r)/e}return o*s}{const t=(i-1)*(i+1);return.25*i/Math.pow(t,1.5)*(-2*i*Math.sqrt(t)*o-4*r[1].y*r[2].x*Math.atanh(Math.sqrt((i-1)/(i+1)))-r[1].x*r[2].y*Math.log(2*i*(i-Math.sqrt(t))-1))}}(s,i)}function Yn(t){var e;return e=t.calculateUpperLength2D(),256*n.doubleEps()*e}function Xn(t){return t.m_cachedValues}function Rn(t,e){t.m_cachedValues=e}function Fn(t,e,s,i,r){const o=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(o);const a=[0,0,0];t.queryWeights(a);const m=[0];return 1===Vn(o,a,e,n.Envelope1D.unit(),i,r,1,m)?m[0]:Number.NaN}function Vn(t,i,r,o,a,m,h,u){e.checkAndThrow(n.Envelope1D.unit().contains(o)&&h>0,""),(m<0||Number.isNaN(m))&&(m=Number.MAX_VALUE);const l=new Array(3);for(let e=0;e<3;++e)l[e]=t[e].sub(r);const c=oi(i),g=x.constructPoint2D(l[0]),d=x.constructPoint2D(l[1]),p=x.constructPoint2D(l[2]),_=n.MPValue.constructDouble(c),P=_.clone();P.ldexpThis(1);const f=g.dotProduct(d.sub(g)).mul(_),y=_.mul(_.addDouble(2)),D=p.sub(d.mul(y.ldexp(1))),v=d.sqrLength().mul(_.mul(_).ldexp(1)).add(g.sqrLength().mul(_.ldexp(2).subDouble(1))).add(g.dotProduct(D)),E=p.sub(d.mul(P)).add(g.mul(P.subDouble(1))),C=d.mul(_).sub(g).dotProduct(E).mulDouble(3),b=d.dotProduct(p).mul(_.subDouble(3).mul(_)).ldexp(1),A=d.sqrLength().mul(_.mul(_).ldexp(2)),w=g.sqrLength().mul(_.ldexp(2).subDouble(3)),S=g.dotProduct(p.sub(d.mul(_.mulDouble(3).subDouble(1)).mul(_))).ldexp(1),T=p.sqrLength().addThis(b).addThis(A).addThis(w).addThis(S),I=g.add(p).sub(d.mul(P)),M=_.subDouble(1),N=p.sub(g).dotProduct(I).mul(M),q=new n.Point2D(0,0),Y=[];let X=new n.Point2D;ii(l,i,o.vmin,X);let R=n.Point2D.distance(X,q);if(R<=m&&Y.push(new n.Point2D(o.vmin,R)),o.vmin!==o.vmax&&(ii(l,i,o.vmax,X),R=n.Point2D.distance(X,q),R<=m&&Y.push(new n.Point2D(o.vmax,R))),o.width()>0){const t=l[2].isZero(),e=n.makeObjectArray(n.MPValue,4),s=Kt(N,T,C,v,f,58,o,t,e);for(let t=0;t<s;t++){if(!o.containsExclusiveCoordinate(e[t].toDouble()))continue;let s=e[t].toDouble();s=ai(i,s);const r=new n.Point2D;ii(l,i,s,r),R=n.Point2D.distance(r,q),R<=m&&Y.push(new n.Point2D(s,R))}}if(a){e.geometryReleaseAssert(o.equals(n.Envelope1D.unit()));{ii(l,i,-1,X,!0);const t=new n.Point2D;ii(l,i,0,t);const e=new Nr({start:X,end:t}),s=e.getClosestCoordinate(q,!0);s<1&&(X=e.getCoord2D(s),R=n.Point2D.distance(X,q),R<=m&&Y.push(new n.Point2D(s-1,R)))}{ii(l,i,2,X,!0);const t=new n.Point2D;ii(l,i,o.vmax,t);const e=new Nr({start:t,end:X}),s=e.getClosestCoordinate(q,!0);s>0&&(X=e.getCoord2D(s),R=n.Point2D.distance(X,q),R<=m&&Y.push(new n.Point2D(1+s,R)))}}if(!Y.length)return 0;Y.sort((t,e)=>t.compare(e));let F=0;const V=Y[0].x;if(u[F++]=V,F<h){const t=s.calculateToleranceFromPointsForOps(l,4,!1).total(),e=Y[0].y;for(let s=1,n=Y.length;s<n;s++)if(Y[s].y>e+t){Y.length=s;break}Y.sort((t,e)=>n.standardNumericCompare(t.x,e.x)),F=0,u[F++]=Y[0].x;for(let t=1,e=Y.length;t<e;t++)Y[t].x!==u[F-1]&&F<h&&(u[F++]=Y[t].x)}return F}function kn(t,e,s){const i=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(i);const r=[0,0,0];t.queryWeights(r),Ln(i,r,e,s)}function Ln(t,e,s,i){if(s.equalsRange(0,1))return void i.setFromPoints(t,3);const r=n.makeObjectArray(n.Point2D,3);Bn(t,e,s.vmin,s.vmax,r,[0,0,0]),i.setFromPoints(r,3)}function zn(t){const e=n.compareNoNANs(t[0].y,t[1].y),s=n.compareNoNANs(t[1].y,t[2].y);if(e>=0&&s>=0||e<=0&&s<=0){const e=n.compareNoNANs(t[0].x,t[1].x),s=n.compareNoNANs(t[1].x,t[2].x);if(e>=0&&s>=0||e<=0&&s<=0)return!0}return!1}function Gn(t){const e=n.makeObjectArray(n.Point2D,3);t.queryControlPoints(e);const s=On(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function On(t){let e=!1;for(let s=0;s<2;s++){const i=n.compareNoNANs(t[0][s],t[2][s]);i>0?(n.compareNoNANs(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),n.compareNoNANs(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):i<0?(n.compareNoNANs(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),n.compareNoNANs(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function jn(t,i,r,o,a,m,h){e.geometryReleaseAssert(r>=0&&r<=1&&o!==m&&a!==h),e.geometryReleaseAssert(i[0]>0&&i[2]>0&&i[1]>=0);const u=[1,oi(i),1],l=mi(i,r),c=n.cloneObjectArray(t,3),g=n.makeObjectArray(s.Point3D,3);ei(c,u,g);const d=n.makeObjectArray(s.Point3D,3),p=n.makeObjectArray(s.Point3D,3);hi(g,l,o?d:null,m?p:null),ui(i,r,a,h);const _=zn(c);if(o){for(let t=0;t<3;++t)ni(d[t],o[t]);ci(c,o),_&&On(o)}if(m){for(let t=0;t<3;++t)ni(p[t],m[t]);ci(c,m),_&&On(m)}}function Bn(t,i,r,o,a,m){if(e.geometryReleaseAssert(r>=0&&o<=1&&r<=o),r===o){const e=new n.Point2D,s=si(t,i,r,e);return li(t,e),a[0].assign(e),a[1].assign(e),a[2].assign(e),m[0]=s,m[1]=s,void(m[2]=s)}if(0===r&&1===o)return a[0].assign(t[0]),a[1].assign(t[1]),a[2].assign(t[2]),m[0]=i[0],m[1]=i[1],void(m[2]=i[2]);const h=n.makeObjectArray(s.Point3D,3);{const e=[1,oi(i),1],s=mi(i,r),n=mi(i,o);ei(t,e,h),hi(h,n,h,null),hi(h,s>=n?1:s/n,null,h)}const u=[0,0,0];ui(i,o,u,null),ui(u,r/o,null,u);const l=zn(t),c=n.makeObjectArray(n.Point2D,3);ni(h[1],c[1]),ii(t,i,r,c[0]),ii(t,i,o,c[2]),ci(t,c);for(let t=0;t<3;++t)a[t].assign(c[t]),m[t]=u[t];l&&On(a)}function Wn(t,e,s){const i=oi(e),r=[1,i,1],o=4*i/(3*(1+i));s[0].assign(t[0]),s[3].assign(t[2]),n.lerpPoint2D(t[0],t[1],o,s[1]),n.lerpPoint2D(t[2],t[1],o,s[2]),new pn({cp:s}),new zt({points:t,weight:i});let a=0,m=.1,h=0;for(let e=0;e<9;e++,m+=.1){const e=new n.Point2D;ii(t,r,m,e);const i=new n.Point2D;zs(s,m,i);const o=n.Point2D.sqrDistance(e,i);o>a&&(a=o,h=m)}{const e=new n.Point2D;ii(t,r,h,e);const i=[0];sn(s,e,n.Envelope1D.unit(),!1,-1,1,i);const o=new n.Point2D;return zs(s,i[0],o),a=n.Point2D.sqrDistance(e,o),Math.sqrt(a)}}function Hn(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==Qn(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function Zn(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==$n(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Un(t,e,s,n,i){if(i){if(0!==br(e,s))return t?4:2}else if(E(e,s))return 1;return 0!==Jn(t,e,s,null,null,null,n,i??!1,0,!1)?4:0}function Qn(t,s,i,r,o,a,m,h,u,l){if(null!==o&&(o.length=0),null!==a&&(a.length=0),null!==r&&(r.length=0),i.isDegenerate(0)){const t=[0,0],e=s.intersectPoint(i.getStartXY(),t,m);if(e>0){if(null!==o)for(let s=0;s<e;s++)o.push(t[s]);if(null!=a)for(let t=0;t<e;t++)a.push(0);if(null!=r)for(let i=0;i<e;i++){const e=new n.Point2D;s.queryCoord2D(t[i],e),r.push(e)}}return e}const c=k(s,i);if(m=Math.max(m,c),s.isDegenerateToLineHelper(c)){const t=new Nr({start:s.getStartXY(),end:s.getEndXY()}),e=st(t,i,r,o,a,m,h,l);if(o)for(let n=0;n<e;++n){const e=t.getCoord2D(o[n]);o[n]=s.getClosestCoordinate(e,!1)}return e}if(L(s,i,m))return 0;const g=n.makeObjectArray(n.Point2D,3);s.queryControlPoints(g);const d=[0,0,0];s.queryWeights(d);const p=[1,oi(d),1],_=i.getEndXY().sub(i.getStartXY()),P=_.clone();P.leftPerpendicularThis();const f=g[0].clone(),y=g[1].clone(),x=g[2].clone(),D=y.sub(f),v=x.sub(f),E=x.sub(y),C=p[0],b=p[1],A=p[2],w=C*b,S=C*A,T=b*A,I=D.dotProduct(P)*w,M=v.dotProduct(P)*S;let N=I,q=M-2*I,Y=E.dotProduct(P)*T+M-M;const X=n.makePrimitiveArray(13,Number.NaN),R=n.makePrimitiveArray(13,Number.NaN);let F=Ct(Y,q,N,n.Envelope1D.unit(),!1,X);F<0&&(X[0]=0,X[1]=1,F=2);let V=0;for(let t=0,e=V;t<F;++t){const s=new n.Point2D;ii(g,p,X[t+e],s),R[V]=i.getClosestCoordinate(s,!1),n.Point2D.distance(s,i.getCoord2D(R[V]))<=m&&(X[V]=X[t+e],V++)}const z=n.makeObjectArray(n.Point2D,3),G=n.makeObjectArray(n.Point2D,3);if(s.queryControlPoints(G),G[0].subThis(i.getStartXY()),G[1].subThis(i.getStartXY()),G[2].subThis(i.getStartXY()),function(t,e,s,i=!1){const r=n.makeObjectArray(n.Point2D,3);i?(r[0].setCoordsPoint2D(t[0]),r[1].setCoordsPoint2D(t[1]),r[1].subThis(r[0]),r[2].setCoordsPoint2D(t[2]),r[2].subThis(r[0]),r[0].setCoords(0,0)):(r[0].setCoordsPoint2D(t[0]),r[1].setCoordsPoint2D(t[1]),r[2].setCoordsPoint2D(t[2])),r[0].mulThis(e[0]),r[1].mulThis(e[1]),r[2].mulThis(e[2]),s[1].setCoords(r[1].x-r[0].x,r[1].y-r[0].y),s[2].setCoordsPoint2D(r[2].sub(r[1])),s[2].subThis(s[1]),s[1].x*=2,s[1].y*=2,s[0].setCoordsPoint2D(r[0])}(G,p,z,!1),Math.abs(_.x)>=Math.abs(_.y)){const t=_.y/_.x;Y=z[2].y-z[2].x*t,q=z[1].y-z[1].x*t,N=z[0].y-z[0].x*t}else{const t=_.x/_.y;Y=z[2].x-z[2].y*t,q=z[1].x-z[1].y*t,N=z[0].x-z[0].y*t}const O=s.getEndXY().equals(i.getStartXY())||s.getEndXY().equals(i.getEndXY()),j=[0,0];F=Ct(Y,q,N,n.Envelope1D.unit(),O,j);for(let t=0,e=V;t<F;++t){X[t+e]=j[t];const s=new n.Point2D;ii(g,p,X[t+e],s),R[V]=i.getClosestCoordinate(s,!1),n.Point2D.distance(s,i.getCoord2D(R[V]))<=m&&(X[V]=X[t+e],V++)}e.geometryReleaseAssert(V<X.length+4);for(let t=0;t<V;t++)X[t]=ai(d,X[t]);F=s.intersectPoint(i.getStartXY(),j,m);for(let t=0;t<F;t++)X[V]=j[t],R[V++]=0;F=s.intersectPoint(i.getEndXY(),j,m);for(let t=0;t<F;t++)X[V]=j[t],R[V++]=1;F=i.intersectPoint(s.getStartXY(),j,m);for(let t=0;t<F;t++)R[V]=j[t],X[V++]=0;F=i.intersectPoint(s.getEndXY(),j,m);for(let t=0;t<F;t++)R[V]=j[t],X[V++]=1;return 0===V?0:Tr(t,s,i,X,R,V,r,o,a,m,h,0,l)}function $n(t,e,s,i,o,a,m,h,u,l){if($i(s))return Qn(t,e,new Nr({start:s.getStartXY(),end:s.getEndXY()}),i,o,a,m,h,0,l);const c=k(e,s);if(L(e,s,m=Math.max(m,c)))return 0;const g=[],d=[],p=n.makeObjectArray(n.Point2D,4);{e.queryControlPoints(p);const t=n.makeObjectArray(n.Point2D,4),i=new r.Transformation2D;s.canonicToWorldTransformation(i);const o=new r.Transformation2D;o.setInvert(i),o.transformPoints2D(p,4,t);const a=n.makeObjectArray(n.MPValue,3),u=n.makeObjectArray(n.MPValue,3),l=n.makeObjectArray(n.MPValue,3),c=[0,0,0];e.queryWeights(c),ti(t,c,a,u,l);const _=n.makeObjectArray(n.MPValue,3);_[0].setDouble(s.getSemiMinorAxis()),_[0].sqrThis(),_[1].setDouble(s.getSemiMajorAxis()),_[1].sqrThis(),_[2].setThis(_[0]),_[2].mulThis(_[1]),_[2].negateThis();const P=Zt(a,2,u,2,l,2,_,0,n.Envelope1D.unit(),n.Envelope1D.unit(),g,h);if(P>0){let t=0;for(let i=0;i<P;i++){const r=new n.Point2D;e.queryCoord2D(g[i],r);const o=s.getClosestCoordinate(r,!1),a=new n.Point2D;s.queryCoord2D(o,a),n.Point2D.distance(r,a)<=m&&(g[t]=g[i],d.push(o),t++)}g.length=t}}const _=[0,1];for(let t=0;t<2;t++){const i=0===t?s.getStartXY():s.getEndXY(),r=Fn(e,i,n.Envelope1D.unit(),!1,-1),o=new n.Point2D;e.queryCoord2D(r,o),n.Point2D.distance(i,o)<=m&&(g.push(r),d.push(_[t]))}for(let t=0;t<2;t++){const e=[0,3];{const i=s.getClosestCoordinate(p[e[t]],!1),r=new n.Point2D;s.queryCoord2D(i,r),n.Point2D.distance(p[e[t]],r)<=m&&(g.push(_[t]),d.push(i))}}return Tr(t,e,s,g,d,g.length,i,o,a,m,h,0,l)}function Kn(t,s,i,r,o,a,m,h,u,l){const c=n.makeObjectArray(n.Point2D,3);s.queryControlPoints(c);const g=n.makeObjectArray(n.Point2D,3);if(i.queryControlPoints(g),z(c,g,3)<0)return Kn(t,i,s,r,a,o,m,h,u,!l);const p=k(s,i);if(s.isDegenerateToLineHelper(p)){const e=new Nr({start:s.getStartXY(),end:s.getEndXY()}),n=Qn(t,i,e,r,a,o,m,h,0,!l);if(o)for(let t=0;t<n;++t){const n=e.getCoord2D(o[t]);o[t]=s.getClosestCoordinate(n,!1)}return n}if(i.isDegenerateToLineHelper(p)){const e=new Nr({start:i.getStartXY(),end:i.getEndXY()}),n=Qn(t,s,e,r,o,a,m,h,0,l);if(a)for(let t=0;t<n;++t){const s=e.getCoord2D(a[t]);a[t]=i.getClosestCoordinate(s,!1)}return n}if(L(s,i,m=Math.max(m,p)))return 0;const _=n.makePrimitiveArray(3,Number.NaN);s.queryWeights(_);const P=n.makePrimitiveArray(3,Number.NaN);i.queryWeights(P);const f=[1,oi(_),1],y=[1,oi(P),1],x=new n.Envelope1D(0,1),D=new n.Envelope1D(0,1);{const t=d.constructEmpty();Ln(c,f,new n.Envelope1D(0,1),t);const e=d.constructEmpty();Ln(g,y,new n.Envelope1D(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*m),e.inflate(3*m),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(ri(c,f,t,x),ri(g,y,t,D),x.isEmpty()||D.isEmpty())return 0;Bn(c,f,x.vmin,x.vmax,c,f),Bn(g,y,D.vmin,D.vmax,g,y)}}const v=Ir(c,2,g,2,m);if(0===v)return 0;const E=[],C=[];if(-1===v){const t=n.makeObjectArray(n.MPValue,3),e=n.makeObjectArray(n.MPValue,3),s=n.makeObjectArray(n.MPValue,3);ti(c,f,t,e,s);const i=n.makeObjectArray(n.MPValue,3),r=n.makeObjectArray(n.MPValue,3),o=n.makeObjectArray(n.MPValue,3);ti(g,y,i,r,o);const a=[],u=[],d=Ht(t,2,e,2,s,2,i,2,r,2,o,2,0,n.Envelope1D.unit(),n.Envelope1D.unit(),a,u,h,0,l);if(d>0)for(let t=0;t<d;t++){const e=new n.Point2D;ii(g,y,u[t],e);const s=new n.Point2D;ii(c,f,a[t],s),n.Point2D.distance(s,e)<=m&&(E.push(a[t]),C.push(u[t]))}}for(let t=0;t<2;t++){let s,i,r;0===t?(s=c,i=g,r=y):(s=g,i=c,r=f);for(let o=0;o<2;o++){const a=0===o?0:s.length-1,h=new n.Point2D,u=[0],l=Vn(i,r,s[a],n.Envelope1D.unit(),!1,-1,1,u);e.geometryReleaseAssert(1===l),ii(i,r,u[0],h),n.Point2D.distance(s[a],h)<=m&&(0===t?(E.push(0===a?0:1),C.push(u[0])):(C.push(0===a?0:1),E.push(u[0])))}}if(0===E.length)return 0;if(!x.equalsRange(0,1))for(let t=0;t<E.length;++t)E[t]=zt.recalculateParentT(x.vmin,x.vmax,E[t]);if(!D.equalsRange(0,1))for(let t=0;t<C.length;++t)C[t]=zt.recalculateParentT(D.vmin,D.vmax,C[t]);for(let t=0;t<E.length;++t)E[t]=ai(_,E[t]);for(let t=0;t<C.length;++t)C[t]=ai(P,C[t]);return Tr(t,s,i,E,C,E.length,r,o,a,m,h,0,l)}function Jn(t,e,s,i,r,o,a,m,h,u){if(e.isLine())return ke(t,s,new Nr({start:e.getStartXY(),end:e.getEndXY()}),i,o,r,a,m,0,!u);if(s.isLine())return Qn(t,e,new Nr({start:s.getStartXY(),end:s.getEndXY()}),i,r,o,a,m,0,u);const l=k(e,s);if(L(e,s,a=Math.max(a,l)))return 0;const c=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(c);const g=n.makeObjectArray(n.Point2D,3);s.queryControlPoints(g);const d=Ir(c,2,g,2,a);if(0===d)return 0;const p=[],_=[];if(-1===d){const t=n.makeObjectArray(n.MPValue,3),i=n.makeObjectArray(n.MPValue,3),r=n.makeObjectArray(n.MPValue,3),o=[0,0,0];e.queryWeights(o),ti(c,o,t,i,r);const h=n.makeObjectArray(x,3);Oe(g,h);const l=Ht(t,2,i,2,r,2,[h[0].x,h[1].x,h[2].x],2,[h[0].y,h[1].y,h[2].y],2,null,0,0,n.Envelope1D.unit(),n.Envelope1D.unit(),p,_,m,0,u);if(l>0){let t=0;for(let i=0;i<l;i++){const r=new n.Point2D;s.queryCoord2D(_[i],r);const o=new n.Point2D;e.queryCoord2D(p[i],o),n.Point2D.distance(o,r)<=a&&(p[t]=p[i],_[t]=_[i],t++)}p.length=t,_.length=t}}for(let t=0;t<2;t++){let i;i=0===t?c:g;for(let r=0;r<2;r++){const o=0===r?0:i.length-1;let m;const h=new n.Point2D;0===t?(m=Te(s,i[o],n.Envelope1D.unit(),!1),s.queryCoord2D(m,h)):(m=Fn(e,i[o],n.Envelope1D.unit(),!1,-1),e.queryCoord2D(m,h)),n.Point2D.distance(i[o],h)<=a&&(0===t?(p.push(0===o?0:1),_.push(m)):(_.push(0===o?0:1),p.push(m)))}}return Tr(t,e,s,p,_,p.length,i,r,o,a,m,0,u)}function ti(t,e,s,i,r){const o=n.MPValue.constructDouble(e[0]),a=n.MPValue.constructDouble(e[1]),m=n.MPValue.constructDouble(e[2]);s[0].setDouble(t[0].x),s[0].mulThis(o),s[1].setDouble(t[1].x),s[1].mulThis(a),s[2].setDouble(t[2].x),s[2].mulThis(m),s[2].subThis(s[1]),s[1].subThis(s[0]),s[2].subThis(s[1]),s[1].ldexpThis(1),i[0].setDouble(t[0].y),i[0].mulThis(o),i[1].setDouble(t[1].y),i[1].mulThis(a),i[2].setDouble(t[2].y),i[2].mulThis(m),i[2].subThis(i[1]),i[1].subThis(i[0]),i[2].subThis(i[1]),i[1].ldexpThis(1),r[0].setDouble(e[0]),r[1].setDouble(e[1]),r[2].setThis(r[1]),r[2].ldexpThis(1),r[2].negateThis(),r[2].addThis(r[0]),r[2].addDoubleThis(e[2]),r[1].subThis(r[0]),r[1].ldexpThis(1)}function ei(t,e,s){for(let n=0;n<3;++n)s[n].setCoordsPoint2DZ(t[n].mul(e[n]),e[n])}function si(t,e,s,i){if(0===s)return i.assign(t[0]),e[0];if(1===s)return i.assign(t[2]),e[2];const r=[t[0].x*e[0],t[1].x*e[1],t[2].x*e[2]],o=[t[0].y*e[0],t[1].y*e[1],t[2].y*e[2]],a=[e[0],e[1],e[2]],m=s;let h,u,l;if(s<=.5){const t=n.lerpLo(r[0],r[1],m),e=n.lerpLo(r[1],r[2],m);h=n.lerp(t,e,m);const s=n.lerpLo(o[0],o[1],m),i=n.lerpLo(o[1],o[2],m);u=n.lerp(s,i,m);const c=n.lerpLo(a[0],a[1],m),g=n.lerpLo(a[1],a[2],m);l=n.lerpLo(c,g,m)}else{const t=n.lerpHi(r[0],r[1],m),e=n.lerpHi(r[1],r[2],m);h=n.lerpHi(t,e,m);const s=n.lerpHi(o[0],o[1],m),i=n.lerpHi(o[1],o[2],m);u=n.lerpHi(s,i,m);const c=n.lerpHi(a[0],a[1],m),g=n.lerpHi(a[1],a[2],m);l=n.lerpHi(c,g,m)}return h/=l,u/=l,i.setCoords(h,u),li(t,i),l}function ni(t,e){return e.setCoords(t.x/t.z,t.y/t.z),t.z}function ii(t,e,s,n,i){if(i){if(s<0)return void Z(new Nr({start:t[0],end:t[0].add(Mn(t,e,0).getUnitVector())}),s,n);if(s>1)return void Z(new Nr({start:t[2],end:t[2].add(Mn(t,e,1).getUnitVector())}),s-1,n)}si(t,e,s,n)}function ri(t,e,s,i){i.setEmpty();const r=[];r.push(new n.Envelope1D(0,1));const o=.5*Math.max(s.width(),s.height());for(;r.length;){const a=r.at(-1);r.pop();const m=new d;if(Ln(t,e,a,m),m.isIntersectingW(s)){const t=Math.max(m.width(),m.height());if(s.containsW(m)||t<=o||a.width()<1e-12)i.merge(a);else{const t=a.getCenter();r.push(n.Envelope1D.construct(a.vmin,t)),r.push(n.Envelope1D.construct(t,a.vmax))}}}}function oi(t){return t[1]/Math.sqrt(t[0]*t[2])}function ai(t,e){const s=Math.sqrt(t[2]/t[0]);return e/n.lerp(s,1,e)}function mi(t,e){const s=Math.sqrt(t[0]/t[2]);return e/n.lerp(s,1,e)}function hi(t,i,r,o){e.geometryReleaseAssert(i>=0&&i<=1),(new s.Point3D).setCoordsPoint3D(t[0]),(new s.Point3D).setCoordsPoint3D(t[1]),(new s.Point3D).setCoordsPoint3D(t[2]);const a=new s.Point3D,m=new s.Point3D,h=new s.Point3D;n.lerpPoint(3,t[0],t[1],i,a),n.lerpPoint(3,t[1],t[2],i,m),n.lerpPoint(3,a,m,i,h);const u=t[2].clone();r&&(r[0].assign(t[0]),r[1].assign(a),r[2].assign(h)),o&&(o[0].assign(h),o[1].assign(m),o[2].assign(u))}function ui(t,s,i,r){const o=[t[0],t[1],t[2]];e.geometryReleaseAssert(s>=0&&s<=1&&i!==r);const a=n.lerp(o[0],o[1],s),m=n.lerp(o[1],o[2],s),h=n.lerp(a,m,s);i&&(i[0]=o[0],i[1]=a,i[2]=h),r&&(r[0]=h,r[1]=m,r[2]=o[2])}function li(t,e){const s=n.Envelope1D.constructEmpty();s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e.x=n.snap(e.x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e.y=n.snap(e.y,s.vmin,s.vmax)}function ci(t,e){const s=new n.Envelope1D;s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e[0].x=n.snap(e[0].x,s.vmin,s.vmax),e[1].x=n.snap(e[1].x,s.vmin,s.vmax),e[2].x=n.snap(e[2].x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e[0].y=n.snap(e[0].y,s.vmin,s.vmax),e[1].y=n.snap(e[1].y,s.vmin,s.vmax),e[2].y=n.snap(e[2].y,s.vmin,s.vmax)}const gi=n.geometryPi/180,di=180/n.geometryPi;function pi(t){let e=t;return e=function(t){let e=t;return e>=-360&&e<720?(e<0?e+=360:e>=360&&(e-=360),e):(e=n.fmod(e,360),e<0&&(e+=360),e)}(e),e>180&&(e-=360),e}function _i(t){return t*gi}function Pi(t){return t*di}function fi(t){const e=n.twoPi();let s=t;return s>=-e&&s<2*e?(s<0&&(s+=e),s>=e&&(s-=e),s):(s=n.fmod(s,e),s<0&&(s+=e),s)}function yi(t){const e=n.pi();let s=t;return s>-e&&s<=e||(s=fi(s),s>e&&(s-=n.twoPi())),s}var xi=s.VertexDescription;class Di extends W{constructor(t){if(void 0===t||n.isOnlyProperty(t,"vd"))return super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new n.Point2D(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new n.Point2D(0,0),void(this.m_bits=0);if(t.copy)return super(t),void(this!==t.copy&&(this.m_center=new n.Point2D(0,0),this.m_interior=new n.Point2D(0,0),t.copy.copyToImpl(this)));if(t.move)super(t),this.m_semiMajorAxis=t.move.m_semiMajorAxis,this.m_minorMajorRatio=t.move.m_minorMajorRatio,this.m_rotation=t.move.m_rotation,this.m_cosr=t.move.m_cosr,this.m_sinr=t.move.m_sinr,this.m_center=t.move.m_center.clone(),this.m_sweepAngle=t.move.m_sweepAngle,this.m_startAngle=t.move.m_startAngle,this.m_interior=t.move.m_interior.clone(),this.m_bits=t.move.m_bits,this.m_cachedValues=t.move.m_cachedValues,t.move.m_cachedValues=null;else{if(t.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new n.Point2D(0,0),this.m_interior=new n.Point2D(0,0),void this.constructCircularArcThreePoint(t.fromPoint,t.toPoint,t.interiorPoint);if(t.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new n.Point2D(0,0),this.m_interior=new n.Point2D(0,0),void this.constructCircleRadius(t.radius,t.center,t.bIsCounterClockwise);if(t.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(t.fromPoint,t.toPoint,t.semiMajorAxis,t.minorMajorRatio,t.axisXRotationRad,t.bBigArc,t.bIsCounterClockwise)}}getBoundary(){return Dt(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}constructCircleRadius(t,e,s=!1){return this.constructEllipse(t,1,e,0,s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(t,e,s=!1){const i=n.Point2D.distance(t,e);return this.constructEllipticArcEndPointsCenter(e,e,i,1,0,!0,s,t),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(t,e,s=!1){const i=n.Point2D.lerp(t,e,.5);return this.constructCircleCenterAndPoint(i,t,s),this}constructLineEllipticArc(t,e){return Qi(this,t,e,1),this}constructLineCircularArc(t,e){return Qi(this,t,e,0),this}constructEllipse(t,e,s,i,r=!1){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const o=new n.Point2D(0,this.m_minorMajorRatio*this.m_semiMajorAxis),a=Math.cos(i),m=Math.sin(i);return o.rotateDirect(a,m),o.addThis(s),this.constructEllipticArcEndPointsCenter(o,o,this.m_semiMajorAxis,this.m_minorMajorRatio,i,!0,r,s),this}inflate(t){if(this.isDegenerateToLine())return;let e=this.getSemiMinorAxis()+t;if(e=e<=0?0:(this.getSemiMajorAxis()+t)/this.getSemiMajorAxis(),this.isCircular()){const t=new r.Transformation2D;t.setShiftCoords(-this.m_center.x,-this.m_center.y),t.scale(e,e),t.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(t)}else{const t=new r.Transformation2D;this.canonicToWorldTransformation(t);const s=t.clone();s.invertPreciseThis(),s.scale(e,e),s.multiply(t),this.applyTransformation(s)}}constructEnclosingCircle(t,s,i=!1){return function(t,s,i,r){0===i&&e.throwInvalidArgumentException("construct_enclosing_circle");const o=[0,0,0],a=vi(s,i,o);if(1===a)t.constructCircleRadius(0,s[o[0]],r);else if(2===a){const e=n.Point2D.lerp(s[o[0]],s[o[1]],.5),i=n.Point2D.distance(s[o[0]],e),a=n.Point2D.distance(s[o[1]],e);t.constructCircleRadius(Math.max(i,a),e,r)}else if(3===a){const e=n.Point2D.calculateCircleCenterFromThreePoints(s[o[0]],s[o[1]],s[o[2]]),i=n.Point2D.distance(s[o[0]],e),a=n.Point2D.distance(s[o[1]],e),m=n.Point2D.distance(s[o[2]],e);t.constructCircleRadius(Math.max(i,a,m),e,r)}else e.throwInternalErrorException("unexpected")}(this,t,s,i),this}constructThreePointCircle(t,e,s,i=!1){if(t.equals(e)||e.equals(s)||t.equals(s)){const n=t.clone(),r=e.clone(),o=s.clone();return n.equals(r)&&r.assign(o),this.constructTwoPointCircle(n,r,i)}{const r=n.Point2D.calculateCircleCenterFromThreePoints(t,e,s);if(!r.isFinite()||!Number.isFinite(n.Point2D.distance(t,r))){const i=n.Point2D.distance(t,e),r=n.Point2D.distance(t,s);this.constructLineCircularArc(t,i>=r?e:s)}return this.constructCircleCenterAndPoint(r,t,i)}}constructCircularArcThreePoint(t,e,s){const i=new n.ECoordinate(t.x),r=new n.ECoordinate(e.x),o=new n.ECoordinate(s.x),a=new n.ECoordinate(t.y),m=new n.ECoordinate(e.y),h=new n.ECoordinate(s.y),u=new n.ECoordinate(.5),l=r.subE(i),c=m.subE(a),g=o.subE(i),d=h.subE(a),p=l.mulE(d).subThisE(c.mulE(g));if(p.scaleError(10),p.isZero()){if(!l.isZero()||!c.isZero())return Qi(this,t,e,0),this;{const n=t.clone().addThis(e).mulThis(.5).addThis(s).mulThis(.5),i=s.sub(n).length();this.constructEllipticArcEndPointsCenter(t,e,i,1,0,!0,!1,n),this.m_interior.assign(s)}return this.setProjectionBehavior(0),this}const _=l.sqr().addThisE(c.sqr()).mulThisE(u),P=g.sqr().addThisE(d.sqr()).mulThisE(u),f=_.mulE(d).subThisE(P.mulE(c)),y=l.mulE(P).subThisE(g.mulE(_));f.divThisE(p),y.divThisE(p);const x=f.sqr().addThisE(y.sqr());x.sqrtThis();const D=f.addE(i),v=y.addE(a);let E=t.x-D.value(),C=t.y-v.value();const b=Math.atan2(C,E);E=e.x-D.value(),C=e.y-v.value();const A=Math.atan2(C,E);E=s.x-D.value(),C=s.y-v.value();const w=Math.atan2(C,E);let S=w-2*n.pi();for(;S<b;)S+=2*n.pi();let T=A-2*n.pi();for(;T<S;)T+=2*n.pi();let I=w+2*n.pi();for(;I>b;)I-=2*n.pi();let M,N=A+2*n.pi();for(;N>I;)N-=2*n.pi();M=T-b<b-N?T-b:N-b;const q=new n.Point2D(D.value(),v.value());return this.constructEllipticArcEndPointsCenter(t,e,x.value(),1,0,Math.abs(M)>n.pi(),M>0,q),this.m_interior.assign(s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(t,e,s,n){return this.constructEllipticArcGeneral(t,1,e,s,n,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(t,e,s,n,i,r,o){return Ui(this,t,e,s,n,i,r,o)}constructEllipticArcEndPointsCenter(t,e,s,n,i,r,o,a){return Ui(this,t,e,s,n,i,r,o,a)}constructEllipticArcGeneral(t,e,s,i,r,o){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const a=yi(o),m=Math.cos(a),h=Math.sin(a),u=new n.Point2D(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),l=n.Point2D.getNAN(),c=yi(i);l.x=u.x*Math.cos(c),l.y=u.y*Math.sin(c),l.rotateDirect(m,h),l.addThis(s);const g=n.snapMagnitude(r,n.twoPi());let d=g;Math.abs(d)===n.twoPi()&&(d=0);const p=n.Point2D.getNAN();return p.x=u.x*Math.cos(c+d),p.y=u.y*Math.sin(c+d),p.rotateDirect(m,h),p.addThis(s),this.constructEllipticArcEndPointsCenter(l,p,this.m_semiMajorAxis,this.m_minorMajorRatio,a,Math.abs(g)>n.pi(),g>0,s)}constructEllipticArcAsNURB(t,s,n,i){return(i>=1||i<0)&&e.throwInvalidArgumentException("construct_elliptic_arc_as_NURB: weight"),s.isFinite()||e.throwInvalidArgumentException("construct_elliptic_arc_as_NURB: control_point"),cr([t,s,n],i*i,null,!1,this),this}constructCanonic(t){return this.assignCopy(t),t.isDegenerateToLine()||t.m_center.isEqual(0,0)&&0===this.m_rotation||(this.m_XStart=t.getSemiMajorAxis()*Math.cos(t.m_startAngle),this.m_YStart=t.getSemiMinorAxis()*Math.sin(t.m_startAngle),this.m_XEnd=t.getSemiMajorAxis()*Math.cos(t.getEndAngle()),this.m_YEnd=t.getSemiMinorAxis()*Math.sin(t.getEndAngle()),this.m_center.setCoords(0,0),this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,pr(this),this.afterCompletedModification(),t!==this&&F(this,t)),this}isCircular(){return 1===this.m_minorMajorRatio&&0===this.m_rotation&&!this.isDegenerateToLine()}isDegenerateToLineHelper(t){if(this.isLine())return!0;if(this.isMajor())return!1;const e=this.getEndXY().sub(this.getStartXY()).length();return!(this.calculateLength2D()-e>t)}isDegenerateToLine(){return $i(this)}getCenter(){return this.m_center.clone()}setCenter(t){if(!this.m_center.isNAN()){const e=t.sub(this.m_center);this.m_XStart+=e.x,this.m_YStart+=e.y,this.m_XEnd+=e.x,this.m_YEnd+=e.y,this.m_interior.addThis(e),this.m_center.assign(t),this.endPointModified(),this.normalizeAfterEndpointChange()}}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return n.Point2D.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!rr(this)}isMajor(){return ar(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return e.GeometryType.enumEllipticArc}queryEnvelope(t){if(4===t.m_EnvelopeType){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=i.Envelope2D.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let e=1,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e);for(let n=0,i=xi.getComponentCount(s);e<i;e++){const e=this.queryInterval(s,n);t.setIntervalEnvelope(s,n,e)}}}else 2===t.m_EnvelopeType?yr(this,n.Envelope1D.unit(),t):e.throwNotImplementedException("3d not impl")}applyTransformation(t){tr(this,t,!1,null,null)}createInstance(){return new Di}calculateLength2D(){return function(t){if($i(t))return 1*n.Point2D.distance(t.getStartXY(),t.getEndXY());if(1===t.m_minorMajorRatio)return Math.abs(-1*t.getSweepAngle())*t.m_semiMajorAxis;const e=Ki(t,0);return Ki(t,1)-e}(this)}queryControlPointsHelper(t){e.throwInternalErrorException("")}queryCoord2D(t,e){if($i(this))U(t,this.getStartXY(),this.getEndXY(),e);else if(0===t)e.assign(n.Point2D.construct(this.m_XStart,this.m_YStart));else if(1===t)e.assign(n.Point2D.construct(this.m_XEnd,this.m_YEnd));else{const s=ji(this,t),i=new n.Point2D(this.m_semiMajorAxis*Math.cos(s),this.getSemiMinorAxis()*Math.sin(s));i.rotateDirect(this.m_cosr,this.m_sinr),i.addThis(this.m_center),e.assign(i)}}queryCoord2DE(t,e){!function(t,e,s){if($i(t))K(new Nr({start:t.getStartXY(),end:t.getEndXY()}),e,s);else if(0===e.value())s.set(t.getStartXY());else if(1===e.value())s.set(t.getEndXY());else{const i=new n.ECoordinate;Bi(t,e,i);const r=new n.ECoordinate,o=new n.ECoordinate;n.ECoordinate.st_cosAndSin(i,r,o);const a=f.constructCoordsE(new n.ECoordinate(t.m_semiMajorAxis).mulThisE(r),new n.ECoordinate(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio).mulThisE(o)),m=new n.ECoordinate(t.m_rotation);n.ECoordinate.st_cosAndSin(m,r,o),a.rotateDirect(r,o),a.addThisE(f.constructPoint2D(t.m_center)),s.setE(a)}}(this,t,e)}queryCoord2DMP(t,s){e.throwNotImplementedException("")}getCoordX(t){const e=new n.Point2D;return this.queryCoord2D(t,e),e.x}getCoordY(t){const e=new n.Point2D;return this.queryCoord2D(t,e),e.y}cut(t,e,s){const n=new qr;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,i){const r=s.createEllipticArc();i&&r.dropAllAttributes();let o=0===t&&1===e;if(o&&!i)return void this.copyTo(r);const a=n.Point2D.getNAN();this.queryCoord2D(t,a);const m=n.Point2D.getNAN();if(this.queryCoord2D(e,m),!o)if(a.equals(m))e-t>.5&&this.isMajor()&&this.isClosed()?(o=!0,t=0,e=1):1===e?t=e:e=t;else if(t>0&&a.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&m.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),o=0===t&&1===e,o&&!i)return void this.copyTo(r);if(r.m_center.assign(this.m_center),r.m_semiMajorAxis=this.m_semiMajorAxis,r.m_minorMajorRatio=this.m_minorMajorRatio,r.m_interior.assign(this.m_interior),r.m_rotation=this.m_rotation,r.m_cosr=this.m_cosr,r.m_sinr=this.m_sinr,r.m_sweepAngle=this.m_sweepAngle,r.m_startAngle=this.m_startAngle,r.m_bits=this.m_bits,S(r,a.x,a.y),I(r,m.x,m.y),o)return void sr(r,Wi(this));r.m_startAngle=ji(this,t),r.m_sweepAngle=ji(this,e)-r.m_startAngle,r.m_startAngle=ki(r.m_startAngle),or(r,Math.abs(r.m_sweepAngle)>n.pi()),i&&r.assignVertexDescription(this.m_description),pr(r),Gi(r);const h=this.m_description.getAttributeCount();if(h>1&&!i){for(let e=1;e<h;e++){const s=this.m_description.getSemantics(e),n=xi.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);r.setStartAttribute(s,e,n)}}for(let t=1;t<h;t++){const s=this.m_description.getSemantics(t),n=xi.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);r.setEndAttribute(s,t,n)}}}r.afterCompletedModification()}queryDerivative(t,e){!function(t,e,s){if($i(t))s.setE(f.constructPoint2D(t.getEndXY()).subE(f.constructPoint2D(t.getStartXY())));else{const i=new n.ECoordinate;Bi(t,e,i);const r=new f;if(r.setCoordsE(new n.ECoordinate(t.m_semiMajorAxis).negate().mulE((new n.ECoordinate).setSin(i)),new n.ECoordinate(t.getSemiMinorAxis()).mulE((new n.ECoordinate).setCos(i))),t.m_rotation){const e=new n.ECoordinate(t.m_rotation);r.rotateDirect((new n.ECoordinate).setCos(e),(new n.ECoordinate).setSin(e))}r.scaleThis(new n.ECoordinate(t.getSweepAngle())),s.setE(r)}}(this,t,e)}cutArcIgnoreAttributes(t,e,s){let i=0===t&&1===e;const r=new n.Point2D;this.queryCoord2D(t,r);const o=new n.Point2D;this.queryCoord2D(e,o),i||(r.equals(o)?e-t>.5&&this.isMajor()&&this.isClosed()?(i=!0,t=0,e=1):1===e?t=e:e=t:(t>0&&r.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&o.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),i=0===t&&1===e)),s.m_center.assign(this.m_center),s.m_semiMajorAxis=this.m_semiMajorAxis,s.m_minorMajorRatio=this.m_minorMajorRatio,s.m_interior.assign(this.m_interior),s.m_rotation=this.m_rotation,s.m_cosr=this.m_cosr,s.m_sinr=this.m_sinr,s.m_sweepAngle=this.m_sweepAngle,s.m_startAngle=this.m_startAngle,s.m_bits=this.m_bits,S(s,r.x,r.y),I(s,o.x,o.y),i?sr(s,Wi(this)):(s.m_startAngle=ji(this,t),s.m_sweepAngle=ji(this,e)-s.m_startAngle,s.m_startAngle=ki(s.m_startAngle),or(s,Math.abs(s.m_sweepAngle)>Math.PI),pr(s),s.afterCompletedModification())}changeEndPoints2D(t,e){Zi(this,t,e,!1)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const i=this.calculateLength2D(),r=i>0?this.tToLength(t)/i:0,o=xi.getInterpolation(e),a=this.getStartAttributeAsDbl(e,s),m=this.getEndAttributeAsDbl(e,s);return n.interpolate(o,a,m,r,xi.getDefaultValue(e))}getClosestCoordinate(t,e){return xr(this,t,n.Envelope1D.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return xr(this,t,e,!1)}getYMonotonicParts(t,s=!1){t.length<2&&e.throwInvalidArgumentException("");const i=this.getSemiAxes(),r=Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr),o=r+n.pi(),a=n.makePrimitiveArray(3,Number.NaN);let m=0;if(a[0]=Oi(this,r),a[0]>0&&a[0]<1&&m++,a[1]=Oi(this,o),a[1]>0&&a[1]<1&&(a[m]=a[1],m++),0===m)return 0;a[m]=1,m++,e.geometryReleaseAssert(t.length>=m);let h=0;for(let e=0;e<m;e++){const n=a[e];this.queryCut(h,n,t[e],s),h=n}return m}getMonotonicParts(t,s){if(t.length<4&&e.throwInvalidArgumentException(""),this.isDegenerateToLine())return t[0].createEllipticArc().assignCopy(this),s&&t[0].get().dropAllAttributes(),1;const i=this.getSemiAxes(),r=n.makePrimitiveArray(4,Number.NaN);r[0]=Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr),r[1]=r[0]+n.pi(),r[2]=Math.atan2(-i.y*this.m_sinr,i.x*this.m_cosr),r[3]=r[2]+n.pi();const o=n.makePrimitiveArray(5,Number.NaN);let a=0;for(let t=0;t<4;t++)o[a]=Oi(this,r[t]),o[a]>0&&o[a]<1&&a++;if(0===a)return 0;n.numericSortRange(o,a),o[a-1]<1&&(o[a]=1,a++),e.geometryReleaseAssert(t.length>=a);let m=0;for(let e=0;e<a;e++){const n=o[e];this.queryCut(m,n,t[e],s),m=n}return a}intersectionWithAxis2D(t,e,s,i){if($i(this))return new Nr({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(t,e,s,i);let r,o;const a=new n.ECoordinate(e),m=this.getSemiAxes();if(t){if(e>this.m_center.y+m.x||e<this.m_center.y-m.x)return 0;r=new n.ECoordinate(m.x).mulThis(this.m_sinr),o=new n.ECoordinate(m.y).mulThis(this.m_cosr),a.subThis(this.m_center.y)}else{if(e>this.m_center.x+m.x||e<this.m_center.x-m.x)return 0;r=new n.ECoordinate(m.x).mulThis(this.m_cosr),o=new n.ECoordinate(m.y).mulThis(-this.m_sinr),a.subThis(this.m_center.x)}const h=r.sqr(),u=o.sqr(),l=h.addE(u),c=o.mulE(a).mulThis(-2),g=a.sqr().subThisE(h),d=c.sqr().subThisE(l.mulE(g).mulThis(4)),p=r.mulE(a).mulThis(-2),_=a.sqr().subThisE(u),P=p.sqr().subThisE(l.mulE(_).mulThis(4));let f=d.eps()*Math.abs(P.value())<=P.eps()*Math.abs(d.value());f?r.isZero()&&(f=!1):o.isZero()&&(f=!0),f||(c.setE(p),g.setE(_));const y=n.makeObjectArray(n.ECoordinate,2);let x=Mt(l,c,g,n.Envelope1D.construct(-1,1),!1,y);if(0===x)return 0;const D=[0,0];let v=0;for(let t=0;t<x;t++){const e=new n.ECoordinate,s=new n.ECoordinate;f?(e.setE(y[t]),s.setE(a.subE(o.mulE(y[t])).divThisE(r))):(s.setE(y[t]),e.setE(a.subE(r.mulE(y[t])).divThisE(o)));const i=Oi(this,Math.atan2(e.value(),s.value()));i>=0&&i<=1&&(D[v]=i,v++)}return x=v,0===x?0:(2===x&&D[0]>D[1]&&(D[1]=n.swap(D[0],D[0]=D[1])),i&&n.memcpy(i,D,0,0,x),s&&(s[0]=t?this.getCoordX(D[0]):this.getCoordY(D[0]),x>1&&(s[1]=t?this.getCoordX(D[1]):this.getCoordY(D[1]),!i&&s[0]>s[1]&&(s[1]=n.swap(s[0],s[0]=s[1])))),x)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0];return-1===this.intersectionWithAxis2D(!0,t,s,null)?e:s[0]}isCurve(){return!0}isDegenerate(t){return C(this,t)}isDegenerate3D(t,s){return e.geometryReleaseAssert(0),!1}queryLooseEnvelope(t){3!==t.m_EnvelopeType?this.queryLooseEnvelopeOnInterval(new n.Envelope1D(0,1),t):e.throwNotImplementedException("3d not impl")}clone(t){const e=new Di;return this.copyTo(e),e}queryInterval(t,e){if(0===t){if($i(this))return 0===e?n.Envelope1D.construct(this.getStartX(),this.getEndX()):n.Envelope1D.construct(this.getStartY(),this.getEndY());let t;const s=this.getSemiAxes();t=0===e?Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr):Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr);const i=t+Math.PI,r=[0,0];r[0]=Oi(this,t),r[1]=Oi(this,i);const o=0===e?n.Envelope1D.construct(this.getStartX(),this.getEndX()):n.Envelope1D.construct(this.getStartY(),this.getEndY()),a=new n.Point2D;for(let t=0;t<2;t++){const s=r[t];s>0&&s<1&&(this.queryCoord2D(s,a),o.mergeNeCoordinate(0===e?a.x:a.y))}return o}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=new n.Envelope1D(0,1);if(s.intersect(t),s.isEmpty())return void e.setEmpty();if($i(this))return e.setCoords(this.getCoord2D(s.vmin)),void e.mergeNe(this.getCoord2D(s.vmax));const i=this.getCoord2D(s.vmin),r=this.getCoord2D(s.vmax);if(1===this.m_minorMajorRatio&&Math.abs(this.m_sweepAngle)*s.width()<=n.geometryHalfPi){let t=n.Point2D.lerp(i,r,.5);const s=t.sub(this.m_center);return s.normalize(),t=t.add(s.mul(.5*n.Point2D.distance(i,r))),e.setCoords(i),e.mergeNe(r),void e.mergeNe(t)}yr(this,s,e)}tToLength(t){return $i(this)?t*n.Point2D.distance(this.getStartXY(),this.getEndXY()):1===this.m_minorMajorRatio?Math.abs(this.getSweepAngle()*t)*this.m_semiMajorAxis:Ki(this,t)}parametricAngleToT(t){return Oi(this,t)}tToParametricAngle(t){return ji(this,t)}lengthToT(t){if($i(this)){const e=n.Point2D.distance(this.getStartXY(),this.getEndXY());return 0===e?0:t/e}if(1===this.m_minorMajorRatio){const e=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return 0===e?0:t/e}{const e=function(t,e){if($i(t)){const s=n.Point2D.distance(t.getStartXY(),t.getEndXY());return 0===s?0:e/s}if(1===t.m_minorMajorRatio){const s=Math.abs(t.getSweepAngle()*t.m_semiMajorAxis);return 0===s?0:e/s}if(0===e)return 0;const s=t.getSweepAngle();if(0===s)return.5;const i=Hi(t),r=n.halfPi(),o=Ji(t);s<0&&(e=-e);const a=e/t.m_semiMajorAxis+o;let m=n.inverseEllipticE(a,i.e2,i.completeE);return m-=r,m-=t.getStartAngle(),m/s}(this,t);return e}}calculateWeightedAreaCentroid2D(t){if($i(this)){const t=new n.Point2D;return t.setCoords(0,0),t}const e=dr(this),s=this.getStartXY().sub(this.m_center),i=this.getEndXY().sub(this.m_center),r=this.m_semiMajorAxis,o=this.getSemiMinorAxis(),a=this.m_startAngle+this.m_sweepAngle,m=new n.Point2D;m.x=r*o*(r*this.m_cosr*(-Math.sin(a)+Math.sin(this.m_startAngle))+o*(-Math.cos(a)+Math.cos(this.m_startAngle))*this.m_sinr)/3,m.y=r*o*(o*(Math.cos(a)-Math.cos(this.m_startAngle))*this.m_cosr+r*(-Math.sin(a)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const h=i.add(s).mul(i.crossProduct(s)/6);return m.x-=h.x,m.y-=h.y,m.add(this.m_center.sub(t).mul(e))}calculateWeightedCentroid2D(){const t=new n.Point2D;if(this.isDegenerate(0))return t.setCoords(0,0),t;if($i(this))return t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t;let e=this.m_startAngle,s=this.m_startAngle+this.m_sweepAngle;if(s<e){const t=e;e=s,s=t}const i=Math.sin(e),r=Math.sin(s),o=Math.cos(e),a=Math.cos(s);if(1===this.m_minorMajorRatio){const e=this.getSemiMajorAxis(),s=e*e,n=s*(r-i),m=s*(o-a);t.setCoords(n,m)}else{const e=this.getSemiMajorAxis(),s=this.getSemiMinorAxis(),n=e*e,m=s*s,h=e*s,u=n-m,l=u/m,c=u/n,g=Math.sqrt(l),d=Math.sqrt(c),p=.5*h*(Math.asinh(g*r)/g+r*Math.sqrt(1+l*r*r))-.5*h*(Math.asinh(g*i)/g+i*Math.sqrt(1+l*i*i)),_=-.5*h*(Math.asin(d*a)/d+a*Math.sqrt(1-c*a*a))- -.5*h*(Math.asin(d*o)/d+o*Math.sqrt(1-c*o*o));t.setCoords(p,_)}return t.rotateDirect(this.m_cosr,this.m_sinr),t.assign(t.add(this.m_center.mul(this.calculateLength2D()))),t}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;if(!$i(this)){const s=n.Point2D.distance(t,this.m_center),i=this.getSemiAxes();if(s<i.x-e||s>i.y+e)return!1}const i=this.getClosestCoordinate(t,!1),r=new n.Point2D;return this.queryCoord2D(i,r),n.Point2D.distance(r,t)<=e}isIntersectingPoint3D(t,s,n,i,r=1){return e.geometryReleaseAssert(0),!1}getTangent(t){if($i(this))return this.getEndXY().sub(this.getStartXY());{const e=ji(this,t),s=new n.Point2D;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}getDerivative(t){if($i(this))return this.getEndXY().sub(this.getStartXY());{const e=ji(this,t),s=new n.Point2D;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}normalizeAfterEndpointChange(){return!!mr(this)&&($i(this)?(hr(this),!1):ur(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(t){this.m_bits=-5&this.m_bits|t<<2}convertToCanonic(t){const e=new n.Point2D(t.x,t.y);return e.subThis(this.m_center),e.rotateReverse(this.m_cosr,this.m_sinr),e}convertFromCanonic(t){const e=new n.Point2D(t.x,t.y);return e.rotateDirect(this.m_cosr,this.m_sinr),e.addThis(this.m_center),e}canonicToWorldTransformation(t){t.setRotate(this.m_cosr,this.m_sinr),t.shiftCoords(this.m_center.x,this.m_center.y)}getCurvature(t){const e=ji(this,t),s=new n.Point2D,i=this.getSemiMinorAxis();s.setCoords(-this.m_semiMajorAxis*Math.sin(e),i*Math.cos(e));const r=new n.Point2D;r.setCoords(-this.m_semiMajorAxis*Math.cos(e),-i*Math.sin(e)),this.m_rotation&&(s.rotateDirect(this.m_cosr,this.m_sinr),r.rotateDirect(this.m_cosr,this.m_sinr));const o=s.sqrLength();if(0===o)return Number.NaN;const a=Math.sqrt(o);return s.divThis(a),s.crossProduct(r)/o}getMonotonicPartParams(t,s){const i=n.makePrimitiveArray(6,Number.NaN);i[0]=0;let r=1;if(this.isDegenerateToLine())i[1]=1,r=2;else{const t=this.getSemiAxes(),e=n.makePrimitiveArray(4,Number.NaN);this.m_rotation?(e[0]=Math.atan2(t.y*this.m_cosr,t.x*this.m_sinr),e[1]=e[0]+Math.PI,e[2]=Math.atan2(-t.y*this.m_sinr,t.x*this.m_cosr),e[3]=e[2]+Math.PI):(e[0]=0,e[1]=Math.PI,e[2]=.5*Math.PI,e[3]=n.threeHalfPi());for(let t=0;t<4;t++){const s=Oi(this,e[t]);s>0&&s<1&&(i[r]=s,r++)}r>2&&n.numericSortRange(i,r),i[r]=1,r++}if(s){t<r&&e.throwInvalidArgumentException("");for(let t=0;t<r;t++)s[t]=i[t]}return r}calculateLowerLength2D(){const t=n.Point2D.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(e,t)}calculateUpperLength2D(){const t=n.Point2D.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(e,t)}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=n.swap(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=n.swap(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=n.swap(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_startAngle=this.m_startAngle+this.m_sweepAngle,this.m_sweepAngle=-this.m_sweepAngle}}isLine(){return $i(this)}copyIgnoreAttributes(t){t.m_XStart=this.m_XStart,t.m_YStart=this.m_YStart,t.m_XEnd=this.m_XEnd,t.m_YEnd=this.m_YEnd,t.m_center.assign(this.m_center),t.m_semiMajorAxis=this.m_semiMajorAxis,t.m_minorMajorRatio=this.m_minorMajorRatio,t.m_interior.assign(this.m_interior),t.m_rotation=this.m_rotation,t.m_cosr=this.m_cosr,t.m_sinr=this.m_sinr,t.m_sweepAngle=this.m_sweepAngle,t.m_startAngle=this.m_startAngle,t.m_bits=this.m_bits,nr(t)}calculateArea2DHelper(){return dr(this)}absNorm(){let t=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(t+=this.m_center.norm(1),t+=this.m_semiMajorAxis),t}queryEnvelopeW(t,e){if(e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax)),$i(this))return;const s=this.getSemiAxes(),i=n.makePrimitiveArray(8,Number.NaN);{const t=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),e=t+Math.PI,n=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),r=n+Math.PI;i[0]=Oi(this,t),i[1]=Oi(this,e),i[2]=Oi(this,n),i[3]=Oi(this,r)}{const t=this.m_cosr+this.m_sinr,e=this.m_cosr-this.m_sinr,n=Math.atan2(-s.y*t,s.x*e),r=n+Math.PI,o=Math.atan2(s.y*e,s.x*t),a=o+Math.PI;i[4]=Oi(this,n),i[5]=Oi(this,r),i[6]=Oi(this,o),i[7]=Oi(this,a)}const r=n.Point2D.getNAN();for(let s=0;s<8;s++){const n=i[s];t.containsExclusiveCoordinate(n)&&(this.queryCoord2D(n,r),e.mergeNe(r))}}setSegmentFromCoordsForStitcher(t,e){!function(t,e,s){const i=0===t.projectionBehavior();if(s<=2)return void Qi(t,e[0],e[s-1],i?0:1);if(i){t.constructCircularArcThreePoint(e[0],e[s-1],e[Math.trunc(s/2)]);const i=new n.Point2D;return t.queryCoord2D(.5,i),void t.m_interior.setCoordsPoint2D(i)}const r=t.getSemiMajorAxis(),o=t.getMinorMajorRatio(),a=t.getAxisXRotation(),m=t.getCenter(),h=new Array(4);h[0]=t.isMajor(),h[1]=!h[0],h[2]=h[0],h[3]=!h[0];const u=new Array(4);u[0]=t.isClockwise(),u[1]=u[0],u[2]=!u[0],u[3]=!u[0];const l=Math.trunc(s<5?1:(s+4)/5),c=n.makeObjectArray(Di,4),g=n.makePrimitiveArray(4,Number.NaN);let d=0;for(let t=0;t<4;t++){c[t].constructEllipticArcEndPointsCenter(e[0],e[s-1],r,o,a,h[t],u[t],m),g[t]=0;let i=0;for(let r=l;r<s-1;r+=l){const s=c[t].getClosestCoordinate(e[r],!1);g[t]+=n.Point2D.sqrDistance(c[t].getCoord2D(s),e[r]),i++}g[t]/=i,g[t]<g[d]&&(d=t)}t.assignCopy(c[d])}(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(10);return s[0]=this.m_bits,s[1]=this.m_semiMajorAxis,s[2]=this.m_minorMajorRatio,s[3]=this.m_rotation,s[4]=this.m_center.x,s[5]=this.m_center.y,s[6]=this.m_sweepAngle,s[7]=this.m_startAngle,s[8]=this.m_interior.x,s[9]=this.m_interior.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(10);t.queryRange(e,s.length,s,!0,1),this.m_bits=s[0],this.m_semiMajorAxis=s[1],this.m_minorMajorRatio=s[2],this.m_rotation=s[3],this.m_center.x=s[4],this.m_center.y=s[5],this.m_sweepAngle=s[6],this.m_startAngle=s[7],this.m_interior.x=s[8],this.m_interior.y=s[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,s){return e.throwInternalErrorException("should not1; be called"),0}ensureXYMonotone(){if($i(this))return!1;if(this.getStartXY().equals(this.getEndXY()))return Qi(this,this.getStartXY(),this.getEndXY(),this.projectionBehavior()),!0;const t=n.makeObjectArray(n.Point2D,3);let e=lr(this,t);if(On(t)){let s=!1;if(0===this.projectionBehavior()){const r=new i.Envelope2D;r.setCoords({pt:t[0]}),r.mergeNe(t[2]);const o=new n.Point2D;o.setSub(t[2],t[0]),o.leftPerpendicularThis(),o.normalize(),o.scale(n.Point2D.distance(t[2],t[0]));const a=n.Point2D.lerp(t[2],t[0],.5),m=a.sub(o),h=a.add(o);r.clipLine(m,h);const u=n.Point2D.getClosestCoordinate(m,h,t[1],!1);t[1]=n.Point2D.lerp(m,h,u);const l=t[2].sub(t[1]),c=t[0].sub(t[1]),g=l.crossProduct(c),d=l.dotProduct(c);e=n.halfPi()-Math.abs(.5*Math.atan2(g,d)),s=!0}return cr(t,e*e,null,s,this),!0}return!1}setCoordsForIntersector(t,e,s){Zi(this,t,e,s)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(t){const e=t;e.m_center.assign(this.m_center),e.m_semiMajorAxis=this.m_semiMajorAxis,e.m_minorMajorRatio=this.m_minorMajorRatio,e.m_interior.assign(this.m_interior),e.m_rotation=this.m_rotation,e.m_cosr=this.m_cosr,e.m_sinr=this.m_sinr,e.m_sweepAngle=this.m_sweepAngle,e.m_startAngle=this.m_startAngle,e.m_bits=this.m_bits,sr(e,Wi(this))}reverseImpl(){ir(this,!rr(this)),Gi(this),(0!==this.projectionBehavior()||this.getStartXY().equals(this.getEndXY()))&&pr(this)}equalsImpl(t){const e=t;if(this.m_bits!==e.m_bits)return!1;if(this.m_semiMajorAxis!==e.m_semiMajorAxis)return!1;if(this.m_minorMajorRatio!==e.m_minorMajorRatio)return!1;if(!(this.m_center.isEqualPoint2D(e.m_center)||this.m_center.isNAN()&&e.m_center.isNAN()))return!1;if(this.m_rotation!==e.m_rotation)return!1;if(!this.m_interior.equals(e.m_interior))return!1;const s=e.m_sweepAngle;if(this.m_sweepAngle!==s)return!1;const n=e.m_startAngle;return this.m_startAngle===n}equalsImplTol(t,e){const s=t;if(this.m_bits!==s.m_bits)return!1;if(this.m_center.isNAN()&&s.m_center.isNAN())return!0;if(this.m_center.isNAN()!==s.m_center.isNAN())return!1;if(!this.getSemiAxes().isEqualPoint2D(s.getSemiAxes(),e))return!1;if(!this.m_center.isEqualPoint2D(s.m_center,e))return!1;const i=Math.abs(_i(pi(Pi(this.m_rotation-s.m_rotation)))),r=Math.abs(n.pi()-i),o=Math.min(i,r);if(this.m_semiMajorAxis*Math.abs(o)>e)return!1;const a=this.getCoord2D(.5),m=s.getCoord2D(.5);return!!a.isEqualPoint2D(m,e)}swapImpl(t){const e=t;var s;this.m_center=n.swap(e.m_center,e.m_center=this.m_center),this.m_semiMajorAxis=n.swap(e.m_semiMajorAxis,e.m_semiMajorAxis=this.m_semiMajorAxis),this.m_minorMajorRatio=n.swap(e.m_minorMajorRatio,e.m_minorMajorRatio=this.m_minorMajorRatio),this.m_interior=n.swap(e.m_interior,e.m_interior=this.m_interior),this.m_rotation=n.swap(e.m_rotation,e.m_rotation=this.m_rotation),this.m_cosr=n.swap(e.m_cosr,e.m_cosr=this.m_cosr),this.m_sinr=n.swap(e.m_sinr,e.m_sinr=this.m_sinr),this.m_sweepAngle=n.swap(e.m_sweepAngle,e.m_sweepAngle=this.m_sweepAngle),this.m_startAngle=n.swap(e.m_startAngle,e.m_startAngle=this.m_startAngle),this.m_bits=n.swap(e.m_bits,e.m_bits=this.m_bits),(s=e).m_cachedValues=n.swap(this.m_cachedValues,this.m_cachedValues=s.m_cachedValues)}afterCompletedModification(){hr(this),nr(this)}intersect(t,e,s,n,i){return wr(!1,this,t,e,s,n,i)}intersectPoint(t,s,i){if(s.length<2&&e.throwOutOfRangeException(""),$i(this))return new Nr({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(t,s,i);{const e=n.Point2D.distance(t,this.m_center);if(e>this.m_semiMajorAxis+i||e<this.getSemiMinorAxis()-i)return 0}const r=this.getClosestCoordinate(t,!1),o=n.Point2D.getNAN();return this.queryCoord2D(r,o),n.Point2D.distance(o,t)<=i?n.isOneOf(r,0,1)&&(this.queryCoord2D(0===r?1:0,o),n.Point2D.distance(o,t)<=i)?(s&&(s[0]=0,s[1]=1),2):(s&&(s[0]=r),1):0}isIntersecting(t,e,s){return 0!==Er(!1,this,t,e,s)}endPointModified(){this.m_bits|=8,nr(this)}clearEndPointModified(){hr(this)}}function vi(t,e,s,n){const i=[];return Ei(e,i),Ci(t,i,e,s)}function Ei(t,e){e.length=t;for(let t=0;t<e.length;++t)e[t]=t;t>3&&m(t,e)}function Ci(t,e,s,i,r){let o=0;const a=[0,0,0];let m=0,h=0;for(let r=0;r<3;++r){let u=!1;for(;h<s;){const s=t.at(e[h]);let l=1;if(3===o?l=n.Point2D.inCircleRobust(t.at(i[0]),t.at(i[1]),t.at(i[2]),s):2===o?l=n.Point2D.inCircleRobust3Point(t.at(i[0]),t.at(i[1]),s):1===o&&s.equals(t.at(i[0]))&&(l=0),l<=0){if(l<0&&r+1<3){e[m]=n.swap(e[h],e[h]=e[m]);for(let t=0;t<o;t++)if(i[t]===e[h]){a[t]=h;break}m++}h++;continue}u=!0;let c=0;for(let t=0;t<o;t++)a[t]>h&&(i[c]=i[t],a[c]=a[t],c++);o=c,i[o]=e[h],a[o]=h,o++,o<3?h=m:(1===n.Point2D.orientationRobust(t.at(i[0]),t.at(i[1]),t.at(i[2]))&&(i[2]=n.swap(i[0],i[0]=i[2]),a[2]=n.swap(a[0],a[0]=a[2])),h++)}if(!u)break;if(r+1<3){m=0;let s=!1;for(let t=0;t<o;t++)for(let e=t+1;e<o;e++)a[t]>a[e]&&(a[e]=n.swap(a[t],a[t]=a[e]),i[e]=n.swap(i[t],i[t]=i[e]),s=!0);for(let t=0;t<o;t++)e[a[t]]=n.swap(e[t],e[t]=e[a[t]]),a[t]=t;s&&3===o&&1===n.Point2D.orientationRobust(t.at(i[0]),t.at(i[1]),t.at(i[2]))&&(i[2]=n.swap(i[0],i[0]=i[2]),a[2]=n.swap(a[0],a[0]=a[2]))}h=o}return o}function bi(t,s,i,r,o,a,m,h){a&&(a.length=0),m&&(m.length=0);const u=t.getGeometryType();if(u===e.GeometryType.enumLine)return a&&(a.push(t.getStartXY()),a.push(n.Point2D.getNAN()),a.push(n.Point2D.getNAN()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(u===e.GeometryType.enumBezier){if(!r)return a&&(a.push(t.getStartXY()),a.push(t.getControlPoint1()),a.push(t.getControlPoint2()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;const e=n.makePrimitiveArray(9,Number.NaN);let s=t.getMonotonicPartParams(e.length,e);if(e.length=s,s=Si(t,i,e),2===s&&o&&(e[1]=.5,e.push(1),s=3),m&&m.splice(0,0,...e.slice(0,s)),a){const n=new qr;for(let i=1;i<s;i++){const s=e[i-1],r=e[i];t.queryCut(s,r,n,!0);const o=n.get();Rs(o),1===i&&a.push(o.getStartXY()),a.push(o.getControlPoint1()),a.push(o.getControlPoint2()),a.push(o.getEndXY())}}return s-1}if(u===e.GeometryType.enumEllipticArc){const h=t;if(h.isDegenerateToLine()||h.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(n.Point2D.getNAN()),a.push(n.Point2D.getNAN()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(r&&(o||!h.isMonotoneQuickAndDirty())){const u=n.makePrimitiveArray(6,Number.NaN);let l=h.getMonotonicPartParams(u.length,u);u.length=l,l=Si(t,i,u),2===l&&o&&(u[1]=.5,u.push(1),l=3);let c=0;if(l>2){const t=new qr,n=m||[];let o=0;for(let g=1;g<l;g++){const d=u[o],p=u[g];if(h.queryCut(d,p,t,!0),t.get().isDegenerate(0))continue;const _=n.length,P=Mi(1===g,t.get(),s,i,r,a,m);e.geometryReleaseAssert(P>0),c+=P;const f=g===l-1,y=u[o],x=t.get().getSweepAngle()/h.getSweepAngle();for(let t=_,e=n.length;t<e;t++)if(n[t]=!f||t+1<e?y+n[t]*x:1,a){const e=3*t,s=h.getCoord2D(n[t]);a[e].setCoordsPoint2D(s),e>0&&Fs(a.slice(e-3))}o=g}return c}}return Mi(!0,h,s,i,r,a,m)}if(u===e.GeometryType.enumRationalBezier2){const e=t;if(r&&(o||!e.isMonotoneQuickAndDirty())){const r=n.makePrimitiveArray(6,Number.NaN);let h=e.getMonotonicPartParams(r.length,r);r.length=h,h=Si(t,i,r),2===h&&o&&(r[1]=.5,r.push(1),h=3);let u=0;if(h>2){const t=new qr,n=m||[];for(let o=1;o<h;o++){const l=r[o-1],c=r[o];e.queryCut(l,c,t,!0);const g=n.length;u+=qi(1===o,t.get(),s,i,!1,a,m);const d=o===h-1,p=r[o-1];for(let t=g,s=n.length;t<s;t++)if(n[t]=!d||t+1<s?p+n[t]:1,a){const s=3*t,i=e.getCoord2D(n[t]);a[s].setCoordsPoint2D(i),s>0&&Ye(a.slice(s-3))}}return u}}return qi(!0,e,s,i,r,a,m)}if(u===e.GeometryType.enumBezier2){const e=t,h=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(h);const u=new pn;u.constructFromQuadratic(h);const l=bi(u,s,i,r,o,a,m);if(null!=a&&null!=m){const t=3;for(let s=1,i=0;s<l;++s,i+=t){const o=new n.Point2D;e.queryCoord2D(m[s],o);const h=a[i+t];!o.equals(h)&&(a[i+t].setCoordsPoint2D(o),r)&&Fs(a.slice(i,i+4))}}return l}e.throwNotImplementedException("")}function Ai(t,s,i,r,o,a,m,h,u){const l=t.getGeometryType();if(a&&(a.length=0,m.length=0),h&&(h.length=0),l===e.GeometryType.enumEllipticArc){const e=t;if(e.isDegenerateToLine()||e.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(n.Point2D.getNAN()),a.push(t.getEndXY()),m.push(Number.NaN),m.push(Number.NaN),m.push(Number.NaN)),h&&(h.push(0),h.push(1)),1}const c=n.makePrimitiveArray(9,Number.NaN);let g;if(o)g=t.getMonotonicPartParams(c.length,c),c.length=g,g=Si(t,i,c);else{if(g=2,c[0]=0,c[1]=1,l===Di.type){const e=t.getSweepAngle();if(e>.9*Math.PI){const t=2*Math.PI/3;Math.min(3,Math.trunc(e/t+.5))>2?(c[0]=0,c[1]=1/3,c[2]=2/3,c[3]=1,g=4):(c[0]=0,c[1]=.5,c[2]=1,g=3)}}else e.geometryReleaseAssert(l===zt.type);c.length=g}if(2===g&&r&&(c[1]=.5,c.push(1),g=3),a){const s=new qr;let i=1;for(;i<g;){const r=c[i-1],h=c[i];t.queryCut(r,h,s,!0);const u=n.makeObjectArray(n.Point2D,3),d=[1,1,1];if(l===e.GeometryType.enumEllipticArc){const t=s.get();if(Math.abs(t.getSweepAngle())>.9*Math.PI){const t=(h-r)/3;c.splice(i,0,r+t),c.splice(i+1,0,r+2*t),g+=2;continue}d[1]=lr(t,u)}else{const t=s.get();t.queryControlPoints(u),t.queryWeights(d)}o&&On(u),1===i&&(a.push(u[0].clone()),m.push(d[0])),a.push(u[1].clone()),a.push(u[2].clone()),m.push(d[1]),m.push(d[2]),i++}}return h&&(h.length=g,n.memcpy(h,c,0,0,g)),g-1}Di.type=e.GeometryType.enumEllipticArc;class wi{static constructDefault(t){return new wi(0,0,0,t,!1,n.intMax())}constructor(t,i,r,o,a,m){this.m_segmentBuffer=null,this.m_dummyPoint=new s.Point,this.m_progressCounter=0,this.m_progressTracker=o,this.m_bSetDensifyFlag=a,this.m_maxLength=t,this.m_maxDeviation=i,this.m_maxAngle=r>n.halfPi()?n.halfPi():r,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=m,e.checkAndThrow(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(t){return this.densifyGeom(t)}densifySegment(t,e){this.densifySegmentEx(t,null,!0,!1,e)}densifyEx(t,s,i,r,o,a){return this.m_maxLength=s,this.m_maxDeviation=i,this.m_maxAngle=r>n.halfPi()?n.halfPi():r,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=o,this.m_maxSegmentsPerCurve=a,e.checkAndThrow(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(t)}densifyGeom(t){if(t.isEmpty()||t.getDimension()<1)return t;const s=t.getGeometryType();return e.isMesh(s)?t:e.isMultiPath(s)?this.densifyMultiPath(t):e.isSegment(s)?this.densifySegmentImpl(t):s===e.GeometryType.enumEnvelope?this.densifyEnvelope(t):void e.throwInternalErrorException("")}densifySegmentEx(t,s,n,i,r){const o=t.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&o!==e.GeometryType.enumLine)&&(!i||n))return void(s?o===e.GeometryType.enumLine?s.addSegment(t,n):(n&&(t.queryStart(this.m_dummyPoint),s.startPathPoint(this.m_dummyPoint)),t.queryEnd(this.m_dummyPoint),s.lineToPoint(this.m_dummyPoint)):(n&&r.push(0),r.push(1)));if(o===e.GeometryType.enumBezier)return void this.densifyCubicBezier(t,s,n,i,r);if(o===e.GeometryType.enumRationalBezier2)return void this.densifyRationalBezier2(t,s,n,i,r);if(o===e.GeometryType.enumBezier2)return void this.densifyBezier2(t,s,n,i,r);if(o===e.GeometryType.enumEllipticArc&&!t.isLine()&&t.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(t,s,n,i,r);let a=1;this.m_maxLength>0&&(a=this.calculateLengthSubdivisionStep(t,this.m_maxLength)),this.m_maxDeviation>0&&(a=Math.min(a,this.calculateDeviationSubdivisionStep(t,this.m_maxDeviation))),this.m_maxAngle>0&&(a=Math.min(a,this.calculateAngularSubdivisionStep(t,this.m_maxAngle))),this.densifySegmentByLength(t,a,s,n,i,r)}densifyMultiPath(t){if(!t.hasNonLinearSegments()){if(1===t.getDescription().getAttributeCount())return this.densifyMultiPathLinear(t);if(!(this.m_maxLength>0))return t}const s=t.createInstance();s.getGeometryType()===e.GeometryType.enumPolygon&&s.setFillRule(t.getFillRule()),s.reserve(t.getPointCount());const n=t.getImpl().querySegmentIterator();for(;n.nextPath();){let t=!0;for(;n.hasNextSegment();){const e=n.nextSegment(),i=n.isClosingSegment();this.densifySegmentEx(e,s,t,i,null),i&&s.closePathWithLine(),t=!1}}return s}densifySegmentImpl(t){const e=new yt({vd:t.getDescription()});return this.densifySegmentEx(t,e,!0,!1,[0]),e}densifyEnvelope(t){const e=new ts({vd:t.getDescription()});e.addEnvelope(t,!1);const s=i.Envelope2D.constructEmpty();t.queryEnvelope(s);const n=s.width(),r=s.height();return!(this.m_maxLength>0)||n<=this.m_maxLength&&r<=this.m_maxLength?e:this.densifyMultiPath(e)}densifyMultiPathLinear(t){if(!(this.m_maxLength>0))return t;const s=t.createInstance();s.getGeometryType()===e.GeometryType.enumPolygon&&s.setFillRule(t.getFillRule()),s.reserve(t.getPointCount());const i=s.getImpl(),r=t.getImpl(),o=r.getAttributeStreamRef(0),a=new Nr;for(let t=0,e=r.getPathCount();t<e;t++){const e=r.isClosedPath(t);if(0===r.getPathSize(t))continue;const m=r.getPathStart(t),h=o.readPoint2D(2*m),u=h.clone();i.startPath(h);for(let e=m+1,h=r.getPathEnd(t);e<h;e++){const t=o.readPoint2D(2*e),r=n.Point2D.distance(u,t);if(r>this.m_maxLength){let e=Math.ceil(r/this.m_maxLength);e>n.intMax()&&(e=n.intMax());const s=1/e;let o,m,h;u.compare(t)<0?(a.setStartXY(u),a.setEndXY(t),o=0,m=1):(a.setStartXY(t),a.setEndXY(u),o=e-2,m=-1);for(let t=0,r=e-1;t<r;t++,o+=m){this.progress_(),h=s*(o+1);const t=new n.Point2D;a.queryCoord2D(h,t),i.lineTo(t),this.m_bSetDensifyFlag&&i.setAttributeNoCurves(10,i.getPointCount()-1,0,1)}}else this.progress_();s.lineTo(t),u.assign(t)}if(e){const t=n.Point2D.distance(u,h);if(t>this.m_maxLength){const e=h;let s=Math.ceil(t/this.m_maxLength);s>n.intMax()&&(s=n.intMax());const r=1/s;let o,m;u.compare(e)<0?(a.setStartXY(u),a.setEndXY(e),o=0,m=1):(a.setStartXY(e),a.setEndXY(u),o=s-2,m=-1);const l=new n.Point2D(0,0);let c;for(let t=0,e=s-1;t<e;t++,o+=m)this.progress_(),c=r*(o+1),a.queryCoord2D(c,l),i.lineTo(l),this.m_bSetDensifyFlag&&i.setAttributeNoCurves(10,i.getPointCount()-1,0,1)}i.closePathWithLine()}}return s}densifySegmentByLength(t,s,i,r,o,a){e.geometryReleaseAssert(t.getGeometryType()!==e.GeometryType.enumBezier);let m=t.getStartXY().compare(t.getEndXY());0===m&&s<1&&(t.getGeometryType()===e.GeometryType.enumEllipticArc?m=t.getSweepAngle()<0?1:-1:e.throwNotImplementedException("densify segment by length"));let h=0;if(r&&(i?(t.queryStart(this.m_dummyPoint),i.startPathPoint(this.m_dummyPoint)):a.push(0),++h),s*this.m_maxSegmentsPerCurve<1&&(s=1/this.m_maxSegmentsPerCurve),s<1){this.m_segmentBuffer||(this.m_segmentBuffer=new qr);let e=Math.ceil(1/s);e>n.intMax()&&(e=n.intMax()),s=1/e,this.m_segmentBuffer.create(t.getGeometryType());let r,o,u,l=t;m<0?(r=0,o=1):(t.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),r=e-2,o=-1,l=this.m_segmentBuffer.get());const c=e-1;for(let t=0;t<c;t++,r+=o)u=s*(r+1),i?(l.queryCoord(u,this.m_dummyPoint),i.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==u&&0!==u&&i.setAttribute(10,i.getPointCount()-1,0,1)):a.push(m>0?1-u:u),this.progress_();u=1,h+=c}(!o||o&&r&&h<2)&&(i?(t.queryEnd(this.m_dummyPoint),i.lineToPoint(this.m_dummyPoint)):a.push(1))}densifyCubicBezier(t,e,s,i,r){const o=new pn;let a=t;const m=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());if(0===h&&m>0){const e=n.makeObjectArray(n.Point2D,4);t.queryControlPoints(e),h=e[1].compare(e[2]),0===h&&(h=e[1].compare(e[0]))}h>0&&(t.copyTo(o),o.reverse(),a=o);let u=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):r.push(0),++u);const l=[],c=[],g=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let d=!0,p=0;if(h>0)for(l.push([a.getStartXY(),a.getControlPoint1(),a.getControlPoint2(),a.getEndXY(),new n.Point2D(0,1)]),c.push(0);l.length;){this.progress_();const t=l.at(-1),o=c.at(-1),m=t[4].x,h=t[4].y;if(o<g&&this.bezierNeedsSplit(t)){d&&(p=a.findMinDeriv(),d=!1);let e=.5*(m+h);Math.abs(p-e)<.4*(h-m)&&(e=p);const s=(e-m)/(h-m),i=t[0].mul(1-s).add(t[1].mul(s)),r=t[1].mul(1-s).add(t[2].mul(s)),u=t[2].mul(1-s).add(t[3].mul(s)),g=i.mul(1-s).add(r.mul(s)),_=r.mul(1-s).add(u.mul(s)),P=g.mul(1-s).add(_.mul(s)),f=t[3];t[1]=i,t[2]=g,t[3]=P,t[4].setCoords(m,e);const y=[P,_,u,f,new n.Point2D(e,h)];l.push(y),c[c.length-1]=o+1,c.push(o+1);continue}l.pop(),c.pop(),(l.length>0||!i||i&&s&&u<2)&&(e?(a.queryCoord(m,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==m&&0!==m&&e.setAttribute(10,e.getPointCount()-1,0,1)):r.push(1-m),++u)}else for(l.push([a.getStartXY(),a.getControlPoint1(),a.getControlPoint2(),a.getEndXY(),new n.Point2D(0,1)]),c.push(0);l.length;){this.progress_();const t=l.at(-1),o=c.at(-1),m=t[4].x,h=t[4].y;if(o<g&&this.bezierNeedsSplit(t)){d&&(p=a.findMinDeriv(),d=!1);let e=.5*(m+h);Math.abs(p-e)<.4*(h-m)&&(e=p);const s=(e-m)/(h-m),i=t[0].mul(1-s).add(t[1].mul(s)),r=t[1].mul(1-s).add(t[2].mul(s)),u=t[2].mul(1-s).add(t[3].mul(s)),g=i.mul(1-s).add(r.mul(s)),_=r.mul(1-s).add(u.mul(s)),P=g.mul(1-s).add(_.mul(s)),f=t[0];t[0]=P,t[1]=_,t[2]=u,t[4].setCoords(e,h);const y=[f,i,g,P,new n.Point2D(m,e)];l.push(y),c[c.length-1]=o+1,c.push(o+1);continue}l.pop(),c.pop(),(l.length>0||!i||i&&s&&u<2)&&(e?(a.queryCoord(h,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==h&&0!==h&&e.setAttribute(10,e.getPointCount()-1,0,1)):r.push(h),++u)}}densifyRationalBezier2(t,e,s,i,r){const o=new zt;let a=t;const m=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&m>0&&(h=0),h>0&&(t.copyTo(o),o.reverse(),a=o);let u=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):r.push(0),++u);const l=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new zt,g=[],d=[];for(g.push(new n.Envelope1D(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),o=d.at(-1);if(o<l&&this.rationalBezier2NeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();h>0?(g.at(-1).vmax=e,g.push(new n.Envelope1D(e,t.vmax))):(g.at(-1).vmin=e,g.push(new n.Envelope1D(t.vmin,e))),d[d.length-1]=o+1,d.push(o+1);continue}if(g.pop(),d.pop(),g.length>0||!i||i&&s&&u<2){const s=h>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):r.push(h>0?1-s:s),++u}}}densifyBezier2(t,e,s,i,r){const o=new Ot;let a=t;const m=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&m>0&&(h=0),h>0&&(t.copyTo(o),o.reverse(),a=o);let u=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):r.push(0),++u);const l=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),c=new Ot,g=[],d=[];for(g.push(new n.Envelope1D(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),o=d.at(-1);if(o<l&&this.bezier2NeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();h>0?(g.at(-1).vmax=e,g.push(new n.Envelope1D(e,t.vmax))):(g.at(-1).vmin=e,g.push(new n.Envelope1D(t.vmin,e))),d[d.length-1]=o+1,d.push(o+1);continue}if(g.pop(),d.pop(),g.length>0||!i||i&&s&&u<2){const s=h>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):r.push(h>0?1-s:s),++u}}}densifyEllipticArc(t,e,s,i,r){const o=new Di;let a=t;const m=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&m>0&&(h=t.isClockwise()?0:1),h>0&&(t.copyTo(o),o.reverse(),a=o);let u=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):r.push(0),++u);const l=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),c=new Di,g=[],d=[];for(g.push(new n.Envelope1D(0,1)),d.push(0);g.length;){this.progress_();const t=g.at(-1).clone(),o=d.at(-1);if(o<l&&this.ellipticArcNeedsSplit(a,c,t.vmin,t.vmax)){const e=t.getCenter();h>0?(g.at(-1).vmax=e,g.push(new n.Envelope1D(e,t.vmax))):(g.at(-1).vmin=e,g.push(new n.Envelope1D(t.vmin,e))),d[d.length-1]=o+1,d.push(o+1);continue}if(g.pop(),d.pop(),g.length>0||!i||i&&s&&u<2){const s=h>0?t.vmin:t.vmax;e?(a.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):r.push(h>0?1-s:s),++u}}}calculateLengthSubdivisionStep(t,s){const n=t.calculateUpperLength2D();if(!t.isCurve())return n?s/n:1;if(t.getGeometryType()===e.GeometryType.enumEllipticArc){const e=t;if(e.isCircular()||e.isDegenerate(0)||e.isDegenerateToLine()){let t=s/n;return t<this.m_minStep&&(t=this.m_minStep),t}return s/n*e.getSemiAxes().y/e.getSemiAxes().x}t.getGeometryType()===e.GeometryType.enumBezier&&e.throwNotImplementedException(""),e.throwNotImplementedException("")}calculateDeviationSubdivisionStep(t,s){if(!t.isCurve())return 1;if(t.getGeometryType()===e.GeometryType.enumEllipticArc){const e=t;if(e.isDegenerate(0)||e.isDegenerateToLine())return 1;{const n=e.getSemiMajorAxis(),i=1-s/n;let r=Math.PI/2;if(i>0){const t=4*Math.sqrt(s/n*.5);r=Math.min(Math.PI/2,Math.abs(t))}r=Math.max(r,2*Math.PI/this.m_maxSegmentsPerCurve);const o=r*n;return this.calculateLengthSubdivisionStep(t,o)}}e.throwNotImplementedException("")}calculateAngularSubdivisionStep(t,s){if(!t.isCurve())return 1;if(t.getGeometryType()===e.GeometryType.enumEllipticArc){const e=t;return e.isDegenerate(0)||e.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(t,s*e.getSemiMinorAxis())}e.throwNotImplementedException("")}rationalBezier2NeedsSplit(t,e,s,i){t.cutBezierIgnoreAttributes(s,i,e);let r=!1;if(this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0;const o=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(o);const a=[0,0,0];return e.queryWeights(a),!r&&this.m_maxDeviation>0&&(r=!wi.checkRationalBezier2MaxDeviation(o,a,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!wi.checkRationalBezier2MaxAngle(o,a,this.m_cosMaxAngle)),r}bezier2NeedsSplit(t,e,s,i){t.cutBezierIgnoreAttributes(s,i,e);let r=!1;if(this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength)return r=!0,!0;const o=n.makeObjectArray(n.Point2D,3);return e.queryControlPoints(o),!r&&this.m_maxDeviation>0&&(r=!wi.checkBezier2MaxDeviation(o,this.m_maxDeviation)),!r&&this.m_maxAngle>0&&(r=!wi.checkBezier2MaxAngle(o,this.m_cosMaxAngle)),r}ellipticArcNeedsSplit(t,e,s,n){t.cutArcIgnoreAttributes(s,n,e);let i=!1;return this.m_maxLength>0&&e.calculateUpperLength2D()>this.m_maxLength?(i=!0,!0):(!i&&this.m_maxDeviation>0&&(i=!wi.checkEllipticArcMaxDeviation(e,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!wi.checkEllipticArcMaxAngle(e,this.m_cosMaxAngle)),i)}bezierNeedsSplit(t){let e=!1;return this.m_maxLength>0&&n.Point2D.distance(t[0],t[1])+n.Point2D.distance(t[1],t[2])+n.Point2D.distance(t[2],t[3])>this.m_maxLength?(e=!0,!0):(!e&&this.m_maxDeviation>0&&(e=!wi.checkBezierMaxDeviation(t,this.m_maxDeviation)),!e&&this.m_maxAngle>0&&(e=!wi.checkBezierMaxAngle(t,this.m_cosMaxAngle)),e)}progress_(){}static checkBezierMaxDeviation(t,e){const s=t[3].sub(t[0]);if(s.sqrLength()>0){const i=s.clone();i.leftPerpendicularThis(),i.normalize();const r=i.dotProduct(t[0].sub(t[1])),o=i.dotProduct(t[0].sub(t[2]));if(Math.max(Math.abs(r),Math.abs(o))<=e){const e=new n.Point2D;zs(t,.5,e,!1);const i=e.sub(t[0]).dotProduct(s);return i>=0&&i<=s.sqrLength()}return!1}return Math.max(t[0].sub(t[1]).sqrLength(),t[0].sub(t[2]).sqrLength())<=e*e}static checkBezierMaxAngle(t,e){if(t[0].equals(t[3]))return!(!t[0].equals(t[1])||!t[1].equals(t[2]));const s=t[3].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[1]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkRationalBezier2MaxDeviation(t,e,s){if(0===e[1])return!1;const n=t[2].sub(t[0]);if(n.sqrLength()>0){const e=n.clone();e.leftPerpendicularThis(),e.normalize();const i=e.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=s){const e=t[1].sub(t[0]).dotProduct(n);return e>=0&&e<=n.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=s*s}static checkRationalBezier2MaxAngle(t,e,s){if(0===e[1])return!1;if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const n=t[2].sub(t[0]);n.normalize();{const e=t[1].sub(t[0]),i=e.dotProduct(n);if(i<0)return!1;if(e.length()*s>i)return!1}return!0}static checkBezier2MaxDeviation(t,e){const s=t[2].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=e){const e=t[1].sub(t[0]).dotProduct(s);return e>=0&&e<=s.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=e*e}static checkBezier2MaxAngle(t,e){if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const s=t[2].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkEllipticArcMaxDeviation(t,s){if(Math.abs(t.getSweepAngle())<Math.PI){const i=t.getEndXY().sub(t.getStartXY()),o=[0,0],a=function(t,s,i){e.geometryReleaseAssert(!$i(t));const o=new r.Transformation2D;o.setRotateAngle(-t.getAxisXRotation());const a=new n.Point2D;o.queryTransform(s,a);const m=Math.atan2(-a.x*t.getMinorMajorRatio(),a.y),h=m+n.pi();let u=Oi(t,m),l=Oi(t,h);l<u&&(l=n.swap(u,u=l));let c=0;return u>=0&&u<=1&&(i[c++]=u),l>=0&&l<=1&&(i[c++]=l),c}(t,i,o);if(1===a){const e=t.getCoord2D(o[0]),i=n.Point2D.getClosestCoordinate(t.getStartXY(),t.getEndXY(),e),r=new n.Point2D;return n.lerpPoint2D(t.getStartXY(),t.getEndXY(),i,r),n.Point2D.distance(e,r)<=s}}const i=t.getCoord2D(.5),o=new n.Point2D;return n.lerpPoint2D(t.getEndXY(),t.getStartXY(),.5,o),n.Point2D.distance(i,o)<=s}static checkEllipticArcMaxAngle(t,e){const s=t.getTangent(0),n=t.getTangent(1),i=s.dotProduct(n);return!(i<0||s.length()*n.length()*e>i)}static checkTypeForReplace(t,s){return t.getGeometryType()===s&&(s!==e.GeometryType.enumEllipticArc||t.isCircular())}}function Si(t,e,s){const i=s.length;if(e<=0||i<=2)return i;let r=0;const o=n.makePrimitiveArray(i-1,Number.NaN);for(let e=1,n=i;e<n;e++){const n=t.tToLength(s[e]);o[e-1]=n-r,r=n}for(;o.length>1;){const t=o.findIndex(t=>t<=2*e);if(-1===t)break;let n=t+1,i=t+1;if(t>0){const e=t-1;(i===o.length||o[e]>o[i])&&(i=e,n--)}o[i]+=o[t],o.splice(t,1),s.splice(n,1)}return s.length}function Ti(t,e,n,i,r){const o=[],a=[],m=bi(e,n,0,i,!1,o,a),h=new pn;let u=r;const l=e.getDescription();h.assignVertexDescription(l);const c=l.getAttributeCount()>1,g=new s.Point,d=new Nr;for(let s=0,n=0;s<m;s++){if(o[n+1].isNAN()){if(c){let t=a[s];e.queryCoord(t,g),d.setStart(g),t=a[s+1],e.queryCoord(t,g),d.setEnd(g)}d.setStartXY(o[n]),d.setEndXY(o[n+3]),t.addSegment(d,u)}else{if(c){let t=a[s];e.queryCoord(t,g),h.setStart(g),t=a[s+1],e.queryCoord(t,g),h.setEnd(g)}h.setStartXY(o[n]),h.setControlPoint1(o[n+1]),h.setControlPoint2(o[n+2]),h.setEndXY(o[n+3]),t.addSegment(h,u)}n+=3,u=!1}}function Ii(t,i,r,o,a){const m=[],h=[],u=function(t,s,i,r,o,a,m){a&&(a.length=0),m&&(m.length=0);const h=t.getGeometryType();if(h===e.GeometryType.enumLine)return a&&(a.push(t.getStartXY()),a.push(n.Point2D.getNAN()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(h===e.GeometryType.enumBezier2){const e=n.makePrimitiveArray(9,Number.NaN);let s=t.getMonotonicPartParams(e.length,e);if(e.length=s,s=Si(t,0,e),m&&m.splice(0,0,...e.slice(0,s)),a){const n=new qr;for(let i=1;i<s;i++){const s=e[i-1],r=e[i];t.queryCut(s,r,n,!0);const o=n.get();qe(o),1===i&&a.push(o.getStartXY()),a.push(o.getControlPoint1()),a.push(o.getEndXY())}}return s-1}if(h===e.GeometryType.enumEllipticArc){const e=t;if(e.isDegenerateToLine()||e.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(n.Point2D.getNAN()),a.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(!e.isMonotoneQuickAndDirty()){const i=n.makePrimitiveArray(6,Number.NaN);let r=e.getMonotonicPartParams(i.length,i);i.length=r,r=Si(t,0,i);let o=0;if(r>2){const t=new qr,n=m||[];for(let h=1;h<r;h++){const u=i[h-1],l=i[h];e.queryCut(u,l,t,!0);const c=n.length;o+=Yi(1===h,t.get(),s,0,0,a,m);const g=h===r-1,d=i[h-1],p=t.get().getSweepAngle()/e.getSweepAngle();for(let t=c,s=n.length;t<s;t++)if(n[t]=!g||t+1<s?d+n[t]*p:1,a){const s=2*t,i=e.getCoord2D(n[t]);a[s].setCoordsPoint2D(i),s>0&&Ye(a.slice(s-2))}}return o}}return Mi(!0,e,s,0,r,a,m)}if(h===e.GeometryType.enumBezier){const e=t;if(!e.isMonotoneQuickAndDirty()){const i=n.makePrimitiveArray(6,Number.NaN);let r=e.getMonotonicPartParams(i.length,i);i.length=r,r=Si(t,0,i);let o=0;if(r>2){const t=new qr,n=m||[];for(let h=1;h<r;h++){const u=i[h-1],l=i[h];e.queryCut(u,l,t,!0);const c=n.length;o+=Xi(1===h,t.get(),s,0,0,a,m);const g=h===r-1,d=i[h-1];for(let t=c,s=n.length;t<s;t++)if(n[t]=!g||t+1<s?d+n[t]:1,a){const s=2*t,i=e.getCoord2D(n[t]);a[s].setCoordsPoint2D(i),s>0&&Ye(a.slice(s-2))}}return o}}return Xi(!0,e,s,0,0,a,m)}if(h===e.GeometryType.enumRationalBezier2){const e=t;if(!e.isMonotoneQuickAndDirty()){const i=n.makePrimitiveArray(6,Number.NaN);let r=e.getMonotonicPartParams(i.length,i);i.length=r,r=Si(t,0,i);let o=0;if(r>2){const t=new qr,n=m||[];for(let h=1;h<r;h++){const u=i[h-1],l=i[h];e.queryCut(u,l,t,!0);const c=n.length;o+=Ni(1===h,t.get(),s,0,0,a,m);const g=h===r-1,d=i[h-1];for(let t=c,s=n.length;t<s;t++)if(n[t]=!g||t+1<s?d+n[t]:1,a){const s=2*t,i=e.getCoord2D(n[t]);a[s].setCoordsPoint2D(i),s>0&&Ye(a.slice(s-2))}}return o}}return Ni(!0,e,s,0,0,a,m)}e.throwNotImplementedException("")}(i,r,0,o,0,m,h),l=new Ot;let c=a;const g=i.getDescription();l.assignVertexDescription(g);const d=g.getAttributeCount()>1,p=new s.Point,_=new Nr;for(let e=0,s=0;e<u;e++){if(m[s+1].isNAN()){if(d){let t=h[e];i.queryCoord(t,p),_.setStart(p),t=h[e+1],i.queryCoord(t,p),_.setEnd(p)}_.setStartXY(m[s]),_.setEndXY(m[s+2]),t.addSegment(_,c)}else{if(d){let t=h[e];i.queryCoord(t,p),l.setStart(p),t=h[e+1],i.queryCoord(t,p),l.setEnd(p)}l.setStartXY(m[s]),l.setControlPoint1(m[s+1]),l.setEndXY(m[s+2]),t.addSegment(l,c)}s+=2,c=!1}}function Mi(t,e,s,o,a,m,h,u){const l=e.clone();l.dropAllAttributes();const c=(t,e,s,i)=>(e&&(t&&e.push(i.getStartXY()),e.push(n.Point2D.getNAN()),e.push(n.Point2D.getNAN()),e.push(i.getEndXY())),s&&(t&&s.push(0),s.push(1)),1);if(l.isDegenerateToLine()||l.isDegenerate(0))return c(t,m,h,e);const g=l.getStartXY(),d=l.getEndXY(),p=l.getSemiAxes(),_=new r.Transformation2D;if(l.isCircular())_.setIdentity();else{const t=l.getAxisXRotation();_.setScaleCoords(1,l.getMinorMajorRatio()),_.rotateAngle(t)}const P=l.getCenter();_.shift(P);const f=_.clone();f.invertThis(),l.applyTransformation(f);const y=l.getSweepAngle();if(0===y)return c(t,m,h,e);const x=i.Envelope2D.constructEmpty();x.setCoords({center:P,width:2*p.x,height:2*p.x});const D=.05*x.calculateToleranceFromEnvelope(),v=Math.max(s/p.x,D/p.x);let E=4*Math.pow(v/.0741,1/6);E=Math.min(E,Math.PI/2);const C=fi(l.getStartAngle());let b=y>0?Math.floor(C/E):Math.ceil(C/E);b*=E;const A=y>0?E:-E;b+A===C&&(b+=A);let w=4/3*Math.tan(Math.abs(E)/4);y>0&&(w=-w),h&&t&&h.push(0);const S=E/Math.abs(y);let T=(b-C)/y;const I=g.clone(),M=new n.Point2D;l.queryCoord2D(0,M);const N=M.clone(),q=1-.01*S;let Y=0,X=0;for(;T<1;){let s;if(T+=S,X>0&&T<q)s=w;else{T>=q&&(T=1);const t=(T-X)*y;s=4/3*Math.tan(Math.abs(t)/4),y>0&&(s=-s)}l.queryCoord2D(T,M);const i=new n.Point2D;_.queryTransform(M,i);const r=e.getClosestCoordinate(i,!1);if(e.queryCoord2D(r,i),1!==T&&(n.Point2D.distance(I,i)<=2*o||n.Point2D.distance(i,d)<=2*o))continue;I.setCoordsPoint2D(i);const u=n.makeObjectArray(n.Point2D,4);u[0].assign(N),u[3].assign(M),u[1].rightPerpendicularOther(N),u[1].scaleAddThis(s,N),u[2].leftPerpendicularOther(M),u[2].scaleAddThis(s,M),_.transformPoints2D(u,3,u),u[3].assign(i),0===X&&u[0].setCoordsPoint2D(g),1===T&&u[3].setCoordsPoint2D(d),a&&Fs(u);let c=!0;for(let t=1;t<4;t++)if(!u[t].isEqualPoint2D(u[0])){c=!1;break}c||(h&&h.push(r),m&&(0===X&&t&&m.push(u[0].clone()),m.push(u[1].clone()),m.push(u[2].clone()),m.push(u[3].clone())),Y++),X=T,N.setCoordsPoint2D(M)}return Y}function Ni(t,e,s,r,o,a,m,h){e.clone().dropAllAttributes();const u=new i.Envelope2D;e.queryLooseEnvelope(u);const l=.05*u.calculateToleranceFromEnvelope(),c=Math.max(s,l);m&&t&&m.push(0);let g=0;const d=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(d);const p=[0,0,0];e.queryWeights(p);const _=[],P=n.makePrimitiveArray(9,Number.NaN);let f=e.getMonotonicPartParams(P.length,P);P.length=f,f=Si(e,r,P);let y=0,x=t;for(let t=1;t<f;t++){const e=P[t];for(_.push(y),_.push(e);_.length>1;){const t=_.at(-1);_.pop();const e=_.at(-1),s=n.makeObjectArray(n.Point2D,3);Bn(d,p,t,e,s,[0,0,0]);const i=n.makeObjectArray(n.Point2D,3),r=We(s,p,i),o=16,h=_.length>o;c>=r||h?(m.push(e),a&&(x&&(a.push(i[0]),x=!1),a.push(i[1]),a.push(i[2])),g++):(_.push(.5*(t+e)),_.push(t))}y=e}return g}function qi(t,e,s,r,o,a,m,h){e.clone().dropAllAttributes();const u=new i.Envelope2D;e.queryLooseEnvelope(u);const l=.05*u.calculateToleranceFromEnvelope(),c=Math.max(s,l);m&&t&&m.push(0);let g=0;const d=n.makeObjectArray(n.Point2D,3);e.queryControlPoints(d);const p=[0,0,0];e.queryWeights(p);const _=[],P=n.makePrimitiveArray(9,Number.NaN);let f=0;o?(f=e.getMonotonicPartParams(P.length,P),P.length=f,f=Si(e,r,P)):(P.length=2,f=2,P[0]=0,P[1]=1);let y=0,x=t;for(let t=1;t<f;t++){const e=P[t];for(_.length=0,_.push(e),_.push(y);_.length>1;){const t=_.at(-1);_.pop();const e=_.at(-1),s=n.makeObjectArray(n.Point2D,3),i=[0,0,0];Bn(d,p,t,e,s,i);const r=n.makeObjectArray(n.Point2D,4),o=Wn(s,i,r),h=16,u=_.length>h;c>=o||u?(m.push(e),a&&(x&&(a.push(r[0]),x=!1),a.push(r[1]),a.push(r[2]),a.push(r[3])),g++):(_.push(.5*(t+e)),_.push(t))}y=e}return g}function Yi(t,e,s,o,a,m,h,u){const l=e.clone();if(l.dropAllAttributes(),l.isDegenerateToLine()||0===l.getSweepAngle())return m&&(t&&m.push(e.getStartXY()),m.push(n.Point2D.getNAN()),m.push(e.getEndXY())),h&&(t&&h.push(0),h.push(1)),1;const c=l.getStartXY(),g=l.getEndXY(),d=l.getSemiAxes(),p=new r.Transformation2D;if(l.isCircular())p.setIdentity();else{const t=l.getAxisXRotation();p.setScaleCoords(1,l.getMinorMajorRatio()),p.rotateAngle(t)}const _=l.getCenter();p.shift(_);const P=p.clone();P.invertThis(),l.applyTransformation(P);const f=i.Envelope2D.constructEmpty();f.setCoords({center:_,width:2*d.x,height:2*d.x});const y=.05*f.calculateToleranceFromEnvelope(),x=Math.max(s/d.x,y/d.x),D=Math.sqrt(2*x+x*x);let v=2*Math.sqrt(2*D*(1+x-D));v=Math.min(v,Math.PI/2);const E=l.getSweepAngle(),C=Math.ceil(Math.abs(E)/v),b=Math.max(C,1);v=E/b;const A=1/b;let w=Math.tan(Math.abs(v)/2);E>0&&(w=-w),h&&t&&h.push(0);const S=new n.Point2D;l.queryCoord2D(0,S);for(let e=0;e<b;e++){const s=S.clone(),i=(e+1)*A;if(h&&h.push(i),!m)continue;l.queryCoord2D(i,S);const r=n.makeObjectArray(n.Point2D,3);r[0].assign(s),r[2].assign(S),r[1].rightPerpendicularOther(r[0]),r[1].mulThis(w),r[1].addThis(r[0]),p.transformPoints2D(r,3,r),0===e&&r[0].setCoordsPoint2D(c),e===b-1&&r[2].setCoordsPoint2D(g),0===e&&t&&m.push(r[0]),m.push(r[1]),m.push(r[2])}return b}function Xi(t,e,s,r,o,a,m,h){e.clone().dropAllAttributes();const u=new i.Envelope2D;e.queryLooseEnvelope(u);const l=.05*u.calculateToleranceFromEnvelope(),c=Math.max(s,l);m&&t&&m.push(0);let g=0;const d=n.makeObjectArray(n.Point2D,4);e.queryControlPoints(d);const p=[],_=n.makePrimitiveArray(9,Number.NaN);let P=e.getMonotonicPartParams(_.length,_);_.length=P,P=Si(e,r,_);let f=0,y=t;for(let t=1;t<P;t++){const e=_[t];for(p.push(f),p.push(e);p.length>1;){const t=p.at(-1);p.pop();const e=p.at(-1),s=n.makeObjectArray(n.Point2D,4);Ls(d,t,e,s);const i=n.makeObjectArray(n.Point2D,3),r=Be(s,i),o=16,h=p.length>o;c>=r||h?(m.push(e),a&&(y&&(a.push(i[0]),y=!1),a.push(i[1]),a.push(i[2])),g++):(p.push(.5*(t+e)),p.push(t))}f=e}return g}class Ri{constructor(t,e){this.m_arc=t,this.m_sqrChordLength=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?n.Point2D.sqrDistance(this.m_arc.getCoord2D(e),this.m_arc.getCoord2D(1-e))-this.m_sqrChordLength:0}getError(t){return 0}}function Fi(t,e){return t.convertToCanonic(e)}function Vi(t,e,s,i){let r=t.m_startAngle,o=t.m_sweepAngle;const a=1e-12;for(;r>n.pi();)r-=2*n.pi();for(;r<=-n.pi();)r+=2*n.pi();if(!Number.isNaN(e)){for(;e>n.pi();)e-=2*n.pi();for(;e<=-n.pi();)e+=2*n.pi();!s&&e>r&&(e-=2*n.pi()),s&&e<r&&(e+=2*n.pi()),o=e-r,Math.abs(o)<a&&!i&&(o=s?2*n.pi():-2*n.pi()),Math.abs(o)>2*n.pi()-a&&i&&(o=0)}Math.abs(o)>2*n.pi()-a&&(o=o>=0?2*n.pi():-2*n.pi(),t.setEndXY(t.getStartXY())),Math.abs(o)<a&&(o=0,t.setEndXY(t.getStartXY())),i=Math.abs(o)<=n.pi(),o&&(s=o>0),t.m_startAngle=ki(r),t.m_sweepAngle=o,or(t,!i),ir(t,s)}function ki(t){let e=t,s=!1;return e<=-n.pi()?(e+=n.twoPi(),s=!0):e>n.pi()&&(e-=n.twoPi(),s=!0),e<=-n.pi()?(e=n.fmod(e,n.twoPi()),e<=-n.pi()&&(e+=n.twoPi()),s=!0):e>n.pi()&&(e=n.fmod(e,n.twoPi()),e>n.pi()&&(e-=n.twoPi()),s=!0),s&&(e>n.pi()||e<=-n.pi())&&(e=n.pi()),e}function Li(t,e,s){const i=s,r=i.getSemiAxes();let o=new n.Point2D(r.x*Math.cos(t[0]),r.y*Math.sin(t[0]));return o=i.convertFromCanonic(o),n.Point2D.sqrDistance(o,i.getStartXY())}function zi(t,e,s){const i=s,r=i.getSemiAxes(),o=t[0]+i.getStartAngle();let a=new n.Point2D(r.x*Math.cos(o),r.y*Math.sin(o));return a=i.convertFromCanonic(a),n.Point2D.sqrDistance(a,i.getEndXY())}function Gi(t){if(t.m_center.isNAN())return t.m_startAngle=0,void(t.m_sweepAngle=0);const e=t.getStartXY(),s=t.getEndXY(),i=e.equals(s),r=ar(t),o=rr(t),a=t.projectionBehavior();if(i){const s=t.convertToCanonic(e),i=new n.Point2D(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);s.x/=i.x,s.y/=i.y,t.m_startAngle=ki(Math.atan2(s.y,s.x)),t.m_sweepAngle=r?o?n.twoPi():-n.twoPi():0}else{const i=t.convertToCanonic(e),m=new n.Point2D(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);i.x/=m.x,i.y/=m.y;const h=t.convertToCanonic(s);h.x/=m.x,h.y/=m.y,t.m_startAngle=Math.atan2(i.y,i.x),t.m_sweepAngle=n.Point2D.calculateAngle(i,h),o?t.m_sweepAngle<0&&(t.m_sweepAngle+=n.twoPi()):t.m_sweepAngle>0&&(t.m_sweepAngle-=n.twoPi()),t.m_startAngle=ki(t.m_startAngle);let u=Li([t.m_startAngle],0,t);if(u=Math.sqrt(u),u>.25*V(t)){const e=t.m_startAngle-1e-4,s=t.m_startAngle+1e-4,n=[0];At(Li,t,1,[t.m_startAngle],[e],[s],0,n),t.m_startAngle=ki(n[0])}if(u=zi([t.m_sweepAngle],0,t),u=Math.sqrt(u),u>.25*V(t)){const e=t.m_sweepAngle-1e-4,s=t.m_sweepAngle+1e-4,n=[0];At(zi,t,1,[t.m_sweepAngle],[e],[s],0,n),t.m_sweepAngle=n[0]}const l=Math.abs(t.m_sweepAngle)>n.pi();if(or(t,l),r!==l&&!r&&Math.abs(t.m_sweepAngle)>1.5*n.pi())return void Qi(t,e,s,a);if(0===t.m_sweepAngle||o!==t.m_sweepAngle>0)return void Qi(t,e,s,a)}}function Oi(t,e){const s=function(t,e){const s=new n.Envelope1D(t.getStartAngle(),t.getEndAngle());s.normalize();const i=n.twoPi(),r=n.fmod(e,i);if(r<s.vmin){let t=r+i;for(;t<s.vmin;)t+=i;return s.containsCoordinate(t)?t:s.vmin-r<t-s.vmax?r:t}if(r>s.vmax){let t=r-i;for(;t>s.vmax;)t-=i;return s.containsCoordinate(t)||s.vmin-t<r-s.vmax?t:r}return r}(t,e);return(s-t.getStartAngle())/t.getSweepAngle()}function ji(t,e){return t.m_startAngle+e*t.m_sweepAngle}function Bi(t,e,s){s.assign(new n.ECoordinate(t.m_startAngle).addE(e.mulE(new n.ECoordinate(t.m_sweepAngle))))}function Wi(t){return t.m_cachedValues}function Hi(t){if(t.m_cachedValues)return t.m_cachedValues;const e={e2:0,completeE:0};return e.e2=function(t){return 1-n.sqr(t.m_minorMajorRatio)}(t),e.completeE=n.completeEllipticE(e.e2),t.m_cachedValues=e,e}function Zi(t,e,s,i){if(!e.isEqual(t.m_XStart,t.m_YStart)||!s.isEqual(t.m_XEnd,t.m_YEnd)){if($i(t))return t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,pr(t),void t.afterCompletedModification();if(i&&Math.abs(t.getSweepAngle())<=1.01*n.halfPi()){const i=n.makeObjectArray(n.Point2D,3),r=lr(t,i);if(zn(i)){if(i[0].assign(e),i[2].assign(s),On(i),0===t.projectionBehavior()){let e=0,s=2;n.Point2D.sqrDistance(i[1],i[0])<n.Point2D.sqrDistance(i[1],i[2])&&(s=n.swap(e,e=s));const r=i[s].sub(i[e]),o=r.length();r.divThis(o);const a=i[1].sub(i[e]),m=a.length(),h=a.dotProduct(r)/m,u=a.crossProduct(r)/m,l=new n.Point2D;n.lerpPoint2D(i[e],i[s],.5,l);const c=.5*o/u*n.snap(1-h,0,1),g=i[1].side(i[e],i[s]),d=r.clone();g?d.leftPerpendicularThis():d.rightPerpendicularThis();const p=l.sub(d.mul(c));t.constructCircularArcThreePoint(i[0],i[2],p)}else cr(i,r*r,null,!1,t);return}}0===t.projectionBehavior()?function(t,e,s){const i=t.getStartXY(),o=t.getEndXY(),a=i.equals(o),m=e.equals(s);if(!a&&!m){const a=new r.Transformation2D;a.setShiftCoords(-t.m_XStart,-t.m_YStart);const m=n.Point2D.distance(e,s),h=n.Point2D.distance(i,o),u=m/h;a.scale(u,u);const l=o.sub(i);l.divThis(h);const c=s.sub(e);c.divThis(m);const g=l.crossProduct(c),d=c.dotProduct(l);return a.rotate(d,g),a.shiftCoords(e.x,e.y),void tr(t,a,!0,e,s)}const h=new n.Point2D;if(t.queryCoord2D(.5,h),m){if(a){const n=t.m_center.add(e.sub(i));t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),1,0,!0,!t.isClockwise(),n),t.setProjectionBehavior(0)}else if(t.isMajor()){const n=h.sub(e).getUnitVector().mul(2*t.getSemiMajorAxis()).add(e);t.constructCircularArcThreePoint(e,s,n)}else t.constructCircularArcThreePoint(e,s,e);return}const u=e.add(s).mul(.5),l=s.sub(e);l.rightPerpendicularThis();const c=u.add(l),g=n.Point2D.getClosestCoordinate(u,c,t.getCenter(),!0),d=new n.Point2D;n.lerpPoint2D(u,c,g,d);const p=n.Point2D.distance(e,d);t.constructEllipticArcEndPointsCenter(e,s,p,1,0,!0,!t.isClockwise(),d),t.setProjectionBehavior(0)}(t,e,s):vr(t,e,s)}}function Ui(t,e,s,n,i,r,o,a,m){return t.m_bits=0,t.m_rotation=r,w(t,e),T(t,s),t.m_cosr=Math.cos(r),t.m_sinr=Math.sin(r),or(t,o),ir(t,a),void 0!==m?t.m_center.assign(m):t.m_center.setNAN(),t.setProjectionBehavior(1),t.m_semiMajorAxis=n,t.m_minorMajorRatio=i,ur(t,void 0===m)}function Qi(t,e,s,n){t.m_bits=0,t.m_rotation=0,w(t,e),T(t,s),t.m_interior.assign(e.add(s).mul(.5)),t.m_startAngle=0,t.m_sweepAngle=0,t.m_cosr=1,t.m_sinr=0,or(t,!1),ir(t,!1),t.m_center.setNAN(),t.m_semiMajorAxis=1,t.m_minorMajorRatio=0,t.setProjectionBehavior(n),t.afterCompletedModification()}function $i(t){return t.m_center.isNAN()}function Ki(t,e){if(0===e)return 0;const s=Hi(t),i=ji(t,e),r=n.halfPi(),o=Ji(t),a=n.ellipticE(i+r,s.e2,s.completeE),m=t.m_semiMajorAxis*(a-o);return Math.abs(m)}function Ji(t){const e=Hi(t);return n.ellipticE(t.getStartAngle()+n.halfPi(),e.e2,e.completeE)}function tr(t,s,i,r,o){if(2===s.m_TransformationType)return void e.geometryReleaseAssert(0);if(e.geometryReleaseAssert(!mr(t)),s.isIdentity()&&(!r||r.equals(t.getStartXY())&&o.equals(t.getEndXY())))return;nr(t);let a=n.Point2D.getNAN(),m=n.Point2D.getNAN();if(null===r?(a.x=t.m_XStart,a.y=t.m_YStart,s.transformInPlace(a),m.x=t.m_XEnd,m.y=t.m_YEnd,s.transformInPlace(m)):(a=r,m=o),$i(t))return t.m_XStart=a.x,t.m_YStart=a.y,t.m_XEnd=m.x,void(t.m_YEnd=m.y);const h=t.m_center.clone();if(s.transformInPlace(h),i||s.isUniformNoRotation()){let e=rr(t);if(s.isReflective()&&(e=!e),0===t.projectionBehavior()){if(!a.equals(m)){const e=t.m_interior.clone();return s.transformInPlace(e),void t.constructCircularArcThreePoint(a,m,e)}return void er(t,a,m,h,e,!1)}const i=new n.Point2D(t.m_cosr,t.m_sinr);s.transformWithoutTranslateInPlace(i);const r=Math.atan2(i.y,i.x),o=t.getSemiAxes();s.transformWithoutTranslateInPlace(o);const u=t.m_center.clone();return s.transformInPlace(u),void t.constructEllipticArcEndPointsCenter(a,m,o.x,o.y/o.x,r,t.isMajor(),e,u)}{{const e=new Array(4);!function(t,e){const s=new n.ECoordinate(t.m_cosr).sqrThis(),i=new n.ECoordinate(t.m_sinr).sqrThis(),r=new n.ECoordinate(t.m_minorMajorRatio),o=new n.ECoordinate(1/t.m_minorMajorRatio),a=r.mulE(s).addThisE(o.mulE(i)),m=r.subE(o).mulThis(2*t.m_cosr*t.m_sinr),h=r.mulE(i).addThisE(o.mulE(s));e[0]=a,e[1]=m,e[2]=h,e[3]=new n.ECoordinate(-t.m_semiMajorAxis).mulThis(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio)}(t,e);const i=new y;if(i.a11.setE(e[0]),i.a12.setE(e[1]),i.a12.mulThisByPower2(.5),i.a21.setE(i.a12),i.a22.setE(e[2]),!i.det().isZero()){const r=new y;if(r.a11.set(s.xx),r.a12.set(s.xy),r.a21.set(s.yx),r.a22.set(s.yy),r.invertThis()){const o=r.clone();o.transposeThis();const u=i.clone();if(u.mulThis(r),u.mulLeftThis(o),!u.det().isZero()){const i=n.makeObjectArray(n.ECoordinate,4);i[0].setE(u.a11),i[1].setE(u.a12),i[1].mulThisByPower2(2),i[2].setE(u.a22),i[3].setE(e[3]);const r=n.Point2D.getNAN(),o=function(t,e){const s=new y;s.a11.setE(t[0]),s.a12=n.ECoordinate.st_mulByPower2(t[1],.5),s.a21.setE(s.a12),s.a22.setE(t[2]);const i=[n.Point2D.getNAN(),n.Point2D.getNAN()],r=[new n.ECoordinate,new n.ECoordinate];s.eigenSymmetric(r,i);const o=t[3].clone();return o.negateThis(),o.invThis(),r[0].mulThisE(o),r[1].mulThisE(o),r[0].sqrtThis().invThis(),r[1].sqrtThis().invThis(),e.x=r[0].toDouble(),e.y=r[1].toDouble(),Math.atan2(i[0].y,i[0].x)}(i,r);let l=rr(t);return s.isReflective()&&(l=!l),void t.constructEllipticArcEndPointsCenter(a,m,r.x,r.y/r.x,o,t.isMajor(),l,h)}}}}const e=[n.Point2D.getNAN(),n.Point2D.getNAN(),n.Point2D.getNAN()];e[0].setCoords(t.getSemiMajorAxis(),0),e[0].rotateDirect(t.m_cosr,t.m_sinr),e[1].setCoords(t.getSemiMajorAxis(),t.getSemiMinorAxis()),e[1].rotateDirect(t.m_cosr,t.m_sinr),e[2].setCoords(0,t.getSemiMinorAxis()),e[2].rotateDirect(t.m_cosr,t.m_sinr);let i=t.isClockwise();i&&(e[2]=n.swap(e[0],e[0]=e[2]));const r=.5;s.transformWithoutTranslateArray(e,3,e),s.isReflective()&&(i=!i);const o=new n.Point2D(0,0),u=t.createInstance();cr(e,r,o,!1,u),t.constructEllipticArcEndPointsCenter(a,m,u.getSemiMajorAxis(),u.getMinorMajorRatio(),u.getAxisXRotation(),t.isMajor(),!i,h)}}function er(t,e,s,n,i,r){const o=.5*(n.sub(e).length()+n.sub(s).length());t.m_center.assign(n),t.m_startAngle=Math.atan2(e.y-t.m_center.y,e.x-t.m_center.x),Vi(t,Math.atan2(s.y-t.m_center.y,s.x-t.m_center.x),i,r);const a=t.constructEllipticArcEndPointsCenter(e,s,o,1,0,Math.abs(t.m_sweepAngle)>Math.PI,t.m_sweepAngle>0,n);return t.setProjectionBehavior(0),a}function sr(t,e){t.m_cachedValues=e}function nr(t){t.m_cachedValues=null}function ir(t,e){const s=e?1:0;t.m_bits=-2&t.m_bits|s}function rr(t){return!!(1&t.m_bits)}function or(t,e){const s=e?1:0;t.m_bits=-3&t.m_bits|s<<1}function ar(t){return!!(2&t.m_bits)}function mr(t){return!!(8&t.m_bits)}function hr(t){t.m_bits&=-9}function ur(t,s){hr(t);const i=t.getStartXY(),r=t.getEndXY();let o=!1;const a=ar(t),m=rr(t),h=t.projectionBehavior(),u=i.equals(r);let l=0===t.m_minorMajorRatio||0===t.m_semiMajorAxis;if(Number.isNaN(t.m_minorMajorRatio)&&(0===t.m_semiMajorAxis?t.m_minorMajorRatio=1:e.throwCorruptedGeometryException("NAN minor major ratio and non-zero major axis")),l||=s?u:t.m_center.isNAN(),l)return Qi(t,i,r,h),!0;t.m_semiMajorAxis=Math.abs(t.m_semiMajorAxis),t.m_minorMajorRatio=Math.abs(t.m_minorMajorRatio),t.m_minorMajorRatio>1&&(t.m_semiMajorAxis*=t.m_minorMajorRatio,t.m_minorMajorRatio=1/t.m_minorMajorRatio);const c=new n.Point2D(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);if(e.geometryReleaseAssert(c.y>0&&c.x>=c.y),u){const s=t.convertToCanonic(i);e.geometryReleaseAssert(!c.isZero()),s.x/=c.x,s.y/=c.y;const r=Math.sqrt(n.sqr(s.x)+n.sqr(s.y));if(o=1!==r,t.m_semiMajorAxis*=r,c.mulThis(r),t.m_startAngle=ki(Math.atan2(s.y,s.x)),!a)return t.m_interior.assign(i),t.m_sweepAngle=0,t.afterCompletedModification(),o;t.m_sweepAngle=m?n.twoPi():-n.twoPi()}else{let e=t.m_center.isNAN()||function(t){if(t.m_center.isNAN())return!1;const e=new f;e.setWithEps(t.getStartXY(),8),e.subThisE((new f).setWithEps(t.m_center,8));const s=new n.ECoordinate;s.setWithEps(t.m_rotation,8);const i=new n.ECoordinate,r=new n.ECoordinate;n.ECoordinate.st_cosAndSin(s,i,r),e.rotateReverse(i,r);const o=new f;o.setWithEps(t.getEndXY()),o.subThisE(f.constructPoint2D(t.m_center)),o.rotateReverse(i,r);const a=new n.ECoordinate;a.setWithEps(t.m_semiMajorAxis,8);const m=a.clone(),h=new n.ECoordinate;h.setWithEps(t.m_minorMajorRatio),m.mulThisE(h),e.x.divThisE(a),e.y.divThisE(m),o.x.divThisE(a),o.y.divThisE(m);const u=e.x.sqr().addThisE(e.y.sqr()).subThisE(n.s_one),l=o.x.sqr().addThisE(o.y.sqr()).subThisE(n.s_one);return!u.isZero()||!l.isZero()}(t);if(!e){const s=t.convertToCanonic(i);s.x/=c.x,s.y/=c.y;const o=new n.Point2D(1,0);t.m_startAngle=n.Point2D.calculateAngle(o,s);const a=t.convertToCanonic(r);a.x/=c.x,a.y/=c.y,t.m_sweepAngle=n.Point2D.calculateAngle(s,a),e=!gr(t)}if(e){o=!0;const e=i.sub(r).mulThis(.5);e.rotateReverse(t.m_cosr,t.m_sinr);let s=n.sqr(e.x/c.x)+n.sqr(e.y/c.y);s>1&&(s=Math.sqrt(s),t.m_semiMajorAxis*=s,c.mulThis(s));const h=new n.Point2D(0,0);{const t=c.x*c.x,s=c.y*c.y,n=t*e.y*e.y+s*e.x*e.x,i=t*s-n;if(i>0){const t=Math.sqrt(i/n);h.setCoords(c.x*e.y/c.y,-c.y*e.x/c.x),h.mulThis(t),a===m&&h.negateThis()}}{const e=new n.Point2D(h.x,h.y);e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(i.add(r).mulThis(.5)),t.m_center.assign(e)}}if(Gi(t),!gr(t))return Qi(t,i,r,h),!0}return pr(t),t.afterCompletedModification(),o}function lr(t,s){e.geometryReleaseAssert(Math.abs(t.getSweepAngle())<15*Math.PI/16);const i=t.getSemiMajorAxis(),r=t.getSemiMinorAxis();let o;if(0===i)return s[0].setCoordsPoint2D(t.getStartXY()),s[1].setCoordsPoint2D(t.getStartXY()),s[2].setCoordsPoint2D(t.getStartXY()),o=1,o;if(0===r)return s[0].setCoordsPoint2D(t.getStartXY()),s[2].setCoordsPoint2D(t.getEndXY()),s[1]=n.Point2D.lerp(s[0],s[2],.5),o=1,o;const a=t.getSweepAngle(),m=t.getStartAngle(),h=m+a,u=new n.Point2D(-i*Math.sin(m),r*Math.cos(m)),l=new n.Point2D(-i*Math.sin(h),r*Math.cos(h));u.normalize(),l.normalize(),u.rotateDirect(t.m_cosr,t.m_sinr),l.rotateDirect(t.m_cosr,t.m_sinr),s[0].setCoordsPoint2D(t.getStartXY()),s[2].setCoordsPoint2D(t.getEndXY()),s[1].setSub(s[2],s[0]);const c=u.crossProduct(l);return s[1].assign(u.mul(s[1].crossProduct(l)/c)),s[1].addThis(s[0]),o=Math.cos(.5*a),o}function cr(t,s,i,r,o){if(r){const e=.5,i=Math.sqrt(s),r=n.sqr(1-e)+2*i*e*(1-e)+n.sqr(e),a=t[0].mul(n.sqr(1-e)).add(t[1].mul(2*i*e*(1-e))).add(t[2].mul(n.sqr(e))).divThis(r);return o.constructCircularArcThreePoint(t[0],t[2],a),!0}const a=t[0].sub(t[1]),m=t[2].sub(t[1]),h=a.crossProduct(m),u=a.dotProduct(m),l=s;e.geometryReleaseAssert(l<=1),e.geometryReleaseAssert(l>0);const c=.5/(1-l),g=a.sqrLength(),d=u,p=m.sqrLength(),_=n.sqr(h),P=a.sub(m).sqrLength();if(0===_)return Qi(o,t[0],t[2],1),!1;if(u<=-Math.sqrt(g)*Math.sqrt(p))return Qi(o,t[0],t[2],1),!1;const f=[0,0],y=new n.Envelope1D;y.setInfinite();const x=Ct(2*_,-(P/l+4*d),2*(1-l)/l,y,!1,f);if(0===x)return Qi(o,t[0],t[2],1),!1;1===x&&(f[1]=f[0]);const D=Math.sqrt(c/f[0]),v=Math.sqrt(c/f[1]),E=.5/l;let C=E-p*f[0],b=E-g*f[0];Math.abs(C)>Math.abs(b)?b=d*f[0]-E+1:C=d*f[0]-E+1;const A=a.mul(C).add(m.mul(b)),w=A.norm(1)<1e-15*D?0:Math.atan2(A.y,A.x)+Math.PI,S=a.add(m),T=i?i.clone():t[1].add(S.mul(c)),I=t[0].sub(T),M=t[2].sub(T),N=I.crossProduct(M)<0;return new Di,o.constructEllipticArcEndPointsCenter(t[0],t[2],D,v/D,w,!1,!N,T)}function gr(t){const e=V(t);let s=!1;{const i=new n.Point2D(t.m_semiMajorAxis*Math.cos(t.m_startAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle));i.rotateDirect(t.m_cosr,t.m_sinr),i.addThis(t.m_center),s=n.Point2D.distance(t.getStartXY(),i)>e}let i=!1;if(!s){const s=new n.Point2D(t.m_semiMajorAxis*Math.cos(t.m_startAngle+t.m_sweepAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle+t.m_sweepAngle));s.rotateDirect(t.m_cosr,t.m_sinr),s.addThis(t.m_center),i=n.Point2D.distance(t.getEndXY(),s)>e}return!s&&!i}function dr(t){if($i(t))return 0;if(t.isDegenerate(0))return 0;const e=t.m_semiMajorAxis,s=t.getSemiMinorAxis(),n=e*e+s*s,i=t.getStartAngle(),r=t.getEndAngle(),o=t.m_center.y-t.m_YStart,a=t.m_cosr,m=t.m_sinr;let h=1,u=0;t.m_rotation&&(h=(a-m)*(a+m),u=2*a*m);const l=((-.5*(r-i)+.25*h*(2*Math.cos(r+i)*Math.sin(r-i)))*s+-2*Math.sin(.5*(r+i))*Math.sin(.5*(r-i))*a*o)*e/n;let c=0;return t.m_rotation&&(c=-2*Math.sin(r+i)*Math.sin(r-i)*.125*u-s*o/n*(2*Math.cos(.5*(r+i))*Math.sin(.5*(r-i)))*m),n*(l+c)+-.5*(t.m_XEnd-t.m_XStart)*(t.m_YEnd-t.m_YStart)}function pr(t){t.queryCoord2D(.5,t.m_interior)}function _r(t,e,s,n,i){if(i){if(0!==br(e,s))return 2}else if(E(e,s))return 1;return 0!==Pr(t,e,s,null,null,null,n,void 0!==i&&i,0,!1)?4:0}function Pr(t,s,i,r,o,a,m,h,u,l){if($i(s))return st(new Nr({start:s.getStartXY(),end:s.getEndXY()}),i,r,o,a,m,h,l);null!==o&&(o.length=0),null!==a&&(a.length=0),null!==r&&(r.length=0);const c=k(s,i);if(L(s,i,m=Math.max(c,m)))return 0;const g=i.getStartXY();g.subThis(s.m_center);const d=i.getEndXY();d.subThis(s.m_center),g.rotateReverse(s.m_cosr,s.m_sinr),d.rotateReverse(s.m_cosr,s.m_sinr);const p=d.clone();p.subThis(g);const _=s.m_semiMajorAxis,P=1/_,f=s.getSemiMinorAxis(),y=1/f,x=p.clone();x.leftPerpendicularThis();const D=Math.atan2(f*x.y,_*x.x),v=n.makePrimitiveArray(16,Number.NaN),E=n.makePrimitiveArray(16,Number.NaN);let C=0;const b=[D,D+Math.PI];for(let t=0;t<2;++t){const e=Oi(s,b[t]);if(e>=0&&e<=1){v[C]=e;const t=s.getCoord2D(v[C]);E[C]=i.getClosestCoordinate(t,!1),n.Point2D.distance(t,i.getCoord2D(E[C]))<=m&&C++}}const A=g.x*P,w=g.y*y,S=p.x*P,T=p.y*y;let I=Ct(S*S+T*T,2*(A*S+w*T),A*A+w*w-1,n.Envelope1D.unit(),!1,E);e.geometryReleaseAssert(I>=0);for(let t=0;t<I;t++){const e=p.mul(E[t]).add(g);e.x*=P,e.y*=y;const r=Oi(s,Math.atan2(e.y,e.x));if(r>=0&&r<=1){v[C]=r;const t=s.getCoord2D(r);E[C]=i.getClosestCoordinate(t,!1),n.Point2D.distance(t,i.getCoord2D(E[C]))<=m&&C++}}e.geometryReleaseAssert(C<v.length+4);const M=n.makePrimitiveArray(16,Number.NaN);I=s.intersectPoint(i.getStartXY(),M,m);for(let t=0;t<I;t++,C++)v[C]=M[t],E[C]=0;I=s.intersectPoint(i.getEndXY(),M,m);for(let t=0;t<I;t++,C++)v[C]=M[t],E[C]=1;I=i.intersectPoint(s.getStartXY(),M,m);for(let t=0;t<I;t++,C++)v[C]=0,E[C]=M[t];I=i.intersectPoint(s.getEndXY(),M,m);for(let t=0;t<I;t++,C++)v[C]=1,E[C]=M[t];return 0===C?0:Tr(t,s,i,v,E,C,r,o,a,m,h,0,l)}function fr(t,s,i,r,o,a,m,h,u,l){if($i(s)){const e=new Nr({start:s.getStartXY(),end:s.getEndXY()});return Pr(t,i,e,r,a,o,m,h,0,!0)}if($i(i)){const e=new Nr({start:i.getStartXY(),end:i.getEndXY()});return Pr(t,s,e,r,o,a,m,h,0,l)}const c=k(s,i);m=Math.max(m,c);let g=!1;{const t=s.getSemiAxes(),r=s.getCenter(),l=i.getSemiAxes(),c=i.getCenter(),d=n.Point2D.distance(c,r),p=t.x+l.x;if(d>p+m)return 0;if(t.y>l.x){if(d+l.x+m<t.y)return 0}else if(l.y>t.x&&d+t.x+m<l.y)return 0;if(u&&!h){const n=1===s.m_minorMajorRatio&&s.isClosed()&&s.isMajor(),r=1===i.m_minorMajorRatio&&i.isClosed()&&i.isMajor();if(n&&r&&(g=!0,d<=p)&&Math.max(t.x,l.x)<=Math.min(t.x,l.x)+d)return e.geometryReleaseAssert(!o&&!a),1}}if(!g&&L(s,i,m))return 0;const d=[],p=[],_=!1,P=!1,f=Ai(s,0,0,_,P,d,p,null),y=[],x=[],D=Ai(i,0,0,_,P,y,x,null);if(1===f&&1===D){const t=new zt({points:d,weights:p}),e=new zt({points:y,weights:x}),c=[],g=[],_=Kn(!1,t,e,r,null===o?null:c,null===a?null:g,m,h,u,l);if(_>0&&null!==o||null!==a){o&&(o.length=0),a&&(a.length=0);for(let r=0;r<_;++r){if(o)if(n.isOneOf(c[r],0,1))o.push(c[r]);else{const e=t.tToLength(c[r]),n=s.lengthToT(e);o.push(n)}if(a)if(n.isOneOf(g[r],0,1))a.push(g[r]);else{const t=e.tToLength(g[r]),s=i.lengthToT(t);a.push(s)}}}return _}let v=[];const E=[];let C=0;const b=u&&!h;for(let t=0;t<f;t++){const e=new zt({points:d.slice(2*t,2*t+3),weights:p.slice(2*t,2*t+3)});let r=0;for(let o=0;o<D;o++){E.length<=o&&E.push(new zt({points:y.slice(2*o,2*o+3),weights:x.slice(2*o,2*o+3)}));const a=[],h=[],u=b?null:a,l=b?null:h,c=Kn(!1,e,E[o],null,u,l,m,!1,b,!1);if(c>0&&b)return 1;for(let m=0;m<c;++m){if(0===a[m]&&0===t)a[m]=0;else if(1===a[m]&&t===f-1)a[m]=1;else{const t=e.tToLength(a[m])+C,n=s.lengthToT(t);a[m]=n}if(0===h[m]&&0===o)h[m]=0;else if(1===h[m]&&o===D-1)h[m]=1;else{const t=E[o].tToLength(h[m])+r,e=i.lengthToT(t);h[m]=e}v.push(n.makePair(a[m],h[m]))}r+=E[o].calculateLength2D()}C+=e.calculateLength2D()}if(0===v.length)return 0;if(h&&(v=v.filter(t=>!n.isOneOf(t.first,0,1)||!n.isOneOf(t.second,0,1)||!s.getCoord2D(t.first).equals(i.getCoord2D(t.second)))),u)return v.length;const A=[],w=[];for(const t of v)A.push(t.first),w.push(t.second);return Tr(t,s,i,A,w,A.length,r,o,a,m,h,0,l)}function yr(t,e,s){if(s.setCoords(t.getCoord2D(e.vmin)),s.mergeNe(t.getCoord2D(e.vmax)),$i(t))return;const i=t.getSemiAxes(),r=[0,0,0,0];{const e=Math.atan2(-i.y*t.m_sinr,i.x*t.m_cosr),s=e+Math.PI,n=Math.atan2(i.y*t.m_cosr,i.x*t.m_sinr),o=n+Math.PI;r[0]=Oi(t,e),r[1]=Oi(t,s),r[2]=Oi(t,n),r[3]=Oi(t,o)}const o=new n.Point2D;for(let n=0;n<4;n++){const i=r[n];e.containsExclusiveCoordinate(i)&&(t.queryCoord2D(i,o),s.mergeNe(o))}}function xr(t,s,i,r,o){if(0===t.m_semiMajorAxis)return i.vmin;let a=n.Point2D.getNAN();t.queryCoord2D(i.vmin,a);let m=n.Point2D.getNAN();if(t.queryCoord2D(i.vmax,m),$i(t))return new Nr({start:a,end:m}).getClosestCoordinate(s,r);const h=Fi(t,s);if(a=Fi(t,a),m=Fi(t,m),1===t.m_minorMajorRatio){if(h.isEqual(0,0))return i.vmin;const e=Oi(t,Math.atan2(h.y,h.x));return r||i.containsCoordinate(e)?e:n.Point2D.distance(h,a)<=n.Point2D.distance(h,m)?i.vmin:i.vmax}const u=t.getSemiMajorAxis(),l=t.getSemiMinorAxis(),c=(u-l)*(u+l),g=n.sqr(c),d=h.x,p=h.y,_=n.sqr(l*p),P=l*c*p*2,f=[new n.ECoordinate(_),new n.ECoordinate(P),new n.ECoordinate(g-n.sqr(u*d)-_),new n.ECoordinate(-P),new n.ECoordinate(-g)],y=n.makeObjectArray(n.ECoordinate,4),x=qt(f,4,new n.Envelope1D(-1,1),!1,y,4);let D=i.vmin,v=n.Point2D.sqrDistance(h,a);{const t=n.Point2D.sqrDistance(h,m);t<v&&(D=i.vmax,v=t)}e.geometryReleaseAssert(!r);let E=n.makePrimitiveArray(8,Number.NaN);for(let e=0;e<x;++e){const s=y[e].value(),n=Math.sqrt(1-s*s),i=Math.atan2(s,n),r=Math.atan2(s,-n);E[2*e]=Oi(t,i),E[2*e+1]=Oi(t,r)}E=E.slice(0,2*x),n.numericSort(E);for(let e=0,r=2*x;e<r;++e)if(E[e]>i.vmin&&E[e]<i.vmax){const i=n.Point2D.sqrDistance(s,t.getCoord2D(E[e]));v>i&&(v=i,D=E[e])}return D}function Dr(t,e,s){return t.m_semiMajorAxis===e.m_semiMajorAxis&&t.isMajor()!==e.isMajor()&&!!t.m_center.equals(e.m_center)&&t.m_sinr===e.m_sinr&&t.m_cosr===e.m_cosr&&t.m_minorMajorRatio===e.m_minorMajorRatio&&(s?t.isClockwise()!==e.isClockwise():t.isClockwise()===e.isClockwise())}function vr(t,s,i,o){const a=t.getStartXY(),m=t.getEndXY(),h=a.equals(m),u=s.equals(i);if(!h&&!u){const e=new r.Transformation2D;return e.initializeFromTwoPoints(a,m,s,i),tr(t,e,!0,s,i),t.endPointModified(),void t.normalizeAfterEndpointChange()}if(!t.isMajor())return void Qi(t,s,i,1);if(h&&u){const e=t.m_center.add(s.sub(a));return void t.constructEllipticArcEndPointsCenter(s,i,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),e)}if(!h){const e=.5*(n.twoPi()-Math.abs(t.getSweepAngle())),r=(t.getSweepAngle()+e*n.sign(t.getSweepAngle()))/t.getSweepAngle(),o=new n.Point2D;t.queryCoord2D(r,o),t.constructEllipticArcEndPointsCenter(o,o,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.getCenter());const a=t.getCenter().add(s.sub(o));return void t.constructEllipticArcEndPointsCenter(s,i,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),a)}const l=n.Point2D.sqrDistance(s,i);let c=.25,g=.75;if(l<n.Point2D.sqrDistance(t.getCoord2D(.25),t.getCoord2D(.75))){const s=[0],i=Et(new Ri(t,l),n.Envelope1D.construct(0,.25),1,s);i>0&&(e.geometryReleaseAssert(1===i),c=s[0],g=1-s[0])}const d=t.getCoord2D(c),p=t.getCoord2D(g);e.geometryReleaseAssert(!d.equals(p)),t.constructEllipticArcEndPointsCenter(d,p,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.m_center),vr(t,s,i)}function Er(t,e,s,n,i){return Cr(t,!1,e,s,n,i)}function Cr(t,s,n,i,r,o){const a=n.getGeometryType(),m=i.getGeometryType(),h=Math.max(r,k(n,i));if(a===e.GeometryType.enumLine&&m===e.GeometryType.enumLine)return et(n,i,h,o);let u=n,l=i,c=n.getStartXY(),g=n.getEndXY();if(c.compare(g)>0&&(u=n.clone().reverse()),c=i.getStartXY(),g=i.getEndXY(),c.compare(g)>0&&(l=i.clone().reverse()),s){if(n.equals(i))return 2;if(function(t,s,n){return e.geometryReleaseAssert(t.isCurve()||s.isCurve()),!!(t.getStartXY().equals(s.getStartXY())&&A(t,s,0,0,n,2,[0,0],[0,0])||t.getEndXY().equals(s.getEndXY())&&A(t,s,1,1,n,2,[0,0],[0,0])||t.getStartXY().equals(s.getEndXY())&&A(t,s,0,1,n,2,[0,0],[0,0])||t.getEndXY().equals(s.getStartXY())&&A(t,s,1,0,n,2,[0,0],[0,0]))}(n,i,h))return 4}switch(a){case e.GeometryType.enumLine:switch(m){case e.GeometryType.enumEllipticArc:return _r(t,l,u,h,o);case e.GeometryType.enumBezier:return js(t,l,u,h,o);case e.GeometryType.enumRationalBezier2:return Hn(t,l,u,h,o);case e.GeometryType.enumBezier2:return Fe(t,l,u,h,o);default:e.throwInternalErrorException("")}break;case e.GeometryType.enumEllipticArc:switch(m){case e.GeometryType.enumLine:return _r(t,u,l,h,o);case e.GeometryType.enumEllipticArc:return function(t,e,s,n,i){if(i){if(0!==br(e,s))return 2}else if(E(e,s))return 1;return 0!==fr(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,u,l,h,o);case e.GeometryType.enumBezier:return Bs(t,l,u,h,o);case e.GeometryType.enumRationalBezier2:return Zn(t,l,u,h,o);case e.GeometryType.enumBezier2:return Ve(t,l,u,h,o);default:e.throwInternalErrorException("")}break;case e.GeometryType.enumBezier:switch(m){case e.GeometryType.enumLine:return js(t,u,l,h,o);case e.GeometryType.enumEllipticArc:return Bs(t,u,l,h,o);case e.GeometryType.enumBezier:return function(t,e,s,n,i){if(i){if(0!==br(e,s))return 2}else if(E(e,s))return 1;return 0!==Qs(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,u,l,h,o);case e.GeometryType.enumRationalBezier2:return Ws(t,u,l,h,o);case e.GeometryType.enumBezier2:return Hs(t,u,l,h,o);default:e.throwInternalErrorException("")}break;case e.GeometryType.enumRationalBezier2:switch(m){case e.GeometryType.enumLine:return Hn(t,u,l,h,o);case e.GeometryType.enumEllipticArc:return Zn(t,u,l,h,o);case e.GeometryType.enumBezier:return Ws(t,l,u,h,o);case e.GeometryType.enumRationalBezier2:return function(t,e,s,n,i){if(i){const n=br(e,s);if(0!==n){if(t){if(1===n){if(e.m_weights[0]===s.m_weights[0]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[2])return 2}else if(e.m_weights[0]===s.m_weights[2]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[0])return 2;return 4}return 2}}else if(E(e,s))return 1;return 0!==Kn(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}(t,u,l,h,o);case e.GeometryType.enumBezier2:return Un(t,u,l,h,o);default:e.throwInternalErrorException("")}break;case e.GeometryType.enumBezier2:switch(m){case e.GeometryType.enumLine:return Fe(t,u,l,h,o);case e.GeometryType.enumEllipticArc:return Ve(t,u,l,h,o);case e.GeometryType.enumBezier:return Hs(t,l,u,h,o);case e.GeometryType.enumRationalBezier2:return Un(t,l,u,h,o);case e.GeometryType.enumBezier2:return function(t,e,s,n,i){if(i){if(0!==br(e,s))return 2}else if(E(e,s))return 1;return 0!==ze(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}(t,u,l,h,o);default:e.throwInternalErrorException("")}break;default:e.throwInternalErrorException("")}}function br(t,s,n=!0){if(!n&&!Ar(t,s))return 0;const i=t.isLine()&&s.isLine();if(t.getStartXY().equals(s.getStartXY())&&t.getEndXY().equals(s.getEndXY())){const n=1;if(i)return n;const r=t.getGeometryType();if(r!==s.getGeometryType())return 0;if(r===e.GeometryType.enumBezier){const e=t,i=s;return e.getControlPoint1().equals(i.getControlPoint1())&&e.getControlPoint2().equals(i.getControlPoint2())?n:0}if(r===e.GeometryType.enumEllipticArc)return Dr(t,s,!1)?n:0;if(r===e.GeometryType.enumRationalBezier2){const e=t,i=s;if(e.getControlPoint1().equals(i.getControlPoint1())&&e.getStandardFormWeight()===i.getStandardFormWeight())return n}else if(r===e.GeometryType.enumBezier2){const e=s;if(t.getControlPoint1().equals(e.getControlPoint1()))return n}return 0}if(t.getStartXY().equals(s.getEndXY())&&t.getEndXY().equals(s.getStartXY())){const n=-1;if(i)return n;const r=t.getGeometryType();if(r!==s.getGeometryType())return 0;if(r===e.GeometryType.enumBezier){const e=t,i=s;return e.getControlPoint1().equals(i.getControlPoint2())&&e.getControlPoint2().equals(i.getControlPoint1())?n:0}if(r===e.GeometryType.enumEllipticArc)return Dr(t,s,!0)?n:-1;if(r===e.GeometryType.enumRationalBezier2){const e=t,i=s;if(e.getControlPoint1().equals(i.getControlPoint1())&&e.getStandardFormWeight()===i.getStandardFormWeight())return n}else if(r===e.GeometryType.enumBezier2){const e=s;if(t.getControlPoint1().equals(e.getControlPoint1()))return n}return 0}return 0}function Ar(t,s){const n=t.getGeometryType();return n===s.getGeometryType()&&(n!==e.GeometryType.enumEllipticArc||t.projectionBehavior()===s.projectionBehavior())}function wr(t,s,n,i,r,o,a){!r&&o&&e.throwInvalidArgumentException("");const m=s.getGeometryType(),h=n.getGeometryType(),u=Math.max(a,k(s,n));if(i&&(i.length=0),r&&(r.length=0),o&&(o.length=0),m===e.GeometryType.enumLine&&h===e.GeometryType.enumLine)return st(s,n,i,r,o,u,!1,!1);let l=s,c=n,g=s.getStartXY(),d=s.getEndXY(),p=!1,_=!1;g.compare(d)>0&&(l=s.clone(!0).reverse(),p=!0),g=n.getStartXY(),d=n.getEndXY(),g.compare(d)>0&&(c=n.clone(!0).reverse(),_=!0);let P=0;switch(m){case e.GeometryType.enumLine:switch(h){case e.GeometryType.enumEllipticArc:P=Pr(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumBezier:P=Zs(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumRationalBezier2:P=Qn(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumBezier2:P=ke(t,c,l,i,o,r,u,!1,0,!0);break;default:e.throwInternalErrorException("")}break;case e.GeometryType.enumEllipticArc:switch(h){case e.GeometryType.enumLine:P=Pr(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumEllipticArc:P=fr(t,l,c,i,r,o,u,!1,!1,!1);break;case e.GeometryType.enumBezier:P=Us(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumRationalBezier2:P=$n(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumBezier2:P=Le(t,c,l,i,o,r,u,!1,0,!0);break;default:e.throwInternalErrorException("")}break;case e.GeometryType.enumRationalBezier2:switch(h){case e.GeometryType.enumLine:P=Qn(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumEllipticArc:P=$n(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumBezier:P=$s(t,c,l,i,o,r,u,!1,!1,!0);break;case e.GeometryType.enumRationalBezier2:P=Kn(t,l,c,i,r,o,u,!1,!1,!1);break;case e.GeometryType.enumBezier2:P=Jn(t,l,c,i,r,o,u,!1,0,!1);break;default:e.throwInternalErrorException("")}break;case e.GeometryType.enumBezier2:switch(h){case e.GeometryType.enumLine:P=ke(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumEllipticArc:P=Le(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumBezier:P=Ks(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumRationalBezier2:P=Jn(t,c,l,i,o,r,u,!1,0,!0);break;case e.GeometryType.enumBezier2:P=ze(t,l,c,i,r,o,u,!1,!1,!1);break;default:e.throwInternalErrorException("")}break;case e.GeometryType.enumBezier:switch(h){case e.GeometryType.enumLine:P=Zs(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumEllipticArc:P=Us(t,l,c,i,r,o,u,!1,0,!1);break;case e.GeometryType.enumBezier:P=Qs(t,l,c,i,r,o,u,!1,!1,!1);break;case e.GeometryType.enumRationalBezier2:P=$s(t,l,c,i,r,o,u,!1,!1,!1);break;case e.GeometryType.enumBezier2:P=Ks(t,l,c,i,r,o,u,!1,0,!1);break;default:e.throwInternalErrorException("")}break;default:e.throwInternalErrorException("")}if(p){if(r){for(let t=0;t<P;t++)r[t]=1-r[t];r.reverse()}i&&i.reverse(),o&&o.reverse()}if(_&&o)for(let t=0;t<P;t++)o[t]=1-o[t];return P}function Sr(t,e,s){return e===s?0:(e>s&&(s=n.swap(e,e=s)),t.cut(e,s,!0).calculateUpperLength2D())}function Tr(t,e,s,i,r,o,a,m,h,u,l,c,g){if(!o)return 0;const d=(t,e)=>{for(let s=0;s<o;++s){let i=e[s];if(n.isOneOf(i,0,1)){i=n.normalizeSignedZero(i);continue}const r=t.getCoord2D(i);i<.5?r.equals(t.getStartXY())&&Sr(t,0,i)<=V(t)&&(e[s]=0):r.equals(t.getEndXY())&&Sr(t,i,1)<=V(t)&&(e[s]=1)}};d(e,i),d(s,r),function(t,e,s,i,r){const o=[],a=[],m=[];for(let h=0,u=r;h<u;h++)o.push(t.calculateSubLengthFromStart(s[h])),a.push(e.calculateSubLengthFromStart(i[h])),n.isOneOf(s[h],0,1)&&n.isOneOf(i[h],0,1)&&t.getCoord2D(s[h]).equals(e.getCoord2D(i[h]))&&m.push(h);if(0===m.length||m.length===r)return;m.sort((t,e)=>s[t]<s[e]?-1:s[t]>s[e]?1:i[t]<i[e]?-1:i[t]>i[e]?1:0);let h=-1;for(const u of m){if(h>=0&&s[u]===s[h]&&s[u]===s[h]){h=u;continue}h=u;const m=[];m.length=r;for(let t=0;t<m.length;++t)m[t]=t;m.sort((t,e)=>{const s=o[u],n=a[u],i=o[t]-s,r=a[t]-n,m=i*i+r*r,h=o[e]-s,l=a[e]-n,c=h*h+l*l;return m<c?-1:m>c?1:0});for(let o=0;o<r;o++){const r=m[o];if(r===u||s[r]===s[u]&&i[r]===i[u]||n.isOneOf(s[r],0,1)&&n.isOneOf(i[r],0,1))continue;const a=(s,i,r,o)=>{const a=new f,m=new n.ECoordinate;m.setWithEps(1);const h=new n.ECoordinate;h.set(i,m.eps()),t.queryCoord2DE(h,a);const u=new f;t.queryCoord2DE(new n.ECoordinate(s),u);let l=!1;return a.eq(u)&&(h.set(o,m.eps()),e.queryCoord2DE(h,a),e.queryCoord2DE(new n.ECoordinate(r),u),l=a.eq(u)),!l},h=n.Point2D.getNAN();t.queryCoord2D(s[r],h);const l=n.Point2D.getNAN();if(e.queryCoord2D(i[r],l),0===n.Point2D.distance(h,l)&&a(s[u],s[r],i[u],i[r]))break;const c=new n.Envelope1D(i[r],i[u]);c.normalizeNoNAN();const g=new n.Envelope1D(s[r],s[u]);g.normalizeNoNAN();let d=-1,p=Number.POSITIVE_INFINITY,_=Number.POSITIVE_INFINITY,P=s[r];h.assign(t.getCoord2D(P));for(let o=0;o<5;o++){const o=e.getClosestCoordinateOnInterval(h,c,-1);l.assign(e.getCoord2D(o));const m=n.Point2D.distance(h,l);if(P=t.getClosestCoordinateOnInterval(l,g,-1),P===s[u]&&o===i[u]){d=1;break}h.assign(t.getCoord2D(P));const f=n.Point2D.distance(l,h);if(!(f<_&&m<p)){d=0;break}if(0===f&&0===m){a(s[u],s[r],i[u],i[r])?(s[r]=P,i[r]=o,d=0):d=1;break}_=f,p=m}if(-1===d&&(d=n.isOneOf(s[r],0,1)||n.isOneOf(i[r],0,1)?0:1),1!==d)break;s[r]=s[u],i[r]=i[u]}}}(e,s,i,r,o);const p=[];for(let t=0,e=o;t<e;t++)p.push(t);const _=(t,e)=>g?n.standardNumericCompare2(r[t],i[t],r[e],i[e]):n.standardNumericCompare2(i[t],r[t],i[e],r[e]);if(p.length>1){p.sort(_);const t=Math.max(V(e),V(s));let o=0;for(let a=1,m=p.length;a<m;a++){const m=i[p[o]],h=i[p[a]],u=r[p[o]],l=r[p[a]];if(m!==h||u!==l){if(Sr(e,m,h)<=t&&Sr(s,u,l)<=t&&!(n.isOneOf(m,0,1)&&n.isOneOf(u,0,1)||n.isOneOf(h,0,1)&&n.isOneOf(l,0,1))){const t=n.Point2D.distance(e.getCoord2D(m),s.getCoord2D(u)),i=n.Point2D.distance(e.getCoord2D(h),s.getCoord2D(l));if(t<=i)continue;if(i<t){p[o]=p[a];continue}continue}o++,p[o]=p[a]}}if(p.length=o+1,1===p.length&&0!==p[0]&&(i[0]=i[p[0]],r[0]=r[p[0]],p[0]=0),p.length>2){const t=n.Envelope1D.constructEmpty(),o=n.Envelope1D.constructEmpty();t.setCoords(i[p[0]],i[p.at(-1)]),o.setCoords(r[p[0]],r[p.at(-1)]);let a=!0;for(let e=1,s=p.length-1;e<s;e++)if(!t.containsCoordinate(i[p[e]])||!o.containsCoordinate(r[p[e]])){a=!1;break}if(a){const i=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let r=0;r<i.length;r++){let m=n.lerp(t.vmin,t.vmax,i[r]);const h=e.getCoord2D(m);if(!s.isCloserThanDistance(h,o,u)){a=!1;break}m=n.lerp(o.vmin,o.vmax,i[r]);const l=s.getCoord2D(m);if(!e.isCloserThanDistance(l,t,u)){a=!1;break}}}a&&(p[1]=p.at(-1),p.length=2)}}if(1===p.length&&t){const t=0,n=0;A(e,s,i[0],r[0],u,1,[t],[n])&&(p.push(1),i[1]=t,r[1]=n,p.sort(_))}if(l&&1===p.length){let t=!0;for(let o=0,a=p.length;o<a;o++)if(!n.isOneOf(i[p[o]],0,1)||!n.isOneOf(r[p[o]],0,1)||0!==n.Point2D.distance(e.getCoord2D(i[p[o]]),s.getCoord2D(r[p[o]]))){t=!1;break}if(t)return 0}let P=0;for(let t=0,s=p.length;t<s;t++){if(m&&m.push(i[p[t]]),h&&h.push(r[p[t]]),a){const s=n.Point2D.getNAN();e.queryCoord2D(i[p[t]],s),a.push(s)}P++}return P}function Ir(t,s,i,r,o){let a=-1,m=-1,h=-1,u=-1;{const e=[0,s],n=[s,0],o=[0,r],l=[r,0];for(let s=0;s<2&&-1===a;++s)for(let r=0;r<2;++r)if(t[e[s]].equals(i[o[r]])){a=e[s],m=n[s],h=o[r],u=l[r];break}}if(-1===a){const e=new d;e.setFromPoints(t,s+1);const n=new d;return n.setFromPoints(i,r+1),n.inflate(o),e.isIntersectingW(n)?-1:0}{const l=n.makePrimitiveArray(s+1,Number.NaN),c=as(t,s+1,l);e.geometryReleaseAssert(c>1);let g=0,d=0;for(let t=0;t<c;++t)a===l[t]&&(d=t,g++),m===l[t]&&g++;if(2!==g)return-1;const p=n.makePrimitiveArray(r+1,Number.NaN),_=as(i,r+1,p);e.geometryReleaseAssert(_>1),g=0;let P=0;for(let t=0;t<_;++t)h===p[t]&&(P=t,g++),u===p[t]&&g++;if(2!==g)return-1;const f=t[l[(d+c-1)%c]],y=t[l[(d+1)%c]],x=i[p[(P+_-1)%_]],D=i[p[(P+1)%_]],v=t[a],E=[f,y,x,D],C=[0,1,2,3];C.sort((t,e)=>n.Point2D.compareVectorsOrigin(v,E[t],E[e]));let b=C[0];for(let t=1;t<4;t++){if(C[t]!==(b+1)%4)return-1;b=C[t]}{const t=f.sub(v),e=D.sub(v),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),r=i*t.length(),a=i*e.length();if(r<=o||a<=o)return-1}}{const t=y.sub(v),e=x.sub(v),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),r=i*t.length(),a=i*e.length();if(r<=o||a<=o)return-1}}return 1}}var Mr=s.VertexDescription;class Nr extends H{constructor(t){super(t||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(t){return this!==t&&(this.m_description=t.m_description,t.m_description=null,this.m_attributes=t.m_attributes,t.m_attributes=null,this.m_XStart=t.m_XStart,t.m_XStart=Number.NaN,this.m_YStart=t.m_YStart,this.m_XEnd=t.m_XEnd,t.m_XEnd=Number.NaN,this.m_YEnd=t.m_YEnd),this}assignCopy(t){return this!==t&&t.copyTo(this),this}calculateLowerLength3D(){return e.geometryReleaseAssert(0),0}calculateUpperLength3D(){return e.geometryReleaseAssert(0),0}changeEndPoints3D(t,s){e.geometryReleaseAssert(0)}getClosestCoordinate3D(t,s,n){return e.geometryReleaseAssert(0),0}getBoundary(){return Dt(this)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?Q(this,t):$(this,t);const i=Mr.getInterpolation(e),r=this.getStartAttributeAsDbl(e,s),o=this.getEndAttributeAsDbl(e,s);return n.interpolate(i,r,o,t,Mr.getDefaultValue(e))}constructFromCoords(t,e,s,n){this.dropAllAttributes(),this.setStartXYCoords(t,e),this.setEndXYCoords(s,n)}construct(t,e){this.dropAllAttributes(),this.setStartXY(t),this.setEndXY(e)}construct3D(t,s){e.geometryReleaseAssert(0)}constructPoint(t,e){this.assignVertexDescription(t.getDescription()),this.mergeVertexDescription(e.getDescription()),this.setStart(t),this.setEnd(e)}getGeometryType(){return Nr.type}queryEnvelope(t){if(4===t.m_EnvelopeType){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=i.Envelope2D.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let e=1,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e);for(let n=0,i=Mr.getComponentCount(s);e<i;e++){const e=this.queryInterval(s,n);t.setIntervalEnvelope(s,n,e)}}}else 2===t.m_EnvelopeType?t.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):3===t.m_EnvelopeType?(t.setEmpty(),t.mergeCoords(this.m_XStart,this.m_YStart,X(this,0,1,0)),t.mergeCoords(this.m_XEnd,this.m_YEnd,X(this,1,1,0))):e.throwNotImplementedException("env type not impl")}applyTransformation(t){e.geometryReleaseAssert(t instanceof r.Transformation2D);const s=new n.Point2D;s.x=this.m_XStart,s.y=this.m_YStart,t.transformInPlace(s),this.m_XStart=s.x,this.m_YStart=s.y,s.x=this.m_XEnd,s.y=this.m_YEnd,t.transformInPlace(s),this.m_XEnd=s.x,this.m_YEnd=s.y}createInstance(){return new Nr({vd:this.m_description})}calculateLength2D(){return Math.sqrt(at(this))}calculateLength3D(t){return e.geometryReleaseAssert(0),0}changeEndPoints2D(t,e){this.setStartXY(t),this.setEndXY(e),this.normalizeAfterEndpointChange()}queryControlPointsHelper(t){return e.geometryReleaseAssert(t.length>=2),t[0]=this.getStartXY(),t[1]=this.getEndXY(),2}queryCoord2D(t,e){return Z(this,t,e)}queryCoord3D(t,s){e.geometryReleaseAssert(0)}getCoordZ(t){return function(t,e){const s=t.getStartZ(),i=t.getEndZ();return n.lerp(s,i,e)}(this,t)}queryCoord2DE(t,e){K(this,t,e)}queryCoord2DMP(t,e){e.assignPoint2D(this.getStartXY());const s=x.constructPoint2D(this.getEndXY());s.subThis(e),s.mulThis(n.MPValue.constructDouble(t)),e.addThis(s)}getCoordX(t){return Q(this,t)}getCoordY(t){return $(this,t)}cut(t,e,s){const n=new qr;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,i){const r=s.createLine();i&&r.assignVertexDescription(this.m_description);const o=n.Point2D.getNAN();if(Z(this,t,o),r.setStartXYCoords(o.x,o.y),Z(this,e,o),r.setEndXYCoords(o.x,o.y),!i)for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),i=Mr.getComponentCount(n);for(let s=0;s<i;s++){const i=this.getAttributeAsDbl(t,n,s);r.setStartAttribute(n,s,i);const o=this.getAttributeAsDbl(e,n,s);r.setEndAttribute(n,s,o)}}}queryDerivative(t,e){!function(t,e,s){const n=f.constructPoint2D(t.getStartXY()),i=f.constructPoint2D(t.getEndXY());s.setCoordsE(i.x.subE(n.x),i.y.subE(n.y))}(this,0,e)}getClosestCoordinate(t,e){return n.Point2D.getClosestCoordinate(this.getStartXY(),this.getEndXY(),t,e)}getClosestCoordinateOnInterval(t,e,s=-1){const i=new n.Point2D;this.queryCoord2D(e.vmin,i);const r=new n.Point2D;this.queryCoord2D(e.vmax,r);const o=n.Point2D.getClosestCoordinate(i,r,t,!1);return O.recalculateParentT(e.vmin,e.vmax,o)}intersectionOfYMonotonicWithAxisX(t,e){const s=this.m_YEnd-this.m_YStart;if(!s)return t===this.m_YEnd?e:Number.NaN;const n=(t-this.m_YStart)/s;let i=Q(this,n);return 1===n&&(i=this.m_XEnd),i}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(t){const e=this.m_XStart-this.m_XEnd,s=this.m_YStart-this.m_YEnd;return Math.sqrt(e*e+s*s)<=t}isDegenerate3D(t,s){return e.geometryReleaseAssert(0),!1}queryLooseEnvelope(t){this.queryEnvelope(t)}clone(t){const e=new Nr;return this.copyTo(e),e}tToLength(t){return t*this.calculateLength2D()}lengthToT(t){const e=this.calculateLength2D();return 0!==e?t/e:0}calculateWeightedAreaCentroid2D(t){const e=new n.Point2D;return e.setCoords(0,0),e}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}getTangent(t){const e=n.Point2D.getNAN();return e.setSub(this.getEndXY(),this.getStartXY()),e}getDerivative(t){const e=new n.Point2D;return e.setSub(this.getEndXY(),this.getStartXY()),e}getCurvature(t){return 0}isIntersectingPoint(t,e,s){return nt(this,t,e,s)>=0}isIntersectingPoint3D(t,s,n,i,r=1){return e.geometryReleaseAssert(0),!1}getYMonotonicParts(t,e){return 0}getMonotonicParts(t,e){return 0}getMonotonicPartParams(t,s){return s&&(t<2&&e.throwInvalidArgumentException(""),s[0]=0,s[1]=1),2}intersectionWithAxis2D(t,e,s,n){if(t){const t=this.m_YEnd-this.m_YStart;if(!t)return e===this.m_YEnd?-1:0;const i=(e-this.m_YStart)/t;return i<0||i>1?0:(s&&(s[0]=Q(this,i)),n&&(n[0]=i),1)}{const t=this.m_XEnd-this.m_XStart;if(!t)return e===this.m_XEnd?-1:0;const i=(e-this.m_XStart)/t;return i<0||i>1?0:(s&&(s[0]=$(this,i)),n&&(n[0]=i),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(t,s){if(2===s.m_EnvelopeType){let e=n.snap(t.vmin,0,1);const i=new n.Point2D;return this.queryCoord2D(e,i),s.setCoords({pt:i}),e=n.snap(t.vmax,0,1),this.queryCoord2D(e,i),void s.mergeNe(i)}e.throwNotImplementedException("3d dst not impl")}orientBottomUp(){tt(this)}isLine(){return!0}isDegenerateToLineHelper(t){return!0}copyIgnoreAttributes(t){t.setStartXY(this.getStartXY()),t.setEndXY(this.getEndXY()),t.normalizeAfterEndpointChange()}calculateArea2DHelper(){return 0}absNormXYZ(t){return function(t,e){const s=t.getStartXYZ();s.z*=e;const n=t.getEndXYZ();return n.z*=e,s.norm(1)+n.norm(1)}(this,t)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(t,e){e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax))}setSegmentFromCoordsForStitcher(t,e){J(this,t[0],t[e-1])}writeInBufferStream(t,s){return e.geometryReleaseAssert(0),0}readFromBufferStream(t,s){e.geometryReleaseAssert(0)}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return!1}setCoordsForIntersector(t,e,s){J(this,t,e)}static isIntersectingLineLine(t,e,s,n){return et(t,e,s,n)}static isIntersectingLineLine_(t,e,s,n){return et(t,e,s,n)}copyToImpl(t){}reverseImpl(){}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}swapImpl(t){}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(t,e,s,n,i){return wr(!1,this,t,e,s,n,i)}intersectPoint(t,s,n){s.length<1&&e.throwOutOfRangeException("");const i=nt(this,t,n,!1);return i>=0?(s&&(s[0]=i),1):0}isIntersecting(t,e,s){return 0!==Er(!1,this,t,e,s)}}Nr.type=e.GeometryType.enumLine;class qr{constructor(t){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new Nr,this.m_mask=0,this.m_active=0,void 0!==t&&(t.copy?t.copy.copyTo(this,!1):t.move?this.assignMove(t.move):t.segment?this.copyFrom(t.segment,!!t.bIgnoreAttributes):e.throwInternalErrorException("bad constructor params"))}assignCopy(t){return t instanceof qr?this!==t&&t.copyTo(this,!1):this.copyFrom(t,!1),this}assignMove(t){if(t instanceof qr){if(this===t)return this;this.reset(),1&t.m_mask&&(this.m_lineBuffer=t.m_lineBuffer,t.m_lineBuffer=null,this.m_mask=1),this.m_curves=t.m_curves,this.m_mask=t.m_mask,this.m_active=t.m_active,t.reset(),this.m_seg=this.activeSegment(),t.m_seg=null}else{if(this.m_seg===t)return this;this.create(t.getGeometryType()),this.m_seg.swap(t)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:e.throwInternalErrorException("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return null===this.m_seg}copyTo(t,e){this!==t&&(this.empty()?t.m_seg=null:t.copyFrom(this.m_seg,e))}copyToWithZ(t,s){e.geometryReleaseAssert(0)}createImpl(t){switch(t){case e.GeometryType.enumLine:1&this.m_mask||(this.m_lineBuffer=new Nr,this.m_mask|=1,this.m_active=1);break;case e.GeometryType.enumEllipticArc:2&this.m_mask||(this.m_curves=new Di,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case e.GeometryType.enumBezier:4&this.m_mask||(this.m_curves=new pn,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case e.GeometryType.enumBezier2:8&this.m_mask||(this.m_curves=new Ot,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case e.GeometryType.enumRationalBezier2:16&this.m_mask||(this.m_curves=new zt,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:e.throwInvalidArgumentException("")}}create(t){t===e.GeometryType.enumLine?this.createLine():t===e.GeometryType.enumEllipticArc?this.createEllipticArc():t===e.GeometryType.enumBezier?this.createCubicBezier():t===e.GeometryType.enumRationalBezier2?this.createQuadraticRationalBezier():t===e.GeometryType.enumBezier2?this.createQuadraticBezier():e.throwInvalidArgumentException("Segment_buffer.create")}copyFrom(t,e){this.m_seg!==t&&(this.create(t.getGeometryType()),e?t.copyIgnoreAttributes(this.m_seg):t.copyTo(this.m_seg))}copyFromWithZ(t,s){e.geometryReleaseAssert(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(e.GeometryType.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(e.GeometryType.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(e.GeometryType.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(e.GeometryType.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(e.GeometryType.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,0===this.m_active&&e.throwInternalErrorException("releaseSegment"),1&this.m_active){const t=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,t}let t;return 2&this.m_active?t=this.arc():4&this.m_active?t=this.bezier3():8&this.m_active?t=this.bezier2():16&this.m_active?t=this.rbezier2():e.throwInternalErrorException("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,t}equals(t){return t instanceof qr?this===t||(this.empty()?t.empty():!t.empty()&&this.get().equals(t.get())):(e.throwNotImplementedException("seg comparison not yet impl"),!1)}}t.ConvexHull=hs,t.CubicBezier=pn,t.Densificator=wi,t.EPoint2D=f,t.EditShape=os,t.EllipticArc=Di,t.GeometryCollection=B,t.Line=Nr,t.MPPoint2D=x,t.MultiPoint=g,t.Polygon=ts,t.Polyline=yt,t.QuadraticRationalBezier=zt,t.Segment=O,t.SegmentBuffer=qr,t.SegmentTypeInfo=rs,t.VertexIterator=is,t.approximationWithBeziers=bi,t.approximationWithQuadraticRationalBeziers=Ai,t.arcimpl_NormalizeAngles=Vi,t.calculate=Dt,t.calculateStandardWeight=oi,t.canUseQuadTree=function(t){return!(t.isEmpty()||t.getGeometryType()!==e.GeometryType.enumPolyline&&t.getGeometryType()!==e.GeometryType.enumPolygon||t.getPointCount()<20)},t.canUseQuadTreeForPaths=function(t){return!(t.isEmpty()||t.getGeometryType()!==e.GeometryType.enumPolyline&&t.getGeometryType()!==e.GeometryType.enumPolygon||t.getPointCount()<20)},t.checkSharpCorner=function(t,e,s,i,r,o,a,m,h){if(n.isOneOf(s,0,1)&&n.isOneOf(i,0,1)&&0===n.Point2D.distance(t.getCoord2D(s),e.getCoord2D(i))){const u=1e-12,l=new f,c=Number.EPSILON;if(t.queryDerivative(new n.ECoordinate(s,c),l),l.isTrueZero()){const e=1===s?-1e-12:u;t.queryDerivative(new n.ECoordinate(s,c).add(e),l)}1===s&&l.negateThis();const g=new f;if(e.queryDerivative(new n.ECoordinate(i,c),g),g.isTrueZero()){const t=1===s?-1e-12:u;e.queryDerivative(new n.ECoordinate(i,c).add(t),g)}1===i&&g.negateThis(),l.isZero()||l.normalize(),g.isZero()||g.normalize();const d=l.dotProduct(g),p=l.crossProduct(g);p.scaleError(3);const _=()=>{if(h)return.001;{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*r/Math.min(s,n),1e-10)}};if(d.ge(n.s_zero)&&(p.isZero()||Math.abs(p.value())<_()))return b(t,e,s,i,r,o,a,m)}return 0},t.clearEndPointModified=hr,t.compareConnectedSegments=function(t,s,i){const r=n.makeObjectArray(n.Point2D,4);let o=t.queryControlPointsHelper(r);const a=n.makeObjectArray(n.Point2D,4);let m=s.queryControlPointsHelper(a);r[0].equals(a[0])||e.throwNonSimpleGeometryException("");const h=t.getGeometryType();if(h===s.getGeometryType()&&r.map((t,e)=>a[e].equals(t)).reduce((t,e)=>t&&e)){if(h!==e.GeometryType.enumRationalBezier2)return 0;{const e=s,n=[0,0,0],i=[0,0,0];if(t.queryWeights(n),e.queryWeights(i),n.map((t,e)=>i[e]===t).reduce((t,e)=>t&&e))return 0}}for(;o>2&&r[1].equals(r[0]);)r.splice(1,1),o--;for(;m>2&&a[1].equals(a[0]);)a.splice(1,1),m--;(r[1].equals(r[0])||a[1].equals(r[0]))&&e.throwNonSimpleGeometryException("");const u=n.Point2D.compareVectorsOrigin(r[0],r[1],a[1]);if(0===u){const e=x.constructPoint2D(r[0]),n=new x;t.queryCoord2DMP(1e-16,n),n.sub(e);const i=new x;return s.queryCoord2DMP(1e-16,i),i.sub(e),i.crossProduct(n).sign()}return u},t.construct=function(t){if(t.isEmpty())return new ts({vd:t.getDescription()});if(e.isMultiPath(t.getGeometryType())&&t.hasNonLinearSegments())return function(t){e.geometryReleaseAssert(t.hasNonLinearSegments()&&!t.isEmpty());const s=new hs;return s.addGeometry(t),s.getBoundingGeometry()}(t);const i=t.getImpl(),r=i.getPointCount();if(r<=2){if(1===r||i.getXY(0).equals(i.getXY(1))){const t=new s.Point({vd:i.getDescription()});return i.getPointByVal(0,t),t}{const t=new s.Point,e=new yt({vd:i.getDescription()});return i.getPointByVal(0,t),e.startPathPoint(t),i.getPointByVal(1,t),e.lineToPoint(t),e}}const o=i.getAttributeStreamRef(0),a=new hs({stream:o,n:r});let m=1;const h=o.readPoint2D(0),u=new n.Point2D;for(;m<r&&o.queryPoint2D(m<<1,u).equals(h);)m++;if(a.m_treeHull.addElement(0),m<r){a.m_treeHull.addBiggestElement(m);const t=new n.Point2D;for(let e=m+1;e<i.getPointCount();e++){o.queryPoint2D(e<<1,t);const s=a.treeHull(t);-1!==s&&a.m_treeHull.setElement(s,e)}}const l=i.getDescription(),c=l.getAttributeCount()>1,g=a.m_treeHull.size();let d=null;if(g>=2){d=g>=3?new ts({vd:l}):new yt({vd:l});const t=d.getImpl();t.reserve(a.m_treeHull.size()),t.addPathPoint2D(null,0,!0);const e=new n.Point2D;for(let n=a.m_treeHull.getFirst();-1!==n;n=a.m_treeHull.getNext(n))if(c){const e=new s.Point;i.getPointByVal(a.m_treeHull.getElement(n),e),t.insertPoint(0,-1,e)}else o.queryPoint2D(a.m_treeHull.getElement(n)<<1,e),t.insertPoint2D(0,-1,e)}else if(c){const t=new s.Point({vd:l});i.getPointByVal(a.m_treeHull.getElement(a.m_treeHull.getFirst()),t),d=t}else{const t=o.readPoint2D(a.m_treeHull.getElement(a.m_treeHull.getFirst())<<1);d=new s.Point(t)}return d},t.constructCircularArcHelperForOldFormat=er,t.constructOrientedMinimumBoundingBox=function(t,s,i,r,o){if(function(t,e,s){t.setNAN(),e.setCoords(1,0),s.setCoords(0,0)}(i,r,o),t.isEmpty())return;if(t.getGeometryType()===e.GeometryType.enumPoint)return void i.assign(t.getXY());const a=t,m=a.getPointCount();0!==m&&(1!==m?function(t,e,s,i,r,o){if(2===e){const e=t.getXY(0),s=t.getXY(1);i.assign(e.add(s).mul(.5));const n=s.sub(e);r=ps(n),o.setCoords(.5*n.length(),0)}else{let a=Number.MAX_VALUE;const m=[0,1,0,0],h=new n.SmallMatrix(4,2);for(h.set(0,0,0),h.set(0,1,1),h.set(1,0,1),h.set(1,1,2);m[0]<e;++m[0],_s(h,0,e)){m[1]===m[0]&&(++m[1],_s(h,1,e));for(let s=1;;++s){for(;;){const n=Ps(t.getXY(h.get(0,0)),t.getXY(h.get(0,1)),t.getXY(h.get(s,0)),t.getXY(h.get(s,1)),2^s);if(n>0)break;if(++m[s],_s(h,s,e),0===n)break}if(3===s)break;m[s+1]<m[s]&&(m[s+1]=m[s],h.set(s+1,0,h.get(s,0)),h.set(s+1,1,h.get(s,1)))}const u=t.getXY(h.get(0,0)).add(t.getXY(h.get(2,0))).mul(.5),l=ps(t.getXY(h.get(0,1)).sub(t.getXY(h.get(0,0)))),c=new n.Point2D;let g,d;if(c.x=Math.max(0,l.dotProduct(t.getXY(h.get(1,0)).sub(t.getXY(h.get(3,0))))),c.y=Math.max(0,l.crossProduct(t.getXY(h.get(0,0)).sub(t.getXY(h.get(2,0))))),s?(g=c.x*c.y,d=g<a):(g=c.y,d=g<a),d){a=g;const e=t.getXY(h.get(1,0)),s=t.getXY(h.get(3,0)),n=e.add(s).mul(.5).sub(u);i.assign(u.add(l.mul(l.dotProduct(n)))),r.assign(l),o.assign(c)}}o.mulThis(.5),o.x<o.y&&(o.y=n.swap(o.x,o.x=o.y),r.leftPerpendicularThis())}r.y<0?r.negateThis():0===r.y&&(r.x=1)}(a,m,s,i,r,o):i.assign(a.getXY(0)))},t.convertToDegrees=Pi,t.convertToRadians=_i,t.defaultRank=1,t.densify=function(t,e,s,i,r,o){return new wi(0,0,0,null,!1,n.intMax()).densifyEx(t,e,s,i,!1,o)},t.ensureXYMonotoneSegment$1=Rs,t.forEachDir=function(t,e,s){if(t)for(let t=e.length-1;t>=0;--t)s(e[t]);else e.forEach(s)},t.generateGeometryCursor=function(t,e=-1){return new j(t,e)},t.getPolynomialCoefs$1=xs,t.groupTransform=function(t,e,s){if(0===t.length)return;let n=0,i=0;for(++i;i!==t.length;++i)e(t[n],t[i])||(s(n,i),n=i);s(n,i)},t.hasNonEmptyBoundary=function t(s,n){if(s.isEmpty())return!1;const i=s.getGeometryType();if(i===xt.enumPolygon)return 0!==s.calculateArea2D();if(i===xt.enumPolyline)return vt(s.getImpl(),0,!0).bNotEmpty;if(i===xt.enumEnvelope)return!0;if(e.isSegment(i))return!!s.isClosed();if(e.isPoint(i))return!1;if(i===xt.enumGeometryCollection){const e=s;for(let s=0,i=e.getGeometryCount();s<i;s++)if(t(e.getGeometry(s),n))return!0;return!1}e.throwNotImplementedException("")},t.integrateByRomberg=ue,t.intersect=wr,t.intersectInfiniteLines=function(t,e){const s={bIntersect:!1,t1:Number.NaN,t2:Number.NaN},n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*i-n*o;if(0===a)return s;const m=e.m_XStart-t.m_XStart,h=e.m_YStart-t.m_YStart,u=r*h-m*o,l=n*h-m*i,c=1/a;return s.t1=u*c,s.t2=l*c,s.bIntersect=!0,s},t.isEndPointModified=mr,t.isExactOverlap2d=br,t.isIdenticalType=Ar,t.isIntersecting=Er,t.isIntersectingEx=Cr,t.isPathConvex=function(t,s,i){if((s<0||s>=t.getPathCount())&&e.throwInvalidArgumentException("path index"),t.hasNonLinearSegmentsPath(s))return!1;const r=t.getImpl(),o=r.getPathStart(s),a=r.getPathEnd(s),m=!r.isClosedPath(s)&&r.isClosedPathInXYPlane(s),h=r.getAttributeStreamRef(0),u=2*o;let l=2*a;if(m&&(l-=2),l-u<6)return!0;const c=h.readPoint2D(u),g=h.readPoint2D(u+2),d=h.readPoint2D(u+4);if(!cs(n.Point2D.orientationRobust(g,d,c)))return!1;const p=g.clone(),_=new n.Point2D;for(let t=u+6;t<l;t+=2){if(_.assign(g),g.assign(d),h.queryPoint2D(t,d),!cs(n.Point2D.orientationRobust(g,d,c)))return!1;if(!cs(n.Point2D.orientationRobust(p,d,c)))return!1;if(!cs(n.Point2D.orientationRobust(g,d,_)))return!1}return!0},t.minTolerance=V,t.minimumBoundingCircle=function(t,s,n){t.isEmpty()&&e.throwEmptyGeometryException(""),e.throwIfCurves(t);const i=t.getImpl(),r=[];return Ei(i.getPointCount(),r),Ci((o=i,{at:t=>o.getXY(t)}),r,i.getPointCount(),s);var o},t.minimumBoundingCirclePoint2D=vi,t.nthElement=function(t,e,s,i,r){n.sortRange(t,e,i-e,(t,e)=>r(t,e)?-1:1)},t.nullHandle=ss,t.nurbs2ToArc128=function(t,e,s,n,i){return cr(t,e,s,n,i)},t.orientBottomUp=tt,t.quadraticRealRoots$2=Ct,t.replaceAllCurvesWithBeziers=function(t,s,n,i){return Number.isFinite(s)||e.throwInvalidArgumentException("replace_all_curves_with_beziers: maxDeviation"),function(t,s,n,i){e.geometryReleaseAssert(t===e.GeometryType.enumBezier||t===e.GeometryType.enumEllipticArc||t===e.GeometryType.enumBezier2);const r=s.createInstance();r.getGeometryType()===e.GeometryType.enumPolygon&&r.setFillRule(s.getFillRule());const o=s.querySegmentIterator();for(let a=0,m=s.getPathCount();a<m;++a){if(!s.hasNonLinearSegmentsPath(a)){r.addPath(s,a,!0);continue}const m=s.getPathStart(a);let h=!0,u=0;for(o.resetToPath(a),e.geometryReleaseAssert(o.nextPath());o.hasNextSegment();){const l=o.nextCurve();if(!l)break;{const c=o.getStartPointIndex()-m,g=c-u;g>0&&(r.addSegmentsFromPath(s,a,u,g,h),h=!1),u=c+1,t===e.GeometryType.enumBezier?Ti(r,l,n,i,h):t===e.GeometryType.enumBezier2?Ii(r,l,n,i,h):e.throwInternalErrorException(""),h=!1}}const l=s.getSegmentCountPath(a);l-u!==0&&r.addSegmentsFromPath(s,a,u,l-u,h)}return r}(e.GeometryType.enumBezier,t,s,n)},t.rotate=function(t,e,s,n){h(t,e,s-1),h(t,s,n-1),t.reverse()},t.shorterArcDistance=function(t,e){return pi(e-t)},t.shuffle=m,t.sizeInBuffer=ct,t.solve$1=Et,t.tToParametricAngle=ji});