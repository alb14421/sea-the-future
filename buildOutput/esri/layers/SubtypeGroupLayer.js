// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","../chunks/tslib.es6","../core/Clonable","../core/Collection","../core/Error","../core/loadAll","../core/MapUtils","../core/MultiOriginJSONSupport","../core/promiseUtils","../core/reactiveUtils","../core/sql","../core/accessorSupport/decorators/property","../core/has","../core/Logger","../core/RandomLCG","../core/accessorSupport/decorators/reader","../core/accessorSupport/decorators/subclass","./Layer","./mixins/APIKeyMixin","./mixins/ArcGISService","./mixins/BlendLayer","./mixins/CustomParametersMixin","./mixins/DisplayFilteredLayer","./mixins/EditBusLayer","./mixins/FeatureLayerBase","./mixins/OperationalLayer","./mixins/PortalLayer","./mixins/RefreshableLayer","./mixins/ScaleRangeLayer","./mixins/TemporalLayer","./support/arcgisLayerUrl","./support/commonProperties","./support/featureLayerUtils","./support/fieldProperties","./support/fieldUtils","./support/subtypeGroupLayerUtils","./support/SubtypeSublayer","./support/TimeInfo","./support/versionUtils","../rest/support/Query","../support/guards"],function(e,t,r,s,i,a,o,n,u,l,p,y,d,c,h,b,m,f,g,w,S,F,_,L,v,T,x,E,C,O,I,P,q,A,G,M,U,R,j,D,k){"use strict";const N=e=>Object.freeze(Object.defineProperty({__proto__:null,default:e},Symbol.toStringTag,{value:"Module"})),$="SubtypeGroupLayer";function Q(e,t){return new i("layer:unsupported",`Layer (${e.title}, ${e.id}) of type '${e.declaredClass}' ${t}`,{layer:e})}function B(e,t){const r=[];for(const s of e){const e=new U;e.read(s,t),r.push(e)}return r}const J=A.defineFieldProperties();let V=class extends(v.FeatureLayerBase(_.DisplayFilteredLayer(L.EditBusLayer(S.BlendLayer(O.TemporalLayer(C.ScaleRangeLayer(E.RefreshableLayer(w.ArcGISService(T.OperationalLayer(x.PortalLayer(n.MultiOriginJSONMixin(F.CustomParametersMixin(g.APIKeyMixin(r.ClonableMixin(f))))))))))))))){constructor(...t){super(...t),this._sublayerLookup=new Map,this.fields=null,this.fieldsIndex=null,this.outFields=null,this.sublayers=new(s.ofType(U)),this.useUniqueColorsForSublayers=!0,this.supportedSourceTypes=new Set(["Feature Layer","Table"]),this.timeInfo=null,this.title="Layer",this.type="subtype-group",this._debouncedSaveOperations=u.debounce(async(t,r,s)=>{const{save:i,saveAs:a}=await new Promise((t,r)=>e(["./save/featureLayerUtils"],t,r));switch(t){case 0:return i(this,r);case 1:return a(this,s,r)}}),this.addHandles(l.watch(()=>this.sublayers,(e,t)=>this._handleSublayersChange(e,t),l.sync))}destroy(){this.source?.destroy()}normalizeCtorArgs(e,t){return"string"==typeof e?{url:e,...t}:e}load(e){const t=null!=e?e.signal:null,r=this.loadFromPortal({supportedTypes:["Feature Service"]},e).catch(u.throwIfAbortError).then(async()=>{if(!this.url)throw new i("subtype-grouplayer:missing-url-or-source","SubtypeGroupLayer must be created with either a url or a portal item");if(null==this.layerId)throw new i("subtype-grouplayer:missing-layerid","layerId is required for a SubtypeGroupLayer created with url");this._initLayerProperties(await this.createGraphicsSource(t))}).then(()=>q.ensureLayerCredential(this,"load",e));return this.addResolvingPromise(r),Promise.resolve(this)}get createQueryVersion(){return this.commitProperty("definitionExpression"),this.commitProperty("timeExtent"),this.commitProperty("timeOffset"),this.commitProperty("geometryType"),this.commitProperty("gdbVersion"),this.commitProperty("historicMoment"),this.commitProperty("returnZ"),this.commitProperty("capabilities"),this.commitProperty("returnM"),(this._get("createQueryVersion")??0)+1}get editingEnabled(){return this.loaded&&null!=this.capabilities&&this.capabilities.operations.supportsEditing&&this.userHasEditingPrivileges}get effectiveEditingEnabled(){return q.computeEffectiveEditingEnabled(this)}get operationalLayerType(){return this.isTable?"SubtypeGroupTable":"SubtypeGroupLayer"}set source(e){this._get("source")!==e&&this._set("source",e)}readTitleFromService(e,{name:t}){return this.url?I.titleFromUrlAndName(this.url,t):t}async addAttachment(e,t){const r=await q.addAttachment(this,e,t,$);return this.lastEditsEventDate=new Date,r}async updateAttachment(e,t,r){const s=await q.updateAttachment(this,e,t,r,$);return this.lastEditsEventDate=new Date,s}async applyEdits(e,t){return q.applyEdits(this,e,t)}async createGraphicsSource(t){const{default:r}=await u.whenOrAbort(new Promise((t,r)=>e(["./graphics/sources/FeatureLayerSource"],e=>t(N(e)),r)),t);return new r({layer:this,supportedSourceTypes:this.supportedSourceTypes}).load({signal:t})}createQuery(){const e=q.createQuery(this),t=this.sublayers.map(e=>e.subtypeCode);return e.where=p.sqlAnd(`${this.subtypeField} IN (${t.join(",")})`,this.definitionExpression),e}async deleteAttachments(e,t){const r=await q.deleteAttachments(this,e,t,$);return this.lastEditsEventDate=new Date,r}async fetchRecomputedExtents(e){return q.fetchRecomputedExtents(this,e,$)}findSublayerForFeature(e){const t=this.fieldsIndex.get(this.subtypeField),r=e.attributes[t.name];return this.findSublayerForSubtypeCode(r)}findSublayerForSubtypeCode(e){return this._sublayerLookup.get(e)}getFieldDomain(e,t){if(!t?.excludeImpliedDomains){const t=q.computeDomainFromSubtypes(this,e);if(t)return t}const r=q.getFeatureSubtype(this,t?.feature);if(r){const t=r.domains?.[e];return"inherited"===t?.type?this._getLayerDomain(e):t}return this._getLayerDomain(e)}loadAll(){return a.loadAll(this,e=>{e(this.sublayers)})}async queryAttachments(e,t){return q.queryAttachments(this,e,t,$)}async queryFeatures(e,t){const r=await this.load(),s=D.from(e)??r.createQuery(),i=s.outFields??[];i.includes(this.subtypeField)||(i.push(this.subtypeField),s.outFields=i);const a=await r.source.queryFeatures(s,t);if(a?.features)for(const e of a.features){const t=this.findSublayerForFeature(e);e.origin=t?.graphicOrigin,e.layer=e.sourceLayer=this.findSublayerForFeature(e)}return a}async queryObjectIds(e,t){return(await q.queryObjectIds(this,e,t,$)).filter(k.isNumber)}async queryFeatureCount(e,t){return q.queryFeatureCount(this,e,t,$)}async queryExtent(e,t){return q.queryExtent(this,e,t,$)}async queryRelatedFeatures(e,t){return q.queryRelatedFeatures(this,e,t,$)}async queryRelatedFeaturesCount(e,t){return q.queryRelatedFeaturesCount(this,e,t,$)}async save(e){return this._debouncedSaveOperations(0,e)}async saveAs(e,t){return this._debouncedSaveOperations(1,t,e)}write(e,t){const{origin:r,layerContainerType:s,messages:a}=t;if(this.isTable){if("web-scene"===r||"web-map"===r&&"tables"!==s)return a?.push(Q(this,"using a table source cannot be written to web scenes and web maps")),null}else if(this.loaded&&"web-map"===r&&"tables"===s)return a?.push(Q(this,"using a non-table source cannot be written to tables in web maps")),null;return this.sublayers?.length?super.write(e,t):(a?.push(new i("web-document-write:invalid-property",`Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' has invalid value for 'sublayers' property. 'sublayers' collection should contain at least one sublayer`,{layer:this})),null)}serviceSupportsSpatialReference(e){return!!this.loaded&&j.serviceSupportsSpatialReference(this,e)}async getFeatureTitle(e,t){const r=this.findSublayerForFeature(e);return r?await r.getFeatureTitle(e,t):this._getFeatureTitleForUnknownSublayer(e)}async getFeatureTitles(e,t){const r=new Map,s=new Map,i=[s];e.forEach(e=>{const t=this.findSublayerForFeature(e);if(t)o.getOrCreateMapValue(r,t,()=>[]).push(e);else{const t=e.getObjectId()??e.attributes[this.objectIdField];s.set(t,this._getFeatureTitleForUnknownSublayer(e))}});const a=await Promise.all(Array.from(r).map(([e,r])=>e.getFeatureTitles(r,t)));return a.forEach(e=>i.push(e)),new Map(i.flatMap(e=>[...e]))}get featureTitleFields(){const e=new Set;for(const t of this.sublayers){const r=t.featureTitleFields;for(const t of r)e.add(t)}return[...e]}_getLayerDomain(e){const t=this.fieldsIndex.get(e);return t?t.domain:null}_initLayerProperties(e){this._set("source",e);const{sourceJSON:t}=e;if(t&&(this.sourceJSON=t,this.read(t,{origin:"service",url:this.parsedUrl})),!this.subtypes?.length)throw new i("subtype-grouplayer:missing-subtypes","SubtypeGroupLayer must be created using a layer with subtypes");this._verifyFields(),G.fixTimeInfoFields(this.timeInfo,this.fieldsIndex)}async hasDataChanged(){return q.hasDataChanged(this)}_verifyFields(){const e=this.parsedUrl?.path??"undefined";this.objectIdField||console.log("SubtypeGroupLayer: 'objectIdField' property is not defined (url: "+e+")"),this.isTable||-1!==e.search(/\/FeatureServer\//i)||this.fields?.some(e=>"geometry"===e.type)||console.log("SubtypeGroupLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: "+e+")")}_handleSublayersChange(e,t){t&&(t.forEach(e=>{e.parent=null}),this.removeHandles("sublayers-owner"),this._sublayerLookup.clear()),e&&(e.forEach(e=>{e.parent=this,this._sublayerLookup.set(e.subtypeCode,e)}),this.addHandles([e.on("after-add",({item:e})=>{e.parent=this,this._sublayerLookup.set(e.subtypeCode,e)}),e.on("after-remove",({item:e})=>{e.parent=null,this._sublayerLookup.delete(e.subtypeCode)})],"sublayers-owner"))}_getFeatureTitleForUnknownSublayer(e){const{displayField:t,fieldsIndex:r,objectIdField:s}=this;if(t&&r.has(t))return e.attributes[r.get(t).name]??"";const i=e.getObjectId();return null!=i?i.toString():s&&r.has(s)?e.attributes[r.get(s).name]??"":""}};return t.__decorate([y.property({readOnly:!0})],V.prototype,"createQueryVersion",null),t.__decorate([y.property({readOnly:!0})],V.prototype,"editingEnabled",null),t.__decorate([y.property({readOnly:!0})],V.prototype,"effectiveEditingEnabled",null),t.__decorate([y.property({...J.fields,readOnly:!0,json:{origins:{service:{read:!0}},read:!1}})],V.prototype,"fields",void 0),t.__decorate([y.property(J.fieldsIndex)],V.prototype,"fieldsIndex",void 0),t.__decorate([y.property(P.id)],V.prototype,"id",void 0),t.__decorate([y.property({type:["show","hide","hide-children"],json:{origins:{"portal-item":{read:!1,write:!1}}}})],V.prototype,"listMode",void 0),t.__decorate([y.property({type:["SubtypeGroupLayer","SubtypeGroupTable"],json:{name:"layerType",read:{enabled:!0},write:{enabled:!0,ignoreOrigin:!0,isRequired:!0},origins:{"web-document":{name:"layerType",read:{enabled:!0},write:{enabled:!0,ignoreOrigin:!0,isRequired:!0}},"portal-item":{name:"layerType",read:{enabled:!0},write:{enabled:!0,ignoreOrigin:!0,isRequired:!0}}}}})],V.prototype,"operationalLayerType",null),t.__decorate([y.property(J.outFields)],V.prototype,"outFields",void 0),t.__decorate([y.property({clonable:!1})],V.prototype,"source",null),t.__decorate([y.property({type:s.ofType(U),json:{origins:{service:{read:{source:"subtypes",reader(e,t,r){let i=null;if(this.useUniqueColorsForSublayers){const s=M.getSymbolWithColorSupport(t,r);i=s?M.createSimpleRenderersWithUniqueColors(e.length,s):null}const a=e.map(({code:e},s)=>{const a=new U({subtypeCode:e});a.read(t,r);const o=i?.[s];return o&&a.read({drawingInfo:{renderer:o.toJSON()}},r),a});return new(s.ofType(U))(a)}}}},read:{source:["layers","tables"],reader(e,t,r){let i;return"SubtypeGroupLayer"===t.layerType&&t.layers?.length?i=B(t.layers,r):"SubtypeGroupTable"===t.layerType&&t.tables?.length&&(i=B(t.tables,r)),new(s.ofType(U))(i)}},write:{ignoreOrigin:!0,writer(e,t,r,s){const i=[];for(const t of e){const e=t.write({},s);i.push(e)}this.isTable?t.tables=i:t.layers=i}}}})],V.prototype,"sublayers",void 0),t.__decorate([y.property()],V.prototype,"useUniqueColorsForSublayers",void 0),t.__decorate([y.property({type:R})],V.prototype,"timeInfo",void 0),t.__decorate([y.property({json:{origins:{"portal-item":{write:{enabled:!0,ignoreOrigin:!0,writerEnsuresNonNull:!0}}}}})],V.prototype,"title",void 0),t.__decorate([b.reader("service","title",["name"])],V.prototype,"readTitleFromService",null),t.__decorate([y.property({json:{read:!1}})],V.prototype,"type",void 0),t.__decorate([y.property({clonable:!1,readOnly:!0})],V.prototype,"featureTitleFields",null),V=t.__decorate([m.subclass("esri.layers.SubtypeGroupLayer")],V),V});