// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../chunks/tslib.es6","../../core/Accessor","../../core/Error","../../core/Logger","../../core/MapUtils","../../core/promiseUtils","../../core/sql","../../core/accessorSupport/decorators/property","../../core/has","../../core/RandomLCG","../../core/accessorSupport/decorators/subclass","../../geometry/Extent","../../geometry/Polygon","../../geometry/projectionUtils","../../geometry/support/spatialReferenceUtils","./constants","./SessionMemoryStorage","./supportUtils","../../rest/knowledgeGraphService","../../rest/knowledgeGraph/GraphQueryStreaming","../../rest/support/Query"],function(e,t,i,n,a,o,s,r,d,p,l,m,c,h,y,u,g,f,w,b,T,M){"use strict";e.KnowledgeGraphLayerDataManager=class extends i{constructor(e){super(e),this._processingCacheUpdatesLookup=new Map,this.knowledgeGraph=null,this.inclusionModeDefinition={generateAllSublayers:!0,namedTypeDefinitions:new Map},this.entityTypeNames=new Set,this.relationshipTypeNames=new Set,this.geographicLookup=new Map,this.sublayerCaches=new Map,this.nodeConnectionsLookup=new Map,this.relationshipConnectionsLookup=new Map,this.memberIdTypeLookup=new Map;const t=new Map;e.knowledgeGraph.dataModel.entityTypes?.forEach(i=>{i.name&&(t.set(i.name,"entity"),this._processingCacheUpdatesLookup.set(i.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.entityTypeNames.add(i.name),i.properties?.forEach(e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(i.name,{name:e.name??"",geometryType:e.geometryType})}))}),e.knowledgeGraph.dataModel.relationshipTypes?.forEach(i=>{i.name&&(t.set(i.name,"relationship"),this._processingCacheUpdatesLookup.set(i.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.relationshipTypeNames.add(i.name),i.properties?.forEach(e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(i.name,{name:e.name??"",geometryType:e.geometryType})}))}),e.inclusionModeDefinition?.namedTypeDefinitions.forEach((i,n)=>{if("entity"===t.get(n))this.entityTypeNames.add(n);else{if("relationship"!==t.get(n))return a.getLogger(this).warn(`A named type, ${n}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(n);this.relationshipTypeNames.add(n)}const s=new Map;i.members?.forEach(e=>{o.getOrCreateMapValue(this.memberIdTypeLookup,e.id,()=>new Set).add(n);const t=this.getById(e.id);t&&s.set(e.id,t)}),this.sublayerCaches.set(n,s)})}addToLayer(e){e.forEach(({typeName:e,id:t})=>{if(!this.inclusionModeDefinition)throw new n("knowledge-graph:layer-data-manager","You cannot add to a layer's exclusion list if it was not created with an exclusion list originally");if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){const i=this.inclusionModeDefinition.namedTypeDefinitions.get(e);i.members||(i.members=new Map),i.members.set(t,{id:t}),o.getOrCreateMapValue(this.memberIdTypeLookup,t,()=>new Set).add(e)}}else{const i=new Map;i.set(t,{id:t}),this.inclusionModeDefinition.namedTypeDefinitions.set(e,{useAllData:!1,members:i}),o.getOrCreateMapValue(this.memberIdTypeLookup,t,()=>new Set).add(e)}})}getById(e){return f.getInstance().readFromStoreById(e)}async getData(e,t,i){if(t.objectType.name&&this.inclusionModeDefinition?.namedTypeDefinitions&&this.inclusionModeDefinition.namedTypeDefinitions.size>0&&!this.inclusionModeDefinition.namedTypeDefinitions.has(t.objectType.name))return[];let n;if(n=e||new M({where:"1=1",outFields:["*"]}),"link-chart"===t.parentCompositeLayer.type){const e=t.parentCompositeLayer,i=this._processingCacheUpdatesLookup.get(t.objectType.name??""),a=n.outFields;a&&1===a.length&&a[0]===g.systemOidFieldName&&"1=1"===n.where||await Promise.all(i??[]);const o=this.sublayerCaches.has(t.objectType.name??"")?Array.from(this.sublayerCaches.get(t.objectType.name)?.values()):[],s=[];return o.forEach(i=>{if(this.relationshipTypeNames.has(t.objectType.name)){i.geometry=e.relationshipLinkChartDiagramLookup.get(i.attributes[t.objectIdField]);const n=this.memberIdTypeLookup.get(i.attributes[g.systemOriginIdFieldName]),a=this.memberIdTypeLookup.get(i.attributes[g.systemDestinationIdFieldName]),o=this._isEndEntitySpatial(n,i,g.systemOriginIdFieldName),s=this._isEndEntitySpatial(a,i,g.systemDestinationIdFieldName);i.attributes[g.systemIsSpatialFieldName]=Number(o&&s)}else{i.geometry=e.entityLinkChartDiagramLookup.get(i.attributes[t.objectIdField]);const n=this.geographicLookup.get(t.objectType.name);n&&i.attributes[n.name]?i.attributes[g.systemIsSpatialFieldName]=1:i.attributes[g.systemIsSpatialFieldName]=0}i.attributes[g.systemLayoutGeometryFieldName]=i.geometry,s.push(i)}),s}return this.retrieveDataFromService(n,t,i)}async getConnectedRecordIds(e,t,i){const n=[];let a="";const o=this._getNamedTypeIdMapFromNodeIds(e);if(t&&0!==t?.length){for(const e of t)a=a+e+"|";a=a.slice(0,-1)}const s={},r=[];for(const[e,i]of o){const n=`${e}_ids`;s[n]=i,t&&0!==t?.length?r.push(`MATCH (n:${e}) WHERE id(n) IN $${n} WITH n MATCH (n)-[r:${a}]-(m) RETURN id(r), type(r), id(m), labels(m)[0]`):r.push(`MATCH (n:${e}) WHERE id(n) IN $${n} WITH n MATCH (n)-[r]-(m) RETURN id(r), type(r), id(m), labels(m)[0]`)}if(!r.length)return n;const d=r.join(" UNION "),p=(await b.executeQueryStreaming(this.knowledgeGraph,new T({openCypherQuery:d,bindParameters:s}),{signal:i?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await p.read();if(e)break;for(let e=0;e<t.length;e++){const i=t[e];n.push({id:i[0],typeName:i[1]}),n.push({id:i[2],typeName:i[3]})}}return n}async getRelationshipsBetweenNodes(e,t,i){const n=this._getNamedTypeIdMapFromNodeIds(e);if(0===n.size)return[];const a={relationshipExclusionIds:t,possibleConnectionEntityIds:e},o=[];for(const[e,t]of n.entries()){const i=`${e}_ids`;a[i]=t,o.push(`MATCH (n:${e}) WHERE id(n) IN $${i} WITH n MATCH (n)-[r]->(m) WHERE id(m) IN $possibleConnectionEntityIds AND NOT id(r) IN $relationshipExclusionIds RETURN id(r), type(r)`)}const s=o.join(" UNION "),r=[],d=(await b.executeQueryStreaming(this.knowledgeGraph,new T({openCypherQuery:s,bindParameters:a}),{signal:i?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await d.read();if(e)break;for(let e=0;e<t.length;e++){const i=t[e];r.push({id:i[0],typeName:i[1]})}}return r}async getRelationshipsFromNodes(e,t,i,n){const a=this._getNamedTypeIdMapFromNodeIds(e);if(0===a.size||0===t.length)return[];const o={relationshipExclusionIds:i,possibleConnectionEntityIds:t},s=[];for(const[e,t]of a.entries()){const i=`${e}_ids`;o[i]=t,s.push(`MATCH (n:${e}) WHERE id(n) IN $${i} WITH n MATCH (n)-[r]-(m) WHERE id(m) IN $possibleConnectionEntityIds AND NOT id(r) IN $relationshipExclusionIds RETURN id(r), type(r)`)}const r=s.join(" UNION "),d=new Map,p=(await b.executeQueryStreaming(this.knowledgeGraph,new T({openCypherQuery:r,bindParameters:o}),{signal:n?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await p.read();if(e)break;for(let e=0;e<t.length;e++){const i=t[e];let n=d.get(i[1]);n||(n=new Set,d.set(i[1],n)),n.add(i[0])}}const l=[];for(const[e,t]of d)for(const i of t)l.push({id:i,typeName:e});return l}async refreshCacheContent(e,t,i,a=!0,r){const d=f.getInstance(),p=[],l=new Map,m=new Map;this.knowledgeGraph.dataModel.entityTypes?.forEach(e=>{e.name&&m.set(e.name,e)}),this.knowledgeGraph.dataModel.relationshipTypes?.forEach(e=>{e.name&&m.set(e.name,e)}),e||this.inclusionModeDefinition?e?e.forEach(e=>{if(this.memberIdTypeLookup.has(e))for(const t of this.memberIdTypeLookup.get(e))l.has(t)?l.get(t)?.push(e):l.set(t,[e])}):this.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e,t)=>{e.useAllData?l.set(t,null):e.members&&e.members.forEach(e=>{l.has(t)&&null!==l.get(t)?l.get(t)?.push(e.id):l.set(t,[e.id])})}):(this.knowledgeGraph.dataModel.entityTypes?.forEach(e=>{e.name&&l.set(e.name,null)}),this.knowledgeGraph.dataModel.entityTypes?.forEach(e=>{e.name&&l.set(e.name,null)}));for(const[e,s]of l){const l=new Set(s),c=new Promise((p,c)=>{(async()=>{const p=new Set,c=[];let h,y="",u=!1;if(t||m.get(e)?.properties?.forEach(e=>{e.name&&p.add(e.name)}),i&&this.geographicLookup.has(e)){const t=this.geographicLookup.get(e)?.name;t&&p.add(t)}if(this.entityTypeNames.has(e))y=`MATCH (n:${e}) ${s?"WHERE id(n) IN $ids ":""}return ID(n)`,p.forEach(e=>{y+=`, n.${e}`,c.push(e)});else{if(!this.relationshipTypeNames.has(e))throw new n("knowledge-graph:layer-data-manager",`The graph type of ${e} could not be determined. Was this type set in the KG data model and inclusion definition?`);u=!0,y=`MATCH ()-[n:${e}]->() ${s?"WHERE id(n) IN $ids ":""}return ID(n), id(startNode(n)), id(endNode(n))`,p.forEach(e=>{y+=`, n.${e}`,c.push(e)})}h=new T(s?{openCypherQuery:y,bindParameters:{ids:s}}:{openCypherQuery:y});const f=(await b.executeQueryStreaming(this.knowledgeGraph,h,{signal:r?.signal})).resultRowsStream.getReader();for(;;){const{done:t,value:i}=await f.read();if(t)break;const n=[];for(let e=0;e<i.length;e++){const t=i[e];let a=0,s=0;const r={properties:{}};for(r.id=t[a],a++,s++,u&&(r.originId=t[a],a++,s++,r.destinationId=t[a],a++,s++,o.getOrCreateMapValue(this.nodeConnectionsLookup,r.originId,()=>new Set).add(r.id),o.getOrCreateMapValue(this.nodeConnectionsLookup,r.destinationId,()=>new Set).add(r.id),o.getOrCreateMapValue(this.relationshipConnectionsLookup,r.id,()=>[r.originId,r.destinationId]));a<t.length;a++)r.properties[c[a-s]]=t[a];l.delete(r.id),n.push(r)}const s=d.writeToStore(n,g.systemOidFieldName,this.geographicLookup.get(e)?.name);this.sublayerCaches.has(e)||this.sublayerCaches.set(e,new Map),a&&!this.inclusionModeDefinition?.namedTypeDefinitions.has(e)&&this.inclusionModeDefinition?.namedTypeDefinitions.set(e,{useAllData:!1,members:new Map}),a&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(e).members&&(this.inclusionModeDefinition.namedTypeDefinitions.get(e).members=new Map);const r=this.sublayerCaches.get(e);s.forEach(t=>{r?.set(t.attributes[g.systemOidFieldName],t),a&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(e).members.has(t.attributes[g.systemOidFieldName])&&(this.inclusionModeDefinition?.namedTypeDefinitions.get(e).members.set(t.attributes[g.systemOidFieldName],{id:t.attributes[g.systemOidFieldName]}),o.getOrCreateMapValue(this.memberIdTypeLookup,t.attributes[g.systemOidFieldName],()=>new Set).add(e))})}const w=this.inclusionModeDefinition?.namedTypeDefinitions.get(e);if(w)for(const e of l)w.members?.delete(e)})().then(()=>{p(null)}).catch(e=>{"AbortError"===e.name?p(null):c(e)})});p.push(c),this._processingCacheUpdatesLookup.get(e)?.push(c)}if(await Promise.all(p),r?.signal?.aborted)throw s.createAbortError()}removeFromLayer(e){const t=new Set,i=new Set(e.map(e=>e.id));for(const i of e)t.add(i.typeName),1===this.memberIdTypeLookup.get(i.id)?.size?this.memberIdTypeLookup.delete(i.id):this.memberIdTypeLookup.get(i.id)?.delete(i.typeName),this.inclusionModeDefinition?.namedTypeDefinitions.forEach((e,t)=>{t===i.typeName&&e.members?.has(i.id)&&e.members.delete(i.id)});t.forEach(e=>{this.sublayerCaches.get(e)?.forEach((t,n)=>{i.has(n)&&this.sublayerCaches.get(e)?.delete(n)})})}async retrieveDataFromService(e,t,i){const a=f.getInstance(),o=new Set,s=[];let d,p="",l=[];const m="relationship"===t.graphType,M=this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData,I=t.parentCompositeLayer.sublayerIdsCache.get(t.objectType.name);let N=!M&&I?Array.from(I).sort():null;if(this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData)this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData&&null!=e.objectIds&&(N=e.objectIds);else if(null!=e.objectIds&&N&&N.length>0){const t=e.objectIds;e.objectIds=N.filter(e=>t.includes(e))}else if(null!=e.objectIds)N=e.objectIds;else{if(this.inclusionModeDefinition?.namedTypeDefinitions.has(t.objectType.name)&&(!this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members||this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members?.size<1))return e.objectIds=[],[];e.objectIds=N}if(null!=e.outFields){const i=e.outFields;i.includes("*")?t.fields.forEach(e=>{o.add(e.name)}):i.forEach(e=>{e!==g.systemOidFieldName&&e!==t.geometryFieldName&&o.add(e)})}if(null!=e.geometry){const i=e.geometry;let a;const l=t.parentCompositeLayer.dataManager.knowledgeGraph.serviceDefinition,g=l?.spatialReference,f=l?.serviceCapabilities?.geometryCapabilities;let b=f?.geometryMaxBoundingRectangleSizeX,M=f?.geometryMaxBoundingRectangleSizeY;if("point"===i.type){let e=i;e.spatialReference?.isWGS84||(await y.initializeProjection(e.spatialReference,u.wgs84),e=y.project(e,u.wgs84)),a=new c({spatialReference:u.wgs84,xmin:e.x-1e-4,ymin:e.y-1e-4,xmax:e.x+1e-4,ymax:e.y+1e-4})}else i?.extent?.spatialReference&&!i.spatialReference?.isWGS84?(await y.initializeProjection(i.extent.spatialReference,u.wgs84),a=y.project(i.extent,u.wgs84)):a=i.extent;if(b&&M&&g){if(4326!==g.wkid){const e=new c({spatialReference:g,xmax:b,ymax:M}),t=y.project(e,u.wgs84);b=t.xmax,M=t.ymax}if(a.xmax-a.xmin>b)throw new n("knowledge-graph:layer-data-manager",`Extent x bounds should be within ${b}° latitude, limit exceeded`);if(a.ymax-a.ymin>M)throw new n("knowledge-graph:layer-data-manager",`Extent y bounds should be within ${M}° longitude, limit exceeded`)}if(null!=e.where&&"1=1"!==e.where){const i=await r.parseWhereClause(e.where.toUpperCase(),t.fieldsIndex);t.fields.forEach(e=>{i.fieldNames.includes(e.name)&&o.add(e.name)})}p=m?`Match ()-[n:${t.objectType.name}]->() WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n), id(startNode(r)), id(endNode(r))`:`Match (n:${t.objectType.name}) WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n)`,t.geometryFieldName&&o.add(t.geometryFieldName),o.forEach(e=>{p+=`, n.${e}`,s.push(e)}),d=new T({openCypherQuery:p,bindParameters:{param_filter_geom:new h({rings:w.utilsExtentToInBoundsRings(a)})}})}else{let i="";if(null!=e.where&&"1=1"!==e.where){const n=await r.parseWhereClause(e.where,t.fieldsIndex);t.fields.forEach(e=>{n.fieldNames.includes(e.name)&&o.add(e.name)});const a=new Set(["column-reference","string","number","binary-expression"]),s=new Set(["=","<","<=","<>",">",">=","AND","OR","LIKE"]);let d=!1;const p=e=>{if("column-reference"===e.type)return`n.${e.column}`;if("string"===e.type)return`'${e.value}'`;if("number"===e.type)return`${e.value}`;if("binary-expression"===e.type&&a.has(e.left.type)&&a.has(e.right.type)&&s.has(e.operator))return`${p(e.left)} ${e.operator} ${p(e.right)}`;if("binary-expression"===e.type&&"LIKE"===e.operator){let t="";if("function"===e.left.type&&"column-reference"===e.left.args.value[0].type)t+=`lower(n.${e.left.args.value[0].column})`;else{if("column-reference"!==e.left.type)return d=!0,"";t+=`lower(n.${e.left.column})`}if(t+=" CONTAINS (","string"!==e.right.type)return d=!0,"";{let i=e.right.value;i.startsWith("%")&&(i=i.slice(1)),i.endsWith("%")&&(i=i.slice(0,-1)),t+=`'${i.toLowerCase()}')`}return t}return d=!0,""};i=p(n.parseTree),d&&(i="")}let n="";n=m?`Match ()-[n:${t.objectType.name}]->()`:`Match (n:${t.objectType.name})`;let a=!1;N&&(a=!0,n+=" WHERE ID(n) IN $ids"),i&&(n+=a?" AND":" WHERE",n+=` ${i}`),n+=" return ID(n)",m&&(n+=", id(startNode(n)), id(endNode(n))"),e.returnGeometry&&t.geometryFieldName&&o.add(t.geometryFieldName),o.forEach(e=>{n+=`, n.${e}`,s.push(e)}),d=new T(N?{openCypherQuery:n,bindParameters:{ids:N}}:{openCypherQuery:n})}const D=(await b.executeQueryStreaming(t.parentCompositeLayer.dataManager.knowledgeGraph,d,i)).resultRowsStream.getReader();for(;;){const{done:e,value:i}=await D.read();if(e)break;const n=[];for(let e=0;e<i.length;e++){const t=i[e];let a=0,o=0;const r={properties:{}};for(r.id=t[a],a++,o++,m&&(r.originId=t[a],a++,o++,r.destinationId=t[a],a++,o++);a<t.length;a++)r.properties[s[a-o]]=t[a];n.push(r)}l=l.concat(a.writeToStore(n,g.systemOidFieldName,t.parentCompositeLayer.dataManager.geographicLookup.get(t.objectType.name)?.name))}return l}_isEndEntitySpatial(e,t,i){for(const n of e??[])if(this.entityTypeNames.has(n)){const e=this.geographicLookup.get(n),a=e&&this.sublayerCaches.get(n)?.get(t.attributes[i]);if(e&&a?.attributes[e.name])return!0}return!1}_getNamedTypeIdMapFromNodeIds(e){const t=new Map;return e.forEach(e=>{if(this.memberIdTypeLookup.has(e))for(const i of this.memberIdTypeLookup.get(e)){if(!this.entityTypeNames.has(i))return;t.has(i)?t.get(i)?.push(e):t.set(i,[e])}}),t}},t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"knowledgeGraph",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"inclusionModeDefinition",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"entityTypeNames",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"relationshipTypeNames",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"geographicLookup",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"sublayerCaches",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"nodeConnectionsLookup",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"relationshipConnectionsLookup",void 0),t.__decorate([d.property()],e.KnowledgeGraphLayerDataManager.prototype,"memberIdTypeLookup",void 0),e.KnowledgeGraphLayerDataManager=t.__decorate([m.subclass("esri.layers.knowledgeGraph.KnowledgeGraphLayerDataManager")],e.KnowledgeGraphLayerDataManager),Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});