// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/tslib.es6","../../../request","../../../core/Error","../../../core/JSONSupport","../../../core/Logger","../../../core/promiseUtils","../../../core/QueueProcessor","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/has","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../../geometry/Point","../../../geometry/SpatialReference","../arcgisLayerUrl","../commonProperties","../DimensionalDefinition","../LOD","../RasterStorageInfo","../TileInfo","./datasetUtils","./multidimensionalUtils","./RawBlockCache","../rasterFormats/pixelRangeUtils","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../rasterFunctions/vectorFieldUtils"],function(e,t,i,o,r,n,s,l,a,c,u,f,h,p,m,d,x,y,g,I,R,S,w,_,k,T,v,b,P,W){"use strict";let B=0;return e.default=class extends r.JSONSupport{constructor(){super(...arguments),this._tileFetchQueue=new l.QueueProcessor({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:S.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=P.getWorldWidth(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),w.isFunctionRaster(this)&&this.primaryRasters?.rasters?.forEach(t=>t.rasterJobHandler=e)}get rasterId(){return this.url||"rasterId-"+B++}set url(e){this._set("url",x.sanitizeUrl(e,n.getLogger(this)))}async open(e){return this._openPromise??=P.load().then(()=>this._open(e)),this._openPromise}async fetchTile(e,t,i,o={}){const r=o.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,i,r);return o={noClip:!0,...o},this.fetchPixels(n,r.size[0],r.size[1],o)}async identify(e,t={}){e=c.ensureClass(m,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:o}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:s}=r;let{transposedVariableName:l}=t;const a=null!=s&&n&&(null!=o||_.isMultiSliceOrRangeDefinition(i));a&&!l&&(l=null!=i&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:u,extent:f}=r,{datumTransformation:h}=t;let d=P.projectPoint(e,u,h);if(!f.intersects(d))return{location:d,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(d);if(!r.nativeExtent.intersects(e))return{location:e,value:null};d=e}let x=0;const y=null!=l&&null!=s&&r.hasMultidimensionalTranspose;if(w.isFunctionRaster(this)){const e=this.primaryRasters.rasters[0];if(y)return e.identify(d,t);const{pixelSize:o}=r,n=3,s=o.x*n/2,l=o.y*n/2,a=new p({xmin:d.x-s,xmax:d.x+s,ymin:d.y-l,ymax:d.y+l,spatialReference:u}),c={interpolation:"nearest",multidimensionalDefinition:i,sliceId:t.sliceId},{pixelBlock:f}=await e.fetchPixels(a,n,n,c),{pixelBlock:h}=await this.fetchPixels(a,n,n,c);if(null==f)return{location:d,value:null};const m=Math.floor(n*n*.5),x=!f.mask||f.mask[m]?f.pixels.map(e=>e[m]):null;let g;return null!=h&&(g=!h.mask||h.mask[m]?h.pixels.map(e=>e[m]):void 0),{location:d,value:x,processedValue:g,pyramidLevel:0}}if(!y)if(t.srcResolution)x=P.snapPyramid(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(x=await this.computeBestPyramidLevelForLocation(e,t),null==x)return{location:d,value:null};const g=this.identifyPixelLocation(d,x,null,y);if(null===g)return{location:d,value:null};const{row:I,col:R,rowOffset:S,colOffset:k,blockWidth:T}=g,v=await this._tileFetchQueue.push({pyramidLevel:x,row:I,col:R,options:t},{signal:t.signal});if(!v?.pixels?.length)return{location:d,value:null};const b=S*T+k;return this._processIdentifyResult(v,{srcLocation:d,position:b,pyramidLevel:x,useTransposedTile:!!y,requestSomeSlices:a,identifyOptions:t})}async fetchPixels(e,t,i,o={}){e=P.shiftExtent(e),o=this._getRequestOptionsWithSliceId(o);const{_hasNoneOrGCSShiftTransform:r}=this;if(o.requestRawData&&r)return this._fetchPixels(e,t,i,o);const n=P.getWorldWidth(e.spatialReference),s=P.getWorldWrapCount(e);if(null==n||0===s||1===s&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,i,o);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,u=Math.round(n/(c-a)*t),f=u-Math.round((n/2-a)/(c-a)*t);let h=0;const m=[];for(let r=0;r<=s;r++){const d=new p({xmin:0===r?a:-n/2,xmax:r===s?c-n*r:n/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),x=0===r?u-f:r===s?t-h:u;h+=x,m.push(x);const y=o.disableWrapAround&&r>0?null:this._fetchPixels(d,x,i,o);l.push(y)}const d=(await Promise.all(l)).map(e=>e?.pixelBlock);let x=null;const y={width:t,height:i};return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},o)).pixelBlock:b.mosaic(d,y,{blockWidths:m}),{extent:e,srcExtent:P.projectExtent(e,this.rasterInfo.spatialReference,o.datumTransformation),pixelBlock:x}}async fetchRawPixels(e,t,i,o={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,i,o),{nativeExtent:n,nativePixelSize:s,storageInfo:l}=this.rasterInfo,a=2**e,c=s.x*a,u=s.y*a,f=new p({xmin:n.xmin+c*t.x,xmax:n.xmin+c*(t.x+i.width-1),ymin:n.ymax-u*(t.y+i.height-1),ymax:n.ymax-u*t.y,spatialReference:n.spatialReference});if(!r)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:h,mosaicSize:m}=r;if(1===h.length&&null!=h[0]&&h[0].width===i.width&&h[0].height===i.height)return{extent:f,srcExtent:f,pixelBlock:r.pixelBlocks[0]};const d=e>0?l.pyramidBlockWidth:l.blockWidth,x=e>0?l.pyramidBlockHeight:l.blockHeight,y={x:t.x%d,y:t.y%x};let g;return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:m,destDimension:i,clipOffset:y,clipSize:i,coefs:null,sampleSpacing:null,interpolation:o.interpolation,alignmentInfo:null,blockWidths:null},o)).pixelBlock:b.mosaic(h,m,{clipOffset:y,clipSize:i}),{extent:f,srcExtent:f,pixelBlock:g}}fetchRawTile(e,t,i,r){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return P.projectExtent(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?v.decode(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,o=0){const{customFetchParameters:r}=this.ioConfig,{range:n,query:s,headers:l}=t;o=o??t.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await i(e,{...t,query:{...s,...r},headers:{...l,...a}})}catch(i){if(o>0)return o--,this.request(e,t,o);throw i}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:_.getSliceIndex(e,t)}getTileExtentFromTileInfo(e,t,i,o){const r=o.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,i,o.origin,o.spatialReference,o.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:o}=this.rasterInfo,{pyramidResolutions:r}=e;if(!e.tileInfo){const n=[],s=e.maximumPyramidLevel||0;let l=(o.x+o.y)/2,a=1/.0254*96*l;for(let e=0;e<=s&&(n.unshift(new I({level:s-e,resolution:l,scale:a})),e!==s);e++)if(r){const t=(r[e].x+r[e].y)/2;a*=t/l,l=t}else l*=2,a*=2;const c=new m({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new S({origin:c,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:n}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,o){const{width:r,height:n,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new m({x:s.xmin,y:s.ymax,spatialReference:a});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(r,n))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],o);e.storageInfo=new R({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,o,r,n=0,s=2){if(1===r.length&&n>0){r=[...r];let{x:e,y:t}=r[0];for(let i=0;i<n;i++)e*=s,t*=s,r.push({x:e,y:t})}const l=[],{x:a,y:c}=o;for(let o=0;o<r.length;o++){const{x:n,y:s}=r[o];l.push({minCol:Math.floor((e.xmin-a+.1*n)/t/n),maxCol:Math.floor((e.xmax-a-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*s)/i/s),maxRow:Math.floor((c-e.ymin-.1*s)/i/s)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const r=o**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,i,o){const{spatialReference:r,nativeExtent:n,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=s,u=o&&null!=c?c.tileSize[0]:s.blockWidth,f=o&&null!=c?c.tileSize[1]:s.blockHeight,h=P.projectPoint(e,r,i);if(!n.intersects(h))return null;if(t<0||t>l)return null;const p=this.getPyramidPixelSize(t),{x:m,y:d}=p,x=(a.y-h.y)/d/f,y=(h.x-a.x)/m/u,g=Math.min(f-1,Math.floor((x-Math.floor(x))*f)),I=Math.min(u-1,Math.floor((y-Math.floor(y))*u));return{pyramidLevel:t,row:Math.floor(x),col:Math.floor(y),rowOffset:g,colOffset:I,blockWidth:u,srcLocation:h}}getTileExtent(e,t,i,o,r,n){const[s,l]=n,a=o.x+i*s*e.x,c=a+s*e.x,u=o.y-t*l*e.y,f=u-l*e.y;return new p({xmin:a,xmax:c,ymin:f,ymax:u,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<i||o.minRow>t||o.minCol>i}updateImageSpaceRasterInfo(e){const{pixelSize:t}=e,{width:i,height:o}=e,r=d.WebMercator;e.spatialReference=r,e.extent=e.nativeExtent=new p({xmin:-.5,ymax:.5,xmax:i-.5,ymin:.5-o,spatialReference:r}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new m({x:1,y:1,spatialReference:r});const{extent:n,storageInfo:s}=e;if(s){s.origin=new m({x:n.xmin,y:n.ymax,spatialReference:r});const{pyramidResolutions:i,tileInfo:o}=s;if(i&&i.forEach(e=>{e.x/=t.x,e.y/=t.y}),o){o.origin=s.origin;const t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;o.lods.forEach((e,i)=>{e.resolution=t*2**i,e.scale=96*e.resolution/.0254})}}}async _fetchPixels(e,t,i,o={}){let r=P.getWorldWrapCount(e);if(r>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,i,o),{pyramidLevel:s,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:u,ul:f}=n;if(0===c||0===u)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:h}=this,p=h.transform,d="gcs-shift"===p?.type,x=null!=P.getWorldWidth(e.spatialReference);!d&&x||(r=P.getWorldWrapCount(n.srcExtent,d));const y=await this._fetchRawTiles(s,f,{width:c,height:u,wrapCount:r},o);if(!y)return{extent:e,srcExtent:a,pixelBlock:null};const g=h.storageInfo,I=s>0?g.pyramidBlockWidth:g.blockWidth,R=s>0?g.pyramidBlockHeight:g.blockHeight;let{x:S,y:w}=h.pixelSize;if(s>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=g;if(null!=e&&e[s-1])({x:S,y:w}=e[s-1]);else{const e=t**s;S*=e,w*=e}}const _=h.spatialReference,k=new m({x:S,y:w,spatialReference:_}),T=I===c&&R===u&&f.x%I===0&&f.y%R===0,v=new m({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),B=!e.spatialReference.equals(_),M=_.isGeographic?1e-9:1e-4,{datumTransformation:C}=o,E=!B&&T&&1===y.pixelBlocks.length&&I===t&&R===i&&function(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}(l,v,M);if(E)return{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:y.pixelBlocks[0]};const L=x&&null!=P.getWorldWidth(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,z=o.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");z&&!this.rasterJobHandler&&await P.load();const H=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:v.toJSON(),datumTransformation:C,rasterTransform:p,hasWrapAround:r>0||L,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:z},o):P.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:v,datumTransformation:C,rasterTransform:p,hasWrapAround:r>0||L,isAdaptive:!1,includeGCSGrid:z});let D;const O=!o.requestRawData,F={rows:H.spacing[0],cols:H.spacing[1]},A=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,y.extent.xmin):void 0,{pixelBlocks:G,mosaicSize:N,isPartiallyFilled:q}=y;let J=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:G,srcMosaicSize:N,destDimension:O?{width:t,height:i}:null,coefs:O?H.coefficients:null,sampleSpacing:O?F:null,projectDirections:z,gcsGrid:z?H.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:o.interpolation,alignmentInfo:A,blockWidths:null},o);({pixelBlock:D,localNorthDirections:J}=e)}else{const e=b.mosaic(G,N,{alignmentInfo:A});D=O?b.approximateTransform(e,{width:t,height:i},H.coefficients,F,o.interpolation):e,z&&H.gcsGrid&&(J=b.getLocalArithmeticNorthRotations({width:t,height:i},H.gcsGrid),D=W.convertToLocalDirections(D,this.rasterInfo.dataType,J))}return o.requestRawData||z?{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:D,transformGrid:H,localNorthDirections:J,isPartiallyFilled:q}:{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:D}}async _fetchRawTiles(e,t,i,o){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:u,height:f,wrapCount:h}=i;const m=this._getRasterTileAlignmentInfo(e,0);o.buffer&&(a-=o.buffer.cols,c-=o.buffer.rows,u+=2*o.buffer.cols,f+=2*o.buffer.rows);let d=0,x=0,y=0;h&&null!=m&&(({worldColumnCountFromOrigin:x,originColumnOffset:y,rightPadding:d}=m),x*m.blockWidth-d>=a+u&&(d=0));const g=Math.floor(a/s),I=Math.floor(c/l),R=Math.floor((a+u+d-1)/s),S=Math.floor((c+f+d-1)/l),w=n[e];if(!w)return null;const{minRow:_,minCol:k,maxCol:T,maxRow:v}=w;if(0===h&&(S<_||R<k||I>v||g>T))return null;const b=new Array;let P=!1;const W=null==this.ioConfig.allowPartialFill?o.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=I;t<=S;t++)for(let i=g;i<=R;i++){let r=i;if(!o.disableWrapAround&&h&&null!=m&&x<=i&&(r=i-x-y),t>=_&&r>=k&&v>=t&&T>=r){const i=this._tileFetchQueue.push({pyramidLevel:e,row:t,col:r,options:o},{signal:o.signal});W?b.push(new Promise(e=>{i.then(t=>e(t)).catch(()=>{P=!0,e(null)})})):b.push(i)}else b.push(Promise.resolve(null))}if(0===b.length)return null;const B=await Promise.all(b),M={height:(S-I+1)*l,width:(R-g+1)*s},{spatialReference:C}=this.rasterInfo,E=this.getPyramidPixelSize(e),{x:L,y:z}=E;return{extent:new p({xmin:r.x+g*s*L,xmax:r.x+(R+1)*s*L,ymin:r.y-(S+1)*l*z,ymax:r.y-I*l*z,spatialReference:C}),pixelBlocks:B,mosaicSize:M,isPartiallyFilled:P}}_fetchRawTile(e,t,i,o){const{storageInfo:r}=this.rasterInfo,n=null!=r.transposeInfo&&!!o.transposedVariableName;if(!n){const o=r.blockBoundary[e];if(!o)return Promise.resolve(null);const{minRow:n,minCol:s,maxCol:l,maxRow:a}=o;if(t<n||i<s||t>a||i>l)return Promise.resolve(null)}const l=n?o.transposeVariableName:o.sliceId,a=this.rasterInfo.storageInfo.isBsqTile?o.bandIds:null,c=k.getRasterId(this.rasterId,l,a),u=`${e}/${t}/${i}`;let f=k.getBlock(c,o.registryId,u);if(null==f){const r=new AbortController;f=this.fetchRawTile(e,t,i,{...o,signal:r.signal}),k.putBlock(c,o.registryId,u,f,r),f.catch(()=>k.deleteBlock(c,o.registryId,u))}return o.signal&&s.onAbort(o,()=>{k.decreaseRefCount(c,o.registryId,u)}),f}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if((2!==t||"vector-magdir"!==i)&&"vector-uv"!==i||2!==e?.length||!e[0]?.length)return null;const o=e[0].length;if("vector-magdir"===i){const t=e[1].map(e=>(e+360)%360);return[e[0],t]}const[r,n]=e,s=[],l=[];for(let e=0;e<o;e++){const[t,i]=W.uvComponentToVector([r[e],n[e]]);s.push(t),l.push(i)}return[s,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=P.getRasterDatasetAlignmentInfo(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,o={}){const r={datumTransformation:o.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};o.srcResolution&&(r.srcResolution=o.srcResolution,this._updateSourceDataInfo(e,r));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=r,c=s/t,u=l/i,f=a<n&&c*u>=16,h=a===n&&this._requireTooManySrcTiles(s,l,t,i);if(f||h||0===s||0===l){const s=new m({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=P.projectResolution(s,this.rasterInfo.spatialReference,e,r.datumTransformation);const h=!l||o.srcResolution&&l.x+l.y<o.srcResolution.x+o.srcResolution.y;if(f&&o.srcResolution&&h){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-a+3>=e){const t=2**e;l={x:o.srcResolution.x*t,y:o.srcResolution.y*t}}}l&&(r.srcResolution=l,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,i,o){const{tileInfo:r}=this.rasterInfo.storageInfo,n=e/i,s=t/o;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=256*Math.max(1,(i+o)/1024)||n>8||s>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,o=i.spatialReference,{srcResolution:r,datumTransformation:n}=t,{pyramidLevel:s,pyramidResolution:l,excessiveReading:a}=P.snapPyramid(r,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||P.projectExtent(e,o,n);if(null==c)return;const u=i.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:f,y:h}=i.storageInfo.origin,p=Math.floor((c.xmin-f)/l.x+.1),m=Math.floor((h-c.ymax)/l.y+.1),d=Math.floor((c.xmax-f)/l.x-.1),x=Math.floor((h-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:d-p+1,g=c.height<.1*l.y?0:x-m+1;t.pyramidLevel=s,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=g,t.ul={x:p,y:m}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:o,pyramidLevel:r,useTransposedTile:n}=t,s=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[o])return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!n){const t=e.pixels.map(e=>e[o]),n={location:i,value:t,pyramidLevel:r},s=this._computeMagDirValues(t.map(e=>[e]));return s?.length&&(n.magdirValue=s.map(e=>e[0])),n}let a=e.pixels.map(e=>e.slice(o*s,o*s+s)),c=this._computeMagDirValues(a);const{requestSomeSlices:u,identifyOptions:f}=t;let h=_.createSlices(l,f.transposedVariableName);if(u){const e=_.getSliceIds(h,f.multidimensionalDefinition,f.timeExtent);a=a.map(t=>e.map(e=>t[e])),c=c?.map(t=>e.map(e=>t[e])),h=e.map(e=>h[e])}const p=e.noDataValues||this.rasterInfo.noDataValue,m={pixels:a,pixelType:e.pixelType};let d;return null!=p&&(T.convertNoDataToMask(m,p),d=m.mask),{location:i,value:null,dataSeries:h.map((e,t)=>{const i={value:0===d?.[t]?null:a.map(e=>e[t]),multidimensionalDefinition:e.multidimensionalDefinition.map(e=>new g({...e,isSlice:!0}))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i}),pyramidLevel:r}}},t.__decorate([a.property()],e.default.prototype,"_rasterTileAlignmentInfo",void 0),t.__decorate([a.property()],e.default.prototype,"_tileFetchQueue",void 0),t.__decorate([a.property({readOnly:!0})],e.default.prototype,"_isGlobalWrappableSource",null),t.__decorate([a.property({readOnly:!0})],e.default.prototype,"_hasNoneOrGCSShiftTransform",null),t.__decorate([a.property()],e.default.prototype,"_openPromise",void 0),t.__decorate([a.property()],e.default.prototype,"rasterJobHandler",null),t.__decorate([a.property({readOnly:!0})],e.default.prototype,"rasterId",null),t.__decorate([a.property(y.url)],e.default.prototype,"url",null),t.__decorate([a.property({type:String,json:{write:!0}})],e.default.prototype,"datasetName",void 0),t.__decorate([a.property({type:String,json:{write:!0}})],e.default.prototype,"datasetFormat",void 0),t.__decorate([a.property()],e.default.prototype,"hasUniqueSourceStorageInfo",void 0),t.__decorate([a.property()],e.default.prototype,"rasterInfo",void 0),t.__decorate([a.property()],e.default.prototype,"ioConfig",void 0),t.__decorate([a.property()],e.default.prototype,"sourceJSON",void 0),e.default=t.__decorate([h.subclass("esri.layers.support.rasterDatasets.BaseRaster")],e.default),e.default});