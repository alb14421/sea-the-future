// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../chunks/tslib.es6","../../../core/Error","../../../core/has","../../../core/Logger","../../../core/accessorSupport/decorators/property","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../../geometry/Point","../../../geometry/SpatialReference","../RasterInfo","../RasterStorageInfo","./BaseRaster","./DBFParser","./pamParser","../rasterFormats/TiffDecoder","../rasterFormats/tiffTag","../rasterFunctions/stretchUtils","../rasterTransforms/PolynomialTransform","../../../rest/support/FeatureSet"],function(e,t,i,a,r,s,n,o,f,l,u,c,h,p,d,m,y,g,x,I){"use strict";const T=(e,t)=>e.get(t)?.values,w=(e,t)=>e.get(t)?.values?.[0];let _=class extends h{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this._chunkSize=10485760,this.datasetFormat="TIFF"}async fetchRawTile(e,t,i,a={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,i))return null;const r=await this._fetchRawTiffTile(e,t,i,!1,a);if(null!=r&&this._headerInfo.hasMaskBand){const s=await this._fetchRawTiffTile(e,t,i,!0,a);null!=s&&s.pixels[0]instanceof Uint8Array&&(r.mask=s.pixels[0])}return r}async _open(e){const i=e?e.signal:null,{data:r}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:i});if(!r)throw new t("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:s,firstIFDPos:n,isBigTiff:h}=m.parseSignature(r),p=[],y={fileChunk:r,posIFD:n,fileOffset:0};await this._readIFDs(p,y,s,h?8:4,i);const{imageInfo:I,rasterInfo:_}=function(e){const t=m.getImageInfo(e),{width:i,height:a,tileWidth:r,tileHeight:s,planes:n,pixelType:h,compression:p,firstPyramidLevel:y,maximumPyramidLevel:g,pyramidBlockWidth:I,pyramidBlockHeight:_,pyramidResolutions:F,tileBoundary:R,affine:S,metadata:O}=t,b=t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid;let k=d.parseSpatialReference(b),D=!!t.isPseudoGeographic;null==k&&(D=!0,k=new l({wkid:3857}));const E=new o({...t.extent,spatialReference:k}),v=new f(E?{x:E.xmin,y:E.ymax,spatialReference:k}:{x:0,y:0}),P=new c({blockWidth:r,blockHeight:s,pyramidBlockWidth:I,pyramidBlockHeight:_,compression:p,origin:v,firstPyramidLevel:y,maximumPyramidLevel:g,pyramidResolutions:F,blockBoundary:R}),B=new f({x:(E.xmax-E.xmin)/i,y:(E.ymax-E.ymin)/a,spatialReference:k}),C=O?{BandProperties:O.bandProperties,DataType:O.dataType}:{};let L=null;const z=w(e[0],"PHOTOMETRICINTERPRETATION"),A=T(e[0],"COLORMAP");if(z<=3&&A?.length>3&&A.length%3==0){L=[];const e=A.length/3;for(let t=0;t<e;t++)L.push([t,A[t]>>>8,A[t+e]>>>8,A[t+2*e]>>>8])}const H=new u({width:i,height:a,bandCount:n,pixelType:h,pixelSize:B,storageInfo:P,spatialReference:k,isPseudoSpatialReference:D,keyProperties:C,extent:E,colormap:L,statistics:O?O.statistics:null});if(S?.length&&(H.nativeExtent=new o({xmin:-.5,ymin:.5-a,xmax:i-.5,ymax:.5,spatialReference:k}),H.transform=new x({polynomialOrder:1,forwardCoefficients:[S[2]+S[0]/2,S[5]-S[3]/2,S[0],S[3],-S[1],-S[4]]}),H.extent=H.transform.forwardTransform(H.nativeExtent),H.pixelSize=new f({x:(E.xmax-E.xmin)/i,y:(E.ymax-E.ymin)/a,spatialReference:k}),P.origin.x=-.5,P.origin.y=.5),F){const{x:e,y:t}=H.pixelSize;F.forEach(i=>{i.x*=e,i.y*=t})}return{imageInfo:t,rasterInfo:H}}(p),F=m.getPyramidIFDs(p),R=m.getMaskIFDs(p);if(this._headerInfo={littleEndian:s,isBigTiff:h,ifds:p,pyramidIFDs:F,maskIFDs:R,...I},this._set("rasterInfo",_),!I.isSupported)throw new t("tiffraster:open","this tiff is not supported: "+I.message);if(!I.tileWidth)throw new t("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");_.isPseudoSpatialReference&&a.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const S=p[0].get("PREDICTOR")?.values?.[0],O=p[0].get("SAMPLEFORMAT")?.values?.[0];if(3===O&&2===S)throw new t("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");const{skipMapInfo:b,skipExtensions:k=[]}=this.ioConfig;if(!k.includes("aux.xml")&&!b){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&function(e,t){if(t.statistics=e.statistics??t.statistics,t.histograms=e.histograms,e.histograms&&null==t.statistics&&(t.statistics=g.estimateStatisticsFromHistograms(e.histograms)),e.transform&&null==t.transform){t.transform=e.transform,t.nativeExtent=t.extent;const i=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new f({x:(i.xmax-i.xmin)/t.width,y:(i.ymax-i.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=i}t.isPseudoSpatialReference&&e.spatialReference&&(t.spatialReference=e.spatialReference,t.extent.spatialReference=t.nativeExtent.spatialReference=t.storageInfo.origin.spatialReference=t.spatialReference)}(t,_)}k.includes("vat.dbf")||1!==_.bandCount||"u8"!==_.pixelType||b||(_.attributeTable=await this._fetchAuxiliaryTable(e),null!=_.attributeTable&&(_.keyProperties.DataType="thematic")),b&&this.updateImageSpaceRasterInfo(_),this.updateTileInfo()}async _validateOrFetchHeaderBuffer(e,t){let{fileChunk:i,fileOffset:a,posIFD:r}=e;return(r+8>=i.byteLength||r<0)&&(a=r+a,i=(await this.request(this.url,{range:{from:a,to:a+this._bufferSize},responseType:"array-buffer",signal:t})).data,r=0),{fileChunk:i,fileOffset:a,posIFD:r}}async _readIFDs(e,i,a,r=4,s){if(!i.posIFD)return null;i=await this._validateOrFetchHeaderBuffer(i,s);const n=await this._readIFD(i,a,y.tiffTags,r,s);if(!n?.ifd)throw new t("tiffraster:open","cannot parse tiff header. failed to open url "+this.url);if(e.push(n.ifd),!n.nextIFD)return null;i.posIFD=n.nextIFD-i.fileOffset,await this._readIFDs(e,i,a,r,s)}async _readIFD(e,t,i=y.tiffTags,a=4,r){let{fileChunk:s,posIFD:n,fileOffset:o}=e;if(!e.fileChunk)return null;const f=m.parseIFD(s,t,n,o,i,a);if(f.success){const e=[];if(f.ifd?.forEach(t=>{t.values||e.push(t)}),e.length>0&&await this._fillOffsets(e,t,f.nextIFD,r),f.ifd?.has("GEOKEYDIRECTORY")){const e=f.ifd.get("GEOKEYDIRECTORY"),i=e?.values;if(i&&i.length>4){const a=i[0]+"."+i[1]+"."+i[2];n=e.valueOffset+6-o;const f=await this._validateOrFetchHeaderBuffer({fileChunk:s,posIFD:n,fileOffset:o},r),l=await this._readIFD(f,t,y.geoKeys,2,r);e.data=l?.ifd,e.data&&e.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[a]})}}return f}return f.requiredBufferSize?(s=(await this.request(this.url,{range:{from:o,to:o+n+f.requiredBufferSize+8},responseType:"array-buffer",signal:r})).data,s.byteLength<n+f.requiredBufferSize?null:(e.fileChunk=s,e.fileOffset=o,this._readIFD(e,t,i,a,r))):null}async _fillOffsets(e,t,i,a){const r=e.filter(e=>null!=e.offlineOffsetSize);if(0===r.length)return;const s=r.map(e=>e.offlineOffsetSize),n=Math.min.apply(null,s.map(e=>e[0])),o=Math.max.apply(null,s.map(e=>e[0]+e[1]));let f=1===s.length||o-n<=this._bufferSize;if(!f&&s.length>1&&(s.sort((e,t)=>e[0]-t[0]),f=s.reduce((e,t)=>e===t[0]?t[0]+t[1]:0,s[0][0])===o),f){const e=await this._fetchOffsets(n,Math.max(o,n+this._bufferSize),a);return void r.forEach(i=>m.parseFieldValues(e,t,i,n))}const l=r.map(async e=>{const i=e.offlineOffsetSize,r=await this._fetchOffsets(i[0],i[1]+i[0],a);m.parseFieldValues(r,t,e,i[0])});await Promise.all(l)}async _fetchOffsets(e,t,i){const a=[],r=this._chunkSize,s=Math.ceil((t-e)/r);let n=e;for(let e=0;e<s;e++)a.push(this.request(this.url,{range:{from:n,to:e===s-1?t:n+r-1},responseType:"array-buffer",signal:i})),n+=r;const o=await Promise.all(a);if(1===s)return o[0].data;const f=new Uint8Array(t-e+1);for(let e=0;e<s;e++)f.set(new Uint8Array(o[e].data),e*r);return f.buffer}async _fetchRawTiffTile(e,t,i,a,r={}){const s=this._getTileLocation(e,t,i,a);if(!s)return null;const{ranges:n,actualTileWidth:o,actualTileHeight:f,ifd:l}=s,u=n.map(e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:r.signal})),c=await Promise.all(u),h=c.map(e=>e.data.byteLength).reduce((e,t)=>e+t),p=1===c.length?c[0].data:new ArrayBuffer(h),d=[0],m=[0];if(c.length>1){const e=new Uint8Array(p);for(let t=0,i=0;t<c.length;t++){const a=c[t].data;e.set(new Uint8Array(a),i),d[t]=i,i+=a.byteLength,m[t]=a.byteLength}}const{blockWidth:y,blockHeight:g}=this.getBlockWidthHeight(e),x=await this.decodePixelBlock(p,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:l,offsets:d,sizes:m},width:y,height:g,planes:null,pixelType:null});if(null==x)return null;let I,T,w;if(o!==y||f!==g){let e=x.mask;if(e)for(I=0;I<g;I++)if(w=I*y,I<f)for(T=o;T<y;T++)e[w+T]=0;else for(T=0;T<y;T++)e[w+T]=0;else for(e=new Uint8Array(y*g),x.mask=e,I=0;I<f;I++)for(w=I*y,T=0;T<o;T++)e[w+T]=1}return x}_getTileLocation(e,t,i,a=!1){const{firstPyramidLevel:r,blockBoundary:s}=this.rasterInfo.storageInfo,n=0===e?0:e-(r-1),{_headerInfo:o}=this;if(!o)return null;const f=a?o.maskIFDs[n]:0===n?o?.ifds[0]:o?.pyramidIFDs[n-1];if(!f)return null;const l=m.isBSQConfig(f,o),u=T(f,"TILEOFFSETS");if(void 0===u)return null;const c=T(f,"TILEBYTECOUNTS"),{minRow:h,minCol:p,maxRow:d,maxCol:y}=s[n];if(t>d||i>y||t<h||i<p)return null;const g=w(f,"IMAGEWIDTH"),x=w(f,"IMAGELENGTH"),I=w(f,"TILEWIDTH"),_=w(f,"TILELENGTH"),F=[];if(l){const{bandCount:e}=this.rasterInfo;for(let a=0;a<e;a++){const e=a*(d+1)*(y+1)+t*(y+1)+i;F[a]={from:u[e],to:u[e]+c[e]-1}}}else{const e=t*(y+1)+i;F.push({from:u[e],to:u[e]+c[e]-1})}for(let e=0;e<F.length;e++)if(null==F[e].from||!F[e].to||F[e].to<0)return null;return{ranges:F,ifd:f,actualTileWidth:i===y&&g%I||I,actualTileHeight:t===d&&x%_||_}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return d.parsePAMInfo(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),i=p.parse(t);return i?.recordSet?I.fromJSON(i.recordSet):null}catch{return null}}};return e.__decorate([r.property()],_.prototype,"_files",void 0),e.__decorate([r.property()],_.prototype,"_headerInfo",void 0),e.__decorate([r.property()],_.prototype,"_bufferSize",void 0),e.__decorate([r.property()],_.prototype,"_chunkSize",void 0),e.__decorate([r.property({type:String,json:{write:!0}})],_.prototype,"datasetFormat",void 0),_=e.__decorate([n.subclass("esri.layers.support.rasterDatasets.TIFFRaster")],_),_});