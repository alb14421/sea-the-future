// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/tslib.es6","../../../core/Error","../../../core/Logger","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../ogc/crsUtils","../../ogc/wcsUtils","../DimensionalDefinition","./BaseRaster","./multidimensionalUtils","./multipartParser","./wcsCoverageParser","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils"],function(e,t,i,n,s,r,o,a,l,c,d,u,h,p,f,g,m,v){"use strict";const w=["nearest neighbor","bilinear","bicubic"],y=["nearest","linear","cubic"],x="response is not a supported multipart/related mediaType with inline tiff,  switching to compatibility mode",I=new Set(["1.0.0","1.1.0","1.1.1","1.1.2","2.0.1"]);function C(e,t=!1){return(t?new Date(p.convertOleDateTimeToEpoch(e)):new Date(e)).toISOString()}return e.default=class extends h{constructor(){super(...arguments),this.datasetFormat="WCSServer",this.tileType="Raster"}get rasterId(){return`${this.url}-${this.coverageId}-${this.version}`}async fetchRawTile(e,t,n,s={}){if(this.isBlockOutside(e,t,n))return null;const{nativePixelSize:r,spatialReference:o}=this.rasterInfo,a=2**e,l=r.x*a,c=r.y*a,{blockWidth:d,blockHeight:u}=this.getBlockWidthHeight(e),{origin:h}=this.rasterInfo.storageInfo.tileInfo,p=this.getTileExtent({x:l,y:c},t,n,h,o,[d,u]),f=this.rasterInfo.extent,g=p.xmax>f.xmax,m=p.ymin<f.ymin,w=g||m;let y=p,x=d,I=u;if(w&&(y=p.clone().intersection(f),null!=y&&(g&&(x=Math.floor((y.xmax-y.xmin)/l),y.xmax=y.xmin+l*x),m&&(I=Math.floor((y.ymax-y.ymin)/c),y.ymin=y.ymax-c*I))),null==y||x<=1||I<=1)return null;const C=await this._getCoverage(y,x,I,a,s);if(!C)return null;const{coverageDescription:b}=this.coverageInfo,{noDataValue:$,multidimensionalInfo:S}=this.rasterInfo,{multidimensionalDefinition:_}=s;let T;if(null!=S&&null!=_&&_.length){const e=_[0].variableName;if("2.0"===b.version){const t=b.rangeType[0].find(t=>t.name===e);T=t?.nilValue}else if("1.1"===b.version){const t=b.range.find(t=>t.identifier===e);T=t?.nullValues}}const L=T??$,P=await this.decodePixelBlock(C,{width:x,height:I,planes:null,pixelType:null,tiffNoDataValue:Array.isArray(L)?L[0]:L,matchAllNoData:!0});if(null==P)return null;if(P&&(P.width!==x||P.height!==I))throw new i("wcsraster-fetch",`the response has unexpected dimension width: ${P.width}, height: {pixelBlock.height}`);return w?v.clip(P,{x:0,y:0},{width:u,height:u}):P}async _open(e){const{customFetchParameters:t}=this.ioConfig,n=e?.signal,s=await d.getCapabilities(this.url,{version:t?.version??this.version,customParameters:t,signal:n});if(this.capabilities=s,!this.version){let e=s.version.slice(0,3);"2.0"===e||"1.1"===e||"1.0"===e?this.version=s.version:(e=s.supportedVersions.find(e=>"2.0.1"===e)||s.supportedVersions.find(e=>e.startsWith("2.0"))||s.supportedVersions.find(e=>e.startsWith("1.1"))||s.supportedVersions.find(e=>e.startsWith("1.0"))||"1.0.0",this.version=e)}const{version:r}=this;if(!I.has(r))throw new i("wcsraster-open",`unsupported WCS version ${r}`);const{gridCoverages:o}=s;if(!o.length)throw new i("wcsraster-open","cannot find rectified grid coverages");this.coverageId??=o[0].id;const{coverageId:a}=this,l=o.find(e=>e.id===a);if(null==l)throw new i("wcsraster-open",`the coverageId ${a} does not exist in capabilities`);const c=await d.describeCoverage(this.url,{coverageIds:[a],version:r,customParameters:t,signal:n});if(this.coverageInfo=c[0],r.startsWith("2.0")){const{coverageInfo:e}=this;e.lonLatEnvelope=l.lonLatEnvelope,e.supportedInterpolations=g.standardizeInterpolations(s.supportedInterpolations),this._patchDimensionValues201(a,n)}this.datasetName=this.coverageInfo.title;const{rasterInfo:u}=this.coverageInfo;if(this.createRemoteDatasetStorageInfo(u,512,512),this._set("rasterInfo",u),null==u.spatialReference)throw new i("wcsraster-open",`coverage without spatial reference is not supported: ${a}`);const{pixelType:h,bandCount:p}=await this._getPixelTypeAndBandCount(n);u.pixelType=h,1===u.bandCount&&p>1&&(u.bandCount=p),this.updateTileInfo()}async _patchDimensionValues201(e,t){const{coverageInfo:i}=this,n=i.rasterInfo.multidimensionalInfo?.variables,s=I.has("1.1.2")?"1.1.2":I.has("1.1.1")?"1.1.1":I.has("1.1.0")?"1.1.0":null,{customFetchParameters:r}=this.ioConfig;if(n&&s)try{const i=this.url.includes("/ImageServer/"),o=e.length>8&&e.startsWith("Coverage")&&i?e.slice(8):e,a=await d.describeCoverage(this.url,{coverageIds:[o??e],version:s,customParameters:r,signal:t}).catch(()=>{if(o)return d.describeCoverage(this.url,{coverageIds:[e],version:s,customParameters:r,signal:t})}),l=a?.[0].rasterInfo.multidimensionalInfo?.variables;if(l)for(const e of n){const t=l.find(({name:t})=>t===e.name);if(t?.dimensions?.length)for(let n=e.dimensions.length-1;n>=0;n--){const s=e.dimensions[n],r=t.dimensions.find(({name:e})=>e===s.name);r?r.values&&r.extent?.join(",")===s.extent?.join(",")&&(e.dimensions[n]={...s,values:r.values}):i&&e.dimensions.splice(n,1)}}}catch{}}async _getPixelTypeAndBandCount(e){const{pixelSize:t,extent:s,multidimensionalInfo:r}=this.rasterInfo,o=s.center,a=new l({xmin:o.x-t.x,xmax:o.x+t.x,ymin:o.y-t.y,ymax:o.y+t.y,spatialReference:s.spatialReference});let c=[];if(null!=r){const e=r.variables[0];c=[],e.dimensions.forEach(t=>{c.push(new u({variableName:e.name,dimensionName:t.name,values:t.hasRegularIntervals?t.extent?.[0]:t.values?.[0],isSlice:!0}))})}const{coverageDescription:d}=this.coverageInfo,h={interpolation:"nearest",multidimensionalDefinition:c,signal:e},{version:p}=d,{ioConfig:f}=this,g="2.0"===p&&null==f.allowAnyMediaType||"1.1"===p&&null==f.use2GridOffsets;let m;try{m=await this._getCoverage(a,2,2,1,h,!0)}catch(e){if(!g)throw e;if("1.1"===p){if(!e.details?.isResolutionMismatch)throw e;f.use2GridOffsets=!0}}if(!m&&g&&("2.0"===p&&(f.allowAnyMediaType=!0),m=await this._getCoverage(a,2,2,1,h),m&&n.getLogger(this).warn("wcsraster:getcoverage",x)),!m)throw new i("wcsraster-open","unable to determine pixel type");const v=await this.decodePixelBlock(m,{width:2,height:2,planes:null,pixelType:null});if(null==v)throw new i("wcsraster-open","unable to determine pixel type");return{pixelType:v.pixelType,bandCount:v.getPlaneCount()??0}}async _getCoverage(e,t,s,r,o,a=!1){const{coverageDescription:l}=this.coverageInfo,{version:c}=l,d="2.0"===c?this._getCoverage201Parameters(e,t,s,r,o,l):"1.1"===c?this._getCoverage110Parameters(e,t,s,o,l):this._getCoverage100Parameters(e,t,s,o),u="2.0"===c?await this.request(this._constructWCS201Url(d),{signal:o.signal,responseType:"array-buffer"}):await this.request(this.url,{query:d,signal:o.signal,responseType:"array-buffer"});if("1.0"===c)return u.data;if("2.0"===c&&!1!==this.ioConfig.allowAnyMediaType&&"tiff"===m.getFormat(u.data))return a&&(this.ioConfig.allowAnyMediaType=!0,n.getLogger(this).warn("wcsraster:getcoverage",x)),u.data;const h=f.parse(u);if(h.isMultipart&&h.data){const e=h.data.find(e=>e.isValidImage);return a&&"base64"===e?.contentTransferEncoding&&n.getLogger(this).warn("wcsraster:getcoverage","response is base64 encoded which may impact layer display performance"),e?.contentData}const p=new Uint8Array(u.data,0,Math.min(u.data.byteLength,2e3)),g=String.fromCharCode.apply(null,p).toLowerCase().includes("exception"),v=g&&String.fromCharCode.apply(null,p).includes("A non-zero RESX/RESY or WIDTH/HEIGHT is required but neither was provided");if(g)throw new i("wcsraster:getcoverage","server returns an exception",{isResolutionMismatch:v});throw new i("wcsraster:getcoverage","response is not a supported multipart mediaType with inline tiff")}_getInterpolationIndex(e){return e&&this.coverageInfo.supportedInterpolations?.includes(e)?"nearest"===e?0:"bilinear"===e?1:"cubic"===e?2:0:0}_getCoverage100Parameters(e,t,i,n){const s=`${e.xmin},${e.ymin},${e.xmax},${e.ymax}`,r=e.spatialReference.wkid,o=(this.coverageInfo.supportedFormats||[]).find(e=>e.toLowerCase().includes("tiff"))||"GEOTIFF",{bandIds:a,interpolation:l}=n,c=this._getInterpolationIndex(l),d=a?a.map(e=>this.coverageInfo.bandNames[e]):null,u=w[c],{multidimensionalDefinition:h}=n;let p;if(null!=h&&null!=this.rasterInfo.multidimensionalInfo){const e=h.find(e=>"StdTime"===e.dimensionName);let t=e?.values;t&&t.length>0&&(Array.isArray(t[0])&&(t=t[0]),p=t.map(e=>C(e)).join(","))}return{service:"WCS",request:"GetCoverage",version:this.version,coverage:this.coverageId,format:o,crs:`EPSG:${r}`,bbox:s,width:t,height:i,time:p,interpolation:u,band:d?.join(",")}}_getCoverage110Parameters(e,t,i,n,s){const{multidimensionalDefinition:r,bandIds:o,interpolation:a}=n,l=e.spatialReference.wkid,d=`urn:ogc:def:crs:EPSG::${l}`,u=(this.coverageInfo.supportedFormats||[]).find(e=>e.toLowerCase().includes("tiff"))||"image/tiff",h=this._getInterpolationIndex(a),p=y[h],f=null==a||0===this.coverageInfo.supportedInterpolations?.indexOf(a),g=s.domain.spatialDomain,m=g.origin.x<=g.envelope.xmin&&g.origin.y<=g.envelope.ymin,v=e.width/t,w=e.height/i*(m?1:-1),x=m?[e.xmin,e.ymin]:[e.xmin,e.ymax],I=g.useEPSGAxis&&c.isAxesOrderReversedForWkid(l),b=I?`${x[1]},${x[0]}`:`${x[0]},${x[1]}`,$=this.ioConfig.use2GridOffsets,S=I?$?`${w},${v}`:`${w},0,0,${v}`:$?`${v},${w}`:`${v},0,0,${w}`,_=v/2,T=e.xmin+_,L=e.xmax-_,P=Math.abs(w)/2,R=e.ymin+P,D=e.ymax-P,A=I?`${R},${T},${D},${L},${d}`:`${T},${R},${L},${D},${d}`,E=s.range.find(e=>e.axis.some(e=>e.identifier.toLowerCase().includes("band")));let j,W=E&&p&&o?f?`${E.identifier}[${E.axis[0].identifier}[${o.join(",")}]]`:`${E.identifier}:${p}[${E.axis[0].identifier}[${o.join(",")}]]`:null;if(null!=r&&r.length)for(let e=0;e<r.length;e++){let t=r[e].values;const i=r[e].dimensionName?.toLowerCase(),n=r[e].variableName?.toLowerCase(),o=s.range.find(e=>e.identifier.toLowerCase()===n);if(t.length>0)if(Array.isArray(t[0])&&(t=t[0]),"stdtime"===i)j=t.map(e=>C(e)).join(",");else if(o){const e=o.axis.find(e=>e.identifier.toLowerCase()===i);e&&(W=f?o.identifier+"["+e.identifier+"["+t.join(",")+"]]":o.identifier+":"+p+"["+e.identifier+"["+t.join(",")+"]]")}e===r.length-1&&o&&!W&&(W=f?o.identifier:o.identifier+":"+p)}return{service:"WCS",request:"GetCoverage",version:this.version,identifier:this.coverageId,format:u,crs:`EPSG:${l}`,boundingbox:A,gridCS:"urn:ogc:def:cs:OGC:0.0:Grid2dSquareCS",gridType:"urn:ogc:def:method:WCS:1.1:2dGridIn2dCrs",gridOrigin:b,gridOffsets:S,gridBaseCRS:d,timeSequence:j,rangeSubset:W}}_getCoverage201Parameters(e,t,i,n,s,r){const{multidimensionalDefinition:o,interpolation:a}=s,l=this._getInterpolationIndex(a);let c=null;const{supportedInterpolations:d}=this.capabilities;if(d?.length)switch(l){case 0:c=d.find(e=>e.toLowerCase().includes("nearest"));break;case 1:c=d.find(e=>e.toLowerCase().includes("linear"));break;case 2:c=d.find(e=>e.toLowerCase().includes("cubic")||e.toLowerCase().includes("quadratic"))}const u=(this.coverageInfo.supportedFormats||[]).find(e=>e.toLowerCase().includes("tiff"))||"image/tiff",{bandNames:h}=this.coverageInfo,{boundedBy:p,domainSet:f,rangeType:g}=r,m=p.isEastFirst?0:1,v=1-m,{axisLabels:w}=p,y=w[m],x=w[v],I=`http://www.opengis.net/def/crs/EPSG/0/${e.spatialReference.wkid}`,b=I,$=[];$.push(`${y}(${e.xmin},${e.xmax})`),$.push(`${x}(${e.ymin},${e.ymax})`);const S=[];if(w.length>2)for(let e=2;e<w.length;e++){const t=f.origin[e];if(w[e].toLowerCase().includes("time")){let i=t.toString();p.uomLabels?.[e].toLowerCase().includes("ole")&&(S.push(w[e]),i=C(t,!0)),$.push(w[e]+",http://www.opengis.net("+i+")")}else $.push(w[e]+",http://www.opengis.net("+t+")")}let _=null;if(null!=o&&o.length){const e=[];g.forEach(t=>t.forEach(t=>e.push(t.name)));const t=[];for(let i=0;i<o.length;i++){const n=w.find(e=>e===o[i].dimensionName),s=e.find(e=>e===o[i].variableName);if(t.includes(s)||t.push(s),n){let e=o[i].values;if(e.length>0){Array.isArray(e[0])&&(e=e[0]);let t="";t=n.toLowerCase().includes("time")?e.map(e=>C(e)).join(","):e.join(",");const i=$.findIndex(e=>e.startsWith(n+",http://www.opengis.net"));-1===i&&$.push(n+",http://www.opengis.net("+t+")"),-1===i||$[i].includes("("+t+")")||$.splice(i,1,n+",http://www.opengis.net("+t+")")}}}t.length&&(_=t.join(","))}else h?.length>=2&&(_=(s.bandIds?s.bandIds.map(e=>h[e]):h).join(","));const T=$.join("&subset="),L=!r.domainSet.hasSameAxisLabelsAsBoundedBy&&!1!==this.ioConfig.allowScaleFactor,P=L?null:`${y}(${t}),${x}(${i})`,R=L?1/n:null;return{service:"WCS",request:"GetCoverage",version:this.version,coverageId:this.coverageId,rangesubset:_,interpolation:c,scaleSize:P,scaleFactor:R,subset:T,format:u,mediaType:this.ioConfig.allowAnyMediaType?null:"multipart/related",outputcrs:I,subsettingcrs:b}}_constructWCS201Url(e){const t={...this.ioConfig.customFetchParameters,...e},i=[];return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&("subset"===e?"string"==typeof n&&n.split("&subset=").forEach(e=>{e&&i.push(`subset=${encodeURIComponent(e)}`)}):i.push(`${e}=${encodeURIComponent(n)}`))}),`${encodeURI(this.url)}?${i.join("&")}`}},t.__decorate([s.property({type:String,json:{write:!0}})],e.default.prototype,"datasetFormat",void 0),t.__decorate([s.property({readOnly:!0})],e.default.prototype,"tileType",void 0),t.__decorate([s.property({type:String,json:{write:!0}})],e.default.prototype,"version",void 0),t.__decorate([s.property({type:String,json:{write:!0}})],e.default.prototype,"coverageId",void 0),t.__decorate([s.property({readOnly:!0})],e.default.prototype,"rasterId",null),e.default=t.__decorate([a.subclass("esri.layers.support.rasterDatasets.WCSRaster")],e.default),e.default});