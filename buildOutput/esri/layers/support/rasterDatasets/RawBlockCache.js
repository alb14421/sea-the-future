// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../geometry/Point","./EphemeralBlockCache","../rasterFunctions/rasterProjectionHelper"],function(e,t,n,o){"use strict";const l=new Map,r=new n;e.decreaseRefCount=function(e,t,n){const o=l.get(e);if(!o)return null==t?r.decreaseRefCount(e,n):0;if(null==t||null==o[t])return r.decreaseRefCount(e,n);const c=o[t]?.cache,i=c?.get(n);if(c&&i){if(i.refCount--,0===i.refCount){c.delete(n);for(let e=0;e<o.length;e++)o[e]?.cache.delete(n);i.controller&&i.controller.abort()}return i.refCount}return 0},e.deleteBlock=function(e,t,n){const o=l.get(e);o?null!=t&&null!=o[t]?o[t]?.cache.delete(n):r.deleteBlock(e,n):null==t&&r.deleteBlock(e,n)},e.deleteRaster=function(e){l.delete(e)},e.getBlock=function(e,t,n){const o=l.get(e);if(!o)return null==t?r.getBlock(e,n):null;if(null==t||null==o[t]){for(let e=0;e<o.length;e++){const t=o[e]?.cache.get(n);if(t)return t.refCount++,t.block}return r.getBlock(e,n)}const c=o[t]?.cache.get(n);if(c)return c.refCount++,c.block;for(let e=0;e<o.length;e++){if(e===t||!o[e])continue;const l=o[e]?.cache,r=l?.get(n);if(l&&r)return r.refCount++,l.set(n,r),r.block}return null},e.getRasterId=function(e,t,n){const o=[];return null!=t&&o.push(`sliceId=${t}`),null!=n&&o.push(`bandIds=${n.join(",")}`),o.length?`${e}?${o.join("&")}`:e},e.putBlock=function(e,t,n,o,c=null){const i=l.get(e);if(!i)return void(null==t&&r.putBlock(e,n,o,c));if(null==t||null==i[t])return void r.putBlock(e,n,o,c);const u={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:c};o.then(()=>u.isResolved=!0).catch(()=>u.isRejected=!0),i[t]?.cache.set(n,u)},e.register=function(e,t){const n={extent:null,rasterInfo:t,cache:new Map},o=l.get(e);return o?(o.push(n),o.length-1):(l.set(e,[n]),0)},e.unregister=function(e,t){const n=l.get(e);n&&(n[t]=null,n.some(e=>null!=e)||l.delete(e))},e.update=function(e,n,r,c,i,u,a=null){const s=function(e,t){const n=l.get(e);return n?n[t]??null:null}(e,n);if(!s)return;const f=s.extent,{cache:h,rasterInfo:m}=s;if(f&&f.xmin===r.xmin&&f.xmax===r.xmax&&f.ymin===r.ymin&&f.ymax===r.ymax)return;c=c??0;const d=r.clone().normalize(),{spatialReference:x,transform:g}=m,p=new Set;for(let e=0;e<d.length;e++){const n=d[e];if(n.xmax-n.xmin<=c||n.ymax-n.ymin<=c)continue;let l=o.projectExtent(n,x,a);if(null==l)continue;if(null!=g&&(l=g.inverseTransform(l),null==l))continue;const r=new t({x:c,y:c,spatialReference:n.spatialReference});if(null==i&&!(i=o.projectResolution(r,x,n,a)))return;const{pyramidLevel:s,pyramidResolution:f,excessiveReading:h}=o.snapPyramid(i,m,u||"closest");if(h)return;const{storageInfo:y}=m,{origin:k}=y,{x:R,y:M}=f,B=Math.max(0,Math.floor((l.xmin-k.x)/R)),C=Math.max(0,Math.floor((k.y-l.ymax)/M)),b=Math.ceil(l.width/R-.1),j=Math.ceil(l.height/M-.1),v=s>0?y.pyramidBlockWidth:y.blockWidth,w=s>0?y.pyramidBlockHeight:y.blockHeight,$=y.blockBoundary[s];if(!$)continue;const I=1,P=Math.max($.minCol,Math.floor(B/v)-I),E=Math.max($.minRow,Math.floor(C/w)-I),H=Math.min($.maxCol,Math.floor((B+b-1)/v)+I),S=Math.min($.maxRow,Math.floor((C+j-1)/w)+I);for(let e=E;e<=S;e++)for(let t=P;t<=H;t++)p.add(`${s}/${e}/${t}`)}h.forEach((e,t)=>{if(!p.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}}),s.extent={xmin:r.xmin,ymin:r.ymin,xmax:r.xmax,ymax:r.ymax}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});