// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../chunks/tslib.es6","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../../geometry/Point","../../../geometry/SpatialReference","../PixelBlock","../RasterInfo","../RasterStorageInfo","./BaseRaster","./pamParser","./xmlUtilities","../rasterFormats/utils","../rasterFunctions/stretchUtils"],function(e,t,s,r,a,n,i,o,l,c,f,h,u,g,p,m,d,y){"use strict";const x=new Map;x.set("Int8","s8"),x.set("UInt8","u8"),x.set("Int16","s16"),x.set("UInt16","u16"),x.set("Int32","s32"),x.set("UInt32","u32"),x.set("Float32","f32"),x.set("Float64","f32"),x.set("Double64","f32");const w=new Map;w.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),w.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),w.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),w.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let I=class extends g{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async fetchRawTile(e,t,s,r={}){const{blockWidth:a,blockHeight:n,blockBoundary:i}=this.rasterInfo.storageInfo,o=i[e];if(!o||o.maxRow<t||o.maxCol<s||o.minRow>t||o.minCol>s)return null;const{bandCount:l,pixelType:c}=this.rasterInfo,{ranges:h,actualTileWidth:u,actualTileHeight:g}=this._getTileLocation(e,t,s);if(!h||0===h.length)return null;if(0===h[0].from&&0===h[0].to){const e=new Uint8Array(a*n);return new f({width:a,height:n,pixels:void 0,mask:e,validPixelCount:0})}const{bandIds:p}=this.ioConfig,m=this._getBandSegmentCount(),d=[];let y=0;for(y=0;y<m;y++)p&&!p.includes(y)||d.push(this.request(this._files.data,{range:{from:h[y].from,to:h[y].to},responseType:"array-buffer",signal:r.signal}));const x=await Promise.all(d),I=x.map(e=>e.data.byteLength).reduce((e,t)=>e+t),b=new Uint8Array(I),_=[];let R=0;for(y=0;y<m;y++)_.push(R),b.set(new Uint8Array(x[y].data),R),R+=x[y].data.byteLength;const A=w.get(this.rasterInfo.storageInfo.compression).decoderFormat,F=await this.decodePixelBlock(b.buffer,{width:a,height:n,format:A,planes:p?.length||l,offsets:_,pixelType:c});if(null==F)return null;let{noDataValue:S}=this.rasterInfo;if(null!=S&&"lerc"!==A&&!F.mask&&(S=S[0],null!=S)){const e=F.width*F.height,t=new Uint8Array(e);if(Math.abs(S)>1e24)for(y=0;y<e;y++)Math.abs((F.pixels[0][y]-S)/S)>1e-6&&(t[y]=1);else for(y=0;y<e;y++)F.pixels[0][y]!==S&&(t[y]=1);F.mask=t}let E=0,M=0;if(u!==a||g!==n){let e=F.mask;if(e)for(y=0;y<n;y++)if(M=y*a,y<g)for(E=u;E<a;E++)e[M+E]=0;else for(E=0;E<a;E++)e[M+E]=0;else for(e=new Uint8Array(a*n),F.mask=e,y=0;y<g;y++)for(M=y*a,E=0;E<u;E++)e[M+E]=1}return F}async _open(e){this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const t=e?e.signal:null,s=await this.request(this.url,{responseType:"xml",signal:t}),{rasterInfo:r,files:a}=this._parseHeader(s.data),{skipMapInfo:n,skipExtensions:i=[]}=this.ioConfig;if(!i.includes("aux.xml")&&!n){const t=await this._fetchAuxiliaryData(e);null!=t&&(r.statistics=t.statistics??r.statistics,r.histograms=t.histograms,t.histograms&&null==r.statistics&&(r.statistics=y.estimateStatisticsFromHistograms(t.histograms)))}n&&this.updateImageSpaceRasterInfo(r),this._set("rasterInfo",r),this._files=a;const o=await this.request(a.index,{responseType:"array-buffer",signal:t});this._storageIndex=function(e){if(e.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let t,s,r,a,n,i;if(d.isPlatformLittleEndian){for(s=new Uint8Array(e),a=new ArrayBuffer(e.byteLength),r=new Uint8Array(a),n=0;n<e.byteLength/4;n++)for(i=0;i<4;i++)r[4*n+i]=s[4*n+3-i];t=new Uint32Array(a)}else t=new Uint32Array(e);return t}(o.data);const{blockWidth:l,blockHeight:c}=this.rasterInfo.storageInfo,f=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:h,height:u}=this.rasterInfo,g=[],p=this._getBandSegmentCount();let m=0,x=-1;for(;m<this._storageIndex.length;){x++;const e=Math.ceil(h/l/f**x)-1,t=Math.ceil(u/c/f**x)-1;m+=(e+1)*(t+1)*p*4,g.push({maxRow:t,maxCol:e,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=g,x>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=x),this.updateTileInfo()}_getBandSegmentCount(){return w.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(e,t,s){const{blockWidth:r,blockHeight:a,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:i,height:o}=this.rasterInfo,l=this._getBandSegmentCount();let c,f,h,u=0,g=0;for(h=0;h<e;h++)g=n**h,c=Math.ceil(i/r/g),f=Math.ceil(o/a/g),u+=c*f;g=n**e,c=Math.ceil(i/r/g),f=Math.ceil(o/a/g),u+=t*c+s,u*=4*l;const p=this._storageIndex.subarray(u,u+4*l);let m=0,d=0;const y=[];for(let e=0;e<l;e++)m=p[4*e]*2**32+p[4*e+1],d=m+p[4*e+2]*2**32+p[4*e+3]-1,y.push({from:m,to:d});return{ranges:y,actualTileWidth:s<c-1?r:Math.ceil(i/g)-r*(c-1),actualTileHeight:t<f-1?a:Math.ceil(o/g)-a*(f-1)}}_parseHeader(e){const s=m.getElement(e,"MRF_META/Raster");if(!s)throw new t("mrf:open","not a valid MRF format");const r=m.getElement(s,"Size"),a=parseInt(r.getAttribute("x"),10),n=parseInt(r.getAttribute("y"),10),i=parseInt(r.getAttribute("c"),10),f=(m.getElementValue(s,"Compression")||"none").toLowerCase();if(!w.has(f))throw new t("mrf:open","currently does not support compression "+f);const g=m.getElementValue(s,"DataType")||"UInt8",d=x.get(g);if(null==d)throw new t("mrf:open","currently does not support pixel type "+g);const y=m.getElement(s,"PageSize"),I=parseInt(y.getAttribute("x"),10),b=parseInt(y.getAttribute("y"),10),_=m.getElement(s,"DataValues");let R,A;if(_&&(A=_.getAttribute("NoData"),null!=A&&(R=A.trim().split(" ").map(e=>parseFloat(e)))),m.getElement(e,"MRF_META/CachedSource"))throw new t("mrf:open","currently does not support MRF referencing other data files");const F=m.getElement(e,"MRF_META/GeoTags"),S=m.getElement(F,"BoundingBox");let E,M=!1;if(null!=S){const e=parseFloat(S.getAttribute("minx")),t=parseFloat(S.getAttribute("miny")),s=parseFloat(S.getAttribute("maxx")),r=parseFloat(S.getAttribute("maxy")),a=m.getElementValue(F,"Projection")||"";let n=c.WGS84;if("LOCAL_CS[]"!==a)if(a.toLowerCase().startsWith("epsg:")){const e=Number(a.slice(5));isNaN(e)||0===e||(n=new c({wkid:e}))}else n=p.parseSpatialReference(a)??c.WGS84;else M=!0,n=new c({wkid:3857});E=new o(e,t,s,r),E.spatialReference=n}else M=!0,E=new o({xmin:-.5,ymin:.5-n,xmax:a-.5,ymax:.5,spatialReference:new c({wkid:3857})});const k=m.getElement(e,"MRF_META/Rsets"),C=parseInt(k?.getAttribute("scale")||"2",10),T=E.spatialReference,L=new u({origin:new l({x:E.xmin,y:E.ymax,spatialReference:T}),blockWidth:I,blockHeight:b,pyramidBlockWidth:I,pyramidBlockHeight:b,compression:f,pyramidScalingFactor:C}),U=new l({x:E.width/a,y:E.height/n,spatialReference:T}),B=new h({width:a,height:n,extent:E,isPseudoSpatialReference:M,spatialReference:T,bandCount:i,pixelType:d,pixelSize:U,noDataValue:R,storageInfo:L}),P=m.getElementValue(e,"datafile"),H=m.getElementValue(e,"IndexFile");return{rasterInfo:B,files:{mrf:this.url,index:H||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",w.get(f).blobExtension)}}}async _fetchAuxiliaryData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return p.parsePAMInfo(t)}catch{return null}}};return e.__decorate([s.property()],I.prototype,"_files",void 0),e.__decorate([s.property()],I.prototype,"_storageIndex",void 0),e.__decorate([s.property({type:String,json:{write:!0}})],I.prototype,"datasetFormat",void 0),I=e.__decorate([i.subclass("esri.layers.support.rasterDatasets.MRFRaster")],I),I});