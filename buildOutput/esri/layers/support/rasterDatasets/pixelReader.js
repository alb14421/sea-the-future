// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../core/Error","../../../core/promiseUtils","../../../geometry/Extent","../../../geometry/Point","../Field","../PixelBlock","../rasterFormats/pixelRangeUtils","../rasterFunctions/clipUtils","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../rasterFunctions/stretchUtils","../../../renderers/support/rasterRendererHelper","../../../rest/support/ImageIdentifyParameters"],function(e,t,i,n,a,o,r,s,l,c,u,p,f,x,m){"use strict";const d=2**30,h=2048;async function y(e,t){return"imagery"===e.type?await e.generateRasterInfo(e.rasterFunction,t)??e.serviceRasterInfo:e.raster.rasterInfo}function w(e){const t=[new r({name:"PixelID",alias:"Pixel ID",type:"oid"})],{pixelType:i}=e,n="f32"===i?"single":"f64"===i?"double":"integer";return x.getBandNames(e).forEach(e=>{t.push(new r({name:e,alias:e,type:n}))}),t.map(e=>e.toJSON())}async function g(t,n){if(t.spatialReference.equals(n))return t;if("polyline"===t.type){const a=(await new Promise((t,i)=>e(["../../../geometry/operators/projectOperator"],t,i))).execute(t,n);if(null==a)throw new i("read-pixels","failed to project the geometry into the layer's spatial reference");return a}if("extent"===t.type||t.rings[0].length<20){const i=(await new Promise((t,i)=>e(["../../../geometry/operators/lengthOperator"],t,i))).execute(t,{unit:"meters"})/100;t=(await new Promise((t,i)=>e(["../../../geometry/operators/densifyOperator"],t,i))).execute(t,i,{unit:"meters"}),await p.load(),t=p.projectPolygon(t,n)}return t}async function b(e,t){const{spatialReference:i}=e,n=t?.geometry,a=await g(n??e.extent,i),r="extent"===a.type?a:a.extent,s=null==n||"extent"===n.type&&n.spatialReference.equals(i)?void 0:a,l=new o({x:e.pixelSize.x,y:e.pixelSize.y,spatialReference:i}),u=!!t?.autoResample,p=u?l:t?.pixelSize??l;let{extent:f,width:x,height:m}=c.snapToRaster(e,r,p);if(!u)return{extent:f,clipGeometry:s,width:x,height:m,pixelSize:p};const d=e.storageInfo?.pyramidScalingFactor??2;let{x:h,y}=p;const w=t?.maxPixelCount??1048576;if(x*m>w)for(;x*m>w;)h*=d,y*=d,x/=d,m/=d;return x=Math.round(x),m=Math.round(m),{extent:f,clipGeometry:s,width:x,height:m,pixelSize:new o({x:h,y,spatialReference:i})}}async function*k(e,t,i=!1,o){const{extent:r,clipGeometry:s,width:l,height:u}=t,p=r.width/l,f=r.height/u,x=Math.ceil(l/h),m=Math.ceil(u/h),d=p*h,y=f*h,{xmin:w,xmax:g,ymin:b,ymax:k}=r,S=m*x,B={bandIds:t.bandIds?.length?t.bandIds:void 0,interpolation:"nearest",...o};for(let t=0;t<m;t++)for(let o=0;o<x;o++){n.throwIfAborted(B);const l=new a({xmin:w+o*d,xmax:i?Math.min(g,w+(o+1)*d):w+(o+1)*d,ymax:k-t*y,ymin:i?Math.max(b,k-(t+1)*y):k-(t+1)*y,spatialReference:r.spatialReference}),u={row:t,col:o},m=t*x+o+1;if(s&&!l.intersects(s)){yield{extent:l,pixelBlock:null,id:u,total:S,current:m};continue}const P=i?Math.round(l.width/p):h,I=i?Math.round(l.height/f):h;let{pixelBlock:R}=await e.fetchPixels(l,P,I,B).catch(()=>({pixelBlock:void 0}));R&&s&&(R=await c.clip(R,l,s)),yield{extent:l,pixelBlock:R,id:u,total:S,current:m}}}function S(e,t,n){const a=l.getByteCount(t),{width:o,height:r}=e;if(o*r*a>d)throw new i("fetch-pixels","failed to fetch pixels as pixel byte count exceeds the 1GB limit");if(n&&o*r>n)throw new i("fetch-pixels",`failed to fetch pixels as pixel count exceeds the ${n} limit`)}async function B(e,t,i){if("imagery"===e.type){const n=await e.identify(new m({geometry:t,returnCatalogItems:!1}),i).catch(()=>null);return null==n?.value||n.value.includes("NoData")?null:n.value.replaceAll(", "," ").split(" ").map(e=>Number(e))}const n=await e.identify(t,i).catch(()=>null);return n?.value}function P(e){return e.reduce((e,t)=>e.map((e,i)=>e+t[i]))}async function I(e,t,i){const n=await R(e,t.geometry,u.getValidPixels,i);return n?.flat()??[]}async function R(t,a,o,r){const s=t.spatialReference;if("polyline"===a.type&&!a.spatialReference.equals(s)){const t=(await new Promise((t,i)=>e(["../../../geometry/operators/projectOperator"],t,i))).execute(a,s);if(null==t)throw new i("read-pixels","failed to fetch pixels");a=t}const l="polyline"===a.type?a.extent:a,u=await g(l,s),p="polyline"===a.type?a:u,f=await y(t,r),x={geometry:u,autoResample:!1},m=[],d=k(t,await b(f,x),!0,r);for await(const e of d){if(!e.pixelBlock)continue;const{extent:t}=e,i=o(await c.clip(e.pixelBlock,t,p),t);m.push(i),n.throwIfAborted(r)}return m}async function F(e,t){const{rasterJobHandler:i}=e,{pixelBlock:n}=e,{statistics:a,histograms:o}=i?await i.computeStatisticsHistograms({pixelBlock:n},t):f.computeStatisticsHistograms(n);return{statistics:a,histograms:o}}async function T(e,t){const{extent:i,fields:n,skipFactor:a,rasterJobHandler:o,pixelIdOffset:r,imageRowSize:s}=e,{pixelBlock:l}=e,c=n.map(({name:e})=>e),p=o?await o.convertPixelBlockToFeatures({pixelBlock:l,extent:i,fieldNames:c,skipFactor:a,pixelIdOffset:r,imageRowSize:s},t):u.convertPixelBlockToFeatures({pixelBlock:l,extent:i,fieldNames:c,skipFactor:a,pixelIdOffset:r,imageRowSize:s});return p?{fields:n,features:p}:void 0}function v(e){return"_rasterJobHandler"in e?e._rasterJobHandler:null}async function M(e,t,i){const n=await y(e);t={...t,maxPixelCount:t.maxPixelCount??2**28};const a=await b(n,t);S(a,n.pixelType,t.maxPixelCount);const o=[],r=k(e,a,!1,i);for await(const e of r)o.push(e.pixelBlock);if(!o.some(e=>null!=e))return null;const{width:s,height:l}=a,c=Math.ceil(s/h),p=Math.ceil(l/h),f={width:c*h,height:p*h};let x;const m=v(e);if(m){const e=await m.mosaicAndTransform({srcPixelBlocks:o,srcMosaicSize:f,destDimension:f},{...i,transferPixelsToWorker:!0});x=e?.pixelBlock}else x=u.mosaic(o,f);return x}t.computeBoxStatistics=async function(e,t,i){const{geometry:n}=t;if("multipoint"===n.type)return async function(e,t,i){const n=await y(e,i),a=t.points.map((e,i)=>t.getPoint(i)).map(t=>B(e,t,i)),o=(await Promise.all(a)).filter(e=>null!=e);if(o.length<=1)return r=o[0],r?.map(e=>({min:e,max:e,avg:e,median:e,quartile1:e,quartile3:e}));var r;const l=o[0].map((e,t)=>o.map(e=>e[t]));return f.computeBoxStatistics(new s({pixels:l,pixelType:n.pixelType}))}(e,n,i);if("polyline"===n.type)return async function(e,t,i){const n=await I(e,{geometry:t},i),a=await y(e,i),{bandCount:o,pixelType:r}=a,l=new Array(o).fill(0).map(()=>s.createEmptyBand(r,n.length));let c=0;for(let e=0;e<n.length;e++){const t=n[e];if(null!=t.value){c++;for(let i=0;i<o;i++)l[i][e]=t.value[i]}}return c!==n.length&&l.forEach((e,t)=>{l[t]=e.subarray(0,c)}),f.computeBoxStatistics(new s({pixels:l,pixelType:r}))}(e,n,i);const a=await M(e,{geometry:n},i);return a?f.computeBoxStatistics(a):null},t.computeRasterAttributeTable=async function(e,t,n){const a=await y(e,n);if(!a.attributeTable||!a.pixelType.startsWith("u"))return null;const o=a.attributeTable.clone(),r=o.fields.find(e=>"value"===e.name.toLowerCase()),s=o.fields.find(e=>"count"===e.name.toLowerCase());if(!r||!s)throw new i("compute-attribute-table","Value or count field not found in attribute table");const l=2**Number(a.pixelType.slice(1)),c=new Uint32Array(l),{geometry:p}=t;return await R(e,p,(e,t)=>u.countCategoricalPixels(e,c),n),o.features.forEach(e=>{const t=e.attributes[r.name];e.attributes[s.name]=c[t]}),o},t.computeStatisticsHistograms=async function(e,t,n){if(!t.geometry)throw new i("compute-statistics-histograms","geometry is required to fetch pixel feature set");const a=await M(e,t,n);if(!a)throw new i("compute-statistics-histograms","failed to get intersecting pixels");const o=v(e);return o?await o.computeStatisticsHistograms({pixelBlock:a,includeSkewnessKurtosis:!0},{...n,transferPixelsToWorker:!0}):f.computeStatisticsHistograms(a,{includeSkewnessKurtosis:!0})},t.convertPixelSampleResultToFeatureSet=function(e,t){const i=w(t),n=i.map(({name:e})=>e),a=[],o=n.length-1;for(let t=0;t<e.length;t++){const i=e[t];if(i.pixelValue){const e={objectId:t};for(let t=0;t<o;t++)e[n[t+1]]=i.pixelValue[t];a.push({geometry:i.location,attributes:e})}}return{fields:i,features:a}},t.createPixelFeatureSetCursor=async function*(e,t,i){const a=await y(e,i),o=w(a),r={...t,geometry:t?.geometry??a.extent},s=k(e,await b(a,r),!0,i),l=a.width;for await(const r of s){if(!r.pixelBlock){yield{...r};continue}const s=v(e),{pixelBlock:c}=r,{statistics:u,histograms:p}=await F({pixelBlock:c,rasterJobHandler:s},i),f=r;f.statistics=u,f.histograms=p;const x=r.id.row*a.width*h+r.id.col*h;n.throwIfAborted(i),f.featureSet=await T({pixelBlock:c,extent:r.extent,fields:o,skipFactor:t?.skipFactor??1,rasterJobHandler:s,pixelIdOffset:x,imageRowSize:l},i),n.throwIfAborted(i),yield f}},t.fetchLargePixelBlock=M,t.fetchPixelFeatureSet=async function(e,t,n){if(!t.geometry)throw new i("fetch-pixels","geometry is required to fetch pixel feature set");const a=await y(e),o=await b(a,t);S(o,a.pixelType);const{extent:r,pixelSize:s}=o,l=Math.round(a.extent.width/s.x),c=w(a),u={fields:c,features:[]},p=u.features,f=k(e,o,!1,n);for await(const i of f){if(!i.pixelBlock)continue;const o=v(e),r=Math.floor((a.extent.ymax-i.extent.ymax)/s.y)*l+Math.floor((i.extent.xmin-a.extent.xmin)/s.x),u=await T({pixelBlock:i.pixelBlock,extent:i.extent,fields:c,skipFactor:t?.skipFactor??1,rasterJobHandler:o,pixelIdOffset:r,imageRowSize:l},n);if(u?.features?.length){const{features:e}=u,t=e.length;for(let i=0;i<t;i++){const t=e.pop();p.push(t)}}}return{extent:r,featureSet:u,pixelSize:s}},t.identifyAveragePixelValue=async function(e,t,i){const{geometry:n}=t;if("point"===n.type)return B(e,n,i);if("multipoint"===n.type){const t=n.points.map((e,t)=>n.getPoint(t)).map(t=>B(e,t,i)),a=(await Promise.all(t)).filter(e=>null!=e);return 0===a.length?null:P(a).map(e=>e/a.length)}const a=await R(e,n,(e,t)=>function(e){const{width:t,height:i,pixels:n,mask:a}=e,o=new Array(n.length).fill(0);let r=0;for(let e=0;e<i;e++)for(let i=0;i<t;i++){const s=e*t+i;if(!a||a[s]){for(let e=0;e<n.length;e++)o[e]+=n[e][s];r++}}return{bandSum:o,count:r}}(e),i),o=a?.filter(e=>e.count>0);if(!o?.length)return null;const r=P(o.map(e=>e.bandSum)),s=o.map(e=>e.count).reduce((e,t)=>e+t);return r.map(e=>e/s)},t.readIntersectingPixels=I,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});