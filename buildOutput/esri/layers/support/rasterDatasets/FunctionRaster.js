// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../chunks/tslib.es6","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Polygon","./BaseRaster","../rasterFunctions/clipUtils","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../../../rest/support/FeatureSet"],function(e,t,r,s,i,a,o,n,l,c,p,u,d,h,m){"use strict";return t.default=class extends p{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,r,s={}){const{rasters:i,rasterIds:a}=this.primaryRasters;let o=!1;const{interpolation:n}=s,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!s.requestRawData&&l&&(o=1===i.length&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:o}),s.requestRawData&&i.length>1&&!this.hasUniqueSourceStorageInfo&&(o=!1,s={...s,requestRawData:!1});const c=i.map(i=>i.fetchPixels(e,t,r,s)),p=await Promise.all(c),h=p.map(e=>e.pixelBlock),m=o||s.requestRawData?p.map(e=>e.srcTilePixelSize):null;if(s.skipRasterFunction||h.every(e=>null==e))return p[0];const y=p.find(e=>null!=e.pixelBlock)?.extent??e;let f=this.rasterJobHandler?await this.rasterJobHandler.process({extent:y,primaryPixelBlocks:h,primaryPixelSizes:m,primaryRasterIds:a}):this.rasterFunction.process({extent:y,primaryPixelBlocks:h,primaryPixelSizes:m,primaryRasterIds:a});const{transformGrid:g}=p[0];if(!o||null==f||null==g){const e=s.noClip?null:this.getClippingGeometry(y.spatialReference);return s.noClip||s.requestRawData||null==f||!e||(f=await u.clip(f,y,e)),{...p[0],pixelBlock:f}}const x={rows:g.spacing[0],cols:g.spacing[1]};let R;R=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[f],srcMosaicSize:{width:f.width,height:f.height},destDimension:{width:t,height:r},coefs:g.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:n,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock:d.approximateTransform(f,{width:t,height:r},g.coefficients,x,n);const w=s.noClip?null:this.getClippingGeometry(e.spatialReference);return s.noClip||s.requestRawData||null==R||null==w||(R=await u.clip(R,e,w)),{extent:e,srcExtent:p[0].srcExtent,pixelBlock:R}}getClippingGeometry(e){const t=this._clippingGeometry.get("0");if(!e||!t)return t;const r=function(e){return String(e.wkid??e.wkt??e.wkt2)}(e);let s=this._clippingGeometry.get(r);return null!=s||(s=e.equals(t.spatialReference)?t:h.projectPolygon(t,e),this._clippingGeometry.set(r,s)),s}async _open(e){const{rasterFunction:t}=this;t.isRoot=!0,this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(e=>e.rasterJobHandler=this.rasterJobHandler));const{rasters:r,rasterIds:i}=this.primaryRasters,a=r.map(t=>t.rasterInfo?void 0:t.open(e));await Promise.all(a);const o=r.map(({rasterInfo:e})=>e),n=t.bind({rasterInfos:o,rasterIds:i});if(t.rawSourceRasterInfos=o,!n.success||0===o.length)throw new s("raster-function:open",`cannot bind the function: ${n.error??""}`);const l="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===l?.functionName&&(t.rasterInfo.attributeTable=m.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=o[0];this.hasUniqueSourceStorageInfo=1===o.length||o.slice(1).every(e=>function(e,t){const{storageInfo:r,pixelSize:s,spatialReference:i,extent:a}=e,{storageInfo:o,pixelSize:n,spatialReference:l,extent:c}=t;return s.x===n.x&&s.y===n.y&&i.equals(l)&&a.equals(c)&&r.blockHeight===o.blockHeight&&r.blockWidth===o.blockWidth&&r.maximumPyramidLevel===o.maximumPyramidLevel&&r.firstPyramidLevel===o.firstPyramidLevel&&r.pyramidBlockWidth===o.pyramidBlockWidth&&r.pyramidBlockHeight===o.pyramidBlockHeight&&r.pyramidScalingFactor===o.pyramidScalingFactor}(e,c)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let r=t?.clippingGeometry;if(r&&"inside"===t.clippingType){const{extent:t}=this.rasterInfo,s=await new Promise((t,r)=>e(["../../../geometry/operators/densifyOperator"],t,r)),i=await new Promise((t,r)=>e(["../../../geometry/operators/differenceOperator"],t,r));let a=s.execute(c.fromExtent(t),2*(t.width+t.height)/40);a=h.projectPolygon(a,r.spatialReference),r=i.execute(a,r)}this._clippingGeometry.clear(),r&&this._clippingGeometry.set("0",r)}},r.__decorate([i.property({type:String,json:{write:!0}})],t.default.prototype,"datasetFormat",void 0),r.__decorate([i.property()],t.default.prototype,"tileType",void 0),r.__decorate([i.property()],t.default.prototype,"rasterFunction",void 0),r.__decorate([i.property()],t.default.prototype,"primaryRasters",void 0),t.default=r.__decorate([l.subclass("esri.layers.support.rasterDatasets.FunctionRaster")],t.default),t.default});