// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../chunks/tslib.es6","../../../core/Error","../../../core/maybe","../../../core/urlUtils","../../../core/accessorSupport/decorators/property","../../../core/has","../../../core/Logger","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../../geometry/Point","../../../geometry/SpatialReference","../RasterInfo","../RasterStorageInfo","../TileInfo","../TilemapCache","./BaseRaster","../rasterFunctions/pixelUtils","../rasterTransforms/GCSShiftTransform","../../../rest/imageService/fetchRasterInfo"],function(e,t,i,s,a,l,r,n,o,c,u,h,m,f,p,d,y,x,g,v){"use strict";let S=class extends y{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async fetchRawTile(e,t,i,s={}){const{storageInfo:a,extent:l}=this.rasterInfo,{transposeInfo:r}=a,n=null!=r&&!!s.transposedVariableName;if(this._slices&&!n&&null==s.sliceId)return null;const o=n?0:a.maximumPyramidLevel-e+this._levelOffset,c=`${this.url}/tile/${o}/${t}/${i}`,u=this._slices?n?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null;let h,m;if(a.isBsqTile){const e=(s.bandIds?.length?s.bandIds:[0,1,2]).map(e=>this.request(c,{query:{...u,bandId:e},responseType:"array-buffer",signal:s.signal})),t=await Promise.all(e),i=t.map(e=>e.data.byteLength).reduce((e,t)=>e+t),a=new Uint8Array(i);m=[];let l=0;for(const{data:e}of t)m.push(l),a.set(new Uint8Array(e),l),l+=e.byteLength;h=a.buffer}else h=(await this.request(c,{query:u,responseType:"array-buffer",signal:s.signal})).data;if(!h)return null;const f=n?r.tileSize:a.tileInfo.size,p=await this.decodePixelBlock(h,{width:f[0],height:f[1],planes:m?.length,offsets:m,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:n,noDataValue:this.rasterInfo.noDataValue});if(null==p)return null;const d=a.blockBoundary[e];if("jpg"!==a.compression||i>d.minCol&&i<d.maxCol&&t>d.minRow&&t<d.maxRow)return p;const{origin:y,blockWidth:g,blockHeight:v}=a,{x:S,y:I}=this.getPyramidPixelSize(e),w=Math.round((l.xmin-y.x)/S)%g,b=Math.round((l.xmax-y.x)/S)%g||g,T=Math.round((y.y-l.ymax)/I)%v,_=Math.round((y.y-l.ymin)/I)%v||v,M=i===d.minCol?w:0,O=t===d.minRow?T:0,R=i===d.maxCol?b:g,L=t===d.maxRow?_:v;return x.setValidBoundary(p,{x:M,y:O},{width:R-M,height:L-O}),p}getSliceIndex(e){if(!this._slices||null==e||0===e.length)return null;const t=e;for(let e=0;e<this._slices.length;e++){const i=this._slices[e].multidimensionalDefinition;if(i.length===t.length&&!i.some(e=>{const i=t.find(t=>e.variableName===t.variableName&&t.dimensionName===e.dimensionName);return!i||(Array.isArray(e.values[0])?`${e.values[0][0]}-${e.values[0][1]}`:e.values[0])!==(Array.isArray(i.values[0])?`${i.values[0][0]}-${i.values[0][1]}`:i.values[0])}))return e}return null}async fetchVariableStatisticsHistograms(e,t){const i=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:t}).then(e=>e.data?.statistics),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:t}).then(e=>e.data?.histograms),a=await Promise.all([i,s]);return a[0]&&a[0].forEach(e=>{e.avg=e.mean,e.stddev=e.standardDeviation}),a[1]?.[0]?.counts?.length||(a[1]=null),{statistics:a[0]||null,histograms:a[1]||null}}async computeBestPyramidLevelForLocation(e,t={}){if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,t.datumTransformation);if(null===i)return null;let s=0;const{maximumPyramidLevel:a}=this.rasterInfo.storageInfo;let l=a-s+this._levelOffset;const r=i.srcLocation;for(;l>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(l,i.row,i.col,t))break}catch{}if(l--,s++,i=this.identifyPixelLocation(r,s,t.datumTransformation),null===i)return null}return-1===l||null==i?null:s}async _open(e){const a=e?.signal,l=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:a});l.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const r=l.data;if(this.sourceJSON=r,!r)throw new t("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!r.tileInfo)throw new t("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo(),this.tileType=r.cacheType,null==this.tileType&&(["jpg","jpeg","png","png8","png24","png32","mixed"].includes(r.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===r.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=r.name?.slice(r.name.indexOf("/")+1)??"";const n=await this._fetchRasterInfo({signal:a});if(null==n)throw new t("image-server-raster:open","cannot initialize image service");v.patchServiceInfo(n,r);const o="Map"===this.tileType?function(e,t){if(!e)return null;const{minScale:i,maxScale:s,minLOD:a,maxLOD:l}=t;if(null!=a&&null!=l)return p.fromJSON({...e,lods:e.lods.filter(({level:e})=>null!=e&&e>=a&&e<=l)});if(0!==i&&0!==s){const t=e=>Math.round(1e4*e)/1e4,a=i?t(i):1/0,l=s?t(s):-1/0;return p.fromJSON({...e,lods:e.lods.filter(e=>{const i=t(e.scale);return i<=a&&i>=l})})}return p.fromJSON(e)}(r.tileInfo,r):p.fromJSON(r.tileInfo);i.assertIsSome(o);const[c,u]=this._computeMinMaxLOD(n,o),{extent:h,pixelSize:m}=n,y=.5/n.width*m.x,x=Math.max(m.x,m.y),{lods:S}=o;("Map"!==this.tileType&&0!==r.maxScale||Math.abs(m.x-m.y)>y||!S.some(e=>Math.abs(e.resolution-x)<y))&&(m.x=m.y=c.resolution,n.width=Math.ceil((h.xmax-h.xmin)/m.x-.1),n.height=Math.ceil((h.ymax-h.ymin)/m.y-.1));const I=c.level-u.level,[w,b]=o.size,T=[],_=[];S.forEach((e,t)=>{e.level>=u.level&&e.level<=c.level&&T.push({x:e.resolution,y:e.resolution}),t<S.length-1&&_.push(Math.round(10*e.resolution/S[t+1].resolution)/10)}),T.sort((e,t)=>e.x-t.x);const M=this.computeBlockBoundary(h,w,b,o.origin,T,I),O=T.length>1?T.slice(1):null;let R;r.transposeInfo&&(R={tileSize:[r.transposeInfo.rows,r.transposeInfo.cols],packetSize:n.keyProperties?._yxs.PacketSize??0});const L=_.length<=1||_.length>=3&&_.slice(0,-1).every(e=>e===_[0])?_[0]??2:Math.round(10/(u.resolution/c.resolution)**(-1/I))/10;if(n.storageInfo=new f({blockWidth:o.size[0],blockHeight:o.size[1],pyramidBlockWidth:o.size[0],pyramidBlockHeight:o.size[1],pyramidResolutions:O,pyramidScalingFactor:L,compression:o.format,origin:o.origin,firstPyramidLevel:1,maximumPyramidLevel:I,tileInfo:o,isBsqTile:!!r.bsq,transposeInfo:R,blockBoundary:M}),function(e){const{extent:t,spatialReference:i}=e;t.xmin>-1&&t.xmax>181&&i?.wkid&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new g,e.extent=e.transform.forwardTransform(t))}(n),this._set("rasterInfo",n),r.capabilities.toLowerCase().includes("tilemap")){const e={tileInfo:n.storageInfo.tileInfo,parsedUrl:s.urlToObject(this.url),url:this.url,tileServers:[]};this._tilemapCache=new d.TilemapCache({layer:e})}}async _fetchRasterInfo(e){const t=this.sourceJSON;if("Map"===this.tileType){const e=t.fullExtent||t.extent,i=Math.ceil((e.xmax-e.xmin)/t.pixelSizeX-.1),s=Math.ceil((e.ymax-e.ymin)/t.pixelSizeY-.1),a=h.fromJSON(t.spatialReference||e.spatialReference),l=new u({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:a});return new m({width:i,height:s,bandCount:3,extent:c.fromJSON(e),spatialReference:a,pixelSize:l,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,s=v.fetchServiceRasterInfo(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),a=t.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:i}).then(e=>e.data?.slices).catch(()=>null):null,l=await Promise.all([s,a]);return this._slices=l[1],l[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_computeMinMaxLOD(e,t){const{pixelSize:i}=e,s=.5/e.width*i.x,{lods:a}=t,l=t.lodAt(Math.max.apply(null,a.map(e=>e.level))),r=t.lodAt(Math.min.apply(null,a.map(e=>e.level))),{tileType:n}=this;if("Map"===n)return this._levelOffset=a[0].level,[l,r];if("Raster"===n)return[a.find(e=>e.resolution===i.x)??l,r];const{minScale:o,maxScale:c}=this.sourceJSON;let u=l;c>0&&(u=a.find(e=>Math.abs(e.scale-c)<s),u||(u=a.filter(e=>e.scale>c).sort((e,t)=>e.scale>t.scale?1:-1)[0]??l));let h=r;return o>0&&(h=a.find(e=>Math.abs(e.scale-o)<s)??r,this._levelOffset=h.level-r.level),[u,h]}};return e.__decorate([a.property({type:String,json:{write:!0}})],S.prototype,"datasetFormat",void 0),e.__decorate([a.property()],S.prototype,"tileType",void 0),S=e.__decorate([o.subclass("esri.layers.support.rasterDatasets.ImageServerRaster")],S),S});