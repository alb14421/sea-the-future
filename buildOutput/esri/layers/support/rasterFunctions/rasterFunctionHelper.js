// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/colorUtils","../../../core/Error","../../../core/lang","./ArithmeticFunction","./AspectFunction","./BandArithmeticFunction","./ClipFunction","./ColormapFunction","./ColormapToRGBFunction","./CompositeBandFunction","./ComputeChangeFunction","./ContrastBrightnessFunction","./ConvolutionFunction","./CurvatureFunction","./ExtractBandFunction","./GrayscaleFunction","./HillshadeFunction","./LocalFunction","./MaskFunction","./NDVIFunction","./RemapFunction","./ShadedReliefFunction","./SlopeFunction","./StatisticsFunction","./StatisticsHistogramFunction","./StretchFunction","./TableFunction"],function(t,e,r,n,s,o,a,i,c,u,l,m,p,f,d,g,F,h,y,A,b,C,_,R,j,N,S,v){"use strict";const w=new Map;function T(t,e){return"rasters"===e[0]&&Array.isArray(t.rasters)?t.rasters:e.map(e=>t[e])}function V(t){return!!(t&&"object"==typeof t&&t.rasterFunction&&t.rasterFunctionArguments)}function B(t){const{rasterFunction:e,rasterFunctionArguments:r}=t,n={};for(const t in r){let e=r[t];const s=t.toLowerCase();if("rasters"===s&&Array.isArray(e))n.rasters=e.map(t=>V(t)?B(t):t);else switch(V(e)&&(e=B(e)),s){case"dra":n.dra=e;break;case"pspower":n.psPower=e;break;case"pszfactor":n.psZFactor=e;break;case"bandids":n.bandIds=e;break;default:n[t[0].toLowerCase()+t.slice(1)]=e}}return"Local"!==e||n.rasters?.length||(n.rasters=["$$"]),{...t,rasterFunctionArguments:n}}function D(t,e){const{rasterFunction:n,rasterFunctionArguments:s}=t,o=t.outputPixelType?.toLowerCase();if(null==n||!w.has(n))throw new r("raster-function-helper",`unsupported raster function: ${n}`);const a=w.get(n),i=("function"==typeof a.ctor?a.ctor:a.ctor.default).fromJSON({...t,outputPixelType:o}),{rasterArgumentNames:c}=i,u=[],l=T(s,c),m="rasters"===c[0]||c.length>1,p=[];for(let t=0;t<l.length;t++){const r=l[t];let n;null==r||"string"==typeof r&&r.startsWith("$")?u.push(e?.raster):"string"==typeof r?e[r]&&u.push(e[r]):"number"!=typeof r&&"rasterFunction"in r&&(n=D(r,e),m||(i.functionArguments[c[t]]=n),u.push(n)),m&&p.push(n??r)}if(m&&("rasters"===c[0]?i.functionArguments.rasters=p:c.forEach((t,e)=>{i.functionArguments[t]=p[e]})),e){i.sourceRasters=u;const t=e.raster?.url;t&&(i.mainPrimaryRasterId=t)}return i}function k(t,e){if(t&&e)for(const r in t){const n=t[r];n&&"object"==typeof n&&"type"in n&&("RasterFunctionTemplate"===n.type?k(n.arguments,e):"RasterFunctionVariable"===n.type&&null!=e[n.name]&&(n.value=e[n.name]))}}function x(t,e){if(!t||"object"!=typeof t)return t;const{value:n}=t;if(!n||"object"!=typeof n)return t.isDataset?"$$":n;if(Array.isArray(n))return 0===n.length?[]:n.map(t=>t&&"object"==typeof t&&"RasterFunctionVariable"===t.type?x(t,e):t);if("value"in n&&["number","string","boolean"].includes(typeof n.value))return n.value;if(t.isDataset&&"Scalar"!==n.type)return"$$";if(!("type"in n))return n;let s=n;switch(n.type){case"Scalar":s=n.value;break;case"AlgorithmicColorRamp":s=M(n);break;case"MultiPartColorRamp":s={type:"multipart",colorRamps:n.ArrayOfColorRamp.map(M)};break;case"ArgumentArray":if(n.elements?.length&&"RasterStatistics"!==n.elements[0].type){const t=[];for(let s=0;s<n.elements.length;s++){const o=n.elements[s],{type:a}=o;if(a)if("RasterFunctionTemplate"===a){const{renderingRule:r}=E(o,e);t.push(r),null!=o._object_id&&e.set(o._object_id,r)}else{if("RasterFunctionVariable"!==a)throw new r("raster-function-helper","unsupported raster function json.");{const r=x(o,e);t.push(r),null!=o._object_id&&e.set(o._object_id,r)}}else t.push(o)}s=t}else s=n.elements}return null!=n._object_id&&e.set(n._object_id,s),s}function M(t){const r=t.algorithm??"esriHSVAlgorithm";let{FromColor:n,ToColor:s}=t;if(!Array.isArray(n)){const{r:t,g:r,b:s}=e.toRGB({h:n.Hue,s:n.Saturation,v:n.Value});n=[t,r,s,n.AlphaValue]}if(!Array.isArray(s)){const{r:t,g:r,b:n}=e.toRGB({h:s.Hue,s:s.Saturation,v:s.Value});s=[t,r,n,s.AlphaValue]}return{type:"algorithmic",algorithm:r,fromColor:n,toColor:s}}function E(t,e,r){r&&k(t,r);const n={renderingRule:{},templates:e};return $(t,n),n}function $(t,e){if(!t||!e.renderingRule)return;const{renderingRule:r,templates:n}=e,{function:s,arguments:o,_object_id:a}=t;if(!s||!o)return;null!=a&&n.set(a,r),r.rasterFunction=s.type.replace("Function",""),r.outputPixelType=s.pixelType;const i={};r.rasterFunctionArguments=i;for(const t in o){if("type"===t||"object_id"===t||"_object_ref_id"===t)continue;const e=o[t];e&&"object"==typeof e&&"type"in e&&("RasterFunctionTemplate"===e.type||"RasterFunctionVariable"===e.type)?("RasterFunctionVariable"===e.type?i[t]=x(e,n):(r.rasterFunctionArguments[t]={},$(e,{renderingRule:r.rasterFunctionArguments[t],templates:n})),null!=e._object_id&&n.set(e._object_id,i[t])):i[t]=e}switch(i.DEM&&!i.Raster&&(i.Raster=i.DEM,delete i.DEM),r.rasterFunction){case"Stretch":!function(t){t.Statistics?.length&&"object"==typeof t.Statistics&&(t.Statistics=t.Statistics.map(t=>[t.min,t.max,t.mean,t.standardDeviation])),null!=t.NumberOfStandardDeviation&&(t.NumberOfStandardDeviations=t.NumberOfStandardDeviation,delete t.NumberOfStandardDeviation)}(i);break;case"Colormap":!function(t){"randomcolorramp"===t.ColorRamp?.type?.toLowerCase()&&(delete t.ColorRamp,t.ColormapName="Random"),0===t.ColorSchemeType&&delete t.ColorRamp}(i);break;case"Convolution":null!=(c=i).ConvolutionType&&(c.Type=c.ConvolutionType,delete c.ConvolutionType);break;case"Mask":!function(t){t.NoDataValues?.length&&"string"==typeof t.NoDataValues[0]&&(t.NoDataValues=t.NoDataValues.filter(t=>""!==t).map(t=>Number(t)))}(i)}var c}function H(t){const{renderingRule:e,templates:n}=t;if("object"!=typeof e||!e?.rasterFunctionArguments||!n.size)return;const{rasterFunctionArguments:s}=e;for(const t in s){const e=s[t],o="_object_ref_id"===t?e:e&&"object"==typeof e&&"_object_ref_id"in e?e._object_ref_id:null;if(null!=o){if(!n.has(o))throw new r("raster-function-helper",`unsupported raster function json. _object_ref_id: ${o} does not exist`);const e=n.get(o);"_object_ref_id"!==t?s[t]=e:e&&"object"==typeof e&&Object.assign(s,e);continue}e&&"object"==typeof e&&(e.rasterFunctionArguments&&H({renderingRule:e,templates:n}),Array.isArray(e)&&e.forEach((t,s)=>{if(t&&"object"==typeof t)if(null!=t._object_ref_id){if(!n.has(t._object_ref_id))throw new r("raster-function-helper",`unsupported raster function json. _object_ref_id: ${e} does not exist`);const a=n.get(o);a&&"object"==typeof a?Object.assign(t,a):e[s]=a}else H({renderingRule:t,templates:n})}))}}w.set("Arithmetic",{desc:"Arithmetic Function",ctor:s,rasterArgumentNames:["rasters"]}),w.set("Aspect",{desc:"Aspect Function",ctor:o,rasterArgumentNames:["raster"]}),w.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:a,rasterArgumentNames:["raster"]}),w.set("Colormap",{desc:"Colormap Function",ctor:c,rasterArgumentNames:["raster"]}),w.set("ColormapToRGB",{desc:"ColormapToRGB Function",ctor:u,rasterArgumentNames:["raster"]}),w.set("CompositeBand",{desc:"CompositeBand Function",ctor:l,rasterArgumentNames:["rasters"]}),w.set("ComputeChange",{desc:"ComputeChange Function",ctor:m,rasterArgumentNames:["rasters"]}),w.set("Convolution",{desc:"Convolution Function",ctor:f,rasterArgumentNames:["raster"]}),w.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:p,rasterArgumentNames:["raster"]}),w.set("ExtractBand",{desc:"ExtractBand Function",ctor:g,rasterArgumentNames:["raster"]}),w.set("Curvature",{desc:"Curvature Function",ctor:d,rasterArgumentNames:["raster"]}),w.set("Hillshade",{desc:"Hillshade Function",ctor:h,rasterArgumentNames:["raster"]}),w.set("ShadedRelief",{desc:"ShadedRelief Function",ctor:_,rasterArgumentNames:["raster"]}),w.set("Grayscale",{desc:"Grayscale Function",ctor:F,rasterArgumentNames:["raster"]}),w.set("Clip",{desc:"Clip Function",ctor:i,rasterArgumentNames:["raster"]}),w.set("Local",{desc:"Local Function",ctor:y,rasterArgumentNames:["rasters"]}),w.set("Mask",{desc:"Mask Function",ctor:A,rasterArgumentNames:["raster"]}),w.set("NDVI",{desc:"NDVI Function",ctor:b,rasterArgumentNames:["raster"]}),w.set("Remap",{desc:"Remap Function",ctor:C,rasterArgumentNames:["raster"]}),w.set("Slope",{desc:"Slope Function",ctor:R,rasterArgumentNames:["raster"]}),w.set("Statistics",{desc:"Focal Statistics Function",ctor:j,rasterArgumentNames:["raster"]}),w.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:N,rasterArgumentNames:["raster"]}),w.set("Stretch",{desc:"Stretch Function",ctor:S,rasterArgumentNames:["raster"]}),w.set("Table",{desc:"Attribute Table Function",ctor:v,rasterArgumentNames:["raster"]}),t.create=function(t,e){e=e??{};try{if("function"in(t=n.clone(t))&&"arguments"in t&&t.arguments){const n=E(t,new Map,e);if(H(n),!n.renderingRule)throw new r("raster-function-helper","Unsupported raster function json.");t=n.renderingRule}if("rasterFunction"in t){const r=D(t=B(t),e);return r.isRoot=!0,r}}catch{}throw new r("raster-function-helper","unsupported raster function json.")},t.getPrimaryRasterUrls=function t(e,r){const{rasterFunctionArguments:n}=e;n&&(n.rasters||[n.raster,n.raster2]).forEach(e=>{e&&"number"!=typeof e&&("string"==typeof e?e.startsWith("http")&&(r.includes(e)||r.push(e)):"rasterFunctionArguments"in e&&t(e,r))})},t.getRasterValues=T,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});