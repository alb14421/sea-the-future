// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../chunks/tslib.es6","../../../core/JSONSupport","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/cast","../../../core/has","../../../core/RandomLCG","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo"],function(t,e,s,r,o,n,i,a,p){"use strict";const u=new Set(["slope","aspect","curvature","hillshade","shadedrelief","statistics"]);let l=class extends e.JSONSupport{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0,this.id=-1,this.isNoopProcess=!1,this.rawInputBandIds=[],this.rawSourceRasterInfos=null,this.isInputBandIdsSwizzled=!1,this.swizzledBandSelection=[],this.isBranch=!1,this.isRoot=!1,this._bindingResult=null}get supportsGPU(){return this._bindingResult.supportsGPU}get flatWebGLFunctionChain(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let r=s.rasters||s.raster&&[s.raster];for(;r?.length;){e.unshift(...r);const t=[];for(let e=0;e<r.length;e++){const{parameters:s}=r[e],o=s.rasters||s.raster&&[s.raster];o?.length&&t.push(...o)}r=t}for(let t=e.length-1;t>=0;t--)e[t].isNoopProcess&&e.splice(t,1);let o=!1;for(let t=0;t<e.length;t++){const s=e[t];s.id=e.length-t-1;const{rasters:r}=s.parameters;o=o||null!=r&&r.length>1}const n=e.some(({name:t})=>u.has(t.toLowerCase())),{rawSourceRasterInfos:i}=this;return{functions:e,hasBranches:o,hasFocalFunction:n,isSourceSingleBand:1===i?.[0]?.bandCount}}bind(t,e=!1,s=-1){this.id=s+1;const r=this._getRasterValues();let o=!0;for(let s=0;s<r.length;s++){const n=r[s];if(null!=n&&this._isRasterFunctionValue(n)){const r=n.bind(t,e,this.id+s);if(!r.success)return this._bindingResult=r,r;o=o&&r.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),o&&=this._bindingResult.supportsGPU,this._bindingResult.success&&(this._patchRasterInfo(),o&&this.isRoot)&&(this.processInputBandIds(),this.swizzleInputBandIds(this.rawInputBandIds)||(o=this.rawInputBandIds.length<=3)),this._bindingResult.supportsGPU=o,this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this._bindingResult)}process(t){const e=this._getRasterValues(),s=0===e.length?t.pixelBlocks??t.primaryPixelBlocks:e.map(e=>this._readRasterValue(e,t));return this._processPixels({...t,pixelBlocks:s})}processInputBandIds(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);if(t.length>1){const e=t.map(t=>t.processInputBandIds());return this.rawInputBandIds=[...new Set(e.flat())],this.rawInputBandIds}const e=t[0];if(e)return this.rawInputBandIds=e.processInputBandIds(),this.rawInputBandIds;const{bandCount:s}=this.sourceRasterInfos[0],r=Array.from({length:s},(t,e)=>e);return this.rawInputBandIds=this._getInputBandIds(r),this.rawInputBandIds}swizzleInputBandIds(t){const e=this._getRasterValues().filter(this._isRasterFunctionValue);let s=!0;for(const r of e)s=r.swizzleInputBandIds(t)&&s;return!!s&&this._swizzleBandIds(t)}getPrimaryRasters(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}}getWebGLProcessorDefinition(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map(t=>this._isRasterFunctionValue(t)?t.getWebGLProcessorDefinition():"number"==typeof t?{name:"Constant",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}),t.rasters.some(t=>null!=t)||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}}getClippingGeometries(){const t=[];"Clip"===this.functionName&&t.push(this.functionArguments);const{raster:e,rasters:s}=this.functionArguments;if(s&&Array.isArray(s)&&s.length)s.forEach(e=>{if(this._isRasterFunctionValue(e)){const s=e.getClippingGeometries();t.push(...s)}});else if(this._isRasterFunctionValue(e)){const s=e.getClippingGeometries();t.push(...s)}return t}_getOutputPixelType(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t}_getWebGLParameters(){return{}}_getInputBandIds(t){return t}_swizzleBandIds(t){return!0}_isInputRasterPrimaryOrConstant(){return!this._getRasterValues().some(t=>t&&"object"==typeof t&&"rasterFunction"in t&&t.rasterFunction)}_removeStatsHistColormapVAT(t){t.statistics=null,t.histograms=null,t.colormap=null,t.attributeTable=null,t.multidimensionalInfo?.variables.forEach(t=>{t.statistics=void 0,t.histograms=void 0})}_getRasterValues(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]?this.functionArguments.rasters??[]:t.flatMap(t=>this.functionArguments[t])}_getSourceRasterInfos(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:r}=t;if(0===e.length)return s;const o=e.map(t=>t&&"object"==typeof t&&"bind"in t&&t.rasterInfo?t.rasterInfo:"string"==typeof t&&r.includes(t)?s[r.indexOf(t)]:"number"!=typeof t?s[0]:void 0),n=o.find(t=>t)??s[0];return o.forEach((t,e)=>{void 0===t&&(o[e]=n)}),o}_getPrimaryRasterId(t){return t?.rasterId}_getPrimaryRasters(t,e=[],s=[]){for(let r=0;r<t.sourceRasters.length;r++){const o=t.sourceRasters[r];if("number"!=typeof o)if("bind"in o)this._getPrimaryRasters(o,e,s);else{const t=o,r=this._getPrimaryRasterId(t);if(null==r)continue;s.includes(r)||(this.mainPrimaryRasterId===r?(e.unshift(t),s.unshift(r)):(e.push(t),s.push(r)))}}}_isRasterFunctionValue(t){return null!=t&&"object"==typeof t&&"getWebGLProcessorDefinition"in t}_readRasterValue(t,e){const{primaryPixelBlocks:s}=e;if(null==t||"$$"===t){const t=s[0];return null==t?null:t.clone()}if("string"==typeof t){const r=e.primaryRasterIds.indexOf(t);return-1===r?null:s[r]}if("number"==typeof t){const e=s[0];if(null==e)return null;const{width:r,height:o,pixelType:n}=e,i=new Float32Array(r*o);i.fill(t);const p=this.sourceRasterInfos[0].bandCount,u=new Array(p).fill(i);return new a({width:r,height:o,pixelType:n,pixels:u})}return t.process(e)}_patchRasterInfo(){const{rasterInfo:t}=this;if(!t?.keyProperties)return;const{bandCount:e,keyProperties:s,statistics:r,histograms:o}=t,n=s.BandProperties;n&&n.length!==e&&(t.keyProperties={...s,BandProperties:void 0}),r&&r.length!==e&&(t.statistics=r.length>e?r.slice(0,e):null),o&&o.length!==e&&(t.histograms=o.length>e?o.slice(0,e):null),s.BAND_COUNT&&Number(s.BAND_COUNT)!==e&&(t.keyProperties={...s,BAND_COUNT:"string"==typeof s.BAND_COUNT?String(e):e})}};return t.__decorate([s.property({json:{write:!0}})],l.prototype,"functionName",void 0),t.__decorate([s.property({json:{write:!0}})],l.prototype,"functionArguments",void 0),t.__decorate([s.property()],l.prototype,"rasterArgumentNames",void 0),t.__decorate([s.property({json:{write:!0}}),r.cast(t=>t?.toLowerCase())],l.prototype,"outputPixelType",void 0),t.__decorate([s.property({json:{write:!0}})],l.prototype,"mainPrimaryRasterId",void 0),t.__decorate([s.property()],l.prototype,"sourceRasters",void 0),t.__decorate([s.property({type:[p],json:{write:!0}})],l.prototype,"sourceRasterInfos",void 0),t.__decorate([s.property({json:{write:!0}})],l.prototype,"rasterInfo",void 0),t.__decorate([s.property({json:{write:!0}})],l.prototype,"readingBufferSize",void 0),t.__decorate([s.property({json:{write:!0}})],l.prototype,"id",void 0),t.__decorate([s.property()],l.prototype,"isNoopProcess",void 0),t.__decorate([s.property()],l.prototype,"supportsGPU",null),t.__decorate([s.property()],l.prototype,"rawInputBandIds",void 0),t.__decorate([s.property()],l.prototype,"rawSourceRasterInfos",void 0),t.__decorate([s.property()],l.prototype,"isInputBandIdsSwizzled",void 0),t.__decorate([s.property()],l.prototype,"swizzledBandSelection",void 0),t.__decorate([s.property()],l.prototype,"isBranch",void 0),t.__decorate([s.property()],l.prototype,"isRoot",void 0),t.__decorate([s.property({readOnly:!0})],l.prototype,"flatWebGLFunctionChain",null),t.__decorate([s.property()],l.prototype,"_bindingResult",void 0),l=t.__decorate([i.subclass("esri.layers.support.rasterFunctions.BaseRasterFunction")],l),l});