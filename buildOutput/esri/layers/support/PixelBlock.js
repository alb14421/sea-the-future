// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../chunks/tslib.es6","../../core/Error","../../core/JSONSupport","../../core/lang","../../core/Logger","../../core/accessorSupport/decorators/property","../../core/accessorSupport/decorators/cast","../../core/accessorSupport/decorators/subclass","./SimpleBandStatistics","./rasterFormats/pixelRangeUtils"],function(t,e,s,i,l,r,a,o,n,h,p){"use strict";var c;return t.default=c=class extends i.JSONSupport{static createEmptyBand(t,e){return new(c.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,s=new Uint8Array(e).fill(255);for(let i=0;i<t.length;i++){const l=t[i];for(let t=0;t<e;t++)l[t]||(s[t]=0)}return s}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new s("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new h.SimpleBandStatistics)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(t=>function(t,e){let s=1/0,i=-1/0;const l=t.length;let r,a=0;if(null!=e)for(r=0;r<l;r++)e[r]&&(a=t[r],s=a<s?a:s,i=a>i?a:i);else for(r=0;r<l;r++)a=t[r],s=a<s?a:s,i=a>i?a:i;return new h.SimpleBandStatistics(s,i)}(t,this.mask));const t=this.mask;let e=0;if(null!=t)for(let s=0;s<t.length;s++)t[s]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||"f64"===t||"f32"===t||!this.pixels)return;const[e,s]=p.getPixelValueRange(t),i=this.pixels,l=this.width*this.height,r=i.length;let a,o,n;const h=[];for(let p=0;p<r;p++){n=c.createEmptyBand(t,l),a=i[p];for(let t=0;t<l;t++)o=a[t],n[t]=o>s?s:o<e?e:o;h.push(n)}this.pixels=h,this.pixelType=t}extractBands(t){const{pixels:e,statistics:s}=this;if(null==t||0===t.length||!e||0===e.length)return this;const i=e.length,l=t.some(t=>t>=e.length),r=i===t.length&&!t.some((t,e)=>t!==e);if(l||r)return this;const a=this.bandMasks?.length===i?t.map(t=>this.bandMasks[t]):void 0;let{mask:o,validPixelCount:n}=this;const{width:h,height:p}=this;return a?.length&&(o=c.combineBandMasks(a),n=o.filter(t=>!!t).length),new c({pixelType:this.pixelType,width:h,height:p,mask:o,bandMasks:a,validPixelCount:n,maskIsAlpha:this.maskIsAlpha,pixels:t.map(t=>e[t]),statistics:s&&t.map(t=>s[t])})}clone(){const t=new c({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount});let e;null!=this.mask&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(t=>new Uint8Array(t)));const s=c.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const i=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=i?this.pixels[e].slice():new s(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=l.clone(this.statistics[e]);return t}getTransferableObject(){const{pixels:t,bandMasks:e,mask:s}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;const i=this.toJSON();this.pixels=t,this.bandMasks=e,this.mask=s,i.pixels=t?[...t]:t,i.bandMasks=e?[...e]:e,i.mask=s;const l=[];return[...t??[],s,...e??[]].filter(t=>null!=t&&ArrayBuffer.isView(t)).forEach(t=>{t&&!l.includes(t.buffer)&&l.push(t.buffer)}),{pixelBlock:i,transferList:l}}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:s,premultiplyAlpha:i,pixels:l}=this;if(!t||!l?.length)return void r.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let a,o,n,h;a=o=n=l[0],l.length>=3?(o=l[1],n=l[2]):2===l.length&&(o=l[1]);const p=new Uint32Array(t),c=this.width*this.height;if(a.length===c)if(null!=e&&e.length===c)if(s)for(h=0;h<c;h++){const t=e[h];if(t){const e=t/255;p[h]=i?t<<24|n[h]*e<<16|o[h]*e<<8|a[h]*e:t<<24|n[h]<<16|o[h]<<8|a[h]}}else for(h=0;h<c;h++)e[h]&&(p[h]=255<<24|n[h]<<16|o[h]<<8|a[h]);else for(h=0;h<c;h++)p[h]=255<<24|n[h]<<16|o[h]<<8|a[h];else r.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:s,statistics:i}=this;if(!t||!e?.length)return void r.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const l=this.pixelType;let a=1,o=0,n=1;if(i&&i.length>0){for(const t of i)if(null!=t.minValue&&(o=Math.min(o,t.minValue)),null!=t.maxValue&&null!=t.minValue){const e=t.maxValue-t.minValue;n=Math.max(n,e)}a=255/n}else{let t=255;"s8"===l?(o=-128,t=127):"u16"===l?t=65535:"s16"===l?(o=-32768,t=32767):"u32"===l?t=4294967295:"s32"===l?(o=-2147483648,t=2147483647):"f32"===l?(o=-34e38,t=34e38):"f64"===l&&(o=-Number.MAX_VALUE,t=Number.MAX_VALUE),a=255/(t-o)}const h=new Uint32Array(t),p=this.width*this.height;let c,u,d,f,g;if(c=u=d=e[0],c.length!==p)return r.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(u=e[1],e.length>=3&&(d=e[2]),null!=s&&s.length===p)for(f=0;f<p;f++)s[f]&&(h[f]=255<<24|(d[f]-o)*a<<16|(u[f]-o)*a<<8|(c[f]-o)*a);else for(f=0;f<p;f++)h[f]=255<<24|(d[f]-o)*a<<16|(u[f]-o)*a<<8|(c[f]-o)*a;else if(null!=s&&s.length===p)for(f=0;f<p;f++)g=(c[f]-o)*a,s[f]&&(h[f]=255<<24|g<<16|g<<8|g);else for(f=0;f<p;f++)g=(c[f]-o)*a,h[f]=255<<24|g<<16|g<<8|g}_fillFrom32Bit(t){const{pixels:e,mask:s}=this;if(!t||!e?.length)return r.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,l,a,o;i=l=a=e[0],e.length>=3?(l=e[1],a=e[2]):2===e.length&&(l=e[1]);const n=this.width*this.height;if(i.length!==n)return r.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let h=0;if(null!=s&&s.length===n)for(o=0;o<n;o++)t[h++]=i[o],t[h++]=l[o],t[h++]=a[o],t[h++]=1&s[o];else for(o=0;o<n;o++)t[h++]=i[o],t[h++]=l[o],t[h++]=a[o],t[h++]=1}},e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"width",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"height",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"pixelType",void 0),e.__decorate([o.cast("pixelType")],t.default.prototype,"castPixelType",null),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"validPixelCount",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"mask",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"maskIsAlpha",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"pixels",void 0),e.__decorate([a.property()],t.default.prototype,"premultiplyAlpha",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"statistics",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"depthCount",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"noDataValues",void 0),e.__decorate([a.property({json:{write:!0}})],t.default.prototype,"bandMasks",void 0),t.default=c=e.__decorate([n.subclass("esri.layers.support.PixelBlock")],t.default),t.default});