// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../core/Error","../../core/workers/workers","./PixelBlock"],function(e,r,o){"use strict";return class{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await r.open("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=r.pixelBlock.getTransferableObject().pixelBlock,i=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:n,type:r.dataType},t);return i?new o(i):null}async convertPixelBlockToFeatures(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("convertPixelBlockToFeatures",{pixelBlock:r.pixelBlock.toJSON(),extent:r.extent.toJSON(),fieldNames:r.fieldNames,skipFactor:r.skipFactor,pixelIdOffset:r.pixelIdOffset,imageRowSize:r.imageRowSize},o),n=r.extent.spatialReference?.toJSON();return t.forEach(e=>e.geometry.spatialReference=n),t}computeStatisticsHistograms(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const{transferList:t,pixelBlock:n}=r.pixelBlock.getTransferableObject();return o?.transferPixelsToWorker&&(o={...o,transferList:t}),this._workerThread.invoke("computeStatisticsHistograms",{...r,pixelBlock:n},o)}async decode(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("decode",r,{...t,transferList:[r.data]});return n?new o(n):null}async symbolize(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=r.pixelBlock?.getTransferableObject().pixelBlock,i={extent:r.extent?.toJSON(),pixelBlock:n,simpleStretchParams:r.simpleStretchParams,bandIds:r.bandIds},a=await this._workerThread.invoke("symbolize",i,t);return a?new o(a):null}async highlightPixels(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t={pixelBlock:r.pixelBlock?.toJSON(),renderedPixelBlock:r.renderedPixelBlock?.toJSON(),highlightOptions:r.highlightOptions},n=await this._workerThread.invoke("highlightPixels",t,o);r.renderedPixelBlock.pixels=n.pixels,r.renderedPixelBlock.mask=n.mask,r.renderedPixelBlock.maskIsAlpha=n.maskIsAlpha}async updateSymbolizer(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=r?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:r.toJSON(),histograms:t},o))}async updateRasterFunction(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");await Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:r.toJSON()},o))}async process(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("process",{extent:r.extent?.toJSON(),primaryPixelSizes:r.primaryPixelSizes?.map(e=>null!=e?e.toJSON():null),primaryPixelBlocks:r.primaryPixelBlocks.map(e=>e?.getTransferableObject().pixelBlock),primaryRasterIds:r.primaryRasterIds},t);return n?new o(n):null}async stretch(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const n={srcPixelBlock:r.pixelBlock.getTransferableObject().pixelBlock,stretchParams:r.stretchParams},i=await this._workerThread.invoke("stretch",n,t);return i?new o(i):null}async split(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const n={srcPixelBlock:r.pixelBlock.getTransferableObject().pixelBlock,tileSize:r.tileSize,maximumPyramidLevel:r.maximumPyramidLevel,useBilinear:r.useBilinear},i=await this._workerThread.invoke("split",n,t);return i&&i.forEach((e,r)=>{i.set(r,e?o.fromJSON(e):null)}),i}async clipTile(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const n=r.pixelBlock.getTransferableObject().pixelBlock,i={...r,pixelBlock:n},a=await this._workerThread.invoke("clipTile",i,t);return a?o.fromJSON(a):null}async estimateStatisticsHistograms(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.getTransferableObject().pixelBlock};return await this._workerThread.invoke("estimateStatisticsHistograms",t,o)}async mosaicAndTransform(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.srcPixelBlocks?.length)return{pixelBlock:null};const n=r.srcPixelBlocks.map(e=>e?.getTransferableObject()),i={...r,srcPixelBlocks:n.map(e=>e?.pixelBlock)};if(t?.transferPixelsToWorker){const e=n.flatMap(e=>e?.transferList).filter(e=>null!=e);t={...t,transferList:e}}const a=await this._workerThread.invoke("mosaicAndTransform",i,t);return{pixelBlock:a.pixelBlock?new o(a.pixelBlock):null,localNorthDirections:a.localNorthDirections}}async createFlowMesh(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t={buffer:r.flowData.data.buffer,maskBuffer:r.flowData.mask.buffer,width:r.flowData.width,height:r.flowData.height},{meshType:n,simulationSettings:i}=r,a=await this._workerThread.invoke("createFlowMesh",{meshType:n,flowData:t,simulationSettings:i},{...o,transferList:[t.buffer,t.maskBuffer]});return{vertexData:new Float32Array(a.vertexBuffer),indexData:new Uint32Array(a.indexBuffer)}}getProjectionOffsetGrid(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=null!=r.datumTransformation?r.datumTransformation.steps.map(e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse})):null,n=null!=r.rasterTransform?r.rasterTransform.toJSON():null,i={projectedExtent:r.projectedExtent.toJSON(),srcBufferExtent:r.srcBufferExtent.toJSON(),pixelSize:r.pixelSize,hasWrapAround:r.hasWrapAround,spacing:r.spacing,datumTransformationSteps:t,rasterTransform:n,isAdaptive:r.isAdaptive,includeGCSGrid:r.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",i,o)}}});