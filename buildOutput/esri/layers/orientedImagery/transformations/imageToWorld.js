// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/mathUtils","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../chunks/vec32","../../../geometry/Point","../core/ElevationSourceDefinitions","./rectifyMapPoint","./utils","./worldToImage","../../../widgets/OrientedImageryViewer/constants"],function(e,a,r,t,i,o,n,c,s,l,f){"use strict";function m(e,a,r,o,n,c){let l=t.clone(e);const m=Math.sqrt((e[2]-a[2])**2+(Math.sqrt((e[0]-a[0])**2+(e[1]-a[1])**2)/r)**2)*r,d=s.scaleWithFactor(i.sub(t.zeros(),e,a),1/m,1/r);if(function(e,a,r,t){return e<a||r+t/2<f.viewingLimit}(e[2],o,n,c)){const e=Math.abs((a[2]-o)/-d[2])*r;l=s.scaleAndAddWithFactor(a,d,e,r)}else l[2]=o;return l}function d(e,a,r,t,i){let o,n=null,c=0,l=e,f=a;for(;c<=9;){const e=p(r,f,l,i);if(o=e.error,n=e.transformedPoint,s.or(o<=1,9===c))break;l=s.computeNewReferenceCoordinates(l,o,r,a),f=g(l,t,i),c++}return n}function g(e,a,r){return l.worldToImage(e.map(a),r).map(({x:e,y:a})=>[e,a,1])}function p(e,a,r,t){const{cameraLocation:i}=t,n=s.projectiveTransform(e,a,r),{x:c,y:f}=l.worldToImage(new o(n,i.spatialReference),t);var m,d;return{transformedPoint:n,error:(m=e,d=[c,f,1],Math.abs(m[0]-d[0])+Math.abs(m[1]-d[1]))}}e.imageToWorld=async function(e,r,t){const{verticalFieldOfView:i,imageBoundaries:n,scalingFactor:f,farPlaneVertices:g,cameraLocation:p,pixelsToTransform:u,vecToPoint:y}=function(e,r){const t=a.isArrayLike(e)||"items"in e?e:[e],{cameraLocation:i,rotationMatrix:n}=r;if(s.validatePixelsToTransform(t,i),s.validateRotationMatrix(n),9!==n?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix");const c=s.getWebMercatorScalingFactor(i.y,i.spatialReference),f=s.computeFarplaneVertices({...r,scalingFactor:c}),m=l.worldToImage(f.map(e=>new o(e,i.spatialReference)),r),{vfov:d}=s.computeHFOVAndVFOV(r.horizontalFieldOfView,r.verticalFieldOfView,r.cameraRoll);return{cameraLocation:i.toArray(),imageBoundaries:m.map(({x:e,y:a})=>[e,a,1]),verticalFieldOfView:d,farPlaneVertices:f,scalingFactor:c,pixelsToTransform:t.map(e=>[e.x,e.y,1]),vecToPoint:s.vecToPoint(i.spatialReference)}}(e,r),v=new Array;return await async function(e,a,r,t,i,o,n,l,f,g){let p=i.averageElevation;for(const u of e){const e=d(a,r,u,t,i);g&&s.or(s.isElevationSampler(g.elevationSample),s.isUpdateElevationWithElevationSource(g))&&(p=(await c.rectifyMapPoint(t(e),{x:u[0],y:u[1]},{...i,...g,farPlaneVertices:a.map(t)}))[2]),o.push(t(m(e,n,l,p,i.cameraPitch,f)))}}(u,g,n,y,r,v,p,f,i,t),Array.isArray(e)?v:v[0]},e.imageToWorldPanoramic=async function(e,a,t){const{cameraHeading:i,cameraLocation:l,farDistance:f,imageHeight:d,imageWidth:g,verticalFieldOfView:p}=a,u=s.getWebMercatorScalingFactor(l.y,l.spatialReference),y=f*u,v=new Array,[h,w,P]=l.toArray(),x=Array.isArray(e)?e:[e];for(const e of x){let x,M;if(s.hasAngles(e))x=e.heading,M=e.pitch;else{const a=s.convertPixelToHeadingPitch({x:e.x,y:e.y},g,d);x=a.heading,M=a.pitch}x=(x+i)%360;const T=[h+Math.sin(r.deg2rad(x))*Math.sin(r.deg2rad(M))*y,w+Math.cos(r.deg2rad(x))*Math.sin(r.deg2rad(M))*y,P+-Math.cos(r.deg2rad(M))*f];let A=a.averageElevation;t&&(n.isElevationSource(t)||s.isElevationSampler(t.elevationSample))&&(A=(await c.rectifyMapPointPanoramic(new o(T,l.spatialReference),{heading:x,pitch:M},{...a,...t,farPlaneVertices:s.reducerFn(f,f).map(([e,a])=>new o([l.x+e,l.y+a],l.spatialReference))}))[2]),v.push(new o(m(T,l.toArray(),u,A,M,p),l.spatialReference))}return Array.isArray(e)?v:v[0]},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});