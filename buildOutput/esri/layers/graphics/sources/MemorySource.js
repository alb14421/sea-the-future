// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/tslib.es6","../../../Graphic","../../../core/Collection","../../../core/Error","../../../core/has","../../../core/Loadable","../../../core/Logger","../../../core/Promise","../../../core/workers/workers","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/RandomLCG","../../../core/accessorSupport/decorators/shared","../../../core/accessorSupport/decorators/subclass","../../../geometry/Extent","../../../geometry/Polygon","../../../geometry/support/typeUtils","../../../rest/query/operations/editsZScale","../../../rest/query/operations/queryZScale","../../../rest/support/FeatureSet"],function(e,t,r,o,i,s,n,a,l,u,c,d,p,y,h,m,g,_,f,S,T){"use strict";let b=0;e.MemorySource=class extends(n.LoadableMixin(l.EsriPromiseMixin(o))){constructor(e){super(e),this._idToClientGeometry=null,this.type="memory"}load(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this._startWorker(t)),Promise.resolve(this)}destroy(){this._connection?.close(),this._connection=null}get _workerGeometryType(){const e=this.layer?.geometryType;return e?this._geometryTypeRequiresClientGraphicMapping(e)?"polygon":e:null}applyEdits(e){return this.load().then(()=>this._applyEdits(e))}openPorts(){return this.load().then(()=>this._connection.openPorts())}async queryFeatures(e,t={}){await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);S.applyFeatureSetZUnitScaling(e,this.layer.spatialReference,r);const o=T.fromJSON(r);if(!this._requiresClientGraphicMapping()||!this._idToClientGeometry)return o;const i=this.layer.objectIdField;for(const e of o.features){const t=e.attributes[i],r=this._idToClientGeometry.get(t);void 0!==r&&(e.geometry=r)}return o.geometryType=this.layer.geometryType,o}async queryFeaturesJSON(e,t={}){if(this._requiresClientGraphicMapping())throw new i("query-features-json:unsupported","Cannot query in JSON format for client only geometry types (mesh and extent)");await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);return S.applyFeatureSetZUnitScaling(e,this.layer.spatialReference,r),r}queryFeatureCount(e,t={}){return this.load(t).then(()=>this._connection.invoke("queryFeatureCount",e?e.toJSON():null,t))}queryObjectIds(e,t={}){return this.load(t).then(()=>this._connection.invoke("queryObjectIds",e?e.toJSON():null,t))}queryExtent(e,t={}){return this.load(t).then(()=>this._connection.invoke("queryExtent",e?e.toJSON():null,t)).then(e=>({count:e.count,extent:m.fromJSON(e.extent)}))}querySnapping(e,t={}){return this.load(t).then(()=>this._connection.invoke("querySnapping",e,t))}async queryAttributeBins(e,t={}){return await this.load(),this._connection.invoke("queryAttributeBins",e?.toJSON(),t)}async _applyEdits(e){if(!this._connection)throw new i("feature-layer-source:edit-failure","Memory source not loaded");const t=this.layer.objectIdField;let r=null;const o=[],s=[];await Promise.all([this._prepareClientMapping(e.addFeatures,null),this._prepareClientMapping(e.updateFeatures,null)]);const n=e=>"objectId"in e&&null!=e.objectId?e.objectId:"attributes"in e&&null!=e.attributes[t]?e.attributes[t]:null;if(e.addFeatures&&(r=this._prepareAddFeatures(e.addFeatures)),e.deleteFeatures)for(const t of e.deleteFeatures){const e=n(t);null!=e&&o.push(e)}const a=e.updateFeatures&&this._idToClientGeometry?new Map:null;if(e.updateFeatures)for(const t of e.updateFeatures)if(s.push(this._serializeFeature(t)),a&&null!=t.geometry){const e=n(t);null!=e&&a.set(e,t)}f.unapplyEditsZUnitScaling(r?r.features:null,s,this.layer.spatialReference);const{fullExtent:l,featureEditResults:u}=await this._connection.invoke("applyEdits",{adds:r?r.features:[],updates:s,deletes:o});return this.fullExtent=l,r&&r.finish(u.uidToObjectId),this._updateIdToClientGeometries(a,u),this._createEditsResult(u)}async _prepareClientMapping(e,t){if("mesh"!==this._layerOrSourceGeometryType||null==e)return;const r=[];for(const{geometry:o}of e)null==o||"mesh"!==o.type||o.hasExtent||o.loaded||r.push(o.load({signal:t}));r.length&&await Promise.all(r)}_updateIdToClientGeometries(e,t){if(this._idToClientGeometry){if(e)for(const r of t.updateResults){if(!r.success)continue;const t=e.get(r.objectId);null!=t&&this._addIdToClientGeometry(t)}for(const e of t.deleteResults)e.success&&this._idToClientGeometry.delete(e.objectId)}}_createEditsResult(e){return{addFeatureResults:e.addResults?e.addResults.map(this._createFeatureEditResult,this):[],updateFeatureResults:e.updateResults?e.updateResults.map(this._createFeatureEditResult,this):[],deleteFeatureResults:e.deleteResults?e.deleteResults.map(this._createFeatureEditResult,this):[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}}_createFeatureEditResult(e){const t=!0===e.success?null:e.error||{code:void 0,description:""};return{objectId:e.objectId,globalId:e.globalId,error:t?new i("feature-layer-source:edit-failure",t.description,{code:t.code}):null}}_prepareAddFeatures(e){const t=new Map,r=new Array(e.length);let o=null;for(let i=0;i<e.length;i++){const s=e[i],n=this._serializeFeature(s);o||null==s.geometry||(o=s.geometry.type),r[i]=n,t.set(`${n.uid}`,s)}const i=this;return{features:r,inferredGeometryType:o,finish(e){const r=i.sourceJSON.objectIdField;for(const o in e){const s=e[o],n=t.get(o);n&&(n.attributes||(n.attributes={}),-1===s?delete n.attributes[r]:n.attributes[r]=s,i._addIdToClientGeometry(n))}}}}_addIdToClientGeometry(e){if(!this._idToClientGeometry)return;const t=this.sourceJSON.objectIdField,r=e.attributes?.[t];null!=r&&this._idToClientGeometry.set(r,e.geometry??null)}get _layerOrSourceGeometryType(){return this.layer?.geometryType??this.sourceJSON?.geometryType}_requiresClientGraphicMapping(){return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType)}_geometryRequiresClientGraphicMapping(e){return this._geometryTypeRequiresClientGraphicMapping(e.type)}_geometryTypeRequiresClientGraphicMapping(e){return"mesh"===e||"multipatch"===e||"extent"===e}_serializeFeature(e){const{attributes:t}=e,r=this._geometryForSerialization(e),o=(b++).toString();return r?{uid:o,geometry:r.toJSON(),attributes:t}:{uid:o,attributes:t}}_geometryForSerialization(e){const{geometry:t}=e;return null==t?null:this._geometryRequiresClientGraphicMapping(t)?t.extent?g.fromExtent(t.extent):null:t}async _startWorker(e){this._connection=await u.open("MemorySourceWorker",{strategy:s("feature-layers-workers")?"dedicated":"local",signal:e,registryTarget:this});const{fields:t,spatialReference:r,objectIdField:o,hasM:i,hasZ:n,timeInfo:l,dateFieldsTimeZone:c}=this.layer,d="defaults"===this.layer.originOf("spatialReference");await this._prepareClientMapping(this.items,e);const p=this._prepareAddFeatures(this.items);this.addHandles(this.on("before-changes",e=>{a.getLogger(this).error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"),e.preventDefault()}));const y={features:p.features,fields:t?.map(e=>e.toJSON()),geometryType:_.typeKebabDictionary.toJSON(this._workerGeometryType),hasM:"mesh"!==this._layerOrSourceGeometryType&&i,hasZ:"mesh"===this._layerOrSourceGeometryType||n,objectIdField:o,spatialReference:d?null:r&&r.toJSON(),timeInfo:l?.toJSON()??null,dateFieldsTimeZone:c},h=await this._connection.invoke("load",y,{signal:e});for(const e of h.warnings)a.getLogger(this.layer).warn("#load()",`${e.message} (title: '${this.layer.title||"no title"}', id: '${this.layer.id??"no id"}')`,{warning:e});h.featureErrors.length&&a.getLogger(this.layer).warn("#load()",`Encountered ${h.featureErrors.length} validation errors while loading features. (title: '${this.layer.title||"no title"}', id: '${this.layer.id??"no id"}')`,{errors:h.featureErrors});const m=h.layerDefinition;this._geometryTypeRequiresClientGraphicMapping(p.inferredGeometryType)&&(m.geometryType=_.typeKebabDictionary.toJSON(p.inferredGeometryType)),this.sourceJSON=m,this._requiresClientGraphicMapping()&&(this._idToClientGeometry=new Map),p.finish(h.assignedObjectIds)}},t.__decorate([y.shared({Type:r,ensureType:d.ensureType(r)})],e.MemorySource.prototype,"itemType",void 0),t.__decorate([c.property()],e.MemorySource.prototype,"type",void 0),t.__decorate([c.property({constructOnly:!0})],e.MemorySource.prototype,"layer",void 0),t.__decorate([c.property({readOnly:!0})],e.MemorySource.prototype,"_workerGeometryType",null),t.__decorate([c.property()],e.MemorySource.prototype,"sourceJSON",void 0),e.MemorySource=t.__decorate([h.subclass("esri.layers.graphics.sources.MemorySource")],e.MemorySource),Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});