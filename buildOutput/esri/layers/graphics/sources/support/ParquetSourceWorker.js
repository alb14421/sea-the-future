// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../chunks/tslib.es6","../../../../core/compilerUtils","../../../../core/Error","../../../../core/maybe","../../../../core/QueueProcessor","../../../../geometry/SpatialReference","../../../../geometry/support/aaBoundingBox","../../data/QueryEngine","../../data/QueryEngineResult","../../../support/FieldsIndex","../../../support/fieldUtils","../../../../libs/parquet/parquet","../../../../views/2d/layers/features/FeatureStoreQueryAdapter","../../../../views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk","../../../../views/2d/layers/features/sources/strategies/chunks/SourceChunkStore","../../../../views/2d/layers/features/support/FeatureMetadata","../../../../views/2d/layers/features/support/FeatureSetReaderParquet"],function(e,t,r,s,n,a,u,o,i,l,c,d,f,m,h,y,p){"use strict";const _=new f.FeatureStoreQueryAdapter,g=8e3;function x(e){return Object.keys(e).some(e=>function(e){switch(e){case"resultOffset":case"resultRecordCount":case"aggregateIds":case"distance":case"gdbVersion":case"geometry":case"having":case"timeExtent":case"where":case"objectIds":case"historicMoment":return!0;default:return!1}}(e))}function w(e,t,r){const s=new h.FeatureSourceChunkStore(e);return s.insert(t),new o.QueryEngine({...r,featureStore:s})}function R(e){switch(e.length){case 4:return u.fromRect(u.create(),e);case 6:return e;default:throw new r("parquet:protocol-violation","Invalid Geoparquet file. BoundingBox size must be 4 or 6.",{bbox:e})}}return class{constructor(){this._files=[],this._queue=new n.QueueProcessor({concurrency:1,process:(e,t)=>this._executeQuery(e,t)})}async load(t){this.setCustomParameters(t.customParameters),this._files=await Promise.all(t.urls.map(e=>d.createParquetFile(e,{geometryInfo:t.geometryInfo,outSpatialReference:null,getCustomParameters:()=>this._customParameters}))),this._metadata=y.FeatureMetadata.createFeature(t.metadata),this._queryEngineParams={fieldsIndex:this._metadata.fieldsIndex,geometryType:t.geometryInfo?.geometryType??"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:"rowId"},hasM:!1,hasZ:!1,spatialReference:a.fromJSON(t.geometryInfo?.spatialReference),aggregateAdapter:null,timeInfo:null,definitionExpression:null};const r=this._files[0];if(!r)return{extent:null};const{fields:s,timeZoneByFieldName:n}=t.metadata.fieldsIndex,o=s.map(e=>({...e,column:r.columnForFieldName(e.name)})),i=l.fromJSON({fields:o,timeZoneByFieldName:n});if(this._fieldsIndex=i,t.metadata.spatialReference&&(this._fullExtent=function(e,t){const r=u.set(u.create(),u.negativeInfinity);for(const t of e){const e=d.readGeoMetadata(t);if(!e)return null;const s=e.columns[e.primary_column];if(!s.bbox)return null;const n=R(s.bbox);u.expandWithAABB(r,n)}return{xmin:r[0],ymin:r[1],xmax:r[3],ymax:r[4],spatialReference:t}}(this._files,t.metadata.spatialReference)),null==this._fullExtent&&"location"===t.geometryInfo?.encoding.type){const{latitudeFieldName:r,longitudeFieldName:s}=t.geometryInfo.encoding,n=this._fieldsIndex.get(r)?.column,a=this._fieldsIndex.get(s)?.column,o=u.set(u.create(),u.negativeInfinity);for(const t of this._files)for(const r of t.rowGroups()){const t={stack:[],error:void 0,hasError:!1};try{const s=e.__addDisposableResource(t,r.columnDescriptorForAttribute(n),!1),i=e.__addDisposableResource(t,r.columnDescriptorForAttribute(a),!1),l=[i.minValue(),s.minValue(),i.maxValue(),s.maxValue()];u.expandWithRect(o,l),r.free()}catch(e){t.error=e,t.hasError=!0}finally{e.__disposeResources(t)}}this._fullExtent={xmin:o[0],ymin:o[1],xmax:o[3],ymax:o[4],spatialReference:t.metadata.spatialReference}}return{extent:this._fullExtent}}destroy(){for(const e of this._files)e.free();this._queue.destroy()}setCustomParameters(e){this._customParameters=e}async queryFeatures(e,t){return this._validateQuery(e),e.resultRecordCount=e.resultRecordCount?Math.min(e.resultRecordCount,8e3):8e3,e.resultOffset=e.resultOffset??0,(await this._enqueueQuery(e,t)).createQueryResponse()}async queryFeatureCount(e,t){return this._validateQuery(e),x(e)?(e.resultRecordCount=e.resultRecordCount??this._getFeatureCount(),e.resultOffset=e.resultOffset??0,delete e.outFields,delete e.returnGeometry,(await this._enqueueQuery(e,t)).createQueryResponseForCount()):this._getFeatureCount()}async queryObjectIds(e,t){return this._validateQuery(e),x(e)?(e.resultRecordCount=e.resultRecordCount?Math.min(e.resultRecordCount,8e3):8e3,e.resultOffset=e.resultOffset??0,delete e.returnGeometry,delete e.outFields,(await this._enqueueQuery(e,t)).items.map(e=>e.getObjectId())):Array.from({length:this._getFeatureCount()},(e,t)=>t)}async queryExtent(e,r){if(this._validateQuery(e),this._fullExtent&&!x(e))return{count:this._getFeatureCount(),extent:this._fullExtent};const s=t.toConst(this._metadata.spatialReference);e.resultOffset=e.resultOffset??0,e.resultRecordCount=e.resultRecordCount??this._getFeatureCount(),e.returnGeometry=!0,delete e.outFields;const n=u.set(u.create(),u.negativeInfinity),a=u.create(),i=await this._enqueueQuery(e,r);let l=0;for(const e of i.items)e.getBounds(a)&&(u.expandWithAABB(n,a),l+=1);return{count:l,extent:o.getQueryResultExtent(n,s,e.outSR?t.toConst(e.outSR):s,s,!1)}}_getFeatureCount(){return this._files.reduce((e,t)=>e+t.numRows(),0)}_validateQuery(e){if(e.outStatistics)throw new r("parquet:unsupported","Statistics queries are not supported",{query:e});if(e.orderByFields?.length)throw new r("parquet:unsupported","Queries using orderBy are not supported",{query:e})}async*_fetchChunks(e,t){const r=this._files[0].numRows(),s=Math.ceil(r/g);for(let r=0;r<s;r++){const s=r*g,n=await this._files[0].readChunk(s,g,e.fields,e.returnGeometry,t);for(const e of n){const t=new p.FeatureSetReaderParquet(this._metadata,this._fieldsIndex,e,0),r=new m.FeatureSnapshotSourceChunk(t,null,0,!1),s=w(this._metadata,r,this._queryEngineParams);yield s}}}_enqueueQuery(e,t){return this._queue.push(e,t)}async _executeQuery(e,t){let r=e.resultRecordCount,n=e.resultOffset;s.assertIsSome(r),s.assertIsSome(n),delete e.resultRecordCount,delete e.resultOffset;const a=await this._getReadParams(e),u=[];for await(const s of this._fetchChunks(a,t)){const a=await s.executeQueryForOpaqueFeatures(e,t);if(a.length>n){const t=a.slice(n,Math.min(r,a.length));for(const e of t)u.push(e);if(n=0,r-=t.length,0===r)return new i.QueryEngineResult(u,e,{fieldsIndex:this._fieldsIndex,geometryType:this._metadata.geometryType,spatialReference:this._metadata.spatialReference,objectIdField:"rowId",hasM:!1,hasZ:!1,featureAdapter:_})}else n-=a.length}return new i.QueryEngineResult(u,e,{fieldsIndex:this._fieldsIndex,geometryType:this._metadata.geometryType,spatialReference:this._metadata.spatialReference,objectIdField:"rowId",hasM:!1,hasZ:!1,featureAdapter:_})}async _getReadParams(e){const t=new Set;if(e.where&&await c.collectSQLFieldNames(t,this._fieldsIndex,e.where),e.outStatistics)for(const r of e.outStatistics)null!=r.onStatisticField&&t.add(r.onStatisticField);if(e.outFields)for(const r of e.outFields)t.add(r);return{fields:this._getAttributeIds(Array.from(t)),returnGeometry:!!e.returnGeometry||!!e.geometry}}_getAttributeIds(e){if(null==e)return new Uint32Array;if(e.includes("*"))return new Uint32Array(this._fieldsIndex.fields.map(e=>e.column).filter(e=>null!=e));const t=[];for(const s of e){const e=this._fieldsIndex.get(s);if(null==e)throw new r("unknown-field",`Field ${s} does not exist`);null==e.column||t.push(e.column)}return new Uint32Array(t)}}});