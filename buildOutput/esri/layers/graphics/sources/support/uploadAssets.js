// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../request","../../../../core/has","../../../../core/Logger","../../../../core/promiseUtils","../../../../core/time","../../../../core/urlUtils","../../../../core/uuid","../../../../geometry/SpatialReference","../../../../geometry/support/meshUtils/External","./uploadAssetErrors","./uploadProgressWeights","./uploads","../../../support/infoFor3D","../../../support/meshSpatialReferenceScaleUtils","../../../../rest/support/meshFeatureAttributes","../../../../support/progressUtils"],function(e,r,s,t,o,a,n,i,c,u,l,p,d,f,g,m,y){"use strict";function h(e,{infoFor3D:r},s={}){if(!e)return null;const t=u.externalSourceToMultiPart(e);if(!t)return null;const{supportedFormats:o,editFormats:a}=r,n=new Array,i=f.getPrjFormatId(r),c=f.getWorldFileFormatId(r);let l=!1;for(const e of t){const r=w(e,o);if(!r)return null;const{assetType:t}=r;if(s.checkForConversionRequired&&(t===i||t===c))return null;a.includes(t)&&(l=!0),n.push(r)}return l?n:null}function w(e,r){const s=u.assetFormatId(e,r);return s?{asset:e,assetType:s}:null}async function P(e,r,s){const t=e.map(e=>async function(e,r){const{asset:s,assetType:t}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:t};const a=await s.toBlob(r);return o.throwIfAborted(r),{blob:a,assetName:s.assetName,assetType:t}}(e,s));return b(t,r,s)}async function b(e,s,a){const i=y.makeProgressManager(p.uploadProgressWeights.uploadAssetBlobs,a?.onProgress,"uploadAssetBlobs"),c=await function(e,r,s){const a=y.makeProgressManager(e.length,s?.onProgress,"prepareAssetItems");return Promise.all(e.map(async(e,i)=>{const c=async function(e,r,s){const{blob:a,assetType:i,assetName:c}=e;let u=null;try{const e=await d.uploadItem({data:a,name:c},r.url,s);o.throwIfAborted(s),u={assetType:i,assetUploadId:e.itemID}}catch(e){o.throwIfAbortError(e),t.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${r.url} does not support the REST Uploads API.`)}if(!u){const e=await n.parseData(a);if(o.throwIfAborted(s),!e.isBase64)throw new l.NotBase64Error;u={assetType:i,assetData:e.data}}if(!u)throw new l.UnableToPrepareOptionsError;return{item:u,assetName:c}}(await e,r,{...s,onProgress:a.makeOnProgress(i)});return o.throwIfAborted(s),c}))}(e,s,{...a,onProgress:i.makeOnProgress("prepareAssetItems")});o.throwIfAborted(a);const g=c.map(({item:e})=>e),{uploadResults:m}=await async function(e,s,t){const a=y.simulateProgress(t?.onProgress);try{const a=await r(n.join(s.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(o.throwIfAborted(t),a.data.uploadResults.length!==e.length)throw new l.BadResponseError(e.length,a.data.uploadResults.length);return a.data}finally{a.remove()}}(g,s,{...a,onProgress:i.makeOnProgress("uploadAssetItems")});return o.throwIfAborted(a),e.map((e,r)=>function(e,r,s){const{success:t}=r;if(!t){const{error:s}=r;throw new l.UploadFailedError(e.assetName,s)}const{assetHash:o}=r,{assetName:a,item:{assetType:n}}=e,{infoFor3D:{supportedFormats:i}}=s,c=f.getFormatIdMimeType(n,i);if(!c)throw new l.UnsupportedFormatUploadedError(n);return new u.ServiceAsset(a,c,[new u.ServiceAssetPart(`${s.parsedUrl.path}/assets/${o}`,o)])}(c[r],m[r],s))}function A(e,s){return r(e,s)}async function T(e,s){const t=(await r(e,s)).data.statusUrl;for(;;){const e=(await r(t,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return r(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(e.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await o.after(S)}}function F({infoFor3D:e}){const r=f.getGlbFormatId(e);if(!r)throw new l.NoGlbSupportError;return r}const S=a.Milliseconds(1e3);e.uploadAssets=async function(e,r,t){const a=e.length;if(!a)return t?.onProgress?.(1),[];const d=y.makeProgressManager(a,t?.onProgress,"uploadAssets");return Promise.all(e.map((e,a)=>async function(e,{layer:r,ongoingUploads:t},a){const d=t.get(e);if(d)return d;if(!function(e){return!!e.infoFor3D&&!!e.url}(r))throw new l.UnsupportedError;if(function(e,r){const{parsedUrl:s}=r;return null!=s&&e.metadata.externalSources.some(e=>u.externalIsOnService(e,s))}(e,r))return a?.onProgress?.(1),e;const w=async function(e,r,t){const{metadata:a}=e,{displaySource:d}=a,w=h(d?.source,r,{checkForConversionRequired:s("enable-feature:georeferenced-uploads")}),S=null!=w?async function(e,r,s){return{source:{type:"service",assets:await P(e,r,s)},original:!0,unitConversionDisabled:!0}}(w,r,t):a.externalSources.length>0?async function(e,r,t){const o=F(r),{externalSources:a}=e.metadata,i=function(e,r){for(const s of e){const e=h(s.source,r);if(e)return e}return null}(a,r);if(!i)throw new l.NoSupportedSourceError;const d=y.makeProgressManager(p.uploadProgressWeights.uploadConvertibleSource,t?.onProgress,"uploadConvertibleSource"),w={type:"service",assets:await P(i,r,{onProgress:d.makeOnProgress("uploadEditSource")})};e.addExternalSources([{source:w,original:!0}]);const b=i.reduce((e,{asset:r})=>r instanceof File?e+r.size:e,0),S=d.simulate("serviceAssetsToGlb",y.estimatedConversionTime(b));try{const{source:a,transform:i,origin:p}=await async function({assets:e},r,t){const o=e.map(({assetName:e,parts:r})=>({assetName:e,assetHash:r[0].partHash}));let a;try{const e=n.join(r.parsedUrl.path,"convert3D"),s=r.capabilities?.operations.supportsAsyncConvert3D;a=(await(s?T:A)(e,{query:{f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:t,async:s},responseType:"json",timeout:0})).data}catch(e){throw new l.Convert3DFailedError}return function(e,r){const t={source:{type:"service",assets:r.assets.map(r=>{const s=f.getMimeTypeFormatId(r.contentType,e.infoFor3D.supportedFormats);if(!s)throw new l.UnsupportedFormatUploadedError(s);return new u.ServiceAsset(r.assetName,r.contentType,[new u.ServiceAssetPart(r.assetURL,r.assetHash)])})},origin:void 0,transform:void 0};if(s("enable-feature:georeferenced-uploads")&&r.transform){if(t.transform=m.extractMeshFeatureTransform(r.transform),r.spatialReference){const e=c.fromJSON(r.spatialReference);t.origin=m.extractMeshFeatureOrigin(r.transform,e)}}else t.transform=g.getMeshTransformForMetersToSpatialReference(e.spatialReference);return t}(r,a)}(w,r,o);return e.transform=i,p&&(e.metadata.georeferenced=!0,t?.useAssetOrigin&&(e.vertexSpace.origin=[p.x,p.y,p.z??0],e.spatialReference=p.spatialReference)),{source:a,unitConversionDisabled:!0}}finally{S.remove()}}(e,r,t):async function(e,r,s){const t=y.makeProgressManager(p.uploadProgressWeights.uploadLocalMesh,s?.onProgress,"uploadLocalMesh"),a=async function(e,r,s){const t=F(r),a=await e.load(s),n=await a.toBinaryGLTF({origin:a.origin,signal:s?.signal,ignoreLocalTransform:!0,unitConversionDisabled:!0});return o.throwIfAborted(s),{blob:new Blob([n],{type:"model/gltf-binary"}),assetName:`${i.generateBracedUUID()}.glb`,assetType:t}}(e,r,{...s,onProgress:t.makeOnProgress("meshToAssetBlob")});return{source:{type:"service",assets:await b([a],r,{...s,onProgress:t.makeOnProgress("uploadAssetBlobs")})},extent:e.extent.clone(),original:!0}}(e,r,t),v=await S;return o.throwIfAborted(t),e.addExternalSources([v]),e}(e,r,a);t.set(e,w);try{await w}finally{t.delete(e)}return e}(e,r,{...t,onProgress:d.makeOnProgress(a)})))},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});