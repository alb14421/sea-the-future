// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../chunks/tslib.es6","../../../../request","../../../../core/Error","../../../../core/Logger","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../core/has","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","../../../../geometry/SpatialReference","../../../../geometry/support/jsonUtils","./WebSocketConnection","../../../../rest/query/operations/query","../../../../rest/support/Query"],function(e,t,r,i,n,s,o,a,c,u,l,d,h,f,g,y){"use strict";const _=e=>Object.freeze(Object.defineProperty({__proto__:null,default:e},Symbol.toStringTag,{value:"Module"})),p={maxQueryDepth:5,maxRecordCountFactor:3};return t.default=class extends f.WebSocketConnection{constructor(e){super({...p,...e}),this._buddyServicesQuery=null,this._relatedFeatures=null}async _open(){const e=await this._fetchServiceDefinition(this._config.source);e.timeInfo.trackIdField||s.getLogger(this).warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");const t=this._fetchWebSocketUrl(e.streamUrls,this._config.spatialReference);this._buddyServicesQuery||(this._buddyServicesQuery=this._queryBuddyServices()),await this._buddyServicesQuery,await this._tryCreateWebSocket(t);const{filter:r,outFields:i}=this._config;this.destroyed||this._setFilter(r,i)}_onMessage(e){if("attributes"in e){let t;try{t=this._enrich(e),null!=this._featureZScaler&&this._featureZScaler(t.geometry)}catch(e){return void s.getLogger(this).error(new n("geoevent-connection","Failed to parse message",e))}this.onFeature(t)}else this.onMessage(e)}async _fetchServiceDefinition(e){const t={f:"json",...this._config.customParameters},r=i(e.path,{query:t,responseType:"json"}),n=(await r).data;return this._serviceDefinition=n,n}_fetchWebSocketUrl(e,t){const r=e[0],{urls:i,token:n}=r,s=this._inferWebSocketBaseUrl(i);return a.addQueryParameters(`${s}/subscribe`,{outSR:""+t.wkid,token:n})}_inferWebSocketBaseUrl(e){if(1===e.length)return e[0];for(const t of e)if(t.includes("wss"))return t;return s.getLogger(this).error(new n("geoevent-connection","Unable to infer WebSocket url",e)),null}async _setFilter(e,t){const r=this._websocket;if(null==r||null==e&&null==t)return;const i=JSON.stringify({filter:this._serializeFilter(e,t)});let a=!1;const c=o.createResolver();return r.onmessage=e=>{const t=JSON.parse(e.data);t.filter&&(t.error&&(s.getLogger(this).error(new n("geoevent-connection","Failed to set service filter",t.error)),this._set("errorString",`Could not set service filter - ${t.error}`),c.reject(t.error)),this._setWebSocketJSONParseHandler(r),a=!0,c.resolve())},r.send(i),setTimeout(()=>{a||(this.destroyed||this._websocket!==r||s.getLogger(this).error(new n("geoevent-connection","Server timed out when setting filter")),c.reject())},1e4),c.promise}_serializeFilter(e,t){const r={};if(null==e&&null==t)return r;if(e?.geometry)try{const t=h.fromJSON(e.geometry);if("extent"!==t.type)throw new n("geoevent-connection",`Expected extent but found type ${t.type}`);r.geometry=JSON.stringify(t.shiftCentralMeridian())}catch(e){s.getLogger(this).error(new n("geoevent-connection","Encountered an error when setting connection geometryDefinition",e))}return e?.where&&"1 = 1"!==e.where&&"1=1"!==e.where&&(r.where=e.where),null!=t&&(r.outFields=t.join(",")),r}_enrich(e){if(!this._relatedFeatures)return e;const t=this._serviceDefinition.relatedFeatures.joinField,r=e.attributes[t],i=this._relatedFeatures.get(r);if(!i)return s.getLogger(this).warn("geoevent-connection","Feature join failed. Is the join field configured correctly?",e),e;const{attributes:o,geometry:a}=i;for(const t in o)e.attributes[t]=o[t];return a&&(e.geometry=a),e.geometry||e.centroid||s.getLogger(this).error(new n("geoevent-connection","Found malformed feature - no geometry found",e)),e}async _queryBuddyServices(){try{const{relatedFeatures:e,keepLatestArchive:t}=this._serviceDefinition,r=this._queryRelatedFeatures(e),i=this._queryArchive(t);await r;const n=await i;if(!n)return;for(const e of n.features)this.onFeature(this._enrich(e))}catch(e){s.getLogger(this).error(new n("geoevent-connection","Encountered an error when querying buddy services",{error:e}))}}async _queryRelatedFeatures(e){if(!e)return;const t=await this._queryBuddy(e.featuresUrl);this._addRelatedFeatures(t)}async _queryArchive(e){if(e)return this._queryBuddy(e.featuresUrl)}async _queryBuddy(t){const r=new((await new Promise((t,r)=>e(["../../../FeatureLayer"],e=>t(_(e)),r))).default)({url:t}),{capabilities:i}=await r.load(),n=i.query.supportsMaxRecordCountFactor,s=i.query.supportsPagination,o=i.query.supportsCentroid,a=this._config.maxRecordCountFactor,c=r.capabilities.query.maxRecordCount,u=n?c*a:c,l=new y;if(l.outFields=this._config.outFields??["*"],l.where=this._config.filter?.where??"1=1",l.returnGeometry=!0,l.returnExceededLimitFeatures=!0,l.outSpatialReference=d.fromJSON(this._config.spatialReference),o&&(l.returnCentroid=!0),n&&(l.maxRecordCountFactor=a),s)return l.num=u,r.destroy(),this._queryPages(t,l);const h=await g.executeQuery(t,l,this._config.sourceSpatialReference);return r.destroy(),h.data}async _queryPages(e,t,r=[],i=0){t.start=null!=t.num?i*t.num:null;const{data:n}=await g.executeQuery(e,t,this._config.sourceSpatialReference);return n.exceededTransferLimit&&i<(this._config.maxQueryDepth??0)?(n.features.forEach(e=>r.push(e)),this._queryPages(e,t,r,i+1)):(r.forEach(e=>n.features.push(e)),n)}_addRelatedFeatures(e){const t=new Map,r=e.features,i=this._serviceDefinition.relatedFeatures.joinField;for(const e of r){const r=e.attributes[i];t.set(r,e)}this._relatedFeatures=t}},t.default=r.__decorate([l.subclass("esri.layers.graphics.sources.connections.GeoEventConnection")],t.default),t.default});