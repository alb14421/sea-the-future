// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/compilerUtils","../../../core/Error","../../../core/has","../../../core/lang","../../../core/maybe","../../../core/promiseUtils","../../../core/unitUtils","../../../core/support/jsonUtils","../../../geometry/projectionUtils","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/boundsUtils","../../../geometry/support/jsonUtils","../../../geometry/support/spatialReferenceUtils","../featureConversionUtils","./attributeSupport","./geometryUtils","./projectionSupport","./QueryEngineCache","./QueryEngineCapabilities","./QueryEngineResult","./queryUtils","./queryValidationUtils","./spatialQuerySupport","./timeSupport","../../support/FieldsIndex","../../../views/support/Scheduler"],function(e,t,i,s,r,a,n,u,l,o,c,h,y,d,m,g,f,p,x,w,F,R,S,Q,E,_,I,b,O){"use strict";function A(e){if(_.canQueryWithRBush(e)){if(m.isExtent(e))return[y.fromValues(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if(m.isPolygon(e))return e.rings.map(e=>y.fromValues(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[d.getBoundsXY(y.create(),e)]}function v(e,t,i,s,r){const a={xmin:e[0],ymin:e[1],xmax:e[3],ymax:e[4],spatialReference:x.cleanFromGeometryEngine(s)};r&&isFinite(e[2])&&isFinite(e[5])&&(a.zmin=e[2],a.zmax=e[5],a.hasZ=!0);const n=w.project(a,t,i);if(n.spatialReference=x.cleanFromGeometryEngine(i),n.xmax-n.xmin===0){const e=l.getMetersPerUnitForSR(n.spatialReference);n.xmin-=e,n.xmax+=e}if(n.ymax-n.ymin===0){const e=l.getMetersPerUnitForSR(n.spatialReference);n.ymin-=e,n.ymax+=e}if(r&&null!=n.zmin&&null!=n.zmax&&n.zmax-n.zmin===0){const e=l.getMetersPerUnitForSR(n.spatialReference);n.zmin-=e,n.zmax+=e}return n}e.Feature=class{constructor(e,t=null,i,s,r){this.attributes=e,this.geometry=i,this.centroid=s,this.filterFlags=r,this.groupId=-1,this.displayId=t}},e.QueryEngine=class{constructor(e){this._changeHandle=null,this.capabilities={query:R.queryCapabilities},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._cache=e.cache??new F.QueryEngineCache,this.timeInfo=e.timeInfo,this.featureIdInfo=e.featureIdInfo,"object-id"===e.featureIdInfo.type&&(this.objectIdField=e.featureIdInfo.fieldName),this._changeHandle=this.featureStore.events.on("changed",()=>this._clearCache()),this.fieldsIndex=o.isSerializable(e.fieldsIndex)?e.fieldsIndex:b.fromJSON(e.fieldsIndex),!e.availableFields||1===e.availableFields.length&&"*"===e.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map(e=>e.name)):this.availableFields=new Set(e.availableFields.map(e=>this.fieldsIndex.get(e)?.name).filter(e=>null!=e)),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._changeHandle=n.removeMaybe(this._changeHandle),this._frameTask=n.removeMaybe(this._frameTask),this._clearCache(),n.destroyMaybe(this._cache)}get featureAdapter(){return this.featureStore.featureAdapter}_clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){const i=u.signalFromSignalOrOptions(t);try{const t=await this._executeQuery(e,{},i);return await t.createQueryResponse()}catch(t){if(t!==Q.queryEngineEmptyResult)throw t;return new S.QueryEngineResult([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){const i=u.signalFromSignalOrOptions(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(e){if(e!==Q.queryEngineEmptyResult)throw e;return 0}}async executeQueryForExtent(e,t){const i=u.signalFromSignalOrOptions(t),s=e.outSR;try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),r=t.size;return r?{count:r,extent:await this._getBounds(t.items,t.spatialReference,s||this.spatialReference)}:{count:0,extent:null}}catch(e){if(e===Q.queryEngineEmptyResult)return{count:0,extent:null};throw e}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then(e=>Array.from(e))}async executeQueryForIdSet(e,t){const i=u.signalFromSignalOrOptions(t);try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=t.items,r=new Set;return await this.reschedule(()=>{for(const e of s)r.add(t.featureAdapter.getObjectId(e))},i),r}catch(e){if(e===Q.queryEngineEmptyResult)return new Set;throw e}}async executeQueryForLatestObservations(e,t){const i=u.signalFromSignalOrOptions(t);if(!this.timeInfo?.trackIdField)throw new s("unsupported-query","Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const t=await this._executeQuery(e,{},i);return await this.reschedule(()=>this._filterLatest(t),i),await t.createQueryResponse()}catch(t){if(t!==Q.queryEngineEmptyResult)throw t;return new S.QueryEngineResult([],e,this).createQueryResponse()}}async executeQueryForOpaqueFeatures(e,t){const i=u.signalFromSignalOrOptions(t);return(await this._executeQuery(e,{},i)).items}async executeAttributeBinsQuery(e,t){const i=u.signalFromSignalOrOptions(t);let s;e=a.clone(e);try{e=await this.schedule(()=>Q.normalizeAttributeBinsQuery(e,this.definitionExpression,this.spatialReference),i),e=await this.reschedule(()=>E.validateAttributeBinsQuery(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),i);const t=await this.reschedule(()=>this._executeSceneFilterQuery(e,i),i);s=await this.reschedule(()=>this._executeGeometryQuery(e,t,i),i),await this.reschedule(()=>this._executeAggregateIdsQuery(s),i),await this.reschedule(()=>this.executeObjectIdsQuery(s),i),await this.reschedule(()=>this.executeTimeQuery(s),i),await this.reschedule(()=>this.executeAttributesQuery(s),i)}catch(t){if(t!==Q.queryEngineEmptyResult)throw t;s=new S.QueryEngineResult([],e,this)}return s.createQueryBinsResponse(e)}async executeQueryForSummaryStatistics(e={},t,i){const s=u.signalFromSignalOrOptions(i),{field:r,normalizationField:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:a,valueExpression:n},s)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const s=u.signalFromSignalOrOptions(i),{field:r,field2:a,field3:n,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:r,field2:a,field3:n,valueExpression:l},s)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const s=u.signalFromSignalOrOptions(i),{field:r,normalizationField:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:a,valueExpression:n},s)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const s=u.signalFromSignalOrOptions(i),{field:r,normalizationField:a,valueExpression:n}=t;return(await this._executeQueryForStatistics(e,{field:r,normalizationField:a,valueExpression:n},s)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const t=u.signalFromSignalOrOptions(e);this._timeExtentPromise||=I.getTimeExtent(this.timeInfo,this.featureStore);const[i,s]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return u.throwIfAborted(t),{fullExtent:i,timeExtent:s}}async _getBounds(e,t,i){const s=h.set(h.create(),h.negativeInfinity);return await this.featureStore.forEachBounds(e,e=>h.expandWithAABB(s,e)),v(s,t,i,this.spatialReference,this.hasZ)}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference)),this._fullExtentPromise}async schedule(e,t){return this._frameTask?.schedule(e,t)??e(O.noBudget)}async reschedule(e,t){return this._frameTask?.reschedule(e,t)??e(O.noBudget)}async _getAllFeaturesQueryEngineResult(e){return new S.QueryEngineResult(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>await this.featureStore.forEach(t=>e.push(t)))().then(()=>i.toConst(e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=a.clone(e),e=await this.schedule(()=>Q.normalizeQuery(e,this.definitionExpression,this.spatialReference),i),e=await this.reschedule(()=>E.validateQuery(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),i),e={...e,...t};const s=await this.reschedule(()=>this._executeSceneFilterQuery(e,i),i),r=await this.reschedule(()=>this._executeGeometryQuery(e,s,i),i);return await this.reschedule(()=>this._executeAggregateIdsQuery(r),i),await this.reschedule(()=>this.executeObjectIdsQuery(r),i),await this.reschedule(()=>this.executeTimeQuery(r),i),await this.reschedule(()=>this.executeAttributesQuery(r),i),r}async _executeSceneFilterQuery(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,u=null==a||g.equals(a,n.spatialReference)?n:w.project(n,a);if(!u)return null;const l=s||r,o=g.isValid(i)&&!g.equals(this.spatialReference,i)&&l?async e=>this._project(e,i):e=>e,c=this.featureAdapter,h=await this.reschedule(()=>this.searchFeatures(A(u)),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!h.length)return null;const i=new Set;for(const e of h)i.add(c.getObjectId(e));const s=await this.reschedule(()=>this._getAllFeatures(),t);return o(await this.reschedule(async()=>{const r=await _.getSpatialQueryOperator("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=await this.runSpatialFilter(s,e=>!i.has(c.getObjectId(e))||r(c.getGeometry(e)),t);return new S.QueryEngineResult(a,e,this)},t))}if(!h.length)return new S.QueryEngineResult([],e,this);if(this._canExecuteSinglePass(u,e))return o(new S.QueryEngineResult(h,e,this));const y=await _.getSpatialQueryOperator("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),d=await this.runSpatialFilter(h,e=>y(c.getGeometry(e)),t);return o(new S.QueryEngineResult(d,e,this))}async _executeGeometryQuery(e,i,s){if(null!=i&&0===i.items.length)return i;const{geometry:r,outSR:a,returnGeometry:n,returnCentroid:u}=e,l=i?null:this._getCacheKey(e),o=l?this._cache.get(l):null;if(o)return new S.QueryEngineResult(o,e,this);const c=g.isValid(a)&&!g.equals(this.spatialReference,a),h=n||u,y=async e=>(c&&h&&await this._project(e,a),l&&this._cache.put(l,e.items),e),d=this.featureStore.featureSpatialReference,m=!r||null==d||g.equals(d,r.spatialReference)?r:w.project(r,d);if(!m)return y(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const f=this.featureAdapter;let p=await this.reschedule(()=>this.searchFeatures(A(r)),s);const x=e.spatialRel??"esriSpatialRelIntersects";if("esriSpatialRelDisjoint"===x){if(!p.length)return y(null!=i?i:await this._getAllFeaturesQueryEngineResult(e));const t=new Set;for(const e of p)t.add(f.getObjectId(e));const r=null!=i?i.items:await this.reschedule(()=>this._getAllFeatures(),s);return y(await this.reschedule(async()=>{const i=await _.getSpatialQueryOperator(x,m,this.geometryType,this.hasZ,this.hasM),a=await this.runSpatialFilter(r,e=>!t.has(f.getObjectId(e))||i(f.getGeometry(e)),s);return new S.QueryEngineResult(a,e,this)},s))}if(null!=i){const e=new t.PositionHint;p=p.filter(s=>t.indexOf(i.items,s,i.items.length,e)>=0)}if(!p.length){const t=new S.QueryEngineResult([],e,this);return l&&this._cache.put(l,t.items),t}if(this._canExecuteSinglePass(m,e))return y(new S.QueryEngineResult(p,e,this));const F=await _.getSpatialQueryOperator(x,m,this.geometryType,this.hasZ,this.hasM),R=await this.runSpatialFilter(p,e=>F(f.getGeometry(e)),s);return y(new S.QueryEngineResult(R,e,this))}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds?.length||null==this.aggregateAdapter)return;const t=new Set;for(const i of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach(e=>t.add(e));const i=this.featureAdapter.getObjectId;e.items=e.items.filter(e=>t.has(i(e)))}executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter(e=>t.has(i(e)))}executeTimeQuery(e){if(0===e.items.length)return;const t=I.getTimeOperator(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))}executeAttributesQuery(e){if(0===e.items.length)return;const t=p.getWhereClause(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(e=>t.testFeature(e,this.featureAdapter))}}async runSpatialFilter(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter(e=>t(e));let s=0;const r=new Array,a=async n=>{for(;s<e.length;){const u=e[s++];t(u)&&(r.push(u),n.madeProgress()),n.done&&await this.reschedule(e=>a(e),i)}};return this.reschedule(e=>a(e),i).then(()=>r)}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,n=this.featureAdapter.getAttribute;for(const i of e.items){const e=n(i,t),s=n(i,r),u=a.get(e);(!u||s>n(u,r))&&a.set(e,i)}e.items=Array.from(a.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:s,returnCentroid:r,outSR:a,resultType:n,cacheHint:u}=e;if("tile"!==n&&!u)return null;const l=s||r;return g.isValid(a)&&!g.equals(this.spatialReference,a)&&l?JSON.stringify([t,i,a]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return _.canQueryWithRBush(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(e,t){if(!t||g.equals(this.spatialReference,t))return e;const s=this.featureAdapter;let r;try{const e=await this._getFullExtent();r=c.getTransformation(this.spatialReference,t,e)}catch{}const a=await w.projectMany(e.items.map(e=>x.getGeometry(this.geometryType,this.hasZ,this.hasM,s.getGeometry(e))),this.spatialReference,t,r);return e.items=i.toConst(a.map((t,i)=>s.cloneWithGeometry(e.items[i],f.convertFromGeometry(t,this.hasZ,this.hasM)))),e}async searchFeatures(e){const t=new Set;await Promise.all(e.map(e=>this.featureStore.forEachInBounds(e,e=>t.add(e))));const i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=a.clone(e);try{e=await this.schedule(()=>Q.normalizeQuery(e,this.definitionExpression,this.spatialReference),i),e=await this.reschedule(()=>E.validateStatisticsQuery(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),i);const s=await this.reschedule(()=>this._executeSceneFilterQuery(e,i),i),r=await this.reschedule(()=>this._executeGeometryQuery(e,s,i),i);return await this.reschedule(()=>this._executeAggregateIdsQuery(r),i),await this.reschedule(()=>this.executeObjectIdsQuery(r),i),await this.reschedule(()=>this.executeTimeQuery(r),i),await this.reschedule(()=>this.executeAttributesQuery(r),i),r}catch(t){if(t!==Q.queryEngineEmptyResult)throw t;return new S.QueryEngineResult([],e,this)}}get test(){}},e.getQueryBBoxes=A,e.getQueryResultExtent=v,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});