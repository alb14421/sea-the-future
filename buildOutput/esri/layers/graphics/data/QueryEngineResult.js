// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../core/lang","../../../geometry/support/centroid","../../../geometry/support/extentUtils","../../../geometry/support/quantizationUtils","../../../geometry/support/spatialReferenceUtils","./AttributesBuilder","./geometryUtils","./projectionSupport","./queryUtils","./SnappingCandidate","../../support/fieldUtils","../../../rest/support/AutoIntervalBinParameters","../../../rest/support/DateBinParameters","../../../rest/support/DateBinUtils","../../../rest/support/FixedBoundariesBinParameters","../../../rest/support/FixedIntervalBinParameters","../../../statistics/utils","../../../time/constants","../../../chunks/datetime"],function(e,t,i,s,a,n,r,o,l,u,c,m,d,h,f,g,p,y,x,T,F){"use strict";const I="bin";function b(e,t,i,s){const a=s.x-i.x,n=s.y-i.y,r=t.x-i.x,o=t.y-i.y,l=a*a+n*n;if(0===l)return!1;const u=r*a+o*n,c=Math.min(1,Math.max(0,u/l));return e.x=i.x+a*c,e.y=i.y+n*c,!0}function S(e,t){return e?t?4:3:t?3:2}class _{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const V=[1];t.QueryEngineResult=class{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new o(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!a)return 1;const n=new Map,r=new Map,l=new Set;for(const a of s){const{statisticType:s}=a,o="exceedslimit"!==s?a.onStatisticField:void 0;if(!r.has(o)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,this.items,n);i.push(t)}r.set(o,this._calculateUniqueValues(i,this.items,e.returnDistinctValues))}const u=r.get(o);for(const t in u){const{data:s,items:a}=u[t],n=s.join(",");i&&!e.validateItems(a,i)||l.add(n)}}return l.size}async createQueryResponse(){let e;if(e=this.query.outStatistics?this.query.outStatistics.some(e=>"exceedslimit"===e.statisticType)?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;r.isValid(this.query.outSR)&&!r.equals(t.spatialReference,this.query.outSR)?e.queryGeometry=l.cleanFromGeometryEngine({spatialReference:this.query.outSR,...u.project(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=l.cleanFromGeometryEngine({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const s=this.featureAdapter,a=S(this.hasZ,this.hasM),{point:n,mode:r}=e,o="number"==typeof e.distance?e.distance:e.distance.x,l="number"==typeof e.distance?e.distance:e.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,d="esriGeometryPolyline"===this.geometryType||"esriGeometryPoint"===this.geometryType,h=this._getPointCreator(r,t,this.spatialReference,i),f=new _(null,0),g=new _(null,0),p={x:0,y:0,z:0};for(const t of this.items){const i=s.getGeometry(t);if(null==i)continue;const{coords:r}=i,y=i.isPoint?V:i.lengths;if(f.coords=r,g.coords=r,e.returnEdge){let e=0;for(let i=0;i<y.length;i++){const r=y[i],d=e;for(let i=0;i<r;i++,e+=a){if(!c&&i===r-1)continue;const y=f;y.coordsIndex=e;const x=g;x.coordsIndex=i===r-1?d:e+a;const T=p;if(!b(p,n,y,x))continue;const F=(n.x-T.x)/o,I=(n.y-T.y)/l,S=F*F+I*I;S<=1&&u.candidates.push(m.makeEdgeCandidate(s.getObjectId(t),h(T),Math.sqrt(S),h(y),h(x)))}}}if("all"===e.vertexMode){let e=0;for(let i=0;i<y.length;i++){const r=y[i],d=e,p=g;p.coordsIndex=d;for(let i=0;i<r;i++,e+=a){const a=f;if(a.coordsIndex=e,c&&i===r-1&&a.x===p.x&&a.y===p.y)continue;const d=(n.x-a.x)/o,g=(n.y-a.y)/l,y=d*d+g*g;y<=1&&u.candidates.push(m.makeVertexCandidate(s.getObjectId(t),h(a),Math.sqrt(y)))}}}else if(d&&"ends"===e.vertexMode){let e=0;const i=[];for(let t=0;t<y.length;t++){i.push(e);const s=y[t];e+=s*a,!c&&s>1&&i.push(e-a)}for(const e of i){const i=f;i.coordsIndex=e;const a=(n.x-i.x)/o,r=(n.y-i.y)/l,c=a*a+r*r;c<=1&&u.candidates.push(m.makeVertexCandidate(s.getObjectId(t),h(i),Math.sqrt(c)))}}}return u.candidates.sort((e,t)=>e.distance-t.distance),u}_getPointCreator(e,t,i,s){const a=null==s||r.equals(i,s)?e=>e:e=>u.project(e,i,s),{hasZ:n}=this;return"3d"===e?n&&t?({x:e,y:t,z:i})=>a({x:e,y:t,z:i}):({x:e,y:t})=>a({x:e,y:t,z:0}):({x:e,y:t})=>a({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,minValue:r,maxValue:o,scale:l,timeZone:u,outStatisticTypes:c}=e,m=this.fieldsIndex.get(t),h=d.isDateField(m)||d.isDateOnlyField(m)||d.isTimestampOffsetField(m),f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,scale:l,timeZone:u},this.items),g=x.isNullCountSupported({normalizationType:a,normalizationField:s,minValue:r,maxValue:o}),p={value:.5,fieldType:m?.type},y=d.isStringField(m)?x.calculateStringStatistics({values:f,supportsNullCount:g,percentileParams:p,outStatisticTypes:c}):x.calculateStatistics({values:f,minValue:r,maxValue:o,useSampleStdDev:!a,supportsNullCount:g,percentileParams:p,outStatisticTypes:c});return x.processSummaryStatisticsResult(y,c,h)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:n,timeZone:r}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:n,timeZone:r},this.items,!1),l=x.calculateUniqueValuesCount(o);return x.createUVResult(l,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:m,timeZone:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,scale:m,timeZone:d},this.items),f=x.calculateClassBreaks(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return x.resolveCBResult(f,r)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:m,timeZone:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,scale:m,timeZone:d},this.items);return x.calculateHistogram(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.slice().reverse()){const t=s.split(" "),a=t[0],n=this.fieldsIndex.get(a),r=!!t[1]&&"desc"===t[1].toLowerCase(),o=x.getAttributeComparator(n?.type,r);e.sort((e,t)=>{const s=i(e,a,n),r=i(t,a,n);return o(s,r)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:u,outSR:c,quantizationParameters:m,resultRecordCount:d,resultOffset:h,returnZ:f,returnM:g}=e,p=null!=d&&t.length>(h||0)+d,y=u&&(u.includes("*")?[...this.fieldsIndex.fields]:u.map(e=>this.fieldsIndex.get(e)));return{exceededTransferLimit:p,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&g,hasZ:a&&f,objectIdFieldName:r,spatialReference:l.cleanFromGeometryEngine(c||o),transform:m&&n.toQuantizationTransform(m)||null}}_createFeatures(e,t){const i=new o(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:u,returnGeometry:c,returnCentroid:m,maxAllowableOffset:d,resultOffset:h,resultRecordCount:f,returnZ:g=!1,returnM:p=!1}=e,y=a&&g,x=s&&p;let T=[],F=0;const I=[...t];if(this._sortFeatures(I,r,(e,t,s)=>i.getFieldValue(e,t,s)),this.geometryType&&(c||m)){const e=n.toQuantizationTransform(u)??void 0,t="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(c&&!m)for(const s of I){const a=this.featureAdapter.getGeometry(s),n={attributes:i.getAttributes(s),geometry:l.getGeometry(this.geometryType,this.hasZ,this.hasM,a,d,e,y,x),metadata:this.featureAdapter.getMetadata?.(s)};t&&a&&!n.geometry&&(n.centroid=l.transformCentroid(this,this.featureAdapter.getCentroid(s,this),e)),T[F++]=n}else if(!c&&m)for(const t of I)T[F++]={attributes:i.getAttributes(t),centroid:l.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of I)T[F++]={attributes:i.getAttributes(t),centroid:l.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e),geometry:l.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),d,e,y,x),metadata:this.featureAdapter.getMetadata?.(t)}}else for(const e of I){const t=i.getAttributes(e);t&&(T[F++]={attributes:t})}const b=h||0;if(null!=f){const e=b+f;T=T.slice(b,Math.min(T.length,e))}return T}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const e of this.query.outStatistics??[])if("exceedslimit"===e.statisticType){t=null!=e.maxPointCount?e.maxPointCount:Number.POSITIVE_INFINITY,i=null!=e.maxRecordCount?e.maxRecordCount:Number.POSITIVE_INFINITY,s=null!=e.maxVertexCount?e.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)e=this.items.length>t;else if(this.items.length>i)e=!0;else{const t=S(this.hasZ,this.hasM),i=this.featureAdapter;e=this.items.reduce((e,t)=>{const s=i.getGeometry(t);return e+(null!=s&&s.coords.length||0)},0)/t>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){const s=[],a=new Map,n=new Map,r=new Map,l=new Map,u=new o(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:m,having:h,orderByFields:f,resultRecordCount:g}=e,p=m?.length,y=!!p,x=y?m[0]:null,T=y&&!this.fieldsIndex.get(x);for(const e of c??[]){const{outStatisticFieldName:o,statisticType:c}=e,f=e,g="exceedslimit"!==c?e.onStatisticField:void 0,F="percentile_disc"===c||"percentile_cont"===c,I="EnvelopeAggregate"===c||"CentroidAggregate"===c||"ConvexHullAggregate"===c,b=y&&1===p&&(g===x||T)&&"count"===c;if(y){if(!r.has(g)){const e=[];for(const i of m){const s=this._getAttributeValues(u,i,t,a);e.push(s)}r.set(g,this._calculateUniqueValues(e,t,!I&&u.returnDistinctValues))}const e=r.get(g);if(!e)continue;const i=Object.keys(e);for(const s of i){const{count:i,data:n,items:r,itemPositions:c}=e[s],d=n.join(",");if(!h||u.validateItems(r,h)){const e=l.get(d)||{attributes:{}};if(I){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:t,outStatisticFieldName:i}=await this._getAggregateGeometry(f,r);e.aggregateGeometries[i]=t}else{let s=null;if(b)s=i;else{const e=this._getAttributeValues(u,g,t,a),i=c.map(t=>e[t]);s=F&&"statisticParameters"in f?this._getPercentileValue(f,i):this._getStatisticValue(f,i,null,u.returnDistinctValues)}e.attributes[o]=s}let s=0;m.forEach((t,i)=>e.attributes[this.fieldsIndex.get(t)?t:"EXPR_"+ ++s]=n[i]),l.set(d,e)}}}else if(I){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(f,t);i.aggregateGeometries[s]=e}else{const e=this._getAttributeValues(u,g,t,a);i.attributes[o]=F&&"statisticParameters"in f?this._getPercentileValue(f,e):this._getStatisticValue(f,e,n,u.returnDistinctValues)}const S="min"!==c&&"max"!==c||!d.isStringField(this.fieldsIndex.get(g))&&!this._isAnyDateField(g)?null:this.fieldsIndex.get(g)?.type;s.push({name:o,alias:o,type:S||"esriFieldTypeDouble"})}const F=y?Array.from(l.values()):[i];return this._sortFeatures(F,f,(e,t)=>e.attributes[t]),g&&(F.length=Math.min(g,F.length)),{fields:s,features:F}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return d.isDateField(t)||d.isDateOnlyField(t)||d.isTimestampOffsetField(t)||d.isTimeOnlyField(t)}async _getAggregateGeometry(t,i){const{convexHull:n,union:r}=await new Promise((t,i)=>e(["../../../geometry/geometryEngineJSON"],t,i)),{statisticType:o,outStatisticFieldName:u}=t,{featureAdapter:c,spatialReference:m,geometryType:d,hasZ:h,hasM:f}=this,g=i.map(e=>l.getGeometry(d,h,f,c.getGeometry(e))),p=n(m,g,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=p?a.getPolygonExtent(p):a.getGeometryExtent(r(m,g));y.aggregateGeometries={...e,spatialReference:m},y.outStatisticFieldName=u||"extent"}else if("CentroidAggregate"===o){const e=p?s.polygonCentroid(p):s.extentCentroid(a.getGeometryExtent(r(m,g)));y.aggregateGeometries={x:e[0],y:e[1],spatialReference:m},y.outStatisticFieldName=u||"centroid"}else"ConvexHullAggregate"===o&&(y.aggregateGeometries=p,y.outStatisticFieldName=u||"convexHull");return y}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:n}=e;let r=null;return r=i?.has(a)?i.get(a):d.isStringField(this.fieldsIndex.get(a))||this._isAnyDateField(a)?x.calculateStringStatistics({values:t,returnDistinct:s}):x.calculateStatistics({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,r),r["var"===n?"variance":n]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:n,orderBy:r}=s,o=this.fieldsIndex.get(i),l={value:n,orderBy:r,fieldType:o?.type,isDiscrete:"percentile_disc"===a};return x.calculatePercentile(t,l)}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const a=this.fieldsIndex.get(t),n=i.map(i=>e.getFieldValue(i,t,a));return s.set(t,n),n}_calculateUniqueValues(e,t,i){const s={},a=t.length;for(let n=0;n<a;n++){const a=t[n],r=[];for(const t of e)r.push(t[n]);const o=r.join(",");null==s[o]?s[o]={count:1,data:r,items:[a],itemPositions:[n]}:(i||s[o].count++,s[o].items.push(a),s[o].itemPositions.push(n))}return s}async _getDataValues(e,t,s=!0){const a=new o(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:n,scale:r,timeZone:l}=e;return n?a.getExpressionValues(t,n,{viewingMode:"map",scale:r,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},l):a.getDataValues(t,i.clone(e),s)}_calculateHistogramBins(e,t,i){if(null==t.min&&null==t.max)return[];const s=t.intervals,a=t.min??0,n=t.max??0,r=s.map(([e,t])=>({minValue:e,maxValue:t,count:0,items:[]}));for(let t=0;t<e.length;t++){const o=e[t],l=i[t];if(null!=o&&o>=a&&o<=n){const e=x.binIndex(s,o);e>-1&&(r[e].count++,r[e].items.push(l))}}return r}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:a}=t,n=[],r=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:I,alias:I,type:"esriFieldTypeInteger"}],l=new o(e,this.featureAdapter,this.fieldsIndex),u=new Map,c=[...this.items];this._sortFeatures(c,[i],(e,t,i)=>l.getFieldValue(e,t,i));const m=this._getAttributeValues(l,i,c,u),d=this._calculateUniqueValues([m],c,l.returnDistinctValues);for(const t in d){const{items:a}=d[t],o=await this._createBinsResponse(e,a);if(n.push(...o.features.map(e=>({...e,attributes:{...e.attributes,[s??i]:t}}))),o.fields)for(const e of o.fields)r.some(t=>t.name===e.name)||r.push(e)}return{fields:r,features:n}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(h.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(f.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(p.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(y.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){const{field:s,normalizationField:a,numBins:n,normalizationType:r,normalizationTotal:o,start:l,end:u}=e,m=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),d=x.getBinParams(m,{field:s,normalizationField:a,normalizationType:r,normalizationTotal:o,numBins:n,minValue:c.getDateInNumber(l,!1),maxValue:c.getDateInNumber(u,!1)}),h=this._calculateHistogramBins(m,d,i);return this._createFeaturesFromHistogramBins(h,t)}async _createDateBinsResponse(e,t,i){const{field:s,interval:a,start:n,end:r,snapToData:o,returnFullIntervalBin:l}=e,u=a.unit,m=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},i),h=d.isTimeOnlyField(this.fieldsIndex.get(s)),f=g.unitsDict.toJSON(u),p=m.filter(Boolean).sort((e,t)=>e-t),y=null!=n?c.getDateInNumber(n,h):p[0],x=null!=r?c.getDateInNumber(r,h):p[p.length-1],I={zone:t.outTimeReference?.ianaTimeZone??T.utc},b=F.DateTime.fromMillis(y,I),S=F.DateTime.fromMillis(x,I),_=[];if("last"===o){let e=S;for(;e>b;){const t=e.minus({[f]:a.value});if(t<b){_.unshift([l?t.toMillis():b.toMillis(),e.toMillis()]);break}_.unshift([t.toMillis(),e.toMillis()]),e=t}}else{let e="first"===o?b:b.startOf(f);for(;e<=S;){const t=e.plus({[f]:a.value});if(t>S){_.push([e.toMillis(),l?t.toMillis():S.toMillis()]);break}_.push([e.toMillis(),t.toMillis()]),e=t}}const V=this._calculateHistogramBins(m,{intervals:_,min:y,max:x},i);return this._createFeaturesFromHistogramBins(V,t)}async _createFixedBoundariesBinsResponse(e,t,i){const{field:s}=e,a=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),n=d.isTimeOnlyField(this.fieldsIndex.get(s)),r=e.boundaries.map(e=>c.getDateInNumber(e,n)).sort((e,t)=>e-t),o=[];for(let e=0;e<r.length-1;e++)o.push([r[e],r[e+1]]);const l={intervals:o,min:r.at(0),max:r.at(-1)},u=this._calculateHistogramBins(a,l,i);return this._createFeaturesFromHistogramBins(u,t)}async _createFixedIntervalBinsResponse(e,t,i){const{field:s,interval:a,start:n,end:r}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),l=d.isTimeOnlyField(this.fieldsIndex.get(s)),u=x.getBinParams(o,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:c.getDateInNumber(n,l),maxValue:c.getDateInNumber(r,l)},!0),m=this._calculateHistogramBins(o,u,i);return this._createFeaturesFromHistogramBins(m,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",n=i||"upperBoundary",r=[],o=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:n,alias:n,type:"esriFieldTypeDouble"}],l=t.bin?.stackBy?.value,u=t.bin?.stackBy?.outAlias;l&&o.push({name:I,alias:I,type:"esriFieldTypeInteger"},{name:u??l,alias:u??l,type:"esriFieldTypeString"});let c=0;const m="dateBin"===t.bin.type,d=t.outTimeReference?.ianaTimeZone;for(const i of e){const{minValue:e,maxValue:s,items:h}=i,f={attributes:{}};let g;if(f.attributes[a]=m&&d&&null!=e?F.DateTime.fromMillis(e,{zone:d}).toISO():e,f.attributes[n]=m&&d&&null!=s?F.DateTime.fromMillis(s,{zone:d}).toISO():s,l?(g=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[l],orderByFields:[l]},h),f.attributes[I]=++c,"flat"===t.bin.jsonStyle?r.push(...g.features.map(({attributes:{EXPR_1:e,...t},...i})=>({...i,attributes:u??e?{...t,[u??e]:e,...f.attributes}:{...t,...f.attributes}}))):(f.stackedAttributes=g.features.map(({attributes:{EXPR_1:e,...t}})=>u??e?{...t,[u??e]:e}:t),r.push(f))):(t.bin?.splitBy&&(f.attributes[I]=++c),g=await this._createStatisticsQueryResponse(t,h,f),r.push(f)),g.fields)for(const e of g.fields)o.some(t=>t.name===e.name)||o.push(e)}return"desc"===t.binOrder&&r.reverse(),{fields:o,features:r}}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});