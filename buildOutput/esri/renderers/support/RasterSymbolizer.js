// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../chunks/tslib.es6","../../core/has","../../core/JSONSupport","../../core/Logger","../../core/accessorSupport/decorators/property","../../core/RandomLCG","../../core/accessorSupport/decorators/subclass","../../layers/support/RasterInfo","../../layers/support/rasterFunctions/pixelUtils","../../layers/support/rasterFunctions/stretchUtils","../../layers/support/rasterFunctions/surfaceUtils","./colorRampUtils","./rasterRendererChecks"],function(e,t,r,s,a,o,n,l,i,u,c,p,d,h){"use strict";function m(e){return u.isValidPixelBlock(e)&&0!==e.validPixelCount}return e.default=class extends s.JSONSupport{constructor(e){super(e),this.lookup={rendererJSON:{}},this.canRenderInWebGL=!1}bind(){const{rendererJSON:e}=this;if(!e)return{success:!1};let t;switch(this.lookup={rendererJSON:{}},e.type){case"uniqueValue":t=this._updateUVRenderer(e);break;case"rasterColormap":t=this._updateColormapRenderer(e);break;case"rasterStretch":t=this._updateStretchRenderer(e);break;case"classBreaks":t=this._updateClassBreaksRenderer(e);break;case"rasterShadedRelief":t=this._updateShadedReliefRenderer(e);break;case"vectorField":t=this._updateVectorFieldRenderer();break;case"flowRenderer":t=this._updateFlowRenderer()}return t}symbolize(e){let t=e?.pixelBlock;if(!m(t))return t;if(e.simpleStretchParams&&"rasterStretch"===this.rendererJSON.type)return this.simpleStretch(t,e.simpleStretchParams);try{let r;switch(t.pixels.length>3&&(t=t.extractBands(e.bandIds??[0,1,2])),this.rendererJSON.type){case"uniqueValue":case"rasterColormap":r=this._symbolizeColormap(t);break;case"classBreaks":r=this._symbolizeClassBreaks(t);break;case"rasterStretch":r=this._symbolizeStretch(t,e.bandIds);break;case"rasterShadedRelief":{const s=e.extent,a=s.spatialReference.isGeographic,o={x:(s.xmax-s.xmin)/t.width,y:(s.ymax-s.ymin)/t.height};r=this._symbolizeShadedRelief(t,{isGCS:a,resolution:o});break}}return r}catch(e){return a.getLogger(this).error("symbolize",e.message),t}}simpleStretch(e,t){if(!m(e))return e;try{return e.pixels.length>3&&(e=e.extractBands([0,1,2])),c.stretch(e,{...t,isRenderer:!0})}catch(t){return a.getLogger(this).error("symbolize",t.message),e}}generateWebGLParameters(e){const{rendererJSON:t}=this;switch(t.type){case"uniqueValue":case"rasterColormap":case"classBreaks":return this._generateColormapWebGLParams("classBreaks"===t.type);case"rasterStretch":return this._generateStretchWebGLParams(e.pixelBlock,t,e.bandIds);case"rasterShadedRelief":return this._generateShadedReliefWebGLParams(t,e.isGCS,e.resolution??void 0);case"vectorField":return this._generateVectorFieldWebGLParams(t);default:return null}}_isLUTChanged(e){const t=this.lookup.rendererJSON;if(!t)return!0;const{rendererJSON:r}=this;if("colorRamp"in r&&r.colorRamp){const s=r.colorRamp;if(e)return JSON.stringify(s)!==JSON.stringify(t.colorRamp)}return JSON.stringify(r)!==JSON.stringify(t)}_symbolizeColormap(e){return this._isLUTChanged()&&!this.bind().success?e:u.colorize(e,this.lookup.colormapLut)}_symbolizeClassBreaks(e){const{canUseIndexedLUT:t}=this._analyzeClassBreaks(this.rendererJSON);return this._isLUTChanged()&&!this.bind().success?e:t?u.colorize(e,this.lookup.colormapLut):u.remapColor(e,this.lookup.remapLut??[])}_symbolizeStretch(e,t){if(!e)return null;const{rasterInfo:r,lookup:s}=this,{pixelType:a,bandCount:o}=r,n=this.rendererJSON,l=["u8","u16","s8","s16"].includes(a);let i;const{dra:p}=n,{gamma:d}=s;if("histogramEqualization"===n.stretchType){const a=p?null:s.histogramLut,o=c.getStretchCutoff(n,{rasterInfo:r,pixelBlock:e,bandIds:t,returnHistogramLut:!a}),l="u8"===r.pixelType&&!p&&c.isStandardU8Histogram(r.histograms?.[0])?e:c.stretch(e,{...o,gamma:d,isRenderer:!0});i=u.lookupPixels(l,{lut:p?o.histogramLut:t?.length?t.map(e=>a[e]):a,offset:0})}else if(l){let l;if(p){const s=c.getStretchCutoff(n,{rasterInfo:r,pixelBlock:e,bandIds:t});l=c.createStretchLUT({pixelType:a,...s,gamma:d,rounding:"floor"})}else{if(this._isLUTChanged()&&!this.bind().success)return e;l=s.stretchLut}if(!l)return e;o>1&&null!=t&&t.length===e?.pixels.length&&l.lut.length===o&&(l={lut:t.map(e=>l.lut[e]),offset:l.offset}),i=u.lookupPixels(e,l)}else{const s=c.getStretchCutoff(n,{rasterInfo:r,pixelBlock:e,bandIds:t});i=c.stretch(e,{...s,gamma:d,isRenderer:!0})}if(n.colorRamp){if(this._isLUTChanged(!0)&&!this.bind().success)return e;i=u.colorize(i,s.colormapLut)}return i}_symbolizeShadedRelief(e,t){const r=this.rendererJSON,s={...r,...t},a=p.hillshade(e,s);if(!r.colorRamp)return a;if(this._isLUTChanged(!0)&&!this.bind().success)return a;const{hsvMap:o}=this.lookup;if(!o)return a;const n=this.rasterInfo.statistics?.[0]??{min:0,max:8e3};return p.tintHillshade(a,e,o,n),a}_isVectorFieldData(){const{bandCount:e,dataType:t}=this.rasterInfo;return 2===e&&("vector-magdir"===t||"vector-uv"===t)}_updateVectorFieldRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; VectorFieldRenderer only supports "vector-magdir" and "vector-uv".`}}_updateFlowRenderer(){return this._isVectorFieldData()?{success:!0}:{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; FlowRenderer only supports "vector-magdir" and "vector-uv".`}}_updateUVRenderer(e){const{bandCount:t,attributeTable:r,pixelType:s}=this.rasterInfo,a=e.field1;if(!a)return{success:!1,error:"Unsupported renderer; missing UniqueValueRenderer.field."};const o=e.defaultSymbol,n=1===t&&["u8","s8"].includes(s);if(!h.isUVRendererSupported(this.rasterInfo,a)&&!n)return{success:!1,error:"Unsupported data; UniqueValueRenderer is only supported on single band data with a valid raster attribute table."};const l=[];if(null!=r){const t=r.fields.find(e=>"value"===e.name.toLowerCase());if(!t)return{success:!1,error:"Unsupported data; the data's raster attribute table does not have a value field."};r.features.forEach(r=>{const s=e.uniqueValueInfos?.find(e=>String(e.value)===String(r.attributes[a])),n=s?.symbol?.color;n?l.push([r.attributes[t.name]].concat(n)):o&&l.push([r.attributes[t.name]].concat(o.color))})}else{if("value"!==a.toLowerCase())return{success:!1,error:'Unsupported renderer; UniqueValueRenderer.field must be "Value" when raster attribute table is not available.'};e.uniqueValueInfos?.forEach(e=>{const t=e?.symbol?.color;t?l.push([parseInt(""+e.value,10)].concat(t)):o&&l.push([parseInt(""+e.value,10)].concat(o?.color))})}if(0===l.length)return{success:!1,error:"Invalid UniqueValueRenderer. Cannot find matching records in the raster attribute table."};const i=u.createColormapLUT({colormap:l});return this.lookup={rendererJSON:e,colormapLut:i},this.canRenderInWebGL=h.isColormapSupportedByWebGL(i?.indexedColormap),{success:!0}}_updateColormapRenderer(e){if(!h.isColormapRendererSupported(this.rasterInfo))return{success:!1,error:"Unsupported data; the data source does not have a colormap."};const t=e.colormapInfos.map(e=>[e.value].concat(e.color)).sort((e,t)=>e[0]-t[0]);if(!t||0===t.length)return{success:!1,error:"Unsupported renderer; ColormapRenderer must have meaningful colormapInfos."};const r=u.createColormapLUT({colormap:t});return this.lookup={rendererJSON:e,colormapLut:r},this.canRenderInWebGL=h.isColormapSupportedByWebGL(r?.indexedColormap),{success:!0}}_updateShadedReliefRenderer(e){if(!h.isShadedReliefRendererSupported(this.rasterInfo))return{success:!1,error:`Unsupported data type "${this.rasterInfo.dataType}"; ShadedReliefRenderer only supports "elevation", or single band float/s16 data.`};if(e.colorRamp){const t=d.convertColorRampToColormap(e.colorRamp,{interpolateAlpha:!0}),r=u.createColormapLUT({colormap:t}),s=d.createHsvMap(r.indexedColormap);this.lookup={rendererJSON:e,colormapLut:r,hsvMap:s}}else this.lookup={rendererJSON:e};return this.canRenderInWebGL=!0,{success:!0}}_analyzeClassBreaks(e){const{attributeTable:t,pixelType:r}=this.rasterInfo,s=t?.fields.find(e=>"value"===e.name.toLowerCase()),a=t?.fields.find(t=>t.name.toLowerCase()===e.field.toLowerCase()),o=null!=s&&null!==a;return{canUseIndexedLUT:["u8","u16","s8","s16"].includes(r)||o,tableValueField:s,tableBreakField:a}}_updateClassBreaksRenderer(e){const{attributeTable:t}=this.rasterInfo,{canUseIndexedLUT:r,tableValueField:s,tableBreakField:a}=this._analyzeClassBreaks(e),o=e.classBreakInfos;if(!o?.length)return{success:!1,error:"Unsupported renderer; missing or invalid ClassBreaksRenderer.classBreakInfos."};const n=o.sort((e,t)=>e.classMaxValue-t.classMaxValue),l=n[n.length-1];let i=e.minValue;if(!r){const t=[];for(let e=0;e<n.length;e++)t.push({value:n[e].classMinValue??i,mappedColor:n[e].symbol.color}),i=n[e].classMaxValue;return t.push({value:l.classMaxValue,mappedColor:l.symbol.color}),this.lookup={rendererJSON:e,remapLut:t},this.canRenderInWebGL=!1,{success:!0}}const c=[];if(null!=t&&null!=s&&null!==a&&s!==a){const r=s.name,o=a.name,l=n[n.length-1],{classMaxValue:u}=l;i=e.minValue;for(const e of t.features){const t=e.attributes[r],s=e.attributes[o],a=s===u?l:s<i?null:n.find(({classMaxValue:e})=>e>s);a&&c.push([t].concat(a.symbol.color))}}else{i=Math.floor(e.minValue);for(let e=0;e<n.length;e++){const t=n[e];for(let e=i;e<t.classMaxValue;e++)c.push([e].concat(t.symbol.color));i=Math.ceil(t.classMaxValue)}l.classMaxValue===i&&c.push([l.classMaxValue].concat(l.symbol.color))}const p=u.createColormapLUT({colormap:c,fillUnspecified:!1});return this.lookup={rendererJSON:e,colormapLut:p},this.canRenderInWebGL=h.isColormapSupportedByWebGL(p?.indexedColormap),{success:!0}}_updateStretchRenderer(e){let{stretchType:t,dra:r}=e;if(!("none"===t||e.statistics?.length||(s=this.rasterInfo.statistics,null!=s&&s.length>0&&null!=s[0].min&&null!=s[0].max)||r))return{success:!1,error:"Unsupported renderer; StretchRenderer.customStatistics is required when dynamic range adjustment is not used."};var s;const a=e.histograms||this.rasterInfo.histograms;!function(e){return"percentClip"===e||"histogramEqualization"===e}(e.stretchType)||a?.length||r||(t="minMax");const{computeGamma:o,useGamma:n,colorRamp:l}=e;let{gamma:i}=e;if(n&&o&&!i?.length){const t=e.statistics?.length?e.statistics:this.rasterInfo.statistics;i=c.computeGammaValues(this.rasterInfo.pixelType,t)}const p=this.rasterInfo.pixelType,h=!r&&["u8","u16","s8","s16"].includes(p);if("histogramEqualization"===t){const t=a.map(e=>c.createHistogramEqualizationLUT(e));this.lookup={rendererJSON:e,histogramLut:t}}else if(h){const t=c.getStretchCutoff(e,{rasterInfo:this.rasterInfo}),r=c.createStretchLUT({pixelType:p,...t,gamma:n?i:null,rounding:"floor"});this.lookup={rendererJSON:e,stretchLut:r}}else this.lookup={rendererJSON:e};if(l&&!function(e){return"algorithmic"===e.type&&["0,0,0,255","0,0,0"].includes(e.fromColor.join(","))&&["255,255,255,255","255,255,255"].includes(e.toColor.join(","))}(l)){const t=d.convertColorRampToColormap(l,{interpolateAlpha:!0});this.lookup.colormapLut=u.createColormapLUT({colormap:t}),this.lookup.rendererJSON=e}return this.lookup.gamma=n&&i?.length?i:null,this.canRenderInWebGL="histogramEqualization"!==t,{success:!0}}_generateColormapWebGLParams(e){const{indexedColormap:t,offset:r}=this.lookup.colormapLut||{};return{colormap:t,colormapOffset:r,isClassBreaks:e,type:"lut"}}_generateStretchWebGLParams(e,t,r){const{colormapLut:s}=this.lookup,a=t.colorRamp?s?.indexedColormap:null,o=t.colorRamp?s?.offset:null;"histogramEqualization"===t.stretchType&&(t={...t,stretchType:"minMax"});const{gamma:n}=this.lookup,l=!(!t.useGamma||!n?.some(e=>1!==e)),{minCutOff:i,maxCutOff:u,minOutput:p,maxOutput:d}=c.getStretchCutoff(t,{rasterInfo:this.rasterInfo,pixelBlock:e,bandIds:r});let h=0;null!=e&&(h=e.getPlaneCount(),2===h&&((e=e.clone()).statistics=[e.statistics[0]],e.pixels=[e.pixels[0]]));const{bandCount:m}=this.rasterInfo,f=Math.min(3,r?.length||h||m,m),g=a||l?1:255,b=new Float32Array(f);if(l&&n)for(let e=0;e<f;e++)n[e]>1?n[e]>2?b[e]=6.5+(n[e]-2)**2.5:b[e]=6.5+100*(2-n[e])**4:b[e]=1;1===i.length&&(i[2]=i[1]=i[0]),1===u.length&&(u[2]=u[1]=u[0]);const y=l&&n?[n[0],n[1]??n[0],n[2]??n[0]]:[1,1,1],S=l?[b[0],b[1]??b[0],b[2]??b[0]]:[1,1,1],C=u.map((e,t)=>u[t]===i[t]?0:(d-p)/(u[t]-i[t])/g);return{bandCount:f,minOutput:p/g,maxOutput:d/g,minCutOff:i,maxCutOff:u,factor:C,useGamma:l,gamma:y,gammaCorrection:S,colormap:a,colormapOffset:o,stretchType:t.stretchType,type:"stretch"}}_generateShadedReliefWebGLParams(e,t=!1,r={x:0,y:0}){const{colormapLut:s}=this.lookup,a=e.colorRamp?s?.indexedColormap:null,o=e.colorRamp?s?.offset:null,n={...e,isGCS:t,resolution:r},l=p.calculateHillshadeParams(n),i=this.rasterInfo.statistics?.[0];return{...l,minValue:i?.min??0,maxValue:i?.max??8e3,hillshadeType:"traditional"===e.hillshadeType?0:1,type:"hillshade",colormap:a,colormapOffset:o}}_generateVectorFieldWebGLParams(e){const{style:t,inputUnit:r,outputUnit:s,visualVariables:a,symbolTileSize:o,flowRepresentation:n}=e,l=this.rasterInfo.statistics?.[0].min??0,i=this.rasterInfo.statistics?.[0].max??50,u=a?.find(e=>"sizeInfo"===e.type)??{maxDataValue:i,maxSize:.8*o,minDataValue:l,minSize:.2*o},c=u.minDataValue??l,p=u.maxDataValue??i,d=null!=u.maxSize&&null!=u.minSize?[u.minSize/o,u.maxSize/o]:[.2,.8];if("wind_speed"===t){const e=(d[0]+d[1])/2;d[0]=d[1]=e}const h=null!=c&&null!=p?[c,p]:null;let m=null;if("classified_arrow"===t)if(null!=c&&null!=p&&null!=u){m=[];const e=(u.maxDataValue-u.minDataValue)/5;for(let t=0;t<6;t++)m.push(u.minDataValue+e*t)}else m=[0,1e-6,3.5,7,10.5,14];const f="flow_to"===n==("ocean_current_kn"===t||"ocean_current_m"===t)?0:Math.PI,g=a?.find(e=>"rotationInfo"===e.type);return{breakValues:m,dataRange:h,inputUnit:r,outputUnit:s,symbolTileSize:o,symbolPercentRange:d,style:t||"single_arrow",rotation:f,rotationType:this.rasterInfo.storageInfo?.tileInfo&&"vector-uv"===this.rasterInfo.dataType?"geographic":g?.rotationType||e.rotationType,type:"vectorField"}}},t.__decorate([o.property({json:{write:!0}})],e.default.prototype,"rendererJSON",void 0),t.__decorate([o.property({type:i,json:{write:!0}})],e.default.prototype,"rasterInfo",void 0),t.__decorate([o.property({json:{write:!0}})],e.default.prototype,"lookup",void 0),t.__decorate([o.property()],e.default.prototype,"canRenderInWebGL",void 0),e.default=t.__decorate([l.subclass("esri.renderers.support.RasterSymbolizer")],e.default),e.default});