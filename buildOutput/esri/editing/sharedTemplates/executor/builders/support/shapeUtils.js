// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/arrayUtils","../../../../../core/libs/gl-matrix-2/factories/vec3f64","./builderUtils","../../../../../geometry/Point","../../../../../geometry/Polyline"],function(e,t,n,a,s,r){"use strict";function o(e,t,n){let a=t[0]-e[0],s=t[1]-e[1];const r=Math.sqrt(a*a+s*s);return a/=r,s/=r,a*=n,s*=n,[e[0]+a,e[1]+s]}function i(e,t,n,a){const s=function(e){const t=function(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}(e);return[e[0]/t,e[1]/t,e[2]/t]}([t[0]-e[0],t[1]-e[1],t[2]*a-e[2]*a]);return[e[0]+s[0]*n,e[1]+s[1]*n,e[2]+s[2]*n]}function c(e,t,n){const a=h(t[0],t[1]),r=e.x+n*((t[1][0]-t[0][0])/a),o=e.y+n*((t[1][1]-t[0][1])/a),i={};return e.hasM&&(i.m=e.m),new s({x:r,y:o,spatialReference:e.spatialReference,...i})}function l(e,t,n,a){const r=p(t[0],t[1],a),o=e.x+n*((t[1][0]-t[0][0])/r),i=e.y+n*((t[1][1]-t[0][1])/r),c=e.z+n*((t[1][2]-t[0][2])/r),l={};return e.hasM&&(l.m=e.m),new s({x:o,y:i,z:c,spatialReference:e.spatialReference,...l})}function f(e,t,n,a){return void 0===e||void 0===t||null===e||null===t?null:e+(t-e)/n*a}function h(e,t){const n=t[0]-e[0],a=t[1]-e[1];return Math.sqrt(n*n+a*a)}function p(e,t,n){return Math.sqrt((e[0]-t[0])**2+(e[1]-t[1])**2+(void 0!==e[2]&&void 0!==t[2]?(e[2]*n-t[2]*n)**2:0))}function u(e,t,n){const a=t[0],s=t[1],r=[s[0]-a[0],s[1]-a[1]],o=Math.sqrt(r[0]**2+r[1]**2),i=[r[0]/o,r[1]/o];return e.x+=n*i[0],e.y+=n*i[1],e}function g(e,t,n){const a=e.paths[t][n];return new s({spatialReference:e.spatialReference,x:a[0],y:a[1],hasZ:e.hasZ,hasM:e.hasM,z:e.hasZ?a[2]:void 0,m:e.hasM?e.hasZ?a[3]:a[2]:void 0})}e.computedTotalLength=function(e){let t=0;const n=a.getHeightUnitCorrectionFactor(e);for(let a=0;a<e.paths.length;a++){const s=e.paths[a].length;for(let r=0;r<s;r++)r>0&&(t+=e.hasZ?p(e.paths[a][r-1],e.paths[a][r],n):h(e.paths[a][r-1],e.paths[a][r]))}return t},e.convertRadialToPolylines=function(e){const t=e.geometry.clone();return t.paths.map(n=>new r({spatialReference:e.geometry.spatialReference,paths:[n],hasZ:t.hasZ,hasM:t.hasM}))},e.convertToTwoPoint=function(e){const t=[];for(const n of e.paths)for(let a=1;a<n.length;a++){const s=[[n[a-1].slice(),n[a].slice()]];t.push(new r({paths:s,spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM}))}return t},e.distanceAlongLineSegment=o,e.distanceAlongLineSegmentWithZ=i,e.getSegmentLength=h,e.getSegmentLength3d=p,e.offsetPointFromSegment=u,e.pointAlongLine=function(e,t){let n=0,a=null;const r=e.hasM,i=e.hasZ?3:2;for(const c of e.paths){if(0===t){a=new s({x:c[0][0],y:c[0][1],...r?{m:c[0][i]}:{},spatialReference:e.spatialReference,hasM:r});break}for(let l=0;l<c.length-1;l++){const p=h(c[l],c[l+1]),u=n+p;if(u===t){a=new s({x:c[l+1][0],y:c[l+1][1],...r?{m:c[l+1][i]}:{},spatialReference:e.spatialReference,hasM:r});break}if(u>t){const h=o(c[l],c[l+1],t-n);a=new s({x:h[0],y:h[1],...r?{m:f(c[l][i],c[l+1][i],p,t-n)??void 0}:{},spatialReference:e.spatialReference,hasM:r});break}n+=p}if(null!==a)break}return a},e.pointAlongLineAndOffset=function(e,t,n){let a=0,r=null;if(t<=0){const a=[e.paths[0][0],e.paths[0][1]];let s=g(e,0,0);return s=c(s,a,t),u(s,a,n)}const i=e.hasM?e.hasZ?3:2:-1;for(const c of e.paths)for(let l=0;l<c.length-1;l++){const p=h(c[l],c[l+1]),g=a+p;if(g===t)return r=new s({x:c[l+1][0],y:c[l+1][1],...e.hasM?{m:c[l+1][i]}:{},spatialReference:e.spatialReference}),0===n?r:u(r,[c[l],c[l+1]],n);if(g>t){const h=o(c[l],c[l+1],t-a);return r=new s({x:h[0],y:h[1],...i>-1?{m:f(c[l][i],c[l+1][i],p,t-a)??void 0}:{},spatialReference:e.spatialReference}),0===n?r:u(r,[c[l],c[l+1]],n)}a+=p}if(0===a)return null;const l=e.paths.length-1,p=e.paths[l].length-1,m=[e.paths[l][p-1],e.paths[l][p]];let R=g(e,l,p);return R=c(R,m,t-a),u(R,m,n)},e.pointAlongLineWithZ=function(e,t,a){let r=0;const o=e.hasM;for(const c of e.paths){if(0===t)return new s({x:c[0][0],y:c[0][1],z:c[0][2],...o?{m:c[0][3]}:{},hasZ:!0,hasM:o,spatialReference:e.spatialReference});for(let l=0;l<c.length-1;l++){const h=p(c[l],c[l+1],a),u=r+h;if(u===t)return new s({x:c[l+1][0],y:c[l+1][1],z:c[l+1][2],...o?{m:c[l+1][3]}:{},hasZ:!0,hasM:o,spatialReference:e.spatialReference});if(u>t){const p=i(n.fromArray(c[l]),n.fromArray(c[l+1]),t-r,a);return new s({x:p[0],y:p[1],z:p[2],...o?{m:f(c[l][3],c[l+1][3],h,t-r)??void 0}:{},hasZ:!0,hasM:o,spatialReference:e.spatialReference})}r+=h}}return null},e.pointAlongLineWithZAndOffset=function(e,t,a,r){let o=0;if(t<=0){const n=[e.paths[0][0],e.paths[0][1]];let s=g(e,0,0);return s=l(s,n,t,r),u(s,n,a)}const c=e.hasM?e.hasZ?3:2:-1;for(const l of e.paths)for(let h=0;h<l.length-1;h++){const g=p(l[h],l[h+1],r),m=o+g;if(m===t){const t=new s({x:l[h+1][0],y:l[h+1][1],z:l[h+1][2],...e.hasM?{m:l[h+1][c]}:{},hasZ:!0,spatialReference:e.spatialReference});return 0===a?t:u(t,[l[h],l[h+1]],a)}if(m>t){const p=i(n.fromArray(l[h]),n.fromArray(l[h+1]),t-o,r),m=new s({x:p[0],y:p[1],z:p[2],...c>-1?{m:f(l[h][c],l[h+1][c],g,t-o)}:{},hasZ:!0,spatialReference:e.spatialReference});return 0===a?m:u(m,[l[h],l[h+1]],a)}o+=g}if(0===o)return null;const h=e.paths.length-1,m=e.paths[h].length-1,R=[e.paths[h][m-1],e.paths[h][m]];let y=g(e,h,m);return y=l(y,R,t-o,r),u(y,R,a)},e.pointFromPolygonVertex=function(e,t,n){const a=e.rings[t][n];return new s({spatialReference:e.spatialReference,x:a[0],y:a[1],hasZ:e.hasZ,hasM:e.hasM,z:e.hasZ?a[2]:void 0,m:e.hasM?e.hasZ?a[3]:a[2]:void 0})},e.pointFromPolylineVertex=g,e.sameStartEndPoint=function(e){return t.equals(e.at(0),e.at(-1))},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});