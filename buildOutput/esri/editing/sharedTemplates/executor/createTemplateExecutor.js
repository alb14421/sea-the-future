// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../Graphic","../../../core/Error","../../../core/Logger","../../../core/MapUtils","../../../core/promiseUtils","../../../core/uuid","../../templateUtils","./support/createFeatureServiceEdit","./support/executorUtils","./support/getBuilder","../../../geometry/support/jsonUtils","../../../networks/support/networkFieldUtils"],function(e,t,r,o,a,i,s,l,n,u,p,c,d,m){"use strict";const y=()=>a.getLogger("esri.editing.sharedTemplates.executor.createTemplateExecutor"),f="globalid";async function g(e){const t=await c.getBuilder(e.builderType);return r=>t.execute({...r,templatePart:e})}function T(e,t,o){const{associationGraphics:a,associationsTable:i,edits:s,utilityNetworkHelper:n,relationships:u}=o,p=n.findAgat(e.graphic,e.layer),c=n.findAgat(t.graphic,t.layer);if(!p||!c)return;const d=n.findRules(p).map(r=>r.fromNetworkSource?.sourceId!==p.networkSourceId||r.fromAssetGroup?.assetGroupCode!==p.assetGroup||null!==r.fromAssetType?.assetTypeCode&&r.fromAssetType?.assetTypeCode!==p.assetType||r.toNetworkSource.sourceId!==c.networkSourceId||r.toAssetGroup?.assetGroupCode!==c.assetGroup||null!==r.toAssetType&&r.toAssetType?.assetTypeCode!==c.assetType?r.toNetworkSource.sourceId!==p.networkSourceId||r.toAssetGroup?.assetGroupCode!==p.assetGroup||null!==r.toAssetType&&r.toAssetType?.assetTypeCode!==p.assetType||r.fromNetworkSource.sourceId!==c.networkSourceId||r.fromAssetGroup?.assetGroupCode!==c.assetGroup||null!==r.fromAssetType?.assetTypeCode&&r.fromAssetType?.assetTypeCode!==c.assetType?null:{rule:r,from:{agat:c,item:t},to:{agat:p,item:e}}:{rule:r,from:{agat:p,item:e},to:{agat:c,item:t}}).filter(e=>4===e?.rule.ruleType||5===e?.rule.ruleType||2===e?.rule.ruleType?null:e).filter(e=>null!==e);if(0===d.length)return;const y=m.getAssociationsTableFields(i),g=new Set;for(const e of d){const t={};t[y.fromNetworkSourceId]=e.rule.fromNetworkSource.sourceId,t[y.fromGlobalId]=e.from.item.graphic.attributes[e.from.item.layer.globalIdField??f],t[y.fromTerminalId]=null,e.rule.fromTerminal&&(t[y.fromTerminalId]=e.rule.fromTerminal.terminalId),t[y.toNetworkSourceId]=e.rule.toNetworkSource.sourceId,t[y.toGlobalId]=e.to.item.graphic.attributes[e.to.item.layer.globalIdField??f],t[y.toTerminalId]=null,e.rule.toTerminal&&(t[y.toTerminalId]=e.rule.toTerminal.terminalId),t[y.associationType]=e.rule.ruleType,t[y.percentAlong]=null,t[y.isContentVisible]=2===e.rule.ruleType?1:0,t[y.status]=0,t[y.globalId]=l.generateBracedUUID();const o=`${t[y.fromNetworkSourceId]}-${t[y.fromGlobalId]}-${t[y.toNetworkSourceId]}-${t[y.toGlobalId]}-${t[y.associationType]}`;if(g.has(o))continue;g.add(o);const n=new r({attributes:t,sourceLayer:i});a.add(n),s.push({id:i.layerId,graphic:n,tag:"",layer:i}),u.push({sourceGraphic:e.to.item.graphic,sourceLayerId:e.to.item.layer.layerId,destinationGraphic:n,destinationLayerId:i.layerId,sourceField:e.to.item.layer.globalIdField??f,destinationField:y.toGlobalId??f}),u.push({sourceGraphic:e.from.item.graphic,sourceLayerId:e.from.item.layer.layerId,destinationGraphic:n,destinationLayerId:i.layerId,sourceField:e.from.item.layer.globalIdField??f,destinationField:y.fromGlobalId??f})}}t.createTemplateExecutor=async function(t){if(!n.isLoadedSharedTemplate(t))throw new o("template-executor:template-not-loaded","The template must be loaded before it can be executed.");if(n.isSharedFeatureTemplate(t))return function(e){return t=>{const r=[],o=[];u.createFeatureServiceEdit({geometry:t,template:e,edits:r,relationships:o});const a=p.calculateExtent(r);return{edits:p.groupEditsByLayer(r),relationships:o,primary:r[0]??null,featureExtent:a,rotationPoint:a?.center??null}}}(t);if(n.isSharedGroupTemplate(t))return async function(e){const{definition:t}=e,r=await Promise.all(t.allParts.map(g));return(o,a)=>{const l=[],n=[],u=new Set,c=()=>{if(t.createUtilityNetworkAssociations&&"completion"===a){const{utilityNetwork:e,utilityNetworkAssociationsTable:r}=t;e&&r?function(e){const{edits:t,utilityNetworkHelper:r}=e,o=new Map;for(const e of t)""!==e.tag&&r.layerIdToSourceIdLookup.has(e.id)&&i.getOrCreateMapValue(o,e.tag,()=>[]).push(e);for(const t of o.values())if(!(t.length<2))for(let r=0;r<t.length;r++){const o=t[r];for(let a=r+1;a<t.length;a++)T(o,t[a],e)}}({associationGraphics:u,associationsTable:r,edits:l,relationships:n,utilityNetworkHelper:e}):y().warn("Unable to create utility network associations between group template features. The utility network or its associations table is unavailable.")}const e=p.calculateExtent(l);return{associationGraphics:u,edits:p.groupEditsByLayer(l),relationships:n,primary:l[0]??null,featureExtent:e,rotationPoint:e?.center??null}};if(null==o)return y().warn("No geometry provided to group template executor. Result will be empty."),c();const d=r.map(t=>t({edits:l,mode:a,parentTemplate:e,relationships:n,shape:o})).filter(s.isPromiseLike);return 0===d.length?c():Promise.all(d).then(()=>c())}}(t);if(n.isSharedPresetTemplate(t))return async function(t){const{createPresetServiceEdit:r}=await new Promise((t,r)=>e(["./support/createPresetServiceEdit"],t,r));return(e,a,i=0)=>{if(!d.isPoint(e))throw new o("template-executor:invalid-input-geometry","The input geometry for a preset template must be a point.");const s=[],l=[],n=r({geometry:e,template:t,edits:s,relationships:l,rotation:i,mode:a});return{edits:p.groupEditsByLayer(s),relationships:l,primary:s[0]??null,featureExtent:p.calculateExtent(s),rotationPoint:n}}}(t);throw new o("template-executor:unsupported-template-type","The template type is not supported.")},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});