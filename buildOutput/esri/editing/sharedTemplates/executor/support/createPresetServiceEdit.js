// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/Error","../../../templateUtils","./createFeatureServiceEdit","./executorUtils","../../../../geometry/Multipoint","../../../../geometry/Point","../../../../geometry/Polygon","../../../../geometry/Polyline","../../../../geometry/operators/affineTransformOperator","../../../../geometry/operators/support/Transformation"],function(e,t,s,i,o,r,n,a,l,h,p){"use strict";function f(e,t,s,i=0){if(!e)return null;if("point"===e.type)return new n({spatialReference:e.spatialReference,x:e.x+t,y:e.y+s,...e.hasZ?{z:e.z+i}:{},...e.hasM?{m:e.m}:{}});if("multipoint"===e.type){const o=[];if(e.hasZ&&e.hasM)for(let r=0;r<e.points.length;r++){const n=e.points[r];o.push([n[0]+t,n[1]+s,n[2]+i,n[3]])}else if(e.hasZ)for(let r=0;r<e.points.length;r++){const n=e.points[r];o.push([n[0]+t,n[1]+s,n[2]+i])}else if(e.hasM)for(let i=0;i<e.points.length;i++){const r=e.points[i];o.push([r[0]+t,r[1]+s,r[2]])}else for(let i=0;i<e.points.length;i++){const r=e.points[i];o.push([r[0]+t,r[1]+s])}return new r({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM,points:o})}if("polygon"===e.type){const o=new a({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM});for(let r=0;r<e.rings.length;r++){const n=e.rings[r],a=[];if(e.hasZ&&e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s,n[e][2]+i,n[e][3]]);else if(e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s,n[e][2]]);else if(e.hasZ)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s,n[e][2]+i]);else for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s]);o.addRing(a)}return o}if("polyline"===e.type){const o=new l({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM});for(let r=0;r<e.paths.length;r++){const n=e.paths[r],a=[];if(e.hasZ&&e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s,n[e][2]+i,n[e][3]]);else if(e.hasZ)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s,n[e][2]+i]);else if(e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s,n[e][2]]);else for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+s]);o.addPath(a)}return o}return e.clone()}e.createPresetServiceEdit=function e({edits:r,geometry:n,mode:a,relationships:l,rotation:g,tag:c="",template:u}){const{definition:m}=u,y=n.x-m.origin.x,d=n.y-m.origin.y,M=m.origin.hasZ&&n.hasZ?n.z-m.origin.z:0,Z=f(m.origin.clone(),y,d,M),x=(new p).rotate(g,Z.x,Z.y);for(const p of m.parts){if(r.length>o.maxDigitizingDisplayEdits&&"digitizing"===a)break;const g=p.template;if(!s.isLoadedSharedTemplate(g))throw new t("shared-template:template-not-loaded","A template part's template must be loaded before use");if(s.isSharedFeatureTemplate(g)){let e=f(p.geometry,y,d,M);x.isIdentity||(e=h.execute(e,x)),i.createFeatureServiceEdit({edits:r,geometry:e,relationships:l,tag:c,template:g})}else if(s.isSharedPresetTemplate(g)){const t=[];if(e({edits:x.isIdentity?t:r,geometry:n,mode:a,relationships:l,rotation:0,tag:c,template:g}),!x.isIdentity)for(const e of t){const{geometry:t}=e.graphic;t&&"mesh"!==t.type&&(e.graphic.geometry=h.execute(t,x),r.push(e))}}}return Z},e.translate=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});