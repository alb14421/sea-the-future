// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/RandomLCG","../CIMPlacements"],function(t,s,i){"use strict";const e=512,h=24,n=1e-6;class _{static{this.instance=null}static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(t,s,i,e){return new r(t,s,i,e)}}class r{constructor(t,h,n,_){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._accelerationMap=null,this._testInsidePolygon=!1,this._verticalSubdivision=!0,this._stepX=Math.abs(h.stepX??16)*n,this._stepY=Math.abs(h.stepY??16)*n,this._stepX=Math.round(128*this._stepX)/128,this._stepY=Math.round(128*this._stepY)/128,0!==this._stepX&&0!==this._stepY){if(this._gridType=h.gridType??"Fixed","Random"===this._gridType){const t=h.seed??13,i=1;this._randomLCG=new s(t*i),this._randomness=(h.randomness??100)/100,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0,this._buildRandomValues()}else{if(this._randomness=0,this._gridAngle=h.gridAngle??0,this._shiftOddRows=h.shiftOddRows??!1,this._offsetX=(h.offsetX??0)*n,this._offsetY=(h.offsetY??0)*n,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}if(this._graphicOriginX=0,this._graphicOriginY=0,null!=_){const[t,s,i,h]=_.split("/"),n=parseFloat(t),r=parseFloat(s),a=parseFloat(i),o=parseFloat(h);this._graphicOriginX=-(o*2**n+a)*e,this._graphicOriginY=r*e,this._testInsidePolygon=!0}this._internalPlacement=new i.Placement,this._calculateMinMax(t),this._geometryCursor=t}}next(){return this._geometryCursor?this._nextInside():null}_buildRandomValues(){if(!r._randValues){r._randValues=[];for(let t=0;t<h;t++)for(let t=0;t<h;t++)r._randValues.push(this._randomLCG.getFloat()),r._randValues.push(this._randomLCG.getFloat())}}_calculateMinMax(t){let s,i,h,n,_,r,a,o,l,f,c,u,M,p;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,a=o=M=c=Number.MAX_VALUE,l=f=p=u=-Number.MAX_VALUE;const g=1!==this._cosAngle;for(t.reset();t.nextPath();)for(;t.nextPoint();)r=t.x,_=t.y,s=r-this._graphicOriginX-this._offsetX,i=_-this._graphicOriginY-this._offsetY,g?(h=this._cosAngle*s-this._sinAngle*i,n=this._sinAngle*s+this._cosAngle*i):(h=s,n=i),a=Math.min(a,h),l=Math.max(l,h),o=Math.min(o,n),f=Math.max(f,n),c=Math.min(c,_),u=Math.max(u,_),M=Math.min(M,r),p=Math.max(p,r);c=c!==Number.MAX_VALUE?c:-512-this._stepY,u=u!==-Number.MAX_VALUE?u:this._stepY,M=M!==Number.MAX_VALUE?M:-this._stepX,p=p!==-Number.MAX_VALUE?p:e+this._stepX;const d=u-c,X=p-M;if(this._verticalSubdivision=d>=X,this._polygonMin=this._verticalSubdivision?c:M,this._testInsidePolygon){let t=0-this._graphicOriginX-this._offsetX-this._stepX,s=e-this._graphicOriginX-this._offsetX+this._stepX,i=-512-this._graphicOriginY-this._offsetY-this._stepY,h=0-this._graphicOriginY-this._offsetY+this._stepY;if(g){const e=[[t,i],[t,h],[s,i],[s,h]];t=i=Number.MAX_VALUE,s=h=-Number.MAX_VALUE;for(const n of e){const e=this._cosAngle*n[0]-this._sinAngle*n[1],_=this._sinAngle*n[0]+this._cosAngle*n[1];t=Math.min(t,e),s=Math.max(s,e),i=Math.min(i,_),h=Math.max(h,_)}}a=a!==Number.MAX_VALUE?Math.max(a,t):t,o=o!==Number.MAX_VALUE?Math.max(o,i):i,l=l!==-Number.MAX_VALUE?Math.min(l,s):s,f=f!==-Number.MAX_VALUE?Math.min(f,h):h}this._xMin=Math.round(a/this._stepX),this._xMax=Math.round(l/this._stepX),this._yMin=Math.round(o/this._stepY),this._yMax=Math.round(f/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1,this._buildAccelerationMap(t,M,p,c,u)}_buildAccelerationMap(t,s,i,h,n){t.reset();const _=new Map,r=this._verticalSubdivision,o=r?n-h:i-s;let l=Math.ceil(o/10);if(l<=1)return;const f=Math.floor(o/l);let c,u,M,p,g,d,X,m,x,A,Y;for(l++,this._delta=f,r?(x=-512-2*this._stepY,A=2*this._stepY,Y=h):(x=-2*this._stepX,A=e+2*this._stepX,Y=s);t.nextPath();)if(!(t.pathSize<2)&&t.nextPoint())for(c=t.x,u=t.y;t.nextPoint();c=M,u=p){if(M=t.x,p=t.y,r){if(u===p||u<x&&p<x||u>A&&p>A)continue;g=Math.min(u,p),d=Math.max(u,p)}else{if(c===M||c<x&&M<x||c>A&&M>A)continue;g=Math.min(c,M),d=Math.max(c,M)}for(;g<d;)X=Math.floor((g-Y)/f),a(X,c,u,M,p,_),g+=f;m=Math.floor((d-Y)/f),m>X&&a(m,c,u,M,p,_)}this._accelerationMap=_}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let t=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(t+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let i,e;if(this._currentX++,"Random"===this._gridType){const n=(this._currentX%h+h)%h,_=(this._currentY%h+h)%h;i=this._graphicOriginX+t+this._stepX*this._randomness*(.5-r._randValues[_*h+n])*2/3,e=this._graphicOriginY+s+this._stepY*this._randomness*(.5-r._randValues[_*h+n+1])*2/3}else i=this._graphicOriginX+this._cosAngle*t+this._sinAngle*s,e=this._graphicOriginY-this._sinAngle*t+this._cosAngle*s;if(!this._testInsidePolygon||this._isInsidePolygon(i,e,this._geometryCursor))return this._internalPlacement.setTranslate(i,e),this._internalPlacement}}_isInsidePolygon(t,s,i){if(null==this._accelerationMap)return function(t,s,i){let e,h,_,r,a=0;for(t+=n,s+=n,i.reset();i.nextPath();)if(i.nextPoint())for(e=i.x,h=i.y;i.nextPoint();e=_,h=r)_=i.x,r=i.y,h>s!=r>s&&((_-e)*(s-h)-(r-h)*(t-e)>0?a++:a--);return 0!==a}(t,s,i);t+=n,s+=n;const e=this._verticalSubdivision,h=e?s:t,_=Math.floor((h-this._polygonMin)/this._delta),r=this._accelerationMap.get(_);if(!r)return!1;let a,o,l,f=0;for(const i of r){if(a=i[0],o=i[1],e){if(a[1]>s==o[1]>s)continue;l=(o[0]-a[0])*(s-a[1])-(o[1]-a[1])*(t-a[0])}else{if(a[0]>t==o[0]>t)continue;l=(o[1]-a[1])*(t-a[0])-(o[0]-a[0])*(s-a[1])}l>0?f++:f--}return 0!==f}}function a(t,s,i,e,h,n){let _=n.get(t);_||(_=[],n.set(t,_)),_.push([[s,i],[e,h]])}t.PlacementInsidePolygon=_,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});