// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Error","../../../core/Logger","../../../geometry/GeometryCursor","../../../geometry/SpatialReference","../../../geometry/support/jsonUtils","../../../geometry/support/PolylineBuilder","../../../geometry/support/TileClipper","../CIMCursor","../CIMEffects"],function(e,t,s,o,i,n,l,r,a,h){"use strict";const c=()=>s.getLogger("esri.symbols.cim.effects.EffectTaperedPolygon");class _{static{this.instance=null}static local(){return null===_.instance&&(_.instance=new _),_.instance}execute(e,t,s){return new y(e,t,s)}}class y extends a.PathEffectCursor{constructor(e,t,s){super(e,!1,!0),this._slopeS=0,this._slopeC=1,this._lastTangent1=new r.Point(NaN,NaN),this._lastWidth=0,this._geomUnitsPerPoint=s,this._halfFromWidth=Math.abs(void 0!==t.fromWidth?t.fromWidth:0)*s*.5,this._halfToWidth=Math.abs(void 0!==t.toWidth?t.toWidth:1)*s*.5,this._originalLength=(void 0!==t.length?t.length:0)*s,this._length=0}processPath(e){if(e.totalSize<=0)return null;if(this._halfFromWidth<=0&&this._halfToWidth<=0){const t=o.GeometryCursor.createEmptyOptimizedCIM("esriGeometryPolygon",!1,!1,e.yFactor);for(e.seekPathEnd();e.prevPoint();)t.pushXY(e.x,e.y);for(e.seekPathStart();e.nextPoint();)t.pushXY(e.x,e.y);return t}const s=e.asJSON();e.seekPath(e.totalSize-1);const r=h.lazyGeneralizeOperator.module.execute(s,.25*this._geomUnitsPerPoint,{removeDegenerateParts:!0}),a=null==r?null:n.isPolygon(r)?r.rings:n.isPolyline(r)?r.paths:null;if(!a)return c().error(new t("mapview-bad-resource","Unable to process geometry")),null;const _=h.lazyLengthOperator.module.execute(r);if((0===this._originalLength||this._originalLength>_)&&_>0){this._length=_;const e=(this._halfToWidth-this._halfFromWidth)/this._length;if(Math.abs(e)<1){const t=e*e;this._slopeC=Math.sqrt(1/(1+t)),this._slopeS=Math.sqrt(t/(1+t)),e<0&&(this._slopeS=-this._slopeS)}else this._slopeC=this._slopeS=.7071}else this._length=this._originalLength,this._slopeC=1,this._slopeS=0;const y=[];for(const e of a){const t=new l,s=new l;let o=0;this._setFromOffset(e.slice(0,2),t,s);for(let i=0,n=3;n<=e.length;++i,++n)o=this._setOffset(e.slice(i,n),o,t,s);this._setToOffset(e.slice(-2),o,t,s);const[i]=t.getGeometry(),[n]=s.getGeometry();y.push([...i,...n.reverse()])}const p={rings:y,spatialReference:{wkid:i.WebMercator.wkid}},f=h.lazySimplifyOperator.module.execute(p);return o.GeometryCursor.fromJSONCIM(f)}_setFromOffset([[e,t],[s,o]],i,n){const l=this._halfFromWidth,a=new r.Point(s-e,o-t).normalize().scale(l);i.beginPath([e-a.y,t+a.x]),n.beginPath([e+a.y,t-a.x])}_setToOffset([[e,t],[s,o]],i,n,l){let a;a=(i+=Math.sqrt((s-e)**2+(o-t)**2))>=this._length?this._halfToWidth:this._halfFromWidth+(this._halfToWidth-this._halfFromWidth)*i/this._length;const h=new r.Point(s-e,o-t).normalize().scale(a);n.lineTo([s-h.y,o+h.x]),l.lineTo([s+h.y,o-h.x])}_setOffset([[e,s],[o,i],[n,l]],a,h,_){const y=Math.sqrt((o-e)**2+(i-s)**2);let p;p=a+y>=this._length?this._halfToWidth:this._halfFromWidth+(this._halfToWidth-this._halfFromWidth)*(a+y)/this._length,a+=y;const f=new r.Point(o,i),d=new r.Point(o-e,i-s).normalize(),g=new r.Point(n-o,l-i).normalize(),x=r.Point.sub(g,d),u=h.getPointCount(),m=_.getPointCount();d.leftPerpendicular(),g.leftPerpendicular();const P=d.x*g.x+d.y*g.y;if(P>.99){const e=r.Point.add(d,g).scale(p/2),t=e.clone().rotate(this._slopeC,this._slopeS);h.lineTo([f.x+t.x,f.y+t.y]);const s=e.rotateReverse(this._slopeC,this._slopeS);_.lineTo([f.x-s.x,f.y-s.y])}else{const o=d.x*g.y-d.y*g.x;if(x.scale(1/o),o<0){x.scale(-p).rotateReverse(this._slopeC,this._slopeS);const e=_.getXY(m-1);e||c().error(new t("mapview-bad-resource","Unable to process geometry, index out of scope"));const s=r.Point.add(f,x).sub(r.Point.fromArray(e));if(d.x*s.y-d.y*s.x>0){const e=d.clone().scale(-p).rotateReverse(this._slopeC,this._slopeS),t=g.clone().scale(-p).rotateReverse(this._slopeC,this._slopeS);_.lineTo([f.x+e.x,f.y+e.y]),_.lineTo([f.x,f.y]),_.lineTo([f.x+t.x,f.y+t.y])}else _.lineTo([f.x+x.x,f.y+x.y])}else{x.scale(p).rotate(this._slopeC,this._slopeS);const e=h.getXY(u-1);e||c().error(new t("mapview-bad-resource","Unable to process geometry, index out of scope"));const s=r.Point.add(f,x).sub(r.Point.fromArray(e));if(d.x*s.y-d.y*s.x>0){const e=d.clone().scale(p).rotate(this._slopeC,this._slopeS),t=g.clone().scale(p).rotate(this._slopeC,this._slopeS);h.lineTo([f.x+e.x,f.y+e.y]),h.lineTo([f.x,f.y]),h.lineTo([f.x+t.x,f.y+t.y])}else h.lineTo([f.x+x.x,f.y+x.y])}const i=Math.acos(P);let n=1;if(p>.25){const e=2*Math.acos(1-.25/p);e<i&&(n=Math.round(i/e))}const l=Math.cos(i/n),a=Math.sin(i/n),y=d.clone();if(o<0){y.rotate(this._slopeC,this._slopeS);const o=h.getXY(u-1);o||c().error(new t("mapview-bad-resource","Unable to process geometry, index out of scope"));const i=r.Point.add(f,y.clone().scale(this._lastWidth)),n=r.Point.sub(i,r.Point.fromArray(o)),l=d.x*n.y-d.y*n.x;if(!isNaN(this._lastTangent1.x)&&!isNaN(this._lastTangent1.y)&&l>0){const t=new r.Point(e,s),o=this._lastTangent1.clone().scale(this._lastWidth);o.rotate(this._slopeC,this._slopeS);const i=d.clone().scale(this._lastWidth);i.rotate(this._slopeC,this._slopeS),h.lineTo([t.x+o.x,t.y+o.y]),h.lineTo([t.x,t.y]),h.lineTo([t.x+i.x,t.y+i.y])}}else{y.scale(-1).rotateReverse(this._slopeC,this._slopeS);const o=_.getXY(m-1);o||c().error(new t("mapview-bad-resource","Unable to process geometry, index out of scope"));const i=r.Point.add(f,y.clone().scale(this._lastWidth)),n=r.Point.sub(i,r.Point.fromArray(o)),l=d.x*n.y-d.y*n.x;if(!isNaN(this._lastTangent1.x)&&!isNaN(this._lastTangent1.y)&&l>0){const t=new r.Point(e,s),o=this._lastTangent1.clone().scale(-this._lastWidth);o.rotateReverse(this._slopeC,this._slopeS);const i=d.clone().scale(-this._lastWidth);i.rotateReverse(this._slopeC,this._slopeS),_.lineTo([t.x+o.x,t.y+o.y]),_.lineTo([t.x,t.y]),_.lineTo([t.x+i.x,t.y+i.y])}}y.scale(p);for(let e=0;e<=n;e++)o<0?(h.lineTo([f.x+y.x,f.y+y.y]),y.rotateReverse(l,a)):(_.lineTo([f.x+y.x,f.y+y.y]),y.rotate(l,a))}return this._lastTangent1.setCoords(d.x,d.y),this._lastWidth=p,a}}e.EffectTaperedPolygon=_,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});