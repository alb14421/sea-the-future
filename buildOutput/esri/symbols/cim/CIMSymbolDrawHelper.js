// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/fontUtils","../../core/has","../../core/lang","../../core/Logger","../../core/mathUtils","../../core/ObjectPool","../../core/screenUtils","../../geometry/GeometryCursor","../../geometry/support/aaBoundingRect","../../geometry/support/boundsUtils","../../geometry/support/centroid","../../geometry/support/jsonUtils","./CIMEffects","./CIMImageColorSubstitutionHelper","./CIMOperators","./CIMPlacements","./defaultCIMValues","./imageUtils","./mathUtils","./rasterizingUtils","./Rect","./TextRasterizer","./utils","../../views/2d/engine/svgUtils","../../views/2d/engine/webgl/definitions","../../views/2d/engine/webgl/mesh/templates/shapingUtils","../../views/2d/layers/graphics/graphicsUtils"],function(t,e,i,r,s,a,n,o,l,h,c,u,m,f,d,g,p,y,_,P,S,x,M,w,b,C,k,I){"use strict";const v=Math.PI/180,T=()=>s.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class R{constructor(t){this._t=t}static createIdentity(){return new R([1,0,0,0,1,0])}clone(){const t=this._t;return new R(t.slice())}transform(t){const e=this._t;return[e[0]*t[0]+e[1]*t[1]+e[2],e[3]*t[0]+e[4]*t[1]+e[5]]}static createScale(t,e){return new R([t,0,0,0,e,0])}scale(t,e){const i=this._t;return i[0]*=t,i[1]*=t,i[2]*=t,i[3]*=e,i[4]*=e,i[5]*=e,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(t,e){return new R([0,0,t,0,0,e])}translate(t,e){const i=this._t;return i[2]+=t,i[5]+=e,this}static createRotate(t){const e=Math.cos(t),i=Math.sin(t);return new R([e,-i,0,i,e,0])}rotate(t){return R.multiply(this,R.createRotate(t),this)}angle(){const t=this._t[0],e=this._t[3],i=Math.sqrt(t*t+e*e);return[t/i,e/i]}static multiply(t,e,i){const r=t._t,s=e._t,a=r[0]*s[0]+r[3]*s[1],n=r[1]*s[0]+r[4]*s[1],o=r[2]*s[0]+r[5]*s[1]+s[2],l=r[0]*s[3]+r[3]*s[4],h=r[1]*s[3]+r[4]*s[4],c=r[2]*s[3]+r[5]*s[4]+s[5],u=i._t;return u[0]=a,u[1]=n,u[2]=o,u[3]=l,u[4]=h,u[5]=c,i}invert(){const t=this._t;let e=t[0]*t[4]-t[1]*t[3];if(0===e)return new R([0,0,0,0,0,0]);e=1/e;const i=(t[1]*t[5]-t[2]*t[4])*e,r=(t[2]*t[3]-t[0]*t[5])*e,s=t[4]*e,a=-t[1]*e,n=-t[3]*e,o=t[0]*e;return new R([s,a,i,n,o,r])}}class z{constructor(t,e){this._resourceManager=t,this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new n(p.Placement,void 0,void 0,100),this._earlyReturn=!1,this._mapRotation=0,this._transfos.push(e||R.createIdentity()),this._sizeTransfos.push(e?e.scaleRatio():1)}setTransform(t,e){this._transfos=[t||R.createIdentity()],this._sizeTransfos=[e||(t?t.scaleRatio():1)]}setGeomUnitsPerPoint(t){this._geomUnitsPerPoint=t}transformPt(t){return this._transfos[this._transfos.length-1].transform(t)}transformSize(t){return t*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(t){return this._transfos[this._transfos.length-1].invert().transform(t)}reverseTransformSize(t){return t/this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformScalar(t){return t/this._transfos[this._transfos.length-1].scaleRatio()}getTransformAngle(){return this._transfos[this._transfos.length-1].angle()}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}prevGeomUnitsPerPoint(){return this._transfos.length>2?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(t,e){const i=e?t.scaleRatio():1;R.multiply(t,this.back(),t),this._transfos.push(t),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*i)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(t,e,i){if(t)switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(t,e);break;case"CIMTextSymbol":this.drawTextSymbol(t,e,i)}}drawMultiLayerSymbol(t,e){if(!t||!e)return;const i=t.symbolLayers;if(!i)return;const r=t.effects;if(r&&r.length>0){const t=this.executeEffects(r,e);if(t){let e=t.next();for(;e;)this.drawSymbolLayers(i,e.asJSON()),e=t.next()}}else this.drawSymbolLayers(i,e)}executeEffects(t,e){let i=new f.SimpleEffectCursor(l.GeometryCursor.fromJSONCIM(e));for(const e of t){const t=g.getEffectOperator(e);t&&(i=t.execute(i,e,this.geomUnitsPerPoint(),null))}return i}drawSymbolLayers(t,e){let i=t.length;for(;i--;){const r=t[i];if(!r||!1===r.enable)continue;const s=r.effects;if(s&&s.length>0){const t=this.executeEffects(s,e);if(t){let e=null;for(;(e=t.next())&&(this.drawSymbolLayer(r,e.asJSON()),!this._earlyReturn););}}else this.drawSymbolLayer(r,e);if(this._earlyReturn)return}}drawSymbolLayer(t,e){switch(t.type){case"CIMSolidFill":this.drawSolidFill(e,t.color,t.path);break;case"CIMHatchFill":this.drawHatchFill(e,t);break;case"CIMPictureFill":this.drawPictureFill(e,t);break;case"CIMGradientFill":this.drawGradientFill(e,t);break;case"CIMSolidStroke":this.drawSolidStroke(e,t.color,t.width,t.capStyle,t.joinStyle,t.miterLimit,t.path);break;case"CIMPictureStroke":this.drawPictureStroke(e,t);break;case"CIMGradientStroke":this.drawGradientStroke(e,t);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(t,e)}}drawHatchFill(t,e){const i=function(t,e,i){let r=w.getNumericValue(t.separation,y.defaultCIMValues.CIMHatchFill.separation)*i,s=w.getNumericValue(t.rotation);if(0===r)return null;r<0&&(r=-r);let a=0;const n=.5*r;for(;a>n;)a-=r;for(;a<-n;)a+=r;const o=h.create();c.getBoundsXY(o,e),o[0]-=n,o[1]-=n,o[2]+=n,o[3]+=n;const l=[[o[0],o[1]],[o[0],o[3]],[o[2],o[3]],[o[2],o[1]]];for(;s>180;)s-=180;for(;s<0;)s+=180;const u=Math.cos(s*v),m=Math.sin(s*v),f=-r*m,d=r*u;let g,p,_,P;a=w.getNumericValue(t.offsetX)*i*m-w.getNumericValue(t.offsetY)*i*u,g=_=Number.MAX_VALUE,p=P=-Number.MAX_VALUE;for(const t of l){const e=t[0],i=t[1],r=u*e+m*i,s=-m*e+u*i;g=Math.min(g,r),_=Math.min(_,s),p=Math.max(p,r),P=Math.max(P,s)}_=Math.floor(_/r)*r;let S=u*g-m*_-f*a/r,x=m*g+u*_-d*a/r,M=u*p-m*_-f*a/r,b=m*p+u*_-d*a/r;const C=1+Math.round((P-_)/r),k=[];for(let t=0;t<C;t++)S+=f,x+=d,M+=f,b+=d,k.push([[S,x],[M,b]]);return{paths:k}}(e,t,this.geomUnitsPerPoint());i&&(this.pushClipPath(t),this.drawMultiLayerSymbol(e.lineSymbol,i),this.popClipPath())}drawPictureFill(t,e){}drawGradientFill(t,e){}drawPictureStroke(t,e){}drawGradientStroke(t,e){}drawMarkerLayer(t,e){const i=t.markerPlacement;if(i){const r=g.getPlacementOperator(i);if(r){const s="CIMMarkerPlacementInsidePolygon"===i.type||"CIMMarkerPlacementPolygonCenter"===i.type&&i.clipAtBoundary;s&&this.pushClipPath(e);const a=r.execute(l.GeometryCursor.fromJSONCIM(e),i,this.geomUnitsPerPoint(),null);if(a){let e=null;for(;(e=a.next())&&(this.drawMarker(t,e),!this._earlyReturn););}s&&this.popClipPath()}}else{const i=this._placementPool.acquire();if(m.isPoint(e))i.tx=e.x,i.ty=e.y,this.drawMarker(t,i);else if(m.isPolygon(e)){const r=u.polygonCentroid(e);r&&([i.tx,i.ty]=r,this.drawMarker(t,i))}else if(m.isPolyline(e)){for(const r of e.paths)for(const e of r)if(i.tx=e[0],i.ty=e[1],this.drawMarker(t,i),this._earlyReturn)break}else for(const r of e.points)if(i.tx=r[0],i.ty=r[1],this.drawMarker(t,i),this._earlyReturn)break;this._placementPool.release(i)}}drawMarker(t,e){switch(t.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(t,e);break;case"CIMVectorMarker":this.drawVectorMarker(t,e)}}drawPictureMarker(t,e){if(!t)return;const i=this._resourceManager.getResource(t.url),r=w.getNumericValue(t.size,y.defaultCIMValues.CIMPictureMarker.size);if(null==i||r<=0)return;const s=i.width,a=i.height;if(!s||!a)return;const n=s/a,o=w.getNumericValue(t.scaleX,1),l=R.createIdentity(),h=t.anchorPoint;if(h){let e=h.x,i=h.y;"Absolute"!==t.anchorPointUnits&&(e*=r*n*o,i*=r),l.translate(-e,-i)}let c=w.getNumericValue(t.rotation);t.rotateClockwise&&(c=-c),this._mapRotation&&(c+=this._mapRotation),c&&l.rotate(c*v);let u=w.getNumericValue(t.offsetX),m=w.getNumericValue(t.offsetY);if(u||m){if(this._mapRotation){const t=v*this._mapRotation,e=Math.cos(t),i=Math.sin(t),r=u*i+m*e;u=u*e-m*i,m=r}l.translate(u,m)}const f=this.geomUnitsPerPoint();1!==f&&l.scale(f,f);const d=e.getAngle();d&&l.rotate(d),l.translate(e.tx,e.ty),this.push(l,!1),this.drawImage(t,r),this.pop()}drawVectorMarker(t,e){if(!t)return;const i=t.markerGraphics;if(!i)return;const r=w.getNumericValue(t.size,y.defaultCIMValues.CIMVectorMarker.size),s=t.frame,a=s?s.ymax-s.ymin:0,n=r&&a?r/a:1,o=R.createIdentity();s&&o.translate(.5*-(s.xmax+s.xmin),.5*-(s.ymax+s.ymin));const l=t.anchorPoint;if(l){let e=l.x,i=l.y;"Absolute"!==t.anchorPointUnits?s&&(e*=s.xmax-s.xmin,i*=s.ymax-s.ymin):(e/=n,i/=n),o.translate(-e,-i)}1!==n&&o.scale(n,n);let h=w.getNumericValue(t.rotation);t.rotateClockwise&&(h=-h),this._mapRotation&&(h+=this._mapRotation),h&&o.rotate(h*v);let c=w.getNumericValue(t.offsetX),u=w.getNumericValue(t.offsetY);if(c||u){if(this._mapRotation){const t=v*this._mapRotation,e=Math.cos(t),i=Math.sin(t),r=c*i+u*e;c=c*e-u*i,u=r}o.translate(c,u)}const m=this.geomUnitsPerPoint();1!==m&&o.scale(m,m);const f=e.getAngle();f&&o.rotate(f),o.translate(e.tx,e.ty),this.push(o,t.scaleSymbolsProportionally);for(const t of i){t?.symbol&&t.geometry||T().error("Invalid marker graphic",t);let e=t.textString;if("number"==typeof e&&(e=e.toString()),this.drawSymbol(t.symbol,t.geometry,e),this._earlyReturn)break}this.pop()}drawTextSymbol(t,e,i){if(!t)return;if(!m.isPoint(e))return;if(w.getNumericValue(t.height,y.defaultCIMValues.CIMTextSymbol.height)<=0)return;const r=R.createIdentity();let s=w.getNumericValue(t.angle);s=-s,s&&r.rotate(s*v);const a=w.getNumericValue(t.offsetX),n=w.getNumericValue(t.offsetY);(a||n)&&r.translate(a,n);const o=this.geomUnitsPerPoint();1!==o&&r.scale(o,o),r.translate(e.x,e.y),this.push(r,!1),this.drawText(t,i),this.pop()}}function F(t,e,i){for(const r of e){const e=r.length;for(let s=1;s<e;s++){const e=r[s-1],a=r[s];let n=(a[0]-e[0])*(a[0]-e[0])+(a[1]-e[1])*(a[1]-e[1]);if(0===n)continue;n=Math.sqrt(n);const o=((a[0]-e[0])*(t[1]-e[1])-(a[1]-e[1])*(t[0]-e[0]))/n;if(Math.abs(o)<i){const r=((a[0]-e[0])*(t[0]-e[0])+(a[1]-e[1])*(t[1]-e[1]))/n;if(r>-i&&r<n+i)return!0}}}return!1}function V(t,e){const i=e[0]-t[0],r=e[1]-t[1];return 180/Math.PI*Math.atan2(r,i)}const L=t=>t?{spatialReference:t.spatialReference,rings:[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]]}:null,G=(t,e,i)=>{switch(t){case"ExtraLeading":return 1+e/i;case"Multiple":return e;case"Exact":return e/i}};function A(t,i=1){const r=w.fromCIMFontDecoration(t),s=w.fromCIMFontStyle(t.fontStyleName),a=t.fontFamilyName??e.defaultFontFamily,{weight:n,style:o}=s,l=i*(t.height||5),h=w.fromCIMHorizontalAlignment(t.horizontalAlignment),c=w.fromCIMVerticalAlignment(t.verticalAlignment),u=w.getFillColor(t),m=w.getFillColor(t.haloSymbol),f=null!=m?i*(t.haloSize??0):0,d=w.getStrokeColor(t.symbol),g=i*(w.getStrokeWidth(t.symbol)||0),p="CIMBackgroundCallout"===t.callout?.type?t.callout.backgroundSymbol:null,y=w.getFillColor(p),_=w.getStrokeWidth(p),P=w.getStrokeColor(p);return{color:u,size:l,horizontalAlignment:h,verticalAlignment:c,font:{family:a,style:w.getFontStyle(o),weight:w.getFontWeight(n),decoration:r},outline:{size:g||0,color:d},halo:{size:f||0,color:m,style:o},backgroundColor:y,borderLine:null!=_&&null!=P?{size:_,color:P}:null,pixelRatio:1,premultiplyColors:!0}}function U(t){let e,i,r,s,a,n=t[0],o=1;for(;o<t.length;)e=t[o][0]-n[0],i=t[o][1]-n[1],s=0!==e?i/e:Math.PI/2,void 0!==r&&Math.abs(s-r)<=1e-4?(t.splice(o-1,1),n=a):(a=n,n=t[o],o++),r=s}t.CIMSymbolDrawHelper=z,t.CanvasDrawHelper=class extends z{constructor(t,e,i,r){super(e,i),this._applyAdditionalRenderProps=r,this._colorSubstitutionHelper=new d,this._ctx=t}drawSolidFill(t,e){if(!t)return;if(m.isPolygon(t))this._buildPath(t.rings,!0);else if(m.isPolyline(t))this._buildPath(t.paths,!0);else if(m.isExtent(t))this._buildPath(L(t).rings,!0);else{if(!m.isMultipoint(t))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const i=this._ctx;i.fillStyle="string"==typeof e?e:"rgba("+Math.round(e[0])+","+Math.round(e[1])+","+Math.round(e[2])+","+(e[3]??255)/255+")",i.fill("evenodd")}drawSolidStroke(t,e,i,r,s,a){if(!t||!e||0===i)return;if(m.isPolygon(t))this._buildPath(t.rings,!0);else if(m.isPolyline(t))this._buildPath(t.paths,!1);else{if(!m.isExtent(t))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(L(t).rings,!0)}const n=this._ctx;n.strokeStyle="string"==typeof e?e:"rgba("+Math.round(e[0])+","+Math.round(e[1])+","+Math.round(e[2])+","+(e[3]??255)/255+")",n.lineWidth=Math.max(this.transformSize(i),.5),this._setCapStyle(r),this._setJoinStyle(s),n.miterLimit=a,n.stroke()}pushClipPath(t){if(this._ctx.save(),m.isPolygon(t))this._buildPath(t.rings,!0);else if(m.isPolyline(t))this._buildPath(t.paths,!0);else{if(!m.isExtent(t))return;this._buildPath(L(t).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(t,e){const{colorSubstitutions:i,url:r,tintColor:s}=t,a=w.getNumericValue(t.scaleX,1),n=this._resourceManager.getResource(r);if(null==n)return;let o=e*(n.width/n.height),l=e;e||(o=n.width,l=n.height);const h=w.isSVGImage(r)||"src"in n&&w.isSVGImage(n.src);let c="getFrame"in n?_.getFirstFrame(n):n;i&&(c=this._colorSubstitutionHelper.applyColorSubstitution(c,i)),this._applyAdditionalRenderProps&&!h&&s&&(c=this._colorSubstitutionHelper.tintImageData(c,s));const u=this.transformPt([0,0]),[m,f]=this.getTransformAngle(),d=this.transformSize(1),g=this._ctx;g.save(),g.setTransform({m11:a*d*m,m12:a*d*f,m21:-d*f,m22:d*m,m41:u[0],m42:u[1]}),g.drawImage(c,-o/2,-l/2,o,l),g.restore()}drawText(t,e){if(!e||0===e.length)return;this._textRasterizer||(this._textRasterizer=new M);const i=A(t,this.transformSize(o.px2pt(1))),r=this._textRasterizer.rasterizeText(e,i);if(!r)return;const{size:s,anchorX:a,anchorY:n,canvas:l}=r,h=s[0]*(a+.5),c=s[1]*(n-.5),u=this._ctx,m=this.transformPt([0,0]),[f,d]=this.getTransformAngle();u.save(),u.setTransform({m11:1*f,m12:1*d,m21:-1*d,m22:1*f,m41:m[0]-1*h,m42:m[1]+1*c}),u.drawImage(l,0,0),u.restore()}drawPictureFill(t,e){if(!t)return;let{colorSubstitutions:i,height:r,offsetX:s,offsetY:a,rotation:n,scaleX:o,tintColor:l,url:h}=e;const c=this._resourceManager.getResource(h);if(null==c)return;if(m.isPolygon(t))this._buildPath(t.rings,!0);else if(m.isPolyline(t))this._buildPath(t.paths,!0);else if(m.isExtent(t))this._buildPath(L(t).rings,!0);else{if(!m.isMultipoint(t))return;console.log("CanvasDrawHelper.drawPictureFill - No implementation!")}const u=this._ctx,f=w.isSVGImage(h)||"src"in c&&w.isSVGImage(c.src);let d,g="getFrame"in c?_.getFirstFrame(c):c;if(i&&(g=this._colorSubstitutionHelper.applyColorSubstitution(g,i)),this._applyAdditionalRenderProps){f||l&&(g=this._colorSubstitutionHelper.tintImageData(g,l)),d=u.createPattern(g,"repeat");const t=this.transformSize(1);n||(n=0),s?s*=t:s=0,a?a*=t:a=0,r&&(r*=t);const e=r?r/c.height:1,i=o&&r?o*r/c.width:1;if(0!==n||1!==e||1!==i||0!==s||0!==a){const t=new DOMMatrix;t.rotateSelf(0,0,-n).translateSelf(s,a).scaleSelf(i,e,1),d.setTransform(t)}}else d=u.createPattern(g,"repeat");u.save(),u.fillStyle=d,u.fill("evenodd"),u.restore()}drawPictureStroke(t,e){if(!t)return;let{colorSubstitutions:i,capStyle:s,joinStyle:a,miterLimit:n,tintColor:l,url:h,width:c}=e;const u=this._resourceManager.getResource(h);if(null==u)return;let f;if(m.isPolygon(t))f=t.rings;else if(m.isPolyline(t))f=t.paths;else{if(!m.isExtent(t))return m.isMultipoint(t)?void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!"):void 0;f=L(t).rings}c||(c=u.width);const d=w.isSVGImage(h)||"src"in u&&w.isSVGImage(u.src);let g="getFrame"in u?_.getFirstFrame(u):u;i&&(g=this._colorSubstitutionHelper.applyColorSubstitution(g,i)),this._applyAdditionalRenderProps&&(d||l&&(g=this._colorSubstitutionHelper.tintImageData(g,l)));const p=Math.max(this.transformSize(o.pt2px(c)),.5),y=p/g.width,P=this._ctx,S=P.createPattern(g,"repeat-y");let x,M;P.save(),this._setCapStyle(s),this._setJoinStyle(a),void 0!==n&&(P.miterLimit=n),P.lineWidth=p;for(let t of f)if(t=r.clone(t),U(t),t&&!(t.length<=1)){x=this.transformPt(t[0]);for(let e=1;e<t.length;e++){M=this.transformPt(t[e]);const i=V(x,M),r=new DOMMatrix;r.translateSelf(0,x[1]-p/2).scaleSelf(y,y,1).rotateSelf(0,0,90-i),S.setTransform(r),P.strokeStyle=S,P.beginPath(),P.moveTo(x[0],x[1]),P.lineTo(M[0],M[1]),P.stroke(),x=M}}P.restore()}drawGradientFill(t,e){if(!t)return;let i;if(m.isPolygon(t))i=t.rings;else if(m.isPolyline(t))i=t.paths;else{if(!m.isExtent(t))return void T().error("Unable to draw gradient fill");i=L(t).rings}this._buildPath(i,!0);const{angle:r,gradientMethod:s,gradientSize:n,gradientSizeUnits:l}=e,c=y.defaultCIMValues.CIMGradientFill,u=e.gradientType??c.gradientType,f=-a.deg2rad(r??0),d=h.empty();for(const t of i){const e=t?t.length:0;if(e>1)for(let i=0;i<e;i++){let e=this.transformPt(t[i]);"Linear"!==s&&"Rectangular"!==s||(e=P.rotate(e,-f)),h.expandPointInPlace(d,e)}}const[g,p,_,x]=d,M=this._ctx;switch(M.save(),s){case"Buffered":T().error(`Gradient method "${s}" currently unsupported.`);break;case"Linear":{const t=(p+x)/2,i="Absolute"===l?this.transformSize(o.pt2px(n)):w.getRelativeGradientSize(n,c.gradientSize)*(_-g),[r,s]="Discrete"===u?[_,_-i]:[g+i,g],a=P.rotate([r,t],f),h=P.rotate([s,t],f),m=M.createLinearGradient(a[0],a[1],h[0],h[1]);S.addColorStops(m,e),M.fillStyle=m,M.fill("evenodd");break}case"Circular":{const t=h.center(d),i=h.diagonal(d)/2,r="Absolute"===l?this.transformSize(o.pt2px(n)):w.getRelativeGradientSize(n,c.gradientSize)*i,[s,a]="Discrete"===u?[i,i-r]:[r,0],m=M.createRadialGradient(t[0],t[1],s,t[0],t[1],a);S.addColorStops(m,e),M.fillStyle=m,M.fill("evenodd");break}case"Rectangular":{const i=h.center(d),r=i[0],s=i[1],a=P.rotate(i,f),m=(i,r,s,n,o,l,h,c)=>{M.save(),this.pushClipPath(t);const u=P.rotate([o,l],f),m=P.rotate([h,c],f);M.beginPath(),M.moveTo(a[0],a[1]),M.lineTo(u[0],u[1]),M.lineTo(m[0],m[1]),M.lineTo(a[0],a[1]),M.clip();const d=P.rotate([i,r],f),g=P.rotate([s,n],f),p=M.createLinearGradient(d[0],d[1],g[0],g[1]);S.addColorStops(p,e),M.fillStyle=p,M.fill("evenodd"),M.restore()};let y="Absolute"===l?this.transformSize(o.pt2px(n)):w.getRelativeGradientSize(n,c.gradientSize)*(h.width(d)/2),[b,C]="Discrete"===u?[_,_-y]:[r+y,r];m(b,s,C,s,_,p,_,x),[b,C]="Discrete"===u?[g,g+y]:[r-y,r],m(b,s,C,s,g,x,g,p),y="Absolute"===l?this.transformSize(o.pt2px(n)):w.getRelativeGradientSize(n,c.gradientSize)*(h.height(d)/2);let[k,I]="Discrete"===u?[x,x-y]:[s+y,s];m(r,k,r,I,_,x,g,x),[k,I]="Discrete"===u?[p,p+y]:[s-y,s],m(r,k,r,I,g,p,_,p);break}}M.restore()}drawGradientStroke(t,e){const{capStyle:i,gradientMethod:s,gradientSize:a,gradientSizeUnits:n,joinStyle:l,miterLimit:h,width:c}=e;if(!t||0===c)return;let u;if(m.isPolygon(t))u=t.rings;else if(m.isPolyline(t))u=t.paths;else{if(!m.isExtent(t))return void T().error("Unable to draw gradient stroke");u=L(t).rings}const f=e.gradientType??y.defaultCIMValues.CIMGradientStroke.gradientType,d=Math.max(this.transformSize(o.pt2px(c)),.5),g=this._ctx;let p,_;g.save(),this._setCapStyle(i),this._setJoinStyle(l),void 0!==h&&(g.miterLimit=h),g.lineWidth=d;for(let t of u){if(t=r.clone(t),U(t),!t||t.length<=1)continue;let i=0;p=this.transformPt(t[0]);for(let e=1;e<t.length;e++){_=this.transformPt(t[e]);const r=_[0]-p[0],s=_[1]-p[1];i+=Math.sqrt(r*r+s*s),p=_}const l="Absolute"===n?this.transformSize(o.pt2px(a)):w.getRelativeGradientSize(a,y.defaultCIMValues.CIMGradientStroke.gradientSize)*("AcrossLine"===s?d:i);let h=0;p=this.transformPt(t[0]);for(let r=1;r<t.length;r++){_=this.transformPt(t[r]);const a=_[0]-p[0],n=_[1]-p[1],o=Math.sqrt(a*a+n*n);let c,u,m,y;switch(s){case"AcrossLine":{const[t,e]=P.rotate([a/o,n/o],-Math.PI/2),i=d/2,r="Discrete"===f?i:l-i;c=(p[0]+_[0])/2+t*r,u=(p[1]+_[1])/2+e*r,m=c-t*l,y=u-e*l;break}case"AlongLine":{const t=a/o,e=n/o;"Discrete"===f?(c=p[0]-t*h,u=p[1]-e*h,m=c+t*l,y=u+e*l):(m=p[0]+t*(i-h),y=p[1]+e*(i-h),c=m-t*l,u=y-e*l);break}default:return T().error("Unrecognized gradient method:",s),void g.restore()}const x=g.createLinearGradient(c,u,m,y);S.addColorStops(x,e),g.strokeStyle=x,g.beginPath(),g.moveTo(p[0],p[1]),g.lineTo(_[0],_[1]),g.stroke(),h+=o,p=_}}g.restore()}_buildPath(t,e){const i=this._ctx;if(i.beginPath(),t)for(const r of t){const t=r?r.length:0;if(t>1){let s=this.transformPt(r[0]);i.moveTo(s[0],s[1]);for(let e=1;e<t;e++)s=this.transformPt(r[e]),i.lineTo(s[0],s[1]);e&&i.closePath()}}}_setCapStyle(t){switch(t){case"Butt":this._ctx.lineCap="butt";break;case"Round":this._ctx.lineCap="round";break;case"Square":this._ctx.lineCap="square"}}_setJoinStyle(t){switch(t){case"Bevel":this._ctx.lineJoin="bevel";break;case"Round":this._ctx.lineJoin="round";break;case"Miter":this._ctx.lineJoin="miter"}}},t.EnvDrawHelper=class extends z{constructor(t,e){super(t,e),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new x(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return h.fromValues(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(t){if(t&&!(this._clipCount>0))if(m.isPolygon(t))this._processPath(t.rings,0);else if(m.isPolyline(t))this._processPath(t.paths,0);else if(m.isExtent(t)){const e=L(t);e&&this._processPath(e.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(t,e,i){if(!t||this._clipCount>0||null==i||i<=0)return;const r=Math.max(.5*this.transformSize(w.getNumericValue(i,y.defaultCIMValues.CIMSolidStroke.width)),.25);if(m.isPolygon(t))this._processPath(t.rings,r);else if(m.isPolyline(t))this._processPath(t.paths,r);else if(m.isExtent(t)){const e=L(t);e&&this._processPath(e.rings,r)}else console.error("drawSolidStroke unexpected geometry type!")}drawMarkerLayer(t,e){m.isPolygon(e)&&t.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===t.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===t.markerPlacement.type&&t.markerPlacement.clipAtBoundary)?this._processPath(e.rings,0):super.drawMarkerLayer(t,e)}drawHatchFill(t,e){this.drawSolidFill(t)}drawPictureFill(t,e){this.drawSolidFill(t)}drawGradientFill(t,e){this.drawSolidFill(t)}drawPictureStroke(t,e){this.drawSolidStroke(t,null,e.width)}drawGradientStroke(t,e){this.drawSolidStroke(t,null,e.width)}pushClipPath(t){this.drawSolidFill(t),this._clipCount++}popClipPath(){this._clipCount--}drawImage(t,e){const{url:i}=t,r=w.getNumericValue(t.scaleX,1);let s=r*e,a=e;const n=this._resourceManager.getResource(i);if(null!=n){const t=n.height/n.width;s=r*(e?t>1?e:e/t:n.width),a=e?t>1?e*t:e:n.height}this._merge(this.transformPt([-s/2,-a/2]),0),this._merge(this.transformPt([-s/2,a/2]),0),this._merge(this.transformPt([s/2,-a/2]),0),this._merge(this.transformPt([s/2,a/2]),0)}drawText(t,e){if(!e||0===e.length)return;this._textRasterizer||(this._textRasterizer=new M);const i=A(t);let[r,s]=this._textRasterizer.computeTextSize(e,i);r=o.px2pt(r),s=o.px2pt(s);const a=this.transformSize(1)*this.reverseTransformScalar(1);r*=a,s*=a;let n=0;switch(t.horizontalAlignment){case"Left":n=r/2;break;case"Right":n=-r/2}let l=0;switch(t.verticalAlignment){case"Bottom":l=s/2;break;case"Top":l=-s/2;break;case"Baseline":l=s/6}this._merge(this.transformPt([-r/2+n,-s/2+l]),0),this._merge(this.transformPt([-r/2+n,s/2+l]),0),this._merge(this.transformPt([r/2+n,-s/2+l]),0),this._merge(this.transformPt([r/2+n,s/2+l]),0)}_processPath(t,e){if(t)for(const i of t){const t=i?i.length:0;if(t>1){this._merge(this.transformPt(i[0]),e);for(let r=1;r<t;r++)this._merge(this.transformPt(i[r]),e)}}}_merge(t,e){t[0]-e<this._xmin&&(this._xmin=t[0]-e),t[0]+e>this._xmax&&(this._xmax=t[0]+e),t[1]-e<this._ymin&&(this._ymin=t[1]-e),t[1]+e>this._ymax&&(this._ymax=t[1]+e)}},t.HittestDrawHelper=class extends z{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0,this._textInfo=null,this._svg=null,this._path=null,this._canvas=null}destroy(){this._svg=b.destroyHiddenSvg(this._svg),this._path=null,this._canvas=null}hitTest(t,e,r,s,a,n){const l=n*o.pt2px(1);this.setTransform(),this.setGeomUnitsPerPoint(l),this._searchPoint=[(t[0]+t[2])/2,(t[1]+t[3])/2],this._searchDistPoint=(t[2]-t[0])/2/l,this._textInfo=s;const h=e&&("CIMPointSymbol"===e.type&&"Map"!==e.angleAlignment||"CIMTextSymbol"===e.type);if(this._mapRotation=h?a:0,!i("esri-mobile")){const t=o.px2pt(C.hittestToleranceSmallSymbol*window.devicePixelRatio),i=o.px2pt(C.hittestSmallSymbolThreshold);("CIMLineSymbol"!==e?.type&&"CIMPolygonSymbol"!==e?.type||!e.symbolLayers?.some(w.isCIMFill))&&"CIMMeshSymbol"!==e?.type&&(w.getSize(e)??0)<i&&(this._searchDistPoint=t)}return this._earlyReturn=!1,this.drawSymbol(e,r),this._earlyReturn}executeEffects(t,e){return"CIMGeometricEffectDashes"===t.at(-1)?.type&&(t=t.slice(0,-1)),super.executeEffects(t,e)}drawSolidFill(t,e,i){null!=i?this._hittestSvgPath(t,i,!0):this._hitTestFill(t)}drawHatchFill(t,e){this._hitTestFill(t)}drawPictureFill(t,e){this._hitTestFill(t)}drawGradientFill(t,e){this._hitTestFill(t)}drawSolidStroke(t,e,i,r,s,a,n){null!=n?this._hittestSvgPath(t,n,!1,i):this._hitTestStroke(t,i)}drawPictureStroke(t,e){this._hitTestStroke(t,e.width)}drawGradientStroke(t,e){this._hitTestStroke(t,e.width)}drawMarkerLayer(t,e){t.markerPlacement&&("CIMMarkerPlacementInsidePolygon"===t.markerPlacement.type||"CIMMarkerPlacementPolygonCenter"===t.markerPlacement.type&&t.markerPlacement.clipAtBoundary)?this._hitTestFill(e):super.drawMarkerLayer(t,e)}pushClipPath(t){}popClipPath(){}drawImage(t,e){const{url:i}=t,r=w.getNumericValue(t.scaleX,1),s=this._resourceManager.getResource(i);if(null==s||0===s.height||0===e)return;const a=e*this.geomUnitsPerPoint(),n=a*r*(s.width/s.height),o=this.reverseTransformPt(this._searchPoint),l=this._searchDistPoint;Math.abs(o[0])<n/2+l&&Math.abs(o[1])<a/2+l&&(this._earlyReturn=!0)}drawText(t,e){const i=this._textInfo;if(!i)return;const r=i.get(t);if(!r)return;if(!r.glyphMosaicItems.glyphs.length)return;const s=I.roundPtToWholePixel(w.getNumericValue(t.height,y.defaultCIMValues.CIMTextSymbol.height)),{lineGapType:a,lineGap:n}=t,o=a?G(a,w.getNumericValue(n),s):0,l="CIMBackgroundCallout"===t.callout?.type,h=k.shapeGlyphs(r.glyphMosaicItems,{scale:s/C.glyphSize,angle:0,xOffset:0,yOffset:0,horizontalAlignment:t.horizontalAlignment,verticalAlignment:t.verticalAlignment,maxLineWidth:I.getLineWidth(t.lineWidth),lineHeight:C.magicLabelLineHeight*Math.max(.25,Math.min(o||1,4)),decoration:t.font.decoration||"none",useCIMAngleBehavior:!0,hasBackground:l}),c=this.reverseTransformPt(this._searchPoint),u=c[0],m=c[1];for(const t of h.glyphs)if(u>t.xTopLeft&&u<t.xBottomRight&&m>-t.yBottomRight&&m<-t.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(t){let e=null;if(m.isExtent(t)){const i=t;e=[[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]]}else if(m.isPolygon(t))e=t.rings;else{if(!m.isPolyline(t))return;e=t.paths}const i=this.reverseTransformPt(this._searchPoint);(function(t,e){let i=0;for(const r of e){const e=r.length;for(let s=1;s<e;s++){const e=r[s-1],a=r[s];e[1]>t[1]!=a[1]>t[1]&&((a[0]-e[0])*(t[1]-e[1])-(a[1]-e[1])*(t[0]-e[0])>0?i++:i--)}}return 0!==i})(i,e)&&(this._earlyReturn=!0),this._earlyReturn||F(i,e,this.reverseTransformScalar(this._searchDistPoint)*this.prevGeomUnitsPerPoint())&&(this._earlyReturn=!0)}_getSvgPath(){return null!=this._svg&&null!=this._path||(this._svg??=b.createHiddenSvg(),this._path??=b.createSvgElement("path"),this._svg.appendChild(this._path)),this._path}_getCanvasContext(t,e){return this._canvas??=document.createElement("canvas"),this._canvas.width=t,this._canvas.height=e,this._canvas.getContext("2d",{willReadFrequently:!0})}_hittestSvgPath(t,e,i,r=0){const s=this.reverseTransformScalar(this._searchDistPoint)*this.prevGeomUnitsPerPoint(),a=this.reverseTransformPt(this._searchPoint),n=h.create();c.getBoundsXY(n,t);const o=n[0],l=n[1],u=n[2]-n[0],m=n[3]-n[1],f=this._getSvgPath();f.setAttribute("d",e);const d=f.getBBox();let g=Math.max(d.width/u,d.height/m),p=1;const y=2*s*g;y<1&&(p=2/y,g*=p,d.x*=p,d.y*=p,d.width*=p,d.height*=p);const _=1+r*g/2,P=this._getCanvasContext(d.width+2*_,d.height+2*_);P.setTransform(p,0,0,p,-d.x+_,-d.y+_);const S=new Path2D(e);i?P.fill(S):(P.lineWidth=r*(g/p),P.stroke(S));const x=(u*g-d.width)/2,M=(m*g-d.height)/2,w=Math.floor((a[0]-o-s)*g-x+_),b=Math.floor((m-(a[1]-l)-s)*g+M+_),C=Math.ceil(2*s*g),k=Math.ceil(2*s*g),I=P.getImageData(w,b,C,k).data;for(let t=3;t<I.length;t+=4)if(I[t]>127.5)return void(this._earlyReturn=!0)}_hitTestStroke(t,e){let i=null;if(m.isExtent(t)){const e=t;i=[[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]]]}else if(m.isPolygon(t))i=t.rings;else{if(!m.isPolyline(t))return;i=t.paths}F(this.reverseTransformPt(this._searchPoint),i,w.getNumericValue(e,y.defaultCIMValues.CIMSolidStroke.width)*this.geomUnitsPerPoint()/2+this.reverseTransformScalar(this._searchDistPoint)*this.prevGeomUnitsPerPoint())&&(this._earlyReturn=!0)}},t.Transformation=R,t.cDegToRad=v,t.lineGapType2LineHeight=G,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});