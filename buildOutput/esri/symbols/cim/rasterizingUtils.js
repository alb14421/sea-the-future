// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/floatRGBA","../../core/Logger","../../core/mathUtils","./constants","./defaultCIMValues","../../views/2d/engine/webgl/definitions"],function(t,o,e,n,r,a,s){"use strict";const i=()=>e.getLogger("esri.symbols.cim.rasterizingUtils");let l;function c(t){const o=[];switch(t.type){case"CIMPolarContinuousColorRamp":case"CIMLinearContinuousColorRamp":{"CIMPolarContinuousColorRamp"===t.type&&i().warnOnce("CIMPolarContinuousColorRamp is currently unsupported. Falling back to CIMLinearContinuousColorRamp.");const e=t;o.push({offset:0,color:[e.fromColor[0],e.fromColor[1],e.fromColor[2],e.fromColor[3]/255]}),o.push({offset:1,color:[e.toColor[0],e.toColor[1],e.toColor[2],e.toColor[3]/255]});break}case"CIMFixedColorRamp":{const e=t,n=1/(e.colors.length-1);let r=0;for(const t of e.colors)o.push({offset:r,color:[t[0],t[1],t[2],t[3]/255]}),r+=n;break}case"CIMMultipartColorRamp":{const e=t,n=e.weights.reduce((t,o)=>t+o,0);let r=0;for(let t=0;t<e.colorRamps.length;t++){const a=e.colorRamps[t],s=e.weights[t],i=c(a);for(const t of i)o.push({offset:(r+t.offset*s)/n,color:t.color});r+=s}break}default:i().error(`Color ramp "${t.type}" currently unsupported.`)}return o}function h(t,o){const e=[],n=(t.length-1)/(o-1);for(let r=0;r<o;r++){const a=t[Math.round(r*n)].color;e.push({offset:r/o,color:a}),e.push({offset:(r+1)/o,color:a})}return e}function f(t,o,e=0){for(const{offset:n,color:r}of o)t.addColorStop(Math.min(Math.max(n,e),1-e),`rgba(${r[0]}, ${r[1]}, ${r[2]}, ${r[3]})`)}function u(t,o,e,n,r){const a=e+2*r;t.width=a,t.height=n;const s=(r+1)/a,i=t.getContext("2d",{willReadFrequently:!0});if(o.length>0){const t=i.createLinearGradient(0,0,a,n);f(t,o,s),i.fillStyle=t}else i.fillStyle="rgba(128, 128, 128, 1)";i.fillRect(0,0,a,n)}function d(t){const{width:o,height:e}=t,n=t.getContext("2d").getImageData(0,0,o,e),r=new Uint8Array(n.data);for(let t=0;t<r.length;t+=4){const o=r[t+3]/255;r[t]*=o,r[t+1]*=o,r[t+2]*=o}return[r,o,e]}t.addColorStops=function(t,o){const{colorRamp:e,gradientType:n}=o,r=c(e),s="CIMFixedColorRamp"===e.type;if("Continuous"===n&&!s)return f(t,r);const i=o.interval??a.defaultCIMValues.CIMGradientFill.interval;if(s)return f(t,h(r,i));const d=[];l??=document.createElement("canvas"),u(l,r,i,1,0);const m=l.getContext("2d").getImageData(0,0,i,1).data;for(let t=0,o=0;t<i;t++,o=4*t){const e=[m[o+0],m[o+1],m[o+2],m[o+3]];d.push({offset:t/i,color:e}),d.push({offset:(t+1)/i,color:e})}return f(t,d)},t.rasterizeDash=function(t,e){null==t&&(t=[]);const n="Butt"===e,a="Square"===e,s=!n&&!a;t.length%2==1&&(t=[...t,...t]);const i=r.dashRadius,l=2*i;let c=0;for(const o of t)c+=o;const h=Math.round(c*i),f=new Float32Array(h*l),u=.5*i;let d=0,m=0,g=.5,C=!0;for(const o of t){for(d=m,m+=o*i;g<=m;){let t=.5;for(;t<l;){const o=(t-.5)*h+g-.5,e=s?(t-i)*(t-i):Math.abs(t-i);f[o]=C?n?Math.max(Math.max(d+u-g,e),Math.max(g-m+u,e)):e:s?Math.min((g-d)*(g-d)+e,(g-m)*(g-m)+e):a?Math.min(Math.max(g-d,e),Math.max(m-g,e)):Math.min(Math.max(g-d+u,e),Math.max(m+u-g,e)),t++}g++}C=!C}const p=f.length,M=new Uint8Array(4*p);for(let t=0;t<p;++t){const e=(s?Math.sqrt(f[t]):f[t])/i;o.packFloatRGBA(e,M,4*t)}return[M,h,l]},t.rasterizeDash1D=function(t){t.length%2==1&&(t=[...t,...t]);const e=t.reduce((t,o)=>t+o,0),n=Math.round(e*r.dashSdfRasterizationScale),a=new Float32Array(1*n);let s=0,i=0,l=.5,c=!0;for(const o of t){for(s=i,i+=o*r.dashSdfRasterizationScale;l<=i;){const t=l-.5,o=Math.min(Math.abs(l-s),Math.abs(l-i));a[t]=c?-o:o,l++}c=!c}const h=a.length,f=new Uint8Array(4*h);for(let t=0;t<h;++t){const e=a[t]/r.dashSdfRasterizationScale/r.dashSdfDistanceNormalization*.5+.5;o.packFloatRGBA(e,f,4*t)}return[f,n,1]},t.rasterizeFillStyle=function(t,o,e){const r=o.style,a=n.nextPowerOfTwo(Math.ceil(e)),s=(t=>"vertical"===t||"horizontal"===t||"cross"===t||"esriSFSCross"===t||"esriSFSVertical"===t||"esriSFSHorizontal"===t)(r)?8*a:16*a,i=2*a;t.width=s,t.height=s;const l=t.getContext("2d");l.strokeStyle="#ffffff",l.lineWidth=a,l.beginPath(),"vertical"!==r&&"cross"!==r&&"esriSFSCross"!==r&&"esriSFSVertical"!==r||(l.moveTo(s/2,-i),l.lineTo(s/2,s+i)),"horizontal"!==r&&"cross"!==r&&"esriSFSCross"!==r&&"esriSFSHorizontal"!==r||(l.moveTo(-i,s/2),l.lineTo(s+i,s/2)),"backward-diagonal"!==r&&"diagonal-cross"!==r&&"esriSFSDiagonalCross"!==r&&"esriSFSBackwardDiagonal"!==r||(l.moveTo(-i,-i),l.lineTo(s+i,s+i),l.moveTo(s-i,-i),l.lineTo(s+i,i),l.moveTo(-i,s-i),l.lineTo(i,s+i)),"forward-diagonal"!==r&&"diagonal-cross"!==r&&"esriSFSForwardDiagonal"!==r&&"esriSFSDiagonalCross"!==r||(l.moveTo(s+i,-i),l.lineTo(-i,s+i),l.moveTo(i,-i),l.lineTo(-i,i),l.moveTo(s+i,s-i),l.lineTo(s-i,s+i)),l.stroke();const c=l.getImageData(0,0,t.width,t.height),h=new Uint8Array(c.data);let f;for(let t=0;t<h.length;t+=4)f=h[t+3]/255,h[t]=h[t]*f,h[t+1]=h[t+1]*f,h[t+2]=h[t+2]*f;return[h,t.width,t.height,a]},t.rasterizeGradient=function(t,o){const{colorRamp:e,gradientType:n}=o,r="CIMFixedColorRamp"===e.type,i=o.interval||a.defaultCIMValues.CIMGradientFill.interval;let l=c(e);return r&&(l=h(l,i)),"Discrete"===n||r?function(t,o,e){return u(t,o,e,1,s.gradientTextureExternalPadding),d(t)}(t,l,i):function(t,o){return u(t,o,32,1,s.gradientTextureExternalPadding),d(t)}(t,l)},t.scale=function(t,o){const e=function(t){const o=t[0]?.[0]?.[0]??0,e=t[0]?.[0]?.[1]??0,n={ymin:e,xmin:o,ymax:e,xmax:o,width:0,height:0};for(let o=0;o<t.length;o++){const e=t[o];for(let t=0;t<e.length;t++){const o=e[t][0],r=e[t][1];o<n.xmin&&(n.xmin=o),o>n.xmax&&(n.xmax=o),r<n.ymin&&(n.ymin=r),r>n.ymax&&(n.ymax=r)}}return n.width=Math.abs(n.xmax-n.xmin),n.height=Math.abs(n.ymax-n.ymin),n}(t),n=0===e.width?1:e.width,r=0===e.height?1:e.height,a=[];for(let s=0;s<t.length;s++){const i=t[s],l=[];for(let t=0;t<i.length;t++){let a=Math.round(i[t][0]-e.xmin),s=Math.round(i[t][1]-e.ymin);if(a=o.xmin+a*o.width/n,s=o.ymin+s*o.height/r,isNaN(a)||isNaN(s))throw new Error("Scaled shape has NaN values");l.push([a,s])}a.push(l)}return a},t.translate=function(t,o,e){const n=[];for(let r=0;r<t.length;r++){const a=t[r],s=[];for(let t=0;t<a.length;t++){const n=a[t][0]+o,r=a[t][1]+e;if(isNaN(n)||isNaN(r))throw new Error("Scaled shape has NaN values");s.push([n,r])}n.push(s)}return n},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});