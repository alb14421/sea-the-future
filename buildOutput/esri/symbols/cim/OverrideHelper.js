// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../Color","../../core/colorUtils","../../core/lang","../../layers/support/FieldsIndex","../../support/ArcadeExpression","./utils","../../views/2d/arcade/callExpressionWithFeature"],function(e,r,i,t,s,o,a,c){"use strict";const l=e=>{if(!e)return[0,0,0,0];const{r,g:i,b:t,a:s}=e;return[r,i,t,255*s]};class n{static findApplicableOverrides(e,r,i){if(e&&r){if(e.primitiveName){let t=!1;for(const r of i)if(r.primitiveName===e.primitiveName){t=!0;break}if(!t)for(const t of r)t.primitiveName===e.primitiveName&&i.push(t)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)n.findApplicableOverrides(t,r,i);if(e.symbolLayers)for(const t of e.symbolLayers)n.findApplicableOverrides(t,r,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const t of e.effects)n.findApplicableOverrides(t,r,i);if(e.markerPlacement&&n.findApplicableOverrides(e.markerPlacement,r,i),"CIMVectorMarker"===e.type){if(e.markerGraphics)for(const t of e.markerGraphics)n.findApplicableOverrides(t,r,i),n.findApplicableOverrides(t.symbol,r,i)}else"CIMCharacterMarker"===e.type?n.findApplicableOverrides(e.symbol,r,i):"CIMHatchFill"===e.type?n.findApplicableOverrides(e.lineSymbol,r,i):"CIMPictureMarker"===e.type&&n.findApplicableOverrides(e.animatedSymbolProperties,r,i)}}}static findEffectOverrides(e,r){if(!e)return null;if("CIMGeometricEffectDashes"===e.type&&a.normalizeDashEffectTemplate(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const i=a.toLowerCaseProps(e),t=e.primitiveName,s=[];for(const e of r)e.primitiveName===t&&s.push(a.toLowerCaseProps(e));return{type:"cim-effect-param",effect:i,overrides:a.normalizePrimitiveOverrideProps(s)}}static async resolveSymbolOverrides(e,r,i,o,c,l,p){if(!e?.symbol)return null;let{symbol:f,primitiveOverrides:m}=e;const y=!!m;if(!y&&!o)return f;f=t.clone(f),m=t.clone(m);let d=!0;if(r||(r={attributes:{}},d=!1),y){if(d||(m=m.filter(e=>!e.valueExpressionInfo?.expression.includes("$feature"))),p||(m=m.filter(e=>!e.valueExpressionInfo?.expression.includes("$view"))),m.length>0){const e=a.attributesToFields(r.attributes),t={spatialReference:i,fields:e,geometryType:c};await n.createRenderExpressions(m,t),n.evaluateOverrides(m,r,c??"esriGeometryPoint",l,p,new s(e))}n.applyOverrides(f,m)}return o&&n.applyDictionaryTextOverrides(f,r,o,null),f}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const i=[];for(const t of e){const e=t.valueExpressionInfo;if(!e||n._expressionToRenderExpression.has(e.expression))continue;const s=o.createRendererExpression(e.expression,r.spatialReference);i.push(s),s.then(r=>n._expressionToRenderExpression.set(e.expression,r))}i.length>0&&await Promise.all(i)}static evaluateOverrides(e,r,t,s,o,a){const p={$view:{scale:o?.scale}};for(const o of e){o.value&&"object"==typeof o.value&&i.isRGB(o.value)&&("Color"===o.propertyName||"StrokeColor"===o.propertyName)&&(o.value=l(o.value));const e=o.valueExpressionInfo;if(!e)continue;const f=n._expressionToRenderExpression.get(e.expression);f&&(o.value=c(f,r,p,t,a,s))}}static applyDictionaryTextOverrides(e,r,i,t,s="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const a of o)a&&"CIMVectorMarker"===a.type&&n.applyDictionaryTextOverrides(a,r,i,t,"CIMTextSymbol"===e.type?e.textCase:s)}break;case"CIMVectorMarker":{const s=e.markerGraphics;if(!s)return;for(const e of s)e&&n.applyDictionaryTextOverrides(e,r,i,t)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const c=a.analyzeTextParts(o,i);e.textString=a.assignTextValuesFromFeature(r,c,t,s)}}}}static applyOverrides(e,r,i,t){if(e.primitiveName)for(const s of r)if(s.primitiveName===e.primitiveName){const r=a.uncapitalize(s.propertyName);if(t&&t.push({cim:e,nocapPropertyName:r,value:e[r]}),i){let r=!1;for(const t of i)t.primitiveName===e.primitiveName&&(r=!0);r||i.push(s)}null!=s.value&&(e[r]=s.value)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)n.applyOverrides(s,r,i,t);if(e.symbolLayers)for(const s of e.symbolLayers)n.applyOverrides(s,r,i,t);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const s of e.effects)n.applyOverrides(s,r,i,t);if("CIMVectorMarker"===e.type&&e.markerGraphics)for(const s of e.markerGraphics)n.applyOverrides(s,r,i,t),n.applyOverrides(s.symbol,r,i,t)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const i of e)void 0!==i.value&&(r+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return r}static toValue(e,i){if("DashTemplate"===e)return i.split(" ").map(e=>Number(e));if("Color"===e){const e=new r(i).toRgba();return e[3]*=255,e}return i}}e.OverrideHelper=n,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});