// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../chunks/tslib.es6","../../Graphic","../../core/jsonMap","../../core/JSONSupport","../../core/lang","../../core/accessorSupport/decorators/property","../../core/has","../../core/Logger","../../core/accessorSupport/decorators/reader","../../core/accessorSupport/decorators/subclass","../../core/accessorSupport/decorators/writer","../../geometry/SpatialReference","../../geometry/support/jsonUtils","../../geometry/support/typeUtils","../../layers/support/Field"],function(e,t,r,o,n,s,l,i,a,p,u,c,y,f,d,m){"use strict";var h;const g=new o.JSONMap({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});return e.default=h=class extends n.JSONSupport{constructor(e){super(e),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(e,t){return this.readFeaturesWithClass(e,t,r)}writeGeometryType(e,t,r,o){if(e)return void g.write(e,t,r,o);const{features:n}=this;if(n)for(const e of n)if(null!=e?.geometry)return void g.write(e.geometry.type,t,r,o)}readQueryGeometry(e,t){if(!e)return null;const r=!!e.spatialReference,o=f.fromJSON(e);return o&&!r&&t.spatialReference&&(o.spatialReference=y.fromJSON(t.spatialReference)),o}writeSpatialReference(e,t){if(e)return void(t.spatialReference=e.toJSON());const{features:r}=this;if(r)for(const e of r)if(e&&null!=e.geometry&&e.geometry.spatialReference)return void(t.spatialReference=e.geometry.spatialReference.toJSON())}clone(){return new h(this.cloneProperties())}cloneProperties(){return s.clone({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(e){const t=this.write();if(t.features&&Array.isArray(e)&&e.length>0)for(let r=0;r<t.features.length;r++){const o=t.features[r];if(o.geometry){const t=e?.[r];o.geometry=t?.toJSON()||o.geometry}}return t}quantize(e){const{scale:[t,r],translate:[o,n]}=e,s=this.features,l=this._getQuantizationFunction(this.geometryType,e=>Math.round((e-o)/t),e=>Math.round((n-e)/r));for(let e=0,t=s.length;e<t;e++)l?.(s[e].geometry)||(s.splice(e,1),e--,t--);return this.transform=e,this}unquantize(){const{geometryType:e,features:t,transform:r}=this;if(!r)return this;const{translate:[o,n],scale:[s,l]}=r;let i=null,a=null;if(this.hasZ&&null!=r?.scale?.[2]){const{translate:[,,e],scale:[,,t]}=r;i=r=>r*t+e}if(this.hasM&&null!=r?.scale?.[3]){const{translate:[,,,e],scale:[,,,t]}=r;a=r=>null==r?r:r*t+e}const p=this._getHydrationFunction(e,e=>e*s+o,e=>n-e*l,i,a);for(const{geometry:e}of t)null!=e&&p&&p(e);return this.transform=null,this}readFeaturesWithClass(e,t,r){const o=y.fromJSON(t.spatialReference),n=[];for(let t=0;t<e.length;t++){const s=e[t],l=r.fromJSON(s),i=s.geometry?.spatialReference;null==l.geometry||i||(l.geometry.spatialReference=o);const a=s.aggregateGeometries,p=l.aggregateGeometries;if(a&&null!=p)for(const e in p){const t=p[e],r=a[e],n=r?.spatialReference;null==t||n||(t.spatialReference=o)}n.push(l)}return n}_quantizePoints(e,t,r){let o,n;const s=[];for(let l=0,i=e.length;l<i;l++){const i=e[l];if(l>0){const e=t(i[0]),l=r(i[1]);e===o&&l===n||(s.push([e-o,l-n]),o=e,n=l)}else o=t(i[0]),n=r(i[1]),s.push([o,n])}return s.length>0?s:null}_getQuantizationFunction(e,t,r){return"point"===e?e=>(e.x=t(e.x),e.y=r(e.y),e):"polyline"===e||"polygon"===e?e=>{const o=f.isPolygon(e)?e.rings:e.paths,n=[];for(let e=0,s=o.length;e<s;e++){const s=o[e],l=this._quantizePoints(s,t,r);l&&n.push(l)}return n.length>0?(f.isPolygon(e)?e.rings=n:e.paths=n,e):null}:"multipoint"===e?e=>{const o=this._quantizePoints(e.points,t,r);return o&&o.length>0?(e.points=o,e):null}:"extent"===e?e=>e:null}_getHydrationFunction(e,t,r,o,n){return"point"===e?e=>{e.x=t(e.x),e.y=r(e.y),o&&(e.z=o(e.z))}:"polyline"===e||"polygon"===e?e=>{const s=f.isPolygon(e)?e.rings:e.paths;let l,i;for(let e=0,o=s.length;e<o;e++){const o=s[e];for(let e=0,n=o.length;e<n;e++){const n=o[e];e>0?(l+=n[0],i+=n[1]):(l=n[0],i=n[1]),n[0]=t(l),n[1]=r(i)}}if(o&&n)for(let e=0,t=s.length;e<t;e++){const t=s[e];for(let e=0,r=t.length;e<r;e++){const r=t[e];r[2]=o(r[2]),r[3]=n(r[3])}}else if(o)for(let e=0,t=s.length;e<t;e++){const t=s[e];for(let e=0,r=t.length;e<r;e++){const r=t[e];r[2]=o(r[2])}}else if(n)for(let e=0,t=s.length;e<t;e++){const t=s[e];for(let e=0,r=t.length;e<r;e++){const r=t[e];r[2]=n(r[2])}}}:"extent"===e?e=>{e.xmin=t(e.xmin),e.ymin=r(e.ymin),e.xmax=t(e.xmax),e.ymax=r(e.ymax),o&&null!=e.zmax&&null!=e.zmin&&(e.zmax=o(e.zmax),e.zmin=o(e.zmin)),n&&null!=e.mmax&&null!=e.mmin&&(e.mmax=n(e.mmax),e.mmin=n(e.mmin))}:"multipoint"===e?e=>{const s=e.points;let l,i;for(let e=0,o=s.length;e<o;e++){const o=s[e];e>0?(l+=o[0],i+=o[1]):(l=o[0],i=o[1]),o[0]=t(l),o[1]=r(i)}if(o&&n)for(let e=0,t=s.length;e<t;e++){const t=s[e];t[2]=o(t[2]),t[3]=n(t[3])}else if(o)for(let e=0,t=s.length;e<t;e++){const t=s[e];t[2]=o(t[2])}else if(n)for(let e=0,t=s.length;e<t;e++){const t=s[e];t[2]=n(t[2])}}:null}},t.__decorate([l.property({type:String,json:{write:!0}})],e.default.prototype,"displayFieldName",void 0),t.__decorate([l.property({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],e.default.prototype,"exceededTransferLimit",void 0),t.__decorate([l.property({type:[r],json:{write:!0}})],e.default.prototype,"features",void 0),t.__decorate([p.reader("features")],e.default.prototype,"readFeatures",null),t.__decorate([l.property({type:[m],json:{write:!0}})],e.default.prototype,"fields",void 0),t.__decorate([l.property({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:g.read}}})],e.default.prototype,"geometryType",void 0),t.__decorate([c.writer("geometryType")],e.default.prototype,"writeGeometryType",null),t.__decorate([l.property({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],e.default.prototype,"hasM",void 0),t.__decorate([l.property({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],e.default.prototype,"hasZ",void 0),t.__decorate([l.property({types:d.geometryTypes,json:{write:!0}})],e.default.prototype,"queryGeometry",void 0),t.__decorate([p.reader("queryGeometry")],e.default.prototype,"readQueryGeometry",null),t.__decorate([l.property({type:y,json:{write:!0}})],e.default.prototype,"spatialReference",void 0),t.__decorate([c.writer("spatialReference")],e.default.prototype,"writeSpatialReference",null),t.__decorate([l.property({json:{write:!0}})],e.default.prototype,"transform",void 0),e.default=h=t.__decorate([u.subclass("esri.rest.support.FeatureSet")],e.default),e.default.prototype.toJSON.isDefaultToJSON=!0,e.default});