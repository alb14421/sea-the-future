// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../request","../core/accessorSupport/get","../geometry/support/normalizeUtils","./networkService","./utils","./route/utils","./support/FeatureSet","./support/RouteSolveResult"],function(e,r,t,s,o,a,n,u,i){"use strict";function c(e){return e instanceof u}e.solve=async function(e,u,l){const f=[],p=[],y={},m={},d=a.parseUrl(e),{path:g}=d;c(u.stops)&&o.collectGeometries(u.stops.features,p,"stops.features",y),c(u.pointBarriers)&&o.collectGeometries(u.pointBarriers.features,p,"pointBarriers.features",y),c(u.polylineBarriers)&&o.collectGeometries(u.polylineBarriers.features,p,"polylineBarriers.features",y),c(u.polygonBarriers)&&o.collectGeometries(u.polygonBarriers.features,p,"polygonBarriers.features",y);const h=await s.normalizeCentralMeridian(p);for(const e in y){const r=y[e];f.push(e),m[e]=h.slice(r[0],r[1])}if(o.isInputGeometryZAware(m,f)){let e=null;try{e=await o.fetchServiceDescription(g,u.apiKey,l)}catch{}e&&!e.hasZ&&o.dropZValuesOffInputGeometry(m,f)}for(const e in m)m[e].forEach((r,s)=>{t.get(u,e)[s].geometry=r});const R={...l,query:{...d.query,...n.routeParametersToQueryParameters(u),f:"json"}},v=g.endsWith("/solve")?g:`${g}/solve`,{data:B}=await r(v,R);return function(e){const{barriers:r,checksum:t,directionLines:s,directionPoints:o,directions:a,messages:n,polygonBarriers:u,polylineBarriers:c,routes:l,stops:f,traversedEdges:p,traversedJunctions:y,traversedTurns:m}=e,d=e=>{const r=h.find(r=>r.routeName===e);if(null!=r)return r;const t={routeId:h.length+1,routeName:e};return h.push(t),t},g=e=>{const r=h.find(r=>r.routeId===e);if(null!=r)return r;const t={routeId:e,routeName:null};return h.push(t),t},h=[];l?.features.forEach((e,r)=>{e.geometry.spatialReference=l.spatialReference??void 0;const t=e.attributes.Name,s=r+1;h.push({routeId:s,routeName:t,route:e})}),a?.forEach(e=>{const{routeName:r}=e;d(r).directions=e});const R=f?.features.every(e=>null==e.attributes.RouteName)&&h.length>0?h[0].routeName:null;return f?.features.forEach(e=>{e.geometry&&(e.geometry.spatialReference??=f.spatialReference??void 0);const r=R??e.attributes.RouteName,t=d(r);t.stops??=[],t.stops.push(e)}),s?.features.forEach(e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:o,spatialReference:a}=s;t.directionLines??={features:[],geometryType:o,spatialReference:a},t.directionLines.features.push(e)}),o?.features.forEach(e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:s,spatialReference:a}=o;t.directionPoints??={features:[],geometryType:s,spatialReference:a},t.directionPoints.features.push(e)}),p?.features.forEach(e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:s,spatialReference:o}=p;t.traversedEdges??={features:[],geometryType:s,spatialReference:o},t.traversedEdges.features.push(e)}),y?.features.forEach(e=>{const r=e.attributes.RouteID,t=g(r),{geometryType:s,spatialReference:o}=y;t.traversedJunctions??={features:[],geometryType:s,spatialReference:o},t.traversedJunctions.features.push(e)}),m?.features.forEach(e=>{const r=e.attributes.RouteID,t=g(r);t.traversedTurns??={features:[]},t.traversedTurns.features.push(e)}),i.fromJSON({barriers:r,checksum:t,messages:n,polygonBarriers:u,polylineBarriers:c,routeResults:h})}(B)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});