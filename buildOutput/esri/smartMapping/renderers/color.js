// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/colorUtils","../../core/Error","../../core/lang","../../core/accessorSupport/ensureType","../../intl/messages","../../renderers/ClassBreaksRenderer","../../renderers/PointCloudRGBRenderer","../../renderers/PointCloudStretchRenderer","../../renderers/support/AuthoringInfo","../../renderers/support/AuthoringInfoVisualVariable","../../renderers/support/utils","../../renderers/visualVariables/ColorVariable","../../renderers/visualVariables/support/ColorStop","../../renderers/visualVariables/support/VisualVariableLegendOptions","../heuristics/ageUnit","../heuristics/outline","../heuristics/sizeRange","./support/regenerateUtils","./support/utils","../statistics/support/ageUtils","../support/binningUtils","../support/utils","../support/adapters/support/layerUtils","../symbology/color","../symbology/support/utils"],function(e,a,i,r,l,n,o,t,s,c,u,d,m,p,y,f,g,b,h,v,w,T,V,S,z,x){"use strict";const E=2**53-1;async function I(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&T.verifyBinningParams(e,"color-visual-variable");const a={...e},r=e.forBinning?S.binningCapableLayerTypes:S.featureCapableLayerTypes,l=S.createLayerAdapter(a.layer,r,e.forBinning);if(!l)throw new i("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+S.getLayerTypeLabels(r).join(", "));const n=null!=a.signal?{signal:a.signal}:null;if(await l.load(n),"mesh"!==l.geometryType&&a.worldScale&&(!a.view||"3d"!==a.view.type))throw new i("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const o=await V.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),t=v.verifyBasicFieldValidity(l,o,"color-visual-variable:invalid-parameters");if(t)throw t;return{...a,layer:l}}async function C(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&T.verifyBinningParams(e,"color-continuous-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=e.forBinning?S.binningCapableLayerTypes:S.featureCapableLayerTypes,l=S.createLayerAdapter(a.layer,r,e.forBinning);if(!l)throw new i("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+S.getLayerTypeLabels(r).join(", "));const n=null!=a.signal?{signal:a.signal}:null;await l.load(n);const o=l.geometryType;if(a.outlineOptimizationEnabled="polygon"===o&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===o||"multipoint"===o||"polyline"===o)&&a.sizeOptimizationEnabled,"mesh"===o)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==o)throw new i("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await V.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),s=v.verifyBasicFieldValidity(l,t,"color-continuous-renderer:invalid-parameters");if(s)throw s;return{...a,layer:l}}async function M(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&T.verifyBinningParams(e,"color-class-breaks-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="equal-interval",a.normalizationType=V.getNormalizationType(a);const r=e.forBinning?S.binningCapableLayerTypes:S.featureCapableLayerTypes,l=S.createLayerAdapter(a.layer,r,e.forBinning);if(!l)throw new i("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+S.getLayerTypeLabels(r).join(", "));if(!(null!=a.minValue&&null!=a.maxValue||null==a.minValue&&null==a.maxValue))throw new i("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=a.signal?{signal:a.signal}:null;await l.load(n);const o=l.geometryType;if(a.outlineOptimizationEnabled="polygon"===o&&a.outlineOptimizationEnabled,"mesh"===o)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==o)throw new i("color-class-breaks-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const t=await V.getFieldsList({field:a.field,normalizationField:a.normalizationField}),s=v.verifyBasicFieldValidity(l,t,"color-class-breaks-renderer:invalid-parameters");if(s)throw s;return{...a,layer:l}}function B(e){const a={...e};delete a.basemap,delete a.colorScheme,delete a.legendOptions,delete a.symbolType,delete a.defaultSymbolEnabled,delete a.colorMixMode,delete a.edgesType;const i=a;return i.analyzeData=!(null!=a.minValue&&null!=a.maxValue),i}function F(e){const a={...e},i=!!a.symbolType?.includes("3d-volumetric");delete a.symbolType,delete a.defaultSymbolEnabled,delete a.colorMixMode,delete a.edgesType;const r=a;return r.worldScale=i,r}async function O(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=S.createLayerAdapter(a.layer,S.featureCapableLayerTypes);if(!r)throw new i("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+S.getLayerTypeLabels(S.featureCapableLayerTypes).join(", "));const l=null!=a.signal?{signal:a.signal}:null;await r.load(l);const n=r.geometryType;if(a.outlineOptimizationEnabled="polygon"===n&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&a.sizeOptimizationEnabled,"mesh"===n)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else if("3d-volumetric-uniform"===a.symbolType&&"point"!==n)throw new i("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const o=w.verifyDates(r,a.startTime,a.endTime,"color-age-renderer:invalid-parameters");if(o)throw o;if(a.unit&&!w.supportedAgeUnits.includes(a.unit))throw new i("color-age-renderer:invalid-unit",`Supported units are: ${w.supportedAgeUnits.join(", ")}`);return{...a,layer:r}}async function k(e,a){let i=e.colorScheme,r=null,l=null;const{view:n}=e,o=await v.getBasemapInfo(e.basemap,n);if(r=null!=o.basemapId?o.basemapId:null,l=null!=o.basemapTheme?o.basemapTheme:null,i)return{scheme:z.cloneScheme(i),basemapId:r,basemapTheme:l};const t=e.theme||"high-to-low",s=z.getSchemes({theme:t,basemapTheme:l,geometryType:e.geometryType,worldScale:e.worldScale,view:n});if(s)if(r=s.basemapId,l=s.basemapTheme,e.schemeId){const a=t+"/"+r+"/"+e.schemeId;i=z.getSchemeById({id:a,geometryType:e.geometryType})}else i=s.primaryScheme;return{scheme:i,basemapId:r,basemapTheme:l}}function R(e,a,i,r){const l=v.getDataRange(e,a,i,!0);return{values:v.createDataValues(l,e,a,r),defaultValuesUsed:l.defaultValuesUsed}}async function L(e,a,i,r,l,t,s){const c=await n.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),{field:u,defaultSymbolEnabled:d}=s,m=z.cloneScheme(e.colorScheme),p=a?.opacity,y=[e.visualVariable.clone()];return a?.visualVariables?.length&&y.push(...a.visualVariables.map(e=>e.clone())),i?.minSize&&y.push(i.minSize),{renderer:new o({classBreakInfos:[{minValue:-E,maxValue:E,symbol:v.createSymbol(t,{type:s.symbolType,color:m.noDataColor,size:v.getSymbolSizeFromScheme(m,t),outline:v.getSymbolOutlineFromScheme(m,t,p),meshInfo:{colorMixMode:s.colorMixMode,edgesType:s.edgesType}})}],defaultLabel:d?c.other:null,defaultSymbol:d?v.createSymbol(t,{type:s.symbolType,color:m.noDataColor,size:v.getSymbolSizeFromScheme(m,t),outline:v.getSymbolOutlineFromScheme(m,t,p),meshInfo:{colorMixMode:s.colorMixMode,edgesType:s.edgesType}}):null,field:u,normalizationType:r,normalizationField:l,valueExpression:s.valueExpression,valueExpressionTitle:s.valueExpressionTitle,visualVariables:y,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:z.cloneScheme(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function P(e){const r=await I(e),{view:n,field:o,valueExpression:t,minValue:s,maxValue:d,layer:f,normalizationField:g,signal:b,filter:h,statistics:w}=r,T=g?"field":void 0,S=await(w??v.getSummaryStatistics({layer:f,field:o,valueExpression:t,sqlExpression:r.sqlExpression,sqlWhere:r.sqlWhere,normalizationType:T,normalizationField:g,minValue:s,maxValue:d,filter:h,view:n,signal:b})),x=f,E=o&&"function"!=typeof o?x.getField(o):null;return async function(e,r,n,o){const{field:t,theme:s}=e,d=await k({basemap:e.basemap,theme:e.theme,geometryType:n,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),f=d.scheme;if(!f)throw new i("color-visual-variable:insufficient-info","Unable to find color scheme");const g=a.createUniqueColors(f.colors,5);if(g.length<5)throw new i("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const b=f.id.includes("seq-"),{values:h,defaultValuesUsed:v}=R(r,s,o,b),w=a.createUniqueColors(g,5),T=new m({field:t??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:h.map((e,a)=>new p({value:e,color:w[a]})),legendOptions:l.ensureClass(y,e.legendOptions)}),V=new u({type:"color",minSliderValue:null!=e.minValue?e.minValue:r.min,maxSliderValue:null!=e.maxValue?e.maxValue:r.max,theme:f.theme}),S=new c({visualVariables:[V]});return{basemapId:d.basemapId,basemapTheme:d.basemapTheme,visualVariable:T,statistics:r,defaultValuesUsed:v,colorScheme:z.cloneScheme(f),authoringInfo:S}}(r,S,x.geometryType,V.isAnyDateField(E))}async function U(e){const{view:r,filter:l,creatorParameters:n,renderer:o,signal:t}=await async function(e){const a="regenerate-color-visual-variable";await h.processRegenerateParams(e,a);const r=await h.getRendererToUpdate(e);if("class-breaks"!==r?.type)throw new i(`${a}:invalid-parameters`,"Renderer must be a ClassBreaksRenderer to regenerate a color visual variable");const l=r.authoringInfo,n=l?.visualVariables.find(e=>"color"===e.type),o=r.visualVariables?.find(e=>"color"===e.type);if(!o)throw new i(`${a}:invalid-parameters`,"Renderer does not have a color visual variable");const{field:t,normalizationField:s,valueExpression:c,valueExpressionTitle:u}=o,d="univariate-color-size"===l?.type?l?.univariateTheme:n?.theme,{layer:m,forBinning:p,filter:y,view:f,signal:g}=e,b=await I({layer:m,field:t,valueExpression:c,valueExpressionTitle:u,normalizationField:s,theme:d,forBinning:p,filter:y,view:f,signal:g});return{...e,creatorParameters:b,renderer:r}}(e),s=o.authoringInfo?.clone(),c=s?.visualVariables.find(e=>"color"===e.type),u=o.visualVariables?.find(e=>"color"===e.type),{field:d,normalizationField:m,valueExpression:y,theme:f,layer:g}=n,b=await v.getSummaryStatistics({layer:g,field:d,valueExpression:y,normalizationField:m,filter:l,view:r,signal:t}),w=d&&"function"!=typeof d?g.getField(d):null,{values:T}=R(b,f,V.isAnyDateField(w),"high-to-low"===f);if(T.length===u.stops.length)u.stops.forEach((e,a)=>e.value=T[a]);else{const e=u.stops.map(e=>e.color),i=a.createUniqueColors(e,5);u.stops=T.map((e,a)=>new p({value:e,color:i[a]}))}return c&&(c.minSliderValue=b.min,c.maxSliderValue=b.max),{visualVariable:u,authoringInfo:s,statistics:b}}async function q(e,l){const t=await n.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),s=e.layer,u=e.defaultSymbolEnabled,m=s.geometryType,p=e.classificationMethod,y="standard-deviation"===p,f=await k({basemap:e.basemap,geometryType:m,theme:y?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),g=f.scheme,{result:b,outlineResult:h}=l,w=b.classBreakInfos,T=e.normalizationType;if(!g)throw new i("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const V=function(e,i){const l=e.colorsForClassBreaks;if(l?.length)for(const e of l)if(e.numClasses===i)return r.clone(e.colors);return a.createUniqueColors(e.colors,i)}(g,w.length);if(!V||V.length!==w.length)throw new i("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const S=h?.opacity,x=new o({classBreakInfos:w.map((a,i)=>({minValue:a.minValue,maxValue:a.maxValue,symbol:v.createSymbol(m,{type:e.symbolType,color:V[i],size:v.getSymbolSizeFromScheme(g,m),outline:v.getSymbolOutlineFromScheme(g,m,S),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:a.label})),defaultLabel:u?t.other:null,defaultSymbol:u?v.createSymbol(m,{type:e.symbolType,color:g.noDataColor,size:v.getSymbolSizeFromScheme(g,m),outline:v.getSymbolOutlineFromScheme(g,m,S),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:T,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===T?b.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new c({type:"class-breaks-color",classificationMethod:p,standardDeviationInterval:e.standardDeviationInterval})});return y||d.setLabelsForClassBreaks({classBreakInfos:x.classBreakInfos,classificationMethod:p,normalizationType:T,round:!0}),h?.visualVariables?.length&&(x.visualVariables=h.visualVariables.map(e=>e.clone())),{renderer:x,colorScheme:z.cloneScheme(g),classBreaksResult:b,defaultValuesUsed:l.defaultValuesUsed,basemapId:f.basemapId,basemapTheme:f.basemapTheme}}e.createAgeRenderer=async function(e){const a=await O(e),{defaultSymbolEnabled:i,view:r,startTime:l,endTime:n,symbolType:o,colorMixMode:t,edgesType:s,minValue:c,maxValue:u,signal:d,filter:m}=a,p=a.layer,[y,h,w]=await Promise.all([a.unit?{unit:a.unit,statistics:null}:f({view:r,layer:p,startTime:l,endTime:n,minValue:c,maxValue:u,signal:d,filter:m}),a.outlineOptimizationEnabled?g({layer:p,view:r,signal:d,filter:m}).catch(v.errorCallback):null,a.sizeOptimizationEnabled?b({layer:p,view:r,signal:d,filter:m}).catch(v.errorCallback):null]),{unit:T,statistics:V}=y,{valueExpression:S,title:z}=await v.getTitleAndExpressionForAgeRenderer(a,T),x=await P(F({layer:p,basemap:a.basemap,valueExpression:S,symbolType:o,statistics:V,legendOptions:{title:z},colorScheme:a.colorScheme,theme:a.theme,view:r,minValue:a.minValue,maxValue:a.maxValue,filter:m,signal:d})),E={valueExpression:S,defaultSymbolEnabled:i,symbolType:o,colorMixMode:t,edgesType:s},I=await L(x,h,w,null,null,p.geometryType,E),C=I.renderer.authoringInfo?.visualVariables;return C?.forEach(e=>v.updateAgeRendererAuthoringInfoVV(e,l,n,T)),{...I,unit:T}},e.createClassBreaksRenderer=async function(e){const a=await M(e);return q(a,await v.getClassBreaks(B(a),a.outlineOptimizationEnabled))},e.createContinuousRenderer=async function(e){const a=await C(e),{layer:i,view:r,signal:l,filter:n}=a,[o,t,s]=await Promise.all([P(F(a)),a.outlineOptimizationEnabled?g({layer:i,view:r,signal:l,filter:n}).catch(v.errorCallback):null,a.sizeOptimizationEnabled?b({layer:i,view:r,signal:l,filter:n}).catch(v.errorCallback):null]),c=a.normalizationField;return L(o,t,s,c?"field":void 0,c,i.geometryType,a)},e.createPCContinuousRenderer=async function(e){const r=await async function(e){if(!e?.layer||!e.field)throw new i("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const a=e.field.toLowerCase();if("intensity"!==a&&"elevation"!==a)throw new i("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const r={...e,layer:e.layer,field:e.field},l=[10],n=S.createLayerAdapter(r.layer,l);if(!n)throw new i("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+S.getLayerTypeLabels(l).join(", "));if(r.layer=n,r.density=r.density||25,r.size=r.size||"100%",!v.isValidPointSize(r.size))throw new i("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const o=null!=r.signal?{signal:r.signal}:null;return await n.load(o),r}(e),l=r.statistics??await v.getSummaryStatistics({layer:r.layer,field:r.field,signal:r.signal}),n=await async function(e,r){const l=r.layer,n=await k({basemap:r.basemap,colorScheme:r.colorScheme,geometryType:l.geometryType,schemeId:"elevation"===r.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),o=n.scheme;if(!o)throw new i("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const t=a.createUniqueColors(o.colors,5);if(t.length<5)throw new i("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const s=v.getDefaultDataRange(e,!1,!0),c=s?v.createDefaultStopValues(s[0],s[1],5):v.createStopValues(e);return{stops:d.createColorStops({values:c,isDate:!1,colors:t,labelIndexes:[0,2,4]}),basemapId:n.basemapId,basemapTheme:n.basemapTheme,statistics:e,defaultValuesUsed:!!s,colorScheme:z.cloneScheme(o)}}(l,r);return{renderer:new s({field:r.field,pointsPerInch:r.density??void 0,pointSizeAlgorithm:v.getPointSizeAlgorithm(r.size),stops:n.stops}),basemapId:n.basemapId,basemapTheme:n.basemapTheme,statistics:n.statistics,defaultValuesUsed:n.defaultValuesUsed,colorScheme:n.colorScheme}},e.createPCTrueColorRenderer=function(e){return async function(e){if(!e?.layer)throw new i("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const a={...e,layer:e.layer},r=[10],l=S.createLayerAdapter(a.layer,r);if(!l)throw new i("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+S.getLayerTypeLabels(r).join(", "));if(a.layer=l,a.density=a.density||25,a.size=a.size||"100%",!v.isValidPointSize(a.size))throw new i("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=a.signal?{signal:a.signal}:null;return await l.load(n),a}(e).then(e=>({renderer:new t({field:"RGB",pointsPerInch:e.density??void 0,pointSizeAlgorithm:v.getPointSizeAlgorithm(e.size)})}))},e.createVisualVariable=P,e.regenerateAgeRenderer=async function(e){const{renderer:a,creatorParameters:r}=await async function(e){const a="regenerate-color-age-renderer";await h.processRegenerateParams(e,a);const r=await h.getRendererToUpdate(e);if("color-age"!==h.getStyleType(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:l}=r,n=l?.visualVariables.find(e=>"color"===e.type),o=n.startTime,t=n.endTime,s=n.units,c=n.theme,{layer:u,filter:d,view:m,signal:p}=e,y=h.hasOutlineVV(r),f=h.hasScaleDependentSizeVV(r),g=await O({layer:u,startTime:o,endTime:t,unit:s,theme:c,outlineOptimizationEnabled:y,sizeOptimizationEnabled:f,filter:d,view:m,signal:p});return{...e,creatorParameters:g,renderer:r}}(e),{layer:l,outlineOptimizationEnabled:n,sizeOptimizationEnabled:o,startTime:t,endTime:s,theme:c,view:u,signal:d,filter:m}=r,[p,y,w]=await Promise.all([f({view:u,layer:l,startTime:t,endTime:s,signal:d,filter:m}),n?g({layer:l,view:u,signal:d,filter:m}).catch(v.errorCallback):null,o?b({layer:l,view:u,signal:d,filter:m}).catch(v.errorCallback):null]),{unit:T,statistics:V}=p,{valueExpression:S,title:z}=await v.getTitleAndExpressionForAgeRenderer(r,T),x=await P(F({layer:l,valueExpression:S,statistics:V,legendOptions:{title:z},theme:c,view:u,filter:m,signal:d}));h.spliceVisualVariables(a,x.visualVariable,h.findColorVVIndex),h.spliceVisualVariables(a,y?.visualVariables,h.findOutlineVVIndex),h.spliceVisualVariables(a,w?.minSize,h.findScaleDependentSizeVVIndex),a.authoringInfo=x.authoringInfo.clone();const E=a.authoringInfo?.visualVariables;return E?.forEach(e=>v.updateAgeRendererAuthoringInfoVV(e,t,s,T)),{renderer:a}},e.regenerateClassBreaksRenderer=async function(e){const{renderer:a,creatorParameters:r}=await async function(e){const a="regenerate-color-class-breaks-renderer";await h.processRegenerateParams(e,a);const r=await h.getRendererToUpdate(e);if("color-class-breaks"!==h.getStyleType(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:l,field:n,normalizationField:o,normalizationType:t,normalizationTotal:s,valueExpression:c,valueExpressionTitle:u}=r,{classificationMethod:d,standardDeviationInterval:m}=l,p=r.classBreakInfos.length,{layer:y,forBinning:f,filter:g,view:b,signal:v}=e,w=h.hasOutlineVV(r),T=await M({layer:y,field:n,valueExpression:c,valueExpressionTitle:u,normalizationType:t,normalizationField:o,normalizationTotal:s,classificationMethod:d,standardDeviationInterval:m,numClasses:p,outlineOptimizationEnabled:w,defaultSymbolEnabled:!!r.defaultSymbol,forBinning:f,filter:g,view:b,signal:v});return{...e,creatorParameters:T,renderer:r}}(e),{normalizationType:l,outlineOptimizationEnabled:n,classificationMethod:o}=r;if("manual"===o)return{renderer:a};const t=await v.getClassBreaks(B(r),n),s=t.result.classBreakInfos;if(r.numClasses!==s.length){const e=function(e,a){const i=x.getColorSchemeDefinition(e);return z.createScheme({geometryType:a},void 0,i.commonProps,i.colorRampInfo)}(a.classBreakInfos.map(e=>e.symbol),r.layer.geometryType);return{renderer:(await q({...r,colorScheme:e},t)).renderer}}return a.classBreakInfos.forEach((e,a)=>{e.minValue=s[a].minValue,e.maxValue=s[a].maxValue,e.label=s[a].label}),a.normalizationTotal="percent-of-total"===l?t.result.normalizationTotal:void 0,"standard-deviation"!==o&&d.setLabelsForClassBreaks({classBreakInfos:a.classBreakInfos,classificationMethod:o,normalizationType:l,round:!0}),h.spliceVisualVariables(a,t.outlineResult?.visualVariables,h.findOutlineVVIndex),{renderer:a}},e.regenerateContinuousRenderer=async function(e){const{renderer:a,view:r,signal:l,filter:n,creatorParameters:o}=await async function(e){const a="regenerate-color-continuous-renderer";await h.processRegenerateParams(e,a);const r=await h.getRendererToUpdate(e),l=h.getStyleType(r);if(!l||!["color-continuous","color-size"].includes(l))throw new i(`${a}:invalid-renderer`,"Renderer is invalid");const{authoringInfo:n,field:o,normalizationField:t,valueExpression:s,valueExpressionTitle:c}=r,u=n?.visualVariables.find(e=>"color"===e.type),d=u?.theme,{layer:m,forBinning:p,filter:y,view:f,signal:g}=e,b=h.hasOutlineVV(r),v=h.hasScaleDependentSizeVV(r),w=await C({layer:m,field:o,valueExpression:s,valueExpressionTitle:c,normalizationField:t,theme:d,outlineOptimizationEnabled:b,sizeOptimizationEnabled:v,forBinning:p,filter:y,view:f,signal:g});return{...e,creatorParameters:w,renderer:r}}(e),{layer:t,outlineOptimizationEnabled:s,sizeOptimizationEnabled:c}=o,[u,d,m]=await Promise.all([U(e),s?g({layer:t,view:r,signal:l,filter:n}).catch(v.errorCallback):null,c?b({layer:t,view:r,signal:l,filter:n}).catch(v.errorCallback):null]);return h.spliceVisualVariables(a,u.visualVariable,h.findColorVVIndex),h.spliceVisualVariables(a,d?.visualVariables,h.findOutlineVVIndex),h.spliceVisualVariables(a,m?.minSize,h.findScaleDependentSizeVVIndex),h.updateAuthoringInfoVisualVariable(a,u.authoringInfo,"color"),{renderer:a}},e.regenerateVisualVariable=U,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});