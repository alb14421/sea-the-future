// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/colorUtils","../../core/Error","../../core/lang","../../intl/messages","../../renderers/support/AuthoringInfo","../../renderers/support/AuthoringInfoClassBreakInfo","../../renderers/support/AuthoringInfoFieldInfo","../heuristics/outline","../heuristics/sizeRange","./type","./support/regenerateUtils","./support/utils","../support/binningUtils","../support/adapters/support/layerUtils","../symbology/relationship","../../symbols/support/utils"],function(e,a,n,i,l,r,s,o,t,d,u,f,m,c,p,h,y){"use strict";const b=new Set(["equal-interval","natural-breaks","quantile"]),g=new Set(["HH","HL","LH","LL"]),w={2:[["HL","HH"],["LL","LH"]],3:[["HL","HM","HH"],["ML","MM","MH"],["LL","LM","LH"]],4:[["HL","HM1","HM2","HH"],["M2L","M2M1","M2M2","M2H"],["M1L","M1M1","M1M2","M1H"],["LL","LM1","LM2","LH"]]},v={2:["L","H"],3:["L","M","H"],4:["L","M1","M2","H"]},I=e=>({minValue:e.minValue,maxValue:e.maxValue});async function z(e){if(!(e?.layer&&e.view&&e.field1&&e.field2))throw new n("relationship-renderer:missing-parameters","'layer', 'view', 'field1' and 'field2' parameters are required");e.forBinning&&c.verifyBinningParams(e,"relationship-renderer");const a={...e,layer:e.layer,field1:e.field1,field2:e.field2};if(a.symbolType??="2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="quantile",a.numClasses??=3,a.focus??=null,!b.has(a.classificationMethod))throw new n("relationship-renderer:invalid-parameters",`classification method ${a.classificationMethod} is not supported`);if(a.numClasses<2||a.numClasses>4)throw new n("relationship-renderer:invalid-parameters","'numClasses' must be 2, 3 or 4");if(e.focus&&!g.has(e.focus))throw new n("relationship-renderer:invalid-parameters","'focus' must be 'HH', 'HL', 'LH', 'LL' or null");const i=e.forBinning?p.binningCapableLayerTypes:p.featureCapableLayerTypes,l=p.createLayerAdapter(a.layer,i,e.forBinning);if(!l)throw new n("relationship-renderer:invalid-parameters","'layer' must be one of these types: "+p.getLayerTypeLabels(i).join(", "));const r=null!=a.signal?{signal:a.signal}:null;await l.load(r);const s=l.geometryType,o=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===s&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===s||"multipoint"===s||"polyline"===s)&&a.sizeOptimizationEnabled,"mesh"===s)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==s)throw new n("relationship-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o&&"polygon"===s)throw new n("relationship-renderer:not-supported","3d symbols are not supported for polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new n("relationship-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const{field1:t,field2:d}=a,u=[t.field,d.field];t.normalizationField&&u.push(t.normalizationField),d.normalizationField&&u.push(d.normalizationField);const f=m.verifyBasicFieldValidity(l,u,"relationship-renderer:invalid-parameters");if(f)throw f;return{...a,layer:l}}function V(e,a){const n=i.clone(w[e]);return h.flatten2DArray(n,a)}function M(e,a,n,i){const{field:l,normalizationField:r}=e,{field:s,normalizationField:o}=a,t=n.map(e=>[e.minValue,e.maxValue]),d=i.map(e=>[e.minValue,e.maxValue]),u=t.length,f=v[u];return`\n  var field1 = $feature['${l}'];\n  var field2 = $feature['${s}'];\n  var hasNormField1 = ${r?"true":"false"};\n  var hasNormField2 = ${o?"true":"false"};\n  var normField1 = ${r?`$feature['${r}']`:"null"};\n  var normField2 = ${o?`$feature['${o}']`:"null"};\n\n  if (\n    IsEmpty(field1) ||\n    IsEmpty(field2) ||\n    (hasNormField1 && (IsEmpty(normField1) || normField1 == 0)) ||\n    (hasNormField2 && (IsEmpty(normField2) || normField2 == 0))\n  ) {\n    return null;\n  }\n\n  var value1 = IIf(hasNormField1, (field1 / normField1), field1);\n  var value2 = IIf(hasNormField2, (field2 / normField2), field2);\n\n  var breaks1 = ${JSON.stringify(t)};\n  var breaks2 = ${JSON.stringify(d)};\n  var classCodes = ${JSON.stringify(f)};\n\n  function getClassCode(value, breaks) {\n    var code = null;\n\n    for (var i in breaks) {\n      var info = breaks[i];\n      if (value >= info[0] && value <= info[1]) {\n        code = classCodes[i];\n        break;\n      }\n    }\n\n    return code;\n  }\n\n  var code1 = getClassCode(value1, breaks1);\n  var code2 = getClassCode(value2, breaks2);\n\n  var classValue = IIf(IsEmpty(code1) || IsEmpty(code2), null, code1 + code2);\n  return classValue;\n  `}async function F(e){const{layer:a,classificationMethod:i,field1:l,field2:r,numClasses:s,filter:o,view:t,signal:d}=e,u={layer:a,classificationMethod:i,field:l.field,normalizationField:l.normalizationField,normalizationType:l.normalizationField?"field":null,minValue:l.minValue,maxValue:l.maxValue,analyzeData:!(null!=l.minValue&&null!=l.maxValue),numClasses:s,filter:o,view:t,signal:d},f={layer:a,classificationMethod:i,field:r.field,normalizationField:r.normalizationField,normalizationType:r.normalizationField?"field":null,minValue:r.minValue,maxValue:r.maxValue,analyzeData:!(null!=r.minValue&&null!=r.maxValue),numClasses:s,filter:o,view:t,signal:d},[c,p]=await Promise.all([m.getClassBreaks(u),m.getClassBreaks(f)]);if(!c||!p)throw new n("relationship-renderer:error","error when calculating class breaks");return{field1:c.result,field2:p.result}}async function C(e){const i=await async function(e){if(!e?.renderer||!e.numClasses)throw new n("update-relationship-renderer:missing-parameters","'renderer' and 'numClasses' parameters are required");const{field1:a,field2:i,renderer:l,numClasses:r,colors:s}=e,o=r**2;if((a||i)&&!(a&&i&&a.field&&i.field))throw new n("update-relationship-renderer:missing-parameters","'field1' and 'field2' parameters are required");if(a&&!a.classBreakInfos||i&&!i.classBreakInfos)throw new n("update-relationship-renderer:missing-parameters","'field1.classBreakInfos' and 'field2.classBreakInfos' are required");if(!l.authoringInfo)throw new n("update-relationship-renderer:missing-parameters","'renderer.authoringInfo' is required");if(l.uniqueValueInfos?.length!==o)throw new n("update-relationship-renderer:invalid-parameters",`Renderer must have ${o} unique value infos to support ${r} classes`);if(s&&s.length!==o)throw new n("update-relationship-renderer:invalid-parameters",`The scheme must have ${o} colors`);return e}(e),{field1:l,field2:t,renderer:d,numClasses:u,focus:f,colors:m}=i,c=d.clone();c.valueExpression=M(l,t,l.classBreakInfos,t.classBreakInfos);const p=c.uniqueValueInfos??[];if(function(e,a,n){const i=V(a,n);e.sort((e,a)=>{const n=i.indexOf(e.value),l=i.indexOf(a.value);let r=0;return n<l?r=-1:n>l&&(r=1),r})}(p,u,f),m){const e=a.createUniqueColors(m,m.length);p.forEach((a,n)=>y.applyColorToSymbol(a.symbol,e[n]))}return function(e,a){e.authoringInfo??=new r;const n=e.authoringInfo;n.numClasses=a.numClasses,n.focus=a.focus||null,n.focus||delete n.focus;const{field1:i,field2:l}=a;n.field1=new o.AuthoringInfoFieldInfo({field:i.field,normalizationField:i.normalizationField,label:i.label,classBreakInfos:i.classBreakInfos.map(e=>new s.AuthoringInfoClassBreakInfo(I(e)))}),n.field2=new o.AuthoringInfoFieldInfo({field:l.field,normalizationField:l.normalizationField,label:l.label,classBreakInfos:l.classBreakInfos.map(e=>new s.AuthoringInfoClassBreakInfo(I(e)))}),e.authoringInfo=n}(c,i),c}e.createRenderer=async function(e){const a=await z(e),{field1:i,field2:t}=await F(a);return async function(e,a,i){const t=await l.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),{basemap:d,classificationMethod:f,field1:c,field2:p,focus:y,numClasses:b,signal:g}=e,w=e.layer,v=a.classBreakInfos,I=i.classBreakInfos;if(b!==v.length||v.length!==I.length)throw new n("relationship-renderer:error","incompatible class breaks");const z=function(e,a){return V(e,a).map(e=>({value:e,count:0}))}(b,y),F=M(e.field1,e.field2,v,I),C=(await async function(e){let a=e.relationshipScheme,n=null,i=null;const l=await m.getBasemapInfo(e.basemap,e.view);if(n=null!=l.basemapId?l.basemapId:null,i=null!=l.basemapTheme?l.basemapTheme:null,a)return{scheme:h.cloneScheme(a),basemapId:n,basemapTheme:i};const r=h.getSchemes({basemapTheme:i,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return r&&(a=r.primaryScheme,n=r.basemapId,i=r.basemapTheme),{scheme:a,basemapId:n,basemapTheme:i}}({basemap:d,geometryType:w.geometryType,theme:"default",relationshipScheme:e.relationshipScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view})).scheme,k=await u.createRenderer({layer:w,basemap:d,valueExpression:F,valueExpressionTitle:t.relationship.legendTitle,numTypes:-1,sortEnabled:!1,defaultSymbolEnabled:e.defaultSymbolEnabled,typeScheme:{colors:h.getColors(C,b,y),...C},statistics:{uniqueValueInfos:z},legendOptions:e.legendOptions,outlineOptimizationEnabled:e.outlineOptimizationEnabled,sizeOptimizationEnabled:e.sizeOptimizationEnabled,symbolType:e.symbolType,colorMixMode:e.colorMixMode,edgesType:e.edgesType,filter:e.filter,view:e.view,signal:g}),T=k.renderer,B=T.uniqueValueInfos,L=t.relationship;for(const e of B??[])e.label=L[e.value];const H=new r({type:"relationship",classificationMethod:f,numClasses:b,focus:y,field1:new o.AuthoringInfoFieldInfo({field:c.field,normalizationField:c.normalizationField,label:c.label,classBreakInfos:v.map(({minValue:e,maxValue:a})=>new s.AuthoringInfoClassBreakInfo({minValue:e,maxValue:a}))}),field2:new o.AuthoringInfoFieldInfo({field:p.field,normalizationField:p.normalizationField,label:p.label,classBreakInfos:I.map(({minValue:e,maxValue:a})=>new s.AuthoringInfoClassBreakInfo({minValue:e,maxValue:a}))})});return T.authoringInfo=H,{renderer:T,classBreaks:{field1:a,field2:i},uniqueValueInfos:k.uniqueValueInfos,relationshipScheme:C,basemapId:k.basemapId,basemapTheme:k.basemapTheme}}(a,i,t)},e.regenerateRenderer=async function(e){const{creatorParameters:a,view:i,signal:l,filter:r,renderer:s}=await async function(e){const a="regenerate-relationship-renderer";await f.processRegenerateParams(e,a);const i=await f.getRendererToUpdate(e),l=f.getStyleType(i);if(!l||!["relationship","relationship-size"].includes(l))throw new n(`${a}:invalid-parameters`,"Renderer is invalid");const{layer:r,forBinning:s,filter:o,view:t,signal:d}=e,u=f.hasOutlineVV(i),m=f.hasScaleDependentSizeVV(i),{field1:c,field2:p,classificationMethod:h,focus:y,numClasses:b}=i.authoringInfo,g={field:c.field,normalizationField:c.normalizationField,label:c.label},w={field:p.field,normalizationField:p.normalizationField,label:p.label},v=await z({layer:r,field1:g,field2:w,classificationMethod:h,numClasses:b,focus:y,outlineOptimizationEnabled:u,sizeOptimizationEnabled:m,forBinning:s,filter:o,view:t,signal:d});return{...e,creatorParameters:v,renderer:i}}(e),{layer:o,field1:u,field2:c,numClasses:p,focus:h,outlineOptimizationEnabled:y,sizeOptimizationEnabled:b}=a,{field1:g,field2:w}=await F(a),[v,I,V]=await Promise.all([C({field1:{...u,classBreakInfos:g.classBreakInfos},field2:{...c,classBreakInfos:w.classBreakInfos},renderer:s,numClasses:p,focus:h}),y?t({layer:o,view:i,signal:l,filter:r}).catch(m.errorCallback):null,b?d({layer:o,view:i,signal:l,filter:r}).catch(m.errorCallback):null]);return f.spliceVisualVariables(v,I?.visualVariables,f.findOutlineVVIndex),f.spliceVisualVariables(v,V?.minSize,f.findScaleDependentSizeVVIndex),{renderer:v}},e.updateRenderer=C,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});