// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/colorUtils","../../core/Error","../../core/lang","../../intl/messages","../../layers/support/fieldUtils","../../renderers/PointCloudUniqueValueRenderer","../../renderers/UniqueValueRenderer","../../renderers/support/RendererLegendOptions","../../renderers/support/utils","../../renderers/support/pointCloud/ColorUniqueValueInfo","../heuristics/outline","../heuristics/sizeRange","./support/regenerateUtils","./support/utils","../statistics/uniqueValues","../support/binningUtils","../support/utils","../support/adapters/support/layerUtils","../symbology/type"],function(e,l,i,n,a,t,r,s,o,u,d,p,c,m,y,f,b,g,v,h){"use strict";async function w(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new i("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&b.verifyBinningParams(e,"type-renderer");const l={...e,layer:e.layer};l.symbolType=l.symbolType||"2d",l.defaultSymbolEnabled??=!0,l.sortBy??="count",l.sortEnabled??=!0,l.statistics=n.clone(l.statistics);const a=null==l.numTypes?10:l.numTypes,t=e.forBinning?v.binningCapableLayerTypes:v.featureCapableLayerTypes,r=v.createLayerAdapter(l.layer,t,e.forBinning);if(!r)throw new i("type-renderer:invalid-parameters","'layer' must be one of these types: "+v.getLayerTypeLabels(t).join(", "));const s=null!=l.signal?{signal:l.signal}:null;await r.load(s);const o=r.geometryType;if(l.outlineOptimizationEnabled="polygon"===o&&l.outlineOptimizationEnabled,l.sizeOptimizationEnabled=("point"===o||"multipoint"===o||"polyline"===o)&&l.sizeOptimizationEnabled,"mesh"===o)l.symbolType="3d-volumetric",l.colorMixMode=l.colorMixMode||"replace",l.edgesType=l.edgesType||"none";else{if("3d-volumetric-uniform"===l.symbolType&&"point"!==o)throw new i("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(l.symbolType.includes("3d-volumetric")&&(!l.view||"3d"!==l.view.type))throw new i("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const u=await g.getFieldsList({field:l.field,field2:l.field2,field3:l.field3,valueExpression:l.valueExpression}),d=y.verifyBasicFieldValidity(r,u,"type-renderer:invalid-parameters");if(d)throw d;return{...l,layer:r,numTypes:a}}async function T(e){let l=e.typeScheme,i=null,n=null;const a=await y.getBasemapInfo(e.basemap,e.view);if(i=null!=a.basemapId?a.basemapId:null,n=null!=a.basemapTheme?a.basemapTheme:null,l)return{scheme:h.cloneScheme(l),basemapId:i,basemapTheme:n};const t=h.getSchemes({numColors:e.numColors,basemapTheme:n,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return t&&(l=t.primaryScheme,i=t.basemapId,n=t.basemapTheme),{scheme:l,basemapId:i,basemapTheme:n}}function V(e,l){let i;return i=e.label<l.label?-1:e.label>l.label?1:0,i}function S(e,l){let i;return i=e.value<l.value?-1:e.value>l.value?1:0,i}function z(e,l){let i=l.count-e.count;return 0===i&&(i=V(e,l)),i}function E(e,l){let i=l.count-e.count;return 0===i&&(i=S(e,l)),i}function I(e,l,i){let n;"count"===l?(n=E,i&&"codedValues"in i&&i.codedValues&&(n=z)):"value"===l&&(n=S,i&&"codedValues"in i&&i.codedValues&&(n=V)),n&&e.sort(n)}async function x(e,i){const n=e.uniqueValueInfos,a=await T({numColors:n.length,basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:i}),t=a?.scheme,r="point-cloud-class"===t?.theme,s=r?t.colors:l.createUniqueColors(t?.colors??[],n.length);return I(n,"value"),n.map((e,l)=>{const i=e.value;let n=null;return r?(n=s[i],n||(n=s[s.length-1])):n=s[l],new d({values:[i],color:n,label:e.label})})}e.createPCClassRenderer=async function(e){const l=await async function(e){if(!e?.layer||!e.field)throw new i("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const l={...e,layer:e.layer};l.statistics=n.clone(l.statistics);const a=[10],t=v.createLayerAdapter(l.layer,a);if(!t)throw new i("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+v.getLayerTypeLabels(a).join(", "));if(l.layer=t,l.density=l.density||25,l.size=l.size||"100%",!y.isValidPointSize(l.size))throw new i("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const r=null!=l.signal?{signal:l.signal}:null;await t.load(r);const s=await g.getFieldsList({field:l.field}),o=y.verifyBasicFieldValidity(t,s,"type-point-cloud-class-renderer:invalid-parameters");if(o)throw o;return l}(e),a=null!=l.statistics?l.statistics:await f({layer:l.layer,field:l.field,signal:l.signal});return{renderer:new r({field:l.field,pointsPerInch:l.density??void 0,pointSizeAlgorithm:y.getPointSizeAlgorithm(l.size),colorUniqueValueInfos:await x(a,l.typeScheme)})}},e.createRenderer=async function(e){const l=await w(e),{layer:i,view:n,signal:r,filter:d}=l,m={layer:i,field:l.field,field2:l.field2,field3:l.field3,valueExpression:l.valueExpression,returnAllCodedValues:l.returnAllCodedValues,view:n,filter:d,signal:r},[b,v,V]=await Promise.all([null!=l.statistics?l.statistics:f(m),l.outlineOptimizationEnabled?p({layer:i,view:n,signal:r,filter:d}).catch(y.errorCallback):null,l.sizeOptimizationEnabled?c({layer:i,view:n,signal:r,filter:d}).catch(y.errorCallback):null]);return async function(e,l,i,n){const r=await a.fetchMessageBundle("esri/smartMapping/t9n/smartMapping"),{field:d,field2:p,field3:c}=l,m=e.uniqueValueInfos,f=l.layer,b=d?f.getField(d):null,v=b?f.getFieldDomain(b.name):null,w=-1===l.numTypes?m.length:l.numTypes,V=f.geometryType,S=new s({field:d,field2:p,field3:c,fieldDelimiter:d&&p?g.fieldDelimiter:null}),z=[],E=[],x={value:null,domain:v,fieldInfo:b};m.forEach((e,l)=>{x.value=e.value,e.label=u.createUniqueValueLabel(x);const i=e.value;(null===i||"string"==typeof i&&i.toLowerCase().includes("<null>"))&&z.unshift(l)});for(const e of z)E.unshift(m.splice(e,1)[0]);!1!==l.sortEnabled&&I(m,l.sortBy,v),function(e,l,i){const{field:n,numTypes:a,layer:r,view:s}=l,o=n?r.getField(n):null;if(o&&(g.isAnyDateField(o)||t.isTimeOnlyField(o))){const l=i.filter((e,l)=>l<a).map(e=>e.value),n=t.isTimeOnlyField(o)?null:u.calculateDateFormatInterval(l),d=n?u.dateFormatIntervalOptions[n]:void 0;if(e.dateFormatOptions={fieldType:o.type,format:d},s){const l=r.layer;e.dateFormatOptions.timeZoneOptions={layerTimeZone:"preferredTimeZone"in l?l.preferredTimeZone:null,viewTimeZone:s.timeZone,datesInUnknownTimezone:"datesInUnknownTimezone"in l&&l.datesInUnknownTimezone}}}}(x,l,m);const M=i?.opacity,O=await T({numColors:m.length,basemap:l.basemap,geometryType:V,typeScheme:l.typeScheme,worldScale:!!l.symbolType?.includes("3d-volumetric"),view:l.view}),C=O.scheme,q=C.colors.map(e=>e.clone()),U=y.getSymbolSizeFromScheme(C,V),F=y.getSymbolOutlineFromScheme(C,V,M);m.forEach((e,i)=>{x.value=e.value,e.label=u.createUniqueValueLabel(x),e.symbol=y.createSymbol(V,{type:l.symbolType,color:q[i],size:U,outline:F,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})}),l.valueExpression&&(S.valueExpression=l.valueExpression,S.valueExpressionTitle=l.valueExpressionTitle),l.legendOptions&&(S.legendOptions=new o(l.legendOptions));for(let e=0;e<w;e++){const i=m[e];i&&S.addUniqueValueInfo({value:i.value,label:i.label,symbol:y.createSymbol(V,{type:l.symbolType,color:q[e].clone(),size:U,outline:F,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})})}l.defaultSymbolEnabled&&(S.defaultSymbol=y.createSymbol(V,{type:l.symbolType,color:C.noDataColor,size:U,outline:F,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}}),S.defaultLabel=r.other);for(const e of E)e.symbol=y.createSymbol(V,{type:l.symbolType,color:C.noDataColor,size:U,outline:F,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}}),m.push(e);const L=[],B=S.uniqueValueInfos?.length??0,P=B===m.length?-1:B;if(P>-1)for(let e=P;e<m.length;e++)L.push({...m[e]});return i?.visualVariables?.length&&(S.visualVariables=i.visualVariables.map(e=>e.clone())),n?.minSize&&(S.visualVariables?S.visualVariables.push(n.minSize):S.visualVariables=[n.minSize]),{renderer:S,uniqueValueInfos:m,excludedUniqueValueInfos:L,typeScheme:h.cloneScheme(C),basemapId:O.basemapId,basemapTheme:O.basemapTheme}}(b,l,v,V)},e.getTypeSchemeData=T,e.regenerateRenderer=async function(e){const{creatorParameters:l,view:n,signal:a,filter:t,renderer:r}=await async function(e){const l="regenerate-type-renderer";await m.processRegenerateParams(e,l);const n=await m.getRendererToUpdate(e),a=m.getStyleType(n);if(!a||!["type","type-size"].includes(a))throw new i(`${l}:invalid-parameters`,"Renderer is invalid");const{field:t,field2:r,field3:s,valueExpression:o,valueExpressionTitle:u}=n,d=n.uniqueValueInfos.length,{layer:p,forBinning:c,filter:y,view:f,signal:b}=e,g=m.hasOutlineVV(n),v=m.hasScaleDependentSizeVV(n),h=await w({layer:p,field:t,field2:r,field3:s,valueExpression:o,valueExpressionTitle:u,numTypes:d,outlineOptimizationEnabled:g,sizeOptimizationEnabled:v,forBinning:c,filter:y,view:f,signal:b});return{...e,creatorParameters:h,renderer:n}}(e),{layer:s,outlineOptimizationEnabled:o,sizeOptimizationEnabled:u}=l,[d,f]=await Promise.all([o?p({layer:s,view:n,signal:a,filter:t}).catch(y.errorCallback):null,u?c({layer:s,view:n,signal:a,filter:t}).catch(y.errorCallback):null]);return m.spliceVisualVariables(r,d?.visualVariables,m.findOutlineVVIndex),m.spliceVisualVariables(r,f?.minSize,m.findScaleDependentSizeVVIndex),{renderer:r}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});