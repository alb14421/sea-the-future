// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/Error","../../../../intl/date","../../../../layers/support/fieldUtils","../../../../rest/support/AttributeBinsQuery","../../../../rest/support/AutoIntervalBinParameters","../../../../rest/support/DateBinParameters","../../../../rest/support/FixedBoundariesBinParameters","../../../../rest/support/FixedIntervalBinParameters","../../../../rest/support/GenerateRendererParameters","../../../../rest/support/StatisticDefinition","../../../statistics/support/utils","../../utils","./utils","../../../../statistics/utils"],function(e,i,n,t,a,r,l,o,s,u,d,m,p,f,c){"use strict";const y="countOFExpr";function z(e,i,n){const a=e.valueExpression||e.sqlExpression,r=e.signal;if(!a){const{field:a,normalizationType:l,normalizationField:o}=e,s=a?i.getField(a):null,u=p.isAnyDateField(s)||t.isTimeOnlyField(s),d={field:a,normalizationType:l,normalizationField:o,normalizationTotal:n,layer:i};return{sqlExpression:u?f.getSQLExpressionForDateOrTimeField(i,s):f.getFieldExpr(d),sqlWhere:u?null:e.sqlWhere||m.getSQLFilterForNormalization({field:a,normalizationType:l,normalizationField:o}),filter:e.filter,signal:r}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,filter:e.filter,signal:r}}async function F(e,i,n){const{field:t,normalizationType:a,normalizationField:r,signal:l}=e,o=m.getSQLFilterForNormalization({field:t,normalizationType:a,normalizationField:r}),s=new u({classificationDefinition:c.createClassBreaksDefinition({field:t,normalizationType:a,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,definedInterval:e.definedInterval,breakCount:e.numBins||f.defaultNumBins}),where:m.mergeWhereClauses(o,n)});return i.generateRenderer(s,l).then(e=>{const{normalizationTotal:n,classBreaks:l}=e;return f.generateBinParams({field:t,normalizationType:a,normalizationField:r,normalizationTotal:n,classBreaks:l,where:o,layer:i})})}async function x(e,n,a,u,d){const{field:p,sqlExpression:c,normalizationField:y,classificationMethod:z,normalizationType:x}=e,v=p?n.getField(p):null,T=t.isTimeOnlyField(v),g=t.isDateOnlyField(v)||T,w=e.numBins||f.defaultNumBins;if(g){if(x||z)throw new i(`${n.adapterName}:not-supported`,"NormalizationType and classificationMethod are not supported for date-only and time-only fields");const e=(u-a)/w/1e3,t=e/86400;return new l({field:p,expression:c,interval:{unit:T?"seconds":"days",value:Math.ceil(T?e:t)},start:a,end:u})}if("defined-interval"===z)return new s({field:p,expression:c,normalizationField:y,normalizationTotal:d,normalizationType:x,interval:e.definedInterval??Math.ceil((u-a)/w),start:x?null:a,end:x?null:u,normalizationMinValue:x?a:null,normalizationMaxValue:x?u:null});if("manual"===z)throw new i(`${n.adapterName}:not-supported`,"Layer does not support manual classificationMethod");if("natural-breaks"===z||"quantile"===z||"standard-deviation"===z){const t=f.getFieldExpr({field:p,normalizationField:y,normalizationTotal:d,normalizationType:x,layer:n}),r=null!==e.minValue&&null!==e.maxValue?m.getRangeExpr(t,e.minValue,e.maxValue):void 0,l=await F(e,n,r);if(!l.intervals)throw new i(`${n.adapterName}:invalid`,"Invalid intervals returned from generate renderer");const s=[a,...l.intervals.map(e=>e[1])];return new o({field:x?null:p,expression:x?t:c,boundaries:s})}return new r({field:p,normalizationField:y,normalizationTotal:d,normalizationType:x,expression:c,numBins:w,start:x?null:a,end:x?null:u,normalizationMinValue:x?a:null,normalizationMaxValue:x?u:null})}function v(e,i,n,t){return null!=n&&null!=t?Promise.resolve({min:n,max:t}):i.summaryStatistics({...e,outStatisticTypes:{include:["min","max"]}}).then(e=>({min:e.min,max:e.max}))}function T(e,i=!1){return"string"!=typeof e?e:(i?new Date(`1970-01-01T${e}Z`):new Date(e)).getTime()}e.binParamsFromGenRend=F,e.formatHistogramBinValue=T,e.getAttributeBinsQuery=async function(e,i,r,l){const{field:o,minValue:s,maxValue:u,filter:p,view:c}=e,F=o?i.getField(o):null,T=t.isDateField(F)||t.isTimestampOffsetField(F),g=z(e,i,r),{min:w,max:h}=await v(g,i,s,u);if(null==w||null==h)return{query:null,min:w,max:h};const B=new d({statisticType:"count",outStatisticFieldName:y,onStatisticField:"1"}),V=m.mergeWhereClauses(l,g.sqlWhere),E=new a({binParameters:await x(e,i,w,h,r),outStatistics:[B],binOrder:e.sortOrder,where:V,lowerBoundaryAlias:"lowerBoundary",upperBoundaryAlias:"upperBoundary",outTimeZone:c?.timeZone&&T?n.resolveTimeZone(c.timeZone):null});return f.updateQueryWithFeatureFilter(E,p),{query:E,min:w,max:h}},e.getDataRange=v,e.getHistogramAttributeDefinition=function(e,i,n){const{valueExpression:t,view:a}=e,{featuresJSON:r,graphics:l,fieldInfos:o}=i,s={field:e.field,valueExpression:t,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:n,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return t&&a&&(r||l)&&(s.viewInfoParams=f.getViewInfoParams(a),s.timeZone=a.timeZone,s.fieldInfos=o),s},e.getQueryParamsForExpr=z,e.processQueryAttributeBinsResult=function(e,i,n){const a=t.isTimeOnlyField(i);return{...n,bins:e.features.map(e=>({minValue:T(e.attributes.lowerBoundary,a),maxValue:T(e.attributes.upperBoundary,a),count:e.attributes[y]}))}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});