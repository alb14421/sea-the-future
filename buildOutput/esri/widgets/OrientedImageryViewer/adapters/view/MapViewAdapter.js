// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../Graphic","../../../../core/arrayUtils","../../../../core/Logger","../../../../core/promiseUtils","../../../../geometry/Polygon","../../../../layers/orientedImagery/transformations/utils","../../constants","../../symbols"],function(e,t,o,i,r,a,s,n){"use strict";return class{constructor(l){this.viewModel=l,this.createFootprints=async t=>{await i.waitTick(t);const{coveragePolygons:o,currentBestFeature:r,isAdditionalCoverageVisible:a}=this.viewModel;for(const t of o)t?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:t?.imageID},geometry:t,symbol:n.activePolygonSymbol,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:t?.imageID},geometry:t,symbol:n.polygonSymbol.clone(),visible:a}))},this.updateFootprint=async(a,l)=>{const{activeViewer:c,mode:u,currentBestFeature:g,currentCoverageVisible:d,footprintExtent:p}=this.viewModel,v="video"===u?s.fixedImageSize:c?.imageSize;if(g&&v&&p)try{const o=await this.viewModel.getMapPoint(a,{feature:g,mode:"default",imageSize:v});i.throwIfAborted(l);const s=o.filter(t.isSome);if(!s.length)return;const c=[s.map(({x:e,y:t})=>[e,t,1])];c[0].push(c[0][0]);const u=new r({rings:c,spatialReference:s[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:u,attributes:{imageID:g.attributes.objectId},symbol:n.activePolygonSymbol,visible:d}))}catch(e){i.isAbortError(e)||o.getLogger(this.viewModel).error("update-footprint",e)}else this.viewModel.updateCurrentCoveragePolygon(null)},this.updateFootprintPanorama=async(t,o)=>{const{horizontalFieldOfView:s,pitch:l,verticalFieldOfView:c,yaw:u}=t,{activeViewer:g,currentBestFeature:d,currentCoverageVisible:p,footprintExtent:v}=this.viewModel,m=g?.imageSize;if(!d||!m||!v)return void this.viewModel.updateCurrentCoveragePolygon(null);const{cameraPitch:h,objectId:y}=d.attributes;if(l+h-c/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const w=[],b=c/2,f=s/2,M=l-b,P=h+M,C=h+(l+b);if(P>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const I=M<0,F=[-f,b],S=[f,b],D=[f,-b],V=[-f,-b];if(P<180&&C>180){w.push(I?D:V);const e=Math.floor(s/5),t=s/e;for(let o=0;o<=e;o++)w.push([o*t-f,90-l]);w.push(I?V:D)}C<180&&(w.push(F,S),I?w.push(V,D):w.push(D,V));const x=w.map(([e,t])=>a.convertOrientationToPixelLocation(u+e,l+t,m[0],m[1])),z=await this.viewModel.getMapPoint(x,{feature:d,mode:"panorama",imageSize:m});i.throwIfAborted(o);const A=[z.map(({x:e,y:t})=>[e,t,1])];A[0].push(A[0][0]);const R=new r({rings:A,spatialReference:z[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:R,attributes:{imageID:y},symbol:n.activePolygonSymbol.clone(),visible:p}))}}}});