// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../Graphic","../../../../core/arrayUtils","../../../../core/promiseUtils","../../../../geometry/Mesh","../../../../geometry/Point","../../../../geometry/projectionUtils","../../../../geometry/support/MeshVertexAttributes","../../../../layers/orientedImagery/core/coverageUtils","../../symbols"],function(e,t,i,o,r,a,s,n,l){"use strict";return class{constructor(c){this.viewModel=c,this._updateBestFeatureFootprintElevation=!1,this.createFootprints=async r=>{const{coverageFrustums:c,currentBestFeature:u,isAdditionalCoverageVisible:m,view:p}=this.viewModel,d=c.filter(t.isSome);for(const t of d){let c=t.clone();if(!p.spatialReference.equals(c.spatialReference)){const{components:e,spatialReference:t,origin:l,vertexAttributes:u,vertexSpace:m}=c;if("local"===m.type){const e=await a.projectWithZConversion(l,p.spatialReference,r);i.throwIfAborted(r),c.centerAt(e)}else{const a=u.position,l=Float64Array.from(await n.projectVertices([...a],t.clone(),p.spatialReference.clone(),r));i.throwIfAborted(r),c=new o({vertexAttributes:new s.MeshVertexAttributes({position:l}),components:e,spatialReference:p.spatialReference.clone()})}}t.imageID===u.attributes.objectId?(this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:t.imageID},geometry:c,symbol:l.activeFrustumSymbol.clone(),visible:!1}),this._updateBestFeatureFootprintElevation=!0):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:t.imageID},geometry:c,symbol:l.additionalFrustumSymbol.clone(),visible:m}))}},this.updateFootprint=async(o,s)=>{const{bestFeatureFootprint:c,currentBestFeature:u,activeViewer:m,footprintExtent:p,view:d}=this.viewModel,v=m?.imageSize;if(!(u&&c?.geometry&&v&&p))return void this.viewModel.updateCurrentCoveragePolygon(null);const{attributes:{cameraHeight:h,location:w,cameraPitch:f,horizontalFieldOfView:g,verticalFieldOfView:y,cameraRoll:b},elevationSample:F}=u;F&&this._updateBestFeatureFootprintElevation&&(this.updateGroundElevation([c],F),this._updateBestFeatureFootprintElevation=!1);const M=w.toArray(),{vertexAttributes:{position:R},spatialReference:A}=c.geometry,I=await async function(e,t,i){return Float64Array.from((await Promise.all(e.reduce((e,t,i)=>{const o=Math.floor(i/3);return e[o]=e[o]??[],e[o].push(t),e},new Array).map(async e=>(await a.projectWithZConversion(new r(e,t),i,void 0)).toArray()))).flat())}(R,A,w.spatialReference),V=await this.viewModel.getMapPoint(o,{feature:u,mode:"default",imageSize:v});i.throwIfAborted(s);let C=V.filter(t.isSome);if(!C.length)return;C[0].spatialReference.equals(w.spatialReference)||(C=await Promise.all(C.map(async e=>{const t=await a.projectWithZConversion(e,w.spatialReference,s);return i.throwIfAborted(s),t})));const S=await n.updateFrustum(o.map(({x:e,y:t})=>[e,t]),C.map(e=>e.toArray()),{cameraHeight:h,cameraLocation:M,cameraPitch:f,frustumVertices:I,horizontalFieldOfView:g,imageHeight:v[1],imageWidth:v[0],inSRS:{wkid:w.spatialReference.wkid},outSRS:{wkid:d.spatialReference.wkid},verticalFieldOfView:y,cameraRoll:b??0,options:s});this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:u.attributes.objectId},geometry:S,symbol:l.activeFrustumSymbol.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(t,o)=>{await i.waitTick(o);const{horizontalFieldOfView:r,pitch:a,verticalFieldOfView:s,yaw:c}=t,u=this.viewModel.currentBestFeature?.clone();if(!u)return;const{attributes:m}=u;m.orientedImageryType=null,m.cameraHeading=(c+m.cameraHeading)%360,m.cameraPitch=a,m.horizontalFieldOfView=r,m.verticalFieldOfView=s,m.cameraRoll=0;const{frustum:p}=n.createCoveragePolygon(m);p?this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:m.objectId},geometry:p,symbol:l.activeFrustumSymbol.clone(),visible:this.viewModel.currentCoverageVisible})):this.viewModel.updateCurrentCoveragePolygon(null)}}updateGroundElevation(e,t){const{geometry:i}=this.viewModel.currentBestFeature,o=t.queryElevation(i);e.forEach(e=>{const{geometry:t}=e;switch(t?.type){case"mesh":{const{vertexAttributes:{position:e}}=t,i=Math.floor(e.length/3);for(let t=0;t<i;t+=1)e[3*t+2]+=o?.z??0;break}case"point":t.z=(t.z??0)+(o?.z??0)}})}}});