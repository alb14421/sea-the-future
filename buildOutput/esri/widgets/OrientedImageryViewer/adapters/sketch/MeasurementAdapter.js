// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../chunks/tslib.es6","../../../../Graphic","../../../../core/asyncUtils","../../../../core/Promise","../../../../core/promiseUtils","../../../../core/accessorSupport/decorators/property","../../../../core/has","../../../../core/Logger","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","../../../../geometry/Polygon","../../../../geometry/Polyline","../../../../geometry/projectionUtils","../../../../geometry/SpatialReference","../../../../layers/orientedImagery/transformations/utils","../../imageMeasurementUtils","../../mixins/SketchHandlerMixin"],function(e,t,a,i,s,r,o,n,c,l,h,u,d,m,y,p,M){"use strict";let w=[],g=[],v=0,A=class extends(M.SketchHandlerMixin(i.EsriPromise)){constructor(e){super(e),this.type="measurement",this.measurementArray=[],this.pixelMeasurement=0,this.pixelAreaMeasurement=0,this.polygonVertices=[],this._calculationTask=null,this._distanceCalculation=0,this._areaCalculation=null}initialize(){this.addResolvingPromise(d.load())}async handleCreate(e){const t=e.toolEventInfo;switch(e.tool){case"polyline":await this.handlePolylineEvents(e,t);break;case"polygon":await this.handlePolygonEvents(e,t)}}handleDelete(e){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}handleDestroy(){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}cursorUpdatePolylineHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;if("default"===t)this.measurementArray.push(e.coordinates);else{const t={x:e.coordinates[0],y:e.coordinates[1],z:e.coordinates[2]},i=y.convertSphereVertexToPixelLocation(t,a.imageSize[0],a.imageSize[1]);this.measurementArray.push([i.x,i.y])}const i=g.reduce((e,t)=>e+t,0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=i}async cursorUpdatePolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;const i=e.coordinates;if(w=[...this.polygonVertices],"default"===t)w.push(i);else{const e={x:i[0],y:i[1],z:i[2]},t=y.convertSphereVertexToPixelLocation(e,a?.imageSize[0],a?.imageSize[1]);w.push([t.x,t.y])}if(w.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const s=w[0];w=w.filter((e,t)=>0===t||t===w.length-1||JSON.stringify(e)!==JSON.stringify(s));const r=await this._getAreaFromTask(w);r?.area&&r?.perimeter&&(v=r.area)}async handlePolylineEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetDistanceMeasurements(),this.viewModel.distanceMeasurementResult=0,this.viewModel.distanceAccuracyArray=[],void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),this.viewModel.triangularMeasurementActive){const t=e.graphic.geometry;await this.viewModel.processMeasurementVectors(t.paths[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetDistanceMeasurements()}switch(t?.type){case"cursor-update":this.cursorUpdatePolylineHandler(t);break;case"vertex-add":if(this.measurementArray.length&&a){const e=await this._getAccuracyFromTask();e&&this.viewModel.distanceAccuracyArray.push(e)}this.vertexUpdatePolylineHandler()}const i=await this._getDistanceFromTask();this.pixelMeasurement=i??this.pixelMeasurement}async handlePolygonEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetAreaMeasurements(),this.viewModel.areaMeasurementResult=0,this.viewModel.areaMeasurementAccuracy=0,void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),a){const e=await this._getAreaAccuracyFromTask(this.polygonVertices);this.viewModel.areaMeasurementAccuracy=e&&e>this.viewModel.areaMeasurementAccuracy?e:this.viewModel.areaMeasurementAccuracy}if(this.viewModel.triangularMeasurementActive){const t=e.graphic.geometry;await this.viewModel.processMeasurementVectors(t.rings[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetAreaMeasurements()}switch(t?.type){case"vertex-add":await this.vertexAddPolygonHandler(t);break;case"cursor-update":await this.cursorUpdatePolygonHandler(t)}this.viewModel.areaMeasurementResult=v>0?v:this.pixelAreaMeasurement}async vertexAddPolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel,i=e.added,s=i[i.length-1];if(!Array.isArray(s)||"none"===t||!a?.imageSize)return;if("default"===t)this.polygonVertices.push(s);else{const e={x:s[0],y:s[1],z:s[2]},t=y.convertSphereVertexToPixelLocation(e,a?.imageSize[0],a?.imageSize[1]);this.polygonVertices.push([t.x,t.y])}if(this.polygonVertices.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const r=this.polygonVertices[0];this.polygonVertices=this.polygonVertices.filter((e,t)=>0===t||t===this.polygonVertices.length-1||JSON.stringify(e)!==JSON.stringify(r));const o=await this._getAreaFromTask(this.polygonVertices);if(!o?.area||!o?.perimeter)return;const{area:n}=o;this.pixelAreaMeasurement=n}vertexUpdatePolylineHandler(){this.measurementArray=this.measurementArray.slice(-1);const e=g.reduce((e,t)=>e+t,0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=e,this.pixelMeasurement>0&&g.push(this.pixelMeasurement)}resetDistanceMeasurements(){this.measurementArray=[],this.pixelMeasurement=0,g=[]}resetAreaMeasurements(){this.polygonVertices=[],this.pixelAreaMeasurement=0,v=0}async _overlayFirstMeasurement(e,t){switch(t){case"polyline":await this._overlayFirstDistanceMeasurement(e);break;case"polygon":await this._overlayFirstAreaGeometry(e)}}async _overlayFirstDistanceMeasurement(e){const a=e.geometry?.clone(),i=e.symbol?.clone(),s=[...a.paths[0]],r=p.formatPixels(s,!0),o=await this.viewModel.getMeasurementProperties(),n=await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer);if(r?.length&&o&&n){const e=(await this.viewModel.imageToImageTransform(r,o,n)).map(e=>[e.x-.5,-.5-e.y]),a=new u({paths:[e],spatialReference:m.WebMercator}),s=new t({geometry:a,symbol:i});await this.viewModel.editOverlayedGraphics(s)}}async _overlayFirstAreaGeometry(e){const a=e.geometry?.clone(),i=e.symbol?.clone(),s=[...a.rings[0]],r=p.formatPixels(s,!0),o=await this.viewModel.getMeasurementProperties(),n=await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer);if(r?.length&&o&&n){const e=(await this.viewModel.imageToImageTransform(r,o,n)).map(e=>[e.x-.5,-.5-e.y]),a=new h({rings:[e],spatialReference:m.WebMercator}),s=new t({geometry:a,symbol:i});await this.viewModel.editOverlayedGraphics(s)}}async _getAreaFromTask(e){const{mode:t}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=a.createTask(async a=>{this._areaCalculation=null;const i=await this.viewModel.calculateAreaMeasurement(e,t,a);s.throwIfAborted(a),this._areaCalculation=i}),await this._calculationTask.promise,this._areaCalculation}async _getDistanceFromTask(){const{mode:e}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=a.createTask(async t=>{this._distanceCalculation=0;const a=await this.viewModel.calculateDistanceMeasurement(this.measurementArray,e,t);s.throwIfAborted(t),this._distanceCalculation=a}),await this._calculationTask.promise,this._distanceCalculation}async _getAccuracyFromTask(){const{mode:e}=this.viewModel;return"none"===e?null:(this._calculationTask?.abort(),this._calculationTask=a.createTask(async t=>{this._distanceCalculation=0;const a="default"===e?await this.viewModel.calculateAccuracy(this.measurementArray,"distance",t):await this.viewModel.calculateAccuracyPanoramic(this.measurementArray,"distance",t);s.throwIfAborted(t),this._distanceCalculation=a}),await this._calculationTask.promise,this._distanceCalculation)}async _getAreaAccuracyFromTask(e){const{mode:t}=this.viewModel;return"none"===t?null:(this._calculationTask?.abort(),this._calculationTask=a.createTask(async a=>{this._distanceCalculation=0;const i="default"===t?await this.viewModel.calculateAccuracy(e,"area",a):await this.viewModel.calculateAccuracyPanoramic(e,"area",a);s.throwIfAborted(a),this._distanceCalculation=i}),await this._calculationTask.promise,this._distanceCalculation)}};return e.__decorate([r.property()],A.prototype,"type",void 0),e.__decorate([r.property()],A.prototype,"measurementArray",void 0),e.__decorate([r.property()],A.prototype,"pixelMeasurement",void 0),e.__decorate([r.property()],A.prototype,"pixelAreaMeasurement",void 0),e.__decorate([r.property()],A.prototype,"polygonVertices",void 0),A=e.__decorate([l.subclass("esri.widgets.OrientedImageryViewer.adapters.sketch.MeasurementAdapter")],A),A});