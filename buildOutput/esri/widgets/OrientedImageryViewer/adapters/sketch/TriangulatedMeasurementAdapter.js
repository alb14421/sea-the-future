// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../chunks/tslib.es6","../../../../core/Promise","../../../../core/accessorSupport/decorators/property","../../../../core/has","../../../../core/Logger","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","../../../../geometry/projectionUtils","../../imageMeasurementUtils","../../mixins/TriangulatedSketchHandlerMixin"],function(e,t,a,r,s,i,n,c,o,u){"use strict";let l=[],d=class extends(u.TriangulatedSketchHandlerMixin(t.EsriPromise)){constructor(e){super(e),this.type="measurement"}async handleUpdate(e){const{measureType:t,updatingTriangularMeasurementState:a}=this.viewModel;if("distance"===t){const t=e.graphics[0].geometry;l=t.paths[0]}else if("area"===t){const t=e.graphics[0].geometry;l=t.rings[0]}"complete"===e.state&&(this.viewModel.triangulatedMeasurementGraphic=e.graphics.at(-1),a?await this._updateTriangularMeasurements(l):await this.viewModel.processMeasurementVectors(l))}async _computeMeasurementVector(e,t){const{activeViewer:a,mode:r,view:s}=this.viewModel,i=a?.imageSize;if(!e||!t||!i)return;const n=e.map(e=>[e[0]-.5,-.5-e[1]]),u=s?.spatialReference,l=[];for(let e=0;e<n.length;e++){const a={x:n[e][0],y:n[e][1]};let s=await this.viewModel.getMapPoint(a,{feature:t,imageSize:i,mode:r});u&&!s.spatialReference.equals(u)&&(s=await c.projectWithZConversion(s,u)),l.push(s)}return o.computeTriangulatedVector(l,t)}async _updateTriangularMeasurements(e){const{measureType:t,triangularMeasurementActive:a,currentBestFeatureMeasurementImage:r,updatingTriangularMeasurementState:s}=this.viewModel;if(!a||!r||!s||2!==this.viewModel.measurementVectors?.length)return;this.viewModel.measurementVectors.splice(-1);const i=await this._computeMeasurementVector(e,r);if(i&&this.viewModel.measurementVectors.push(i),2===this.viewModel.measurementVectors.length){switch(t){case"distance":{this.viewModel.triangulatedDistanceMeasurement=await o.computeTriangulatedDistanceMeasurement(this.viewModel.measurementVectors);const t=await this.viewModel.calculateAccuracy(e,"distance");if(t&&this.viewModel.triangulatedDistanceMeasurement?.distance){const e=Math.atan(t/this.viewModel.triangulatedDistanceMeasurement.distance);this.viewModel.triangulatedDistanceAccuracy={distanceAccuracy:t,angleAccuracy:e}}break}case"area":if(r?.geometry.spatialReference){const e=await o.computeTriangulatedAreaMeasurement(this.viewModel.measurementVectors,r.geometry.spatialReference);this.viewModel.triangulatedAreaMeasurement=e}}this.viewModel.updatingTriangularMeasurementState=!1}}};return e.__decorate([a.property()],d.prototype,"type",void 0),d=e.__decorate([n.subclass("esri.widgets.OrientedImageryViewer.adapters.sketch.TriangulatedMeasurementAdapter")],d),d});