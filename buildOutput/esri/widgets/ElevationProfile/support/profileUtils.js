// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/mathUtils","../../../core/promiseUtils","../../../geometry/Multipoint","../../../geometry/support/coordsUtils","../../../geometry/support/spatialReferenceUtils","../../../views/support/ScheduledQueueProcessor","../../../views/support/Scheduler","./constants","./geometryUtils","./ProfileGenerationError","./statisticsUtils","../../support/traversalUtils"],function(e,t,r,n,o,s,i,l,a,c,u,f,p,d){"use strict";function*h(e,r){const{densificationResult:n}=e,o={...e,abortOptions:r,densificationResult:n},s=d.breadthFirstBinaryPartitioning(0,o.result.samples.length),i=s.slice(0,o.provider.numSamplesForPreview);yield m(o,i,!0);const l=t.splitIntoChunks(s,o.provider.numSamplesPerChunk);for(const e of l)yield m(o,e,!1)}async function m({densificationResult:e,result:t,provider:r,queue:s,abortOptions:i,cache:l},a,u){const{densifiedPath:f,pathLength:p}=e,d=t.spatialReference,{samples:h}=t,m=[];for(let e=0;e<a.length;e++){const t=h[a[e]];m[e]=t.coordinate}try{return await s.push({geometry:new o({spatialReference:d,points:m,hasZ:f.hasZ}),provider:r,indices:a,preview:u,result:t,queryOptions:{...c.getConfig().defaultQueryOptions(),minDemResolution:u?Math.round(p/r.numSamplesForPreview):Math.round(p/h.length),cache:l}},i),{...t}}catch(e){return n.isAbortError(e)?null:c.errorResult}}function y(e){const t=e.length-1;let r=0;for(let n=1;n<=t;n++)(e[n].sampled||n===t)&&(g(e,r,n),r=n)}function g(e,t,n){if(n-t===1)return;const o=e[t],s=o.sampledZ,i=e[n],l=i.sampledZ;if(null==s||null==l){for(let r=t+1;r<n;r++)e[r].sampledZ=null;return}const a=o.distance,c=i.distance-a;for(let o=t+1;o<n;o++){const t=e[o],n=(t.distance-a)/c;t.sampledZ=r.lerp(s,l,n)}}function w({densifiedPath:e,distances:t}){const r=e.spatialReference,n=i.getInfo(r),o=e.paths,l=o.length,a=[];let c=null,u=0;for(let e=0;e<l;e++){const r=o[e],i=r.length,l=t[e];for(let e=0;e<i;e++){const t=r[e],o=l[e];n&&(t[0]=s.unnormalizedCoordinate(t[0],n.valid[0],n.valid[1])),c&&0===e&&v(a,c,t,u,o),a.push(P(t,o)),c=t,u=o}}return{progress:0,samples:a,hasZ:!1,statistics:null,spatialReference:r}}function v(e,t,r,n,o){e.push(R(t,n)),e.push(R(r,o))}function P(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function R(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}e.binaryFindClosest=function(e,t,r){if(!e||0===e.length)return;const n=e.length-1,o=e[0];if(t<=r(o))return o;const s=e[n];if(t>=r(s))return s;let i=0,l=0,a=n;for(;i<a;){l=i+Math.floor((a-i)/2);const o=e[l],s=r(o);if(s===t)return o;if(t<s){if(l>0){const n=e[l-1],i=r(n);if(t>i)return t-i>=s-t?o:n}a=l}else{if(l<n){const n=e[l+1],i=r(n);if(t<i)return t-s>=i-t?n:o}i=l+1}}return e[l]},e.createProfileQueue=function(e){return new l.ScheduledQueueProcessor({priority:a.TaskPriority.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{n.throwIfAborted(e.queryOptions);try{await async function({geometry:e,provider:t,indices:r,preview:n,result:o,queryOptions:s}){if(0===r.length)return;const i=(await async function(e,t,r){try{return await e.queryElevation(t,r)}catch(e){throw new f.ProfileGenerationError("elevation-query-error")}}(t,e,s)).geometry,{hasZ:l,points:a}=i,c=s.noDataValue,{samples:u}=o;for(let e=0;e<r.length;e++){const t=u[r[e]];if(t.isHole)continue;const n=l?a[e][2]:null;null===n||n===c?t.sampledZ=null:(o.hasZ=!0,t.sampledZ=n),t.sampled=!0}y(u),o.progress=n?0:o.progress+r.length/u.length,o.statistics=p.getStatistics(o.samples,o.spatialReference)}(e)}catch(e){n.throwIfNotAbortError(e)}}})},e.generateProfile=h,e.generateProfiles=async function*(e,t){const{view:r,geometry:o,elevationInfo:s,providers:i,options:l}=e,a=r.spatialReference;if(!a||null==o||!u.isValidInputPath(o))throw new f.ProfileGenerationError("invalid-geometry");const p=i.length;if(0===p)return null;const d=Math.round(l.maxTotalSamples/p);if(u.countPoints(o)>d)throw new f.ProfileGenerationError("too-complex");const m=await u.densifyPath(o,s,r,a,l,d,t);let y=0;const g=new Array(p),v=new Array(p);for(let r=0;r<p;r++){const n=w(m);g[r]=n,y+=n.samples.length;const o={...e,provider:i[r],result:n,densificationResult:m};v[r]=h(o,t)[Symbol.iterator]()}if(y>l.maxTotalSamples)throw new f.ProfileGenerationError("too-complex");const P=await Promise.all(v.map(e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value}));n.throwIfAborted(t);for(let e=0;e<p;e++)g[e]=P[e];yield g,await n.after(e.delayAfterPreview??c.getConfig().delayAfterPreviewMillis,null,t.signal);const R=[];try{let e;do{e=!1;for(let t=0;t<p;t++){const r=v[t].next();!1===r.done&&(R.push({resultPromise:r.value,index:t}),e=!0)}}while(e)}finally{v.forEach(e=>e.return?.())}for(const{resultPromise:e,index:r}of R)g[r]=await e,n.throwIfAborted(t),yield g;for(const e of g)null!=e&&(e.progress=1);yield g},e.interpolateElevations=y,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});