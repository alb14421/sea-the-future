// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../core/has","../core/MapUtils","../core/promiseUtils","../core/QueueProcessor"],function(e,t,s,r,i){"use strict";class n{constructor(e,t,s){this._executor=e,this._data=t,this._impl=s,this._closed=!1,this._resolver=r.createResolver(),this._impl.open(this)}assertOpen(){if(this._closed)throw new Error("Batch closed.")}get data(){return this.assertOpen(),this._data}get results(){return this._resolver.promise}send(){try{this.assertOpen(),this._closed=!0,this._executor.resume(this),this._impl.close(this),r.settleWithPromise(this._resolver,this._impl.execute(this._data))}catch(e){this._resolver.reject(e)}}}class o{constructor(e,t,s,n){if(this._runJob=t,this._maxRunning=s,this._abortSignal=n,this._jobIdSeq=0,this._running=new Set,this._blocked=new Set,this._openBatches=new Map,this._state="ready",this._runResolver=null,s<1)throw new Error(`_maxRunning=${s} but cannot be < 1`);this._todo=e[Symbol.iterator](),this._queue=new i.QueueProcessor({concurrency:1,process:async e=>{if("start"===e.type){const{id:t,args:s}=e,i=r.createResolver(),n=r.createResolver(),o={id:t,interrupt:i,finished:n.promise};return r.settleWithPromise(n,this._runJob(s,{id:t,yieldFor:e=>this.yieldFor(o,e)}).then(()=>{this._blocked.has(t)&&this._fail(new Error(`job ${t} completed before resuming`)),this._running.delete(t)||this._fail(new Error(`job ${t} not running?`))})),await Promise.race([i.promise,o.finished]),void this._tryQueue()}if("continue"===e.type)return e.job.interrupt=r.createResolver(),"fulfilled"===e.data.status?e.continuation.resolve(e.data.value):e.continuation.reject(e.data.reason),await Promise.race([e.job.interrupt.promise,e.job.finished]),void this._tryQueue()}})}openBatch(e,t){return new n(this,e,t)}_fail(e,t=!1){if(this._runResolver?.reject(e),this._state="stopped",!t)throw e}_schedule(e){this._queue.push(e).catch(e=>this._fail(e,!0))}_tryQueue(){if("running"===this._state)if(this._abortSignal?.aborted)this._fail(r.createAbortError(),!0);else{if(this._running.size<this._maxRunning){const e=this._todo.next();if(!e.done){const t=this._jobIdSeq++;return this._running.add(t),void this._schedule({type:"start",id:t,args:e.value})}}if(0===this._running.size)return this._runResolver?.resolve(),this._runResolver=null,void(this._state="stopped");if(this._blocked.size===this._running.size){let e=null,t=-1/0;for(const[s,r]of this._openBatches)r.size>t&&(e=s,t=r.size);return null==e&&this._fail(new Error("deadlock")),void e.send()}}}resume(e){const t=this._openBatches.get(e);if(this._openBatches.delete(e),null!=t)for(const e of t)this._blocked.delete(e)||this._fail(new Error(`job ${e} not suspended`))}async yieldFor(e,t){t.assertOpen(),this._running.has(e.id)||this._fail(new Error(`job ${e.id} not running`)),this._blocked.has(e.id)&&this._fail(new Error(`job ${e.id} already suspended`)),this._blocked.add(e.id),s.getOrCreateMapValue(this._openBatches,t,()=>new Set).add(e.id),null==e.interrupt&&this._fail(new Error(`job ${e.id} hasn't resumed yet`)),e.interrupt.resolve(),e.interrupt=null;const i=r.createResolver();let n;try{n={status:"fulfilled",value:await t.results}}catch(e){n={status:"rejected",reason:e}}return this._schedule({type:"continue",continuation:i,data:n,job:e}),i.promise}run(){"ready"!==this._state&&this._fail(new Error(`executor not ready to start. state=${this._state}`));const e=r.createResolver();return this._state="running",this._runResolver=e,this._tryQueue(),e.promise}}e.createBatchExecutor=function(e,t,s,r){return new o(e,t,s,r)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});