// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../geometry/support/jsonUtils"],function(e,t,r){"use strict";const o=e=>Object.freeze(Object.defineProperty({__proto__:null,default:e},Symbol.toStringTag,{value:"Module"}));function n(e,t){let r;return{loaded:!1,load:()=>r??=t().then(t=>{s[e]={loaded:!0,execute:t}})}}function a(e){return null==e?null:e.toJSON()}const s={disjoint:n("disjoint",()=>new Promise((t,r)=>e(["../../geometry/operators/json/disjointOperator"],t,r)).then(e=>e.execute)),intersects:n("intersects",()=>new Promise((t,r)=>e(["../../geometry/operators/json/intersectsOperator"],t,r)).then(e=>e.execute)),touches:n("touches",()=>new Promise((t,r)=>e(["../../geometry/operators/json/touchesOperator"],t,r)).then(e=>e.execute)),crosses:n("crosses",()=>new Promise((t,r)=>e(["../../geometry/operators/json/crossesOperator"],t,r)).then(e=>e.execute)),within:n("within",()=>new Promise((t,r)=>e(["../../geometry/operators/json/withinOperator"],t,r)).then(e=>e.execute)),contains:n("contains",()=>new Promise((t,r)=>e(["../../geometry/operators/json/containsOperator"],t,r)).then(e=>e.execute)),overlaps:n("overlaps",()=>new Promise((t,r)=>e(["../../geometry/operators/json/overlapsOperator"],t,r)).then(e=>e.execute)),equals:n("equals",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/equalsOperator"],t,r));return(e,o)=>t.execute(r.fromJSON(e),r.fromJSON(o))}),relate:n("relate",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/relateOperator"],t,r));return(e,o,n)=>t.execute(r.fromJSON(e),r.fromJSON(o),n)}),intersection:n("intersection",()=>new Promise((t,r)=>e(["../../geometry/operators/json/intersectionOperator"],t,r)).then(e=>e.execute)),union:n("union",()=>new Promise((t,r)=>e(["../../geometry/operators/json/unionOperator"],t,r)).then(e=>e.executeMany)),difference:n("difference",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/differenceOperator"],t,r));return(e,o)=>a(t.execute(r.fromJSON(e),r.fromJSON(o)))}),symmetricDifference:n("symmetricDifference",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/symmetricDifferenceOperator"],t,r));return(e,o)=>a(t.execute(r.fromJSON(e),r.fromJSON(o)))}),clip:n("clip",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/clipOperator"],t,r));return(e,o)=>a(t.execute(r.fromJSON(e),r.fromJSON(o)))}),cut:n("cut",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/cutOperator"],t,r));return(e,o)=>t.execute(r.fromJSON(e),r.fromJSON(o)).map(e=>a(e))}),area:n("area",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/areaOperator"],t,r)),{convertFromSpatialReferenceUnit:o,toAreaUnit:n}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,a)=>{const s=t.execute(r.fromJSON(e));return o(e.spatialReference,n(a),s)}}),geodeticArea:n("geodeticArea",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/geodeticAreaOperator"],t,r)),{convert:o,squareMeters:n,toAreaUnit:a}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return await t.load(),(e,s,i)=>{const c=t.execute(r.fromJSON(e),{curveType:i});return o(n,a(s),c)}}),length:n("length",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/json/lengthOperator"],t,r)),{convertFromSpatialReferenceUnit:r,toLengthUnit:o}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,n)=>{const a=t.execute(e);return r(e.spatialReference,o(n),a)}}),geodeticLength:n("geodeticLength",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/geodeticLengthOperator"],t,r)),{convert:o,meters:n,toLengthUnit:a}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return await t.load(),(e,s,i)=>{const c=t.execute(r.fromJSON(e),{curveType:i});return o(n,a(s),c)}}),distance:n("distance",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/distanceOperator"],t,r)),{convertFromSpatialReferenceUnit:o,toLengthUnit:n}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,a,s)=>{const i=t.execute(r.fromJSON(e),r.fromJSON(a));return o(e.spatialReference,n(s),i)}}),densify:n("densify",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/densifyOperator"],t,r)),{convertToSpatialReferenceUnit:o,toLengthUnit:n}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,s,i)=>(s=o(n(i),e.spatialReference,s),a(t.execute(r.fromJSON(e),s)))}),geodeticDensify:n("geodeticDensify",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/geodeticDensifyOperator"],t,r)),{convert:o,meters:n,toLengthUnit:s}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return await t.load(),(e,i,c,m)=>(i=o(s(c),n,i),a(t.execute(r.fromJSON(e),i,{curveType:m})))}),generalize:n("generalize",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/generalizeOperator"],t,r)),{convertToSpatialReferenceUnit:o,toLengthUnit:n}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,s,i,c)=>(s=o(n(i),e.spatialReference,s),a(t.execute(r.fromJSON(e),s,c)))}),buffer:n("buffer",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/json/bufferOperator"],t,r)),{convertToSpatialReferenceUnit:r,toLengthUnit:o}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,n,a)=>(n=r(o(a),e.spatialReference,n),t.execute(e,n))}),geodesicBuffer:n("geodesicBuffer",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/json/geodesicBufferOperator"],t,r)),{convert:r,meters:o,toLengthUnit:n}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return await t.load(),(e,a,s,i)=>(a=r(n(s),o,a),t.execute(e,a,{curveType:i}))}),offset:n("offset",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/json/offsetOperator"],t,r)),{convertToSpatialReferenceUnit:r,toLengthUnit:o}=await new Promise((t,r)=>e(["./unitConversion"],t,r));return(e,n,a,s)=>(n=r(o(a),e.spatialReference,n),t.execute(e,n,s))}),rotate:n("rotate",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/affineTransformOperator"],t,r)),{default:n}=await new Promise((t,r)=>e(["../../geometry/operators/support/Transformation"],e=>t(o(e)),r));return(e,o,s,i)=>{const c=(new n).rotate(o,s,i);return a(t.execute(r.fromJSON(e),c))}}),centroid:n("centroid",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/centroidOperator"],t,r));return e=>a(t.execute(r.fromJSON(e)))}),labelPoint:n("labelPoint",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/labelPointOperator"],t,r));return e=>a(t.execute(r.fromJSON(e)))}),simplify:n("simplify",()=>new Promise((t,r)=>e(["../../geometry/operators/json/simplifyOperator"],t,r)).then(e=>e.execute)),isSelfIntersecting:n("isSelfIntersecting",async()=>{const{NonSimpleResult:t}=await new Promise((t,r)=>e(["../../chunks/OperatorDefinitions"],t,r)),o=await new Promise((t,r)=>e(["../../geometry/operators/simplifyOGCOperator"],t,r)),n=new Set([5,6,7,10,11,12]);return e=>{const a=new t;return!o.isSimple(r.fromJSON(e),a)&&n.has(a.m_reason)}}),isSimple:n("isSimple",()=>new Promise((t,r)=>e(["../../geometry/operators/json/simplifyOperator"],t,r)).then(e=>e.isSimple)),convexHull:n("convexHull",()=>new Promise((t,r)=>e(["../../geometry/operators/json/convexHullOperator"],t,r)).then(e=>e.execute)),getNearestCoordinate:n("getNearestCoordinate",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/proximityOperator"],t,r));return(e,o,n)=>{const s=t.getNearestCoordinate(r.fromJSON(e),r.fromJSON(o),n);return{...s,coordinate:a(s.coordinate)}}}),getNearestVertex:n("getNearestVertex",async()=>{const t=await new Promise((t,r)=>e(["../../geometry/operators/proximityOperator"],t,r));return(e,o)=>{const n=t.getNearestVertex(r.fromJSON(e),r.fromJSON(o));return{...n,coordinate:a(n.coordinate)}}})};t.invokeGeometryOp=function e(t,r){const o=s[t];return o.loaded?o.execute.apply(void 0,r):o.load().then(()=>e(t,r))},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});