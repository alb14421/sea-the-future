// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/Cyclical","../../../core/quantityUtils","../../../core/libs/gl-matrix-2/math/vec2","../../../core/libs/gl-matrix-2/factories/vec2f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../support/elevationInfoUtils","../sketch/constraints","../sketch/normalizedPoint","./SnappingAlgorithm","./snappingUtils","./candidates/RightAngleSnappingCandidate","../support/viewUtils","../../support/angularMeasurementUtils"],function(e,t,n,i,r,a,s,o,c,g,l,h,p,d,f){"use strict";class u extends l.SnappingAlgorithm{constructor(e,t,n){super(e,t),this._geodesicLengthMeasurementUtils=n}snapNewVertex(e,t){const n=t.editGeometryOperations.data.parts[0],i=[];if(n.vertices.length<2)return i;const{view:r}=this,a=d.vectorToScreenPoint(e,t.spatialReference,o.absoluteHeightElevationInfo,r),s=n.vertices.at(-1);this._checkForSnappingCandidate(1,i,s.leftSegment,s,s.leftSegment.leftVertex,e,a,t);const c=n.vertices[0];return this._checkForSnappingCandidate(2,i,c.rightSegment,c,c.rightSegment.rightVertex,e,a,t),i}snapExistingVertex(e,t){const n=[],i=t.vertexHandle;if(i.part.vertices.length<3)return n;const{view:r}=this,a=d.vectorToScreenPoint(e,t.spatialReference,o.absoluteHeightElevationInfo,r),s=i.leftSegment,c=i.rightSegment;if(s?.leftVertex.leftSegment){const i=s.leftVertex.leftSegment;this._checkForSnappingCandidate(3,n,i,i.rightVertex,i.leftVertex,e,a,t)}if(c?.rightVertex.rightSegment){const i=c.rightVertex.rightSegment;this._checkForSnappingCandidate(3,n,i,i.leftVertex,i.rightVertex,e,a,t)}return n}_checkForSnappingCandidate(e,r,o,c,l,h,p,d){if(!this.edgeExceedsShortLineThreshold(o,d))return;const u=this.view,V=g.fromAnyMapPoint(c.pos,u,d),v=g.fromAnyMapPoint(l.pos,u,d);!function(e,r,o,c,l,h){(function(e,i,r,o,{spatialReference:c},g){const l=f.radiansGeographicBetweenVec(i,r,c,c);if(null==l)return!1;const h=f.radiansGeographicBetweenVec(r,o,c,c);if(null==h)return!1;const p=Math.sign(t.cyclical2PI.shortestSignedDiff(l,h))*Math.PI*.5,d=n.createAngle(l+p,"radians","geographic"),u=s.create(),m=g.geodesicDistance(r,o,c);return null!=m&&(f.pointFromDistanceAlongAzimuth(u,r,c,n.valueInUnit(m,"meters"),d,"geodesic"),a.subtract(e,u,r),!0)})(e,r,o,c,l,h)||function(e,t,n){const r=i.subtract(m,g.asVec2(n),g.asVec2(t));a.set(e,r[1],-r[0],0)}(e,r,o)}(S,v,V,h,d,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,r,v,V,S,h,p,d)}_checkForSnappingCandidateAlongProjectedRay(e,t,n,r,l,f,u,S){const{spatialReference:V,pointer:v}=S,x=i.subtract(m,g.asVec2(f),g.asVec2(r)),A=i.dot(l,x)/i.squaredLength(l),P=i.scaleAndAdd(m,g.asVec2(r),l,A),y=g.markAsTarget(g.fromValues(P[0],P[1],f[2]));if(h.squaredScreenDistance(u,d.vectorToScreenPoint(y,V,o.absoluteHeightElevationInfo,this.view))>this.squaredProximityThreshold(v)||this.isVertical(y,r,S)||this.isVertical(r,n,S))return;const b=a.scaleAndAdd(s.create(),r,l,Math.sign(A));t.push(new p.RightAngleSnappingCandidate({targetPoint:y,constraint:new c.VerticalHalfPlaneConstraint(r,g.fromVec3(b)),previousVertex:n,otherVertex:r,otherVertexType:1,selfSnappingType:e,isDraped:"on-the-ground"===S.elevationInfo?.mode}))}}const m=r.create(),S=s.create();e.RightAngleSnapper=u,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});