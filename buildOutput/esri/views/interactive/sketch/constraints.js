// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/mathUtils","../../../core/libs/gl-matrix-2/math/vec2","../../../core/libs/gl-matrix-2/factories/vec2f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../chunks/vec42","../../../core/libs/gl-matrix-2/factories/vec4f64","../../../geometry/support/geodesicConstants","../../../geometry/support/geodesicUtils","../../../geometry/support/plane","../../../chunks/sphere","../../3d/support/mathUtils","./normalizedPoint","../../support/geometry3dUtils"],function(e,t,s,n,r,i,c,a,o,l,u,d,h,f,p,P){"use strict";class C{intersect(e){return Z(this,e)}closestPoints(e){return[this.closestTo(e)]}}class g extends C{constructor(e){super(),this.point=e}equals(e){return this===e||ee(e)&&i.exactEquals(this.point,e.point)}closestTo(){return p.clone(this.point)}}class L extends C{constructor(e,t,s){super(),this.start=e,this.end=t,this.lineLike={start:e,end:t,type:s}}equals(e){return this===e||te(e)&&this.lineLike.type===e.lineLike.type&&i.exactEquals(this.start,e.start)&&i.exactEquals(this.end,e.end)}closestTo(e){const t=p.createWritable();return P.projectPointToLineLike(e,this.lineLike,t),t}}class V extends L{constructor(e,t){super(e,t,1)}}class m extends L{constructor(e,t){super(e,t,0)}}class _ extends C{constructor(e){super(),this.constraints=e}equals(e){return this===e||$(e)&&t.equals(this.constraints,e.constraints,(e,t)=>e.equals(t))}closestTo(e){let t,s=1/0;for(const n of this.constraints){const r=n.closestTo(e),c=i.squaredDistance(e,r);c<s&&(s=c,t=r)}return p.clone(t??e)}closestPoints(e){return this.constraints.flatMap(t=>t===this?[]:t.closestPoints(e))}}class k extends C{constructor(e,t){super(),this.center=e,this.radius=t}equals(e){return this===e||re(e)&&this.center[0]===e.center[0]&&this.center[1]===e.center[1]&&this.radius===e.radius}closestTo(e){const t=p.createWritable();return P.projectPointToVerticalCylinder(e,this.center,this.radius,t),t}}class x extends C{constructor(e,t){super(),this.center=e,this.radius=t}equals(e){return this===e||ie(e)&&i.exactEquals(this.center,e.center)&&this.radius===e.radius}closestTo(e){const t=p.createWritable();return P.projectPointToVerticalCylinder(e,this.center,this.radius,t),t[2]=this.center[2],t}asCircle(){return new y(p.clone(this.center),this.radius,p.fromValues(0,0,1))}}class y extends C{constructor(e,t,s,n=void 0){super(),this.center=e,this.radius=t,this.normal=s,this.slicePlane=n}equals(e){return this===e||ce(e)&&i.exactEquals(this.center,e.center)&&i.exactEquals(this.normal,e.normal)&&this.radius===e.radius}closestTo(e){const{center:t,radius:s}=this;d.projectPoint(this.getPlane(A),e,q);const n=i.sub(q,q,t),r=i.squaredLength(n);if(P.isClose(r,0))return p.clone(e);const c=s/Math.sqrt(r),a=p.createWritable();i.scaleAndAdd(a,t,n,c);const{slicePlane:o}=this;if(o&&!P.isPointInsidePlane(o,a)){const t=U(o,this);return t?.closestTo(e)??p.clone(e)}return a}getPlane(e=d.create()){return d.fromPositionAndNormal(this.center,this.normal,e)}}const q=c.create(),A=d.create();class v extends C{constructor(e){super(),this.z=e}equals(e){return this===e||se(e)&&this.z===e.z}closestTo(e){return p.fromValues(e[0],e[1],this.z)}getPlane(e=d.create()){return i.set(z,0,0,this.z),d.fromPositionAndNormal(z,c.UNIT_Z,e)}}const z=c.create();class T extends C{constructor(e,t,s){super(),this.start=e,this.end=t,this.planeLike={start:p.asVec2(e),end:p.asVec2(t),type:s}}equals(e){return this===e||ne(e)&&this.planeLike.type===e.planeLike.type&&i.exactEquals(this.start,e.start)&&i.exactEquals(this.end,e.end)}closestTo(e){const t=p.createWritable();return P.projectPointToVerticalPlane(e,this.planeLike,t),t}closestEndTo(e){const{start:t,end:s}=this.planeLike;return Math.sign(n.dot(n.subtract(M,s,t),n.subtract(b,p.asVec2(e),t)))>0?this.end:this.start}getPlane(e=d.create()){const t=i.copy(w,this.end);return t[2]+=1,d.fromPoints(this.start,this.end,t,e)}getSlicePlane(e=d.create()){const{start:t,end:s,type:n}=this.planeLike;if(0===n)return;const r=i.set(w,t[0],t[1],0),c=i.set(S,s[0],s[1],0),a=i.subtract(S,c,r);return d.fromPositionAndNormal(r,a,e),e}}const M=r.create(),b=r.create(),w=c.create(),S=c.create();class D extends C{constructor(e,t){super(),this.sphere=h.fromCenterAndRadius(e,t)}equals(e){return this===e||ae(e)&&h.exactEquals(this.sphere,e.sphere)}closestTo(e){const t=p.createWritable();return h.projectPoint(this.sphere,e,t),t}get center(){return h.getCenter(this.sphere)}get radius(){return this.sphere[3]}}class E extends C{constructor(e,t,s){super(),this.start=e,this.end=t,this.getZ=s,this.planeLike={start:p.asVec2(e),end:p.asVec2(t),type:0}}equals(e){return this===e||oe(e)&&i.exactEquals(this.start,e.start)&&i.exactEquals(this.end,e.end)&&this.getZ===e.getZ}closestTo(e){return function(e,t){const s=p.createWritable();return P.projectPointToVerticalPlane(t,e.planeLike,s),s[2]=e.getZ(s[0],s[1])??le,s}(this,e)}addIfOnTheGround(e,t){for(const s of t){const t=this.getZ(s[0],s[1])??0;P.isClose(s[2],t)&&(s[2]=t,e.push(s))}}}class I extends C{constructor(e,t,s){super(),this._x=e,this._y=t,this._z=s}equals(e){return this===e||e instanceof I&&this._x===e._x&&this._y===e._y&&this._z===e._z}closestTo([e,t,s]){return p.create(this._x??e,this._y??t,this._z??s)}}class R extends C{constructor(e,t,s,n,r){super(),this._origin=e,this._spatialReference=t,this._distanceMeters=s,this._z=n,this._directionDegrees=r}equals(e){return this===e||e instanceof R&&n.exactEquals(this._origin,e._origin)&&this._spatialReference===e._spatialReference&&this._distanceMeters===e._distanceMeters&&this._z===e._z&&this._directionDegrees===e._directionDegrees}closestTo([e,t,s]){return n.set(G,e,t),n.exactEquals(G,this._origin)||this._applyDirectionAndDistance(G),p.create(G[0],G[1],this._z??s)}_applyDirectionAndDistance(e){if(null!=this._directionDegrees&&null!=this._distanceMeters)u.directGeodeticSolver(e,this._origin,this._directionDegrees,this._distanceMeters,this._spatialReference);else if(null!=this._directionDegrees)!function(e,t,s,n,r){let{azimuth:i,distance:c}=u.inverseGeodeticSolver(j,t,n,r);i??=0;let a=c*Math.cos((i-s)*l.toRadians);a=Math.max(0,a),u.directGeodeticSolver(e,t,s,a,r)}(e,this._origin,this._directionDegrees,e,this._spatialReference);else if(null!=this._distanceMeters){const{azimuth:t}=u.inverseGeodeticSolver(W,this._origin,e,this._spatialReference);u.directGeodeticSolver(e,this._origin,t??0,this._distanceMeters,this._spatialReference)}}}const G=[0,0],W=new u.InverseGeodeticSolverResult,j=new u.InverseGeodeticSolverResult;function Z(e,t){if($(e)){const s=[];for(const n of e.constraints){const e=n.intersect(t);e&&s.push(e)}return Y(s)}if($(t))return Z(t,e);if(oe(e))return J(e,t);if(oe(t))return J(t,e);if(ee(e)){const{point:s}=e;if(ee(t))return i.exactEquals(s,t.point)?e:void 0;const n=t.closestTo(s);return i.equals(n,s)?e:void 0}if(te(e)){if(ee(t))return Z(t,e);if(te(t))return Q(P.intersectLineLikes(e.lineLike,t.lineLike));if(se(t))return N(e,t);if(ne(t))return Q(P.intersectVerticalPlaneAndLineLike(t.planeLike,e.lineLike));if(re(t))return Q(P.intersectLineLikeAndVerticalCylinder(e.lineLike,t.center,t.radius));if(ce(t))return Q(P.intersectLineLikeAndCircle(e.lineLike,t));if(ie(t))return function({lineLike:e},{center:t,radius:s}){const n=t[2];return Q(P.intersectLineLikeAndVerticalCylinder(e,t,s).filter(e=>P.isClose(e[2],n)))}(e,t);if(ae(t))return function({lineLike:e},{sphere:t}){return Q(h.intersectLine(t,e.start,e.end))}(e,t)}else if(se(e)){if(ee(t)||te(t))return Z(t,e);if(se(t))return function(e,t){return P.isClose(e.z,t.z)?e:void 0}(e,t);if(ne(t))return function({z:e},{planeLike:t}){const[s,n]=t.start,[r,i]=t.end,c=p.fromValues(s,n,e),a=p.fromValues(r,i,e);return 0===t.type?new V(c,a):new m(c,a)}(e,t);if(re(t))return function(e,t){const[s,n]=t.center;return new x(p.fromValues(s,n,e.z),t.radius)}(e,t);if(ce(t))return H(e,t);if(ie(t))return s=e,r=t,P.isClose(r.center[2],s.z)?r:void 0;if(ae(t))return function(e,{center:t,radius:s}){const n=Math.abs(t[2]-e.z);if(n>s&&!P.isClose(n,s))return;const r=p.fromValues(t[0],t[1],e.z),i=Math.sqrt(s**2-n**2);return P.isClose(i,0)?void 0:new x(r,i)}(e,t)}else if(ne(e)){if(ee(t)||te(t)||se(t))return Z(t,e);if(ne(t))return K(P.intersectVerticalPlanes(e.planeLike,t.planeLike));if(re(t))return K(P.intersectVerticalPlaneAndVerticalCylinder(e.planeLike,t.center,t.radius));if(ce(t))return F(e,t);if(ie(t))return O(e,t);if(ae(t))return B(e,t)}else if(re(e)){if(ee(t)||te(t)||se(t)||ne(t))return Z(t,e);if(re(t))return K(P.intersectVerticalCylinders(p.asVec2(e.center),e.radius,p.asVec2(t.center),t.radius));if(ce(t))return;if(ie(t))return function(e,t){const s=n.squaredDistance(p.asVec2(e.center),p.asVec2(t.center));return P.isClose(s,0)&&P.isClose(e.radius,t.radius)?t:X(P.intersectVerticalCylinders(p.asVec2(e.center),e.radius,p.asVec2(t.center),t.radius),t.center[2])}(e,t);if(ae(t))return}else if(ce(e)){if(ee(t)||te(t)||se(t)||ne(t)||re(t))return Z(t,e);if(ce(t))return;if(ie(t))return void t.asCircle();if(ae(t))return}else if(ie(e)){if(ee(t)||te(t)||se(t)||ne(t)||re(t)||ce(t))return Z(t,e);if(ie(t))return function(e,t){if(!P.vectorsHaveCloseZ(e.center,t.center))return;const s=n.squaredDistance(p.asVec2(e.center),p.asVec2(t.center));return P.isClose(s,0)&&P.isClose(e.radius,t.radius)?e:X(P.intersectVerticalCylinders(p.asVec2(e.center),e.radius,p.asVec2(t.center),t.radius),e.center[2])}(t,e);if(ae(t))return}else if(ae(e)){if(ee(t)||te(t)||se(t)||ne(t)||re(t)||ie(t))return Z(t,e);if(ae(t))return}var s,r}const N=(()=>{const e=d.create();return(t,s)=>{const{start:n,end:r}=t;if(P.vectorsHaveCloseZ(n,r)&&P.isClose(n[2],s.z))return t;const i=p.createWritable();return d.intersectLine(s.getPlane(e),n,r,i)?new g(i):void 0}})(),U=(()=>{const e=o.create(),t=c.create(),n=c.create();return(r,o,l)=>{const{normal:u,center:h,radius:C}=o;f.tangentFrame(u,t,n);const L=d.getNormal(r),V=C*i.dot(L,t),m=C*i.dot(L,n);a.set(e,h[0],h[1],h[2],1);const _=a.dot(r,e),k=Math.hypot(V,m),x=P.isClose(k,0);if(P.isClose(d.distance(r,h),0)){if(x)return o;if(P.isClose(C,0))return!l||P.isPointInsidePlane(l,h)?new g(p.clone(h)):void 0;i.cross(t,L,u),i.normalize(t,t);const e=new Array,s=c.clone(h);i.scaleAndAdd(s,s,t,C),l&&!P.isPointInsidePlane(l,s)||e.push(s);const n=c.clone(h);return i.scaleAndAdd(n,n,t,-C),l&&!P.isPointInsidePlane(l,n)||e.push(n),Q(e)}if(x)return;const y=-_/k;if(Math.abs(y)>1||P.isClose(y,1))return;const q=Math.atan(V/m),A=s.asinClamped(y)-q,v=Math.PI-A,z=new Array,T=c.create();i.scaleAndAdd(T,h,t,C*Math.cos(A)),i.scaleAndAdd(T,T,n,C*Math.sin(A)),z.push(T);const M=c.create();return i.scaleAndAdd(M,h,t,C*Math.cos(v)),i.scaleAndAdd(M,M,n,C*Math.sin(v)),z.push(M),Q(l?P.pointsInsidePlane(l,z):z)}})(),H=(()=>{const e=d.create();return(t,s)=>U(t.getPlane(e),s,s.slicePlane)})(),O=(()=>{const e=d.create();return(t,{center:s,radius:n})=>{const r=P.intersectVerticalPlaneAndVerticalCylinder(t.planeLike,s,n),i=s[2];t.getSlicePlane(e);const c=new Array;for(const[t,s]of r){const n=[t,s,i];P.isPointInsidePlane(e,n)&&c.push(n)}return Q(c)}})(),F=(()=>{const e=d.create(),t=d.create();return(s,n)=>U(s.getPlane(e),n,s.getSlicePlane(t))})(),B=(()=>{const e=d.create();return(t,{center:s,radius:n})=>{const r=t.getPlane(e),a=d.signedDistance(r,s),o=Math.abs(a);if(o>n&&!P.isClose(o,n))return;const l=Math.sqrt(n**2-a**2);if(P.isClose(l,0)){const e=p.createWritable();return d.projectPoint(r,s,e),new g(e)}const u=p.createWritable(),h=c.clone(d.getNormal(r));return i.scaleAndAdd(u,s,h,a),new y(u,l,h,t.getSlicePlane())}})();function J(e,t){const{planeLike:s,getZ:n}=e,r=new Array;if(ee(t))e.addIfOnTheGround(r,P.intersectVerticalPlaneAndPoint(s,t.point));else if(te(t))e.addIfOnTheGround(r,P.intersectVerticalPlaneAndLineLike(s,t.lineLike));else if(re(t))for(const[e,i]of P.intersectVerticalPlaneAndVerticalCylinder(s,t.center,t.radius)){const t=n(e,i);null!=t&&r.push(c.fromValues(e,i,t))}else if(ne(t)||oe(t))for(const[e,i]of P.intersectVerticalPlanes(s,t.planeLike)){const t=n(e,i)??le;r.push(c.fromValues(e,i,t))}return Q(r)}function K(e){return Y(e.map(([e,t])=>{const s=p.fromValues(e,t,0),n=p.fromValues(e,t,1);return new V(s,n)}))}function Q(e){return Y(e.map(e=>e?new g(p.fromVec3(e)):void 0))}function X(e,t){return Q(e.map(([e,s])=>[e,s,t]))}function Y(e){if(0!==e.length)return 1===e.length?e[0]??void 0:new _(e.filter(t.isSome))}function $(e){return e instanceof _}function ee(e){return e instanceof g}function te(e){return e instanceof L}function se(e){return e instanceof v}function ne(e){return e instanceof T}function re(e){return e instanceof k}function ie(e){return e instanceof x}function ce(e){return e instanceof y}function ae(e){return e instanceof D}function oe(e){return e instanceof E}const le=0;e.CircleConstraint=y,e.Constraint=C,e.CoordinateConstraint=I,e.DrapedLineConstraint=E,e.GeodesicConstraint=R,e.HorizontalCircleConstraint=x,e.HorizontalPlaneConstraint=v,e.LineConstraint=V,e.LineLikeConstraint=L,e.PointConstraint=g,e.RayConstraint=m,e.SetConstraint=_,e.SphereConstraint=D,e.VerticalCylinderConstraint=k,e.VerticalHalfPlaneConstraint=class extends T{constructor(e,t){super(e,t,1)}},e.VerticalPlaneConstraint=class extends T{constructor(e,t){super(e,t,0)}},e.VerticalPlaneLikeConstraint=T,e.constraintOrSet=Y,e.isPoint=ee,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});