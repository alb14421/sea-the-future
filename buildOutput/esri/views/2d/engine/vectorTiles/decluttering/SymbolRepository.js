// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./core","./util"],function(e,t,i){"use strict";class s{static fromSymbols(e,t){let r=e.length;if(r>=l){let l=t;do{l/=2,r/=4}while(r>o&&l>n);const y=new i.GridIndex(t,t,l);for(const t of e)y.getCell(t.xTile,t.yTile).push(t);return new s(t,e,y)}return new s(t,e,null)}constructor(e,t,i){this.tileCoordRange=e,this._symbols=t,this._index=i}addSymbols(e){for(const t of e)this._symbols.push(t);if(this._index)for(const t of e)this._index.getCell(t.xTile,t.yTile).push(t)}removeSymbols(e){const t=new Set(e);if(this._symbols=this._symbols.filter(e=>!t.has(e)),this._index)for(const e of this._index.cells)for(let i=0;i<e.length;i++)e[i]=e[i].filter(e=>!t.has(e))}getSymbols(){return this._symbols}getCandidate(e,t,i,s){if(!this._index){for(const l of this._symbols)if(i===l.hash&&Math.abs(e-l.xTile)<=s&&Math.abs(t-l.yTile)<=s)return l;return null}const l=this._index.getCellSpan(e-s,t-s,e+s,t+s),[o,n,r,y]=l;for(let l=n;l<=y;l++)for(let n=o;n<=r;n++){const o=this._index.cells[l][n];for(const l of o)if(i===l.hash&&Math.abs(e-l.xTile)<=s&&Math.abs(t-l.yTile)<=s)return l}return null}}const l=32,o=8,n=64;function r(e){const t=new Map;for(const i of e){const e=i.labelClassId;let s=t.get(e);s||(s=[],t.set(e,s)),s.push(i)}return t}e.SymbolRepository=class{constructor(e,t){this.tileCoordRange=e,this._visibleTiles=t,this._indexMapByTile=new Map,this._uniqueSymbolsByStyleLayerId=new Map}get uniqueSymbols(){return null==this._uniqueSymbolLayerArray&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}registerVectorTile(e,t){const i=this._ensureIndexMap(e),s=t?.values()??i.keys();for(const e of s){const t=i.get(e);t&&(this._removeSymbols(e,t.getSymbols()),i.delete(e))}this._addSymbols(e.key,i,e.symbols),this._invalidate()}unregisterVectorTile(e){this._removeTile(e),this._invalidate()}registerFeatureTile(e){this._ensureIndexMap(e),this._invalidate()}unregisterFeatureTile(e){this._removeTile(e),this._invalidate()}insertFeatureTileMetrics(e,t){const i=this._indexMapByTile.get(e);if(!i)throw new Error(`tile ${e.id} not registered!`);this._addSymbols(e.key,i,r(t)),this._invalidate()}removeFeatureTileMetrics(e,t){const i=this._indexMapByTile.get(e);if(!i)return;const s=r(t);for(const[e,t]of i.entries()){const i=s.get(e);i&&(t.removeSymbols(i),this._removeSymbols(e,i))}this._invalidate()}deleteStyleLayers(e){for(const t of this._indexMapByTile.values())for(const i of e){const e=t.get(i);e&&(this._removeSymbols(i,e.getSymbols()),t.delete(i))}this._invalidate()}querySymbols(e,t,s,l){const o=[];for(const[l,n]of this._uniqueSymbolsByStyleLayerId.entries())for(const r of n){const n=r.tileSymbols.find(e=>e.selectedForRendering);n&&i.isSearchCircleOverlapingSymbol(n,e,t*(window.devicePixelRatio||1),s)&&o.push({vtlSymbol:n,styleLayerUID:l,tileKey:n.tile.key})}return o}_ensureIndexMap(e){let t=this._indexMapByTile.get(e);return t||(t=new Map,this._indexMapByTile.set(e,t)),t}_invalidate(){this._uniqueSymbolLayerArray=null}_addSymbols(e,t,i){for(const[e,l]of i){let i=t.get(e);i?i.addSymbols(l):(i=s.fromSymbols(l,this.tileCoordRange),t.set(e,i))}this._updateUniqueSymbols(e,i)}_removeTile(e){const t=this._indexMapByTile.get(e);if(t){for(const[e,i]of t.entries())this._removeSymbols(e,i.getSymbols());this._indexMapByTile.delete(e),this._invalidate()}}_removeSymbols(e,t){for(const i of t){const t=i.uniqueSymbol;if(t){if(t.tileSymbols=t.tileSymbols.filter(e=>e!==i),0===t.tileSymbols.length){const i=this._uniqueSymbolsByStyleLayerId.get(e);i.delete(t),0===i.size&&this._uniqueSymbolsByStyleLayerId.delete(e)}i.uniqueSymbol=null}}}_updateUniqueSymbols(e,i){if(0!==i.size){for(const t of this._visibleTiles)t.parentTile||t.key.world!==e.world||t.key.level===e.level&&!t.key.equals(e)||this._matchSymbols(t,e,i);for(const[e,s]of i)for(const i of s)if(!i.uniqueSymbol){i.uniqueSymbol=new t.UniqueSymbol(i);let s=this._uniqueSymbolsByStyleLayerId.get(e);s||(s=new Set,this._uniqueSymbolsByStyleLayerId.set(e,s)),s.add(i.uniqueSymbol)}}}_matchSymbols(e,t,s){if(e.key.level>t.level){const i=e.key.level-t.level;if(e.key.row>>i!==t.row||e.key.col>>i!==t.col)return}if(t.level>e.key.level){const i=t.level-e.key.level;if(t.row>>i!==e.key.row||t.col>>i!==e.key.col)return}const l=new Map;for(const[o,n]of s){const s=[],r=20+(e.key.level<t.level?1:1<<e.key.level-t.level),y=this._indexMapByTile.get(e),a=y?.get(o);if(a)for(const l of n){if(l.uniqueSymbol)continue;const o=i.tileCoordChangeX(this.tileCoordRange,l.xTile,t,e.key),n=i.tileCoordChangeY(this.tileCoordRange,l.yTile,t,e.key),y=-20,u=this.tileCoordRange+20;if(!(o>=y&&o<u&&n>=y&&n<u)){s.push(l);continue}const h=a.getCandidate(o,n,l.hash,r),c=h?.uniqueSymbol;c?(l.uniqueSymbol=c,c.tileSymbols.push(l)):s.push(l)}s.length>0&&l.set(o,s)}for(const i of e.childrenTiles||[])this._matchSymbols(i,t,l)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsByStyleLayerId,t=new Array(e.size);let i,s=0;for(const[l,o]of e){const e=new Array(o.size);i=0;for(const t of o)e[i++]=t;t[s]={styleLayerUID:l,uniqueSymbols:e},s++}return t}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});