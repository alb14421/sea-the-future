// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../MemoryBuffer","../../../../webgl/enums","../../../../webgl/VertexAttributeLocations","../../../../webgl/VertexElementDescriptor"],function(t,e,n,o,a){"use strict";class r{constructor(t){this._key=t}get key(){return this._key}get type(){return 7&this._key}defines(){return[]}getStride(){return this._geometryLayout||this._buildAttributesInfo(),this._stride}getAttributeLocations(){return this._geometryLayout||this._buildAttributesInfo(),this._locations}get geometryLayout(){return this._geometryLayout||this._buildAttributesInfo(),this._geometryLayout}getEncodingInfos(){return this._propertyEncodingInfo||this._buildAttributesInfo(),this._propertyEncodingInfo}getUniforms(){return this._uniforms||this._buildAttributesInfo(),this._uniforms}getShaderHeader(){return this._shaderHeader||this._buildAttributesInfo(),this._shaderHeader}getShaderMain(){return this._shaderMain||this._buildAttributesInfo(),this._shaderMain}setDataUniforms(t,e,n,o,a){const r=this.getUniforms();for(const s of r){const{name:r,type:i,getValue:c}=s,u=c(n,e,o,a);if(null!==u)switch(i){case"float":t.setUniform1f(r,u);break;case"vec2":t.setUniform2fv(r,u);break;case"vec4":t.setUniform4fv(r,u)}}}encodeAttributes(t,e,n,o){const a=this.attributesInfo,r=this.getEncodingInfos(),s=[];let i=0,c=0;for(const u of Object.keys(r)){const y=r[u],{type:d,precisionFactor:h,isLayout:l}=a[u],f=l?n.getLayoutProperty(u):n.getPaintProperty(u),_=f.interpolator?.getInterpolationRange(e);let p=0;for(const n of y){const{offset:a,bufferElementsToAdd:r}=n;if(r>0){for(let t=0;t<r;t++)s.push(0);i+=c,c=n.bufferElementsToAdd}const u=o??f.getValue(_?_[p]:e,t);switch(d){case 0:case 1:s[i]|=this._encodeByte(u*(h||1),8*a);break;case 2:case 3:s[i]|=this._encodeShort(u*(h||1),8*a);break;case 4:case 5:s[i]|=this._encodeByte(u*(h||1),8*a),s[i]|=this._encodeByte(u*(h||1),8*a+8);break;case 6:case 7:s[i]|=this._encodeShort(u*(h||1),8*a),s[i]|=this._encodeShort(u*(h||1),8*a+16);break;case 8:case 9:s[i]|=this._encodeByte(u*(h||1),8*a),s[i]|=this._encodeByte(u*(h||1),8*a+8),s[i]|=this._encodeByte(u*(h||1),8*a+16),s[i]|=this._encodeByte(u*(h||1),8*a+24);break;case 10:s[i]=this._encodeColor(u);break;case 11:case 12:this._encodePattern(i,s,u);break;default:throw new Error("Unsupported encoding type")}p++}}return s}getAtributeState(t){let e=0;const n=3+2*t;return e|=this._bit(n),e|=this._bit(n+1)<<1,e}static{this._encodingInfo={0:{dataType:n.DataType.BYTE,bytesPerElement:1,count:1,normalized:!1},1:{dataType:n.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:1,normalized:!1},2:{dataType:n.DataType.SHORT,bytesPerElement:2,count:1,normalized:!1},3:{dataType:n.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:1,normalized:!1},4:{dataType:n.DataType.BYTE,bytesPerElement:1,count:2,normalized:!1},5:{dataType:n.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:2,normalized:!1},6:{dataType:n.DataType.SHORT,bytesPerElement:2,count:2,normalized:!1},7:{dataType:n.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:2,normalized:!1},8:{dataType:n.DataType.BYTE,bytesPerElement:1,count:4,normalized:!1},9:{dataType:n.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!1},10:{dataType:n.DataType.UNSIGNED_BYTE,bytesPerElement:1,count:4,normalized:!0},11:{dataType:n.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1},12:{dataType:n.DataType.UNSIGNED_SHORT,bytesPerElement:2,count:4,normalized:!1}}}_buildAttributesInfo(){const t=[],e={},{attributesInfo:o,attributes:a}=this,s={};let i=-1,c=-1;for(const n of a){c++;const a=this.getAtributeState(c);if(0===a||3===a)continue;const u=o[n],y=[];e[n]=y;const d=u.type;for(let e=0;e<a;e++){const{dataType:e,bytesPerElement:n,count:o,normalized:a}=r._encodingInfo[d],c=n*o,u=`${e}-${!0===a}`;let h=s[u],l=0;if(!h||h.count+o>4)i++,h={dataIndex:i,count:0,offset:0},4!==o&&(s[u]=h),t.push({location:-1,name:"a_data_"+i,count:o,type:e,normalized:a}),l=Math.ceil(Math.max(c/4,1));else{const e=t[h.dataIndex];e.count+=o,l=Math.ceil(Math.max(e.count*n/4,1))-Math.ceil(Math.max(h.offset/4,1))}y.push({dataIndex:h.dataIndex,offset:h.offset,bufferElementsToAdd:l}),h.offset+=c,h.count+=o}}for(const e of t)switch(e.type){case n.DataType.BYTE:case n.DataType.UNSIGNED_BYTE:e.count=4;break;case n.DataType.SHORT:case n.DataType.UNSIGNED_SHORT:e.count+=e.count%2}this._buildVertexBufferLayout(t),this._buildShaderInfo(t,e),this._propertyEncodingInfo=e}_buildVertexBufferLayout(t){const e=this.baseGeometryLayout;let n=e[0].stride;if(0===t.length)this._geometryLayout=e;else{const o=[];let r=n;for(const e of t)n+=s(e.type)*e.count;for(const t of e)o.push(new a.VertexElementDescriptor(t.name,t.count,t.type,t.offset,n,t.normalized));for(const e of t)o.push(new a.VertexElementDescriptor(e.name,e.count,e.type,r,n,e.normalized)),r+=s(e.type)*e.count;this._geometryLayout=o}this.opacityLayout?this._locations=o.fromLayouts([this._geometryLayout,this.opacityLayout]):this._locations=o.fromLayout(this._geometryLayout),this._stride=n}_buildShaderInfo(t,e){let n="\n",o="\n";const a=[];for(const e of t)n+=`attribute ${this._getType(e.count)} ${e.name};\n`;const{attributesInfo:s,attributes:c}=this;let u=-1;for(const t of c){u++;const{name:c,type:y,precisionFactor:d,isLayout:h}=s[t],l=d&&1!==d?" * "+1/d:"",{bytesPerElement:f,count:_}=r._encodingInfo[y],p=t=>`a_data_${t.dataIndex}${i(_,t.offset,f)}`;switch(this.getAtributeState(u)){case 0:{const e=this._getType(_),r=`u_${c}`;a.push({name:r,type:e,getValue:(e,n,o,a)=>{const r=h?e.getLayoutValue(t,n):e.getPaintValue(t,n);if(11===y){const t=e.getDashKey(r,e.getLayoutValue("line-cap",n)),o=a.getMosaicItemPosition(t,!1);if(null==o)return null;const{tl:s,br:i}=o;return[s[0],i[1],i[0],s[1]]}if(12===y){const e=a.getMosaicItemPosition(r,!t.includes("line-"));if(null==e)return null;const{tl:n,br:o}=e;return[n[0],o[1],o[0],n[1]]}if(10===y){const t=r[3];return[t*r[0],t*r[1],t*r[2],t]}return r}}),n+=`uniform ${e} ${r};\n`,o+=`${e} ${c} = ${r};\n`}break;case 1:{const n=p(e[t][0]);o+=`${this._getType(_)} ${c} = ${n}${l};\n`}break;case 2:{const r=`u_t_${c}`;a.push({name:r,type:"float",getValue:(e,n,o,a)=>(h?e.getLayoutProperty(t):e.getPaintProperty(t)).interpolator.interpolationUniformValue(o,n)}),n+=`uniform float ${r};\n`;const s=p(e[t][0]),i=p(e[t][1]);o+=`${this._getType(_)} ${c} = mix(${s}${l}, ${i}${l}, ${r});\n`}}}this._shaderHeader=n,this._shaderMain=o,this._uniforms=a}_bit(t){return(this._key&1<<t)>>t}_getType(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4"}throw new Error("Invalid count")}_encodeColor(t){const n=255*t[3];return e.i8888to32(t[0]*n,t[1]*n,t[2]*n,n)}_encodePattern(t,e,n){if(!n?.rect)return;const o=n.rect,a=n.width,r=n.height;e[t]=this._encodeShort(o.x+2,0),e[t]|=this._encodeShort(o.y+2+r,16),e[t+1]=this._encodeShort(o.x+2+a,0),e[t+1]|=this._encodeShort(o.y+2,16)}_encodeByte(t,e){return(255&t)<<e}_encodeShort(t,e){return(65535&t)<<e}}const s=t=>{switch(t){case n.DataType.FLOAT:case n.DataType.INT:case n.DataType.UNSIGNED_INT:return 4;case n.DataType.SHORT:case n.DataType.UNSIGNED_SHORT:case n.DataType.HALF_FLOAT:return 2;case n.DataType.BYTE:case n.DataType.UNSIGNED_BYTE:return 1}},i=(t,e,n)=>{const o=e/n;if(1===t)switch(o){case 0:return".x";case 1:return".y";case 2:return".z";case 3:return".w"}else if(2===t)switch(o){case 0:return".xy";case 1:return".yz";case 2:return".zw"}else if(3===t)switch(o){case 0:return".xyz";case 1:return".yzw"}return""};t.VTLMaterial=r,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});