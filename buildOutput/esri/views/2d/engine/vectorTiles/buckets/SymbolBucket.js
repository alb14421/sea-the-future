// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../../core/BidiEngine","../../../../../core/maybe","../../../../../core/string","../../../../../geometry/support/TileClipper","../constants","../GeometryUtils","../Placement","../TextShaping","./BaseBucket","../style/StyleLayer"],function(e,t,i,n,s,o,a,r,l,h){"use strict";function x(e,t){return e.iconMosaicItem&&t.iconMosaicItem?e.iconMosaicItem.page===t.iconMosaicItem.page?0:e.iconMosaicItem.page-t.iconMosaicItem.page:e.iconMosaicItem&&!t.iconMosaicItem?1:!e.iconMosaicItem&&t.iconMosaicItem?-1:0}class c extends l{constructor(e,t,i,n,s,o,a,r,l){super(t,i,l.getSpriteItems()),this.type=3,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._sourceTileKey=e,this._iconVertexBuffer=n,this._iconIndexBuffer=s,this._textVertexBuffer=o,this._textIndexBuffer=a,this._placementEngine=r,this._workerTileHandler=l}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}static{this._bidiEngine=new e}getResources(e,t,n){const s=this.layer,o=this.zoom;e&&e.setExtent(this.layerExtent);const a=s.getLayoutProperty("icon-image"),r=s.getLayoutProperty("text-field");let l=s.getLayoutProperty("text-transform"),h=s.getLayoutProperty("text-font");const x=[];let d,g,y,f;a&&!a.isDataDriven&&(d=a.getValue(o)),r&&!r.isDataDriven&&(g=r.getValue(o)),l&&l.isDataDriven||(y=s.getLayoutValue("text-transform",o),l=null),h&&h.isDataDriven||(f=s.getLayoutValue("text-font",o),h=null);for(const u of this._features){const m=u.getGeometry(e);if(!m||0===m.length)continue;let p,_;a&&(p=a.isDataDriven?a.getValue(o,u):this._replaceKeys(d,u.values),p&&t(p));let P=!1;if(r&&(_=r.isDataDriven?r.getValue(o,u):this._replaceKeys(g,u.values),_)){switch(_=_.replaceAll("\\n","\n"),l&&(y=l.getValue(o,u)),y){case 2:_=_.toLowerCase();break;case 1:_=_.toUpperCase()}if(c._bidiEngine.hasBidiChar(_)){let e;e="rtl"===c._bidiEngine.checkContextual(_)?"IDNNN":"ICNNN",_=c._bidiEngine.bidiTransform(_,e,"VLYSN"),P=!0}if(_.length>0){h&&(f=h.getValue(o,u));for(const e of f){let t=n[e];t||(t=n[e]=new Set);for(const e of _){const i=e.codePointAt(0);null!=i&&t.add(i)}}}}if(!p&&!_)continue;const M=s.getLayoutValue("symbol-sort-key",o,u),b={feature:u,sprite:p,label:_,rtl:P,geometry:m,hash:(_?i.numericHash(_):0)^(p?i.numericHash(p):0),priority:M,textFont:f};x.push(b)}this._symbolFeatures=x}processFeatures(e){e&&e.setExtent(this.layerExtent);const i=this.layer,n=this.zoom,l=i.getLayoutValue("symbol-placement",n),d=0!==l,g=i.getLayoutValue("symbol-spacing",n)*s.tilePixelRatio,y=i.getLayoutProperty("icon-image"),f=i.getLayoutProperty("text-field"),u=y?new h.IconLayout(i,n,d):null,m=f?new h.TextLayout(i,n,d):null,p=this._workerTileHandler;let _;y&&(_=p.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const P=[];let M=1;m?.size&&(M=m.size/r.sdfGlyphSize);const b=m?m.maxAngle*o.cDegToRad:0,I=m?m.size*s.tilePixelRatio:0;for(const e of this._symbolFeatures){let i,o;u&&_&&e.sprite&&(i=_[e.sprite],i&&i.sdf&&(this._isIconSDF=!0)),i&&u.update(n,e.feature);let h=0;const x=e.label;if(x){t.assertIsSome(m),m.update(n,e.feature);const i=d&&0===m.rotationAlignment?m.keepUpright:m.writingMode&&m.writingMode.includes(1);let a=.5;switch(m.anchor){case 5:case 1:case 7:a=0;break;case 6:case 2:case 8:a=1}let l=.5;switch(m.anchor){case 5:case 3:case 6:l=0;break;case 7:case 4:case 8:l=1}let c=.5;switch(m.justify){case 0:c=a;break;case 1:c=0;break;case 3:c=1}const g=m.letterSpacing*r.sdfGlyphSize,y=d?0:m.maxWidth*r.sdfGlyphSize,f=m.lineHeight*r.sdfGlyphSize,u=e.textFont.map(e=>p.getGlyphItems(e));if(o=new r.TextShaping(u,y,f,g,a,l,c).getShaping(x,e.rtl,i),o&&o.length>0){let e=1e30,t=-1e30;for(const i of o)e=Math.min(e,i.x),t=Math.max(t,i.x);h=(t-e+2*r.sdfGlyphSize)*M*s.tilePixelRatio}}for(let t of e.geometry){const n=[];if(1===l){if(o?.length&&m?.size){const e=m.size*s.tilePixelRatio*(2+Math.min(2,4*Math.abs(m.offset[1])));t=c._smoothVertices(t,e)}c._pushAnchors(n,t,g,h)}else 2===l?c._pushCenterAnchor(n,t):3===e.feature.type?c._pushCentroid(n,t):n.push(new a.Anchor(t[0].x,t[0].y));for(const a of n){if(a.x<0||a.x>s.tileCoordSize||a.y<0||a.y>s.tileCoordSize)continue;if(d&&h>0&&0===m?.rotationAlignment&&!c._honorsTextMaxAngle(t,a,h,b,I))continue;const n={shaping:o,line:t,iconMosaicItem:i,anchor:a,symbolFeature:e,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};P.push(n),this._processFeature(n,u,m)}}}P.sort(x),this._addPlacedGlyphs(),this._symbolInstances=P}serialize(){let e=14;e+=this.layerUIDs.length,e+=3*this.markerPageMap.size,e+=3*this.glyphsPageMap.size,e+=c._symbolsSerializationLength(this._symbolInstances),e+=this._iconVertexBuffer.array.length,e+=this._iconIndexBuffer.array.length,e+=this._textVertexBuffer.array.length,e+=this._textIndexBuffer.array.length;const t=new Uint32Array(e),i=new Int32Array(t.buffer),n=new Float32Array(t.buffer),[s,o,a]=this._sourceTileKey.split("/");let r=0;t[r++]=this.type,t[r++]=this.layerUIDs.length;for(let e=0;e<this.layerUIDs.length;e++)t[r++]=this.layerUIDs[e];t[r++]=this._isIconSDF?1:0,t[r++]=parseFloat(s),t[r++]=parseFloat(o),t[r++]=parseFloat(a),t[r++]=this.markerPageMap.size;for(const[e,[i,n]]of this.markerPageMap)t[r++]=e,t[r++]=i,t[r++]=n;t[r++]=this.glyphsPageMap.size;for(const[e,[i,n]]of this.glyphsPageMap)t[r++]=e,t[r++]=i,t[r++]=n;t[r++]=this._iconVertexBuffer.index/4,t[r++]=this._textVertexBuffer.index/4,r=c.serializeSymbols(t,i,n,r,this._symbolInstances),t[r++]=this._iconVertexBuffer.array.length;for(let e=0;e<this._iconVertexBuffer.array.length;e++)i[r++]=this._iconVertexBuffer.array[e];t[r++]=this._iconIndexBuffer.array.length;for(let e=0;e<this._iconIndexBuffer.array.length;e++)t[r++]=this._iconIndexBuffer.array[e];t[r++]=this._textVertexBuffer.array.length;for(let e=0;e<this._textVertexBuffer.array.length;e++)i[r++]=this._textVertexBuffer.array[e];t[r++]=this._textIndexBuffer.array.length;for(let e=0;e<this._textIndexBuffer.array.length;e++)t[r++]=this._textIndexBuffer.array[e];return t.buffer}static _symbolsSerializationLength(e){let t=0;t+=1;for(const i of e||[]){t+=5,t+=1;for(const e of i.textColliders)t+=10;for(const e of i.iconColliders)t+=10;t+=1,t+=2*i.textVertexRanges.length,t+=1,t+=2*i.iconVertexRanges.length}return t}static serializeSymbols(e,t,i,n,s){s=s||[],t[n++]=s.length;for(const e of s){t[n++]=e.anchor.x,t[n++]=e.anchor.y,t[n++]=e.symbolFeature.hash,t[n++]=e.symbolFeature.priority,t[n++]=e.symbolFeature.feature.featureIndex,t[n++]=e.textColliders.length+e.iconColliders.length;for(const s of e.textColliders)t[n++]=s.xTile,t[n++]=s.yTile,t[n++]=s.dxPixels,t[n++]=s.dyPixels,t[n++]=s.hard?1:0,t[n++]=s.partIndex,i[n++]=s.minLod,i[n++]=s.maxLod,t[n++]=s.width,t[n++]=s.height;for(const s of e.iconColliders)t[n++]=s.xTile,t[n++]=s.yTile,t[n++]=s.dxPixels,t[n++]=s.dyPixels,t[n++]=s.hard?1:0,t[n++]=s.partIndex,i[n++]=s.minLod,i[n++]=s.maxLod,t[n++]=s.width,t[n++]=s.height;t[n++]=e.textVertexRanges.length;for(const[i,s]of e.textVertexRanges)t[n++]=i,t[n++]=s;t[n++]=e.iconVertexRanges.length;for(const[i,s]of e.iconVertexRanges)t[n++]=i,t[n++]=s}return n}_replaceKeys(e,t){return e.replaceAll(/{([^{}]+)}/g,(e,i)=>i in t?t[i]:"")}_processFeature(e,t,i){const{line:n,iconMosaicItem:s,shaping:a,anchor:r}=e,l=this.zoom,h=this.layer,x=!!s;let c=!0;x&&(c=t?.optional||!s);const d=a&&a.length>0,g=!d||i?.optional;let y,f;if(x&&(y=this._placementEngine.getIconPlacement(r,s,t)),(y||c)&&(d&&(f=this._placementEngine.getTextPlacement(r,a,n,i)),f||g)){if(y&&f||(g||c?g||f?c||y||(f=null):y=null:(y=null,f=null)),f){const t=h.hasDataDrivenText?h.textMaterial.encodeAttributes(e.symbolFeature.feature,l,h):null;if(this._storePlacedGlyphs(e,f.shapes,l,i.rotationAlignment,t),f.textColliders){e.textColliders=f.textColliders;for(const e of f.textColliders){e.minLod=Math.max(l+o.log2(e.minLod),0),e.maxLod=Math.min(l+o.log2(e.maxLod),25);const t=e.angle;if(t){const i=Math.cos(t),n=Math.sin(t),s=e.dxPixels*i-e.dyPixels*n,o=e.dxPixels*n+e.dyPixels*i,a=(e.dxPixels+e.width)*i-e.dyPixels*n,r=(e.dxPixels+e.width)*n+e.dyPixels*i,l=e.dxPixels*i-(e.dyPixels+e.height)*n,h=e.dxPixels*n+(e.dyPixels+e.height)*i,x=(e.dxPixels+e.width)*i-(e.dyPixels+e.height)*n,c=(e.dxPixels+e.width)*n+(e.dyPixels+e.height)*i,d=Math.min(s,a,l,x),g=Math.max(s,a,l,x),y=Math.min(o,r,h,c),f=Math.max(o,r,h,c);e.dxPixels=d,e.dyPixels=y,e.width=g-d,e.height=f-y}}}}if(y){const i=h.hasDataDrivenIcon?h.iconMaterial.encodeAttributes(e.symbolFeature.feature,l,h):null;if(this._addPlacedIcons(e,y.shapes,l,s.page,1===t.rotationAlignment,i),y.iconColliders){e.iconColliders=y.iconColliders;for(const e of y.iconColliders){e.minLod=Math.max(l+o.log2(e.minLod),0),e.maxLod=Math.min(l+o.log2(e.maxLod),25);const t=e.angle;if(t){const i=Math.cos(t),n=Math.sin(t),s=e.dxPixels*i-e.dyPixels*n,o=e.dxPixels*n+e.dyPixels*i,a=(e.dxPixels+e.width)*i-e.dyPixels*n,r=(e.dxPixels+e.width)*n+e.dyPixels*i,l=e.dxPixels*i-(e.dyPixels+e.height)*n,h=e.dxPixels*n+(e.dyPixels+e.height)*i,x=(e.dxPixels+e.width)*i-(e.dyPixels+e.height)*n,c=(e.dxPixels+e.width)*n+(e.dyPixels+e.height)*i,d=Math.min(s,a,l,x),g=Math.max(s,a,l,x),y=Math.min(o,r,h,c),f=Math.max(o,r,h,c);e.dxPixels=d,e.dyPixels=y,e.width=g-d,e.height=f-y}}}}}}_addPlacedIcons(e,t,i,n,s,a){const r=Math.max(i-1,0),l=this._iconVertexBuffer,h=this._iconIndexBuffer,x=this._markerMap;for(const c of t){const t=s?0:Math.max(i+o.log2(c.minzoom),r),d=s?25:Math.min(i+o.log2(c.maxzoom),25);if(d<=t)continue;const g=c.tl,y=c.tr,f=c.bl,u=c.br,m=c.mosaicRect,p=c.labelAngle,_=c.minAngle,P=c.maxAngle,M=c.anchor,b=l.index,I=m.x,A=m.y,V=I+m.width,w=A+m.height,L=l.index;l.add(M.x,M.y,g.x,g.y,I,A,p,_,P,t,d,a),l.add(M.x,M.y,y.x,y.y,V,A,p,_,P,t,d,a),l.add(M.x,M.y,f.x,f.y,I,w,p,_,P,t,d,a),l.add(M.x,M.y,u.x,u.y,V,w,p,_,P,t,d,a),e.iconVertexRanges.length>0&&e.iconVertexRanges[0][0]+e.iconVertexRanges[0][1]===L?e.iconVertexRanges[0][1]+=4:e.iconVertexRanges.push([L,4]),h.add(b,b+1,b+2),h.add(b+1,b+2,b+3),x.has(n)?x.get(n)[1]+=6:x.set(n,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const e=this._textVertexBuffer,t=this._textIndexBuffer,i=this._glyphMap;for(const[n,s]of this._glyphBufferDataStorage)for(const o of s){const s=e.index,a=o.symbolInstance,r=o.ddAttributes,l=e.index;e.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tl[0],o.tl[1],o.xmin,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,r),e.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tr[0],o.tr[1],o.xmax,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,r),e.add(o.glyphAnchor[0],o.glyphAnchor[1],o.bl[0],o.bl[1],o.xmin,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,r),e.add(o.glyphAnchor[0],o.glyphAnchor[1],o.br[0],o.br[1],o.xmax,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,r),a.textVertexRanges.length>0&&a.textVertexRanges[0][0]+a.textVertexRanges[0][1]===l?a.textVertexRanges[0][1]+=4:a.textVertexRanges.push([l,4]),t.add(s,s+1,s+2),t.add(s+1,s+2,s+3),i.has(n)?i.get(n)[1]+=6:i.set(n,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(e,t,i,n,s){const a=Math.max(i-1,0),r=1===n;let l,h,x,c,d,g,y,f,u,m,p;for(const n of t)l=r?0:Math.max(i+o.log2(n.minzoom),a),h=r?25:Math.min(i+o.log2(n.maxzoom),25),h<=l||(x=n.tl,c=n.tr,d=n.bl,g=n.br,y=n.labelAngle,f=n.minAngle,u=n.maxAngle,m=n.anchor,p=n.mosaicRect,this._glyphBufferDataStorage.has(n.page)||this._glyphBufferDataStorage.set(n.page,[]),this._glyphBufferDataStorage.get(n.page).push({glyphAnchor:[m.x,m.y],tl:[x.x,x.y],tr:[c.x,c.y],bl:[d.x,d.y],br:[g.x,g.y],xmin:p.x,ymin:p.y,xmax:p.x+p.width,ymax:p.y+p.height,labelAngle:y,minAngle:f,maxAngle:u,minLod:l,maxLod:h,placementLod:a,symbolInstance:e,ddAttributes:s}))}static _pushAnchors(e,t,i,s){i+=s;let r=0;const l=t.length-1;for(let e=0;e<l;e++)r+=n.Point.distance(t[e],t[e+1]);let h=s||i;if(h*=.5,r<=h)return;const x=h/r;let c=0,d=-(i=r/Math.max(Math.round(r/i),1))/2;const g=t.length-1;for(let n=0;n<g;n++){const s=t[n],r=t[n+1],l=r.x-s.x,h=r.y-s.y,g=Math.sqrt(l*l+h*h);let y;for(;d+i<c+g;){d+=i;const t=(d-c)/g,f=o.interpolate(s.x,r.x,t),u=o.interpolate(s.y,r.y,t);void 0===y&&(y=Math.atan2(h,l)),e.push(new a.Anchor(f,u,y,n,x))}c+=g}}static _pushCenterAnchor(e,t){let i=0;const s=t.length-1;for(let e=0;e<s;e++)i+=n.Point.distance(t[e],t[e+1]);const r=i/2;let l=0;const h=t.length-1;for(let i=0;i<h;i++){const n=t[i],s=t[i+1],h=s.x-n.x,x=s.y-n.y,c=Math.sqrt(h*h+x*x);if(r<l+c){const t=(r-l)/c,d=o.interpolate(n.x,s.x,t),g=o.interpolate(n.y,s.y,t),y=Math.atan2(x,h);return void e.push(new a.Anchor(d,g,y,i,0))}l+=c}}static _deviation(e,t,i){const n=(t.x-e.x)*(i.x-t.x)+(t.y-e.y)*(i.y-t.y),s=(t.x-e.x)*(i.y-t.y)-(t.y-e.y)*(i.x-t.x);return Math.atan2(s,n)}static _honorsTextMaxAngle(e,t,i,s,o){let a=0;const r=i/2;let l=new n.Point(t.x,t.y),h=t.segment+1;for(;a>-r;){if(--h,h<0)return!1;a-=n.Point.distance(e[h],l),l=e[h]}a+=n.Point.distance(e[h],e[h+1]);const x=[];let c=0;const d=e.length;for(;a<r;){const t=e[h];let i,r=h;do{if(++r,r===d)return!1;i=e[r]}while(i.isEqual(t));let l,g=r;do{if(++g,g===d)return!1;l=e[g]}while(l.isEqual(i));const y=this._deviation(t,i,l);for(x.push({deviation:y,distToAnchor:a}),c+=y;a-x[0].distToAnchor>o;)c-=x.shift().deviation;if(Math.abs(c)>s)return!1;a+=n.Point.distance(i,l),h=r}return!0}static _smoothVertices(e,t){if(t<=0)return e;let i=e.length;if(i<3)return e;const s=[];let o=0,a=0;s.push(0);for(let t=1;t<i;t++){const i=n.Point.distance(e[t],e[t-1]);i>0&&(o+=i,s.push(o),a++,a!==t&&(e[a]=e[t]))}if(i=a+1,i<3)return e;t=Math.min(t,.2*o);const r=e[0].x,l=e[0].y,h=e[i-1].x,x=e[i-1].y,c=n.Point.sub(e[0],e[1]);c.normalize(),e[0].x+=t*c.x,e[0].y+=t*c.y,c.assignSub(e[i-1],e[i-2]),c.normalize(),e[i-1].x+=t*c.x,e[i-1].y+=t*c.y,s[0]-=t,s[i-1]+=t;const d=[];d.push(new n.Point(r,l));const g=1e-6,y=.5*t;for(let o=1;o<i-1;o++){let a=0,r=0,l=0;for(let i=o-1;i>=0;i--){const n=y+s[i+1]-s[o];if(n<0)break;const h=s[i+1]-s[i],x=s[o]-s[i]<y?1:n/h;if(x<g)break;const c=x*x,d=x*n-.5*c*h,f=x*h/t,u=e[i+1],m=e[i].x-u.x,p=e[i].y-u.y;a+=f/d*(u.x*x*n+.5*c*(n*m-h*u.x)-c*x*h*m/3),r+=f/d*(u.y*x*n+.5*c*(n*p-h*u.y)-c*x*h*p/3),l+=f}for(let n=o+1;n<i;n++){const i=y-s[n-1]+s[o];if(i<0)break;const h=s[n]-s[n-1],x=s[n]-s[o]<y?1:i/h;if(x<g)break;const c=x*x,d=x*i-.5*c*h,f=x*h/t,u=e[n-1],m=e[n].x-u.x,p=e[n].y-u.y;a+=f/d*(u.x*x*i+.5*c*(i*m-h*u.x)-c*x*h*m/3),r+=f/d*(u.y*x*i+.5*c*(i*p-h*u.y)-c*x*h*p/3),l+=f}d.push(new n.Point(a/l,r/l))}return d.push(new n.Point(h,x)),e[0].x=r,e[0].y=l,e[i-1].x=h,e[i-1].y=x,d}static _pushCentroid(e,t){const i=s.tileCoordSize,n=s.tileCoordSize,o=t.length-1;let r=0,l=0,h=0,x=t[0].x,c=t[0].y;x>i&&(x=i),x<0&&(x=0),c>n&&(c=n),c<0&&(c=0);for(let e=1;e<o;e++){let s=t[e].x,o=t[e].y,a=t[e+1].x,d=t[e+1].y;s>i&&(s=i),s<0&&(s=0),o>n&&(o=n),o<0&&(o=0),a>i&&(a=i),a<0&&(a=0),d>n&&(d=n),d<0&&(d=0);const g=(s-x)*(d-c)-(a-x)*(o-c);r+=g*(x+s+a),l+=g*(c+o+d),h+=g}r/=3*h,l/=3*h,isNaN(r)||isNaN(l)||e.push(new a.Anchor(r,l))}}return c});