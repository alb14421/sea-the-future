// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["./BaseBucket","../../webgl/TurboLine"],function(e,t){"use strict";return class extends e{constructor(e,i,n,s,r){var l;super(e,i,n),this.type=2,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=s,this.tessellationProperties._lineIndexBuffer=r,this._lineTessellator=new t.LineTessellation((l=this.tessellationProperties,(e,t,i,n,s,r,a,o,u,f,h)=>(l._lineVertexBuffer.add(e,t,a,o,i,n,s,r,u,f,h,l._ddValues),l._lineVertexBuffer.index-1)),(e=>(t,i,n)=>{e._lineIndexBuffer.add(t,i,n)})(this.tessellationProperties),e.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(e,t,i){const n=this.layer,s=this.zoom,r=n.getPaintProperty("line-pattern"),l=n.getPaintProperty("line-dasharray"),a=n.getLayoutProperty("line-cap");if(!r&&!l)return;const o=a?.getValue(s)||0,u=a?.isDataDriven,f=r?.isDataDriven,h=l?.isDataDriven;if(f||h)for(const e of this._features)t(f?r.getValue(s,e):this._getDashArrayKey(e,s,n,l,u,a,o));else if(r)t(r.getValue(s));else if(l){const e=l.getValue(s);t(n.getDashKey(e,o))}}processFeatures(e){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const t=this.layer,i=this.zoom,n=this._features,s=this._tessellationOptions,{hasDataDrivenLine:r,lineMaterial:l}=t;e&&e.setExtent(this.layerExtent);const a=t.getPaintProperty("line-pattern"),o=t.getPaintProperty("line-dasharray"),u=a?.isDataDriven,f=o?.isDataDriven;let h;h=t.getLayoutProperty("line-cap");const p=h?.isDataDriven?h:null,g=p?null:t.getLayoutValue("line-cap",i),y=g||0,d=!!p;h=t.getLayoutProperty("line-join");const c=h?.isDataDriven?h:null,_=c?null:t.getLayoutValue("line-join",i);h=t.getLayoutProperty("line-miter-limit");const x=h?.isDataDriven?h:null,V=x?null:t.getLayoutValue("line-miter-limit",i);h=t.getLayoutProperty("line-round-limit");const D=h?.isDataDriven?h:null,P=D?null:t.getLayoutValue("line-round-limit",i);h=t.getPaintProperty("line-width");const m=h?.isDataDriven?h:null,I=m?null:t.getPaintValue("line-width",i);h=t.getPaintProperty("line-offset");const L=h?.isDataDriven?h:null,B=L?null:t.getPaintValue("line-offset",i);if(u||f){const r=[];for(const s of n){const n=u?a.getValue(i,s):this._getDashArrayKey(s,i,t,o,d,p,y),f=this._spriteInfo[n];if(!f?.rect)continue;const h=l.encodeAttributes(s,i,t,f),v=s.getGeometry(e);r.push({ddAttributes:h,page:f.page,cap:p?p.getValue(i,s):g,join:c?c.getValue(i,s):_,miterLimit:x?x.getValue(i,s):V,roundLimit:D?D.getValue(i,s):P,halfWidth:.5*(m?m.getValue(i,s):I),offset:L?L.getValue(i,s):B,geometry:v})}r.sort((e,t)=>e.page-t.page),s.textured=!0;for(const{ddAttributes:e,page:t,cap:i,join:n,miterLimit:l,roundLimit:a,halfWidth:o,offset:u,geometry:f}of r)s.capType=i,s.joinType=n,s.miterLimit=l,s.roundLimit=a,s.halfWidth=o,s.offset=u,this._processFeature(f,e,t)}else{if(a){const e=a.getValue(i),t=this._spriteInfo[e];if(!t?.rect)return}s.textured=!(!a&&!o),s.capType=g,s.joinType=_,s.miterLimit=V,s.roundLimit=P,s.halfWidth=.5*I,s.offset=B;for(const a of n){const n=r?l.encodeAttributes(a,i,t):null;p&&(s.capType=p.getValue(i,a)),c&&(s.joinType=c.getValue(i,a)),x&&(s.miterLimit=x.getValue(i,a)),D&&(s.roundLimit=D.getValue(i,a)),m&&(s.halfWidth=.5*m.getValue(i,a)),L&&(s.offset=L.getValue(i,a));const o=a.getGeometry(e);this._processFeature(o,n)}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),i=new Int32Array(t.buffer);let n=0;t[n++]=this.type,t[n++]=this.layerUIDs.length;for(let e=0;e<this.layerUIDs.length;e++)t[n++]=this.layerUIDs[e];t[n++]=this._lineIndexStart,t[n++]=this._lineIndexCount;const s=this._patternMap,r=s.size;if(t[n++]=r,r>0)for(const[e,[i,r]]of s)t[n++]=e,t[n++]=i,t[n++]=r;t[n++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let e=0;e<this.tessellationProperties._lineVertexBuffer.array.length;e++)i[n++]=this.tessellationProperties._lineVertexBuffer.array[e];t[n++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let e=0;e<this.tessellationProperties._lineIndexBuffer.array.length;e++)t[n++]=this.tessellationProperties._lineIndexBuffer.array[e];return t.buffer}_processFeature(e,t,i){if(!e)return;const n=e.length;for(let s=0;s<n;s++)this._processGeometry(e[s],t,i)}_processGeometry(e,t,i){if(e.length<2)return;let n,s,r=e[0],l=1;for(;l<e.length;)n=e[l].x-r.x,s=e[l].y-r.y,n*n+s*s<1e-6?e.splice(l,1):(r=e[l],++l);if(e.length<2)return;const a=this.tessellationProperties._lineIndexBuffer,o=3*a.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=t,this._lineTessellator.tessellate(e,this._tessellationOptions);const u=3*a.index-o;if(void 0!==i){const e=this._patternMap,t=e.get(i);t?t[1]+=u:e.set(i,[o+this._lineIndexCount,u])}this._lineIndexCount+=u}_getDashArrayKey(e,t,i,n,s,r,l){const a=s?r.getValue(t,e):l,o=n.getValue(t,e);return i.getDashKey(o,a)}}});