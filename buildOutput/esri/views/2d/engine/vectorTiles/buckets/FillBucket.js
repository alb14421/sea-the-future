// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../../core/ArrayPool","../../../../../chunks/earcut","../../../../../geometry/libtess","../../../../../geometry/support/TileClipper","./BaseBucket"],function(t,e,i,r,l){"use strict";class n extends l{constructor(t,e,i,r,l,n,s){super(t,e,i),this.type=1,this._patternMap=new Map,this._fillVertexBuffer=r,this._fillIndexBuffer=l,this._outlineVertexBuffer=n,this._outlineIndexBuffer=s}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(t,e,i){const r=this.layer,l=this.zoom,n=r.getPaintProperty("fill-pattern");if(n)if(n.isDataDriven)for(const t of this._features)e(n.getValue(l,t),!0);else e(n.getValue(l),!0)}processFeatures(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const e=this.layer,i=this.zoom,{fillMaterial:r,outlineMaterial:l,hasDataDrivenFill:n,hasDataDrivenOutline:s}=e;t&&t.setExtent(this.layerExtent);const a=e.getPaintProperty("fill-pattern"),o=a?.isDataDriven;let f=!a&&e.getPaintValue("fill-antialias",i);if(e.outlineUsesFillColor){if(f&&!e.hasDataDrivenOpacity){const t=e.getPaintValue("fill-opacity",i),r=e.getPaintValue("fill-opacity",i+1);t<1&&r<1&&(f=!1)}if(f&&!e.hasDataDrivenColor){const t=e.getPaintValue("fill-color",i),r=e.getPaintValue("fill-color",i+1);t[3]<1&&r[3]<1&&(f=!1)}}const u=this._features,d=t?.validateTessellation;if(o){const n=[];for(const o of u){const u=a.getValue(i,o),h=this._spriteInfo[u];if(!h?.rect)continue;const x=r.encodeAttributes(o,i,e,h),c=f&&s?l.encodeAttributes(o,i,e):[],_=o.getGeometry(t);n.push({ddFillAttributes:x,ddOutlineAttributes:c,page:h.page,geometry:_}),n.sort((t,e)=>t.page-e.page);for(const{ddFillAttributes:t,ddOutlineAttributes:i,page:r,geometry:l}of n)this._processFeature(l,f,e.outlineUsesFillColor,t,i,d,r)}}else for(const a of u){const o=n?r.encodeAttributes(a,i,e):null,u=f&&s?l.encodeAttributes(a,i,e):null,h=a.getGeometry(t);this._processFeature(h,f,e.outlineUsesFillColor,o,u,d)}}serialize(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const e=new Uint32Array(t),i=new Int32Array(e.buffer);let r=0;e[r++]=this.type,e[r++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)e[r++]=this.layerUIDs[t];e[r++]=this._fillIndexStart,e[r++]=this._fillIndexCount,e[r++]=this._outlineIndexStart,e[r++]=this._outlineIndexCount;const l=this._patternMap,n=l.size;if(e[r++]=n,n>0)for(const[t,[i,n]]of l)e[r++]=t,e[r++]=i,e[r++]=n;e[r++]=this._fillVertexBuffer.array.length;for(let t=0;t<this._fillVertexBuffer.array.length;t++)i[r++]=this._fillVertexBuffer.array[t];e[r++]=this._fillIndexBuffer.array.length;for(let t=0;t<this._fillIndexBuffer.array.length;t++)e[r++]=this._fillIndexBuffer.array[t];e[r++]=this._outlineVertexBuffer.array.length;for(let t=0;t<this._outlineVertexBuffer.array.length;t++)i[r++]=this._outlineVertexBuffer.array[t];e[r++]=this._outlineIndexBuffer.array.length;for(let t=0;t<this._outlineIndexBuffer.array.length;t++)e[r++]=this._outlineIndexBuffer.array[t];return e.buffer}_processFeature(t,e,i,r,l,s,a){if(!t)return;const o=t.length,f=!l||0===l.length;if(e&&(!i||f))for(let e=0;e<o;e++)this._processOutline(t[e],l);let u;for(let e=0;e<o;e++){const i=n._area(t[e]);i>32?(void 0!==u&&this._processFill(t,u,r,s,a),u=[e]):i<-32&&void 0!==u&&u.push(e)}void 0!==u&&this._processFill(t,u,r,s,a)}_processOutline(t,e){const i=this._outlineVertexBuffer,l=this._outlineIndexBuffer,n=l.index;let s,a,o;const f=new r.Point(0,0),u=new r.Point(0,0),d=new r.Point(0,0);let h=-1,x=-1,c=-1,_=-1,y=-1,g=!1,p=t.length;if(p<2)return;const I=t[0];let B=t[p-1];for(;p&&B.isEqual(I);)--p,B=t[p-1];if(!(p-0<2)){for(let r=0;r<p;++r){0===r?(s=t[p-1],a=t[0],o=t[1],f.assignSub(a,s),f.normalize(),f.rightPerpendicular()):(s=a,a=o,o=r!==p-1?t[r+1]:t[0],f.assign(u));const n=this._isClipEdge(s,a);-1===_&&(g=n),u.assignSub(o,a),u.normalize(),u.rightPerpendicular();const I=f.x*u.y-f.y*u.x;d.assignAdd(f,u),d.normalize();const B=-d.x*-f.x+-d.y*-f.y;let V=Math.abs(0!==B?1/B:1);V>8&&(V=8),I>=0?(c=i.add(a.x,a.y,f.x,f.y,0,1,e),-1===_&&(_=c),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c),x=i.add(a.x,a.y,V*-d.x,V*-d.y,0,-1,e),-1===y&&(y=x),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c),h=x,x=c,c=i.add(a.x,a.y,d.x,d.y,0,1,e),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c),x=i.add(a.x,a.y,u.x,u.y,0,1,e),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c)):(c=i.add(a.x,a.y,V*d.x,V*d.y,0,1,e),-1===_&&(_=c),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c),x=i.add(a.x,a.y,-f.x,-f.y,0,-1,e),-1===y&&(y=x),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c),h=x,x=c,c=i.add(a.x,a.y,-d.x,-d.y,0,-1,e),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c),h=i.add(a.x,a.y,-u.x,-u.y,0,-1,e),h>=0&&x>=0&&c>=0&&!n&&l.add(h,x,c))}h>=0&&x>=0&&_>=0&&!g&&l.add(h,x,_),h>=0&&_>=0&&y>=0&&!g&&l.add(h,y,_),this._outlineIndexCount+=3*(l.index-n)}}_processFill(r,l,n,s,a){let o;l.length>1&&(o=[]);let f=0;for(const t of l)0!==f&&o.push(f),f+=r[t].length;const u=2*f,d=t.acquire();for(const t of l){const e=r[t],i=e.length;for(let t=0;t<i;++t)d.push(e[t].x,e[t].y)}const h=e.earcut(d,o,2);if(e.earcut.deviation(d,o,2,h)>0){const t=l.map(t=>r[t].length),{buffer:e,vertexCount:s}=i.triangulate(d,t);if(s>0){const t=this._fillVertexBuffer.index;for(let t=0;t<s;t++)this._fillVertexBuffer.add(e[2*t],e[2*t+1],n);for(let e=0;e<s;e+=3){const i=t+e;this._fillIndexBuffer.add(i,i+1,i+2)}if(void 0!==a){const t=this._patternMap,e=t.get(a);e?e[1]+=s:t.set(a,[this._fillIndexStart+this._fillIndexCount,s])}this._fillIndexCount+=s}}else{const t=h.length;if(t>0){const e=this._fillVertexBuffer.index;let i=0;for(;i<u;)this._fillVertexBuffer.add(d[i++],d[i++],n);let r=0;for(;r<t;)this._fillIndexBuffer.add(e+h[r++],e+h[r++],e+h[r++]);if(void 0!==a){const e=this._patternMap,i=e.get(a);i?i[1]+=t:e.set(a,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}t.release(d)}_isClipEdge(t,e){return t.x===e.x?t.x<=-64||t.x>=4160:t.y===e.y&&(t.y<=-64||t.y>=4160)}static _area(t){let e=0;const i=t.length-1;for(let r=0;r<i;r++)e+=(t[r].x-t[r+1].x)*(t[r].y+t[r+1].y);return e+=(t[i].x-t[0].x)*(t[i].y+t[0].y),.5*e}}return n});