// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../geometry/support/TileClipper","./constants","./GeometryUtils","./TextShaping","./decluttering/config"],function(e,t,i,n,o,l){"use strict";const s=.5;class a{constructor(e,t,i,o,l,s=.5,a=n.cInfinity){this.anchor=e,this.labelAngle=t,this.glyphAngle=i,this.page=o,this.alternateVerticalGlyph=l,this.minzoom=s,this.maxzoom=a}}class h{constructor(e,t,i,n,o,l,s,a,h,c,r,d){this.tl=e,this.tr=t,this.bl=i,this.br=n,this.mosaicRect=o,this.labelAngle=l,this.minAngle=s,this.maxAngle=a,this.anchor=h,this.minzoom=c,this.maxzoom=r,this.page=d}}class c{constructor(e){this.shapes=e}}e.Anchor=class{constructor(e,t,i=0,n=-1,o=.5){this.x=e,this.y=t,this.angle=i,this.segment=n,this.minzoom=o}},e.PlacedSymbol=h,e.Placement=c,e.PlacementEngine=class{getIconPlacement(e,i,o){const s=new t.Point(e.x,e.y),a=0===o.rotationAlignment,h=o.keepUpright;let r=o.rotate*n.cDegToRad;a&&(r+=e.angle);const d=new c([]);return o.allowOverlap&&o.ignorePlacement||!l.declutterTiles||(d.iconColliders=[]),this._addIconPlacement(d,s,i,o,r),a&&h&&this._addIconPlacement(d,s,i,o,r+n.cPi),d}_addIconPlacement(e,i,o,a,c){const r=o.rasterizationScale,d=o.width/r,g=o.height/r,x=a.offset;let p=x[0],y=x[1];switch(a.anchor){case 0:p-=d/2,y-=g/2;break;case 1:y-=g/2;break;case 2:p-=d,y-=g/2;break;case 3:p-=d/2;break;case 4:p-=d/2,y-=g;break;case 5:break;case 7:y-=g;break;case 6:p-=d;break;case 8:p-=d,y-=g}const m=o.rect,w=2/r,f=p-w,P=y-w,u=f+m.width/r,I=P+m.height/r,b=new t.Point(f,P),T=new t.Point(u,I),k=new t.Point(f,I),z=new t.Point(u,P);if(0!==c){const e=Math.cos(c),t=Math.sin(c);b.rotate(e,t),T.rotate(e,t),k.rotate(e,t),z.rotate(e,t)}const G=new h(b,z,k,T,m,c,0,256,i,s,n.cInfinity,0);if(e.shapes.push(G),(!a.allowOverlap||!a.ignorePlacement)&&l.declutterTiles){const t=a.size,o=a.padding,l={xTile:i.x,yTile:i.y,dxPixels:p*t-o,dyPixels:y*t-o,hard:!a.optional,partIndex:0,width:d*t+2*o,height:g*t+2*o,angle:c,minLod:s,maxLod:n.cInfinity};e.iconColliders.push(l)}}getTextPlacement(e,l,r,d){const g=new t.Point(e.x,e.y),x=d.rotate*n.cDegToRad,p=0===d.rotationAlignment,y=d.keepUpright,m=d.padding;let w=s;const f=p?e.angle:0,P=e.segment>=0&&p,u=d.allowOverlap&&d.ignorePlacement?null:[],I=[],b=!P;let T=Number.POSITIVE_INFINITY,k=Number.NEGATIVE_INFINITY,z=T,G=k;const N=(P||p)&&y,A=d.size/o.sdfGlyphSize;let v=!1;for(const e of l)if(e.vertical){v=!0;break}let M,S=0,_=0;if(!P&&v){const e=o.TextShaping.getTextBox(l,d.lineHeight*o.sdfGlyphSize);switch(d.anchor){case 1:S=e.height/2,_=-e.width/2;break;case 2:S=-e.height/2,_=e.width/2;break;case 3:S=e.height/2,_=e.width/2;break;case 4:S=-e.height/2,_=-e.width/2;break;case 5:S=e.height;break;case 7:_=-e.width;break;case 6:_=e.width;break;case 8:S=-e.height}}S+=d.offset[0]*o.sdfGlyphSize,_+=d.offset[1]*o.sdfGlyphSize;for(const c of l){const l=c.glyphMosaicItem;if(!l||l.rect.isEmpty)continue;const E=l.rect,L=l.metrics,V=l.page;if(u&&b){if(void 0!==M&&M!==c.y){let t,i,o,l;v?(t=-G+S,i=T+_,o=G-z,l=k-T):(t=T+S,i=z+_,o=k-T,l=G-z);const a={xTile:e.x,yTile:e.y,dxPixels:t*A-m,dyPixels:i*A-m,hard:!d.optional,partIndex:1,width:o*A+2*m,height:l*A+2*m,angle:x,minLod:s,maxLod:n.cInfinity};u.push(a),T=Number.POSITIVE_INFINITY,k=Number.NEGATIVE_INFINITY,z=T,G=k}M=c.y}const O=[];if(P){const t=.5*l.metrics.width,n=(c.x+L.left-4+t)*A*i.tilePixelRatio;if(w=this._placeGlyph(e,w,n,r,e.segment,1,c.vertical,V,O),y&&(w=this._placeGlyph(e,w,n,r,e.segment,-1,c.vertical,V,O)),w>=2)break}else O.push(new a(g,f,f,V,!1)),p&&y&&O.push(new a(g,f+n.cPi,f+n.cPi,V,!1));const C=c.x+L.left,F=c.y-o.sdfGlyphBaseline-L.top,R=C+L.width,Y=F+L.height;let q,B,U,D,j,H,J,K;if(!P&&v)if(c.vertical){const e=(C+R)/2-L.height/2,i=(F+Y)/2+L.width/2;q=new t.Point(-i-4+S,e-4+_),B=new t.Point(q.x+E.width,q.y+E.height),U=new t.Point(q.x,B.y),D=new t.Point(B.x,q.y)}else q=new t.Point(4-F+S,C-4+_),B=new t.Point(q.x-E.height,q.y+E.width),U=new t.Point(B.x,q.y),D=new t.Point(q.x,B.y);else q=new t.Point(C-4+S,F-4+_),B=new t.Point(q.x+E.width,q.y+E.height),U=new t.Point(q.x,B.y),D=new t.Point(B.x,q.y);for(const i of O){let n,o,l,s;if(i.alternateVerticalGlyph){if(!j){const e=(C+R)/2+S,i=(F+Y)/2+_;j=new t.Point(e-L.height/2-4,i+L.width/2+4),H=new t.Point(j.x+E.height,j.y-E.width),J=new t.Point(H.x,j.y),K=new t.Point(j.x,H.y)}n=j,o=J,l=K,s=H}else n=q,o=U,l=D,s=B;const a=F,r=Y,g=i.glyphAngle+x;if(0!==g){const e=Math.cos(g),t=Math.sin(g);n=n.clone(),o=o?.clone(),l=l?.clone(),s=s?.clone(),n.rotate(e,t),s?.rotate(e,t),o?.rotate(e,t),l?.rotate(e,t)}let p=0,y=256;if(P&&v?c.vertical?i.alternateVerticalGlyph?(p=32,y=96):(p=224,y=32):(p=224,y=96):(p=192,y=64),I.push(new h(n,l,o,s,E,i.labelAngle,p,y,i.anchor,i.minzoom,i.maxzoom,i.page)),u&&(!N||this._legible(i.labelAngle)))if(b)C<T&&(T=C),a<z&&(z=a),R>k&&(k=R),r>G&&(G=r);else if(i.minzoom<2){const t={xTile:e.x,yTile:e.y,dxPixels:(C+S)*A-m,dyPixels:(a+S)*A-m,hard:!d.optional,partIndex:1,width:(R-C)*A+2*m,height:(r-a)*A+2*m,angle:g,minLod:i.minzoom,maxLod:i.maxzoom};u.push(t)}}}if(w>=2)return null;if(u&&b){let t,i,o,l;v?(t=-G+S,i=T+_,o=G-z,l=k-T):(t=T+S,i=z+_,o=k-T,l=G-z);const a={xTile:e.x,yTile:e.y,dxPixels:t*A-m,dyPixels:i*A-m,hard:!d.optional,partIndex:1,width:o*A+2*m,height:l*A+2*m,angle:x,minLod:s,maxLod:n.cInfinity};u.push(a)}const E=new c(I);return u&&u.length>0&&(E.textColliders=u),E}_legible(e){const t=n.radToByte(e);return t<65||t>=193}_placeGlyph(e,i,o,l,s,h,c,r,d){let g=h;const x=g<0?n.positiveMod(e.angle+n.cPi,n.c2pi):e.angle;let p=0;o<0&&(g*=-1,o*=-1,p=n.cPi),g>0&&++s;let y=new t.Point(e.x,e.y),m=l[s],w=n.cInfinity;if(l.length<=s)return w;for(;;){const e=m.x-y.x,t=m.y-y.y,h=Math.sqrt(e*e+t*t),f=Math.max(o/h,i),P=e/h,u=t/h,I=n.positiveMod(Math.atan2(u,P)+p,n.c2pi);if(d.push(new a(y,x,I,r,!1,f,w)),c&&d.push(new a(y,x,I,r,!0,f,w)),f<=i)return f;y=m.clone();do{if(s+=g,l.length<=s||s<0)return f;m=l[s]}while(y.isEqual(m));let b=m.x-y.x,T=m.y-y.y;const k=Math.sqrt(b*b+T*T);b*=h/k,T*=h/k,y.x-=b,y.y-=T,w=f}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});