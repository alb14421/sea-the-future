// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/urlUtils","../../../../core/workers/workers","./GlyphMosaic","./GlyphSource","./SpriteMosaic","../../tiling/TileKey"],function(t,e,s,r,i,o,n,a,l){"use strict";t.TileHandler=class{constructor(t,e,s,r){this._layer=t,this._styleRepository=e,this.devicePixelRatio=s,this._sourceDataMaxLOD=r,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=e.abortMaybe(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(t){this._requestSprite(t);const e=this._layer.currentStyleInfo.glyphsUrl,a=new n(e?r.addQueryParameters(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new o(1024,1024,a),this._broadcastPromise=i.open("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then(e=>{if(this._layer&&(this._connection?.close(),this._connection=e,this._layer&&!this._connection.closed)){const r=e.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},t);Promise.all(r).catch(t=>s.throwIfNotAbortError(t))}})}_requestSprite(t){this._spriteSourceAbortController?.abort();const e=new AbortController;this._spriteSourceAbortController=e;const r=t?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,r&&(this._inputSignalEventListener=function(t){return()=>t.abort()}(e),r.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:i}=e,o={...t,signal:i};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,o),this._spriteSourcePromise.then(t=>{s.throwIfAbortError(i),this._spriteMosaic=new a(1024,1024,250),this._spriteMosaic.setSpriteSource(t)})}async updateStyle(t){const e=[];for(const s of t)4===s.type?e.push({type:4,data:{spriteSource:null}}):e.push(s);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(t){const e=new a(1024,1024,250);return e.setSpriteSource(t),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(t),this._spriteSourceAbortController=null,e}async setStyle(t,e,s){await this._broadcastPromise,this._styleRepository=t,this._sourceDataMaxLOD=s,this._requestSprite();const i=new n(this._layer.currentStyleInfo.glyphsUrl?r.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new o(1024,1024,i),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:e,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(t,e){const s=await this._getRefKeys(t,e);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),s,e)}async fetchTilePBFs(t){const e=Object.keys(this._layer.sourceNameToSource),s={},r=await this._getRefKeys(t,s),i=[],o=[];for(let t=0;t<r.length;t++)if(null==r[t].value||null==e[t])o.push(null);else{const n=r[t].value,a=this._getTilePayload(n,e[t],s);a.then(t=>{i.push({...t,key:n})}),o.push(a)}return Promise.all(o).then(()=>i)}async parseTileData(t,e){const s=t&&t.data;if(!s)return null;const{sourceName2DataAndRefKey:r,transferList:i}=s;return 0===Object.keys(r).length?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:r,styleLayerUIDs:t.styleLayerUIDs},{...e,transferList:i}))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}async _getTilePayload(t,e,r){const i=l.pool.acquire(t.id),o=this._layer.sourceNameToSource[e],{level:n,row:a,col:c}=i;l.pool.release(i);try{return{protobuff:await o.requestTile(n,a,c,r),sourceName:e}}catch(t){if(s.isAbortError(t))throw t;return{protobuff:null,sourceName:e}}}async _getRefKeys(t,e){const r=this._layer.sourceNameToSource,i=new Array;for(const s in r){const o=r[s].getRefKey(t,e);i.push(o)}return s.eachAlways(i)}_getSourcesData(t,e,r){const i=[];for(let s=0;s<e.length;s++)if(null==e[s].value||null==t[s])i.push(null);else{const o=e[s].value,n=this._getTilePayload(o,t[s],r);i.push(n)}return s.eachAlways(i).then(t=>{const s={},r=[];for(let i=0;i<t.length;i++){const o=t[i].value;if(o&&o.protobuff&&o.protobuff.byteLength>0){const t=e[i].value.id;s[o.sourceName]={refKey:t,protobuff:o.protobuff},r.push(o.protobuff)}}return{sourceName2DataAndRefKey:s,transferList:r}})}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});