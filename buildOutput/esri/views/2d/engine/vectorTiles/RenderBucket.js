// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/maybe","../../../../core/memoryEstimations","../../tiling/TileInfoView","../../tiling/TileKey","../../tiling/TileQueue","../../tiling/TileStrategy","./decluttering/util","../../../webgl/BufferObject","../../../webgl/VertexArrayObject","../../../webgl/VertexBuffer"],function(e,t,r,n,i,s,a,o,f,h,c){"use strict";class u{constructor(e,t){this.layerUIDs=[],this.isDestroyed=!1,this._data=e;let r=1;const n=new Uint32Array(e);this.layerUIDs=[];const i=n[r++];for(let e=0;e<i;e++)this.layerUIDs[e]=n[r++];this.bufferDataOffset=r,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(e){null!=this._data&&(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)}}e.CircleRenderBucket=class extends u{constructor(e,t){super(e,t),this.type=4,this.circleIndexStart=0,this.circleIndexCount=0;const r=new Uint32Array(e);let n=this.bufferDataOffset;this.circleIndexStart=r[n++],this.circleIndexCount=r[n++],this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=t.disposeMaybe(this.vao)}doPrepareForRendering(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),s=n[r++],a=this.layer.circleMaterial,o=new c.VertexBuffer(e,a.geometryLayout,new Int32Array(i.buffer,4*r,s));r+=s;const u=n[r++],y=f.BufferObject.createIndex(e,35044,new Uint32Array(n.buffer,4*r,u));r+=u,this.vao=new h.VertexArrayObject(e,o,y)}},e.FillRenderBucket=class extends u{constructor(e,t){super(e,t),this.type=1,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const r=new Uint32Array(e);let n=this.bufferDataOffset;this.fillIndexStart=r[n++],this.fillIndexCount=r[n++],this.outlineIndexStart=r[n++],this.outlineIndexCount=r[n++];const i=r[n++];if(i>0){this.patternMap=new Map;for(let e=0;e<i;e++){const e=r[n++],t=r[n++],i=r[n++];this.patternMap.set(e,[t,i])}}this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.cachedMemory??0)+(this.outlineVAO?.cachedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=t.disposeMaybe(this.fillVAO),this.outlineVAO=t.disposeMaybe(this.outlineVAO)}doPrepareForRendering(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),s=n[r++],a=this.layer,o=a.fillMaterial,u=new c.VertexBuffer(e,o.geometryLayout,new Int32Array(i.buffer,4*r,s));r+=s;const y=n[r++],l=f.BufferObject.createIndex(e,35044,new Uint32Array(n.buffer,4*r,y));r+=y;const d=n[r++],b=a.outlineMaterial,p=new c.VertexBuffer(e,b.geometryLayout,new Int32Array(i.buffer,4*r,d));r+=d;const g=n[r++],x=f.BufferObject.createIndex(e,35044,new Uint32Array(n.buffer,4*r,g));r+=g,this.fillVAO=new h.VertexArrayObject(e,u,l),this.outlineVAO=new h.VertexArrayObject(e,p,x)}},e.LineRenderBucket=class extends u{constructor(e,t){super(e,t),this.type=2,this.lineIndexStart=0,this.lineIndexCount=0;const r=new Uint32Array(e);let n=this.bufferDataOffset;this.lineIndexStart=r[n++],this.lineIndexCount=r[n++];const i=r[n++];if(i>0){this.patternMap=new Map;for(let e=0;e<i;e++){const e=r[n++],t=r[n++],i=r[n++];this.patternMap.set(e,[t,i])}}this.bufferDataOffset=n}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.cachedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=t.disposeMaybe(this.vao)}doPrepareForRendering(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),s=n[r++],a=this.layer.lineMaterial,o=new c.VertexBuffer(e,a.geometryLayout,new Int32Array(i.buffer,4*r,s));r+=s;const u=n[r++],y=f.BufferObject.createIndex(e,35044,new Uint32Array(n.buffer,4*r,u));r+=u,this.vao=new h.VertexArrayObject(e,o,y)}},e.RenderBucketBase=u,e.SymbolRenderBucket=class extends u{constructor(e,t,r){super(e,t),this.type=3,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const n=new Uint32Array(e),s=new Int32Array(e),a=new Float32Array(e);let f=this.bufferDataOffset;this.isIconSDF=!!n[f++];const h=n[f++],c=n[f++],u=n[f++],y=new i(h,c,u,0),l=n[f++];for(let e=0;e<l;e++){const e=n[f++],t=n[f++],r=n[f++];this.iconPerPageElementsMap.set(e,[t,r])}const d=n[f++];for(let e=0;e<d;e++){const e=n[f++],t=n[f++],r=n[f++];this.glyphPerPageElementsMap.set(e,[t,r])}const b=n[f++],p=n[f++];this.iconOpacity=new Int32Array(b),this.textOpacity=new Int32Array(p),f=o.deserializeSymbols(n,s,a,f,this.symbols,r,y),this.bufferDataOffset=f}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.cachedMemory??0)+(this.textVAO?.cachedMemory??0)+r.estimateNumberArrayMemory(this.iconOpacity)+r.estimateNumberArrayMemory(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const t of this.iconPerPageElementsMap.values())e+=t[1];for(const t of this.glyphPerPageElementsMap.values())e+=t[1];return e/3}doDestroy(){this.iconVAO=t.disposeMaybe(this.iconVAO),this.textVAO=t.disposeMaybe(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,t=this.iconVAO.buffer("opacity");e.length>0&&e.byteLength===t.usedMemory&&t.setSubData(e,0,0,e.length);const r=this.textOpacity,n=this.textVAO.buffer("opacity");r.length>0&&r.byteLength===n.usedMemory&&n.setSubData(r,0,0,r.length)}doPrepareForRendering(e,t,r){const n=new Uint32Array(t),i=new Int32Array(n.buffer),s=n[r++],a=this.layer,o=a.iconMaterial,u=new c.VertexBuffer(e,o.geometryLayout,new Int32Array(i.buffer,4*r,s));r+=s;const y=n[r++],l=f.BufferObject.createIndex(e,35044,new Uint32Array(n.buffer,4*r,y));r+=y;const d=n[r++],b=a.textMaterial,p=new c.VertexBuffer(e,b.geometryLayout,new Int32Array(i.buffer,4*r,d));r+=d;const g=n[r++],x=f.BufferObject.createIndex(e,35044,new Uint32Array(n.buffer,4*r,g));r+=g;const A=new c.VertexBuffer(e,o.opacityLayout,this.iconOpacity.buffer),w=new c.VertexBuffer(e,b.opacityLayout,this.textOpacity.buffer);this.iconVAO=new h.VertexArrayObject(e,new Map([["geometry",u],["opacity",A]]),l),this.textVAO=new h.VertexArrayObject(e,new Map([["geometry",p],["opacity",w]]),x)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});