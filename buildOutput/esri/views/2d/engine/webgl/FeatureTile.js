// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/has","../../../../core/Logger","../../../../core/libs/gl-matrix-2/factories/mat2df32","../../../../core/libs/gl-matrix-2/factories/mat3f32","./AFeatureTile","./definitions","./DisplayEntity","./FeatureDisplayList","./ReshufflePlan","./collisions/LabelMetric","./cpuMapped/MappedMesh","./mesh/meshDebugUtils","./util/Reader","./util/serializationUtils"],function(e,t,s,i,r,d,n,o,h,a,l,c,_,u,f){"use strict";let y=0;class p extends d.AFeatureTile{constructor(e,t,s,d,n,o,h=!1){super(e,t,s,d),this._fader=n,this._labelInstanceId=o,this._meshes=new Map,this._entities=[],this._entityIndex=new Map,this._invalidated=!1,this._nextUploadAllowed=!1,this.tileAge=y++,this._metrics=[],this._metricsVisibility=new Set,this._entityIds=new Set,this._entityIdsFromBuffer=new Set,this._attributeEpoch=0,this._encounteredEnd=!1,this.isCoverage=!1,this.rendering=!1,this._decluttered=!1,this._objectIdMap=null,this.visible=!0,this.transforms.labelMat2d=i.create(),this.transforms.tileUnitsToPixels=r.create(),this.enableDeferredUploads=h}destroy(){super.destroy(),this.clear()}clear(){for(const e of this._meshes.values())e.destroy();this._meshes.clear(),this._entities=[],this._fader?.removeFeatureTileMetrics(this,this._metrics),this._metrics=[],this._displayList=null,this._invalidated=!0,this._entityIds.clear(),this._nextUploadAllowed=!0}beforeRender(e){super.beforeRender(e),this._needsReshuffle&&e.reshuffleManager.schedule(this)}tryReady(e){const s=this._invalidated&&!this._uploadAllowed;return!(this.isReady||s||!this._encounteredEnd||!(e>=this._attributeEpoch)||(t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.ready [epoch=${e}]`),this.ready(),this.requestRender(),this.decluttered=!1,0))}get symbols(){const e=new Map;for(const t of this._metrics)e.get(t.labelClassId)||e.set(t.labelClassId,[]),e.get(t.labelClassId).push(t);return e}get decluttered(){return this._decluttered}set decluttered(e){this._decluttered=e,this.requestRender()}get id(){return this.key.id}get hasData(){return!!this._meshes.size}get hasAnimations(){return!!this._objectIdMap}get needsUpload(){return this._invalidated}get _uploadAllowed(){return!this.enableDeferredUploads||this._nextUploadAllowed}get _hasMetrics(){return this._metrics.length>0}upload(){this._nextUploadAllowed=!0}getDisplayList(e,t){if(this._uploadAllowed&&this._invalidated){this._entities.sort((e,t)=>{const s=t.sortKey,i=e.sortKey;return i===s?e.id-t.id:i-s}),0===t&&this.reshuffle(!0),this._displayList=h.DisplayList.fromDisplayEntities(this._entities,this,e,t);for(const e of this._meshes.values())e.upload();this.debugInfo.display.length=this._displayList.length,this.debugInfo.display.minOrderedLength=this._displayList.minOrderedLength,this.debugInfo.display.minUnorderedLength=this._displayList.minUnorderedLength,this.requestRender(),this._invalidated=!1,this._nextUploadAllowed=!1}return this._displayList}getMesh(e){if(!this._meshes.has(e))throw new Error(`InternalError: Unable to find VAO for instance: ${e}`);return this._meshes.get(e)}getSortKeys(e){const t=new Map;for(const{id:s,sortKey:i}of this._entities)if(e.has(s)&&t.set(s,i),t.size===e.size)break;return t}onMessage(e){if(e.objectIdMap)for(const t in e.objectIdMap)this._objectIdMap||(this._objectIdMap={}),this._objectIdMap[t]=e.objectIdMap[t];switch(e.type){case"append":this._onAppendMessage(e);break;case"update":this._onUpdateMessage(e)}if(this._aggregateMemoryStats(),this.requestRender(),e.end){if(t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.end [epoch=${e.attributeEpoch}]`),!e.attributeEpoch)throw new Error("InternalError: Attribute epoch not defined.");this._attributeEpoch=e.attributeEpoch,this._encounteredEnd=!0}this._writeLabelVisibilityToMesh()}_onAppendMessage(e){if(t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.append`,{append:_.debugMeshDataInfo(e?.append)}),e.clear&&this.clear(),!e.append)return;const s=f.deserializeList(new u(e.append.entities),o);this._insert(s,e.append.data,!1)}_onUpdateMessage(e){t("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.update`,{isPixelBuffer:e.isPixelBuffer,modify:_.debugMeshDataInfo(e.modify),remove:e.remove});const s=f.deserializeList(new u(e.modify.entities),o),i=s.map(e=>e.id),r=e.isPixelBuffer??!1,d=[...e.remove,...i];r?this._removeByIdsFromBuffer(d):this._removeByIds(d),this._insert(s,e.modify.data,r)}reshuffle(e=!1){if(this.destroyed)return;const i=new Map;for(const t of this._entities)for(const s of t.records){const t=this._meshes.get(s.instanceId);let r=i.get(t);r||(r=new a.ReshufflePlan(e),i.set(t,r)),r.copyRecord(s)}for(const[e,t]of i)e.reshuffle(t);this._invalidated=!0,this._aggregateMemoryStats(),t("esri-2d-update-debug")&&s.getLogger("esri.views.2d.engine.webgl.FeatureTile").info(`Tile ${this.key.id} was reshuffled.`)}copyPixelBufferedEntitesFrom(e,t,s,i){const r=s*n.tileSize,d=i*n.tileSize;for(const s of e._entities){let i=null;for(const n of s.records)if(n.overlaps&t){const t=e.getMesh(n.instanceId),h=this._ensureMesh(n.instanceId,t.layout,t.useVisibility).copyRecordFrom(t,n,r,d);i||(i=new o(s.id,s.sortKey),this._entityIdsFromBuffer.add(s.id),this._entityIndex.set(i.id,i),this._entities.push(i)),i.records.push(h)}}this._invalidated=!0}get metricsVisibility(){return this._metricsVisibility}copyMetricsVisibility(e){for(const t of e)this._metricsVisibility.add(t);this._writeLabelVisibilityToMesh()}updateLabelVisibility(){this._metricsVisibility.clear();for(const e of this._metrics)e.uniqueSymbol.show&&e.selectedForRendering&&this._metricsVisibility.add(e.hash);this._writeLabelVisibilityToMesh()}_writeLabelVisibilityToMesh(){const e=this._meshes.get(this._labelInstanceId);if(e&&this._hasMetrics){for(const t of this._metrics){const s=this._entityIndex.get(t.id);if(!s)continue;const i=this._metricsVisibility.has(t.hash);e.setEntityRecordRangeVisibility(s.records,t.recordStart,t.recordCount,i?0:255)}this._invalidated=!0}}_ensureMesh(e,t,s){return this._meshes.has(e)||this._meshes.set(e,new c.MappedMesh(this._stage.bufferPool,t,s)),this._meshes.get(e)}_insert(e,t,s){if(!e.length)return;this._removeDuplicatedBufferedEntites(e);const i=this._insertVertexData(t);for(const t of e){for(const e of t.records)e.updateBaseOffsets(i.get(e.instanceId));s?this._tryInsertBufferedEntity(t):this._insertEntity(t)}this._invalidated=!0}_insertMetrics(e){for(const t of e)t.tile=this;this._metrics.push(...e),this._fader?.insertFeatureTileMetrics(this,e)}_insertVertexData(e){const t=new Map;for(const s of e){const{instanceId:e,layout:i}=s,r=i.attributes.some(e=>"visibility"===e.name),d=this._ensureMesh(e,i,r).append(s);if(s.metrics){const e=f.deserializeList(new u(s.metrics),l.LabelMetric)??[];this._insertMetrics(e)}t.set(e,d)}return t}_insertEntity(e){t("esri-2d-update-debug")&&this._entityIds.has(e.id)&&console.error(`Tile ${this.key.id} insertEntity: Already have entityId ${e.id}`),this._entityIds.add(e.id),this._entityIndex.set(e.id,e),this._entities.push(e)}_tryInsertBufferedEntity(e){this._entityIds.has(e.id)?this._removeRecordsFromMesh(e.records):(this._entityIdsFromBuffer.add(e.id),this._entityIndex.set(e.id,e),this._entities.push(e))}_removeDuplicatedBufferedEntites(e){if(!this._entityIdsFromBuffer.size)return;const t=[];for(const s of e)this._entityIdsFromBuffer.has(s.id)&&t.push(s.id);this._removeByIds(t)}_removeByIdsFromBuffer(e){this._removeByIds(e.filter(e=>this._entityIdsFromBuffer.has(e)))}_removeByIds(e){if(0===e.length)return;const t=new Set(e),s=[];for(const e of this._entities)t.has(e.id)?(this._remove(e),this._entityIndex.delete(e.id)):s.push(e);this._entities=s;const i=this._metrics.filter(e=>t.has(e.displayId));this._metrics=this._metrics.filter(e=>!t.has(e.displayId)),this._fader?.removeFeatureTileMetrics(this,i),this._invalidated=!0}_remove(e){this._removeRecordsFromMesh(e.records),this._entityIds.delete(e.id),this._entityIdsFromBuffer.delete(e.id)}_removeRecordsFromMesh(e){for(const t of e){const{instanceId:e,indexStart:s,indexCount:i,vertexStart:r,vertexCount:d}=t;this._meshes.get(e)?.remove(s,i,r,d)}}_aggregateMemoryStats(){this.debugInfo.memory.bytesUsed=0,this.debugInfo.memory.bytesReserved=0;for(const e of this._meshes.values())this.debugInfo.memory.bytesUsed+=e.memoryStats.bytesUsed,this.debugInfo.memory.bytesReserved+=e.memoryStats.bytesReserved}get _needsReshuffle(){if(this.destroyed)return!1;const{bytesUsed:e,bytesReserved:t}=this.debugInfo.memory,s=e/t,{minOrderedLength:i,length:r}=this.debugInfo.display,d=i/r;return t>n.RESHUFFLING_EXEMPT_MEMORY_BYTES&&s<n.RESHUFFLING_TARGET_MEMORY_EFFICIENCY||r>n.RESHUFFLING_EXEMPT_DRAW_CALLS&&d<n.RESHUFFLING_TARGET_DRAW_EFFICIENCY}get entityIds(){return this._objectIdMap?this._entities.map(({id:e})=>({objectId:this._objectIdMap[e],displayId:e})):[]}}e.FeatureTile=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});