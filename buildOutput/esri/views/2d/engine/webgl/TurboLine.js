// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./definitions"],function(t,e){"use strict";function i(t,e){return t.x===e.x&&t.y===e.y}function x(t,e){return t.x=e.y,t.y=-e.x,t}function r(t,e){return t.x=-e.y,t.y=e.x,t}function n(t,e){return t.x=e.x,t.y=e.y,t}function s(t,e){return t.x=-e.x,t.y=-e.y,t}function y(t){return Math.sqrt(t.x*t.x+t.y*t.y)}function o(t,e){return t.x*e.y-t.y*e.x}function h(t,e){return t.x*e.x+t.y*e.y}function l(t,e,i,x){return t.x=e.x*i+e.y*x,t.y=e.x*x-e.y*i,t}t.LineTessellation=class{constructor(t,e,i){this._writeVertex=t,this._writeTriangle=e,this._canUseThinTessellation=i,this._prevNormal={x:void 0,y:void 0},this._nextNormal={x:void 0,y:void 0},this._textureNormalLeft={x:0,y:1},this._textureNormalRight={x:0,y:-1},this._textureNormal={x:void 0,y:void 0},this._joinNormal={x:void 0,y:void 0},this._inner={x:void 0,y:void 0},this._outer={x:void 0,y:void 0},this._roundStart={x:void 0,y:void 0},this._roundEnd={x:void 0,y:void 0},this._startBreak={x:void 0,y:void 0},this._endBreak={x:void 0,y:void 0},this._innerPrev={x:void 0,y:void 0},this._innerNext={x:void 0,y:void 0},this._bevelStart={x:void 0,y:void 0},this._bevelEnd={x:void 0,y:void 0},this._bevelMiddle={x:void 0,y:void 0}}tessellate(t,x,r=this._canUseThinTessellation){!function(t){if(!t)return;const e=t.length;if(e<=1)return;let x=0;for(let r=1;r<e;r++)i(t[r],t[x])||++x===r||(t[x]=t[r]);t.length=x+1}(t),r&&x.halfWidth<e.thinLineHalfWidthThreshold&&!x.offset?this._tessellateThin(t,x):this._tessellate(t,x)}_tessellateThin(t,e){if(t.length<2)return;const i=e.wrapDistance||65535;let x=e.initialDistance||0,r=!1,n=t[0].x,s=t[0].y;const y=t.length;for(let e=1;e<y;++e){r&&(r=!1,x=0);let y=t[e].x,o=t[e].y,h=y-n,l=o-s,_=Math.sqrt(h*h+l*l);if(h/=_,l/=_,x+_>i){r=!0;const t=(i-x)/_;_=i-x,y=(1-t)*n+t*y,o=(1-t)*s+t*o,--e}const a=this._writeVertex(n,s,0,0,h,l,l,-h,0,-1,x),c=this._writeVertex(n,s,0,0,h,l,-l,h,0,1,x);x+=_;const d=this._writeVertex(y,o,0,0,h,l,l,-h,0,-1,x),u=this._writeVertex(y,o,0,0,h,l,-l,h,0,1,x);this._writeTriangle(a,c,d),this._writeTriangle(c,d,u),n=y,s=o}}_tessellate(t,e){const _=t[0],a=t[t.length-1],c=i(_,a),d=c?3:2;if(t.length<d)return;const u=e.pixelCoordRatio,v=null!=e.capType?e.capType:0,f=null!=e.joinType?e.joinType:2,w=null!=e.miterLimit?Math.min(e.miterLimit,4):2,g=null!=e.roundLimit?Math.min(e.roundLimit,1.05):1.05,T=null!=e.halfWidth?e.halfWidth:2,V=!!e.textured;let m,b,N,k=null;const p=this._prevNormal,L=this._nextNormal;let M=-1,E=-1;const S=this._joinNormal;let B,P;const j=this._textureNormalLeft,A=this._textureNormalRight,D=this._textureNormal;let U=-1,W=-1;const R=e.wrapDistance||65535;let q=e.initialDistance||0;const X=this._writeVertex,C=this._writeTriangle,H=(t,e,i,x,r,n)=>{const s=X(b,N,B,P,i,x,t,e,r,n,q);return U>=0&&W>=0&&s>=0&&C(U,W,s),U=W,W=s,s};c&&(m=t[t.length-2],L.x=a.x-m.x,L.y=a.y-m.y,E=y(L),L.x/=E,L.y/=E);let O=!1;for(let e=0;e<t.length;++e){if(O&&(O=!1,q=0),m&&(p.x=-L.x,p.y=-L.y,M=E,q+M>R&&(O=!0)),O){const i=(R-q)/M;M=R-q,m={x:(1-i)*m.x+i*t[e].x,y:(1-i)*m.y+i*t[e].y},--e}else m=t[e];b=m.x,N=m.y;const i=e<=0&&!O,_=e===t.length-1;if(i||(q+=M),k=_?c?t[1]:null:t[e+1],k?(L.x=k.x-b,L.y=k.y-N,E=y(L),L.x/=E,L.y/=E):(L.x=void 0,L.y=void 0),!c){if(i){r(S,L),B=S.x,P=S.y,2===v&&(H(-L.y-L.x,L.x-L.y,L.x,L.y,0,-1),H(L.y-L.x,-L.x-L.y,L.x,L.y,0,1)),1===v&&(H(-L.y-L.x,L.x-L.y,L.x,L.y,-1,-1),H(L.y-L.x,-L.x-L.y,L.x,L.y,-1,1)),1!==v&&0!==v||(H(-L.y,L.x,L.x,L.y,0,-1),H(L.y,-L.x,L.x,L.y,0,1));continue}if(_){x(S,p),B=S.x,P=S.y,1!==v&&0!==v||(H(p.y,-p.x,-p.x,-p.y,0,-1),H(-p.y,p.x,-p.x,-p.y,0,1)),2===v&&(H(p.y-p.x,-p.x-p.y,-p.x,-p.y,0,-1),H(-p.y-p.x,p.x-p.y,-p.x,-p.y,0,1)),1===v&&(H(p.y-p.x,-p.x-p.y,-p.x,-p.y,1,-1),H(-p.y-p.x,p.x-p.y,-p.x,-p.y,1,1));continue}}let a,d,X=-o(p,L);if(Math.abs(X)<.01)h(p,L)>0?(S.x=p.x,S.y=p.y,X=1,a=Number.MAX_VALUE,d=!0):(r(S,L),X=1,a=1,d=!1);else{S.x=(p.x+L.x)/X,S.y=(p.y+L.y)/X,a=y(S);const t=(a-1)*T*u;d=a>4||t>M&&t>E}B=S.x,P=S.y;let C=f;switch(f){case 0:a<1.05&&(C=2);break;case 1:a<g&&(C=2);break;case 2:a>w&&(C=0)}switch(C){case 2:if(H(S.x,S.y,-p.x,-p.y,0,-1),H(-S.x,-S.y,-p.x,-p.y,0,1),_)break;if(V){const t=O?0:q;U=this._writeVertex(b,N,B,P,L.x,L.y,S.x,S.y,0,-1,t),W=this._writeVertex(b,N,B,P,L.x,L.y,-S.x,-S.y,0,1,t)}break;case 0:{const t=X<0;let e,i,y,o;if(t){const t=U;U=W,W=t,e=j,i=A}else e=A,i=j;if(d)y=t?r(this._innerPrev,p):x(this._innerPrev,p),o=t?x(this._innerNext,L):r(this._innerNext,L);else{const e=t?s(this._inner,S):n(this._inner,S);y=e,o=e}const h=t?x(this._bevelStart,p):r(this._bevelStart,p);H(y.x,y.y,-p.x,-p.y,e.x,e.y);const a=H(h.x,h.y,-p.x,-p.y,i.x,i.y);if(_)break;const c=t?r(this._bevelEnd,L):x(this._bevelEnd,L);if(d){const t=this._writeVertex(b,N,B,P,-p.x,-p.y,0,0,0,0,q);U=this._writeVertex(b,N,B,P,L.x,L.y,o.x,o.y,e.x,e.y,q),W=this._writeVertex(b,N,B,P,L.x,L.y,c.x,c.y,i.x,i.y,q),this._writeTriangle(a,t,W)}else{if(V){const t=this._bevelMiddle;t.x=(h.x+c.x)/2,t.y=(h.y+c.y)/2,l(D,t,-p.x,-p.y),H(t.x,t.y,-p.x,-p.y,D.x,D.y),l(D,t,L.x,L.y),U=this._writeVertex(b,N,B,P,L.x,L.y,t.x,t.y,D.x,D.y,q),W=this._writeVertex(b,N,B,P,L.x,L.y,o.x,o.y,e.x,e.y,q)}else{const t=U;U=W,W=t}H(c.x,c.y,L.x,L.y,i.x,i.y)}if(t){const t=U;U=W,W=t}break}case 1:{const t=X<0;let e,i;if(t){const t=U;U=W,W=t,e=j,i=A}else e=A,i=j;const y=t?s(this._inner,S):n(this._inner,S);let o,c;d?(o=t?r(this._innerPrev,p):x(this._innerPrev,p),c=t?x(this._innerNext,L):r(this._innerNext,L)):(o=y,c=y);const u=t?x(this._roundStart,p):r(this._roundStart,p),v=t?r(this._roundEnd,L):x(this._roundEnd,L),f=H(o.x,o.y,-p.x,-p.y,e.x,e.y),w=H(u.x,u.y,-p.x,-p.y,i.x,i.y);if(_)break;const g=this._writeVertex(b,N,B,P,-p.x,-p.y,0,0,0,0,q);d||this._writeTriangle(U,W,g);const T=s(this._outer,y),m=this._writeVertex(b,N,B,P,L.x,L.y,v.x,v.y,i.x,i.y,q);let k,M;const E=a>2;if(E){let e;a!==Number.MAX_VALUE?(T.x/=a,T.y/=a,e=h(p,T),e=(a*(e*e-1)+1)/e):e=-1,k=t?x(this._startBreak,p):r(this._startBreak,p),k.x+=p.x*e,k.y+=p.y*e,M=t?r(this._endBreak,L):x(this._endBreak,L),M.x+=L.x*e,M.y+=L.y*e}l(D,T,-p.x,-p.y);const R=this._writeVertex(b,N,B,P,-p.x,-p.y,T.x,T.y,D.x,D.y,q);l(D,T,L.x,L.y);const C=V?this._writeVertex(b,N,B,P,L.x,L.y,T.x,T.y,D.x,D.y,q):R,O=g,z=V?this._writeVertex(b,N,B,P,L.x,L.y,0,0,0,0,q):g;let F=-1,G=-1;if(E&&(l(D,k,-p.x,-p.y),F=this._writeVertex(b,N,B,P,-p.x,-p.y,k.x,k.y,D.x,D.y,q),l(D,M,L.x,L.y),G=this._writeVertex(b,N,B,P,L.x,L.y,M.x,M.y,D.x,D.y,q)),V?E?(this._writeTriangle(O,w,F),this._writeTriangle(O,F,R),this._writeTriangle(z,C,G),this._writeTriangle(z,G,m)):(this._writeTriangle(O,w,R),this._writeTriangle(z,C,m)):E?(this._writeTriangle(g,w,F),this._writeTriangle(g,F,G),this._writeTriangle(g,G,m)):(this._writeTriangle(g,w,R),this._writeTriangle(g,C,m)),d?(U=this._writeVertex(b,N,B,P,L.x,L.y,c.x,c.y,e.x,e.y,q),W=m):(U=V?this._writeVertex(b,N,B,P,L.x,L.y,c.x,c.y,e.x,e.y,q):f,this._writeTriangle(U,z,m),W=m),t){const t=U;U=W,W=t}break}}}}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});