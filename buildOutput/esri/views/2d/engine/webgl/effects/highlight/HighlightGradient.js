// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../../../core/Logger","../../definitions","./parameters","../../../../../support/HighlightOptions","../../../../../webgl/Texture","../../../../../webgl/TextureDescriptor"],function(o,i,t,e,l,r){"use strict";const h=()=>o.getLogger("esri.views.2d.engine.webgl.painter.highlight.HighlightGradient"),n=[0,0,0,0];return class{constructor(){this.type="single",this._highlightOptions=new e,this._convertedHighlightOptions={fillColor:[0,0,0,0],outlineColor:[0,0,0,0],outlinePosition:0,outlineWidth:0,innerHaloWidth:0,outerHaloWidth:0},this._optionsShadeTexKey="",this._texelData=new Uint8Array(4*t.shadeTextureSize),this._minMaxDistance=[0,0]}setHighlightOptions(o){this._highlightOptions=o}applyHighlightOptions(o,t){this._updateGradientTexture(o),o.bindTexture(this._shadeTex,i.textureBindingHighlight1),t.setUniform2fv("u_minMaxDistance",this._minMaxDistance)}destroy(){this._shadeTex?.dispose(),this._shadeTex=null}getReasonsWithGradients(){return[{activeReasons:(1<<i.maxHighlightReasons)-1,activeGradient:this}]}_updateGradientTexture(o){const i=`${(e=this._highlightOptions).color};${e.haloColor};${e.haloOpacity};${e.fillOpacity};${e.haloWidth};${e.haloBlur}`;var e;if(i===this._optionsShadeTexKey)return;this._optionsShadeTexKey=i,function(o,i){i.fillColor[0]=o.color.r/255,i.fillColor[1]=o.color.g/255,i.fillColor[2]=o.color.b/255,i.fillColor[3]=o.color.a,o.haloColor?(i.outlineColor[0]=o.haloColor.r/255,i.outlineColor[1]=o.haloColor.g/255,i.outlineColor[2]=o.haloColor.b/255,i.outlineColor[3]=o.haloColor.a):(i.outlineColor[0]=i.fillColor[0],i.outlineColor[1]=i.fillColor[1],i.outlineColor[2]=i.fillColor[2],i.outlineColor[3]=i.fillColor[3]),i.fillColor[3]*=o.fillOpacity,i.outlineColor[3]*=o.haloOpacity,i.fillColor[0]*=i.fillColor[3],i.fillColor[1]*=i.fillColor[3],i.fillColor[2]*=i.fillColor[3],i.outlineColor[0]*=i.outlineColor[3],i.outlineColor[1]*=i.outlineColor[3],i.outlineColor[2]*=i.outlineColor[3],i.outlineWidth=(1-o.haloBlur)*o.haloWidth,i.outerHaloWidth=o.haloBlur*o.haloWidth/2,i.innerHaloWidth=o.haloBlur*o.haloWidth/2,i.outlinePosition=0}(this._highlightOptions,this._convertedHighlightOptions);const s=this._convertedHighlightOptions,a=s.outlinePosition-s.outlineWidth/2-s.outerHaloWidth,u=s.outlinePosition-s.outlineWidth/2,d=s.outlinePosition+s.outlineWidth/2,g=s.outlinePosition+s.outlineWidth/2+s.innerHaloWidth,f=Math.sqrt(Math.PI/2)*t.sigma,C=Math.abs(a)>f?Math.round(10*(Math.abs(a)-f))/10:0,c=Math.abs(g)>f?Math.round(10*(Math.abs(g)-f))/10:0;let p;C&&!c?h().error("The outer rim of the highlight is "+C+"px away from the edge of the feature; consider reducing some width values or shifting the outline position towards positive values (inwards)."):!C&&c?h().error("The inner rim of the highlight is "+c+"px away from the edge of the feature; consider reducing some width values or shifting the outline position towards negative values (outwards)."):C&&c&&h().error("The highlight is "+Math.max(C,c)+"px away from the edge of the feature; consider reducing some width values.");const x=[void 0,void 0,void 0,void 0];function _(o,i,t){x[0]=(1-t)*o[0]+t*i[0],x[1]=(1-t)*o[1]+t*i[1],x[2]=(1-t)*o[2]+t*i[2],x[3]=(1-t)*o[3]+t*i[3]}const{_texelData:T}=this;for(let o=0;o<t.shadeTextureSize;++o)p=a+o/(t.shadeTextureSize-1)*(g-a),p<a?(x[0]=0,x[1]=0,x[2]=0,x[3]=0):p<u?_(n,s.outlineColor,(p-a)/(u-a)):p<d?[x[0],x[1],x[2],x[3]]=s.outlineColor:p<g?_(s.outlineColor,s.fillColor,(p-d)/(g-d)):[x[0],x[1],x[2],x[3]]=s.fillColor,T[4*o]=255*x[0],T[4*o+1]=255*x[1],T[4*o+2]=255*x[2],T[4*o+3]=255*x[3];if(this._minMaxDistance[0]=a,this._minMaxDistance[1]=g,!this._shadeTex){const i=new r.TextureDescriptor(t.shadeTextureSize,1);i.wrapMode=33071,this._shadeTex=new l.Texture(o,i)}this._shadeTex.updateData(0,0,0,t.shadeTextureSize,1,this._texelData)}}});