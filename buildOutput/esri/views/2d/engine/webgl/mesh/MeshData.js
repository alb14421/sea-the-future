// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../DisplayEntity","../DisplayRecord","./VertexDataWriter","../util/Writer"],function(t,e,r,i,n){"use strict";t.MeshData=class{constructor(t,r=0){this._id=t,this._sizeHint=r,this._entityRecordCountOffset=0,this._entityCountOffset=0,this._entityIdIndex=0,this._entitySortKeyIndex=0,this._didEntityStart=!1,this._instanceIdToVertexData=new Map,this._recordIndexStart=0,this._recordIndexCount=0,this._recordVertexStart=0,this._recordVertexCount=0,this._current={metric:null,writer:null,start:0,sortKey:0,instanceId:0,layoutHash:0,indexStart:0,vertexStart:0,textureKey:0,metricBoxLenPointer:0},this._entities=new n(Uint32Array,this._sizeHint*e.byteSizeHint),this._entityCountOffset=this._entities.push(0)}get id(){return this._id}serialize(){const t=new Array,e=[],r=this._entities.buffer();for(const r of this._instanceIdToVertexData.values())e.push(r.serialize(t));return{message:{data:e,entities:r},transferList:t}}vertexStart(){return this._current.vertexStart??0}vertexCount(){return this._current.writer?.vertexCount??0}indexCount(){return this._current.writer?.indexCount??0}vertexEnsureSize(t){this._current.writer.vertexEnsureSize(t)}indexEnsureSize(t){this._current.writer.indexEnsureSize(t)}vertexWrite(t){this._current.writer.writeVertex(t)}vertexWriteRegion(t){this._current.writer.writeVertexRegion(t)}vertexWriteF32(t){this._current.writer.writeVertexF32(t)}recordBounds(t,e,r,i){}indexWrite(t){this._current.writer.writeIndex(t)}metricStart(t){this._current.metric=t,this._current.metric.recordStart=this.recordCount()}metricEnd(){const t=this._current.writer;this._current.metric&&(this._current.metric.recordCount=this.recordCount()-this._current.metric.recordStart),this._current.metric?.bounds.length&&this._current.metric?.recordCount?(t.writeMetric(this._current.metric),this._current.metric=null):this._current.metric=null}metricBoxWrite(t){this._current.metric.bounds.push(t)}entityStart(t,e=t){this._entityIdIndex=this._entities.push(t),this._entitySortKeyIndex=this._entities.writeF32(e),this._entityRecordCountOffset=this._entities.push(0),this._didEntityStart=!0}entityRecordCount(){return this._entities.getValue(this._entityRecordCountOffset)}entityEnd(){this._didEntityStart&&(0===this.entityRecordCount()?this._entities.seek(this._entityIdIndex):this._entities.incr(this._entityCountOffset),this._didEntityStart=!1)}recordCount(){return this._entities.getValue(this._entityRecordCountOffset)}recordStart(t,e,r=0){this._current.writer=this._getVertexWriter(t,e),this._current.indexStart=this._current.writer.indexCount,this._current.vertexStart=this._current.writer.vertexCount,this._current.instanceId=t,this._current.layoutHash=e.hash,this._current.textureKey=r}recordEnd(t=0){const e=this._current.vertexStart,i=this._current.writer.vertexCount-e;if(!i)return!1;const n=this._current.indexStart,s=this._current.writer.indexCount-n;return this._recordIndexStart=n,this._recordIndexCount=s,this._recordVertexStart=e,this._recordVertexCount=i,this._entities.incr(this._entityRecordCountOffset),r.write(this._entities,this._current.instanceId,this._current.textureKey,n,s,e,i,t),!0}copyLast(t,e){const i=this._recordVertexStart+this._recordVertexCount;this._entities.incr(this._entityRecordCountOffset),r.write(this._entities,this._current.instanceId,this._current.textureKey,this._recordIndexStart+this._recordIndexCount,this._recordIndexCount,i,this._recordVertexCount,0);const n=this._current.writer.indexWriter,s=this._current.writer.vertexWriter,c=this._recordIndexStart+this._recordIndexCount,u=this._recordVertexCount;for(let t=this._recordIndexStart;t!==c;t++){const e=n.getValue(t);n.push(e+u)}const o=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,h=this._recordVertexStart*o,_=(this._recordVertexStart+this._recordVertexCount)*o;for(let t=h;t!==_;t++){const e=s.getValue(t);s.push(e)}const d=this._current.writer.layout.position,a=d.packPrecisionFactor??1,x=d.offset/Uint32Array.BYTES_PER_ELEMENT,y=t*a,S=e*a;for(let t=i*o;t<=s.length;t+=o)s.i1616Add(t+x,y,S)}copyLastFrom(t,e,r){const i=t._entities.getValue(t._entityIdIndex);if(i!==this._entities.getValue(this._entityIdIndex)){const e=t._entities.getValueF32(t._entitySortKeyIndex);this.entityStart(i,e)}this.recordStart(t._current.instanceId,t._current.writer.layout,t._current.textureKey);const n=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,s=this._current.vertexStart,c=t._current.vertexStart-s,u=this._current.writer.indexWriter,o=this._current.writer.vertexWriter,h=t._current.writer.indexWriter,_=t._current.writer.vertexWriter;for(let e=t._current.indexStart;e!==h.length;e++){const t=h.getValue(e);u.push(t-c)}for(let e=t._current.vertexStart*n;e!==_.length;e++){const t=_.getValue(e);o.push(t)}const d=this._current.writer.layout.position,a=d.packPrecisionFactor??1,x=d.offset/Uint32Array.BYTES_PER_ELEMENT,y=e*a,S=r*a;for(let t=s*n;t<=o.length;t+=n)o.i1616Add(t+x,y,S);this.recordEnd()}_getVertexWriter(t,e){const r=this._instanceIdToVertexData;return r.has(t)||r.set(t,new i.VertexDataWriter(t,e,this._sizeHint)),r.get(t)}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});