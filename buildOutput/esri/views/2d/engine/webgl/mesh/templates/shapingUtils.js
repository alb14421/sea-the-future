// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../core/libs/gl-matrix-2/math/mat2d","../../../../../../core/libs/gl-matrix-2/factories/mat2df32","../../../../../../core/libs/gl-matrix-2/math/vec2","../../../../../../core/libs/gl-matrix-2/factories/vec2f32","../../alignmentUtils","../../Rect","../../collisions/BoundingBox"],function(t,s,e,i,o,h,n,a){"use strict";const r=Math.PI/180;class f{constructor(t,s,i,o){this._rotationT=e.create(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const h=i.rect,n=new Float32Array(8);t*=o,s*=o;const a=i.code?h.width*o:i.metrics.width,r=i.code?h.height*o:i.metrics.height;this.width=a,this.height=r,n[0]=t,n[1]=s,n[2]=t+a,n[3]=s,n[4]=t,n[5]=s+r,n[6]=t+a,n[7]=s+r,this._data=n,this._setTextureCoords(h),this._scale=o,this._mosaic=i,this.x=t,this.y=s,this.maxOffset=Math.max(t+a,s+r)}get mosaic(){return this._mosaic}set angle(t){this._angle=t,s.fromRotation(this._rotationT,-t),this._setOffsets()}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:t,width:i}=this._mosaic.metrics,o=i*this._scale,h=Math.abs(t)*this._scale,n=new Float32Array(8);n[0]=this.x,n[1]=this.y,n[2]=this.x+o,n[3]=this.y,n[4]=this.x,n[5]=this.y+h,n[6]=this.x+o,n[7]=this.y+h;const r=s.multiply(e.create(),this._rotationT,this._transform);e.transformMany(n,n,r);let f=1/0,c=1/0,d=-1/0,m=-1/0;for(let t=0;t<4;t++){const s=n[2*t],e=n[2*t+1];f=Math.min(f,s),c=Math.min(c,e),d=Math.max(d,s),m=Math.max(m,e)}const g=d-f,l=m-c,_=f+g/2,u=c+l/2;this._bounds=new a(_,u,g,l)}return this._bounds}setTransform(t){this._transform=t,this._offsets=null}_setOffsets(){this._offsets||(this._offsets={topLeft:[0,0],topRight:[0,0],bottomLeft:[0,0],bottomRight:[0,0]});const t=s.multiply(e.create(),this._rotationT,this._transform);this._offsets.topLeft[0]=this._data[0],this._offsets.topLeft[1]=this._data[1],this._offsets.topRight[0]=this._data[2],this._offsets.topRight[1]=this._data[3],this._offsets.bottomLeft[0]=this._data[4],this._offsets.bottomLeft[1]=this._data[5],this._offsets.bottomRight[0]=this._data[6],this._offsets.bottomRight[1]=this._data[7],i.transformMat2d(this._offsets.topLeft,this._offsets.topLeft,t),i.transformMat2d(this._offsets.topRight,this._offsets.topRight,t),i.transformMat2d(this._offsets.bottomLeft,this._offsets.bottomLeft,t),i.transformMat2d(this._offsets.bottomRight,this._offsets.bottomRight,t)}_setTextureCoords({x:t,y:s,width:e,height:i}){this._texcoords={topLeft:[t,s],topRight:[t+e,s],bottomLeft:[t,s+i],bottomRight:[t+e,s+i]}}}const c=(t,s)=>({code:0,page:0,sdf:!0,rect:new n(0,0,11,8),textureBinding:s,metrics:{advance:0,height:4,width:t,left:0,top:0}});function d(t,s){return t.forEach(t=>i.transformMat2d(t,t,s)),{topLeft:t[0],topRight:t[1],bottomLeft:t[2],bottomRight:t[3]}}class m{constructor(t,s,e){this._rotation=0,this._decorate(t,s,e),this.glyphs=t,this.bounds=this._createBounds(t),this.isMultiline=s.length>1,this._hasRotation=0!==e.angle,this._transform=this._createGlyphTransform(this.bounds,e),this._borderLineSizePx=e.borderLineSizePx,(e.borderLineSizePx||e.hasBackground)&&([this.bounds,this.textBox]=this.shapeBackground(this._transform));for(const s of t)s.setTransform(this._transform)}setRotation(t){if(0===t&&0===this._rotation)return;this._rotation=t;const i=this._transform,o=s.fromRotation(e.create(),t);s.multiply(i,o,i);for(const t of this.glyphs)t.setTransform(this._transform)}_decorate(t,s,e){if(!e.decoration||"none"===e.decoration||!t.length)return;const i=e.scale,o="underline"===e.decoration?26:16,h=t[0].textureBinding;for(const e of s){const s=e.startX*i,n=e.startY*i,a=(e.width+e.glyphWidthEnd)*i;t.push(new f(s,n+o*i,c(a,h),1))}}shapeBackground(t){const s=(1.5+(this._borderLineSizePx||0))/2,e=this._borderLineSizePx?s:0,{xmin:i,ymin:o,xmax:h,ymax:n,x:r,y:f,width:c,height:m}=this.bounds,g=[i-8,o-8],l=[h+8,o-8],_=[i-8,n+8],u=[h+8,n+8],x=d([[g[0]-s,g[1]-s],[l[0]+s,l[1]-s],[g[0]+e,g[1]+e],[l[0]-e,l[1]+e]],t),p=d([[_[0]+e,_[1]-e],[u[0]-e,u[1]-e],[_[0]-s,_[1]+s],[u[0]+s,u[1]+s]],t),y=d([[g[0]-s,g[1]-s],[g[0]+e,g[1]+e],[_[0]-s,_[1]+s],[_[0]+e,_[1]-e]],t),b=d([[l[0]-e,l[1]+e],[l[0]+s,l[1]-s],[u[0]-e,u[1]-e],[u[0]+s,u[1]+s]],t),M={main:d([g,l,_,u],t),top:x,bot:p,left:y,right:b};return[new a(r,f,c+2*s,m+2*s),M]}get boundsT(){const t=this.bounds,s=i.set(o.create(),t.x,t.y);if(i.transformMat2d(s,s,this._transform),this._hasRotation){const e=Math.max(t.width,t.height);return new a(s[0],s[1],e,e)}return new a(s[0],s[1],t.width,t.height)}_createBounds(t){let s=1/0,e=1/0,i=0,o=0;for(const h of t)s=Math.min(s,h.xTopLeft),e=Math.min(e,h.yTopLeft),i=Math.max(i,h.xBottomRight),o=Math.max(o,h.yBottomRight);const h=i-s,n=o-e;return new a(s+h/2,e+n/2,h,n)}_createGlyphTransform(t,h){const n=r*h.angle,a=e.create(),f=o.create();return s.translate(a,a,i.set(f,h.xOffset,-h.yOffset)),h.useCIMAngleBehavior?s.rotate(a,a,n):(s.translate(a,a,i.set(f,t.x,t.y)),s.rotate(a,a,n),s.translate(a,a,i.set(f,-t.x,-t.y))),a}}class g{constructor(t,s,e,i,o,h){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(s,e)),this.end=Math.max(0,Math.max(s,e)),this.end<t.length&&(this.glyphWidthEnd=t[this.end].metrics.width),this.width=i,this.yMin=o,this.yMax=h}}const l=t=>10===t,_=t=>32===t;t.ShapedGlyph=f,t.ShapingInfo=m,t.shapeGlyphs=function(t,s){const e=s.scale,i=new Array,{glyphs:o,isRightToLeft:n}=t,a=function(t,s,e){const i=new Array,o=1/e.scale,h=e.maxLineWidth*o,n=s?t.length-1:0,a=s?-1:t.length,r=s?-1:1;let f=n,c=0,d=0,m=f,u=m,x=0,p=1/0,y=0;for(;f!==a;){const{code:s,metrics:e}=t[f],o=Math.abs(e.top);if(l(s)||_(s)||(p=Math.min(p,o),y=Math.max(y,o+e.height)),l(s))f!==n&&(i.push(new g(t,m,f-r,c,p===1/0?0:p,y)),p=1/0,y=0),c=0,m=f+r,u=f+r,d=0;else if(_(s))u=f+r,d=0,x=e.advance,c+=e.advance;else if(c>h){if(u!==m){const s=u-2*r;c-=x,i.push(new g(t,m,s,c-d,p,y)),p=1/0,y=0,m=u,c=d}else i.push(new g(t,m,f-r,c,p,y)),p=1/0,y=0,m=f,u=f,c=0;c+=e.advance,d+=e.advance}else c+=e.advance,d+=e.advance;f+=r}const b=new g(t,m,f-r,c,p,y);return b.start>=0&&b.end<t.length&&i.push(b),i}(o,n,s),r=a.length?function(t,s){let e=0;for(let s=0;s<t.length;s++){const{width:i}=t[s];e=Math.max(i,e)}const i="underline"===s.decoration?4:0,o=t[0].yMin;return{x:0,y:o,height:t[t.length-1].yMax+s.lineHeight*(t.length-1)+i-o,width:e}}(a,s):{y:0,height:0},c=h.getXAnchorDirection(s.horizontalAlignment),d=h.getYAnchorDirection(s.verticalAlignment),u=2===d?1:0,x=u?0:d-1,p=(1-u)*-r.y+x*(r.height/2)+-22*(u?1:0);for(let h=0;h<a.length;h++){const{start:n,end:r,width:d}=a[h];let m=-1*(c+1)*(d/2)-3;const g=(t.isRightToLeft?a.length-1-h:h)*s.lineHeight+p-3;a[h].startX=m,a[h].startY=g;for(let t=n;t<=r;t++){const s=o[t];if(l(s.code))continue;const h=new f(m+s.metrics.left,g-s.metrics.top,s,e);m+=s.metrics.advance,i.push(h)}}return new m(i,a,s)},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});