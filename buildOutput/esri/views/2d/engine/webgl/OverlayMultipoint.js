// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../core/events","../../../../core/Handles","../../../../core/maybe","../../../../core/reactiveUtils","../../../../core/screenUtils","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../geometry/Point","../../../../geometry/Polygon","../../../../geometry/projectionUtils","../DisplayObject","../../../layers/support/Geometry","../../../webgl/Texture","../../../webgl/TextureDescriptor"],function(t,e,r,i,n,s,o,a,h,l,c,u,d){"use strict";class p extends l.DisplayObject{constructor(r){super(),this.element=r,this._handles=new e,this.isWrapAround=!1,this.perspectiveTransform=s.create(),this.wrapAroundShift=0,this.clipGeometry=null,this._handles.add(i.when(()=>this.element,()=>{const e=this.element;this.ready(),e&&this._handles.add(t.on(e,"play",()=>this.requestRender()))},i.initial))}getMesh(t){throw new Error("Method not implemented.")}destroy(){super.destroy(),this._handles.destroy(),this.texture=r.disposeMaybe(this.texture)}get textureSize(){if(!this.texture)return[1,1];const t=this.texture.descriptor;return[t.width,t.height]}get dvsMat3(){return this.parent.dvsMat3}beforeRender(t){const e=this.element;if(null==e)return;const{context:r}=t,{videoWidth:i,videoHeight:n}=e;if(0!==i&&0!==n){if(this.texture)e.paused||this.texture.setData(e);else{const t=new d.TextureDescriptor(i,n);t.wrapMode=33071,t.preMultiplyAlpha=!0,this.texture=new u.Texture(r,t,e)}e.paused||(this.texture.generateMipmap(),this.requestRender()),super.beforeRender(t)}}_createTransforms(){return null}updateDrawCoords(t,e,r,i){const n=this.element,s=this._getFrameInfo();if(!n||!s)return;const{spatialReference:o}=r;this._initializeData(t,s,o);const{controlPoints:l,horizon:u}=s,d=Math.sqrt(l.length),p=d,{x,y:m}=t,f=this._vertices,y=l[0],g=l[d-1],P=l[(p-1)*d],w=l[(p-1)*d+d-1],_=h.project(u?u[0].mapPoint:y.mapPoint,o),v=h.project(u?u[1].mapPoint:g.mapPoint,o),M=h.project(P.mapPoint,o),A=h.project(w.mapPoint,o);this.clipGeometry=u?new c({geometry:a.fromJSON({rings:[[[M.x,M.y],[A.x,A.y],[v.x,v.y],[_.x,_.y],[M.x,M.y]]],spatialReference:o})}):null;for(let t=0;t<l.length;t++){const e=l[t],{sourcePoint:r,mapPoint:i}=e;if(null==r||null==i)continue;const n=h.project(i,o);f[2*t+0]=n.x-x,f[2*t+1]=n.y-m}let S=e;if(i){const t=Math.min(_.x,v.x,M.x,A.x),e=Math.max(_.x,v.x,M.x,A.x),{worldWidth:r,xBounds:n}=i,[s,o]=n;t<s&&e>s?S=r:e>o&&t<o&&(S=-r)}this.wrapAroundShift=S,this.isWrapAround=0!==S}draw(t,e){this.visible&&(this.isReady&&this._vertices&&this._indices&&this._texCoords?(this.stage||console.warn("OverlayMultipoint: stage is null"),e.render(t,{transform:{dvs:this.dvsMat3},config:{perspective:this.perspectiveTransform,texSize:this.textureSize,wrapAroundShift:this.wrapAroundShift,isWrapAround:this.isWrapAround,opacity:this.opacity,texture:{texture:this.texture,unit:0}},position:this._vertices,tex:this._texCoords,index:this._indices})):this.requestRender())}_initializeData(t,e,r){if(null!=this._vertices&&null!=this._indices)return;const{controlPoints:i}=e,n=Math.sqrt(i.length),s=n,o=new Float32Array(2*i.length),a=new Uint16Array(2*i.length);for(let e=0;e<i.length;e++){const n=i[e],{sourcePoint:s,mapPoint:l}=n;if(null==s||null==l)continue;const c=h.project(l,r);o[2*e+0]=c.x-t.x,o[2*e+1]=c.y-t.y,a[2*e+0]=s.x,a[2*e+1]=s.y}const l=new Uint16Array(s*n+(s-2)*(n+2));let c=0;for(let t=0;t<s;t++){for(let e=0;e<n;e++)l[c++]=t*n+e,l[c++]=(t+1)*n+e;t<s-2&&(l[c++]=(t+1)*n+(n-1),l[c++]=(t+1)*n)}this._vertices=o,this._texCoords=a,this._indices=l}_getFrameInfo(){if(!this.groundControlPoints)return null;const t=this._getFrameControlPoints(),e=this.frameHorizonPoints;let r=null;if(e){const t=e.startX,i=e.startY,s=e.endX,a=e.endY;r=[{sourcePoint:n.createScreenPoint(t,i),mapPoint:new o(e.startLongitude,e.startLatitude)},{sourcePoint:n.createScreenPoint(s,a),mapPoint:new o(e.endLongitude,e.endLatitude)}]}return{controlPoints:t,horizon:r}}_getFrameControlPoints(){const t=this.groundControlPoints,e=t?.length;if(!e)return[];const r=new Array(e),i=Math.max(...t.map(({x:t})=>t)),s=this.element.videoWidth/i;for(let i=0;i<e;i++){const{x:e,y:a,lat:h,lon:l}=t[i];r[i]={sourcePoint:n.createScreenPoint(e*s,-a*s),mapPoint:new o(l,h)}}return r}}return p});