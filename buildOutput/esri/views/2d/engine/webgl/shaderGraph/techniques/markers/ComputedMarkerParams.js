// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../../core/screenUtils","../../../../../../../symbols/cim/utils","../../../definitions"],function(t,e,i,o){"use strict";class s{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const i=new s(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:o,width:h,height:r,angle:n,alignment:a,outlineSize:c,referenceSize:f,sprite:l,overrideOutlineColor:m}=t;return i.rawWidth=e.pt2px(h),i.rawHeight=e.pt2px(r),i.angle=n,i.alignment=a,i.outlineSize=e.pt2px(c),i.referenceSize=e.pt2px(f),i.overrideOutlineColor=m,i.offsetX=e.pt2px(t.offsetX),i.offsetY=e.pt2px(t.offsetY),"simple"!==o||l.sdf||(i.rawWidth=l.width,i.rawHeight=l.height),i._computeSize(t,!1),i}static fromComplexMeshParams(t){const o=new s(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:h,transforms:r,size:n,scaleX:a,anchorX:c,anchorY:f,angle:l,colorLocked:m,frameHeight:d,widthRatio:p,offsetX:u,offsetY:g,outlineSize:x,referenceSize:w,scaleFactor:z,sizeRatio:S,isAbsoluteAnchorPoint:X,rotateClockwise:P,scaleSymbolsProportionally:Y,sprite:C}=t;if(r&&r.infos.length>0){const t=i.applyParentTransform(n,l,P,u,g,r);n=t.size,l=t.rotation,u=t.offsetX,g=t.offsetY,P=!1}z&&(n*=z,u*=z,g*=z);const H=a*(C.width/C.height);o.alignment=h,o.rawHeight=e.pt2px(n),o.rawWidth=o.rawHeight*H,o.referenceSize=e.pt2px(w),o.sizeRatio=S,o.sdfDecodeCoeff=(C.sdfDecodeCoeff??1)*S,o.angle=l,o.rotateClockwise=P,o.anchorX=c,o.anchorY=f,o.offsetX=e.pt2px(u),o.offsetY=e.pt2px(g),X&&n&&(C.sdf?o.anchorX=c/(n*p):o.anchorX=c/(n*H),o.anchorY=f/n);const M=Y&&d?n/d:1;return o.outlineSize=0===x||isNaN(x)?0:e.pt2px(x)*M,o.scaleSymbolsProportionally=Y,o.colorLocked=m,o._computeSize(t,!0),o}constructor(t,e,i,o,s,h,r){this.sprite=t,this.color=e,this.outlineColor=i,this.minPixelBuffer=o,this.placement=s,this.scaleInfo=h,this.effects=r,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=0,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,e){const{sprite:i,hasSizeVV:s}=t,n=!!i.sdf,a=i.sdfPaddingRatio??.5,{rawWidth:c,rawHeight:f,sizeRatio:l,outlineSize:m}=this,d=i.rect;let p=c*l,u=f*l,g=0,x=0;if(n){const t=1/(1-a);if(p*=t,u*=t,s)this.computedWidth=p,this.computedHeight=u;else{const t=e&&c>f?p:c,o=f,s=m+2;this.computedWidth=Math.min(t+s,p),this.computedHeight=Math.min(o+s,u);const h=Math.max(i.width,i.height)/Math.max(p,u);g=(this.computedWidth-p)*h,x=(this.computedHeight-u)*h}}else this.computedWidth=p*(d.width/i.width),this.computedHeight=u*(d.height/i.height),g=2*o.spritePadding,x=2*o.spritePadding;const w=d.x+o.spritePadding-g/2,z=d.y+o.spritePadding-x/2,S=w+i.width+g,X=z+i.height+x;this.texXmin=h(w),this.texYmin=h(z),this.texXmax=r(S),this.texYmax=r(X),this.computedWidth*=(this.texXmax-this.texXmin)/(S-w),this.computedHeight*=(this.texYmax-this.texYmin)/(X-z),this.anchorX*=p/this.computedWidth,this.anchorY*=u/this.computedHeight}}function h(t,e=1e-7){const i=Math.ceil(t);return i-t<e?i:Math.floor(t)}function r(t,e=1e-7){const i=Math.floor(t);return t-i<e?i:Math.ceil(t)}t.ComputedMarkerParams=s,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});