// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../../core/arrayUtils","../../../../../../../core/Error","../../../../../../../core/lang","../../../../../../../core/Logger","../../../../../../../support/ArcadeExpression","../../../grouping","../../../animations/infos","../../../animations/utils","./utils","../../../../../layers/features/support/DictionaryValue"],function(e,t,r,s,o,a,i,n,c,p,m){"use strict";const f=()=>o.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function l(e,t,r,s){const{defaultValue:o,valueExpressionInfo:a,value:i}=t;if(a){if("dictionary-template"===a.type)return{...t,computed:e.createDictionaryTemplateField(a,r),defaultValue:o};const{expression:i}=a,n=await e.createComputedField({expression:i},s);return n?{...t,computed:n,defaultValue:o}:null}return{...t,computed:new m.DictionaryValue(i),defaultValue:o}}async function d(e,t,r){const{valueExpressionInfo:s}=t,o="dictionary-template"===s.type?e.createDictionaryTemplateField(s,r):await e.createComputedField({expression:s.expression});return o?{...t,computed:o}:null}function u(e){return"object"==typeof e&&null!=e&&(!(!("valueExpressionInfo"in e)||!e.valueExpressionInfo)||"type"in e&&"Process"===e.type&&"op"in e&&"Random"===e.op)}function y(e){if(Array.isArray(e))for(const t of e)if(y(t))return!0;if("object"==typeof e){if(u(e))return!0;for(const t in e)if(y(e[t]))return!0}return!1}class h{static async create(e,r,s,o){const a={},i=new Map,n=new Map,p=new Map,m=new Map,f=new Map,v=new Map;for(const h in s){const P=s[h];if(null!=P&&"object"==typeof P)if(Array.isArray(P)){if("object"==typeof P[0])throw new Error(`InternalError: Cannot handle ${h}. Nested array params are not supported`);a[h]=P}else{if("valueExpressionInfo"in P){if(P.value){a[h]=P.value;continue}const t=await d(e,P,o);if(!t){a[h]=P.defaultValue;continue}i.set(h,t),a[h]=null;continue}switch(P.type){case"cim-effect-infos":if(P.effectInfos.some(e=>e.overrides.length)){n.set(h,{effects:await Promise.all(P.effectInfos.map(async r=>{const s=r.overrides.map(t=>l(e,t,o,!1));return{effect:r.effect,compiledOverrides:(await Promise.all(s)).filter(t.isSome)}}))});break}a[h]=P.effectInfos.map(e=>e.effect);break;case"cim-marker-placement-param":P.overrides.length&&p.set(h,{placementInfo:P,compiledOverrides:(await Promise.all(P.overrides.map(t=>l(e,t,o,!1)))).filter(t.isSome)}),a[h]=P.placement;break;case"text-rasterization-param":{if(P.overrides.length){const r=P.overrides.map(t=>l(e,t,o,P.useLegacyLabelEvaluationRules??!1));m.set(h,{compiledOverrides:(await Promise.all(r)).filter(t.isSome),rasterizationParam:P,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:P.resource};a[h]=await r.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(P.overrides.length){const r=P.overrides.map(t=>l(e,t,o,!1));m.set(h,{compiledOverrides:(await Promise.all(r)).filter(t.isSome),rasterizationParam:P,objectIdToResourceId:new Map});continue}if("animated"===P.resource.type){m.set(h,{compiledOverrides:[],rasterizationParam:P,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:P.resource};a[h]=await r.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=P;if(y(t)){const r={compiledMarkerInfos:[]};await Promise.all(t.map(async t=>{const s={props:{}};for(const r in t)if(u(t[r])){const a=await d(e,t[r],o);s.compiledExpressionMap||(s.compiledExpressionMap=new Map);const i=s.compiledExpressionMap;a&&i.set(r,a)}else s.props[r]=t[r];r.compiledMarkerInfos.push(s)})),f.set(h,r)}else a[h]={type:"cim-marker-transform-info",infos:t};break}case"animation-params":{const{params:t}=P,s=c.createParamList(t);if(y(s)){const t=await Promise.all(s.map(t=>c.compileAnimationParam(t,e)));v.set(h,{params:t,propertyIdToResourceId:new Map,key:h})}else{const e=c.fromJSON(s),t=await r.fetchResourceImmediate({type:"animation-info",resource:e});null!=t&&"sprite"===t.type&&(a[h]={dataRow:t.rect.y,dataColumn:t.rect.x})}break}default:a[h]=P}}else a[h]=P}return new h(s,a,i,n,p,m,f,v)}constructor(e,t,r,s,o,i,n,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=r,this._dynamicEffectProperties=s,this._dynamicPlacementProperties=o,this._dynamicAsyncProperties=i,this._dynamicTransformProperties=n,this._dynamicAsyncAnimations=c,this.evaluator=e=>e,this._arcadeDependencies=new Set;for(const e of this._expressions())a.collectExpressionDependencies(this._arcadeDependencies,e)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,o){for(const a of this._dynamicAsyncProperties.values()){const n=s.clone(a.rasterizationParam.resource);"animated"===a.rasterizationParam.resource.type&&a.rasterizationParam.resource.randomizeStartTime&&(n.primitiveName="__RESERVED__PRIMITIVE__NAME__",n.startGroup=i.getStartGroup(t.getObjectId()||0));for(const{primitiveName:e,propertyName:s,computed:i,defaultValue:c,valueExpressionInfo:m}of a.compiledOverrides)try{const r="animated"===a.rasterizationParam.resource.type?n.primitiveName:e;p.applyComputedValue(n,r,s,i,t,o,c)}catch(e){f().errorOnce(new r("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:e,valueExpressionInfo:m}))}const c=e.enqueueRequest({type:"cim-rasterization-info",resource:n});a.objectIdToResourceId.set(t.getObjectId(),c)}for(const r of this._dynamicAsyncAnimations.values()){const s=r.params.map(e=>c.resolveToAnimationInfo(e,t,o)).map(n.hydrate).map(e=>e.simplify()),a=c.encodeParamList(s),i=e.enqueueRequest({type:"animation-info",resource:a});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,i)}}evaluateMeshParams(e,t,r){for(const[e,s]of this._dynamicProperties.entries())this._resolvedMeshParams[e]=s.computed.readWithDefault(t,r,s.defaultValue);for(const[e,s]of this._dynamicPlacementProperties.entries())for(const{computed:o,defaultValue:a,propertyName:i}of s.compiledOverrides){const n=o.readWithDefault(t,r,a);s.placementInfo.placement[i]=n,this._resolvedMeshParams[e]=s.placementInfo.placement}for(const[e,s]of this._dynamicEffectProperties.entries())for(const o of s.effects){for(const{computed:e,defaultValue:s,propertyName:a}of o.compiledOverrides){const i=e.readWithDefault(t,r,s);o.effect[a]=i}this._resolvedMeshParams[e]=s.effects.map(e=>e.effect)}for(const[e,s]of this._dynamicTransformProperties.entries()){const o={type:"cim-marker-transform-info",infos:[]};for(const e of s.compiledMarkerInfos){const s={...e.props};if(e.compiledExpressionMap)for(const[o,a]of e.compiledExpressionMap){const e=a.computed.readWithDefault(t,r,a.defaultValue);s[o]="number"==typeof e||"boolean"==typeof e?e:a.defaultValue}o.infos.push(s)}this._resolvedMeshParams[e]=o}for(const[r,s]of this._dynamicAsyncProperties.entries()){const o=s.objectIdToResourceId.get(t.getObjectId());if(null==o)continue;const a=e.getResource(o);this._resolvedMeshParams[r]=a}for(const[r,s]of this._dynamicAsyncAnimations.entries()){const o=s.propertyIdToResourceId.get(t.getObjectId()+"."+r);if(null==o)continue;const a=e.getResource(o);this._resolvedMeshParams[r]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const e of t.compiledOverrides)yield e.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(null!=t.compiledExpressionMap)for(const e of t.compiledExpressionMap.values())yield e.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*c.getAnimationExpressions(t)}}e.MeshWriterInputEvaluator=h,e.hasExpression=u,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});