// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/has","../../../../../core/Logger","./graph/glsl","./graph/GlslGraphWriter","./graph/ShaderGraphContext","./graph/ShaderGraphNode","./typed/TypedShaderProgram","../../../../webgl/ShaderBuilder"],function(e,t,r,o,n,s,i,p,a,u){"use strict";function c(e){return new e}function d(e,t,r){const o=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:o.slice()}),e.constructor[t].push(r)}const y=e=>(t,r)=>{d(t,"builtins",{builtin:e,propertyKey:r})},h=(e,t)=>(r,o)=>{r.constructor.builtins.push({builtin:e,propertyKey:o,typeCtor:t})};class f{static{this.builtins=[]}}t.__decorate([h("gl_VertexID",n.Int)],f.prototype,"glVertexID",void 0);class l{static{this.builtins=[]}}t.__decorate([h("gl_FragCoord",n.Vec4)],l.prototype,"glFragCoord",void 0),t.__decorate([h("gl_PointCoord",n.Vec2)],l.prototype,"glPointCoord",void 0);class m{}t.__decorate([y("gl_FragDepth")],m.prototype,"glFragDepth",void 0),e.ComputeVertexInput=class{},e.FragmentInput=l,e.FragmentOutput=m,e.GraphShaderModule=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast(e=>"vertex"===e.propertyKey&&0===e.parameterIndex);if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast(e=>"vertex"===e.propertyKey&&1===e.parameterIndex)}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast(e=>"fragment"===e.propertyKey);if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const r of this.locations)t.has(r.index)?o.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:e}):(e.set(r.propertyKey,r.index),t.add(r.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map(([e,t])=>`${e}.${t}`).join("."),r=this.computeAttributes;this._locationInfo={stringHash:t,locations:e,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,r,o){try{const{vertex:n,fragment:s,uniformBindings:i}=this._generateShaders(e,t,r,o);return new a.TypedShaderProgram(n,s,this.renamedLocationsMap,i,this.transformFeedbackBindings)}catch(e){return new a.TypedShaderProgram("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find(t=>t.propertyKey===e);if(t)return{type:"option",className:t.typeCtor};const r=this._uniforms.find(t=>t.propertyKey===e);if(!r)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:r.typeCtor}}getShaderKey(e,t,r,o){const n=Object.keys(e).map(t=>`${t}.${e[t]}`).join("."),s=Object.keys(r).map(e=>`${e}.${r[e]}`).join("."),i=Object.keys(o).map(e=>`${e}.${o[e]}`).join("."),p=Object.keys(t).filter(e=>this.optionPropertyKeys.has(e)&&t[e]).join(".");return`${this.type}.${n}.${s}.${i}.${p}`}_generateShaders(e,t,r,o){const n=[];this._setDefines(r),this._setOptionalUniforms(n,t),this._setRequiredUniforms(n);const a=this._hydrateVertexInput(o),u=this._injectPackPrecisionFactor(a,e),c=this._hydrateComputeInput(),d=c&&this._injectComputePackPrecisionFactor(c,e),y=this.vertex(u,d),h=this._hydrateFragmentInput(y),f=this.fragment(h),l=new Set;for(const e in f){const t=f[e];p.setReachableUids(l,t)}const m=this._getVertexInputBuiltins(),g={};for(const[e,t]of Object.entries(a))g[e]=t;if(null!=c)for(const[e,t]of Object.entries(c))g[e]=t;const _=i.ShaderGraphContext.createVertex(g,y,m,n,this.transformFeedbackBindings,l);(new s.GlslShaderWriter).write(_);const b=this._getFragmentInputBuiltins(f);b.set("glPointCoord","gl_PointCoord");const x=i.ShaderGraphContext.createFragment(h,f,b,n,_,this.transformFeedbackBindings);(new s.GlslShaderWriter).write(x);const C=this._createShaderBuilder(_,x),K=C.generate("vertex"),I=C.generate("fragment");return this.logShader&&(console.log(K),console.log(I)),{vertex:K,fragment:I,uniformBindings:n}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const r of this._options)t[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(e,r):this[r.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const r=new(0,t.typeCtor);for(const o of r._uniforms??[]){const n=c(o.typeCtor),s=`u_${t.propertyKey}_${o.propertyKey}`,i=n.type,p=[t.propertyKey,o.propertyKey].join(".");if("type"in o.typeCtor&&"array"===o.typeCtor.type){const t=n;e.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:n})}else if("type"in o.typeCtor&&"array-2d"===o.typeCtor.type){const t=n;e.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:n})}else e.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformHydrated:n});r[o.propertyKey]=n}return r}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,r=t.locations.reduce((t,r)=>!1===e[r.propertyKey]?t:{...t,[r.propertyKey]:c(r.typeCtor)},{});for(const{propertyKey:e,typeCtor:o}of t.builtins){const t=c(o);r[e]=t}return r}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce((e,t)=>({...e,[t.propertyKey]:c(t.typeCtor)}),{})}_injectPackPrecisionFactor(e,t){const r={};for(const o in e){const s=e[o],i=t[o];if(i){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[o]=s.divide(new n.Float(i))}else r[o]=s}return r}_injectComputePackPrecisionFactor(e,t){const r={},o=new Map;for(const e in this.computeAttributes)for(const t of this.computeAttributes[e]??[])o.set(t,e);for(const s in e){const i=e[s],p=o.get(s);if(!p)continue;const a=t[p];if(a){if("float"!==i.type&&"vec2"!==i.type&&"vec3"!==i.type&&"vec4"!==i.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[s]=i.divide(new n.Float(a))}else r[s]=i}return r}_hydrateFragmentInput(e){const t={};for(const r in e)t[r]=e[r];for(const{propertyKey:e,typeCtor:r}of l.builtins){const o=c(r);t[e]=o}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:r,propertyKey:o}of e.builtins)t.set(o,r);return t}_getFragmentInputBuiltins(e){const t=e.constructor,r=new Map;for(const e of t.builtins??[])r.set(e.propertyKey,e.builtin);return r}_createShaderBuilder(e,t){const r=new u.ShaderBuilder;return this._insertDebugInfo(r),e.insertVertexShader(r),t.insertFragmentShader(r),r}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}},e.UniformGroup=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},e.VertexInput=f,e.builtin=y,e.define=(e,t)=>{d(e,"defines",{propertyKey:t})},e.input=e=>(t,r,o)=>{d(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:o})},e.location=function(e,t){return(r,o)=>{d(r,"locations",{typeCtor:t,propertyKey:o,parameterIndex:null,index:e})}},e.option=e=>(t,r)=>{d(t,"options",{typeCtor:e,propertyKey:r})},e.transformFeedback=function(e){return(t,r)=>{d(t,"transformFeedbackBindings",{propertyKey:r,parameterIndex:null,index:e})}},e.uniform=e=>(t,r)=>{d(t,"uniforms",{typeCtor:e,propertyKey:r})},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});