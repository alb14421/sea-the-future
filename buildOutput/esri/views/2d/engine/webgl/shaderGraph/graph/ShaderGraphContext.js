// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","./ShaderGraphNode"],function(e,t){"use strict";class a{constructor(e,t,a,n=[]){this.variableName=e,this.variableInputType=t,this.node=a,this.qualifiers=n,this.type="shader-input",this.isUsed=!1}clone(){return new a(this.variableName,this.variableInputType,t.cloneShaderNode(this.node),[...this.qualifiers])}}class n{constructor(e,t,a,n=[]){this.outVariableName=e,this.outVariableType=t,this.node=a,this.qualifiers=n,this.type="shader-output"}clone(){const e=new n(this.outVariableName,this.outVariableType,t.cloneShaderNode(this.node),[...this.qualifiers]);return e.variableName=this.variableName,e}}class o{static createVertex(e,t,r,s,i,u){const c=[];for(const t in e){const n=e[t],o=r.get(t);o?c.push(new a(o,"builtin",n)):c.push(new a("a_"+t,"in",n))}for(const e of s){const t=e.uniformHydrated;c.push(new a(e.uniformName,"uniform",t))}const p=[];for(const e in t){const a=t[e];if("glPosition"===e)p.push(new n("gl_Position","builtin",a));else if("glPointSize"===e)p.push(new n("gl_PointSize","builtin",a));else{const t=d(a),o=[];t&&o.push(t),p.push(new n("v_"+e,"out",a,o))}}return new o(c,p,i,u)}static createFragment(e,t,d,r,s,i){const u=[],c=Array.from(s.rootOutputNodes());for(const t in e){const n=e[t],o=d.get(t);if(o){u.push(new a(o,"builtin",n));continue}const r=c.find(e=>e.node===n);r&&u.push(new a(r.outVariableName,"in",n))}for(const e of r){const t=e.uniformHydrated;u.push(new a(e.uniformName,"uniform",t))}const p=[];for(const e in t){const a=t[e],o=d.get(e);switch(e){case"discard":p.push(new n(null,"discard",a));break;case"fragData0":p.push(new n("fragData0","fragData0",a));break;case"fragData1":p.push(new n("fragData1","fragData1",a));break;case"fragData2":p.push(new n("fragData2","fragData2",a));break;case"fragData3":p.push(new n("fragData3","fragData3",a));break;default:o?p.push(new n(o,"builtin",a)):p.push(new n(e,"out",a))}}return new o(u,p,i)}constructor(e,t,a,n){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const t of e)this._inputShaderTypesByNodeUid.set(t.node.uid,t);this._outputShaderTypes=t,this._transformFeedbackBindings=a,this._transformFeedbackNames=new Set(a.map(e=>"v_"+e.propertyKey)),this._usedInFragmentShader=n}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&"builtin"!==e.outVariableType&&!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)}setEmit(e,t){this._nodeEmitMap.set(e.uid,t)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const t of this._outputShaderTypes.values())e.push(t.node);for(;e.length;){const t=e.pop();"number"!=typeof t&&"boolean"!=typeof t&&e.push(...t.children.filter(Boolean)),yield t}}*nodesOfTypeOrFunction(){for(const e of this.nodes())"number"!=typeof e&&"boolean"!=typeof e&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new o([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this.rootOutputNodes()){const a="builtin"===t.outVariableType;if(!this.shouldPruneOutputNode(t))if(a)e.vertex.code.add(`// ${t.outVariableType.padEnd(7)} ${t.node.type.padEnd(9)} ${t.outVariableName};`);else{const a=[...t.qualifiers,t.outVariableType].join(" ");e.vertex.code.add(`${a.padEnd(10)} ${t.node.type.padEnd(9)} ${t.outVariableName};`)}}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())this.shouldPruneOutputNode(t)||e.vertex.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("// OUTPUTS: "),e.fragment.code.add("// --------------------------------------------------------- ");let t=0;for(const a of this.rootOutputNodes())"builtin"===a.outVariableType?e.fragment.code.add(`// ${a.outVariableType.padEnd(7)} ${a.node.type.padEnd(9)} ${a.outVariableName};`):e.outputs.add(a.outVariableName,a.node.type,t++);e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())"discard"===t.outVariableType?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${t.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.fragment.code.add("}")}_insertInputs(e,t){e[t].code.add("// INPUTS: "),e[t].code.add("// --------------------------------------------------------- ");for(const a of this.inputs())if(a.isUsed&&"builtin"!==a.variableInputType)if("array"===a.node.type)e[t].code.add(`${a.variableInputType.padEnd(10)} ${a.node.elementType.type.padEnd(9)} ${a.variableName}[${a.node.size}];`);else if("array-2d"===a.node.type)e[t].code.add(`${a.variableInputType.padEnd(10)} ${a.node.elementType.type.padEnd(9)} ${a.variableName}[${a.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const n=[...a.qualifiers,a.variableInputType].join(" ");e[t].code.add(` ${n.padEnd(10)} ${a.node.type.padEnd(9)} ${a.variableName};`)}}}function d(e){switch(e.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${e.type} is not a valid output type`)}}e.ShaderGraphContext=o,e.ShaderInput=a,e.ShaderOutput=n,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});