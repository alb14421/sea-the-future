// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/arrayUtils","../../../../../core/has","../../../../../core/maybe","../number","./Buffer","../shaderGraph/techniques/mesh/dataViewUtils","../shaderGraph/techniques/mesh/utils","../../../../webgl/enums","../../../../webgl/VertexArrayObject"],function(e,t,i,r,s,f,n,o,u,a){"use strict";const h=1e3,l=[{name:"visibility",offset:0,type:u.DataType.FLOAT,count:1}],d={hash:o.vertexLayoutHash(l),attributes:l,stride:4};function _(e,i){return t.unique(e.attributes,(e,t)=>e.name===t.name).filter(e=>i.locations.has(e.name)).map(t=>({name:t.name,type:t.type,count:t.count,divisor:0,normalized:t.normalized??!1,offset:t.offset,stride:e.stride})).sort((e,t)=>i.locations.get(e.name)-i.locations.get(t.name))}function y(e,i){const r=[],s=t.unique(e.attributes,(e,t)=>e.name===t.name).filter(e=>i.locations.has(e.name));for(const t of s){r.push({name:t.name,type:t.type,count:t.count,divisor:0,normalized:t.normalized??!1,offset:t.offset,stride:e.stride});const s=i.computeAttributeMap[t.name];null!=s&&2===s.length&&(r.push({name:s[0],count:t.count,divisor:0,type:t.type,normalized:t.normalized??!1,offset:t.offset+e.stride,stride:e.stride}),r.push({name:s[1],count:t.count,divisor:0,type:t.type,normalized:t.normalized??!1,offset:t.offset+2*e.stride,stride:e.stride}))}return r.sort((e,t)=>i.locations.get(e.name)-i.locations.get(t.name))}e.MappedMesh=class{constructor(e,t,i){if(this._bufferPool=e,this._layout=t,this.useVisibility=i,this._invalidatedGeometry=!1,this._invalidatedCompute=!1,this._position=this._layout.attributes.find(e=>"pos"===e.name||"position"===e.name),!this._position)throw new Error("InternalError: Unable to find position attribute")}destroy(){this._indexBuffer=r.destroyMaybe(this._indexBuffer),this._vertexBuffer=r.destroyMaybe(this._vertexBuffer),this._visibilityBuffer=r.destroyMaybe(this._visibilityBuffer),this._computeVAO?.disposeVAOOnly(),this._geometryVAO?.disposeVAOOnly()}get layout(){return this._layout}getDrawArgs(e,t,i,r){return r?{primitive:u.PrimitiveType.POINTS,count:t/3,offset:i/3}:{primitive:e,count:t,offset:i}}getAttributePrecisionPackFactors(){const e={};for(const t of this.layout.attributes)t.packPrecisionFactor&&(e[t.name]=t.packPrecisionFactor);return e}getDebugVertexInfo(e=!1,t){if(!this._vertexBuffer)return null;const i=this._layout,r=i.stride,s=this._vertexBuffer.getView(0,this._vertexBuffer.byteSize),f=[];if(e)if(null==t)console.log("must provide location info to see compute attributes");else for(const e of i.attributes){const i=t.computeAttributeMap[e.name];null!=i&&2===i.length&&(f.push({...e,name:i[0],offset:e.offset+r}),f.push({...e,name:i[1],offset:e.offset+2*r}))}const o=new DataView(s.slice().buffer);let u=s.byteLength/r;e&&(u=this._indexBuffer.fillPointer/3);const a=this._indexBuffer.getView(0,this._indexBuffer.byteSize);let h=0;const l=[];for(let t=0;t<u;t++){e&&(h=a[3*t]*r);const s={};for(const e of[...i.attributes,...f]){let t=`${e.offset} ${e.name}`,i=n.unpackDataView(o,e,h);if(e.packPrecisionFactor)if(t+=` (precision: ${e.packPrecisionFactor})`,"number"==typeof i)i/=e.packPrecisionFactor;else for(let t=0;t<i.length;t++)i[t]/=e.packPrecisionFactor;s[t]=i}h+=r,l.push(s)}return{vertices:l,layout:i}}_ensure(e,t){if(this._vertexBuffer&&this._indexBuffer)this._indexBuffer.ensure(Math.max(e,h)),this._vertexBuffer.ensure(Math.max(t,h)),this._visibilityBuffer&&this._visibilityBuffer.ensure(Math.max(t,h));else{const i=this._layout.stride/Uint32Array.BYTES_PER_ELEMENT;this._indexBuffer=new f.MappedBuffer("index",Math.max(e,h),1,this._bufferPool),this._vertexBuffer=new f.MappedBuffer("vertex",Math.max(t,h),i,this._bufferPool),this.useVisibility&&(this._visibilityBuffer=new f.MappedBuffer("vertex",Math.max(t,h),4/Uint32Array.BYTES_PER_ELEMENT,this._bufferPool))}}append(e){const t=e.layout.stride,i=e.indices.byteLength/Uint32Array.BYTES_PER_ELEMENT,r=e.vertices.byteLength/t;this._ensure(i,r);const{vertices:s,indices:f}=e,n=this._vertexBuffer.insert(s,0,s.byteLength/t,0),o=new Uint32Array(r);return new Float32Array(o.buffer).fill(255),this._visibilityBuffer&&this._visibilityBuffer.insert(o,0,o.byteLength/4,0),{vertexFrom:n,indexFrom:this._indexBuffer.insert(f,0,f.byteLength/4,n)}}setEntityRecordRangeVisibility(e,t,i,r){if(!(t+i>e.length))for(let s=t;s<t+i;s++){const{vertexStart:t,vertexCount:i}=e[s];this._visibilityBuffer.setF32Range(t,t+i,r)}}getEntityRecordVisibility(e,t){const i=e.records[t];return this._visibilityBuffer.getF32(i.vertexStart)}copyRecordFrom(e,t,i,r){const{indexStart:f,indexCount:n,vertexStart:o,vertexCount:u}=t;this._ensure(n,u);const a=e._position,h=i*(a.packPrecisionFactor??1),l=r*(a.packPrecisionFactor??1),d=a.offset,_=s.i1616to32(h,l),y=this._vertexBuffer.copyFrom(e._vertexBuffer,o,u,_,d);this._visibilityBuffer&&e._visibilityBuffer&&this._visibilityBuffer.copyFrom(e._visibilityBuffer,o,u,0,0);const c=this._indexBuffer.copyFrom(e._indexBuffer,f,n,y-o,0),v=t.clone();return v.vertexStart=y,v.indexStart=c,v.overlaps=0,v}remove(e,t,i,r){this._indexBuffer.free(e,t),this._vertexBuffer.free(i,r),this._visibilityBuffer&&this._visibilityBuffer.free(i,r)}upload(){this._invalidatedGeometry=!0,this._invalidatedCompute=!0}getGeometryVAO(e,t){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedGeometry){if((this._vertexBuffer.invalidated||this._indexBuffer.invalidated||this._visibilityBuffer?.invalidated)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._visibilityBuffer&&this._visibilityBuffer.invalidate(),this._geometryVAO?.disposeVAOOnly(),this._geometryVAO=null),this._vertexBuffer.upload(),this._indexBuffer.upload(),this._visibilityBuffer&&this._visibilityBuffer.upload(),!this._geometryVAO){const i=this._indexBuffer.getIndexBuffer(e,!1),r=new Map([["geometry",this._vertexBuffer.getVertexBuffer(e,_(this.layout,t))]]);this._visibilityBuffer&&r.set("visibility",this._visibilityBuffer.getVertexBuffer(e,_(d,t))),this._geometryVAO=new a.VertexArrayObject(e,r,i)}this._invalidatedGeometry=!1}return this._geometryVAO}getComputeVAO(e,t){if(!this._vertexBuffer||!this._indexBuffer||!this._vertexBuffer.bufferSize)return null;if(this._invalidatedCompute&&((this._vertexBuffer.invalidated||this._indexBuffer.invalidatedComputeBuffer)&&(this._vertexBuffer.invalidate(),this._indexBuffer.invalidate(),this._visibilityBuffer?.invalidate(),this._computeVAO?.disposeVAOOnly(),this._computeVAO=null),this._vertexBuffer.upload(),this._indexBuffer.upload(),this._visibilityBuffer?.upload(),!this._computeVAO)){const i=this._indexBuffer.getIndexBuffer(e,!0),r=new Map([["geometry",this._vertexBuffer.getVertexBuffer(e,y(this.layout,t))]]);this._visibilityBuffer&&r.set("visibility",this._visibilityBuffer.getVertexBuffer(e,_(d,t))),this._computeVAO=new a.VertexArrayObject(e,r,i),this._invalidatedCompute=!1}return this._computeVAO}get memoryStats(){return{bytesUsed:this._vertexBuffer.memoryStats.bytesUsed+this._indexBuffer.memoryStats.bytesUsed,bytesReserved:this._vertexBuffer.memoryStats.bytesReserved+this._indexBuffer.memoryStats.bytesReserved,vertex:this._vertexBuffer.memoryStats,index:this._indexBuffer.memoryStats}}reshuffle(e){this._vertexBuffer&&this._vertexBuffer.reshuffle(e.vertex.count,e.vertex.operations),this._indexBuffer&&this._indexBuffer.reshuffle(e.index.count,e.index.operations),this._visibilityBuffer&&this._visibilityBuffer.reshuffle(e.vertex.count,e.vertex.operations)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});