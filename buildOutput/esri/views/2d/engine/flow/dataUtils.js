// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/has","../../../../core/Logger","../../../../core/mathUtils","../../../../core/promiseUtils","../../../../core/RandomLCG","../../../../geometry/Extent","../../../../geometry/support/spatialReferenceUtils"],function(t,e,n,r,o,l,a,i){"use strict";const s=()=>n.getLogger("esri.views.2d.engine.flow.dataUtils");function c(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),l=new Array(2*o+1);let a=0;for(let t=-o;t<=o;t++){const e=Math.exp(-t*t/(r*r));l[t+o]=e,a+=e}for(let t=-o;t<=o;t++)l[t+o]/=a;const i=new Float32Array(t.length);for(let r=0;r<n;r++)for(let n=0;n<e;n++){let a=0,s=0;for(let i=-o;i<=o;i++){if(n+i<0||n+i>=e)continue;const c=l[i+o];a+=c*t[2*(r*e+(n+i))],s+=c*t[2*(r*e+(n+i))+1]}i[2*(r*e+n)]=a,i[2*(r*e+n)+1]=s}const s=new Float32Array(t.length);for(let t=0;t<e;t++)for(let r=0;r<n;r++){let a=0,c=0;for(let s=-o;s<=o;s++){if(r+s<0||r+s>=n)continue;const f=l[s+o];a+=f*i[2*((r+s)*e+t)],c+=f*i[2*((r+s)*e+t)+1]}s[2*(r*e+t)]=a,s[2*(r*e+t)+1]=c}return s}(e.data,e.width,e.height,t.smoothing);return t.interpolate?(t,r)=>{const o=Math.floor(t),l=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(l<0||l>=e.height)return[0,0];const a=t-o,i=r-l,s=o,c=l,f=o<e.width-1?o+1:o,h=l<e.height-1?l+1:l,u=n[2*(c*e.width+s)],d=n[2*(c*e.width+f)],m=n[2*(h*e.width+s)],g=n[2*(h*e.width+f)],w=n[2*(c*e.width+s)+1],p=n[2*(c*e.width+f)+1];return[(u*(1-i)+m*i)*(1-a)+(d*(1-i)+g*i)*a,(w*(1-i)+n[2*(h*e.width+s)+1]*i)*(1-a)+(p*(1-i)+n[2*(h*e.width+f)+1]*i)*a]}:(t,r)=>{const o=Math.round(t),l=Math.round(r);return o<0||o>=e.width||l<0||l>=e.height?[0,0]:[n[2*(l*e.width+o)],n[2*(l*e.width+o)+1]]}}function f(t,e,n){let r=1/0,o=1;for(let l=0;l+1<n.length;l++){const a=[n[l+1][0]-n[l][0],n[l+1][1]-n[l][1]],i=[t-n[l][0],e-n[l][1]],s=Math.min(Math.max((i[0]*a[0]+i[1]*a[1])/(a[0]*a[0]+a[1]*a[1]),0),1),c=[i[0]-a[0]*s,i[1]-a[1]*s];r=Math.min(r,c[0]*c[0]+c[1]*c[1]),(e>=n[l][1]&&e<n[l+1][1]&&a[0]*i[1]>a[1]*i[0]||e<n[l][1]&&e>=n[l+1][1]&&a[0]*i[1]<=a[1]*i[0])&&(o=-o)}return o*Math.sqrt(r)}function h(t,e,n){const{geometries:r}=t;let o=1/0;for(const[t,l]of r)o=Math.min(o,f(e,n,l));return o}function u(t,e,n){const r=h(t,e,n),o=Math.max(.001,r);return Math.min(1,10/o)}function d(t,e,n,r,o,l,a,i,s,c=null){const f=[];let h=n,d=r,m=0,[g,w]=e(h,d);g*=t.velocityScale,w*=t.velocityScale;const p=Math.sqrt(g*g+w*w);let y,M;f.push({x:h,y:d,t:m,speed:p,colorTime:c??u(t,h,d)});for(let n=0;n<t.verticesPerLine;n++){let[n,r]=e(h,d);n*=t.velocityScale,r*=t.velocityScale;const g=Math.sqrt(n*n+r*r);if(g<t.minSpeedThreshold)return f;const w=n/g,p=r/g;if(h+=w*t.segmentLength,d+=p*t.segmentLength,m+=t.segmentLength/g,Math.acos(w*y+p*M)>t.maxTurnAngle)return f;if(t.collisions){const t=Math.round(h*s),e=Math.round(d*s);if(t<0||t>a-1||e<0||e>i-1)return f;const n=l[e*a+t];if(-1!==n&&n!==o)return f;l[e*a+t]=o}const x=c??Math.max(f[f.length-1].colorTime,u(t,h,d));f.push({x:h,y:d,t:m,speed:g,colorTime:x}),y=w,M=p}return f}function m(t,e,n,r){const o=[],a=new l,i=1/Math.max(t.lineCollisionWidth,1),s=Math.round(n*i),c=Math.round(r*i),f=new Int32Array(s*c);for(let t=0;t<f.length;t++)f[t]=-1;const u=[];for(let e=0;e<r;e+=t.lineSpacing)for(let r=0;r<n;r+=t.lineSpacing)u.push({x:r,y:e,sort:a.getFloat()});u.sort((t,e)=>t.sort-e.sort);const{verticesPerLine:m}=t;for(let{x:n,y:r}of u)if(a.getFloat()<t.density&&h(t,n,r)<10){let l=null;for(let h=0;h<20;h++){const h=d(t,e,n,r,o.length,f,s,c,i,l);if(n=h[h.length-1].x,r=h[h.length-1].y,l=h[h.length-1].colorTime,!(h.length<2||(o.push(h),h.length<7)))for(let h=0;h<20;h++){const h=a.getFloat(),u=d(t,e,n+5*t.lineSpacing*Math.cos(2*Math.PI*h),r+5*t.lineSpacing*Math.sin(2*Math.PI*h),o.length,f,s,c,i,l);u.length>=2&&o.push(u)}}}t.verticesPerLine=m;for(const{x:n,y:r}of u)if(a.getFloat()<t.density){const l=d(t,e,n,r,o.length,f,s,c,i);if(l.length<2)continue;o.push(l)}return o}function g(t,e){const n=new l,r=t.reduce((t,e)=>t+e.length,0),o=new Float32Array(5*r),a=new Array(t.length);let i=0,s=0;for(const r of t){const t=i;for(const t of r)o[5*i]=t.x,o[5*i+1]=t.y,o[5*i+2]=t.t,o[5*i+3]=t.speed,o[5*i+4]=t.colorTime,i++;a[s++]={startVertex:t,numberOfVertices:r.length,totalTime:r[r.length-1].t,timeSeed:e?n.getFloat():0}}return{lineVertices:o,lineDescriptors:a}}function w(t,e){const{lineVertices:n,lineDescriptors:r}=t;let o=0,l=0;for(const t of r)o+=2*t.numberOfVertices,l+=6*(t.numberOfVertices-1);const a=new Float32Array(10*o),i=new Uint32Array(l);let s=0,c=0;function f(){i[c++]=s-2,i[c++]=s,i[c++]=s-1,i[c++]=s,i[c++]=s+1,i[c++]=s-1}function h(t,e,n,r,o,l,i,c,f){const h=10*s;let u=0;a[h+u++]=t,a[h+u++]=e,a[h+u++]=1,a[h+u++]=n,a[h+u++]=l,a[h+u++]=i,a[h+u++]=r/2,a[h+u++]=o/2,a[h+u++]=c,a[h+u++]=f,s++,a[h+u++]=t,a[h+u++]=e,a[h+u++]=-1,a[h+u++]=n,a[h+u++]=l,a[h+u++]=i,a[h+u++]=-r/2,a[h+u++]=-o/2,a[h+u++]=c,a[h+u++]=f,s++}for(const t of r){const{totalTime:r,timeSeed:o}=t;let l=null,a=null,i=null,s=null,c=null,u=null,d=null;for(let m=0;m<t.numberOfVertices;m++){const g=n[5*(t.startVertex+m)],w=n[5*(t.startVertex+m)+1],p=n[5*(t.startVertex+m)+2],y=n[5*(t.startVertex+m)+3],M=n[5*(t.startVertex+m)+4];let x=null,F=null,I=null,A=null;if(m>0){x=g-l,F=w-a;const t=Math.sqrt(x*x+F*F);if(x/=t,F/=t,m>1){let t=x+u,n=F+d;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*x+n*F),e);t*=o,n*=o,I=-n,A=t}else I=-F,A=x;null!==I&&null!==A&&(h(l,a,i,I,A,r,o,y,M),f())}l=g,a=w,i=p,u=x,d=F,s=y,c=M}h(l,a,i,-d,u,r,o,s,c)}return{vertexData:a,indexData:i}}function p(t){const{lineVertices:e,lineDescriptors:n}=t;let r=0,o=0;for(const t of n){const e=t.numberOfVertices-1;r+=4*e*2,o+=6*e*2}const l=new Float32Array(16*r),a=new Uint32Array(o);let i,s,c,f,h,u,d,m,g,w,p,y,M,x,F=0,I=0;function A(t,e){let n=g+p,r=w+y;const o=Math.sqrt(n*n+r*r);n/=o,r/=o;const A=g*n+w*r;n/=A,r/=A;let S=p+M,V=y+x;const v=Math.sqrt(S*S+V*V);S/=v,V/=v;const D=p*S+y*V;S/=D,V/=D,function(t,e,n,r,o,a,i,s,c,f,h,u,d,m){const g=16*F;let w=0;for(const p of[1,2])for(const y of[1,2,3,4])l[g+w++]=t,l[g+w++]=e,l[g+w++]=n,l[g+w++]=r,l[g+w++]=i,l[g+w++]=s,l[g+w++]=c,l[g+w++]=f,l[g+w++]=p,l[g+w++]=y,l[g+w++]=d,l[g+w++]=m,l[g+w++]=o/2,l[g+w++]=a/2,l[g+w++]=h/2,l[g+w++]=u/2,F++}(i,s,c,f,-r,n,h,u,d,m,-V,S,t,e),a[I++]=F-8,a[I++]=F-7,a[I++]=F-6,a[I++]=F-7,a[I++]=F-5,a[I++]=F-6,a[I++]=F-4,a[I++]=F-3,a[I++]=F-2,a[I++]=F-3,a[I++]=F-1,a[I++]=F-2}function S(t,e,n,r,o,l){if(g=p,w=y,p=M,y=x,null==g&&null==w&&(g=p,w=y),null!=h&&null!=u){M=t-h,x=e-u;const n=Math.sqrt(M*M+x*x);M/=n,x/=n}null!=g&&null!=w&&A(o,l),i=h,s=u,c=d,f=m,h=t,u=e,d=n,m=r}function V(t,e){g=p,w=y,p=M,y=x,null==g&&null==w&&(g=p,w=y),null!=g&&null!=w&&A(t,e)}for(const t of n){i=null,s=null,c=null,f=null,h=null,u=null,d=null,m=null,g=null,w=null,p=null,y=null,M=null,x=null;const{totalTime:n,timeSeed:r}=t;for(let o=0;o<t.numberOfVertices;o++)S(e[4*(t.startVertex+o)],e[4*(t.startVertex+o)+1],e[4*(t.startVertex+o)+2],e[4*(t.startVertex+o)+3],n,r);V(n,r)}return{vertexData:l,indexData:a}}function y(t,e){const n=e.pixels,{width:o,height:l}=e,a=new Float32Array(o*l*2),i=e.mask||new Uint8Array(o*l*2);if(e.mask||i.fill(255),"vector-uv"===t)for(let t=0;t<o*l;t++)a[2*t]=n[0][t],a[2*t+1]=-n[1][t];else if("vector-magdir"===t)for(let t=0;t<o*l;t++){const e=n[0][t],o=r.deg2rad(n[1][t]),l=Math.cos(o-Math.PI/2),i=Math.sin(o-Math.PI/2);a[2*t]=l*e,a[2*t+1]=i*e}return{data:a,mask:i,width:o,height:l}}async function M(t,e,n,r,o,l){const a={requestProjectedLocalDirections:!0,signal:l};if(null!=o&&(a.timeExtent=o),"imagery"===t.type){await t.load({signal:l});const o=await t.internalFetchImage(e,n,r,a);return null==o?.pixelData?.pixelBlock?{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r}:y(t.rasterInfo.dataType,o.pixelData.pixelBlock)}await t.load({signal:l});const i=await t.fetchPixels(e,n,r,a);return null==i?.pixelBlock?{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r}:y(t.serviceRasterInfo.dataType,i.pixelBlock)}t.createAnimatedLinesData=g,t.createFlowFieldFromData=c,t.createFlowMesh=async function(t,n,r,l){const a=performance.now(),i=c(n,r),f=performance.now(),h=m(n,i,r.width,r.height),u=performance.now(),d=g(h,!0),y=performance.now(),M="Streamlines"===t?w(d,10):p(d),x=performance.now();return e("esri-2d-profiler")&&(s().info("I.1","_createFlowFieldFromData (ms)",Math.round(f-a)),s().info("I.2","_getStreamlines (ms)",Math.round(u-f)),s().info("I.3","createAnimatedLinesData (ms)",Math.round(y-u)),s().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(x-y)),s().info("I.5","createFlowMesh (ms)",Math.round(x-a)),s().info("I.6","Mesh size (bytes)",M.vertexData.buffer.byteLength+M.indexData.buffer.byteLength)),await Promise.resolve(),o.throwIfAborted(l),M},t.createParticlesMesh=p,t.createStreamlinesMesh=w,t.getStreamlines=m,t.loadImagery=async function(t,n,r,o,l,c){const f=performance.now(),h=i.getInfo(n.spatialReference);if(!h){const a=await M(t,n,r,o,l,c);return e("esri-2d-profiler")&&s().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-f)),e("esri-2d-profiler")&&s().info("I.9","Number of parts",1),a}const[u,d]=h.valid,m=d-u,g=Math.ceil(n.width/m),w=n.width/g,p=Math.round(r/g);let y=n.xmin;const x=[],F=performance.now();for(let e=0;e<g;e++){const e=new a({xmin:y,xmax:y+w,ymin:n.ymin,ymax:n.ymax,spatialReference:n.spatialReference});x.push(M(t,e,p,o,l,c)),y+=w}const I=await Promise.all(x);e("esri-2d-profiler")&&s().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-F)),e("esri-2d-profiler")&&s().info("I.9","Number of parts",I.length);const A={data:new Float32Array(r*o*2),mask:new Uint8Array(r*o),width:r,height:o};let S=0;for(const t of I){for(let e=0;e<t.height;e++)for(let n=0;n<t.width;n++)S+n>=r||(A.data[2*(e*r+S+n)]=t.data[2*(e*t.width+n)],A.data[2*(e*r+S+n)+1]=t.data[2*(e*t.width+n)+1],A.mask[e*r+S+n]=t.mask[e*t.width+n]);S+=t.width}return e("esri-2d-profiler")&&s().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-f)),A},t.toFlowData=y,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});