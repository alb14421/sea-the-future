// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../core/QueueProcessor","../../../../../../core/SetUtils","../../../../../../geometry/Polygon","../../../../../../geometry/SpatialReference","../../../../../../geometry/support/aaBoundingRect","../../../../../../layers/graphics/featureConversionUtils","../../../../../../layers/graphics/OptimizedGeometry","../../../../../../layers/graphics/data/projectionSupport","../../../../../../layers/support/FieldsIndex","../../../../../../libs/parquet/parquet","./ALoadStrategy","./chunks/ParquetSourceChunk","../../support/FeatureSetReaderParquet"],function(e,t,i,a,s,r,n,o,l,u,d,h,m,c){"use strict";class y extends h.ALoadStrategy{constructor(e,t,i,a){super(a),this._metadata=t,this._schema=i,this._files=[];const s=new Set(i.mutable.availableFields);if(!e.geometryInfo.displayOptimization)throw new Error("InternalError: ParquetTileLoadStrategy only supports XZ-enabled parquet files");this._index=f.create(t,e,s,a,()=>this._schema.mutable.dataFilter.customParameters)}destroy(){super.destroy();for(const e of this._files)e.free()}get about(){return{supportsDisplayFilter:!1,willQueryAllFeatures:!0,willQueryFullResolutionGeometry:!0}}async load(e){const t=await this._index;await t.ensureLoaded(e)}unload(e){this._index.then(t=>t.unload(e.tile))}async updateFields(e){return(await this._index).updateFields(e)}async addParquetFile(e){throw new Error("Impl!")}}class f{static async create(e,t,i,a,s){const r=await Promise.all(t.source.urls.map(e=>d.createParquetFile(e,{geometryInfo:t.geometryInfo,outSpatialReference:t.outSpatialReference,getCustomParameters:s}))),[n]=r,o=n.fields().map(e=>({name:e.name,alias:e.name,type:e.type,column:n.columnForFieldName(e.name)})),{timeZoneByFieldName:l}=t.metadata.fieldsIndex,h=u.fromJSON({fields:o,timeZoneByFieldName:l}),m=new Uint32Array(Array.from(i.values()).map(e=>h.get(e)?.column).filter(e=>null!=e)),c=t.geometryInfo.displayOptimization;if(!c)throw new Error("InternalError: tiled parquet load requires display optimization");return new f(e,await Promise.all(r),h,m,a,i,c)}constructor(e,i,a,s,r,n,o){this._metadata=e,this._files=i,this._fieldsIndex=a,this._fieldIndices=s,this._store=r,this._availableFields=n,this._displayOptimization=o,this._queue=new t.QueueProcessor({concurrency:1,process:e=>this._ensureLoaded(e)}),this._tileIdToChunkId=new Map}get file(){return this._files[0]}async ensureLoaded(e){return this._queue.push(e)}unload(e){const t=this._tileIdToChunkId.get(e.id);if(null!=t){for(const e of t)this._store.removeById(e);this._tileIdToChunkId.delete(e.id)}}async _ensureLoaded(e){const t=this._metadata.outSpatialReference,i=e.tile,{xmin:u,ymin:d,xmax:h,ymax:y}=function(e,t){const i=[e.xmin,e.ymin,e.xmax,e.ymax],u=a.fromExtent(r.toExtent(i,t)),d=l.project(u,t,s.WGS84);if(!d)return null;const h=n.convertFromPolygon(new o,d,!1,!1),m=h.coords.filter((e,t)=>!(t%2)),c=h.coords.filter((e,t)=>t%2);return{xmin:Math.min(...m),ymin:Math.min(...c),xmax:Math.max(...m),ymax:Math.max(...c)}}(i.extent,t);let f=0;const p={extent:i.extent,extent_lat_lng:{xmin:u,ymin:d,xmax:h,ymax:y},tile_level:i.level,attributes:this._fieldIndices};if("z"===this._displayOptimization.mode?await this.file.queryZChunks(p.extent_lat_lng,this._fieldIndices,e.signal,t=>{if(e.signal.aborted)return;const a=new c.FeatureSetReaderParquet(this._metadata,this._fieldsIndex,t,f),s=new m.ParquetSourceChunk(this._metadata,a,i,f++,!1);this._insertChunk(i,s)}):await this.file.queryXZChunks(p,e.signal,t=>{if(e.signal.aborted)return;const a=new c.FeatureSetReaderParquet(this._metadata,this._fieldsIndex,t,f),s=new m.ParquetSourceChunk(this._metadata,a,i,f++,!1);this._insertChunk(i,s)}),e.signal.aborted)return;const _=new m.ParquetSourceChunk(this._metadata,null,i,f++,!0);this._insertChunk(i,_)}_insertChunk(e,t){let i=this._tileIdToChunkId.get(e.id);null==i&&(i=[],this._tileIdToChunkId.set(e.id,i)),i.push(t.chunkId),this._store.insert(t)}async updateFields(e){const t=new Set(e),a=i.difference(t,this._availableFields);if(this._availableFields=i.union(a,this._availableFields),a.size)for(const e of this._files){const t=Array.from(a).map(e=>this._fieldsIndex.get(e)?.column);await e.ensureFields(new Uint32Array(t))}}}e.ParquetTileLoadStrategy=y,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});