// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../request","../../../../../core/has","../../../../../core/promiseUtils","../../../../../core/accessorSupport/diffUtils","../../../../../layers/graphics/OptimizedFeature","../../../../../layers/graphics/data/QueryEngine","../../../../../rest/query/operations/query","../../../../../rest/support/StatisticDefinition","../FeatureStoreStatistics","./FeatureSourceQueryInfo","./StreamMessenger","./strategies/DrillDownTileLoadStrategy","./strategies/PagedTileLoadStrategy","./strategies/ParquetSnapshotLoadStrategy","./strategies/ParquetTileLoadStrategy","./strategies/SnapshotLoadStrategy","./strategies/StreamLoadStrategy","./strategies/chunks/SourceChunkStore","../support/FeatureMetadata","../../support/UpdateTracking2D"],function(e,t,a,s,r,i,n,o,c,d,u,h,l,y,m,p,_,g,f,S,b){"use strict";e.FeatureSource=class{constructor(e,t,a,s,r){this.service=e,this._aggregateAdapter=t,this._subscriptions=a,this._connection=s,this._cachedObjectIds=r,this._updateTracking=new b.UpdateTracking2D({debugName:"FeatureSource"}),this._didInvalidateData=!1,this._metadata=S.FeatureMetadata.createFeature(e.metadata),this._store=new f.FeatureSourceChunkStore(this._metadata)}destroy(){this._strategy?.destroy(),this._store.destroy(),this._streamMessenger?.destroy(),"memory"===this.service.type&&this.service.source.map(e=>e.close())}get metadata(){if(!this._metadata)throw new Error("InternalError: Metadata not defined. Was update called?");return this._metadata}get store(){return this._store}get streamMessenger(){return null==this._streamMessenger&&this._initStreamMessenger(),this._streamMessenger}get statistics(){return d.FeatureStoreStatistics.from(this._store)}get updateTracking(){return this._updateTracking}get queryEngine(){if(!this._queryEngine){if(!this._schema)return null;const{dataFilter:e}=this._schema.mutable,t=this._schema.mutable.availableFields,a=this._metadata;this._queryEngine=new n.QueryEngine({featureStore:this._store,fieldsIndex:a.fieldsIndex,geometryType:a.geometryType,featureIdInfo:a.featureIdInfo,hasM:!1,hasZ:!1,spatialReference:this.service.outSpatialReference,aggregateAdapter:this._aggregateAdapter,timeInfo:a.timeInfo,definitionExpression:e.definitionExpression,availableFields:t})}return this._queryEngine}get isStream(){return"stream"===this._schema.type}get hasDisplayFilter(){return!!this._schema&&"displayFilterInfo"in this._schema.mutable&&null!=this._schema.mutable.displayFilterInfo}chunks(){return Array.from(this._store.chunks())}prepareCacheUpdate(e,t){const a=new Set,s=new Set;for(const t of e)this._cachedObjectIds.has(t)||(this._cachedObjectIds.add(t),a.add(t));for(const e of t)this._cachedObjectIds.delete(e),s.add(e);this.hasDisplayFilter&&this._strategy.prepareCacheUpdate(a,s)}async applyCacheUpdate(){this.hasDisplayFilter&&await this._updateTracking.addPromise(this._strategy.applyCacheUpdate())}cleanup(){return this._store.cleanup()}onSubscribe(e){if(this._connection.onEvent({type:"subscribe",tile:e.tile.id}),!this._strategy)return;const t=this._strategy.load(e);t.then(()=>this._connection.onEvent({type:"loaded",tile:e.tile.id})).catch(t=>this._connection.onEvent({type:"error",tile:e.tile.id,error:t})),this._updateTracking.addPromise(t)}onResume(e){this._updateTracking.addPromise(s.ignoreAbortErrors(this._strategy?.load(e)))}onUnsubscribe(e){this._connection.onEvent({type:"unsubscribe",tile:e.tile.id}),this._strategy?.unload(e)}applyOverride(e){this._didInvalidateData=!0,this._store.applyOverride(e)}takeOverrideUpdate(){return this._store.takeOverrideUpdate()}async update(e,t){const s=e.source,i=r.diff(this._schema?.mutable,s.mutable);if(!i)return!1;if(a("esri-2d-update-debug")&&console.debug(`Version[${t}] FeatureSource.update`,{changes:i}),this._schema=s,this._queryEngine?.destroy(),this._queryEngine=null,"feature-service"===this.service.type&&null!=this.service.queryMetadata.lastEditDate&&(this._lastEditDate=this.service.queryMetadata.lastEditDate),null==this._streamMessenger&&"stream"===this._schema.type&&this._initStreamMessenger(),r.hasRootDiffOnly(i,"sourceRefreshVersion")&&this._strategy?.refresh)return this._strategy.refresh();if(("feature"===s.type||"parquet"===s.type)&&r.hasRootDiffOnly(i,"availableFields")){if(await this._queryLastEditDateChanged()||this._didInvalidateData)this._didInvalidateData=!1,await this._updateStrategy(t);else{this._connection.onEvent({type:"updateFieldsStart"});try{await this._strategy.updateFields(s.mutable.availableFields),this._connection.onEvent({type:"updateFieldsEnd"})}catch(e){this._connection.onEvent({type:"updateFieldsError",error:e})}}return!1}return!!(r.hasRootDiff(i,"dataFilter")||r.hasRootDiff(i,"sourceRefreshVersion")||this._strategy.about.supportsDisplayFilter&&r.hasRootDiff(i,"displayFilterInfo"))&&(await this._updateStrategy(t),!0)}async addParquetFile(e){await this._strategy.addParquetFile(e)}unsafeSetQueryHistoricMoment(e){"feature"===this._schema.type&&(this._schema.mutable.dataFilter.historicMoment=e,this._strategy.unsafeSetQueryHistoricMoment(new Date(e)))}_initStreamMessenger(){null==this._streamMessenger&&(this._streamMessenger=new h.StreamMessenger(this._connection))}async normalizeOverrides(e){const t={historicMoment:e.historicMoment,commands:{updateWeak:e.commands.updateWeak.map(i.OptimizedFeature.fromJSON),removeWeak:e.commands.removeWeak,update:e.commands.update.map(i.OptimizedFeature.fromJSON),remove:e.commands.remove,release:e.commands.release}},a=e.commands.updateByIdWeak,s=await this._queryOptimizedFeatures(a);return t.commands.updateWeak.push(...s),t}async _queryOptimizedFeatures(e){if(0===e.length)return[];const t=[],a=(await this._strategy.queryByObjectId(e)).getCursor();for(;a.next();)t.push(a.readOptimizedFeatureWorldSpace());return t}getObjectIdsFromGlobalIds(e){const t=this.metadata.globalIdField;if(null==t)throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");const a=this._store.mapObjectIdsFromGlobalIds(e,t).values();return Array.from(a)}async _queryLastEditDateChanged(){if(null==this._lastEditDate)return!1;const e=this.service.source,a={...e.query,f:"json"},s=(await t(e.path,{query:a,responseType:"json"})).data.editingInfo.lastEditDate;return s!==this._lastEditDate&&(this._lastEditDate=s,!0)}async _createStrategy(){const e="isSourceHosted"in this.service&&this.service.isSourceHosted,t=Array.isArray(this.service.source),a=this.service.source&&"collection"in this.service.source,s=e||t||a;if("stream"===this._schema.type){const e=new g.StreamLoadStrategy(this.service,this._schema.mutable.dataFilter,this._store,{outSR:this.service.outSpatialReference},this.metadata);return this._streamMessenger.strategy=e,e}if("parquet"===this._schema.type){const e=this.service;return null!=e.geometryInfo.displayOptimization?new p.ParquetTileLoadStrategy(e,this._metadata,this._schema,this._store):new m.ParquetSnapshotLoadStrategy(e,this._metadata,this._schema,this._store)}const r=this.service,i=u.FeatureSourceQueryInfo.fromSchema(r,this._schema,this._metadata),n=await this._supportSnapshotMode(r,i);return n?new _.SnapshotLoadStrategy(r,i,this._store,n,this.metadata,this._connection):s?new y.PagedTileLoadStrategy(r,i,this._store,this.metadata,this._connection):new l.DrillDownTileLoadStrategy(r,i,this._store,this.metadata,this._connection)}async _updateStrategy(e){const t=await this._createStrategy();this._connection.onEvent({type:"updateStrategyStart",about:t.about});const r=!!this._strategy;this._store.clear(),this._strategy?.destroy(),this._strategy=t,a("esri-2d-update-debug")&&console.debug(`Version[${e}] FeatureSource.updateStrategy`,{strategy:t});const i=Array.from(this._subscriptions.values());if(!i.length)return void this._connection.onEvent({type:"updateStrategyEnd"});const n=Promise.all(i.map(e=>this._strategy.load(e).then(()=>this._connection.onEvent({type:"loaded",tile:e.tile.id})).catch(t=>this._connection.onEvent({type:"error",tile:e.tile.id,error:t}))));this._updateTracking.addPromise(n),this._strategy.prepareCacheUpdate(this._cachedObjectIds);try{r&&await n}catch(e){s.throwIfNotAbortError(e)}this._connection.onEvent({type:"updateStrategyEnd"}),a("esri-2d-update-debug")&&console.debug(`Version[${e}] FeatureSource.updateStrategyEnd`,{strategy:t})}async _supportSnapshotMode(e,t){const{queryMetadata:a}=e,s=a.snapshotInfo;return s?await this._executeExceedsLimitQuery(e,t,s)?null:s:null}async _executeExceedsLimitQuery(e,t,a){if(!a.supportsExceedsLimit)return this._executeExceedsLimitFallbackQuery(e,t,a);try{const s=e.source,r=t.createQuery();r.inner.orderByFields=[],r.inner.returnGeometry=!1;const i=new c;i.statisticType="exceedslimit",i.maxPointCount=a.maxFeatureCount,i.maxRecordCount=a.maxFeatureCount,i.outStatisticFieldName="exceedslimit",a.maxVertexCount&&(i.maxVertexCount=a.maxVertexCount),r.inner.outStatistics=[i],r.inner.cacheHint=!0;const n=await o.executeQuery(s,r.inner,void 0,{query:r.customParameters}),d=n.data.features[0]?.attributes.exceedslimit;return!(0===d)}catch(e){return!0}}async _executeExceedsLimitFallbackQuery(e,t,a){if(a.maxVertexCount)return!0;const s=e.source,r=t.createQuery();r.inner.orderByFields=[],r.inner.returnGeometry=!1,r.inner.cacheHint=!0;try{return(await o.executeQueryForCount(s,r.inner,{query:r.customParameters})).data.count>a.maxFeatureCount}catch(e){return!0}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});