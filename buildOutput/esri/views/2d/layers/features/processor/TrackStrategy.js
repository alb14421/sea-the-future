// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../../core/arrayUtils","../../../../../core/Logger","../../../../../core/maybe","../../../../../geometry/operators/gx/operatorGeodeticDensify","../../../../../geometry/operators/support/geodeticCurveType","../../../../../geometry/support/aaBoundingRect","../../../../../geometry/support/normalizeUtils","../../../../../geometry/support/normalizeUtilsSync","../../../../../layers/graphics/featureConversionUtils","../../../../../layers/graphics/OptimizedFeature","../../../../../layers/graphics/OptimizedGeometry","../../../../../layers/support/streamLayerUtils","../../../engine/webgl/definitions","../aggregation/AccumulatedStatistics","../aggregation/ComputedAggregateField","./AAggregateStrategy","./AProcessorStrategy","../sources/FeatureSourceMessage","../support/arcadeUtils","../support/ComputedAttributeStorage","../support/FeatureFilterEvaluator","../support/FeatureMetadata","../support/FeatureSetReaderIndirect","../support/FeatureSetReaderJSON"],function(e,t,s,r,a,i,o,n,l,c,d,u,h,p,m,f,g,b,_,y,I,F,v,k,O,S){"use strict";let T;class x{constructor(e,t,s,r,a){this.chunkIndex=e,this.featureIndex=t,this.objectId=s,this.displayId=r,this.time=a}}class R{static getOid(e){return p.externalTrackLineOidPrefix+e}constructor(e,t,s,r,a,i,o,n){this._schema=e,this.trackId=t,this.objectId=s,this.displayId=r,this._fields=a,this._spatialReference=i,this._metadata=o,this._isStream=n,this._maxDisplayDuration=this._schema.maxDisplayDuration>0?this._schema.maxDisplayDuration:1/0,this._maxDisplayObservationsPerTrack=this._schema.maxDisplayObservationsPerTrack>=1?this._schema.maxDisplayObservationsPerTrack:1/0,this._observationRecords=[],this._nextObservationRecords=[],this._trackLinePath=[],this._bounds=[],this._trackLineGeometry=new h}get _trackLineAttributes(){const e={...this._latestObservationFeature?.attributes??{},aggregateId:this.objectId,[p.internalTrackPartField]:0};if(null!=this._statistics)for(const t of this._statistics.values())e[t.field.name]=t.value;return e}get _startTimeField(){return this._metadata.timeInfo?.startTimeField}get length(){return this._observationRecords.length}*observations(){yield*this._observationRecords}*previousObservations(){for(let e=0;e<this._observationRecords.length-1;e++)yield this._observationRecords[e]}get latestObservationFeature(){return this._latestObservationFeature}get latestObservationRecord(){return this._latestObservationRecord}stageObservation(e,t){this._nextObservationRecords.push(new x(e,t.getIndex(),t.getObjectId(),t.getDisplayId(),null!=this._startTimeField?t.readAttributeAsTimestamp(this._startTimeField):null))}commitObservations(e,t,s){const r=new Set(this._nextObservationRecords.map(e=>e.objectId)),h=this._observationRecords.filter(e=>!r.has(e.objectId)).map(e=>e.objectId);let m,f;switch(this._observationRecords=[],this._trackLinePath=[],this._isStream||null==this._startTimeField||this._nextObservationRecords.sort((e,t)=>{const s=e.time,r=t.time;return null!=s&&null!=r?s-r:0}),this._schema.timeField){case"startTimeField":m=this._metadata.timeInfo?.startTimeField;break;case"endTimeField":m=this._metadata.timeInfo?.endTimeField;break;case"timeReceived":m=this._isStream?p.internalTimeReceivedField:null}f=this._isStream?s?.end??Date.now():s?.end??-1/0;const g=t.map(e=>e.reader.getCursor());let b;for(let e=this._nextObservationRecords.length-1;e>=0&&!(this._observationRecords.length>=this._maxDisplayObservationsPerTrack);e--){const t=this._nextObservationRecords[e],s=g[t.chunkIndex];a.assertIsSome(s),s.setIndex(t.featureIndex);const r=null!=m?s.readAttributeAsTimestamp(m):null;(null!=r?f-r:0)>=this._maxDisplayDuration||(this._commitObservation(t,s),b??=t)}if(null!=b){const{chunkIndex:t,featureIndex:s}=b,r=`${b.objectId}.latest`,i=e.createDisplayIdForObjectId(r),o=g[t];a.assertIsSome(o),o.setIndex(s);const n=new u.OptimizedFeature(o.readGeometryWorldSpace(),{...o.readAttributes(),[p.internalTrackPartField]:1},null,r,i);this._latestObservationFeature&&h.push(this._latestObservationFeature.objectId),this._latestObservationFeature=n,this._latestObservationRecord=b}else this._latestObservationFeature=null;return this._trackLineGeometry=function(e,t,s){if(t.length<2)return d.convertFromNestedArray(e,[t],!1,!1);if(s.isWrappable){let r=!1;for(let e=1;e<t.length;e++){const a=t[e][0],i=l.getClosestDenormalizedXToReference(a,t[e-1][0],s);a!==i&&(t[e][0]=i,r=!0)}if(r){const r=c.normalizeCentralMeridianForDisplay({paths:[t],spatialReference:s});if(null!=r)return d.convertFromNestedArray(e,r.paths,!1,!1)}return d.convertFromNestedArray(e,[t],!1,!1)}const r=T.fromGeometryToGXGeometry({hasM:!1,hasZ:!1,paths:[t]}),a=T.fromSpatialReference(s);if(null!=a){const t=i.execute(r,1e6,a,o.geodeticCurveType.geodesic);if(null!=t){const s=T.toGeometry(t,a);if(null!=s&&"paths"in s)return d.convertFromNestedArray(e,s.paths,!1,!1)}}return d.convertFromNestedArray(e,[t],!1,!1)}(this._trackLineGeometry,this._trackLinePath,this._spatialReference),this._bounds=function(e){const{lengths:t,coords:s}=e;if(!t.length)return[n.empty()];const r=[];let a=0;for(let e=0;e<t.length;e++){const i=t[e],o=n.empty();r.push(o);for(let e=0;e<i;e++){const t=s[2*(e+a)],r=s[2*(e+a)+1];n.expandPointInPlace(o,[t,r])}a+=i}return r}(this._trackLineGeometry),this._nextObservationRecords=[],h}updateStatistics(e,t){this._statistics=f.AccumulatedStatistics.create(this._fields);const s=e.map(e=>e.reader.getCursor());for(const{chunkIndex:e,featureIndex:r}of this._observationRecords){const i=s[e];a.assertIsSome(i),i.setIndex(r),this._statistics.insert(i,t)}}overlapsTile(e){for(const t of this._bounds)if(n.intersectsWithMargin(t,e.bounds,32))return!0;return!1}getLatestObservationFeatureForTile(e){if(null==this._latestObservationFeature)return null;const{objectId:t,displayId:s,geometry:r,attributes:a}=this._latestObservationFeature,i=new h;d.quantizeOptimizedGeometry(i,r,!1,!1,this._metadata.geometryType,e.subscription.tile.transform);const o=n.fromValues(1/0,1/0,-1/0,-1/0);return function(e,t){const{coords:s,lengths:r}=e;if(!r.length)return void t(s[0],s[1]);let a=0;for(let e=0;e<r.length;e++){const i=r[e];let o=0,n=0;for(let e=0;e<i;e++)o+=s[2*(e+a)],n+=s[2*(e+a)+1],t(o,n);a+=i}}(i,(e,t)=>n.expandPointInPlace(o,[e,t])),n.intersects(o,n.fromValues(0,0,m.tileSize,m.tileSize))?new u.OptimizedFeature(i,a,null,t,s):null}getTrackLineFeatureForTile(e){const t=new h;return d.quantizeOptimizedGeometry(t,this._trackLineGeometry,!1,!1,"esriGeometryPolyline",e.subscription.tile.transform),new u.OptimizedFeature(t,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineOptimizedFeature(){return new u.OptimizedFeature(this._trackLineGeometry,this._trackLineAttributes,null,this.objectId,this.displayId)}getTrackLineDisplayFeature(){const{_trackLineGeometry:e,_trackLineAttributes:t,displayId:s}=this;return{geometry:d.convertToGeometry(e,"esriGeometryPolyline",!1,!1),attributes:t,displayId:s}}_commitObservation(e,t){const s=t.readCentroidWorldSpace();let r=s?.coords[0],a=s?.coords[1];null==s&&(r=t.readXWorldSpace(),a=t.readYWorldSpace()),null!=r&&null!=a&&(this._observationRecords.unshift(e),this._trackLinePath.unshift([r,a]))}}class A extends _.ASendState{constructor(e){super(e),this.done=!1}}class j extends b.AAggregateStrategy{static async create(t,s,r,a,o,n){const l=new F.ComputedAttributeStorage({spatialReference:s}),c=await Promise.all(t.fields.map(async e=>g.ComputedAggregateField.create(l,e))),d=t.featureFilter?await v.create({geometryType:r.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:r.metadata.timeInfo,fieldsIndex:r.metadata.fieldsIndex,spatialReference:s,filterJSON:t.featureFilter}):null;return s.isWrappable||i.isLoaded()||await Promise.all([new Promise((t,s)=>e(["../../../../../geometry/operators/support/apiConverter"],t,s)),new Promise((t,s)=>e(["../../../../../geometry/operators/support/jsonConverter"],t,s)),i.load()]).then(([e,t,s])=>{T={fromGeometryToGXGeometry:t.fromGeometryToGXGeometry,toGeometry:t.toGeometry,fromSpatialReference:e.fromSpatialReference}}),new j(t,r,a,s,c,d,o,n)}constructor(e,t,s,r,a,i,o,n){super(t,s,r,a,n),this._schema=e,this._featureFilter=i,this._arcadeContextInfo=o,this._tracks=new Map,this._handledChunks=new Set,this._metadata=t.metadata.weakCloneWithAdditionalFields([{name:p.internalTrackPartField,alias:"trackPart",type:"esriFieldTypeSmallInteger"}]),this._trackLineMetadata=k.FeatureMetadata.createFeature({geometryType:"esriGeometryPolyline",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:{fields:[...this._source.metadata.fieldsIndex.fields,...this.aggregateFields,{name:p.internalTrackPartField,alias:"trackPart",type:"esriFieldTypeSmallInteger"},{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}],timeZoneByFieldName:null},globalIdField:null,spatialReference:t.metadata.spatialReference,outSpatialReference:t.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:t.metadata.timeInfo,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}destroy(){super.destroy();for(const e of this._tracks.values())this._removeTrack(e);this._tracks.clear()}get _isStream(){return this._source.isStream}get enablePixelBuffering(){return!0}get isAggregate(){return!1}requiresInvalidation(){const e=new Set(this._source.chunks().map(e=>e.chunkId));for(const t of e)if(!this._handledChunks.has(t))return!0;for(const t of this._handledChunks)if(!e.has(t))return!0;return!1}invalidate(){this._handledChunks.clear(),super.invalidate()}createState(e){return new A(e)}async*applyOverrideUpdate(e){r.getLogger("esri.views.2d.layers.features.processor.TrackStrategy").error("Applying override to tracks is not supported")}displayMap(e,t,s){const r=new Map(e.map(e=>[t(e),e])),a=[];for(const e of this._tracks.values()){const t=r.get(e.objectId);if(null!=t){const i=s(e.displayId,t,e.objectId);a.push(i),r.delete(e.objectId);continue}const i=e.latestObservationFeature;if(i?.objectId){const e=r.get(i.objectId);if(null!=e){const t=s(i.displayId,e,i.objectId);a.push(t),r.delete(i.objectId);continue}}for(const t of e.observations()){const e=r.get(t.objectId);if(null!=e){const i=s(t.displayId,e,t.objectId);a.push(i),r.delete(t.objectId)}}}return a}getDisplayFeatures(e){const t=new Set(e),s=[],r=[],a=this._source.chunks().map(e=>e.reader.getCursor());for(const e of this._tracks.values()){if(t.has(e.displayId)&&r.push(e.getTrackLineDisplayFeature()),null!=e.latestObservationFeature&&t.has(e.latestObservationFeature.displayId)){const{displayId:t,chunkIndex:r,featureIndex:i}=e.latestObservationRecord,o=a[r];o.setIndex(i),s.push({displayId:t,...o.readLegacyFeatureWorldSpace()})}for(const{displayId:r,chunkIndex:i,featureIndex:o}of e.observations())if(t.has(r)){const e=a[i];e.setIndex(o),s.push({displayId:r,...e.readLegacyFeatureWorldSpace()})}}return{features:s,aggregates:[],tracks:r}}getFeatureObjectIdsForAggregate(e){for(const t of this._tracks.values())if(t.objectId===e)return Array.from(t.observations(),e=>e.objectId);return[]}async*updateChunks(){0===this._handledChunks.size&&this._rebuildTracks();for(const e of this._sendStates.values())yield*this._update(e)}forEachAggregateWorldSpace(e){for(const t of this._tracks.values())e(t.getTrackLineOptimizedFeature())}_rebuildTracks(){const e=this._source.chunks();if(!e.length)return;const t=this._metadata.timeInfo?.trackIdField;if(null==t)return;const s=new Set;for(let r=0;r<e.length;r++){const a=e[r];this._handledChunks.add(a.chunkId);const i=a.reader.getCursor();for(;i.next();){const e=i.readAttribute(t),a=i.getObjectId();if(null!=e&&null!=a&&(null===this._featureFilter||this._featureFilter.check(i,this._sqlOptions))){if(i.getDisplayId()||i.setDisplayId(this._attributeStore.createDisplayIdForObjectId(a)),!this._tracks.has(e)){const t=R.getOid(e),s=this._attributeStore.createDisplayIdForObjectId(t),r=new R(this._schema,e,t,s,this.aggregateFields,this.spatialReference,this._source.metadata,this._isStream);this._tracks.set(e,r)}this._tracks.get(e).stageObservation(r,i),s.add(e)}}}for(const t of this._tracks.values())if(s.has(t.trackId)){const s=t.commitObservations(this._attributeStore,e,this._featureFilter?.timeExtent);for(const e of s)this._attributeStore.releaseDisplayIdForObjectId(e);t.updateStatistics(e,I.createArcadeEvaluationOptions(1,this._arcadeContextInfo))}else this._removeTrack(t)}_removeTrack(e){this._tracks.delete(e.trackId),this._attributeStore.releaseDisplayIdForObjectId(e.objectId);for(const{objectId:t}of e.observations())this._attributeStore.releaseDisplayIdForObjectId(t);null!=e.latestObservationFeature&&this._attributeStore.releaseDisplayIdForObjectId(e.latestObservationFeature.objectId)}*_update(e){if(e.done)return;e.done=!this._source.updateTracking.updating;const t=[],r=[];for(const s of this._tracks.values())if(s.length>0){if(this._schema.showLatestObservation){const r=s.getLatestObservationFeatureForTile(e);null!=r&&t.push(r)}this._schema.showTrackLine&&s.overlapsTile(e.subscription.tile)&&r.push(s.getTrackLineFeatureForTile(e))}const a=S.FeatureSetReaderJSON.fromOptimizedFeatures(t,this._metadata,e.subscription.tile.transform),i=S.FeatureSetReaderJSON.fromOptimizedFeatures(r,this._trackLineMetadata,e.subscription.tile.transform);let o=[];if(this._schema.showPreviousObservations){const t=this._source.chunks().map(()=>[]);for(const e of this._tracks.values())for(const{chunkIndex:s,featureIndex:r}of e.previousObservations())t[s].push(r);o=this._source.chunks().map((s,r)=>{const a=s.getTileReader(e.subscription.tile);if(null==a)return null;const i=O.FeatureSetReaderIndirect.from(a,t[r]);return i.setProcessorAttributes({[p.internalTrackPartField]:2}),"esriGeometryPoint"!==i.geometryType&&null!=i.getInTransform()||i.setTransformForDisplay(e.subscription.tile.transform),i}).filter(s.isSome)}this.events.emit("changed");const n=e.subscription.tile.createArcadeEvaluationOptions(this._arcadeContextInfo),l=i.getCursor();for(;l.next();)this._attributeStore.setAttributeData(l.getDisplayId(),l,n,this._sqlOptions);for(const e of o){const t=e.getCursor();for(;t.next();)this._attributeStore.setAttributeData(t.getDisplayId(),t,n,this._sqlOptions)}const c=a.getCursor();for(;c.next();)this._attributeStore.setAttributeData(c.getDisplayId(),c,n,this._sqlOptions);yield new y.FeatureTileAppendMessage(e.subscription,i,!1,!1,{});for(const t of o)yield new y.FeatureTileAppendMessage(e.subscription,t,!1,!1,{});yield new y.FeatureTileAppendMessage(e.subscription,a,!1,e.done,{})}}t.TrackStrategy=j,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});