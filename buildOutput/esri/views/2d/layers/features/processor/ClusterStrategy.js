// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../layers/graphics/featureConversionUtils","../../../../../layers/graphics/OptimizedFeature","../../../../../layers/graphics/OptimizedGeometry","../../../../../layers/support/FieldsIndex","../../../engine/webgl/definitions","../aggregation/ComputedAggregateField","../aggregation/GridCell","../aggregation/GridSpatialIndex","./AAggregateStrategy","./AProcessorStrategy","./support/WithDisplayId","../sources/FeatureSourceMessage","../support/ComputedAttributeStorage","../support/FeatureFilterEvaluator","../support/FeatureMetadata","../support/FeatureSetReaderJSON","../../../tiling/TileKey"],function(e,t,i,s,r,a,n,l,o,d,u,c,h,p,g,f,_,y){"use strict";class S extends u.ASendState{constructor(e){super(e),this.didSend=!1,this.done=!1}}class m{constructor(e,t,i,s,r){this._level=e,this._scale=t,this._indexOptions=i,this._clusterRadius=s,this._store=r,this._cells=new Map,this._handledChunks=new Set,this._statistics=new Map,this._clusters=new Map}destroy(){this._clearClusters()}_clearClusters(){for(const e of this._clusters.values())this._store.releaseDisplayIdForObjectId(e.inner.id);this._clusters.clear()}*aggregatesWorldSpace(){for(const e of this._clusters.values()){const t=e.inner.getCentroid(null),s=new i.OptimizedFeature(t,e.inner.getAttributes(),null,e.inner.id,e.displayId);yield s}}clusters(){return this._clusters.values()}updateChunks(e,t){let i=!1;for(const t of e){const e=t.queryInfo;"tileId"in e&&new y(e.tileId).level!==this._level||this._handledChunks.has(t.normalizedChunkId)||(this._handledChunks.add(t.normalizedChunkId),i=!0,t.getAggregateIndex({...this._indexOptions,scale:this._scale}).put(this._cells))}const s={xMin:1/0,yMin:1/0,xMax:-1/0,yMax:-1/0},r=o.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale),a=this._indexOptions.cellSize;for(const{subscription:e}of t){const t=e.tile.bounds,i=Math.floor(t[0]*r/a),n=Math.floor(t[1]*r/a),l=Math.ceil(t[2]*r/a),o=Math.ceil(t[3]*r/a);s.xMin=Math.min(s.xMin,i),s.yMin=Math.min(s.yMin,n),s.xMax=Math.max(s.xMax,l),s.yMax=Math.max(s.yMax,o)}return null!=this._lastCellBounds&&s.xMin===this._lastCellBounds.xMin&&s.yMin===this._lastCellBounds.yMin&&s.yMin===this._lastCellBounds.yMin&&s.yMax===this._lastCellBounds.yMax||(i=!0,this._lastCellBounds=s),i&&this._clusterCells(s),i}async updateStatistics(e){let t=!1;for(const e of this._clusters.values())e.inner.count>1&&(t=this._updateAggregateStatistics(this._statistics,e.inner)||t);if(t){const t=Array.from(this._statistics.entries()).map(([e,t])=>({fieldName:e,minValue:t.minValue,maxValue:t.maxValue}));await e.container.updateStatistics(this._level,t)}}createAggregateFeatures(e,t){const r=e.subscription,n=[],l=r.tile.transform;for(const e of this._clusters.values()){let t=e.inner.getCentroidX(l);const o=e.inner.getCentroidY(l),d=r.tile.lod,u=d.wrap?d.worldSize[0]:null,c=1===e.inner.count?e.inner.firstObjectId:e.inner.id,h=e.displayId;if(null!=u)if(1===u){const r=new s([],[t,o]),l=new i.OptimizedFeature(r,e.inner.getAttributes(),null,c,h);l.geometry.coords[0]-=a.tileSize,n.push(l);const d=new s([],[t,o]),u=new i.OptimizedFeature(d,e.inner.getAttributes(),null,c,h);u.geometry.coords[0]+=a.tileSize,n.push(u)}else t>a.tileSize+a.tileSize/2?t-=u*a.tileSize:t<-256&&(t+=u*a.tileSize);if(t<a.tileSize+128&&t>=-128&&o<a.tileSize+128&&o>=-128){const r=new s([],[t,o]),a=new i.OptimizedFeature(r,e.inner.getAttributes(),null,c,h);n.push(a)}}return _.FeatureSetReaderJSON.fromOptimizedFeatures(n,t,r.tile.transform)}_clusterCells(e){let t=Array.from(this._cells.values());t=t.sort((e,t)=>t.count-e.count);const i=[];for(const e of this._clusters.values())i.push(e.inner.id);this._clusters.clear();const s=this._clusterRadius*(1/o.pixelsPerMapUnit(this._indexOptions.spatialReference,this._scale)),r=1+this._clusterRadius/this._indexOptions.cellSize,a=new Set;for(const i of t){if(a.has(i.id))continue;if(i.gridX<e.xMin||i.gridX>e.xMax||i.gridY<e.yMin||i.gridY>e.yMax)continue;const t=this._store.createDisplayIdForObjectId(i.id),n=new c.WithDisplayId(i.clone(),t);a.add(i.id),this._clusters.set(i.id,n);const o=i.centroidXWorld,d=i.centroidYWorld;for(let e=i.gridY-r;e<=i.gridY+r;e++)for(let t=i.gridX-r;t<=i.gridX+r;t++){if(e===i.gridY&&t===i.gridX)continue;const r=this._cells.get(l.GridCell.createId(t,e));if(!r||a.has(r.id))continue;const u=Math.abs(r.centroidXWorld-o),c=Math.abs(r.centroidYWorld-d);u<s&&c<s&&(n.inner.merge(r),a.add(r.id))}}for(const e of i)this._store.releaseDisplayIdForObjectId(e)}_updateAggregateStatistics(e,t){let i=!1;for(const s of t.statistics.values()){if("esriFieldTypeString"===s.field.type)continue;const t=s.value,r=s.field,a=e.get(r.name);if(a){const{minValue:e,maxValue:s}=a,r=Math.min(a.minValue,t),n=Math.max(a.maxValue,t);e===r&&s===n||(a.minValue=r,a.maxValue=n,i=!0);continue}e.set(r.name,{minValue:t,maxValue:t}),i=!0}return i}}class x extends d.AAggregateStrategy{static async create(e,t,i,s,r,a,l){const o=new p.ComputedAttributeStorage({spatialReference:i}),d={type:"grid",fields:await Promise.all(t.fields.map(async e=>n.ComputedAggregateField.create(o,e))),spatialReference:i,featureFilter:t.featureFilter?await g.create({geometryType:s.metadata.geometryType,hasM:!1,hasZ:!1,timeInfo:s.metadata.timeInfo,fieldsIndex:s.metadata.fieldsIndex,spatialReference:i,filterJSON:t.featureFilter}):null,cellSize:t.clusterRadius/4,arcadeContextInfo:a,sqlOptions:l};return new x(e,t.clusterRadius,d,t.fields,s,r,l)}constructor(e,t,i,s,a,n,l){super(a,n,i.spatialReference,i.fields,l),this._connection=e,this._clusterRadius=t,this._indexOptions=i,this._cellsPerScale=new Map,this._metadata=f.FeatureMetadata.createFeature({geometryType:"esriGeometryPoint",featureIdInfo:{type:"object-id",fieldName:"aggregateId"},fieldsIndex:new r([...s,...this._source.metadata.fieldsIndex.fields,{name:"aggregateId",alias:"aggregateId",type:"esriFieldTypeOID"}]).toJSON(),globalIdField:null,spatialReference:a.metadata.spatialReference,outSpatialReference:a.metadata.outSpatialReference,subtypeField:null,subtypes:null,timeInfo:null,timeReferenceUnknownClient:null,dateFieldsTimeZone:null,typeIdField:null,types:null})}get enablePixelBuffering(){return!1}invalidate(){super.invalidate();for(const e of this._cellsPerScale.values())e.destroy();this._cellsPerScale.clear()}onSubscribe(e){super.onSubscribe(e),this._requiredLevel=e.tile.level,this._requiredScale=e.tile.scale}createState(e){return new S(e)}async*applyOverrideUpdate(e){for(const e of this._cellsPerScale.values())e.destroy();this._cellsPerScale.clear();for(const e of this._sendStates.values())e.done=!1}displayMap(e,t,i){const s=new Map(e.map(e=>[t(e),e])),r=[],a=this._getClusterState(this._requiredLevel,this._requiredScale);for(const e of a.clusters()){const t=s.get(e.inner.id);if(null!=t){const a=i(e.displayId,t,e.inner.id);r.push(a),s.delete(e.inner.id);continue}if(1===e.inner.count){const{firstObjectId:t}=e.inner,a=t?s.get(t):null;if(null!=a){const n=i(e.displayId,a,t);r.push(n),s.delete(t)}}}return r}getDisplayFeatures(e){const i=new Set(e),s=new Set,r=[],a=[],n=this._getClusterState(this._requiredLevel,this._requiredScale);for(const e of n.aggregatesWorldSpace())if(i.has(e.displayId)&&!s.has(e.displayId)){const i=t.convertToFeature(e,this._metadata.geometryType,!1,!1);if(s.add(e.displayId),1===i.attributes.cluster_count){r.push({...i,displayId:e.displayId});continue}a.push({...i,displayId:e.displayId})}return{features:r,aggregates:a,tracks:[]}}getFeatureObjectIdsForAggregate(e){const t=this._getClusterState(this._requiredLevel,this._requiredScale);for(const i of t.clusters())if(i.inner.id===e)return Array.from(i.inner.containedObjectIds);return[]}async*updateChunks(){const e=this._source.chunks();if(!e.length)return;const t=this._getClusterState(this._requiredLevel,this._requiredScale),i=Array.from(this._sendStates.values()).filter(e=>e.subscription.tile.level===this._requiredLevel);if(t.updateChunks(e,i)||!this._source.updateTracking.updating)for(const e of i)e.subscription.tile.level===this._requiredLevel&&(e.didSend=!1,e.done=!1);const s=Array.from(this._sendStates.values()).filter(e=>e.done).map(e=>e.subscription.tile.key),r=new Set(s);for(const e of this._sendStates.values()){if(this._source.updateTracking.updating){if(s.some(t=>t.containsChild(e.subscription.tile.key)))continue;if(e.subscription.tile.key.getChildKeys().every(e=>r.has(e)))continue}e.didSend||e.subscription.tile.level!==this._requiredLevel||(e.didSend=!0,yield*this._update(e,t,this._source))}await t.updateStatistics(this._connection)}forEachAggregateWorldSpace(e){if(null==this._requiredLevel||null==this._requiredScale)return;const t=this._getClusterState(this._requiredLevel,this._requiredScale);for(const i of t.aggregatesWorldSpace())e(i)}_getClusterState(e,t){if(null==e||null==t)throw new Error("InternalError: Level and scale must be defined");let i=this._cellsPerScale.get(t);return i||(i=new m(e,t,this._indexOptions,this._clusterRadius,this._attributeStore),this._cellsPerScale.set(t,i)),i}async*_update(e,t,i){if(e.done)return;const s=t.createAggregateFeatures(e,this._metadata);this.events.emit("changed"),e.done=!i.updateTracking.updating;const r=s.getCursor(),a=e.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.arcadeContextInfo);for(;r.next();)this._attributeStore.setAttributeData(r.getDisplayId(),r,a,this._sqlOptions);const n=new h.FeatureTileAppendMessage(e.subscription,s,!0,e.done,{});yield n}}e.ClusterState=S,e.ClusterStrategy=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});