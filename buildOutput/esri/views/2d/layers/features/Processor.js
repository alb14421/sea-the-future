// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../core/has","../../../../core/maybe","../../../../core/object","../../../../core/promiseUtils","../../../../core/accessorSupport/diffUtils","../../../../core/workers/utils","../../../../geometry/SpatialReference","../../engine/webgl/mesh/MultiTileMeshData","../../engine/webgl/mesh/factories/FeatureMeshFactory","../../engine/webgl/mesh/factories/ResourceProxy","../../engine/webgl/shaderGraph/techniques/mesh/MeshWriterRegistry","../../engine/webgl/util/MatcherContext","./ProcessorTileMessageQueue","./processor/BinningStrategy","./processor/ClusterStrategy","./processor/FeatureUpdateStrategy","./processor/TrackStrategy","./support/AttributeStore","./support/ComputedAttributeStorage"],function(e,t,s,r,i,a,o,n,c,h,u,g,y,d,p,l,_,f,b){"use strict";function m(e){const{timeZone:t}=e?.mesh.properties??{},{timeExtent:s}=e?.expressionProperties??{};return{timeZone:t,timeExtent:s}}return class{constructor(e,t){this._connection=e,this._source=t,this._version=1,this._registry=new u.MeshWriterRegistry,this._proxy=new h.ResourceProxy({fetch:(e,t)=>this._connection.layerView.fetch(e,t),fetchDictionary:(e,t)=>this._connection.layerView.fetchDictionary(e,t)}),this._attributeStore=new f.AttributeStore({isLocal:!1,update:e=>a.ignoreConnectionErrors(this._connection.container.updateAttributeView(e))})}destroy(){this._proxy.destroy(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}get version(){return this._version}getDisplayFeatures(e){return this._strategy?this._strategy.getDisplayFeatures(e):{features:[],aggregates:[],tracks:[]}}getDisplayIds(e){const t={};return this._strategy?(this._strategy.displayMap(e,e=>e,(e,s,r)=>{t[r]=e}),t):t}getFeatureObjectIdsForAggregate(e){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(e):[]}onSubscribe(e){this._strategy?.onSubscribe(e)}onUnsubscribe(e){this._strategy?.onUnsubscribe(e)}requiresInvalidation(){return this._strategy?.requiresInvalidation()??!1}async update(t,r,a,n,h){const u=t.processor,y=s.notDeepEqual(this._schema?.storage,u.storage),d=s.notDeepEqual(this._schema?.mesh.properties,u.mesh.properties),p=s.notDeepEqual(this._schema?.mesh.factory,u.mesh.factory),l=s.notDeepEqual(this._schema?.mesh.strategy,u.mesh.strategy),_=function(e,t){const s=[];return e?.timeExtent?.start===t.timeExtent?.start&&e?.timeExtent?.end===t.timeExtent?.end||s.push("timeProperties"),s}(this._schema?.expressionProperties,u.expressionProperties),f=_.some(e=>this._attributeStore.hasArcadeDependency(e)),w=_.some(e=>this._factory?.hasArcadeDependency(e)??!1),S=_.some(e=>this._strategy?.hasArcadeDependency(e))||this._strategy?.isAggregate&&f,I=w||S,M=d||p||l;if(!(y||M||w||f||S||n))return!1;e("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:i.diff(this._schema,u),schema:u}),this._schema=u;const x=o.fromJSON(this._source.service.outSpatialReference),v=new b.ComputedAttributeStorage({fields:this._source.metadata.fieldsIndex,spatialReference:x}),A={currentUser:u.mesh.properties.currentUser};if((y||M||f)&&(await this._attributeStore.update(u.storage,v,this._source.metadata,r),this._strategy?.invalidateAttributeData(m(u))),!n&&!M&&!I)return!1;(l||d||I)&&await this._updateStrategy(u.mesh.strategy,x,h,m(u),A),this._updateSortKey(v,"sortKey"in u.mesh.properties?u.mesh.properties.sortKey:null);const k="dictionary"===u.mesh.factory.symbology.type?u.mesh.factory.symbology.fieldMap:null,D=new g.MatcherContext(v,this._proxy,a,this._registry,k);return(p||"dictionary"===u.mesh.factory.symbology.type)&&(this._factory=await c.FeatureMeshFactory.create(D,u.mesh.factory)),this._version=r,!0}async applyOverrideUpdate(e){if(!this._strategy)return;const t=this._strategy.applyOverrideUpdate(e);for await(const e of t)try{await this._process(e)}catch(e){}}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(e){this._strategy?.removeChunks(e),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:e}){if(!this._strategy||!this._strategy.hasSubscribers)return void this._attributeStore.setHighlight(e.map(({objectId:e,highlightFlags:t})=>({objectId:e,highlightFlags:t,displayId:-1})),e);const t=this._strategy.displayMap(e,({objectId:e})=>e,(e,{highlightFlags:t},s)=>({objectId:s,displayId:e,highlightFlags:t}));this._attributeStore.setHighlight(t,e)}invalidate(){this._strategy&&this._strategy.invalidate()}async _doUpdateChunks(){if(!this._strategy)return;const t=this._strategy.updateChunks(),s=[],i=new Map;for await(const e of t){let t=i.get(e.id);null==t&&(t=new y.ProcessorTileMessageQueue({concurrency:16,process:e=>this._process(e)}),i.set(e.id,t));const a=t.push(e).catch(e=>r.throwIfNotAbortError(e));s.push(a)}try{await Promise.all(s)}catch(e){}e("esri-2d-update-debug")&&console.log("SendUpdates"),this._attributeStore.sendUpdates(),e("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(e,t,s,r,i){switch(this._strategy?.destroy(),e.type){case"feature":this._strategy=new l.FeatureUpdateStrategy(this._source,this._attributeStore,r,i);break;case"binning":this._strategy=await d.BinningStrategy.create(e,t,this._source,this._attributeStore,r,i);break;case"cluster":this._strategy=await p.ClusterStrategy.create(this._connection,e,t,this._source,this._attributeStore,r,i);break;case"track":this._strategy=await _.TrackStrategy.create(e,t,this._source,this._attributeStore,r,i)}for(const e of s)this._strategy.onSubscribe(e)}async _updateSortKey(e,s){if(this._sortInfo=t.destroyMaybe(this._sortInfo?.computed),null!=s){const t=s.byRenderer?null:await e.createComputedField(s);this._sortInfo={...s,computed:t}}}async _process(t){const s=t.subscription;if(e("esri-2d-update-debug")){const e=s.tile;console.debug(`Version[${this._version}] Tile[${e.key.id}, end=${t.end}] Processor._process`)}const i={currentUser:this._schema?.mesh.properties.currentUser};await this._fetchResources(t,i),r.throwIfAborted(s.signal);const a=await this._write(t,s.tile.createArcadeEvaluationOptions(m(this._schema)),i),o=s.tile.tileInfoView.getLODInfoAt(s.tile.key);r.throwIfAborted(s.signal);const{message:n,transferList:c}=a.serialize(o),h={objectIdMap:null,inner:t.createMessage(n,this._version,this._attributeStore.epoch)};if(this._schema?.mesh.properties.returnMeshObjectId){h.objectIdMap={};const e=t.reader?.getCursor();if(e)for(;e.next();)h.objectIdMap[e.getDisplayId()]=e.getObjectId()}if(r.throwIfAborted(s.signal),await this._connection.container.onMessage(h,{signal:s.signal,transferList:c}),this._attributeStore.sendUpdates(),e("esri-2d-update-debug")){const e=s.tile;console.debug(`Version[${this._version}] Tile[${e.key.id}, end=${t.end}] Processor._process.await`)}}async _fetchResources(e,t){await this._fetchMatcherResources(e),await this._fetchWriterResources(e,t)}async _fetchMatcherResources(e){if(e.reader)return this._factory.enqueueMatcherRequests(this._proxy,e.reader)}async _fetchWriterResources(e,t){if(!e.reader)return;const s=e.reader.getCursor(),r=e.subscription.tile.createArcadeEvaluationOptions(m(this._schema));for(;s.next();)this._factory.enqueueWriterRequests(this._proxy,s,r,t);await this._proxy.fetchEnqueuedResources()}async _write(e,t,s){const i=e.subscription.tile,a=e.reader?.getCursor(),o=a?.getSize()??0,c=i.tileInfoView.tileInfo.isWrappable,h=i.tileInfoView.tileInfo.spatialReference.isWGS84,u=new n.MultiTileMeshData(i.key,this._strategy.enablePixelBuffering,c,h,o);if(!a)return u;const g=i.createArcadeEvaluationOptions(m(this._schema));let y=0;for(;a.next();){++y%1e3||(await r.after(0),r.throwIfAborted(e.subscription));const o=this._getSortKeyValue(a,t);u.entityStart(a.getDisplayId(),o),this._factory.write(u,this._proxy,a,g,s,i.level),u.entityEnd()}return u}_getSortKeyValue(e,t){if(!this._sortInfo)return 0;const{computed:s,order:r,byRenderer:i}=this._sortInfo,a=i?this._factory.getSortKey(e,t):s?.read(e,t);return null==a||isNaN(a)?0:a*("asc"===r?-1:1)}}});