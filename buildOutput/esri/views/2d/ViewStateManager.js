// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../chunks/tslib.es6","../../Viewpoint","../../core/Accessor","../../core/Error","../../core/has","../../core/Logger","../../core/reactiveUtils","../../core/screenUtils","../../core/Warning","../../core/accessorSupport/decorators/property","../../core/RandomLCG","../../core/accessorSupport/decorators/subclass","../../geometry/Extent","../../chunks/pe","../../geometry/Point","../../geometry/projectionUtils","../../geometry/support/spatialReferenceUtils","./PaddedViewState","./viewpointUtils"],function(e,t,i,r,s,a,o,n,c,p,l,h,d,g,w,v,u,y,_,f){"use strict";e.ViewStateManager=class extends r{constructor(e){super(e),this.constraints=null,this.ready=!1,this.resizeAlign="center",this.addHandles([n.watch(()=>this.constraints?.version,e=>{this.constraints&&e&&this.ready&&(this.state.viewpoint=this.constraints.fit(this.state.paddedViewState.viewpoint))},n.sync)])}get center(){if(!this.ready)return this._get("center");const{center:e,spatialReference:t}=this.state.paddedViewState;return this.state.commitProperty("id"),new v({x:e[0],y:e[1],spatialReference:t})}set center(e){if(null==e)return;if(!this.ready)return void this._set("center",e);let t;try{t=this._project(e,this.state.spatialReference)}catch(t){return void o.getLogger(this).error(new s("mapview:invalid-center","could not project the value in the view's spatial reference",{input:e,error:t}))}const i=this.viewpoint;f.centerAt(i,i,t),this.viewpoint=i}get extent(){return this.ready?(this.state.commitProperty("id"),this.state.paddedViewState.extent.clone()):this._get("extent")}set extent(e){if(null==e)return;if(!e.width||!e.height)return void o.getLogger(this).error(new s("mapview:invalid-extent","invalid extent size"));if(!this.ready)return this._set("extent",e),this._set("center",void 0),this._set("viewpoint",void 0),this._set("scale",void 0),void this._set("zoom",void 0);let t;try{t=this._project(e,this.state.spatialReference)}catch(e){return void o.getLogger(this).error(new s("mapview:invalid-extent","could not project the value in the view's spatial reference",{error:e}))}const i=this.viewpoint;f.setExtent(i,i,t,this.state.size,{constraints:this.constraints}),this.viewpoint=i}get padding(){return this.ready?this.state.padding:this._get("padding")}set padding(e){this.ready?(this.state.padding=e,this._set("padding",this.state.padding)):this._set("padding",e)}get resolution(){return this.ready?(this.state.commitProperty("id"),this.state.resolution):0}get rotation(){return this.ready?(this.state.commitProperty("id"),this.state.rotation):this._get("rotation")}set rotation(e){if(isNaN(e))return;if(!this.ready)return void this._set("rotation",e);const t=this.viewpoint;f.rotateTo(t,t,e),this.viewpoint=t}get scale(){return this.ready?(this.state.commitProperty("id"),this.state.scale):this._get("scale")}set scale(e){if(!e||isNaN(e))return;if(!this.ready){this._set("scale",e),this._set("zoom",void 0);const t=this._get("extent");return void(t&&(this._set("extent",void 0),this._set("center",t.center)))}const t=this.viewpoint;f.scaleTo(t,t,e),this.viewpoint=t}get viewpoint(){return this.ready?this.state.paddedViewState.viewpoint.clone():this._get("viewpoint")}set viewpoint(e){if(null==e)return;if(!this.ready)return this._set("viewpoint",e),this._set("extent",void 0),this._set("center",void 0),this._set("zoom",void 0),void this._set("scale",void 0);let t,r;try{t=this._project(e,this.state.spatialReference),!e.scale||isNaN(e.scale)?r=new s("mapview:invalid-viewpoint",`invalid scale value of ${e.scale}`):null==e.targetGeometry&&(r=new s("mapview:invalid-viewpoint","geometry not defined"))}catch(e){r=new s("mapview:invalid-viewpoint","could not project the value in the view's spatial reference",{error:e})}if(r)return void o.getLogger(this).error(r);this._scaleBeforeChangingSpatialReference=null;const a=new i({targetGeometry:new v,scale:0,rotation:0});f.copy(a,t),this.constraints?.constrain(a,this.state.paddedViewState.viewpoint),this.state.viewpoint=a,this._set("viewpoint",a)}get visibleArea(){return this.ready?this.state.visibleArea:null}get zoom(){return this.ready?this.constraints?.scaleToZoom(this.scale)??-1:this._get("zoom")}set zoom(e){if(!(e>=0))return;if(!this.ready){this._set("zoom",e),this._set("scale",void 0);const t=this._get("extent");return void(t&&(this._set("extent",void 0),this._set("center",t.center)))}const t=this.constraints?.zoomToScale(e)??0;if(!t)return void this._set("zoom",-1);const i=this.viewpoint;f.scaleTo(i,i,t),this.viewpoint=i,this._set("zoom",this.constraints?.scaleToZoom(this.scale)??-1)}getUserStartupOptions(e){if(!e[0]&&!e[1])return{center:void 0,rotation:void 0,scale:void 0};const{padding:t,constraints:i}=this,r=this._get("center"),s=this._get("extent"),a=this._get("scale"),o=this._get("rotation"),n=this._get("viewpoint"),c=this._get("zoom"),p=null!=c&&null!=i&&i.zoomToScale(c)||void 0;let l,h,d;const g=n?.rotation,w=n?.targetGeometry;"extent"===w?.type?l=w:"point"===w?.type&&(h=w,d=n?.scale);const v=s??l;return{center:r??h??v?.center,rotation:o??g,scale:(a??p??d??(v&&f.extentToScale(v,[e[0]-t.left-t.right,e[1]-t.top-t.bottom])))||void 0}}startup(e,t,i,r){const s=e.targetGeometry;try{this._project(e,i)}catch(t){o.getLogger(this).warn(new p("mapview:startup-projection-error","projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.",{center:s.toJSON(),spatialReference:i,error:t})),e.targetGeometry=r||new v({x:0,y:0,spatialReference:i})}this.constraints?.fit(e),this._set("state",new _({padding:this.padding,size:t,viewpoint:e})),this._set("ready",!0)}teardown(){this._set("ready",!1);const{center:[e,t],spatialReference:i,rotation:r,scale:s}=this.state.paddedViewState,a=new v({x:e,y:t,spatialReference:i});this._set("viewpoint",null),this._set("extent",null),this._set("center",a),this._set("zoom",-1),this._set("rotation",r),this._set("scale",s),this._set("state",null)}changeSpatialReference(e){const t=this.state.paddedViewState.clone();if(null==this._scaleBeforeChangingSpatialReference)this._scaleBeforeChangingSpatialReference=t.scale;else{const e=t.viewpoint.clone();e.scale=this._scaleBeforeChangingSpatialReference,t.viewpoint=e}const r=t.clone(),[s,n]=t.center;let c=null;try{c=this._project(new v({x:s,y:n,spatialReference:t.spatialReference}),e)}catch(t){w.isLoaded()||o.getLogger(this).warn(new p("mapview:spatial-reference-change","could not project the view's center to the new spatial reference",{center:c?.toJSON(),spatialReference:e,error:t}))}c||(c=new v({x:0,y:0,spatialReference:e}));const l=f.centerAt(new i({targetGeometry:new v,scale:0,rotation:0}),t.viewpoint,c);r.viewpoint=l;try{const i=20,s=[t.size[0]/2,t.size[1]/2],o=[s[0]+i,s[1]],n=t.toMap([0,0],o),{x:c,y:p}=this._project(new v({x:n[0],y:n[1],spatialReference:t.spatialReference}),e);n[0]=c,n[1]=p,r.toScreen(n,n);const h=f.angleBetween(s,n,o),d=Math.hypot(n[0]-s[0],n[1]-s[1])/i;!Number.isFinite(d)||Math.abs(d)>4?(l.rotation=0,l.targetGeometry=new v({x:0,y:0,spatialReference:e})):(l.scale*=d,l.scale>a("mapview-srswitch-adjust-rotation-scale-threshold")?l.rotation=0:l.rotation+=Number.isFinite(h)?h:0)}catch{}this._get("constraints")?.constrain(l,void 0),this._get("state").viewpoint=l}resize(e,t){if(!this.ready)return;const i=this.state;let r=this.state.paddedViewState.viewpoint;const s=this.state.paddedViewState.size.slice();i.size=[e,t],f.resize(r,r,s,this.state.paddedViewState.size,this.resizeAlign),r=this.constraints?.constrain(r,void 0)??r,this.state.viewpoint=r}toMap(e){if(!this.ready)return null;const[t,i]=this.state.toMap([0,0],[e.x,e.y]),r=this.state.spatialReference;return new v({x:t,y:i,spatialReference:r})}toScreen(e,t){if(!this.ready)return null;const i=this._project(e,this.state.spatialReference),r=[i.x,i.y];return!1===t?.pickClosestTarget||this.state.paddedViewState.wrapMapCoordinate(r,r),this.state.toScreen(r,r),c.createScreenPoint(r[0],r[1])}_project(e,t){const i=e?.targetGeometry||e;if(!t)return e;if(!i)return null;if(t.imageCoordinateSystem||i.spatialReference?.imageCoordinateSystem)return e;if(y.equals(t,i.spatialReference))return e;const r=u.project(i,t);if(!r)throw new s("mapview:projection-not-possible","projecting input geometry to target spatial reference returned a null value",{geometry:i,spatialReference:t});return function(e){return"esri.Viewpoint"===e?.declaredClass}(e)?(e.targetGeometry=r,e):r}},t.__decorate([l.property({type:v})],e.ViewStateManager.prototype,"center",null),t.__decorate([l.property()],e.ViewStateManager.prototype,"constraints",void 0),t.__decorate([l.property({type:g})],e.ViewStateManager.prototype,"extent",null),t.__decorate([l.property({value:{top:0,right:0,bottom:0,left:0},cast:e=>({top:0,right:0,bottom:0,left:0,...e})})],e.ViewStateManager.prototype,"padding",null),t.__decorate([l.property()],e.ViewStateManager.prototype,"ready",void 0),t.__decorate([l.property()],e.ViewStateManager.prototype,"resizeAlign",void 0),t.__decorate([l.property({readOnly:!0})],e.ViewStateManager.prototype,"resolution",null),t.__decorate([l.property({type:Number})],e.ViewStateManager.prototype,"rotation",null),t.__decorate([l.property({type:Number})],e.ViewStateManager.prototype,"scale",null),t.__decorate([l.property({readOnly:!0})],e.ViewStateManager.prototype,"state",void 0),t.__decorate([l.property({type:i})],e.ViewStateManager.prototype,"viewpoint",null),t.__decorate([l.property({readOnly:!0})],e.ViewStateManager.prototype,"visibleArea",null),t.__decorate([l.property()],e.ViewStateManager.prototype,"zoom",null),e.ViewStateManager=t.__decorate([d.subclass("esri.views.2d.ViewStateManager")],e.ViewStateManager),Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});