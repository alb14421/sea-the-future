// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/lang","../../../core/unitUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/Circle","../../../geometry/Multipoint","../../../geometry/Point","../../../geometry/Polygon","../../../geometry/Polyline","../../../chunks/distanceOperator","../../../chunks/simplifyOperator","../../../geometry/support/coordsUtils","../../../geometry/support/spatialReferenceUtils","./surfaceCoordinateSystems"],function(e,t,a,n,o,r,l,i,c,s,u,y,f,m,p,x){"use strict";function h(e,t){const a=new c({x:e[0],y:e[1],spatialReference:t});return e.length>2&&(a.z=e[2]),a}function M(e,n,o,r=!0){const l=a.clone(e);l.forEach(e=>{const a=e[0],n=e[e.length-1];t.equals(a,n)&&1!==e.length||e.push(e[0])});let i=new s({rings:l,spatialReference:n});return i.rings.forEach(e=>{m.isClockwise(e)||e.reverse()}),o&&m.unnormalizeGeometryOnDatelineCrossing(i),r&&!f.isSimple(i)&&p.isValid(n)&&(i=f.execute(i)||i),i}function P(e,t,a){const n=S(t[3],t[2],a),o=S(t[1],t[2],a),r=S(t[0],t[1],a),l=S(t[0],t[3],a);return{geometry:e,midpoints:null!=n&&null!=o&&null!=r&&null!=l?{top:n,right:o,bottom:r,left:l}:null}}function S(e,t,a){k[0]=e.x,k[1]=e.y,k[2]=0,d[0]=t.x,d[1]=t.y,d[2]=0,o.lerp(k,k,d,.5),g.x=k[0],g.y=d[1],g.z=d[2];const n=a.localToMap(g);return null!=n?h(n,a.spatialReference):null}const g=x.makeSurfacePoint(0,0,0),k=r.create(),d=r.create();e.createCircle=function(e,t,a,o){const r=t.mapToLocalMultiple(e);let i=null,c=null;if(a)i=r[0],c=r[1];else{const e=r[0],t=r[1],a=Math.round(t.x-e.x),n=Math.round(t.y-e.y),o=Math.max(Math.abs(a),Math.abs(n));i=x.makeSurfacePoint(a>0?e.x+o/2:e.x-o/2,n>0?e.y+o/2:e.y-o/2),c=x.makeSurfacePoint(Math.abs(a)>Math.abs(n)?i.x-o/2:i.x,Math.abs(a)>Math.abs(n)?i.y:i.y-o/2)}const s=t.localToMap(i),u=t.localToMap(c);if(null==s||null==u)return null;t.doUnnormalization&&m.unnormalizeVerticesOnDatelineCrossing([[s,u]],t.spatialReference);const f=h(s,t.spatialReference),P=h(u,t.spatialReference),S=n.getMetersPerUnitForSR(t.spatialReference);let g=0;if(p.isValid(t.spatialReference))g=S*y.execute(f,P);else{const e=i.x-c.x,t=i.y-c.y;g=S*Math.sqrt(e*e+t*t)*(o||1)}const k=new l({center:f,radius:g,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:M(k.rings,k.spatialReference,!1),center:f,edge:P}},e.createEllipse=function(e,a,n){const o=a.mapToLocalMultiple(e),r=o[0],l=o[1],i=Math.round(l.x-r.x),c=Math.round(l.y-r.y),s=x.makeSurfacePoint(n?r.x:r.x+i/2,n?r.y:r.y+c/2),u=n?i:i/2,y=n?c:c/2,f=[],m=2*Math.PI/60;function p(e){const t=Math.cos(e),a=Math.sin(e);return x.makeSurfacePoint(u*t+s.x,y*a+s.y)}for(let e=0;e<60;e++)f.push(p(e*m));f.push(f[0]);const{spatialReference:P,doUnnormalization:S}=a,g=M([f.map(e=>a.localToMap(e)).filter(t.isSome)],P,S,!1),k=a.localToMap(p(Math.PI/2)),d=a.localToMap(p(0)),R=a.localToMap(p(-Math.PI/2)),T=a.localToMap(p(Math.PI));return{geometry:g,midpoints:null!=k&&null!=d&&null!=R&&null!=T?{top:h(k,P),right:h(d,P),bottom:h(R,P),left:h(T,P)}:null}},e.createMultipoint=function(e,t){return new i({points:e,spatialReference:t})},e.createPoint=h,e.createPolygon=M,e.createPolyline=function(e,t,a){const n=new u({paths:e,spatialReference:t});return a&&m.unnormalizeGeometryOnDatelineCrossing(n),n},e.createRectangle=function(e,a,n){let o=a.mapToLocalMultiple(e);if(1===o.length){const e=48,t=o[0];o=[x.makeSurfacePoint(t.x-e,t.y+e),x.makeSurfacePoint(t.x+e,t.y-e),x.makeSurfacePoint(t.x+e,t.y-e),x.makeSurfacePoint(t.x-e,t.y+e)]}const r=[],l={x:o[0].x,y:o[0].y},i={x:o[1].x,y:o[1].y};if(n){const e=Math.round(i.x-l.x),t=Math.round(i.y-l.y);r.push(x.makeSurfacePoint(l.x-e,l.y-t),x.makeSurfacePoint(i.x,l.y-t),x.makeSurfacePoint(i.x,i.y),x.makeSurfacePoint(l.x-e,i.y))}else r.push(x.makeSurfacePoint(l.x,l.y),x.makeSurfacePoint(i.x,l.y),x.makeSurfacePoint(i.x,i.y),x.makeSurfacePoint(l.x,i.y));return P(M([r.map(e=>a.localToMap(e)).filter(t.isSome)],a.spatialReference,a.doUnnormalization,!0),r,a)},e.createSquare=function(e,a,n){const o=a.mapToLocalMultiple(e),r=[],l={x:o[0].x,y:o[0].y},i=o[1].x,c=o[1].y,s=Math.round(i-l.x),u=Math.round(c-l.y),y=Math.max(Math.abs(s),Math.abs(u));if(n){const e={x:l.x+y,y:l.y+y},t={x:l.x-y,y:l.y-y};r.push(x.makeSurfacePoint(e.x,t.y),x.makeSurfacePoint(t.x,t.y),x.makeSurfacePoint(t.x,e.y),x.makeSurfacePoint(e.x,e.y))}else{const e={x:s>0?l.x+y:l.x-y,y:u>0?l.y+y:l.y-y};r.push(x.makeSurfacePoint(l.x,l.y),x.makeSurfacePoint(e.x,l.y),x.makeSurfacePoint(e.x,e.y),x.makeSurfacePoint(l.x,e.y))}return P(M([r.map(e=>a.localToMap(e)).filter(t.isSome)],a.spatialReference,a.doUnnormalization,!0),r,a)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});