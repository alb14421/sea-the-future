// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../chunks/sphere","./Octree"],function(e,n,t,r){"use strict";function s(e,n,t,r){for(let r=0;r<3;r++)if(e[r]<n[r]||e[r]>t[r])throw new Error("[Octree Validation] Object is not within node bounds");const s=.25*(t[0]-n[0]);if(r&&e[3]<s)throw new Error("[Octree Validation] Object is too small to be a terminal");if(!r&&e[3]>s)throw new Error("[Octree Validation] Object is too large to be a resident")}function i(e,n,t){return t[0]=e[0]+n,t[1]=e[1]+n,t[2]=e[2]+n,t}e.assert=function(e,r){return e.forEachNode((m,a,o)=>{const l=i(t.getCenter(a),-o,n.create()),d=i(t.getCenter(a),o,n.create());if(m.terminals.forAll(e=>s(r(e),l,d,!0)),null!==m.residents){if(m.residents.length>e.maximumObjectsPerNode)throw new Error("[Octree Validation] Number of objects "+m.residents.length+" exceeds maximum allowed ("+e.maximumObjectsPerNode+")");m.residents.forAll(e=>s(r(e),l,d,!1))}let u=!1;if(m.children.forEach(e=>{if(e&&(u=!0,null!==m.residents))throw new Error("[Octree Validation] Node has residents and children")}),!u&&(null===m.residents||0===m.residents.length)&&0===m.terminals.length)throw new Error("[Octree Validation] dangling empty node");return!0}),!0},e.debugDump=function e(s,i=!1){const m=s instanceof r.Octree?s.root:s,a={};return s instanceof r.Octree&&i&&(a.center=n.clone(t.getCenter(s.bounds)),a.size=2*s.halfSize),m.terminals.length>0&&(a.terminals=m.terminals.map(e=>e.id)),null!==m.residents&&m.residents.length>0&&(a.residents=m.residents.map(e=>e.id)),null===m.residents&&m.children.forEach((n,t)=>{n&&(a["child"+t]=e(n))}),a},e.stats=function(e){const n={numNodes:0,numObjects:0,numTerminals:0,numResidents:0,numOutsiders:0,numInnerNodes:0,numTerminalNodes:0,maximumDepth:0,maxNumTerminals:0,maxNumResidents:0,maxNumObjects:0};return e.forEachNode((t,r,s)=>{null===t.residents?n.numInnerNodes++:n.numTerminalNodes++,n.numTerminals+=t.terminals.length,n.maxNumTerminals=Math.max(t.terminals.length,n.maxNumTerminals);let i=t.terminals.length;null!==t.residents&&(n.numResidents+=t.residents.length,n.maxNumResidents=Math.max(t.residents.length,n.maxNumResidents),i+=t.residents.length),n.maxNumObjects=Math.max(i,n.maxNumObjects);const m=Math.round(Math.log(2*e.halfSize/s)*Math.LOG2E);return n.maximumDepth=Math.max(n.maximumDepth,m),!0}),n.numObjects=n.numOutsiders+n.numTerminals+n.numResidents,n.numNodes=n.numInnerNodes+n.numTerminalNodes,n},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});