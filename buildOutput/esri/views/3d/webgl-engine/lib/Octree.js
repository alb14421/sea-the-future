// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/ObjectPool","../../../../core/PooledArray","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/support/frustum","../../../../geometry/support/ray","../../../../chunks/sphere","./Util"],function(e,t,n,o,r,i,s,a,h){"use strict";class l{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(e,t){this.objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new u,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth))}destroy(){this._degenerateObjects.clear(),u.clearPool(),C[0]=null,A.prune(),E.prune()}add(e){const t=Array.from(e);this._grow(t);const n=u.acquire();for(const e of t)++this._objectCount,this._isDegenerate(e)?this._degenerateObjects.add(e):(n.init(this._root),this._add(e,n));u.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=u.acquire();for(const o of e){const e=t??a.copy(this.objectToBoundingSphere(o),R);O(e[3])?(n.init(this._root),f(o,e,n)):this._degenerateObjects.delete(o)}u.release(n),this._shrink()}update(e,t){if(!O(t[3])&&this._isDegenerate(e))return;const n=function(e){return C[0]=e,C}(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const o=s.wrap(e,t);d(this._root,e=>{if(!function(e,t){return g(a.getCenter(t.bounds),2*-t.halfSize,D),g(a.getCenter(t.bounds),2*t.halfSize,B),h.rayBoxTest(e.origin,e.direction,D,B)}(o,e))return!1;const t=e.node;return t.terminals.forAll(e=>{this._intersectsObject(o,e)&&n(e)}),null!==t.residents&&t.residents.forAll(e=>{this._intersectsObject(o,e)&&n(e)}),!0})}forEachAlongRayWithVerticalOffset(e,t,n,o){const r=s.wrap(e,t);d(this._root,e=>{if(!function(e,t,n){return g(a.getCenter(t.bounds),2*-t.halfSize,D),g(a.getCenter(t.bounds),2*t.halfSize,B),n.applyToMinMax(D,B),h.rayBoxTest(e.origin,e.direction,D,B)}(r,e,o))return!1;const t=e.node;return t.terminals.forAll(e=>{this._intersectsObjectWithOffset(r,e,o)&&n(e)}),null!==t.residents&&t.residents.forAll(e=>{this._intersectsObjectWithOffset(r,e,o)&&n(e)}),!0})}forEach(e){d(this._root,t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0}),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,n,r=()=>!0,s=1/0){let h=1/0,l=1/0,u=null;const d=x(e,t),f=o=>{if(--s,!r(o))return;const d=this.objectToBoundingSphere(o);if(!i.intersectsSphere(n,d))return;const c=j(e,t,a.getCenter(d)),f=c-d[3],m=c+d[3];f<h&&(h=f,l=m,u=o)};return c(this._root,r=>{if(s<=0||!i.intersectsSphere(n,r.bounds))return!1;if(o.scale(y,d,r.halfSize),o.add(y,y,a.getCenter(r.bounds)),j(e,t,y)>l)return!1;const h=r.node;return h.terminals.forAll(e=>f(e)),null!==h.residents&&h.residents.forAll(e=>f(e)),!0},e,t),u}forEachInDepthRange(e,t,n,r,s,h,l){let u=-1/0,d=1/0;const f={setRange:e=>{1===n?(u=Math.max(u,e.near),d=Math.min(d,e.far)):(u=Math.max(u,-e.far),d=Math.min(d,-e.near))}};f.setRange(r);const m=j(t,n,e),_=x(t,n),p=x(t,-n),b=e=>{if(!l(e))return;const o=this.objectToBoundingSphere(e),r=a.getCenter(o),c=j(t,n,r)-m,_=c-o[3],p=c+o[3];_>d||p<u||!i.intersectsSphere(h,o)||s(e,f)};c(this._root,e=>{if(!i.intersectsSphere(h,e.bounds))return!1;if(o.scale(y,_,e.halfSize),o.add(y,y,a.getCenter(e.bounds)),j(t,n,y)-m>d)return!1;if(o.scale(y,p,e.halfSize),o.add(y,y,a.getCenter(e.bounds)),j(t,n,y)-m<u)return!1;const r=e.node;return r.terminals.forAll(e=>b(e)),null!==r.residents&&r.residents.forAll(e=>b(e)),!0},t,n)}forEachNode(e){d(this._root,t=>e(t.node,t.bounds,t.halfSize,t.depth))}forEachNeighbor(e,t){const n=a.getRadius(t),r=a.getCenter(t),i=t=>{const i=this.objectToBoundingSphere(t),s=a.getRadius(i),h=n+s;return!(o.squaredDistance(a.getCenter(i),r)-h*h<=0)||e(t)};let s=!0;const h=e=>{s&&(s=i(e))};d(this._root,e=>{const t=a.getRadius(e.bounds),i=n+t;if(o.squaredDistance(a.getCenter(e.bounds),r)-i*i>0)return!1;const l=e.node;return l.terminals.forAll(h),s&&null!==l.residents&&l.residents.forAll(h),s}),s&&this.forEachDegenerateObject(h)}_intersectsObject(e,t){const n=this.objectToBoundingSphere(t);return!(n[3]>0)||a.intersectsRay(n,e)}_intersectsObjectWithOffset(e,t,n){const o=this.objectToBoundingSphere(t);return!(o[3]>0)||a.intersectsRay(n.applyToBoundingSphere(o),e)}_add(e,t){t.advanceTo(this.objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const o=u.acquire().init(e);this._add(t.at(n),o),u.release(o)}}_grow(e){if(S(e,e=>this.objectToBoundingSphere(e),V),O(V[3])&&!this._fitsInsideTree(V))if(_(this._root.node))a.copy(V,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize();else{const e=this._rootBoundsForRootAsSubNode(V);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(V,e):this._growRootAsSubNode(e),u.release(e)}}_rebuildTree(e,t){o.copy(a.getCenter(v),a.getCenter(t.bounds)),v[3]=t.halfSize,S([e,v],e=>e,P);const n=u.acquire().init(this._root);this._root.initFrom(null,P,P[3]),this._root.increaseHalfSize(1.25),d(n,e=>(this.add(e.node.terminals.data),null!==e.node.residents&&this.add(e.node.residents.data),!0)),u.release(n)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return d(this._root,e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth)),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let o=-1/0;const r=this._root.bounds,i=this._root.halfSize;for(let e=0;e<3;e++){const s=r[e]-i-(n[e]-t),a=n[e]+t-(r[e]+i),h=Math.max(0,Math.ceil(s/(2*i))),l=Math.max(0,Math.ceil(a/(2*i)))+1,u=2**Math.ceil(Math.log(h+l)*Math.LOG2E);o=Math.max(o,u),w[e].min=h,w[e].max=l}for(let e=0;e<3;e++){let t=w[e].min,n=w[e].max;const s=(o-(t+n))/2;t+=Math.ceil(s),n+=Math.floor(s);const a=r[e]-i-t*i*2;N[e]=a+(n+t)*i}const s=o*i;return N[3]=s*T,u.acquire().initFrom(null,N,s,0)}_growRootAsSubNode(e){const t=this._root.node;o.copy(a.getCenter(V),a.getCenter(this._root.bounds)),V[3]=this._root.halfSize,this._root.init(e),e.advanceTo(V,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,o=0;for(;o<t.length&&null==e;)n=o++,e=t[n];for(;o<t.length;)if(t[o++])return-1;return n}_isDegenerate(e){return!O(this.objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}toJSON(){const{maximumDepth:e,maximumObjectsPerNode:t,_objectCount:n}=this,o=this._nodeToJSON(this._root.node);return{maximumDepth:e,maximumObjectsPerNode:t,objectCount:n,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:o}}}_nodeToJSON(e){const t=e.children.map(e=>e?this._nodeToJSON(e):null),n=e.residents?.map(e=>this.objectToBoundingSphere(e)),o=e.terminals?.map(e=>this.objectToBoundingSphere(e));return{children:t,residents:n,terminals:o}}static fromJSON(e){const t=new l(e=>e,{maximumDepth:e.maximumDepth,maximumObjectsPerNode:e.maximumObjectsPerNode});return t._objectCount=e.objectCount,t._root.initFrom(e.root.node,e.root.bounds,e.root.halfSize,e.root.depth),t}}class u{constructor(){this.bounds=a.create(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,o=this.depth){return this.node=null!=e?e:u.createEmptyNode(),t&&a.copy(t,this.bounds),this.halfSize=n,this.depth=o,this}increaseHalfSize(e){this.halfSize*=e,this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=this.halfSize*T}advance(e){let t=this.node.children[e];t||(t=u.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=z[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.updateBoundsRadiusFromHalfSize(),this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const o=this._childIndex(e);t&&t(this,o),this.advance(o)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new n({shrink:!0}),residents:new n({shrink:!0})}}static{this._pool=new t(u)}static acquire(){return u._pool.acquire()}static release(e){u._pool.release(e)}static clearPool(){u._pool.prune()}}function d(e,t){let n=u.acquire().init(e);const o=[n];for(;0!==o.length;){if(n=o.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++)n.node.children[e]&&o.push(u.acquire().init(n).advance(e));u.release(n)}}function c(e,t,n,o=1){let r=u.acquire().init(e);const i=[r];for(function(e,t,n){if(!E.length)for(let e=0;e<8;++e)E.push({index:0,distance:0});for(let n=0;n<8;++n){const o=z[n];E.data[n].index=n,E.data[n].distance=j(e,t,o)}E.sort((e,t)=>e.distance-t.distance);for(let e=0;e<8;++e)n[e]=E.data[e].index}(n,o,q);0!==i.length;){if(r=i.pop(),t(r)&&!r.isLeaf())for(let e=7;e>=0;--e){const t=q[e];r.node.children[t]&&i.push(u.acquire().init(r).advance(t))}u.release(r)}}function f(e,t,n){A.clear();const o=n.advanceTo(t,(e,t)=>{A.push(e.node),A.push(t)})?n.node.terminals:n.node.residents;if(o.removeUnordered(e),0===o.length)for(let e=A.length-2;e>=0&&m(A.data[e],A.data[e+1]);e-=2);}function m(e,t){return t>=0&&(e.children[t]=null),!!_(e)&&(null===e.residents&&(e.residents=new n({shrink:!0})),!0)}function _(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}function p(e,t){e[0]=Math.min(e[0],t[0]-t[3]),e[1]=Math.min(e[1],t[1]-t[3]),e[2]=Math.min(e[2],t[2]-t[3])}function b(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3])}function g(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t}function S(e,t,n){D[0]=1/0,D[1]=1/0,D[2]=1/0,B[0]=-1/0,B[1]=-1/0,B[2]=-1/0;for(const n of e){const e=t(n);O(e[3])&&(p(D,e),b(B,e))}o.lerp(a.getCenter(n),D,B,.5),n[3]=Math.max(B[0]-D[0],B[1]-D[1],B[2]-D[2])/2}function x(e,t){let n,o=1/0;for(let r=0;r<8;++r){const i=j(e,t,M[r]);i<o&&(o=i,n=M[r])}return n}function j(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function O(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}const z=[r.fromValues(-1,-1,-1),r.fromValues(1,-1,-1),r.fromValues(-1,1,-1),r.fromValues(1,1,-1),r.fromValues(-1,-1,1),r.fromValues(1,-1,1),r.fromValues(-1,1,1),r.fromValues(1,1,1)],M=[r.fromValues(-1,-1,-1),r.fromValues(-1,-1,1),r.fromValues(-1,1,-1),r.fromValues(-1,1,1),r.fromValues(1,-1,-1),r.fromValues(1,-1,1),r.fromValues(1,1,-1),r.fromValues(1,1,1)],T=Math.sqrt(3),C=[null],N=a.create(),y=r.create(),D=r.create(),B=r.create(),A=new n,R=a.create(),V=a.create(),v=a.create(),P=a.create(),w=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],E=new n,q=[0,0,0,0,0,0,0,0];e.Octree=l,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});