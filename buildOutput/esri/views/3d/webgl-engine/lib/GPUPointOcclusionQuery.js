// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/tslib.es6","../../../../core/maybe","../../../../core/accessorSupport/decorators/property","../../../../core/has","../../../../core/Logger","../../../../core/RandomLCG","../../../../core/accessorSupport/decorators/subclass","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../webgl","../../webgl/RenderNode","./DefaultVertexBufferLayouts","../../../support/Scheduler","../../../support/Yield","../../../webgl/enums","../../../webgl/renderState","../../../webgl/Sync","../../../webgl/Texture","../../../webgl/TextureDescriptor"],function(e,t,i,r,o,s,n,h,u,a,c,p,d,_,l,f,g,y,m,x,P,v){"use strict";e.GPUPointOcclusionQuery=class extends _{constructor(e){super(e),this.category=d.RenderCategory.COMPOSITE,this.readyToRun=!1,this.done=!0,this._origin=p.create(),this._textureWidth=256,this._uploadBuffer=new Float32Array(3*this._textureWidth),this._counter=0,this._width=0,this._height=0,this._pipeline=m.makePipelineState({colorWrite:m.defaultColorWrite}),this._format=0}initialize(){this.view.resourceController.scheduler.registerTask(f.TaskPriority.GRAPHICS_CORE,this),this.produces="disabled",this.consumes.required=[this.category],this.formatOverride&&(this._format=this.formatOverride)}destroy(){this._program=i.disposeMaybe(this._program);const e=this.gl;this._sync=i.destroyMaybe(this._sync),this._pixelBuffer&&(e.deleteBuffer(this._pixelBuffer),this._pixelBuffer=null),this._texture=i.disposeMaybe(this._texture)}precompile(){this._ensureProgram(this.renderingContext)}render(e){const t=e.find(({name:e})=>e===this.category);if(this._sync)return t;this.produces="disabled";const i=this.renderingContext,r=this.gl,o=t.getTexture(r.DEPTH_STENCIL_ATTACHMENT);if(!o)return t;const s=this.view.stage.renderer.fboCache.acquire(this._width,this._height,"hud visibility",9);i.bindFramebuffer(s.fbo),i.setPipelineState(this._pipeline);const n=this._ensureProgram(i);return i.useProgram(n),i.bindTexture(o,0),n.setUniform1i("depthTex",0),i.bindTexture(this._texture,1),n.setUniform1i("positionTex",1),u.multiply(C,this.camera.viewMatrix,u.fromTranslation(C,this._origin)),n.setUniformMatrix4fv("view",C),n.setUniformMatrix4fv("proj",this.camera.projectionMatrix),n.setUniform1i("count",this._counter),i.screen.draw(),this._pixelBuffer||(this._pixelBuffer=r.createBuffer()),0===this._format&&(this._format=6403===r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)&&r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE)===y.DataType.FLOAT?6403:6408),r.bindBuffer(r.PIXEL_PACK_BUFFER,this._pixelBuffer),r.bufferData(r.PIXEL_PACK_BUFFER,this._width*this._height*(6403===this._format?4:16),r.STREAM_READ),r.readPixels(0,0,this._width,this._height,this._format,y.DataType.FLOAT,0),this._sync=new x.Sync(r),s.release(),setTimeout(()=>this.readyToRun=!0,0),t}runTask(){if(!this._sync)return void(this.readyToRun=!1);try{if(!this._sync.poll())return g.Yield}catch(e){return this.readyToRun=!1,void(this._sync=i.destroyMaybe(this._sync))}this.readyToRun=!1,this._sync=i.destroyMaybe(this._sync);const e=this.gl;e.bindBuffer(e.PIXEL_PACK_BUFFER,this._pixelBuffer),this._cpuBuffer=new Float32Array(this._width*this._height*(6403===this._format?1:4)),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,this._cpuBuffer),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),this.done=!0}init(e,t){const i=this._textureWidth;if(this._width=i,this._height=Math.ceil(e/i),this._counter=0,this._texture?.dispose(),0===this._height)return;const r=new v.TextureDescriptor(this._width,this._height);r.pixelFormat=6407,r.dataType=y.PixelType.FLOAT,r.samplingMode=9728,this._texture=new P.Texture(this.renderingContext,r),this.done=!1,c.set(this._origin,Math.fround(t[0]),Math.fround(t[1]),Math.fround(t[2]))}addPosition(e){const t=this._width;if(this._counter>=t*this._height)return-1;const i=this._counter%t;return c.sub(w,e,this._origin),this._uploadBuffer[3*i+0]=w[0],this._uploadBuffer[3*i+1]=w[1],this._uploadBuffer[3*i+2]=w[2],i===t-1&&this._flush(),this._counter++}start(){if(0===this._width||0===this._height)return;const e=this._width;this._counter%e>0&&this._flush(),this.produces=this.category,this.requestRender(1)}getOcclusion(e){return this._cpuBuffer?.[6403===this._format?e:4*e]??-1}_flush(){const e=this._width,t=Math.floor(this._counter/e);this._texture?.updateData(0,0,t,e,1,this._uploadBuffer)}_ensureProgram(e){return this._program??=e.programCache.acquire(T,b,l.Pos2Locations),this._program}},t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"category",void 0),t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"formatOverride",void 0),t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"readyToRun",void 0),t.__decorate([r.property()],e.GPUPointOcclusionQuery.prototype,"done",void 0),e.GPUPointOcclusionQuery=t.__decorate([h.subclass("esri.views.3d.webgl-engine.lib.GPUPointOcclusionQuery")],e.GPUPointOcclusionQuery);const T="#version 300 es\nprecision highp float;\nin vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}",b="#version 300 es\nprecision highp float;\nout highp vec4 fragColor;\n\nuniform highp mat4 proj;\nuniform highp mat4 view;\n\nuniform highp int count;\n\nuniform highp sampler2D depthTex;\nuniform highp sampler2D positionTex;\n\nfloat linearizeDepth(float depth) {\n  float depthNdc = depth * 2.0 - 1.0;\n  float c1 = proj[3][2];\n  float c2 = proj[2][2];\n  return -c1 / (depthNdc + c2 + 1e-7);\n}\n\nvoid main() {\n  int u = int(floor(gl_FragCoord.x));\n  int v = int(floor(gl_FragCoord.y));\n  if (u + v * textureSize(positionTex, 0).x >= count) {\n    fragColor = vec4(-1);\n    return;\n  }\n  vec4 posWorld = vec4(texelFetch(positionTex, ivec2(u, v), 0).rgb, 1.0);\n\n  vec4 posView = view * posWorld;\n  vec4 projected = proj * posView;\n\n  vec3 clipPos = projected.xyz / projected.w;\n\n  if (clipPos.x < -1.0 || clipPos.x > 1.0 || clipPos.y < -1.0 || clipPos.y > 1.0) {\n    fragColor = vec4(-1);\n    return;\n  }\n\n  vec3 uvDepth = 0.5 * clipPos + vec3(0.5);\n\n  float depth = texture(depthTex, uvDepth.xy).r;\n\n  if (uvDepth.z <= depth) {\n    fragColor = vec4(0);\n    return;\n  }\n\n  fragColor = vec4(linearizeDepth(depth) - linearizeDepth(uvDepth.z));\n}\n",w=p.create(),C=a.create();Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});