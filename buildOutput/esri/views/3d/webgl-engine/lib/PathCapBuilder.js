// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64"],function(e,t,s){"use strict";class i{rebuildConnectingProfileGeometry(e,t,s){for(let i=0;i<t.vertices.length;++i)s(e.frame,t.vertices[i],t.normals[i],0,0)}}const r=s.create(),n=s.create();e.NoCapBuilder=class extends i{constructor(){super(),this.numVertices=0,this.numIndices=0}rebuildCapGeometry(){}buildTopology(){}},e.PathCapBuilder=i,e.RoundCapBuilder=class extends i{constructor(e){super(),this.flip=!1,this.sign=0,this.breakNormals=!1,this.numSegments=3,this.profile=e.profile,this.flip=e.flip,this.sign=this.flip?1:-1,this.breakNormals=e.breakNormals,this.numSegments=e.subdivisions}get numVertices(){let e=this.profile.vertices.length*(this.numSegments-1)+this.profile.poles.length;return this.breakNormals&&(e+=this.profile.vertices.length),e}get numIndices(){let e=0;const t=this.profile;e+=2*t.numSegments*(this.numSegments-1);for(let s=0;s<t.numSegments;++s){const i=t.indices[2*s],r=t.indices[2*s+1];t.poleIndices[i]===t.poleIndices[r]?e+=1:e+=2}return 3*e}rebuildCapGeometry(e,s){const i=this.profile,o=e.frame,l=.5*this.sign,c=r,f=n;t.set(f,0,0);for(const e of i.poles)e.normal?s(o,e.position,e.normal,l,0):s(o,e.position,f,l,this.sign);if(this.breakNormals)for(let e=0;e<i.vertices.length;++e)s(o,i.vertices[e],i.normals[e],0,0);for(let e=0;e<this.numSegments-1;++e){const r=(1-(e+1)/this.numSegments)*Math.PI*.5,n=Math.sin(r),h=Math.cos(r);for(let e=0;e<i.vertices.length;++e){const r=i.poles[i.poleIndices[e]];t.subtract(c,i.vertices[e],r.position),t.scale(c,c,n),r.normal?(t.add(c,c,r.position),s(o,c,r.normal,l*h,0)):(t.normalize(f,c),t.scale(f,f,n),t.add(c,c,r.position),s(o,c,f,l*h,this.sign*h))}}}buildTopology(e,t){const s=this.profile,i=this.breakNormals?this.vertexBufferStart+s.poles.length:this.firstProfileVertexIndex,r=this.breakNormals?this.vertexBufferStart+s.poles.length+s.vertices.length:this.vertexBufferStart+s.poles.length;for(let e=0;e<s.numSegments;++e){const n=s.indices[2*e],o=s.indices[2*e+1],l=this.vertexBufferStart+s.poleIndices[n],c=this.vertexBufferStart+s.poleIndices[o];let f=i+n,h=i+o;for(let e=0;e<this.numSegments-1;++e){const i=r+e*s.vertices.length+n,l=r+e*s.vertices.length+o;this.flip?(t(i,h,f),t(h,i,l)):(t(f,h,i),t(l,i,h)),f=i,h=l}this.flip?(t(l,h,f),l!==c&&t(l,c,h)):(t(f,h,l),l!==c&&t(h,c,l))}}},e.TriangulationCapBuilder=class extends i{constructor(e,t=0,s=!1){super(),this.profile=e,this.profilePlaneOffset=t,this.flip=s}get numVertices(){return this.profile.vertices.length}get numIndices(){return 3*this.profile.numSegments}rebuildConnectingProfileGeometry(e,t,s){const i=this.profilePlaneOffset;for(let r=0;r<t.vertices.length;++r)s(e.frame,t.vertices[r],t.normals[r],i,0)}rebuildCapGeometry(e,s){const i=this.profile,r=this.flip?1:-1,o=this.profilePlaneOffset,l=n;t.set(l,0,0);for(let t=0;t<i.vertices.length;++t)s(e.frame,i.vertices[t],l,o,r)}buildTopology(e,t){const s=this.profile,i=this.vertexBufferStart+s.indices[0];for(let e=1;e<s.numSegments;++e){const r=s.indices[2*e],n=s.indices[2*e+1],o=this.vertexBufferStart+r,l=this.vertexBufferStart+n;this.flip?t(l,o,i):t(i,o,l)}}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});