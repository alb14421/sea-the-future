// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../chunks/tslib.es6","../../../../../core/Accessor","../../../../../core/arrayUtils","../../../../../core/mathUtils","../../../../../core/NestedMap","../../../../../core/PooledArray","../../../../../core/accessorSupport/decorators/property","../../../../../core/has","../../../../../core/Logger","../../../../../core/accessorSupport/decorators/subclass","../../../../../core/libs/gl-matrix-2/math/mat4","../../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../support/buffer/glUtil","../../lib/Util","./BufferRange","./Instance","./PerBufferData","./PerOriginData"],function(e,t,r,o,n,s,a,i,l,u,f,c,d,h,g,m,p,y,b){"use strict";e.MergedBuffer=class extends r{constructor(e){super(e),this._vaoCache=null,this._bufferWriter=null,this._useMetalWorkaround=!1,this._hasOccludees=!1}destroy(){this.uninitializeRenderContext()}initializeRenderContext(e){this._useMetalWorkaround=e.renderContext.rctx.isAssumedMetalDriver,this._bufferWriter=this.material.createBufferWriter(),this._vaoCache=e.renderContext.rctx.getVaoCache(h.glLayout(this._bufferWriter.layout))}uninitializeRenderContext(){this._useMetalWorkaround=!1,this._bufferWriter=null,this._vaoCache=null}get hasOccludees(){return this._hasOccludees}modify(e,t){this._applyUpdates(e,t),this._applyAddsAndRemoves(e),this._updateDrawCommands()}get canCompact(){for(const e of this.dataByOrigin.values())if(e.buffers.some(e=>e.holes.length>1))return!0;return!1}compact(e){if(!this.canCompact)return!1;let t=!1;for(const r of this.dataByOrigin.values()){const o=new Array;for(let t=0;t<r.buffers.length&&!e.done;){const n=r.buffers[t];n.holes.length<=1?++t:(n.instances.forEach(({geometry:e})=>o.push(e)),this._vaoCache.deleteVao(n.vao),r.buffers[t]=r.buffers[r.buffers.length-1],--r.buffers.length,e.madeProgress())}if(o.length>0){for(r.buffers.forEach(e=>this._applyAdds(e,o));o.length>0;)r.buffers.push(this._applyAndRebuild(new y.PerBufferData,o,null));t=!0}}return t}updateHighlights(e){this.highlightOrderMap=e,this.dataByOrigin.forEach(t=>t.buffers.forEach(t=>t.updateHighlights(e)))}_applyUpdates(e,t){const r=this._bufferWriter;if(null==r)return void e.clearUpdates();const n=r.layout.stride/4;for(const s of e.updates){if(t.done)return;const{renderGeometry:a,updateType:i}=s;o.removeUnordered(e.pending.updates,s),t.madeProgress();const l=this.dataByOrigin.get(a.localOrigin.id),u=l?.findBuffer(a.id);if(null==u)return;const f=u.instances.get(a.id);if(6&i){const e=R(r.elementCount(f.geometry.geometry.attributes)*n),t=r.layout.createView(e.buffer);this._writeGeometry(a,t,0),u.vao.buffer()?.setSubData(e,f.from*n,0,f.numElements*n)}25&i&&(u.drawCommandsDirty=!0)}}_computeDeltas(e,t){const r=new s.NestedMap;for(const t of e){const e=t.localOrigin;if(null==e)continue;let o=r.get(e.id,null);null==o&&(o=new _(e.vec3),r.set(e.id,null,o)),o.changes.push(t)}for(const e of t){const t=e.localOrigin;if(null==t)continue;const o=this.dataByOrigin.get(t.id),n=o?.findBuffer(e.id);if(null==n)continue;let s=r.get(t.id,n);null==s&&(s=new _(t.vec3),r.set(t.id,n,s)),s.changes.push(e)}return r}_applyAddsAndRemoves(e){const{_bufferWriter:t,dataByOrigin:r,_vaoCache:n}=this;if(null==t||null==n)return void e.clearAddsAndRemoves();const s=t.layout.stride/4,a=this._computeDeltas(e.adds,e.removes);a.forEach((e,i)=>{const l=e.get(null),u=l?.changes??[];a.delete(i,null);let f=r.get(i);if(e.forEach((e,l)=>{if(a.delete(i,l),null==l&&g.assert(!1,"No VAO for removed geometries"),l.instances.size===e.changes.length)return n.deleteVao(l.vao),o.removeUnordered(f.buffers,l),void(0===f.buffers.length&&0===u.length&&r.delete(i));const c=l.numElements,d=l.vao.getByteLength("geometry")/4,h=u.reduce((e,r)=>e+t.elementCount(r.geometry.attributes),0),m=e.changes.reduce((e,r)=>e+t.elementCount(r.geometry.attributes),0),p=Math.min((c+h-m)*s,D),y=p>d;p>A&&p<d/2?(e.changes.forEach(({id:e})=>l.deleteInstance(e)),l.instances.forEach(({geometry:e})=>u.push(e)),this._vaoCache.deleteVao(l.vao),o.removeUnordered(f.buffers,l)):y?this._applyAndRebuild(l,u,e):this._applyRemoves(l,e)}),u.length>0)for(null==f&&(f=new b.PerOriginData(l.origin),r.set(i,f)),f.buffers.forEach(e=>this._applyAdds(e,u));u.length>0;)f.buffers.push(this._applyAndRebuild(new y.PerBufferData,u,null))}),e.clearAddsAndRemoves()}_updateDrawCommands(){this._hasOccludees=!1,this.dataByOrigin.forEach(e=>{e.buffers.forEach(e=>{e.updateIfDrawCommandsDirty(this.highlightOrderMap,this._bufferWriter.layout.stride),this._hasOccludees||=e.hasOccludees})})}_applyAndRebuild(e,t,r){if(r)for(const t of r.changes)e.deleteInstance(t.id);const o=this._bufferWriter,n=o.layout.stride,s=n/4,a=Math.floor(D/s);let i=e.numElements;for(;t.length>0;){const r=t.pop(),n=o.elementCount(r.geometry.attributes);if(i+n>a&&i>0){t.push(r);break}i+=n;const s=new p.Instance(r,0,0,this.highlightOrderMap);g.assert(null==e.instances.get(r.id)),e.addInstance(r.id,s)}const l=i*s,u=R(l),f=o.layout.createView(u.buffer);let c=0;e.resetInstanceSummary(),e.instances.forEach((t,r)=>{this._writeGeometry(t.geometry,f,c);const n=c;c+=o.elementCount(t.geometry.geometry.attributes),e.updateInstance(r,n,c),e.updateDrawState(t)}),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(x(l)),e.vao.buffer()?.setSubData(u,0,0,c*s),e.holes.clear();const d=e.holes.pushNew();return d.from=c,d.to=Math.floor(e.vao.getByteLength("geometry")/n),e.updateDrawCommands(this.highlightOrderMap,n),e}_applyRemoves(e,t){if(0===t.changes.length||null==this._bufferWriter)return;let r=1/0,o=-1/0;for(const n of t.changes){const t=n.id,s=e.instances.get(t);if(!s)continue;e.deleteInstance(t),this._useMetalWorkaround&&(r=Math.min(r,s.from),o=Math.max(o,s.to));const a=O.back();if(a){if(a.to===s.from){a.to=s.to;continue}if(a.from===s.to){a.from=s.from;continue}}const i=O.pushNew();i.from=s.from,i.to=s.to}m.mergeAdjacentRanges(O);const n=this._bufferWriter.layout.stride/4,s=e.vao.buffer();if(this._useMetalWorkaround){const t=(o-r)*n,a=R(t),i=this._bufferWriter.layout.createView(a.buffer);a.fill(0,0,t),e.instances.forEach(e=>{if(!(e.from>=r&&e.to<=o))return;const t=e.from-r;this._writeGeometry(e.geometry,i,t)}),s?.setSubData(a,r*n,0,t)}else{const e=O.reduce((e,t)=>Math.max(e,t.numElements),0)*n,t=R(e);t.fill(0,0,e),O.forAll(e=>s?.setSubData(t,e.from*n,0,e.numElements*n))}e.holes.pushArray(O.data,O.length),O.forAll((e,t)=>O.data[t]=null),O.clear(),e.drawCommandsDirty=!0}_applyAdds(e,t){if(0===t.length||null==this._bufferWriter)return;if(!y.hasVao(e))return void this._applyAndRebuild(e,t,null);const r=this._bufferWriter,n=r.layout.stride/4,s=e.numElements,a=t.reduce((e,t)=>e+r.elementCount(t.geometry.attributes),0),i=Math.min((s+a)*n,D),l=4*i;if(e.vao.getByteLength("geometry")<x(D-A)&&l>e.vao.getByteLength("geometry"))return void this._applyAndRebuild(e,t,null);m.mergeAdjacentRanges(e.holes);const u=new Array;let f=1/0,c=-1/0;for(const o of t){const t=r.elementCount(o.geometry.attributes),n=v(e.holes,t);u.push(n),this._useMetalWorkaround&&null!=n&&(f=Math.min(n,f),c=Math.max(n+t,c))}const d=e.vao.buffer();let h=0,b=0,_=0;const w=this._useMetalWorkaround?R((c-f)*n):R(i),M=r.layout.createView(w.buffer);if(t.forEach((t,o)=>{const s=u[o];if(null==s)return;const a=r.elementCount(t.geometry.attributes);if(!this._useMetalWorkaround){if(_!==s){const e=_-b;e>0&&d?.setSubData(w,b*n,0,e*n),b=s,h=0}this._writeGeometry(t,M,h),h+=a,_=s+a}const i=new p.Instance(t,s,s+a,this.highlightOrderMap);g.assert(null==e.instances.get(t.id)),e.addInstance(t.id,i),e.drawCommandsDirty=!0}),this._useMetalWorkaround){const t=(c-f)*n;w.fill(0,0,t),e.instances.forEach(e=>{if(!(e.from>=f&&e.to<=c))return;const t=e.from-f;this._writeGeometry(e.geometry,M,t)}),b=f,_=c}const O=_-b;O>0&&d?.setSubData(w,b*n,0,O*n),o.filterInPlace(t,(e,t)=>null==u[t])}_writeGeometry(e,t,r){null!=this._bufferWriter&&(c.copy(w,e.transformation),w[12]-=e.localOrigin.vec3[0],w[13]-=e.localOrigin.vec3[1],w[14]-=e.localOrigin.vec3[2],c.invert(M,w),c.transpose(M,M),this._bufferWriter.write(w,M,e.geometry.attributes,e.geometry.olidColor,t,r))}static prune(){E=new Float32Array(A)}},t.__decorate([i.property({constructOnly:!0})],e.MergedBuffer.prototype,"dataByOrigin",void 0),t.__decorate([i.property({constructOnly:!0})],e.MergedBuffer.prototype,"material",void 0),t.__decorate([i.property()],e.MergedBuffer.prototype,"highlightOrderMap",void 0),e.MergedBuffer=t.__decorate([f.subclass("esri.views.3d.webgl-engine.materials.renderers.MergedBuffer")],e.MergedBuffer);class _{constructor(e){this.origin=e,this.changes=new Array}}function v(e,t){const r=e.find(e=>e.numElements>=t);if(null==r)return null;const o=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),o}const w=d.create(),M=d.create(),O=new a({allocator:e=>e||new m.BufferRange,deallocator:null}),A=65536,C=4*A,B=1024,W=16777216,D=W/4;let E=new Float32Array(A);function R(e){return E.length<e&&(E=new Float32Array(e)),E}function x(e){const t=4*e;return t<=B?B:t<C?n.nextHighestPowerOfTwo(t):Math.max(Math.min(Math.ceil(1.5*t/C)*C,W),t)}e.sizeForVao=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});