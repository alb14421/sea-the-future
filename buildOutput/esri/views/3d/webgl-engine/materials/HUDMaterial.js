// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/mathUtils","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f64","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../core/libs/gl-matrix-2/types/mat4","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/buffer/BufferView","../../layers/support/FastSymbolUpdates","../../support/debugFlags","../core/shaderLibrary/ShaderOutput","../core/shaderLibrary/hud/HUD.glsl","../effects/geometry/olidUtils","../lib/GLTextureMaterial","../lib/Material","../lib/screenSizePerspectiveUtils","../lib/Util","./ScaleInfo","./internal/bufferWriterUtils","./internal/MaterialUtil","../../../../chunks/HUDMaterial.glsl","../shaders/HUDMaterialTechnique","../shaders/HUDMaterialTechniqueConfiguration","../../../../webscene/support/AlphaCutoff"],function(e,t,i,r,a,s,n,o,l,c,f,u,h,p,d,g,m,b,v,S,y,O,x,V,z,M,P,A,F,w){"use strict";class _ extends y.Material{constructor(e,t){super(e,ee),this.produces=new Map([[13,e=>m.isColorEmissionHighlightOrOID(e)&&!this.parameters.drawAsLabel],[14,e=>m.isColorEmissionHighlightOrOID(e)&&this.parameters.drawAsLabel],[12,()=>this.parameters.occlusionTest],[18,e=>this.parameters.draped&&m.isColorEmissionHighlightOrOID(e)]]),this._visible=!0,this._configuration=new F.HUDMaterialTechniqueConfiguration(t)}getConfiguration(e,t){const i=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=i,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.hasVVSize=!!this.parameters.vvSize,this._configuration.hasVVColor=!!this.parameters.vvColor,this._configuration.occlusionPass=12===t.slot,this._configuration.occludedFragmentFade=!i&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||12===t.slot,m.isColorOrColorEmission(e)&&(this._configuration.debugDrawLabelBorder=!!g.debugFlags.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,r,s,n,o){const{options:{selectionMode:u,hud:h,excludeLabels:p},point:d,camera:g}=r,{parameters:m}=this;if(!u||!h||p&&m.isLabel||!e.visible||!d||!g)return;const b=e.attributes.get("featureAttribute"),v=null==b?null:f.fromArray(b.data,k),{scaleX:S,scaleY:y}=ie(v,m,g.pixelRatio);i.fromMat4(G,t),e.attributes.has("featureAttribute")&&function(e){const t=e[0],i=e[1],r=e[2],a=e[3],s=e[4],n=e[5],o=e[6],l=e[7],c=e[8],f=1/Math.sqrt(t*t+i*i+r*r),u=1/Math.sqrt(a*a+s*s+n*n),h=1/Math.sqrt(o*o+l*l+c*c);e[0]=t*f,e[1]=i*f,e[2]=r*f,e[3]=a*u,e[4]=s*u,e[5]=n*u,e[6]=o*h,e[7]=l*h,e[8]=c*h}(G);const V=e.attributes.get("position"),z=e.attributes.get("size"),M=e.attributes.get("normal"),A=e.attributes.get("rotation"),F=e.attributes.get("centerOffsetAndDistance");x.assert(V.size>=3);const w=P.calculateAnchorPosition(m),_="screen"===this.parameters.centerOffsetUnits;for(let e=0;e<V.data.length/V.size;e++){const i=e*V.size;l.set(B,V.data[i],V.data[i+1],V.data[i+2]),l.transformMat4(B,B,t),l.transformMat4(B,B,g.viewMatrix);const s=e*F.size;if(l.set(X,F.data[s],F.data[s+1],F.data[s+2]),!_&&(B[0]+=X[0],B[1]+=X[1],0!==X[2])){const e=X[2];l.normalize(X,B),l.subtract(B,B,l.scale(X,X,e))}const n=e*M.size;if(l.set(U,M.data[n],M.data[n+1],M.data[n+2]),D(U,G,g,Z),re(this.parameters,B,Z,g,T),g.applyProjection(B,E),E[0]>-1){_&&(X[0]||X[1])&&(E[0]+=X[0]*g.pixelRatio,0!==X[1]&&(E[1]+=O.applyScaleFactor(X[1],T.factorAlignment)*g.pixelRatio),g.unapplyProjection(E,B)),E[0]+=this.parameters.screenOffset[0]*g.pixelRatio,E[1]+=this.parameters.screenOffset[1]*g.pixelRatio,E[0]=Math.floor(E[0]),E[1]=Math.floor(E[1]);const t=e*z.size;Q[0]=z.data[t],Q[1]=z.data[t+1],O.applyPrecomputedScaleFactor(Q,T.factor,Q);const i=J*g.pixelRatio;let s=0;m.textureIsSignedDistanceField&&(s=Math.min(m.outlineSize,.5*Q[0])*g.pixelRatio/2),Q[0]*=S,Q[1]*=y;const n=e*A.size,f=m.rotation+A.data[n];if(R(d,E[0],E[1],Q,i,s,f,m,w)){const e=r.ray;if(l.transformMat4(I,B,a.invert(W,g.viewMatrix)),E[0]=d[0],E[1]=d[1],g.unprojectFromRenderScreen(E,B)){const t=c.create();l.copy(t,e.direction);const i=1/l.length(t);l.scale(t,t,i),o(l.distance(e.origin,B)*i,t,-1,I)}}}}}intersectDraped(e,t,i,r,a){const s=e.attributes.get("position"),n=e.attributes.get("size"),o=e.attributes.get("rotation"),l=this.parameters,c=P.calculateAnchorPosition(l),u=e.attributes.get("featureAttribute"),h=null==u?null:f.fromArray(u.data,k),{scaleX:p,scaleY:d}=ie(h,l,e.screenToWorldRatio),g=K*e.screenToWorldRatio;for(let t=0;t<s.data.length/s.size;t++){const f=t*s.size,u=s.data[f],h=s.data[f+1],m=t*n.size;Q[0]=n.data[m],Q[1]=n.data[m+1];let b=0;l.textureIsSignedDistanceField&&(b=Math.min(l.outlineSize,.5*Q[0])*e.screenToWorldRatio/2),Q[0]*=p,Q[1]*=d;const v=t*o.size,S=l.rotation+o.data[v];R(i,u,h,Q,g,b,S,l,c)&&r(a.distance,a.normal,-1)}}createBufferWriter(){return new te}applyShaderOffsetsView(e,t,i,r,a,s,n){const o=D(t,i,a,Z);return this._applyVerticalGroundOffsetView(e,o,a,n),re(this.parameters,n,o,a,s),this._applyPolygonOffsetView(n,o,r[3],a,n),this._applyCenterOffsetView(n,r,n),n}applyShaderOffsetsNDC(e,t,i,r,a){return this._applyCenterOffsetNDC(e,t,i,r),null!=a&&l.copy(a,r),this._applyPolygonOffsetNDC(r,t,i,r),r}_applyPolygonOffsetView(e,i,r,a,s){const n=a.aboveGround?1:-1;let o=Math.sign(r);0===o&&(o=n);const c=n*o;if(this.parameters.shaderPolygonOffset<=0)return l.copy(s,e);const f=t.clamp(Math.abs(i.cosAngle),.01,1),u=1-Math.sqrt(1-f*f)/f/a.viewport[2];return c>0?l.scale(s,e,u):l.scale(s,e,1/u),s}_applyVerticalGroundOffsetView(e,t,i,r){const a=l.length(e),s=i.aboveGround?1:-1,n=i.computeRenderPixelSizeAtDist(a)*b.HUDVerticalPixelOffset,o=l.scale(B,t.normal,s*n);return l.add(r,e,o),r}_applyCenterOffsetView(e,t,i){const r="screen"!==this.parameters.centerOffsetUnits;return i!==e&&l.copy(i,e),r&&(i[0]+=t[0],i[1]+=t[1],t[2]&&(l.normalize(U,i),l.sub(i,i,l.scale(U,U,t[2])))),i}_applyCenterOffsetNDC(e,t,i,r){const a="screen"!==this.parameters.centerOffsetUnits;return r!==e&&l.copy(r,e),a||(r[0]+=t[0]/i.fullWidth*2,r[1]+=t[1]/i.fullHeight*2),r}_applyPolygonOffsetNDC(e,t,i,r){const a=this.parameters.shaderPolygonOffset;if(e!==r&&l.copy(r,e),a){const e=i.aboveGround?1:-1,s=e*Math.sign(t[3]);r[2]-=(s||e)*a}return r}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:i}=this.parameters,r=e[3]>=w.alphaCutoff||t>=w.alphaCutoff&&i[3]>=w.alphaCutoff;return this._visible&&r}createGLMaterial(e){return new C(e)}calculateRelativeScreenBounds(e,t,i=h.create()){return function(e,t,i,r){r[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*i,r[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*i}(this.parameters,e,t,i),i[2]=i[0]+e[0],i[3]=i[1]+e[1],i}}class C extends S.GLTextureMaterial{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(A.HUDMaterialTechnique,e)}}function D(e,t,r,a){return u.isMat4(t)&&(t=i.fromMat4(j,t)),l.transformMat3(a.normal,e,t),l.transformMat4(a.normal,a.normal,r.viewInverseTransposeMatrix),a.cosAngle=l.dot(L,$),a}function R(e,i,r,a,s,o,l,c,f){let u=i-s-a[0]*f[0],h=u+a[0]+2*s,p=r-s-a[1]*f[1],d=p+a[1]+2*s;const g=c.distanceFieldBoundingBox;return c.textureIsSignedDistanceField&&null!=g&&(u+=a[0]*g[0],p+=a[1]*g[1],h-=a[0]*(1-g[2]),d-=a[1]*(1-g[3]),u-=o,h+=o,p-=o,d+=o),n.set(q,i,r),n.rotate(H,e,q,t.deg2rad(l)),H[0]>u&&H[0]<h&&H[1]>p&&H[1]<d}const T=new V.ScaleInfo,B=c.create(),U=c.create(),E=f.create(),L=c.create(),I=c.create(),H=o.create(),q=o.create(),G=r.create(),j=r.create(),W=s.create(),N=f.create(),X=c.create(),Y=c.create(),k=f.create(),Z={normal:L,cosAngle:0},J=1,K=2,Q=o.fromValues(0,0),$=c.fromValues(0,0,1);class ee extends S.GLTextureMaterialBindParameters{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1,this.color=f.freeze(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=o.fromValues(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=f.freeze(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=f.create(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}class te{constructor(){this.layout=v.olidEnabled()?A.olidLayout:A.layout}elementCount(e){return 6*e.get("position").indices.length}write(e,t,i,r,a,s){const{position:n,normal:o,uvi:l,color:c,size:f,rotation:u,centerOffsetAndDistance:h,featureAttribute:d}=a;z.writePosition(i.get("position"),e,n,s,6),z.writeNormal(i.get("normal"),t,o,s,6);const g=i.get("uvi")?.data;let m=0,b=0,v=-1-P.fullUV,S=-1-P.fullUV;g&&g.length>=4&&(m=g[0],b=g[1],v=-1-g[2],S=-1-g[3]);let y=i.get("position").indices.length,O=s;for(let e=0;e<y;++e)l.set(O,0,m),l.set(O,1,b),O++,l.set(O,0,v),l.set(O,1,b),O++,l.set(O,0,v),l.set(O,1,S),O++,l.set(O,0,v),l.set(O,1,S),O++,l.set(O,0,m),l.set(O,1,S),O++,l.set(O,0,m),l.set(O,1,b),O++;z.writeColor(i.get("color"),4,c,s,6);const{data:x,indices:V}=i.get("size");y=V.length,O=s;for(let e=0;e<y;++e){const t=x[2*V[e]],i=x[2*V[e]+1];for(let e=0;e<6;++e)f.set(O,0,t),f.set(O,1,i),O++}if(z.writeBufferFloat(i.get("rotation"),u,s,6),i.get("centerOffsetAndDistance")?z.writeBufferVec4(i.get("centerOffsetAndDistance"),h,s,6):z.writeBufferVec4Zeros(h,s,6*y),i.get("featureAttribute")?z.writeBufferVec4(i.get("featureAttribute"),d,s,6):z.writeBufferVec4Zeros(d,s,6*y),null!=r){const e=i.get("position")?.indices;if(e){const t=e.length,i=a.getField("olidColor",p.BufferViewVec4u8);z.writeOlidColor(r,i,t,s,6)}}return{numVerticesPerItem:6,numItems:y}}intersect(e,t,i,r,s,n,o){const{options:{selectionMode:f,hud:u,excludeLabels:h},point:d,camera:g}=r;if(!f||!u||h&&t.isLabel||!d)return;const m=this.layout.createView(e),b=m.getField("position",p.BufferViewVec3f),v=m.getField("normal",p.BufferViewVec3f),S=m.getField("rotation",p.BufferViewFloat),y=m.getField("size",p.BufferViewVec2f),x=m.getField("featureAttribute",p.BufferViewVec4f),V=m.getField("centerOffsetAndDistance",p.BufferViewVec4f),z="screen"===t.centerOffsetUnits,M=P.calculateAnchorPosition(t);if(null==b||null==v||null==S||null==y||null==V||null==g)return;const A=null==x?null:x.getVec(0,k),{scaleX:F,scaleY:w}=ie(A,t,g.pixelRatio),_=b.count/6;for(let e=0;e<_;e++){const s=6*e;if(b.getVec(s,B),null!=i&&l.add(B,B,i),l.transformMat4(B,B,g.viewMatrix),V.getVec(s,N),l.set(X,N[0],N[1],N[2]),!z&&(B[0]+=X[0],B[1]+=X[1],0!==X[2])){const e=X[2];l.normalize(X,B),l.subtract(B,B,l.scale(X,X,e))}if(v.getVec(s,U),D(U,G,g,Z),re(t,B,Z,g,T),g.applyProjection(B,E),E[0]>-1){z&&(X[0]||X[1])&&(E[0]+=X[0]*g.pixelRatio,0!==X[1]&&(E[1]+=O.applyScaleFactor(X[1],T.factorAlignment)*g.pixelRatio),g.unapplyProjection(E,B)),E[0]+=t.screenOffset[0]*g.pixelRatio,E[1]+=t.screenOffset[1]*g.pixelRatio,E[0]=Math.floor(E[0]),E[1]=Math.floor(E[1]),y.getVec(s,Q),O.applyPrecomputedScaleFactor(Q,T.factor,Q);const i=J*g.pixelRatio;let n=0;t.textureIsSignedDistanceField&&(n=Math.min(t.outlineSize,.5*Q[0])*g.pixelRatio/2),Q[0]*=F,Q[1]*=w;const f=S.get(s),u=t.rotation+f;if(R(d,E[0],E[1],Q,i,n,u,t,M)){const t=r.ray;if(l.transformMat4(I,B,a.invert(W,g.viewMatrix)),E[0]=d[0],E[1]=d[1],g.unprojectFromRenderScreen(E,B)){const i=c.create();l.copy(i,t.direction);const r=1/l.length(i);l.scale(i,i,r),o(l.distance(t.origin,B)*r,i,e,I)}}}}}}function ie(e,t,i){return null==e||null==t.vvSize?{scaleX:i,scaleY:i}:(d.evaluateModelTransformScale(Y,t,e),{scaleX:Y[0]*i,scaleY:Y[1]*i})}function re(e,t,i,r,a){if(!e.verticalOffset?.screenLength)return e.screenSizePerspective||e.screenSizePerspectiveAlignment?ae(e,a,l.length(t),i.cosAngle):(a.factor.scale=1,a.factorAlignment.scale=1),t;const s=l.length(t),n=e.screenSizePerspectiveAlignment??e.screenSizePerspective,o=M.verticalOffsetAtDistance(r,s,e.verticalOffset,i.cosAngle,n);return ae(e,a,s,i.cosAngle),l.scale(i.normal,i.normal,o),l.add(t,t,i.normal)}function ae(e,t,i,r){null!=e.screenSizePerspective?O.precomputeScaleFactor(r,i,e.screenSizePerspective,t.factor):(t.factor.scale=1,t.factor.factor=0,t.factor.minScaleFactor=0),null!=e.screenSizePerspectiveAlignment?O.precomputeScaleFactor(r,i,e.screenSizePerspectiveAlignment,t.factorAlignment):(t.factorAlignment.factor=t.factor.factor,t.factorAlignment.scale=t.factor.scale,t.factorAlignment.minScaleFactor=t.factor.minScaleFactor)}e.HUDMaterial=_,e.Parameters=ee,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});