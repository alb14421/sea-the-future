// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/mathUtils","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../geometry/support/aaBoundingBox","../../lib/RayIntersections"],function(t,e,i,n,s){"use strict";const r=1e-6;class a{constructor(t,e,i,n,s){this.aabb=t,this.axis=e,this.d=i,this.midStartIndex=n,this.rightStartIndex=s}}class o{constructor(t,s,r,o){this.globalTriangleVertexIndices=t,this.firstTriangleIndex=s,this.positions=o,this._rayDirection=i.create(),this._callback=u,this._intersectionOptions=f,this.bspNodeTree=new Array;const m=r-s,g=new(m<l?Uint8Array:m<d?Uint16Array:Uint32Array)(m);this.triangleIndexMap=g;for(let t=0;t<m;++t)g[t]=t;{const i=function(t,e,i,n,s){const r=i-e,a=new Float32Array(6*r);for(let i=0;i<r;++i){const r=3*(i+e),o=t[r]*s,c=t[r+1]*s,h=t[r+2]*s;for(let t=0;t<3;++t){const e=n[o+t],s=n[c+t],r=n[h+t];a[6*i+t]=Math.min(e,s,r),a[6*i+3+t]=Math.max(e,s,r)}}return a}(t,s,r,o.data,o.stride),l=e.clamp(Math.log2(m/40),2,10),d=(t,e,s)=>{const r=function(t,e,i,s){if(s<=i)return n.fromValues(NaN,NaN,NaN,NaN,NaN,NaN);{const n=6*t[i];for(let t=0;t<3;++t)c[t]=e[n+0+t],h[t]=e[n+3+t]}for(let n=i+1;n<s;++n){const i=6*t[n];for(let t=0;t<3;++t)c[t]=Math.min(c[t],e[i+0+t]),h[t]=Math.max(h[t],e[i+3+t])}return n.fromValues(c[0],c[1],c[2],h[0],h[1],h[2])}(g,i,t,e),o=e-t;if(o<=40){const i=new a(r,void 0,0,t,e);return this.bspNodeTree.push(i),i}const{axis:f,midValue:u}=function(t){const e=t[3]-t[0],i=t[4]-t[1],n=t[5]-t[2],s=e>i?e>n?0:i>n?1:2:i>n?1:n>e?2:0;return{axis:s,midValue:(t[s]+t[s+3])/2}}(r),m=function(t,e,i,n,s,r){let a=i,o=n;for(;a<o;){const i=t[a];e[6*i+s+3]<=r?++a:(--o,t[a]=t[o],t[o]=i)}let c=a;for(o=n;c<o;){const i=t[o-1];e[6*i+s]>=r?--o:(t[o-1]=t[c],t[c]=i,++c)}return{next:a,mid:c}}(g,i,t,e,f,u),x=(t,e)=>{if(s>l)return;const i=e-t;return i<40||i>=.8*o?void 0:d(t,e,s+1)},y=new a(r,f,u,m.next,m.mid);return this.bspNodeTree.push(y),y.leftNode=x(t,m.next),y.rightNode=x(m.mid,e),y};d(0,m,0)}}intersectRayTriangleRange(t,e){if(t>=e)return;const i=this.positions;s.intersectRayTriangles(this._rayFrom,this._rayDirection,t,e,this.globalTriangleVertexIndices,i.data,i.stride,this._intersectionOptions.normalRequired,this._callback,this.triangleIndexMap,this.firstTriangleIndex),o.numFacesTested+=e-t}intersectRay(t,e,i,n){o.numFacesTested=0;const s=t,a=e,c=a[0]-s[0],h=a[1]-s[1],l=a[2]-s[2];if(c*c+h*h+l*l<r)return;this._rayFrom=s;const d=this._rayDirection;d[0]=c,d[1]=h,d[2]=l;const m=this.triangleIndexMap.length;this._callback=n,this._intersectionOptions=i,this.intersectRayBSP(this.bspNodeTree[0],0,m),this._callback=u,this._intersectionOptions=f}intersectRayBSP(t,e,i){const n=this._rayFrom,s=this._rayDirection;if(!function(t,e,i){const n=e,s=i;let a=0,o=1/0;for(let e=0;e<3;++e){{const i=t[e];if(n[e]<i){if(s[e]<=r)return!1;const t=(i-n[e])/s[e];a=Math.max(a,t)}else if(s[e]<=-r){const t=(i-n[e])/s[e];o=Math.min(o,t)}if(a>o)return!1}{const i=t[e+3];if(n[e]>i){if(s[e]>=-r)return!1;const t=(i-n[e])/s[e];a=Math.max(a,t)}else if(s[e]>=r){const t=(i-n[e])/s[e];o=Math.min(o,t)}if(a>o)return!1}}return!0}(t.aabb,n,s))return;const a=t.axis,o=t.d;if(n[a]<o||s[a]<0){const i=e,n=t.midStartIndex;if(i<n){const e=t.leftNode;void 0!==e?this.intersectRayBSP(e,i,n):this.intersectRayTriangleRange(i,n)}}if(this.intersectRayTriangleRange(t.midStartIndex,t.rightStartIndex),n[a]>o||s[a]>0){const e=t.rightStartIndex,n=i;if(e<n){const i=t.rightNode;void 0!==i?this.intersectRayBSP(i,e,n):this.intersectRayTriangleRange(e,n)}}}static{this.numFacesTested=0}get estimatedMemoryUsage(){return this.triangleIndexMap.byteLength}}const c=[1/0,1/0,1/0],h=[-1/0,-1/0,-1/0],l=255,d=65535,f=new s.MeshIntersectionOptions,u=()=>{};t.ComponentIntersectionData=o,t.componentMinimalSizeForIntersectionData=200,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});