// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../../core/Logger","../../../../../core/MapUtils","../../../../../core/PooledArray","../../../../../core/typedArrayUtil","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../geometry/support/aaBoundingBox","../../../../../geometry/support/Indices","../../../../../chunks/vec3","../../../../../chunks/vec33","../../../layers/support/symbolColorUtils","../../../support/orientedBoundingBox","../../../support/buffer/glUtil","./ComponentData","./ComponentObject","./IntersectionGeometry","./Renderable","./RenderGeometry","./RenderSubmitSystem","./SourceGeometry","./UniformComponentParameters","./Material/ComponentMaterial","./Material/ComponentTechnique","./Material/shader/ComponentData.glsl","../../effects/geometry/olidUtils","../../lib/ComponentUtils","../../lib/Util","../../lib/VertexArrayObject","../../lib/verticalOffsetUtils","../../lib/TextureBackedBuffer/BufferManager","../../../../webgl/BufferObject","../../../../webgl/enums","../../../../webgl/VertexBuffer"],function(e,t,n,i,o,r,a,s,c,l,m,h,f,g,p,u,d,b,v,y,_,C,M,O,w,x,D,S,R,P,V,A,B,E,U){"use strict";const H=()=>n.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");function j(e,t){return e===t?0:0===e?2:1}const I=c.create();t.ComponentObjectCollection=class{constructor(e,t){this._renderManager=e,this._viewingMode=t,this._elevationRangeCacheVerticalOffset=NaN,this._elevationRangeCacheMin=NaN,this._elevationRangeCacheMax=NaN,this._activeHighlightOptions=new Map,this._visible=new o,this._hidden=new o,this._renderSubmit=new _.RenderSubmitSystem(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new A.BufferManager(e.rctx,x.getComponentFieldCount())}destroy(){R.assert(0===this._hidden.length&&0===this._visible.length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy(),this._componentBufferManager=null,this._visible.forAll(e=>e.destroy()),this._visible.prune(),this._hidden.forAll(e=>e.destroy()),this._hidden.prune(),this._renderSubmit.destroy()}createObject(e){const t=e.geometry,n=new u.ComponentData(this._componentBufferManager,l.compactIndices(t.componentOffsets)),i=this._createRenderable(e,n),o=new b.IntersectionGeometry(this._viewingMode,t.positionData,n),r=new d.ComponentObject(e.transform,e.toMapSpace,e.obb.clone(),n,i,o);return(r.visible?this._visible:this._hidden).push(r),r}destroyObject(e){const t=e;(t.visible?this._visible:this._hidden).removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const n=e;t!==n.visible&&(t?(this._hidden.removeUnordered(n),this._visible.push(n)):(this._visible.removeUnordered(n),this._hidden.push(n)),n.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll(e=>e.renderable.meta.cameraDepthSquared=a.squaredDistance(t,e.obb.center))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const n=e.renderable.material;t(n),n.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const n=e;n.componentData.visibility.reset(t),n.componentData.markVisibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.componentData.visibility.forEachComponent(t)}getComponentCount(e){const t=e,n=t.componentData.visibility.componentCount;return{visible:n,invisible:t.componentData.count-n}}setComponentData(e,t){const n=e,{renderable:i,componentData:o}=n,r=i.material,a=o.materialDataBuffer,s=o.materialDataIndices,c=new M.UniformComponentParameters,l=a.textureBuffer,m=new Uint8Array(4),h=new Uint32Array(m.buffer);let p=0,u=0,d=0,b=0,v=0,y=o.verticalOffsets,_=1/0,C=-1/0,w=!1,R=!1,P=!1,V=0;for(let e=0;e<o.count;e++){t(e,c),p+=+(c.externalColor[3]<1),u+=+(3===c.externalColorMixMode&&1===c.externalColor[3]),b+=+(c.emissiveStrength>0),v+=+(1===c.emissiveSource),R||=1!==c.emissiveStrength,d+=+c.castShadows,f.encodeSymbolColor(c.externalColor,c.externalColorMixMode,m),m[2]=254&m[2]|+c.castShadows,l.setData(s[e],0,m[0],m[1],m[2],m[3]),w||=e>0&&V!==h[0],V=h[0],P||=0!==c.elevationOffset,P&&null==y&&(y=new Array(e).fill(0)),null!=y&&(y[e]=c.elevationOffset),_=Math.min(_,c.elevationOffset),C=Math.max(C,c.elevationOffset),x.encodeElevationOffset(c.elevationOffset,m),l.setData(s[e],1,m[0],m[1],m[2],m[3]),x.encodeEmissiveStrength(c.emissiveStrength,m),l.setData(s[e],2,m[0],m[1],m[2],0===c.emissiveSource?0:255);const n=c.olidColor;null!=n&&l.setData(s[e],3,n[0],n[1],n[2],n[3]),c.pickable!==S.getVisibility(o.pickability,e)&&S.updatePickabilityWithCount(o,e,c.pickable)}o.verticalOffsets=P?y:null,n.offsetObb=P?g.computeOffsetObb(n.obb,_,C,this._viewingMode,n.offsetObb??n.obb.clone()):null,w||P||D.olidEnabled()||(R||v>0)&&b>0?(r.componentParameters=new O.ComponentParametersVarying,r.componentParameters.castShadows=j(d,o.count),r.componentParameters.transparent=j(p,o.count),r.componentParameters.opaqueOverride=j(u,o.count),r.componentParameters.emissiveOverride=j(b,o.count),r.componentParameters.emissiveSourceOverride=j(v,o.count),r.componentParameters.texture=l,l.updateTexture()):(r.componentParameters=new O.ComponentParametersUniform,r.componentParameters.castShadows=c.castShadows?0:2,r.componentParameters.externalColor=c.externalColor,r.componentParameters.externalColorMixMode=c.externalColorMixMode,r.componentParameters.emissiveStrength=c.emissiveStrength,r.componentParameters.emissiveSource=c.emissiveSource),this._elevationRangeCacheVerticalOffset=NaN,this._notifyDirty()}getComponentAabb(e,t,n,i=!1){e.intersectionGeometry.getComponentAabb(t,n);const o=e,r=o.componentData.verticalOffsets;if(i||null==r)return n;const a=r[t];if(2===this._viewingMode||0===a)return n[2]+=a,n[5]+=a,n;const s=V.getVerticalOffsetI3S(a);return s.localOrigin=o.transform.position,s.applyToAabb(n)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,n){return e.intersectionGeometry.getComponentPositions(t,n)}expandRangeWithComponentObjectElevationRange(e,t,n,i){Number.isNaN(this._elevationRangeCacheVerticalOffset)||this._elevationRangeCacheVerticalOffset!==t||i.expandElevationRangeValues(this._elevationRangeCacheMin,this._elevationRangeCacheMax);const o=e,r=o.componentData,a=r.count,s=r.verticalOffsets,c=o.intersectionGeometry,l=2===this._viewingMode,m=c.getComponentAabbs(),h=I;let f=1/0,g=-1/0;for(let e=0;e<a;e++){const r=6*e,a=s?.[e]??0;let c=1/0,p=-1/0;if(l)c=m[r+2]+a+t,p=m[r+5]+a+t;else{if(h[0]=m[r],h[1]=m[r+1],h[2]=m[r+2],h[3]=m[r+3],h[4]=m[r+4],h[5]=m[r+5],0!==a){const e=V.getVerticalOffsetI3S(a);e.localOrigin=o.transform.position,e.applyToAabb(h)}const e=Math.max(Math.abs(h[3]),Math.abs(h[0])),s=Math.max(Math.abs(h[4]),Math.abs(h[1])),c=t+h[5]+n;i.expandElevationRangeValues(t+h[2],Math.sqrt(e*e+s*s+c*c)-n)}i.expandElevationRangeValues(c,p),f=Math.min(f,c),g=Math.max(g,p)}this._elevationRangeCacheVerticalOffset=t,this._elevationRangeCacheMin=f,this._elevationRangeCacheMax=g}intersect(e,t,n,i,o,r,a){const s=e,{transform:c,componentData:l,intersectionGeometry:m}=s;return null!=o&&(o.localOrigin=c.position),m.intersect(t,n,i,o,l.verticalOffsets,c,r,a)}addEdges(e,t,n,i,o){const r=e,{indices:a,positions:s}=r.intersectionGeometry,c=r.componentData.offsets;return t.addComponentObject(r,s,a,c,n,i,o)}async extractEdgeInformation(t,n,i){const o=t,r=o.componentData.visibility;if(r.allInvisible()){const{extractComponentsEdgeLocationsLayout:t}=await new Promise((t,n)=>e(["../../lib/edgeRendering/edgeProcessing"],t,n));return{buffer:t.createBuffer(0),origin:[0,0,0]}}const{indices:a,positions:c}=o.intersectionGeometry,l=o.componentData.offsets,{EdgeInputBufferLayout:f}=await new Promise((t,n)=>e(["../../lib/edgeRendering/bufferLayouts"],t,n)),g=f.createBuffer(c.length/3);h.copy(g.position.typedBuffer,c,g.position.typedBufferStride,3),m.transformMat3View(g.position,g.position,o.transform.rotationScale),this._setComponentIndices(g.componentIndex,a,l);const p=g.count,u=this._computeVisibilityIndices(a,r,l,p);return{origin:s.clone(o.transform.position),buffer:await n.extractComponentsEdgeLocations({indices:u,indicesLength:u.length,skipDeduplicate:!0,data:g,writerSettings:{reducedPrecision:!1,variants:0}},i)}}_setComponentIndices(e,t,n){let i=0;for(let o=0;o<n.length-1;o++){const r=n[o],a=n[o+1];for(let n=r;n<a;n++){const o=t?t[n]:n;e.set(o,i)}i++}}_computeVisibilityIndices(e,t,n,i){if(e&&t.allVisible())return e;let o=0;t.forEachComponentRange((e,t)=>(o+=n[t]-n[e],!0));const a=r.isTypedArray(e)?2===e?.BYTES_PER_ELEMENT||i<=65536?new Uint16Array(o):new Uint32Array(o):new Array(o);let s=0;return t.forEachComponentRange((t,i)=>{const o=n[t],r=n[i];for(let t=o;t<r;t++)a[s++]=e?e[t]:t;return!0}),a}addComponentHighlight(e,t,n){const o=e.componentData,r=i.getOrCreateMapValue(o.componentHighlights,n,()=>new Uint32Array(o.count+1));{const e=this._activeHighlightOptions.get(n)??0;this._activeHighlightOptions.set(n,e+1)}0===r[t]++&&(o.markHighlightsDirty(),this._notifyDirty()),r[o.count]++}removeComponentHighlight(e,t,n){const{componentData:i}=e,o=i.componentHighlights.get(n);if(void 0===o)return void H().warn("Removing non-existing highlight.");const r=o[t];if(0===r)return void H().warn("Removing non-existing highlight.");this._removeActiveHighlight(n);const a=o[i.count];if(r>1)return o[t]=r-1,void(o[i.count]=a-1);o[t]=0,1===a?i.componentHighlights.delete(n):o[i.count]=a-1,i.markHighlightsDirty(),this._notifyDirty()}_removeActiveHighlight(e,t=1){const n=this._activeHighlightOptions.get(e);if(void 0===n)H().warn("Removing non-existing highlight.");else{const i=n-t;i<0&&H().warn("Removing non-existing highlight."),i<=0?this._activeHighlightOptions.delete(e):this._activeHighlightOptions.set(e,i)}}clearHighlights(e){const{componentData:t}=e,{componentHighlights:n}=t;if(n.size>0){for(const e of n)this._removeActiveHighlight(e[0],e[1][t.count]);n.clear(),t.markHighlightsDirty(),this._notifyDirty()}}hasHighlight(e){return this._activeHighlightOptions.has(e)}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._visible}_createRenderable(e,t){const n=this._renderManager.rctx,i=e.geometry,o=i.vertices.layoutParameters,r=p.glLayout(C.createVertexBufferLayout(o)),a=new U.VertexBuffer(n,r,i.vertices.data),s=i.indices?B.BufferObject.createIndex(n,35044,i.indices):null,c=new Uint16Array(i.vertices.count);for(let e=0;e<t.count;e++){const n=t.offsets[e],o=t.offsets[e+1],r=t.materialDataIndices[e];if(null!=i.indices)for(let e=n;e<o;e++)c[i.indices[e]]=r;else for(let e=n;e<o;e++)c[e]=r}const l=new U.VertexBuffer(n,w.indexGlLayout,c.buffer),m=new O.ComponentMaterial(e.transform,e.toMapSpace),h=new P.VertexArrayObject(n,new Map([["geometry",a],["componentIndices",l]]),s),f=new y.RenderGeometry(h,E.PrimitiveType.TRIANGLES,o,null!=s),g={cameraDepthSquared:.5,gpuMemoryEstimate:a.usedMemory+l.usedMemory+(null!=s?s.usedMemory:0)};return new v.Renderable(m,f,g)}_notifyDirty(){this._renderManager.notifyDirty()}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});