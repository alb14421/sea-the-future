// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/arrayUtils","../../../core/has","../../../core/mathUtils","../../../core/maybe","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./PatchGeometry","./TerrainConst","./terrainUtils","./TextureFader","./TextureReference","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../../webgl/BufferObject","../../webgl/VertexBuffer"],function(e,t,r,i,s,n,a,l,o,d,g,h,c,u,m,f,y,p,x,_,v){"use strict";const A=a.create(),b=a.create(),C=a.create(),E=a.create(),$=a.create(),S=a.create(),D=[null,null,null,null];function T(e,t){return t?.loaded||t===e?t:null}const R=[0,1,2,3];e.PatchRenderData=class{constructor(){this.geometry=new h.PatchGeometry,this.geometryState=null,this._texture=null,this._textureOpacity=1,this._textureRef=new m.TextureFader(()=>this._tile.surface.fadeDuration),this.overlay=new y,this._localOrigin=null,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._modifiedFlags=0}get tile(){return this._tile}get localOrigin(){return this._localOrigin}init(e,t){this.clear(),this._tile=e,this.geometry.reset(),this.intersectionData=null,this.geometryState=new g.GeometryState,this._localOrigin=t,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this.wireframeChanged||this.clippingAreaChanged||this.samplerDataChanged||this.numVerticesPerSideChanged||this.dirtyCorners||this.dirtyEdgeResolutions||this.dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),u.enableTerrainInternalChecks&&this.tile.intersectsClippingArea)for(let e=0;e<4;++e)u.internalAssert(this.geometry.getEdgeCount(e)===this.geometryState.edgeResolutions[e]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,n=u.neighborEdgeIndices[e];if(!t)return u.internalAssert(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(n)),i;if(t.loaded){const r=t,n=r.renderData.geometryState,a=s-r.level;if(u.internalAssert(a>=0),0===a){const e=n.numVerticesPerSide-1;return Math.max(e,i)}const l=2**a,o=n.edgeResolutions[(e+2)%4]/l;return Math.max(1,o)}u.internalAssert(!t.leaf);let a=i;return t.forAllSubtreeOnSide(u.oppositeEdge(n),e=>e===r||(e.loaded?(a=Math.max(a,2**(e.level-s)),!0):(u.internalAssert(!e.leaf),!1))),a}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState,r=t=>(t.loaded||t.level===e.level)&&t?.intersectsClippingArea,s=t.edgePeerNeighbors,n=t.edgePeerNeighborSamplerVersions;for(let a=0;a<4;++a){const l=e.findNeighborTile(u.neighborEdgeIndices[a],r),o=T(e,l),d=o?.renderData?.geometryState.samplerDataVersion??-1,g=s[a],h=o!==T(e,g),m=n[a]!==d;u.enableTerrainInternalChecks&&l&&(u.internalAssert(e.level>=l.level),u.internalAssert(e.level-l.level<=c.maxTileNeighborLevelDelta)),s[a]=l,(h||m)&&(n[a]=d,this._markEdgeDirty(a));const f=t.edgeResolutions[a],y=this._calculateEdgeResolution(a,l);u.internalAssert(i.isPowerOfTwo(y)),u.internalAssert(y>=1),t.edgeResolutions[a]=y,f!==y&&this._markEdgeResolutionDirty(a)}for(let i=0;i<4;++i){const n=e.findNeighborTile(u.neighborCornerIndices[i],r);t.cornerPeerNeighbors[i]=n;const a=T(e,s[i]),l=T(e,s[(i+1)%4]),o=T(e,n);D[i]=o,D[(i+1)%4]=l,D[(i+2)%4]=e,D[(i+3)%4]=a,u.internalAssert(D.some(t=>t?.loaded||t===e));const d=D.reduce((e,t)=>Math.min(e,t?.level??1/0),1/0);D.forEach((e,t)=>{e&&e?.level>d&&(D[t]=null)}),u.internalAssert(D.some(t=>t?.loaded||t===e));const g=t.cornerNeighborCornerTiles,h=t.cornerNeighborCornerTileSamplerVersions;for(let e=0;e<4;++e){const t=D[e],r=t?.renderData.geometryState.samplerDataVersion??-1,s=4*i+e,n=g[s]!==t,a=!n&&h[s]!==r;(n||a)&&(g[s]=t,h[s]=r,this._markCornerDirty(i))}u.enableTerrainInternalChecks&&u.internalAssert(R.some(t=>g[4*i+t]?.loaded||g[4*i+t]===e))}u.enableTerrainInternalChecks&&u.internalAssert(this.geometryState.edgeResolutions.every(e=>e>0));for(let e=0;e<4;++e)D[e]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;u.enableTerrainInternalChecks&&u.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.edgeResolutions.every(e=>e>0)),this.intersectionData=null;const{tile:t,_vao:r,geometry:i,geometryState:s}=this,n=!r||this.wireframeChanged||this.samplerDataChanged||this.clippingAreaChanged||this.numVerticesPerSideChanged,a=0!==this.dirtyEdgeResolutions,l=s.edgeResolutions.reduce((e,t)=>e+t+1,0),o=n||a&&l>(i?.maxEdgeVertexCount??0),d=!o&&a,g=!d&&(0!==this.dirtyEdges||a),h=!g&&0!==this.dirtyCorners;o?(this.releaseGeometry(),this._createGeometry(e)):d?t.updateEdgeElevationsAndResolutions():g||h?t.updateEdgeElevations():h?t.updateCornerElevations():console.warn("Update for no reason?"),this._modifiedFlags=0}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao=s.disposeMaybe(this._vao),this.geometry.release(),!0)}ensureTexture(e,t,r,i){const s=t?6408:6407;return null!=this._texture&&(0===r&&this._tile.surface.fadeDuration>0&&this._isTextureVisible(this._texture)||this._texture.descriptor.width!==e||this._texture.descriptor.pixelFormat!==s)&&this.releaseTexture(),null==this._texture&&(this._texture=i(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){this._texture&&(this._texture=s.releaseMaybe(this._texture),this.tile.setMemoryDirty())}reuseTexture(e,t){return!(!e||!this._texture||(e.setTextureReference(new f.TextureReference(this._texture,0,t,this._textureOpacity,0,1)),0))}get numVerticesPerSideChanged(){return!!(1&this._modifiedFlags)}get samplerDataChanged(){return!!(2&this._modifiedFlags)}get clippingAreaChanged(){return!!(4&this._modifiedFlags)}get wireframeChanged(){return!!(8&this._modifiedFlags)}get dirtyEdges(){return this._modifiedFlags>>4&15}get dirtyCorners(){return this._modifiedFlags>>8&15}get dirtyEdgeResolutions(){return this._modifiedFlags>>12&15}_markCornerDirty(e){const t=1<<e<<8;this._modifiedFlags|=t}_markEdgeDirty(e){const t=1<<e<<4;this._modifiedFlags|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e<<12;this._modifiedFlags|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._modifiedFlags|=65520}updateGeometryState(){const e=this._elevationInfo,r=this.tile,i=e.samplerData?r.getElevationVerticesPerSide(e.maxTileLevel):r.minimumVerticesPerSide,s=Math.max(i,5);let n=r.clippingArea;r.intersectsClippingArea&&!r.withinClippingArea||(n=null);const a=this.geometryState;let l=!1;a.numVerticesPerSide!==s&&(this._modifiedFlags|=1,a.numVerticesPerSide=s,a.samplerDataVersion++,l=!0),e.changed&&(this._modifiedFlags|=2,a.samplerData=e.samplerData,a.samplerDataVersion++,l=!0),t.equals(a.clippingArea,n)||(this._modifiedFlags=4,a.clippingArea=n,l=!0);const o=r.surface.wireframe;return a.wireframe!==o&&(this._modifiedFlags=8,a.wireframe=o,l=!0),this._geometryStateChangedSinceLastUpdate||=l,l&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const{vertexAttributes:t,indices:r}=this.geometry,i=e.gl;this._vao=new x.VertexArrayObject(e,new v.VertexBuffer(e,d.glLayout(t.layout),t.buffer),_.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=0){e?.texture===this._texture?this._textureOpacity=e.opacities[0]:this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_isTextureVisible(e){return this._textureRef.current?.texture===e||this._textureRef.next?.texture===e&&this._textureRef.fadeFactor<1}get _elevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[0],r=t.length,i=new Array(r);let s=0,n=0,a=!1;for(let l=0;l<r;l++){const r=t[l],o=r.upsampleInfo?.tile;if(o){const t=o.layerInfo[0][l].data,r=t&&t.samplerData;e&&e[s]===r||(a=!0),i[s++]=r,n=Math.max(n,o.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(l,0);if(p.fallsWithinLayerView(this.tile,t)){const t=r.data;e&&e[s]===t.samplerData||(a=!0),i[s++]=t.samplerData,n=this.tile.level}}}null!=e&&e.length!==s&&(a=!0);const l=s>0,o=l?i:null;return l&&(i.length=s),{changed:a,samplerData:o,maxTileLevel:n}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){}checkGeometryWaterproofness(){if(!u.enableTerrainInternalChecks)return;const e=this.tile;if(!e.loaded||!e.intersectsClippingArea||0===e.level)return void u.internalAssert(e?.loaded);const t=e.surface.extent;if(null!=t&&!e.intersectsExtent(t))return;const r=u.neighborEdgeIndices.map((r,i)=>null!=t&&(i<2?-1:1)*(e.extent[3-i]-t[3-i])<0),s=e.level;u.internalAssert(0===this.dirtyCorners),u.internalAssert(0===this.dirtyEdges),u.internalAssert(0===this.dirtyEdgeResolutions),u.internalAssert(!this.numVerticesPerSideChanged),u.internalAssert(!this.samplerDataChanged),u.internalAssert(!this.clippingAreaChanged),u.internalAssert(!this.wireframeChanged);const d=u.neighborCornerIndices.map(t=>e.findNeighborCornerTileExact(t,t=>!t.intersectsClippingArea||t.loaded||t.level===e.level)??null).map(e=>e?.intersectsClippingArea?e:null),g=this.geometryState;for(let t=0;t<4;++t){const r=g.cornerPeerNeighbors[t],i=d[t];u.internalAssert(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}u.neighborEdgeIndices.forEach((t,d)=>{if(r[d])return;const g=e.findNeighborTile(t,e=>(e.level===s||e?.loaded)&&e?.intersectsClippingArea);if(!g){const r=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(t);return void u.internalAssert(!r)}u.internalAssert(g.loaded||g.level===e.level),u.internalAssert(g===this.geometryState.edgePeerNeighbors[d]);const h=s-g.level;if(!g.loaded)return u.internalAssert(!g.leaf),void u.internalAssert(0===h);const c=g.renderData;u.internalAssert(e.isEdgeNeighbor(g,t)),u.internalAssert(h>=0);const m=2**h;if(h<0)return void u.internalAssert(!1);const f=e.renderData,y=f.geometry,p=f.localOrigin,x=y.getEdgeCount(d),_=y.numVerticesPerSide-1,v=c.geometry;if(!v)return void u.internalAssert(!1);const D=c.localOrigin,T=this.geometryState.edgePeerNeighbors[d];if(T?.loaded){const e=T.renderData;u.internalAssert(f.geometryState.edgePeerNeighborSamplerVersions[d]===e.geometryState.samplerDataVersion),u.internalAssert(this.geometryState.edgePeerNeighborSamplerVersions[d]===e.geometryState.samplerDataVersion)}const R=(d+2)%4,V=v.getEdgeCount(R),w=x-1,P=V-1;u.internalAssert(w*m===P,`Tile[${e.lij}]:e${d},res=${w} edgeRes mismatch with Neighbor[${g.lij}]:e${R},res=${P} (expected:${w*m})`);const F=e.extent,N=0===t||4===t,I=V-1,O=I>>h,G=x-1;if(O<1)return void u.internalAssert(1===G);u.internalAssert(O===G),u.internalAssert(i.isPowerOfTwo(O));const j=v.numVerticesPerSide-1;u.internalAssert(h>0||O===Math.max(j,_));const M=e.getNeighborEdgeStartVertexIndex(d,g);u.internalAssert(0<=M&&M<m);const k=M*O;u.internalAssert(0<=k&&k<=I-O);let L=0,U=k;y.getEdgeVertexPosition(d,A,p,0),y.getEdgeVertexPosition(d,b,p,x-1);const X=n.distance(A,b),B=Math.max(1,1e-4*X);for(let r=0;r<=O;++r){y.getEdgeVertexPosition(d,A,p,L),v.getEdgeVertexPosition(R,b,D,U);const i=r/O,s=N?F[0]+i*(F[2]-F[0]):6===t?F[0]:F[2],h=N?4===t?F[1]:F[3]:F[1]+i*(F[3]-F[1]),m=e.surface.extent;if(null==m||l.containsXY(m,s,h)){const t=n.dist(A,b),r=n.len(A)-o.earth.radius,i=n.len(b)-o.earth.radius,l=t<B;if(!l){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${d}[${L}/${x}] and [${g.lij}].edge${R}[${U}/${V}]`),null!=m&&console.warn("  surface extent= ",m," x,y=",s,",",h);const o=a.create();n.subtract(o,f.localOrigin,c.localOrigin),n.len(o)>0&&console.warn(`   localOrigins: ${f.localOrigin} vs ${c.localOrigin} d=${n.len(o)} [${o}]`),(()=>{const t=a.clone(A),r=a.clone(b);e.updateEdgeElevations(),g.updateEdgeElevations(),y.getEdgeVertexPosition(d,A,p,L),v.getEdgeVertexPosition(R,b,D,U);const i=a.create();n.sub(i,A,t),n.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${A} d=${n.len(i)} [${i}]`),n.sub(i,b,r),n.len(i)>0&&console.warn(`  XXX Neighbor[${g.lij}] edge out of date: ${r} vs ${b} d=${n.len(i)} [${i}]`)})();const _=y.getEdgeCount(d),C=v.getEdgeCount(V);u.internalAssert(l,`Mismatch in tile [${e.lij}].edge[${d}][${L}/${_}] vs neighbor [${g.lij}].edge[${R}][${U}/${C}] ${u.v32s(A)} vs ${u.v32s(b)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}y.getEdgeNormal(d,C,L),v.getEdgeNormal(R,E,U),n.normalize($,C),n.normalize(S,E);const _=n.dot($,S),T=1-_<.01||e===g;if(!T){const t=a.create();n.sub(t,C,E);const r=()=>`Mismatch in tile edge normal ${u.lij2s(e.lij)} (${L}/${x-1}) edge ${d} vs neighbor ${u.lij2s(g.lij)}  (${U}/${V-1}) nedge ${R} :${u.v32s(C)} vs ${u.v32s(E)}  dot = ${_} : ${u.v32s(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),g.updateEdgeElevations();const t=a.create(),r=a.create();y.getEdgeNormal(d,t,L),v.getEdgeNormal(R,r,U),n.equals(C,t)||console.warn("Missing update in tile normal: ",u.v32s(C)," => ",u.v32s(t)),n.equals(E,r)||console.warn("Missing update in neighbor normal: ",u.v32s(E)," => ",u.v32s(r))}u.internalAssert(T,r())}}L+=1,U+=1}})}},e.neighborTileIfLoadedOrSelf=T,e.zeroToFour=R,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});