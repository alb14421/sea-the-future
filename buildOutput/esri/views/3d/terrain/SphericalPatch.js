// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/mathUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/projection/lonLatToSphericalPCPF","../../../geometry/support/DoubleArray","../../../geometry/support/frustum","../../../chunks/sphere","./PatchGeometryFactory","./terrainUtils","./Tile","./tileUtils"],function(e,t,s,i,n,o,r,a,l,c,h,u){"use strict";class d extends h.Tile{constructor(e,t,s,i,n){super(),this._convexHull=new Array(24),this._boundingSphere=a.create(),this._baseUsedMemory=1816,this.init(e,t,s,i,n)}init(e,i,o,r,a){super.init(e,i,o,r,a);const l=this.ellipsoid.radius,c=this.extentInRadians[0],h=this.extentInRadians[1],u=this.extentInRadians[2],d=this.extentInRadians[3],p=t.lerp(h,d,.5),f=t.lerp(c,u,.5),m=0===e?0:Math.min(Math.abs(h),Math.abs(d));this._edgeLen=(u-c)*Math.cos(m)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),n.lonLatToSphericalPCPF(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),s.normalize(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const e=this._center;if(0===this.lij[0])s.set(a.getCenter(e[1]),0,0,0),s.set(e[0],0,0,0),s.set(e[2],0,0,0),e[1][3]=this.ellipsoid.radius+this.elevationBoundsMax;else{this._updateCenter();const t=e[1],s=this.convexHull;let i=0;for(let e=0;e<8;++e)i=Math.max(i,f(a.getCenter(t),s,3*e));e[1][3]=Math.sqrt(i)}}_calculateFrustumVisibility(e){if(!r.intersectsSphere(e,this._boundingSphere))return 2;if(this.lij[0]<10)return 1;const t=this.convexHull,s=this.surface.view.state.camera.near;let i=!0;for(let n=0;n<r.numPlanes;n++){const o=4===n,r=e[n],a=r[0],l=r[1],c=r[2],h=r[3]-(o?s:0);let u=!1;for(let e=0;e<8;++e){const s=3*e;if(a*t[s]+l*t[s+1]+c*t[s+2]+h<0){if(u=!0,!i)break}else i=!1}if(!u)return 2}return i?0:1}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){l.createSphericalGlobePatch(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),c.enableTerrainInternalChecks&&this._checkBVs()}_updateBoundingSphere(){const e=this._boundingSphere,t=a.getCenter(e),i=this.elevationBoundsMin,n=this.elevationBoundsMax,o=this.ellipsoid.radius,r=n;if(0===this.level)s.set(t,0,0,0),e[3]=o+r;else{const r=this.extentInRadians,a=.5*(r[0]+r[2]),l=r[1],c=r[3];g(v,a,l,o),g($,a,c,o),s.add(t,v,$);const h=o+.5*(i+n);s.scale(t,t,h/s.len(t));const u=this.convexHull;let d=0;const p=(e,t)=>{const s=e[0]-u[3*t],i=e[1]-u[3*t+1],n=e[2]-u[3*t+2];return Math.sqrt(s*s+i*i+n*n)};for(let e=0;e<8;++e){const s=p(t,e);d=Math.max(d,s)}const f=d;e[3]=f+2}}_updateConvexHull(){const e=this.extentInRadians,t=this.ellipsoid.radius;if(0===this.level)return;const n=this.elevationBoundsMin,o=this.elevationBoundsMax,r=this._getPatchType(),a=this.surface.isWebMercator,l=a&&1===r,h=a&&2===r,u=h||l,d=Math.PI/2,p=e[0],f=e[2],m=h?-d:e[1],v=l?d:e[3],$=.5*(p+f),b=n,M=t+(u?Math.min(0,b-1):b),_=(e,t,s)=>g(e,t,s,M),S=i.create(),y=i.create(),A=i.create(),B=i.create();_(S,p,m),_(y,p,v),_(A,f,v),_(B,f,m);const j=(e,t)=>{for(let s=0;s<3;++s)this._convexHull[3*t+s]=e[s]};j(S,0),j(y,1),j(A,2),j(B,3);const C=o,T=t+(u?Math.max(0,C+1):C),P=i.create(),V=i.create(),R=i.create();g(V,$,v,M),g(R,$,m,M),s.add(P,V,R),s.normalize(P,P);const I=i.create(),z=i.create(),E=(e,t)=>{s.sub(z,e,t),s.normalize(z,z);const i=-s.dot(e,I)/s.dot(z,I);c.internalAssert(i>=0),s.scale(z,z,i),s.add(e,e,z)};if(2**this.lij[0]>2*this.lij[1]){const e=R,t=i.create();s.cross(t,x,e),s.normalize(t,t),s.cross(I,e,t),s.normalize(I,I),c.internalAssert(c.almostEquals(s.dot(I,e)/s.len(e),0)),E(S,y),E(B,A),j(S,0),j(B,3)}else if(2**this.lij[0]!==2*this.lij[1]){const e=V,t=i.create();s.cross(t,x,e),s.normalize(t,t),s.cross(I,t,e),s.normalize(I,I),E(y,S),E(A,B),j(y,1),j(A,2)}const H=(e,t)=>{const i=T/s.dot(t,P);for(let s=0;s<3;++s)this._convexHull[3*e+s]=t[s]*i};H(4,S),H(5,y),H(6,A),H(7,B)}_getPatchType(){const e=this.lij[1],t=0===e,s=e===(1<<this.level)-1;return t?s?3:1:s?2:0}intersectsRay(e,t,s,i){const n=this._boundingSphere,o=n[3]+s,r=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],a=n[0]-e[0],l=n[1]-e[1],c=n[2]-e[2],h=(a*t[0]+l*t[1]+c*t[2])/r,u=t[0]*h-a,d=t[1]*h-l,p=t[2]*h-c;return u*u+d*d+p*p<o*o}get minimumVerticesPerSide(){return this.level<p.length?p[this.level]+1:2}updateCornerElevations(){l.updateCornerSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){l.updateEdgesAndCornersSpherical(this.renderData),this._updateBoundingVolumes()}updateEdgeElevationsAndResolutions(){l.updateEdgeElevationsAndResolutionsSpherical(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!c.enableTerrainInternalChecks)return;if(this.level<=2)return;const e=this._boundingSphere,t=e[3],n=a.getCenter(e),r=i.create(),l=this.ellipsoid.radius,h=this.elevationBoundsMin,d=this.elevationBoundsMax,p=l+h,f=this._center[1][3],x=this.convexHull,v=(e,t)=>{for(let s=0;s<3;++s)e[s]=x[3*t+s]};{const e=i.create(),t=i.create(),n=i.create(),o=i.create(),r=i.create(),a=(i,a,l,h)=>{v(t,i),v(n,a),v(o,l),s.sub(t,t,n),s.sub(o,o,n),s.cross(e,t,o),s.normalize(e,e);const u=s.dot(e,n);v(r,h);const d=s.dot(e,r),p=Math.abs(d-u);c.internalAssert(c.almostEquals(p,0),`Non coplanar ${i},${a},${l},${h} diff = ${p}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const $=o.newDoubleArray(24),b=i.create(),M=i.create(),_=i.create(),S=i.create(),y=(e,t,i,n)=>{v(b,t),v(M,i),v(_,n),s.sub(b,b,M),s.normalize(b,b),s.sub(_,_,M),s.normalize(_,_),s.cross(S,b,_),s.normalize(S,S);const o=s.dot(S,M);((e,t,s)=>{const i=4*e;for(let e=0;e<3;++e)$[i+e]=t[e];$[i+3]=s})(e,S,o)};y(0,0,1,2),y(1,1,0,4),y(2,1,5,2),y(3,3,2,6),y(4,4,0,3),y(5,4,6,5);const A=(e,t,s,i)=>{const n=4*e;return $[n]*t+$[n+1]*s+$[n+2]*i-$[n+3]},B=(e,t,s,i)=>A(e,t,s,i)>=-1,j=(e,t)=>B(e,t[0],t[1],t[2]),C=2**this.lij[0]>2*this.lij[1],T=(e,s,i)=>Math.sqrt(m(e,s,i,n[0],n[1],n[2]))<t,P=e=>T(e[0],e[1],e[2]),V=(e,t)=>T(e[t],e[t+1],e[t+2]),R=this.extentInRadians,I=.5*(R[0]+R[2]),z=R[1],E=R[3],H=i.create(),L=i.create();g(H,I,E,p),g(L,I,z,p);const k=C?"Upper":"Lower";let F=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const s=3*t,i=B(e,x[s],x[s+1],x[s+2]);F&&=i,c.internalAssert(i,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}c.internalAssert(j(e,L),`Tile[${this.lij}] (${k}) bottom mid outside of plane ${e}`),c.internalAssert(j(e,H),`Tile[${this.lij}] (${k}) top mid outside of plane ${e}`)}c.internalAssert(F,"Not all convex hull points are inside  convex hull polyhedron"),c.internalAssert(P(L),`Tile[${this.lij}] (${k}) bottom mid outside of bounding sphere`),c.internalAssert(P(H),`Tile[${this.lij}] (${k}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=V(x,3*e);c.internalAssert(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}for(let e=0;e<6;++e)for(let t=0;t<8;++t){const s=3*t;B(e,x[s],x[s+1],x[s+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const{extentInRadians:D}=this,q=Math.max(D[2]-D[0],D[3]-D[1]),w=Math.round(q*l),{renderData:U}=this;if(!U)return;const{geometry:N,geometryState:G,localOrigin:O}=U,W=N.vertexAttributes?.position;if(!W)return;const J=i.create(),K=N.numVerticesPerSide-2,{indices:Q,indexCount:X,edgeVerticesStartIndex:Y,poleVerticesStartIndex:Z}=N;if(!Q)return;const ee=new Set;for(let e=0;e<X;++e){const i=Q[e];if(ee.has(i))continue;ee.add(i);const o=i<Z,a=i>=Y;let c=!1,p=-1;if(a){let e=Y;for(let t=0;t<4;++t){const s=G.edgeResolutions[t];if(i===e||i===e+s-1){c=!0;break}if(e+=s,i<e){p=t;break}}}const m=a?G.edgePeerNeighbors[p]:null,g=a&&m&&u.compareTilesByLij(this,m)>0;W.getVec(i,r),s.add(J,r,O);const x=s.len(J)-l;let v=0,$=!1;const b=h-x,M=x-d,_=b>1,S=M>1,y=_||S,j=()=>{const e=o?"internal":a&&!c?"edge":c?"corner":"pole";return`Tile[${this.lij}].vertex[${i}]:${e}`+(_?"(below)":S?"(above)":"")+(g?"(Neighbor)":"")},C=s.dist(J,n);if(C>=t+0){const e=C-t;y||(console.error(`${j()} is out of the bounding sphere by ${e.toFixed(0)} / ${t.toFixed(0)}[tol=0] h=${x.toFixed(0)} / [${h.toFixed(0)}..${d.toFixed(0)}] (${(e/t).toFixed(0)})`),$=!0)}for(let e=0;e<6;++e)if(!B(e,J[0],J[1],J[2])){const s=A(e,J[0],J[1],J[2]),n=i%K,o=(i-n)/K;0===e&&b||5===e&&M||(console.error(`${j()} (${n},${o})|${K}] is out of the bounding trapezoid plane ${e} h=${Math.round(x)} / [${Math.round(h)}..${Math.round(d)}] dist=${Math.round(s)} radii = ${Math.round(t)}/${Math.round(f)}} : maxL = ${w}`),++v)}if($||v>0)break}}get convexHull(){return this._convexHull}}const p=[128,64,64,32,16,8,8,4];function f(e,t,s){return m(e[0],e[1],e[2],t[s],t[s+1],t[s+2])}function m(e,t,s,i,n,o){const r=i-e,a=n-t,l=o-s;return r*r+a*a+l*l}const g=(e,t,s,i)=>{const n=Math.cos(t),o=Math.sin(t),r=Math.cos(s),a=Math.sin(s);e[0]=i*r*n,e[1]=i*r*o,e[2]=i*a},x=[0,0,1],v=i.create(),$=i.create();e.SphericalPatch=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});