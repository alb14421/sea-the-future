// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/mathUtils","../../../core/typedArrayUtil","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","./ElevationData","./PatchGeometryLUT","./PatchRenderData","./terrainUtils","./Tile","./tileUtils","../webgl-engine/lib/Normals"],function(e,t,n,o,s,r,i,a,l,c,u,d){"use strict";function m(e){e.tile.intersectsClippingArea&&(p(e),f(e))}function f(e,o=!1){const{geometry:s,geometryState:i,tile:c,localOrigin:d}=e,{level:m,extent:f,extentInRadians:p,ellipsoid:g}=c,x=g.radius,M=p[0],v=p[2],y=p[1],S=p[3],{samplerData:A}=i,E=f[0],V=f[2],b=f[1],B=f[3],C=h(e),{boundingBox:U,vertexAttributes:L}=s,P=d[0],T=d[1],O=d[2],{position:D,uv0:R}=L,N=D.typedBuffer,F=D.typedBufferStride;for(let d=0;d<4;++d){const p=1===d||3===d,g=i.edgeResolutions[d];l.internalAssert(t.isPowerOfTwo(g));const h=g+1,L=a.neighborTileIfLoadedOrSelf(c,i.edgePeerNeighbors[d]);if(w(c,L,d)){I(e,d,L);continue}const D=null!=L;l.internalAssert(!D||L.level===c.level),l.internalAssert(!D||u.compareTilesByLij(c,L)<=0);const j=L?.renderData,k=j?.geometryState;if(l.enableTerrainInternalChecks){const e=c.surface;if(!L&&e&&!e.updatingRootTiles){const t=l.neighborEdgeIndices[d],n=c.findNeighborTile(t,e=>e.loaded||e.leaf||e.level===c.level);n?n.intersectsClippingArea&&(l.internalAssert(!n.loaded),l.internalAssert(!n.leaf),l.internalAssert(n.level===m)):l.internalAssert(null==e?.rootTiles||!c.shouldHaveNeighbor(t))}}const G=1===d?f[2]:f[0],W=L?.extent,z=W&&p?1===d?W[0]:W[2]:G,H=0===d?f[3]:f[1],J=1===d?1:0,K=0===d?1:0,Q=1===d?v:M,X=0===d?S:y,Y=Math.sin(Q),Z=Math.cos(Q),$=Math.sin(X),_=Math.cos(X),ee=k?.samplerData,te=D?(e,t,n)=>.5*(r.sampleElevation(e,t,A)+r.sampleElevation(n,t,ee)):(e,t,n)=>r.sampleElevation(e,t,A),ne=s.outerEdgesOffsetAndLength[2*d+0],oe=o&&h>3?h-3:1,se=null!=A&&A.some(e=>null!=e),re=null!=ee&&ee.some(e=>null!=e),ie=se||re,ae=1/g,le=ne;l.internalAssert(!W||l.almostEquals(W[2]-W[0],f[2]-f[0])),(()=>{const e=1===d?-1:3===d?1:0,t=0===d?-1:2===d?1:0,o=(f[2]-f[0])*ae,i=e*o,a=t*o,l=p?e*((v-M)*ae):0,c=p?0:t*ae,u=K,m=p?Q+l:Q,g=p?Math.sin(m):Y,y=p?Math.cos(m):Z,S=p?Q-l:Q,I=p?Math.sin(S):Y,L=p?Math.cos(S):Z,w=p?X:C(u+c),j=p?$:Math.sin(w),k=p?_:Math.cos(w),W=p?X:C(u-c),ne=p?$:Math.sin(W),se=p?_:Math.cos(W);let re=0,ce=0,ue=0;{const e=0*ae,t=p?G:E*(1-e)+V*e,n=p?z:t,o=p?b*(1-e)+B*e:H,s=p?Q:M*(1-e)+v*e,r=p?Y:Math.sin(s),i=p?Z:Math.cos(s),a=p?C(e):X,l=p?Math.sin(a):$,c=p?Math.cos(a):_,u=x+te(t,o,n);re=i*c*u,ce=r*c*u,ue=l*u}let de=0,me=0,fe=0;{const e=1*ae,t=p?G:E*(1-e)+V*e,n=p?z:t,o=p?b*(1-e)+B*e:H,s=p?Q:M*(1-e)+v*e,r=p?Y:Math.sin(s),i=p?Z:Math.cos(s),a=p?C(e):X,l=p?Math.sin(a):$,c=p?Math.cos(a):_,u=x+te(t,o,n);de=i*c*u,me=r*c*u,fe=l*u}for(let e=1;e<h-1;e+=oe){let t=0,o=0,l=0;{const n=(e+1)*ae,s=p?G:E*(1-n)+V*n,r=p?z:s,i=p?b*(1-n)+B*n:H,a=p?Q:M*(1-n)+v*n,c=p?Y:Math.sin(a),u=p?Z:Math.cos(a),d=p?C(n):X,m=p?Math.sin(d):$,f=p?Math.cos(d):_,g=x+te(s,i,r);t=u*f*g,o=c*f*g,l=m*g}const c=t,u=o,m=l,f=de,h=me,S=fe;de=c,me=u,fe=m;{const t=le+e,o=t*F,s=f-P,r=h-T,i=S-O;N[o]=s,N[o+1]=r,N[o+2]=i,q(s,r,i,U);const a=e*ae,l=p?J:a,c=p?a:K;R.setValues(t,Math.round(l*n.maxUint16),Math.round(c*n.maxUint16))}const w=re,W=ce,oe=ue;re=f,ce=h,ue=S;const pe=f,ge=h,he=S,xe=1/Math.sqrt(pe*pe+ge*ge+he*he),Me=he*xe;let ve=0,ye=0,Se=0;if(ie&&Me*Me<.999){let t=0,n=0,o=0;{const e=0===d?-1:1;t=e*(c-w),n=e*(u-W),o=e*(m-oe)}{const s=e*ae,l=p?G:E*(1-s)+V*s,c=p?z:l,u=p?b*(1-s)+B*s:H,m=p?Q:M*(1-s)+v*s,f=p?Y:Math.sin(m),h=p?Z:Math.cos(m),S=p?C(s):X,U=p?Math.sin(S):$,P=p?Math.cos(S):_;let T=pe,O=ge,R=he;if(D){const e=c-i,t=u-a,n=x+r.sampleElevation(e,t,ee),o=p?P:se;T=(p?L:h)*o*n,O=(p?I:f)*o*n,R=(p?U:ne)*n}{const e=l+i,s=u+a,c=x+r.sampleElevation(e,s,A),m=p?P:k,M=(p?y:h)*m*c,v=(p?g:f)*m*c,S=(p?U:j)*c;D||(T=2*pe-M,O=2*ge-v,R=2*he-S);const E=3===d?-1:1,V=E*(T-M),b=E*(O-v),I=E*(R-S);ve=o*b-n*I,ye=t*I-o*V,Se=n*V-t*b;const B=1/Math.sqrt(ve*ve+ye*ye+Se*Se);ve*=B,ye*=B,Se*=B}}}else ve=pe*xe,ye=ge*xe,Se=he*xe;s.setEdgeNormalFromValues(d,e,ve,ye,Se)}})()}}function p(e){B(e)}function g(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function h(e){const{tile:t}=e;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius,o=t=>function(e,t,n,o){return g(e*(1-o)+t*o,n)}(e[1],e[3],n,t);return o}const n=t.extentInRadians;return e=>function(e,t,n){return e*(1-n)+t*n}(n[1],n[3],e)}function x(e,t){e.tile.intersectsClippingArea&&(v(e),M(e,!1))}function M(e,n){const{geometry:o,geometryState:s,localOrigin:i}=e,c=e.tile,{surface:d,extent:m}=c,{clippingArea:f,samplerData:p}=s,g=null!=f?f:D,h=m[0],x=m[2],M=m[1],v=m[3],S=[v>g[3],x>g[2],M<g[1],h<g[0]],A=c.horizontalScale,E=y(d.isWebMercatorOnPlateCarree,c.ellipsoid.radius,A),{minu:V,minv:b,maxu:B,maxv:C,boundingBox:U}=o,L=Math.max(h,g[0]),P=Math.min(x,g[2]),T=Math.max(M,g[1]),O=Math.min(v,g[3]),R=i[0],N=i[1],F=i[2];for(let i=0;i<4;++i){const m=1===i||3===i,f=s.edgeResolutions[i];l.internalAssert(t.isPowerOfTwo(f));const g=f+1,y=S[i],D=a.neighborTileIfLoadedOrSelf(c,s.edgePeerNeighbors[i]);if(!y&&w(c,D,i)){I(e,i,D);continue}const j=null!=D&&!y,k=D?.renderData,G=k?.geometryState;if(l.enableTerrainInternalChecks&&(l.internalAssert(!j||D.level===c.level),l.internalAssert(!j||u.compareTilesByLij(c,D)<=0),c&&!D&&!d.updatingRootTiles)){const e=l.neighborEdgeIndices[i],t=c.findNeighborTile(e,e=>e.loaded||e.leaf||e.level===c.level);d.updatingRootTiles||(t?t.intersectsClippingArea&&(l.internalAssert(!t.loaded),l.internalAssert(!t.leaf),l.internalAssert(t.level===c.level)):l.internalAssert(null==d?.rootTiles||!c.shouldHaveNeighbor(e)))}const W=t.clamp(1===i?x:h,L,P),z=t.clamp(0===i?v:M,T,O),H=G?.samplerData,J=n&&g>3?g-3:1,K=t.clamp(1===i?1:0,V,B),Q=t.clamp(0===i?1:0,b,C),X=j?(e,t)=>.5*(r.sampleElevation(e,t,H)+r.sampleElevation(e,t,p)):(e,t)=>r.sampleElevation(e,t,p),Y=(x-h)/f,Z=m?1===i?Y:-Y:0,$=m?0:0===i?Y:-Y,_=-Z,ee=-$;let te=0,ne=0,oe=0;{const e=0/f,n=m?W:t.clamp(h*(1-e)+x*e,L,P),o=m?t.clamp(M*(1-e)+v*e,T,O):z,s=X(n,o);te=n*A,ne=E(o),oe=s}let se=0,re=0,ie=0;{const e=1/f,n=m?W:t.clamp(h*(1-e)+x*e,L,P),o=m?t.clamp(M*(1-e)+v*e,T,O):z,s=X(n,o);se=n*A,re=E(o),ie=s}for(let e=1;e<g-1;e+=J){const n=e/f,s=se,a=re,l=ie;{const r=m?K:t.clamp(n,V,B),c=m?t.clamp(n,b,C):Q,u=s-R,d=a-N,f=l-F;q(s,d,f,U),o.setEdgeVertexFromValuesRawPositionUV(i,e,u,d,f,r,c)}{const n=(e+1)/f,o=m?W:t.clamp(h*(1-n)+x*n,L,P),s=m?t.clamp(M*(1-n)+v*n,T,O):z,r=X(o,s);se=o*A,re=E(s),ie=r}const c=se,u=ie,d=te,g=ne,y=oe;te=s,ne=a,oe=l;let S=0,I=0,D=0;if(m){const e=re-a,o=u-l,c=g-a,d=y-l,m=t.clamp(M*(1-n)+v*n,T,O),f=W+_,h=m,x=f*A-s,E=r.sampleElevation(f,h,p)-l,V=3===i?-1:1;if(S=V*(-c+e)*E,I=V*x*(-d+o),D=-V*x*(-c+e),j){const t=W+Z,n=m,i=t*A-s;S=(-c+e)*(E-(r.sampleElevation(t,n,H)-l)),I=(x-i)*(-d+o),D=-(x-i)*(-c+e)}}else{const e=c-s,o=u-l,m=d-s,f=y-l,g=t.clamp(h*(1-n)+x*n,L,P),M=g,v=z+ee,A=r.sampleElevation(M,v,p)-l,V=E(v)-a,b=2===i?-1:1;if(S=b*V*(-f+o),I=b*(-m+e)*A,D=-b*V*(-m+e),j){const t=g,n=z+$,s=E(n)-a;S=(-V+s)*(-f+o),I=(-m+e)*(-A+(r.sampleElevation(t,n,H)-l)),D=-(-V+s)*(-m+e)}}const w=1/Math.sqrt(S*S+I*I+D*D);o.setEdgeNormalFromValues(i,e,S*w,I*w,D*w)}}}function v(e,t){B(e)}function y(e,t,n){return e?e=>function(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}(e,t):e=>function(e,t){return e*t}(e,n)}function S(e,t,n){const{numVerticesPerSide:o,vertexAttributes:s,maxEdgeVertexCount:r}=e,i=o-1,l=s.count,c=2*(o-3)*(o-3),u=4*(i+r-3),d=a.zeroToFour.reduce((t,n)=>t+(i+e.getEdgeCount(n)-3),0),m=t.reduce((e,t)=>e+i*(2*(t.latitudeResolution-1)+1),0),f=3*(n?2:1),p=(c+u+m)*f,g=l>=65536?new Uint32Array(p):new Uint16Array(p);for(let e=0;e<p;++e)g[e]=0;e.indices=g,e.indexCount=(c+d+m)*f,e.poleIndicesStartIndex=c*f,e.edgeIndicesStartIndex=(c+m)*f,n?(function(e){const{indices:t,numVerticesPerSide:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=n-2;let l=0;for(let e=0;e<n-3;++e){const o=e*a;for(let s=0;s<n-3;++s){const n=e*a+s,c=n+1,u=c+a,d=u-1,m=o+s,f=m+1,p=f+a;k(m,f,p,p-1,i,r)?(G(t,l,n,c,u),l+=6,G(t,l,u,d,n)):(G(t,l,n,c,d),l+=6,G(t,l,d,u,c)),l+=6}}}(e),function(e,t){const{indices:n,numVerticesPerSide:o,poleIndicesStartIndex:s}=e,r=o-1;let i=s;for(const s of t){const t=s.connectedOuterEdgeOffset;let a=e.getEdgeVertexIndex(t,0),l=1;for(let e=0;e<s.latitudeResolution;++e){const t=0===e?s.rowOffset:a+o;for(let o=0;o<r;o++)G(n,i,a,a+1,t+o),i+=6,e<s.latitudeResolution-1&&(G(n,i,a+1,t+o+1,t+o),i+=6),a+=l;a=t,l=1}}}(e,t),E(e)):(function(e){const{numVerticesPerSide:t,indices:n,vertexAttributes:o}=e,{position:s}=o,{typedBuffer:r,typedBufferStride:i}=s,a=t-2,l=t-3,c=t-3;let u=0;for(let e=0;e<l;++e){const t=e*a;for(let e=0;e<c;++e){const o=t+e,s=o+1,l=s+a,c=l-1;k(o,s,l,c,i,r)?(n[u]=o,n[u+1]=s,n[u+2]=l,n[u+3]=l,n[u+4]=c,n[u+5]=o):(n[u]=o,n[u+1]=s,n[u+2]=c,n[u+3]=c,n[u+4]=s,n[u+5]=l),u+=6}}}(e),function(e,t){const{numVerticesPerSide:n,indices:o,poleIndicesStartIndex:s}=e,r=n-1;let i=s;for(const s of t){const t=s.isNorth?1:2,a=s.isNorth?2:1,l=s.isNorth?3:4,c=s.isNorth?4:3;let u=e.getEdgeVertexIndex(s.connectedOuterEdgeOffset,0),d=1;for(let e=0;e<s.latitudeResolution;++e){const m=0===e?s.rowOffset:u+n;for(let n=0;n<r;n++){const r=m+n;o[i]=u,o[i+t]=u+1,o[i+a]=r,e<s.latitudeResolution-1?(o[i+l]=u+1,o[i+c]=r+1,o[i+5]=r,i+=6):i+=3,u+=d}u=m,d=1}}}(e,t),A(e))}function A(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let n=0;n<4;++n){const o=F[n];let a=0,c=0;const u=e.getEdgeCount(n),d=o.count;l.internalAssert(d===s-1);const m=1===n||2===n,f=m?1:2,p=m?2:1,g=e.getEdgeFirstVertexIndex(n),h=1,x=o.vertex0Index,M=o.stride;for(;a<u-1||c<d-1;){const e=x+c*M,n=g+a*h,o=a<u-1,l=c<d-1,m=o&&(!l||(o?0+s*(a+.5)/(u-1):0)<=(l?1+r*(c+.5)/(d-1):0));m?++a:++c;const v=m?n+h:e+M;t[i]=e,t[i+f]=n,t[i+p]=v,i+=3}}e.indexCount=i}function E(e){const{indices:t,numVerticesPerSide:n,edgeIndicesStartIndex:o}=e,s=n-1,r=s-2;let i=o;for(let n=0;n<4;++n){const o=F[n];let a=0,c=0;const u=e.getEdgeCount(n),d=o.count;l.internalAssert(d===s-1);const m=1===n||2===n,f=m?1:3,p=m?3:1,g=e.getEdgeFirstVertexIndex(n),h=1,x=o.vertex0Index,M=o.stride;for(;a<u-1||c<d-1;){const e=x+c*M,n=g+a*h,o=a<u-1,l=c<d-1,m=o&&(!l||(o?0+s*(a+.5)/(u-1):0)<=(l?1+r*(c+.5)/(d-1):0));m?++a:++c;const v=m?n+h:e+M;t[i]=e,t[i+f]=n,t[i+f+1]=n,t[i+p]=v,t[i+p+1]=v,t[i+5]=e,i+=6}}e.indexCount=i}function V(e){const{geometry:t,geometryState:n}=e,{edgeResolutions:o}=n,{numVerticesPerSide:s,edgeVerticesStartIndex:r}=t,i=s-2;let a=r;for(let e=0;e<4;++e){{const t=0===e||2===e,n=(0===e?i-1:0)*i+(1===e?i-1:0),o=(t?0:1)*i+(t?1:0),s=F[e];s.vertex0Index=n,s.stride=o,s.count=i}{const n=o[e]+1;t.outerEdgesOffsetAndLength[2*e+0]=a,t.outerEdgesOffsetAndLength[2*e+1]=n,a+=n}}}function b(e){V(e),e.geometryState.wireframe?E(e.geometry):A(e.geometry)}function I(e,o,s){const{geometryState:r,geometry:i,tile:a,localOrigin:c}=e,u=1===o||3===o,d=r.edgeResolutions[o];l.internalAssert(t.isPowerOfTwo(d));const m=d+1,{boundingBox:f,minu:p,minv:g,maxu:h,maxv:x,vertexAttributes:M}=i,v=t.clamp(1===o?1:0,p,h),y=t.clamp(0===o?1:0,g,x),S=s.renderData,A=S.geometryState,E=S.geometry,V=(o+2)%4,b=E.getEdgeCount(V),I=a.getNeighborEdgeStartVertexIndex(o,s)*d,B=d*2**(a.level-s.level);l.internalAssert(A.edgeResolutions[V]===B),l.internalAssert(b-1===B);const C=S.localOrigin[0]-c[0],U=S.localOrigin[1]-c[1],L=S.localOrigin[2]-c[2],P=i.getEdgeFirstVertexIndex(o),{position:T,uv0:O}=M,D=T.typedBuffer,R=T.typedBufferStride,w=M.normalCompressed,N=w.typedBuffer,F=w.typedBufferStride,j=E.vertexAttributes,k=E.getEdgeFirstVertexIndex(V),G=j.position.typedBuffer,W=j.position.typedBufferStride,z=j.normalCompressed.typedBuffer,H=j.normalCompressed.typedBufferStride;for(let e=1;e<m-1;++e){const o=P+e,s=k+(I+e),r=o*R,i=s*W,a=G[i]+C,l=G[i+1]+U,c=G[i+2]+L;D[r]=a,D[r+1]=l,D[r+2]=c,q(a,l,c,f);const m=o*F,M=s*H;N[m]=z[M],N[m+1]=z[M+1];const S=e/d,A=u?v:t.clamp(S,p,h),E=u?t.clamp(S,g,x):y;O.setValues(o,Math.round(A*n.maxUint16),Math.round(E*n.maxUint16))}}function B(e){const{geometry:o,geometryState:s,localOrigin:i}=e,{clippingArea:a,samplerData:c}=s,{minu:d,minv:m,maxu:f,maxv:p,boundingBox:g,vertexAttributes:x}=o,M=e.tile,{surface:v,ellipsoid:S,extent:A,extentInRadians:E,horizontalScale:V}=M,b="local"===v.view?.viewingMode,I=S.radius;let B=0,U=0,L=0;const P=b?(()=>{const e=a,n=null!=e&&(A[3]>e[3]||A[2]>e[2]||A[1]<e[1]||A[0]<e[0]),o=y(v.isWebMercatorOnPlateCarree,I,V);return(s,r,i)=>{const a=0===s?A[0]:A[2],l=0===r?A[1]:A[3],c=n?t.clamp(a,e[0],e[2]):a,u=n?t.clamp(l,e[1],e[3]):l,d=i;B=c*V,U=o(u),L=d}})():(e,t,n)=>{const o=E[0===t?1:3],s=E[0===e?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),l=Math.cos(s),c=I+n;B=l*r*c,U=a*r*c,L=i*c};let O=0,w=0,N=0,F=0,j=0,k=0,G=0,W=0,z=0;const H=b&&v.isWebMercatorOnPlateCarree,J=(e,t,n,o,s)=>{let r=0,i=0,a=0;if(b){const e=t*V,s=H?(Math.PI/2-2*Math.atan(Math.exp(-n/I)))*I:n*V;r=e-B,i=s-U,a=o-L}else{const s=h(e),l=e.tile,c=l.extent,u=l.extentInRadians,d=(t-c[0])/(c[2]-c[0]),m=(n-c[1])/(c[3]-c[1]),f=u[0]*(1-d)+u[2]*d,p=s(m),g=Math.cos(p),x=Math.sin(p),M=Math.sin(f),v=Math.cos(f),y=I+o;r=v*g*y-B,i=M*g*y-U,a=x*y-L}switch(s){case 0:G+=r,W+=i,z+=a;break;case 1:F-=r,j-=i,k-=a;break;case 2:G-=r,W-=i,z-=a;break;case 3:F+=r,j+=i,k+=a}},K=a??D,Q=A[0],X=A[2],Y=A[1],Z=A[3],$=[Z>K[3],X>K[2],Y<K[1],Q<K[0]],_=Math.max(Q,K[0]),ee=Math.min(X,K[2]),te=Math.max(Y,K[1]),ne=Math.min(Z,K[3]),oe=e=>Math.max(K[0],Math.min(K[2],e)),se=e=>Math.max(K[1],Math.min(K[3],e)),re=e=>{const t=s.cornerNeighborCornerTiles;O=0,w=0,N=1,F=0,j=0,k=0,G=0,W=0,z=0;let n=1/0;for(let o=0;o<4;++o){const s=t[4*e+o];n=Math.min(n,s?.level??1/0)}for(let o=0;o<4;++o){const s=t[4*e+o];R[o]=s?.level===n?s:null}let o=1,i=0;for(let e=0;e<4;++e){const t=R[e];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),i=t.extent[2]-t.extent[0])}const a=i,c=o;l.internalAssert(c>1);const u=a/c;for(let e=0;e<4;++e){const t=R[(e+3)%4],n=R[e%4];if(!t&&!n)continue;const o=0===e?1:1===e?2:2===e?3:0,s=0===e?2:1===e?3:2===e?0:1;if(t&&n){const i=T[e][0]*u,a=T[e][1]*u,l=t.extent,c=oe(l[0===o||1===o?2:0]+i),d=se(l[0===o||3===o?3:1]+a),m=n.extent,f=oe(m[0===s||1===s?2:0]+i),p=se(m[0===s||3===s?3:1]+a),g=t.renderData,h=n.renderData,x=r.sampleElevation(c,d,g.geometryState.samplerData),M=r.sampleElevation(f,p,h.geometryState.samplerData);J(g,c,d,.5*(x+M),e)}else{const i=t??n,a=t?o:s,l=i.extent,c=T[e],d=oe(l[0===a||1===a?2:0]+c[0]*u),m=se(l[0===a||3===a?3:1]+c[1]*u),f=i.renderData,p=r.sampleElevation(d,m,f.geometryState.samplerData);J(f,d,m,p,e)}}if(!b){const e=Math.sqrt(B*B+U*U+L*L);O=B/e,w=U/e,N=L/e}if(b||N*N<.999){const e=Math.sqrt(F*F+j*j+k*k);F/=e,j/=e,k/=e;const t=Math.sqrt(G*G+W*W+z*z);G/=t,W/=t,z/=t,O=k*W-j*z,w=F*z-k*G,N=j*G-F*W;const n=1/Math.sqrt(O*O+w*w+N*N);O*=n,w*=n,N*=n}},ie=s.cornerNeighborCornerTiles;for(let e=0;e<4;++e){const a=e,h=(e+1)%4,v=0===e||1===e?1:0,y=0===e||3===e?1:0,S=t.clamp(v,d,f),A=t.clamp(y,m,p),E=o.getEdgeFirstVertexIndex(a),V=o.getEdgeCount(a),b=0===e||3===e?V-1:0,I=o.getEdgeFirstVertexIndex(h),T=o.getEdgeCount(h),D=0===e||1===e?T-1:0;let R=-1;for(let t=0;t<4;++t){const n=ie[4*e+t],o=ie[4*e+R];n&&(-1===R||u.compareTilesByLij(o,n)>0)&&(R=t)}const F=R,j=ie[4*e+F];if(j!==M){const t=M.level-j.level,o=2**t,r=[j.lij[0]+t,j.lij[1]*o,j.lij[2]*o],a=[r[1]+o===M.lij[1],0===e&&(1===F||0===F&&j!==ie[4*e+3])||1===e&&(0===F||1===F&&j!==ie[4*e+2]),r[1]===M.lij[1]+1,2===e&&(3===F||2===F&&j!==ie[4*e+1])||3===e&&(2===F||3===F&&j!==ie[4*e+0])],c=a.reduce((e,t)=>e+(t?1:0),0);l.internalAssert(1===c||2===c);let u=-1,d=-1;const m=j.renderData;if(1===c){const t=a.findIndex(e=>e);l.internalAssert(0<=t&&t<=3),u=(t+2)%4;const n=s.edgeResolutions[t];d=M.getNeighborEdgeStartVertexIndex(t,j)*n+n*(0===t&&0===e||1===t&&0===e||2===t&&1===e||3===t&&3===e?1:0)}else{l.internalAssert(a[1]||a[3]),u=a[1]?3:1;const t=m.geometryState.edgeResolutions[u];d=0===e||3===e?0:t}const f=m.geometry;{const e=E+b,t=I+D,o=f.getEdgeFirstVertexIndex(u)+d,s=f.vertexAttributes,r=m.localOrigin,a=s.position,l=a.typedBuffer,c=o*a.typedBufferStride,p=l[c]+r[0]-i[0],h=l[c+1]+r[1]-i[1],M=l[c+2]+r[2]-i[2];q(p,h,M,g);const v=x.position,y=v.typedBuffer,V=e*v.typedBufferStride;y[V]=p,y[V+1]=h,y[V+2]=M;const B=t*v.typedBufferStride;y[B]=p,y[B+1]=h,y[B+2]=M;const C=x.uv0;C.setValues(e,Math.round(S*n.maxUint16),Math.round(A*n.maxUint16)),C.setValues(t,Math.round(S*n.maxUint16),Math.round(A*n.maxUint16));{const n=s.normalCompressed.typedBuffer,r=o*s.normalCompressed.typedBufferStride,i=x.normalCompressed,a=i.typedBuffer;{const t=e*i.typedBufferStride;a[t]=n[r],a[t+1]=n[r+1]}{const e=t*i.typedBufferStride;a[e]=n[r],a[e+1]=n[r+1]}}}}else{let n;if($[a]||$[h]){const e=t.clamp(Q*(1-v)+X*v,_,ee),o=t.clamp(Y*(1-y)+Z*y,te,ne);n=r.sampleElevation(e,o,c)}else n=C(ie,e);P(v,y,n),re(e);const s=B-i[0],l=U-i[1],u=L-i[2];q(s,l,u,g),o.setEdgeVertexFromValuesRawPositionUVNormal(a,b,s,l,u,S,A,O,w,N),o.setEdgeVertexFromValuesRawPositionUVNormal(h,D,s,l,u,S,A,O,w,N)}}for(let e=0;e<4;++e)R[e]=null}function C(e,t){const n=4*t,o=a.zeroToFour.reduce((t,o)=>Math.min(t,e[n+o]?.level??1/0),1/0);l.enableTerrainInternalChecks&&(l.internalAssert(!e[n+0]||!e[n+2]||c.isCornerNeighbor(e[n+0],e[n+2],5)),l.internalAssert(!e[n+1]||!e[n+3]||c.isCornerNeighbor(e[n+1],e[n+3],7)));let s=0,i=0;for(let t=0;t<4;++t){const a=e[n+t];if(a&&a.level===o){const e=0===t||1===t,n=0===t||3===t,o=a.extent,l=o[e?0:2],c=o[n?1:3],u=a.renderData?.geometryState?.samplerData;i+=r.sampleElevation(l,c,u),s++}}const u=s?i/s:0;return l.internalAssert(null!=u),u}function U(e){const{vao:t,geometry:n}=e,{vertexAttributes:o,edgeVerticesStartIndex:s}=n,r=o.position.typedBuffer;t.buffer()?.setSubData(r,s,s,r.length)}function L(e){const{vao:t,geometry:n}=e,{indices:o,indexCount:s,edgeIndicesStartIndex:r}=n;t.indexBuffer.setSubData(o,r,r,s)}class P{constructor(e,t,n,o,s){this.isNorth=e,this.connectedRowOffset=t,this.connectedOuterEdgeOffset=n,this.rowOffset=o,this.latitudeResolution=s}}const T=[[0,1],[1,0],[0,-1],[-1,0]],O=new i.PatchGeometryLUT,D=s.fromValues(-1/0,-1/0,1/0,1/0),R=[null,null,null,null];function w(e,t,n){if(!t)return!1;const o=u.compareTilesByLij(e,t);return o>0||0===o&&n>=2}class N{constructor(){this.vertex0Index=0,this.stride=1,this.count=0}getVertexIndex(e){return l.internalAssert(0<=e&&e<this.count),this.vertex0Index+this.stride*e}}const F=[new N,new N,new N,new N];function q(e,t,n,o){e<o[0]?o[0]=e:e>o[3]&&(o[3]=e),t<o[1]?o[1]=t:t>o[4]&&(o[4]=t),n<o[2]?o[2]=n:n>o[5]&&(o[5]=n)}function j(e){const{edgeResolutions:t,numVerticesPerSide:n}=e,o=1+Math.max(...t);return Math.max(n,o)}function k(e,t,n,o,s,r){const i=e*s,a=r[i],l=r[i+1],c=r[i+2],u=t*s,d=r[u],m=r[u+1],f=r[u+2],p=n*s,g=r[p],h=r[p+1],x=r[p+2],M=o*s,v=r[M],y=r[M+1],S=r[M+2];return(d-v)*(d-v)+(m-y)*(m-y)+(f-S)*(f-S)>(a-g)*(a-g)+(l-h)*(l-h)+(c-x)*(c-x)}function G(e,t,n,o,s){e[t]=n,e[t+1]=o,e[t+2]=o,e[t+3]=s,e[t+4]=s,e[t+5]=n}e.createPlanarGlobePatch=function(e,s){const{tile:i,geometryState:a,geometry:l}=e,{extent:c,surface:u}=i,{wireframe:m}=a,f=c[0],p=c[1],g=c[2]-f,h=c[3]-p,{numVerticesPerSide:M,clippingArea:v}=a,y=null!=v?Math.max(0,(v[0]-f)/g):0,A=null!=v?Math.max(0,(v[1]-p)/h):0,E=null!=v?Math.min(1,(v[2]-f)/g):1,b=null!=v?Math.min(1,(v[3]-p)/h):1,I=(M-2)**2,B=j(a),C=I+4*B,U=u.renderer.tileGeometryCache.acquire(C),{boundingBox:L}=l;o.empty(L),l.numVerticesPerSide=M,l.vertexAttributes=U,l.maxEdgeVertexCount=B,l.minu=y,l.minv=A,l.maxu=E,l.maxv=b,function(e){const o=e.tile;if(!o.intersectsClippingArea)return;const{geometry:s,geometryState:i,localOrigin:a}=e,{samplerData:l,clippingArea:c,numVerticesPerSide:u}=i,{surface:m,extent:f,ellipsoid:p}=o,{isWebMercatorOnPlateCarree:g}=m,h=null!=c?c:D,x=f[0],M=f[1],v=f[2],y=f[3],S=Math.max(x,h[0]),A=Math.min(v,h[2]),E=Math.max(M,h[1]),V=Math.min(y,h[3]),b=p.radius,I=o.horizontalScale,B=u-1,C=u-2,{minu:U,minv:L,maxu:P,maxv:T,boundingBox:O,vertexAttributes:R}=s,{position:w,uv0:N}=R,{typedBuffer:F,typedBufferStride:j}=R.normalCompressed,k=a[0],G=a[1],W=a[2],z=w.typedBuffer,H=w.typedBufferStride;let J=0;const K=t.clamp(M,E,V),Q=g?(Math.PI/2-2*Math.atan(Math.exp(-K/b)))*b:K*I,X=1/B,Y=t.clamp(M*(1-X)+y*X,E,V);let Z=Q,$=g?(Math.PI/2-2*Math.atan(Math.exp(-Y/b)))*b:Y*I;for(let e=1;e<=C;e++){const o=e/B,s=t.clamp(M*(1-o)+y*o,E,V),i=t.clamp(o,L,T),a=$,c=(e-1)/B,u=t.clamp(M*(1-c)+y*c,E,V),m=Z,f=(e+1)/B,p=t.clamp(M*(1-f)+y*f,E,V),h=g?(Math.PI/2-2*Math.atan(Math.exp(-p/b)))*b:p*I,D=t.clamp(f,L,T);Z=$,$=h;const R=t.clamp(x,S,A);let w=R*I,K=r.sampleElevation(R,s,l);const Q=1/B,X=t.clamp(Q,U,P),Y=t.clamp(x*(1-X)+v*X,S,A);let _=X,ee=Y,te=Y*I,ne=r.sampleElevation(Y,s,l);if(1===e){const e=te-k,o=Z-G,s=ne-W,r=0*H;z[r]=e,z[r+1]=o,z[r+2]=s,q(e,o,s,O);const a=t.clamp(Q,U,P);N.setValues(J,Math.round(a*n.maxUint16),Math.round(i*n.maxUint16))}for(let o=1;o<=C;o++){const c=te,f=ne,g=(o+1)/B,M=t.clamp(g,U,P),y=t.clamp(x*(1-g)+v*g,S,A),E=ee;ee=y;{const t=J+1,c=t*H;if(1===e||o===C){const u=y*I,d=r.sampleElevation(y,s,l);if(1===e&&o<C){const e=u-k,o=a-G,s=d-W;z[c]=e,z[c+1]=o,z[c+2]=s,q(e,o,s,O),N.setValues(t,Math.round(M*n.maxUint16),Math.round(i*n.maxUint16))}te=u,ne=d}else te=z[c]+k,ne=z[c+2]+W}const V=te,b=ne,L=w,T=K;w=c,K=f;const R=(J-C)*H,Q=1===e?r.sampleElevation(E,u,l):z[R+2]+W,X=r.sampleElevation(E,p,l);if(e<C){const e=J+C,t=e*H,o=c-k,s=h-G,r=X-W;z[t]=o,z[t+1]=s,z[t+2]=r,q(o,s,r,O);const i=_;_=M,N.setValues(e,Math.round(i*n.maxUint16),Math.round(D*n.maxUint16))}{const e=V-L,t=m-h,n=t*(b-T),o=e*(Q-X),s=-t*e,r=n*n+o*o+s*s;if(0===r)d.compressNormal(F,J,0,0,1,j);else{const e=1/Math.sqrt(r);d.compressNormal(F,J,n*e,o*e,s*e,j)}}++J}}}(e),l.edgeVerticesStartIndex=I,V(e),x(e),S(l,[],m),e.intersectionData=null},e.createSphericalGlobePatch=function(e,t){const{tile:s,geometry:i,geometryState:a}=e,{extentInRadians:l,surface:c}=s,{isWebMercator:u,renderer:f}=c,{numVerticesPerSide:p,wireframe:x}=a,M=p-1,v=(p-2)**2,y=u&&(2===t||3===t),A=u&&(1===t||3===t),E=6*((y?1:0)+(A?1:0))*p,b=j(a),I=v+E+4*b,B=f.tileGeometryCache.acquire(I);i.numVerticesPerSide=p,i.vertexAttributes=B,i.maxEdgeVertexCount=b;const{boundingBox:C}=i;o.empty(C);const U=h(e);O.update(M,l,U),function(e){const{tile:t}=e;if(!t.intersectsClippingArea)return;const{geometry:o,geometryState:s,localOrigin:i}=e,{numVerticesPerSide:a,samplerData:l}=s,c=a-2,u=a-1,{vertexAttributes:m,boundingBox:f}=o,{position:p,uv0:g}=m,{typedBuffer:h,typedBufferStride:x}=m.normalCompressed,{extent:M}=t,v=M[0],y=M[2],S=M[1],A=M[3],E=t.ellipsoid.radius,V=i[0],b=i[1],I=i[2],B=p.typedBuffer,C=p.typedBufferStride,U=1/u;let L=0;if(1<=c){const e=U,t=S*(1-e)+A*e,o=O.sinLatLUT[1],s=O.cosLatLUT[1];for(let i=1;i<=c;i++){const a=i*U,c=v*(1-a)+y*a,u=O.sinLonLUT[i],d=O.cosLonLUT[i],m=E+r.sampleElevation(c,t,l),p=m*d*s-V,h=m*u*s-b,x=m*o-I;q(p,h,x,f);const M=(i-1)*C;B[M]=p,B[M+1]=h,B[M+2]=x,g.setValues(i-1,Math.round(a*n.maxUint16),Math.round(e*n.maxUint16))}}for(let e=1;e<=c;e++){const t=e*U,o=S*(1-t)+A*t,s=O.sinLatLUT[e],i=O.cosLatLUT[e],a=e+1,m=a*U,p=S*(1-m)+A*m,M=O.sinLatLUT[a],P=O.cosLatLUT[a],T=O.sinLonLUT[0],D=O.cosLonLUT[0],R=E+r.sampleElevation(v,o,l);let w=D*i*R-V,N=T*i*R-b,F=s*R-I;const j=L*C;let k=B[j],G=B[j+1],W=B[j+2];for(let t=1;t<=c;t++){const a=t*U,A=v*(1-a)+y*a,T=O.sinLonLUT[t],D=O.cosLonLUT[t];let R=0,j=0,z=0;if(t<c){const e=(L+1)*C;R=B[e],j=B[e+1],z=B[e+2]}else{const e=O.sinLonLUT[u],t=O.cosLonLUT[u],n=E+r.sampleElevation(y,o,l);R=t*i*n-V,j=e*i*n-b,z=s*n-I}const H=w,J=N,K=F;w=k,N=G,F=W,k=R,G=j,W=z;const Q=R-H,X=j-J,Y=z-K;let Z=0,$=0,_=0;if(e>1){const e=(L-c)*C;Z=B[e],$=B[e+1],_=B[e+2]}else{const e=O.sinLatLUT[0],t=O.cosLatLUT[0],n=E+r.sampleElevation(A,S,l);Z=D*t*n-V,$=T*t*n-b,_=e*n-I}const ee=E+r.sampleElevation(A,p,l),te=D*P*ee-V,ne=T*P*ee-b,oe=M*ee-I;if(e<c){const e=L+c,t=e*C;B[t]=te,B[t+1]=ne,B[t+2]=oe,q(te,ne,oe,f),g.setValues(e,Math.round(a*n.maxUint16),Math.round(m*n.maxUint16))}const se=Z-te,re=$-ne,ie=_-oe;let ae=D*i,le=T*i,ce=s;ce*ce<.999&&(ae=Y*re-X*ie,le=Q*ie-Y*se,ce=X*se-Q*re);const ue=1/Math.sqrt(ae*ae+le*le+ce*ce);d.compressNormal(h,L,ae*ue,le*ue,ce*ue,x),++L}}}(e),i.poleVerticesStartIndex=v;const L=function(e,t,o){const{tile:s,localOrigin:r,geometry:i}=e,{extent:a,ellipsoid:l}=s,{boundingBox:c,numVerticesPerSide:u,vertexAttributes:m,poleVerticesStartIndex:f}=i,p=u-1,h=r[0],x=r[1],M=r[2],v=l.radius,y=a[1],S=a[3],A=[];let E=f;const V=(e,t)=>{const o=t*u;q(-h,-x,e*v-M,c),A.push(new P(1===e,o,1===e?0:2,E,6));const s=g(-1===e?y:S,v),r=e*Math.PI/2-s,i=.99*(1===e?1:-1),a=v+0,{position:l,uv0:f}=m,{typedBuffer:V,typedBufferStride:b}=m.normalCompressed;for(let e=1;e<=6;++e){const t=s+r*(e/6),o=Math.cos(t),u=Math.sin(t);for(let e=0;e<=p;e++){const t=e/p,s=O.sinLonLUT[e],r=O.cosLonLUT[e]*o,m=s*o,g=u,v=r*a-h,y=m*a-x,S=g*a-M;q(v,y,S,c),l.setValues(E,v,y,S),f.setValues(E,Math.round(t*n.maxUint16),Math.round(i*n.maxUint16)),d.compressNormal(V,E,r,m,g,b),++E}}};return t&&V(-1,0),o&&V(1,p),A}(e,y,A);i.edgeVerticesStartIndex=v+E,V(e),m(e),S(i,L,x),e.intersectionData=null},e.updateCornerSpherical=function(e){e.tile.intersectsClippingArea&&(p(e),f(e,!0),U(e),e.intersectionData=null)},e.updateCornersPlanar=function(e,t){e.tile.intersectsClippingArea&&(v(e),M(e,!0),U(e),e.intersectionData=null)},e.updateEdgeElevationsAndResolutionsPlanar=function(e,t){e.tile.intersectsClippingArea&&(b(e),x(e),U(e),L(e),e.intersectionData=null)},e.updateEdgeElevationsAndResolutionsSpherical=function(e){e.tile.intersectsClippingArea&&(b(e),m(e),U(e),L(e),e.intersectionData=null)},e.updateEdgesAndCornersPlanar=function(e,t){e.tile.intersectsClippingArea&&(x(e),U(e),e.intersectionData=null)},e.updateEdgesAndCornersSpherical=function(e){e.tile.intersectsClippingArea&&(m(e),U(e),e.intersectionData=null)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});