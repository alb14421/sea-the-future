// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../Camera","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Cyclical","../../../core/Error","../../../core/promiseUtils","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/factories/mat3f64","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/Extent","../../../geometry/Geometry","../../../geometry/Multipoint","../../../geometry/Point","../../../geometry/projectionUtils","../../../geometry/SpatialReference","../../../geometry/projection/computeTranslationToOriginAndRotation","../../../geometry/projection/projectPointToVector","../../../geometry/projection/projectVectorToPoint","../../../geometry/projection/projectVectorToVector","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/scaleUtils","../webgl","../camera/intersectionUtils","./cameraUtils","./ElevationProvider","./viewingModeUtils"],function(e,t,n,a,o,r,i,c,s,l,u,m,f,g,p,y,h,d,w,x,v,R,b,T,S,z,A,C,j,G,V,P,Z){"use strict";function M(e){return 360-i.cyclicalDegrees.normalize(e)}function B(e){return i.cyclicalDegrees.normalize(360-e)}async function D(e,t,n,a){const o=t.camera;if(null!=o)return async function(e,t,n){const a=e.position,o=await w.projectWithZConversion(a,t,{signal:n});s.throwIfAborted(n);const r=e.clone();return r.position=o.clone(),r}(o,V.getViewSR(e),a);const{targetGeometry:r}=t;if(null==r)throw new Error("Viewpoint has no targetGeometry!");const{camera:i,mode:c}=W(e,t.rotation,n);if("point"===r.type)return async function(e,t,n,a,o,r){const i=e.spatialReference,c=await w.projectWithZConversion(n.clone(),i,{signal:r});s.throwIfAborted(r);const l=null!=t.scale?V.scaleToDistance(e,t.scale):e.state.camera.distance;return V.fromCenterDistanceAsync(e,c,l,a,o,r)}(e,t,r,i,c,a);const l=r.extent;if(null==l)throw new Error("Target geometry has no extent!");return V.fromExtentAsync(e,l,i.heading,i.tilt,c,a)}function W(e,t,n){const a=j.fromRenderCamera(e,e.state.camera);let o=1;return null!=t&&(a.heading=M(t),o=0),null!=n&&(a.tilt=n),{camera:a,mode:o}}function E(e,t){return null==t.scale&&null!=t.zoom?V.zoomToScale(e,t.zoom):t.scale}function F(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=M(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function O(e,t,n,a){const o=e.spatialReference||x.WGS84;if(t??=j.toRenderCamera(e,n),null==t)return a;const r=new d({spatialReference:o});return b.projectVectorToPoint(t.center,e.renderSpatialReference,r)?(a.targetGeometry=r,a.scale=V.distanceToScale(e,t.distance),a.rotation=B(n.heading),a.camera=n,a):a}async function I(e,t,n,a){const o=()=>new c("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw o();"mesh"===t.type&&(t=t.extent);const r=e.basemapTerrain.spatialReference;if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}null!=n&&r&&e.elevationProvider?(n=await w.projectWithZConversion(n,r,{signal:a}),q[2]=P.getElevationAtPoint(e.elevationProvider,n)??0):q[2]=0}const i=ne[t.type],s=new Array;if(i(t,t.hasZ?e=>{s.push([e[0],e[1],e[2]])}:e=>{s.push([e[0],e[1]])},q),0===s.length)throw o();const l=t.spatialReference,u=e.spatialReference,m=await w.projectWithZConversion(new h({spatialReference:l,hasZ:t.hasZ,hasM:!1,points:s}),u,{signal:a});if(t.hasZ&&(n.hasZ=!0),t.hasZ)for(const[e,t,a]of m.points)q[0]=e,q[1]=t,q[2]=a,S.expandWithVec3(n.boundingBox,q);else for(const[e,t]of m.points)q[0]=e,q[1]=t,S.expandWithVec3(n.boundingBox,q)}async function U(e,t,a,r,i){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return te.x=n,te.y=a,te.z=void 0,te.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:x.WGS84,void await I(e,te,r,i)}t&&"map"in t&&"function"==typeof t.map?await Promise.allSettled(t.map(t=>U(e,t,a,r,i))):t instanceof y?await I(e,t,r,i):t instanceof n&&await async function(e,t,n,a,r){const i=await o.result(e.whenViewForGraphic(t));if(!1===i.ok||null==i.value||!("whenGraphicBounds"in i.value))return void await I(e,t.geometry,a,r);const c=i.value,s=await o.result(c.whenGraphicBounds(t,{minDemResolution:n}));if(!1===s.ok||!s.value)return void await I(e,t.geometry,a,r);const{screenSpaceObjects:l,boundingBox:u}=s.value;S.expandWithAABB(a.boundingBox,u),l&&l.forEach(e=>{a.screenSpaceObjects.push(e)}),isFinite(u[2])&&(a.hasZ=!0)}(e,t,a,r,i)}async function k(e,t,n,a){const o=e.spatialReference,r=await w.projectWithZConversion(t.position,o,{signal:n}),i=t.clone();return i.position=r,O(e,null,i,a)}async function N(e,t,n,a,o,r){r.targetGeometry=n.clone();const i=G.cameraOnContentAlongViewDirection(e);if(t.position)return async function(e,t,n,a,o,r,i){const c=e.renderSpatialReference;return await R.projectPointToVectorAsync(t,$,c,0,{signal:i}),await R.projectPointToVectorAsync(n,Q,c,0,{signal:i}),r.targetGeometry=new d(t),o.position=new d(n),f.subtract(L,$,Q),Z.directionToHeadingTilt(e,Q,L,a.up,o),r.scale=V.distanceToScale(e,f.distance(Q,$)),r.rotation=B(o.heading),r.camera=o,r}(e,r.targetGeometry,t.position,i,a,r,o);if(t.zoomFactor){const n=i.distance/t.zoomFactor,a=f.scale(q,i.viewForward,-n);i.eye=f.add(q,i.center,a),r.scale=V.distanceToScale(e,n)}j.fromRenderCamera(e,i,a);const c=F(a,t)?0:1;if(!t.zoomFactor){const n=E(e,t);if(null==n){await R.projectPointToVectorAsync(r.targetGeometry,q,e.renderSpatialReference,0,{signal:o});const t=A.intersectsPoint(i.frustum,q)?f.distance(i.eye,q):i.distance;r.camera=await V.fromCenterDistanceAsync(e,r.targetGeometry,t,a,c),r.scale=V.distanceToScale(e,t)}else r.scale=n,r.camera=await V.fromCenterScale(e,r.targetGeometry,r.scale,a,c,o)}return r}function H(e){return null!=e?.camera&&(e.rotation=B(e.camera.heading)),e}class Y{constructor(){this.hasZ=!1,this.boundingBox=S.empty(),this.screenSpaceObjects=new Array}}const q=g.create(),X=m.create(),_=u.create(),J=S.create(),K=z.create(),L=g.create(),Q=g.create(),$=g.create(),ee={heading:0,tilt:0},te=new d,ne={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const a=e.hasZ;for(let o=0;o<e.rings.length;o++){const r=e.rings[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},polyline(e,t,n){const a=e.hasZ;for(let o=0;o<e.paths.length;o++){const r=e.paths[o];for(let e=0;e<r.length;e++)n[0]=r[e][0],n[1]=r[e][1],a&&(n[2]=r[e][2]),t(n)}},multipoint(e,t,n){const a=e.points,o=e.hasZ;for(let e=0;e<a.length;e++)n[0]=a[e][0],n[1]=a[e][1],o&&(n[2]=a[e][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(f.set(n,e.xmin,e.ymin,e.zmin)),t(f.set(n,e.xmax,e.ymin,e.zmin)),t(f.set(n,e.xmin,e.ymax,e.zmin)),t(f.set(n,e.xmax,e.ymax,e.zmin)),t(f.set(n,e.xmin,e.ymin,e.zmax)),t(f.set(n,e.xmax,e.ymin,e.zmax)),t(f.set(n,e.xmin,e.ymax,e.zmax)),t(f.set(n,e.xmax,e.ymax,e.zmax))):(t(f.set(n,e.xmin,e.ymin,n[2])),t(f.set(n,e.xmax,e.ymin,n[2])),t(f.set(n,e.xmin,e.ymax,n[2])),t(f.set(n,e.xmax,e.ymax,n[2])))}};e.create=async function(e,n,o){const r=function(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),!n.target&&"center"in t&&t.center&&(n.target=t.center)),n}(e,n);if(!r)throw new c("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new t({fov:e.camera.fov}),s=new a({camera:i});if(r.target instanceof a){const t=await async function(e,t,n,a,o){if(t.camera)return k(e,t.camera,a,o);o.scale=t.scale,o.rotation=t.rotation,o.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,o.camera=null,null!=n.heading?o.rotation=B(n.heading):null!=n.rotation&&(o.rotation=n.rotation);const r=E(e,n);return null!=r&&(o.scale=r),o.camera=await D(e,o,n.tilt,a),o}(e,r.target,r,o,s);return H(t)}if(r.target instanceof t)return H(await k(e,r.target,o,s));const u=null!=r.scale||null!=r.zoom;if(r.target instanceof p){const t=r.target.xmin===r.target.xmax||r.target.ymin===r.target.ymax;return H(u||t?await N(e,r,r.target.center,i,o,s):await async function(e,t,n,a,o,r){r.targetGeometry=n.clone();const i=G.cameraOnContentAlongViewDirection(e);j.fromRenderCamera(e,i,a);const c=F(a,t)?0:1;return r.camera=await V.fromExtentAsync(e,n,a.heading,a.tilt,c,o),r}(e,r,r.target,i,o,s))}const m=new Y,g=u?function(e,t){const n=E(e,t);return n?C.getResolutionInMetersForScale(n):void 0}(e,r):void 0;if(await U(e,r.target,g,m,o),isFinite(m.boundingBox[0])){let t;if(S.center(m.boundingBox,q),te.x=q[0],te.y=q[1],te.z=q[2],te.spatialReference=e.spatialReference,isFinite(te.z)&&m.hasZ?t=S.isPoint(m.boundingBox):(te.z=void 0,t=z.isPoint(S.toRect(m.boundingBox,K))),u||t)return H(await N(e,r,te,i,o,s));const n=function(e,t){if(!t.length)return.66;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){const a=t[e].screenSpaceBoundingRect;n=Math.max(n,Math.abs(a[0]),Math.abs(a[1]),Math.abs(a[2]),Math.abs(a[3]))}return.66-n/Math.min(e.width,e.height)*2}(e,m.screenSpaceObjects);return H(await async function(e,t,n,a,o,r,i,c){c.targetGeometry=n.clone();const s=G.cameraOnContentAlongViewDirection(e),u=function(e,t,n,a,o){let r=0;null!=n.z?r=n.z:e.basemapTerrain&&e.elevationProvider&&(r=P.getElevationAtPoint(e.elevationProvider,n)),f.set(q,n.x,n.y,r),v.computeTranslationToOriginAndRotation(e.spatialReference,q,X,e.renderSpatialReference),l.fromMat4(_,X),l.transpose(_,_),S.empty(J);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let t=0;t<i.length;t++){const n=i[t];let o=a[n[2]];isFinite(o)||(o=r),f.set(q,a[n[0]],a[n[1]],o),T.projectVectorToVector(q,e.spatialReference,q,e.renderSpatialReference),S.expandWithVec3(J,f.transformMat3(q,q,_))}const c=S.width(J),s=S.height(J),u=S.depth(J),m=1/Math.tan(t.fovX/2),g=1/Math.tan(t.fovY/2),p=.5*Math.sqrt(c*c+u*u)*Math.max(g,m)+.5*s,y=.5*s*g+.5*Math.max(c,u);return Math.max(p,y)/o}(e,s,n,a,o);j.fromRenderCamera(e,s,r);const m=F(r,t)?0:1;return c.camera=await V.fromCenterDistanceAsync(e,c.targetGeometry,u,r,m,i),c.scale=V.distanceToScale(e,u),c}(e,r,te,m.boundingBox,n,i,o,s))}return r.position?H(await async function(e,t,n,a,o){const r=G.cameraOnContentAlongViewDirection(e);f.copy(L,r.viewForward),Z.directionToHeadingTilt(e,r.eye,L,r.up,ee);const i=e.spatialReference,{position:c}=t;if(c){const e=await w.projectWithZConversion(c,i,{signal:o});n.position=e}else n.position=new d;return n.heading=null!=t.heading?t.heading:ee.heading,n.tilt=null!=t.tilt?t.tilt:ee.tilt,O(e,null,n,a)}(e,r,i,s,o)):H(await async function(e,t,n,a,o){if(null!=t.heading||null!=t.rotation||null!=t.scale||null!=t.tilt||null!=t.zoom||null!=t.zoomFactor){const r=G.cameraOnContentAlongViewDirection(e),{spatialReference:i,renderSpatialReference:c}=e,s=new d({spatialReference:i});return b.projectVectorToPoint(r.center,c,s)?N(e,t,s,n,a,o):o}return o.scale=e.scale,o.camera=e.camera.clone(),F(o.camera,t),o}(e,r,i,o,s))},e.fromCamera=function(e,t,n=null){return null==n&&(n=new a),O(e,null,t.clone(),n)},e.toCameraAsync=D,e.toCameraSync=function(e,t,n){const a=t.camera;if(null!=a)return function(e,t){const n=e.position;let a;try{a=w.tryProjectWithZConversion(n,t)}catch(e){return null}if(!a)return null;const o=e.clone();return o.position=a.clone(),o}(a,V.getViewSR(e));const{targetGeometry:o}=t;if(null==o)return null;const{camera:r,mode:i}=W(e,t.rotation,n);if("point"===o.type)return function(e,t,n,a,o){const r=e.spatialReference;let i;try{i=w.tryProjectWithZConversion(n.clone(),r)}catch(e){return null}if(!i)return null;const c=null!=t.scale?V.scaleToDistance(e,t.scale):e.state.camera.distance;return V.fromCenterDistanceSync(e,i,c,a,o)}(e,t,o,r,i);const c=o.extent;return null==c?null:V.fromExtentSync(e,c,r.heading,r.tilt,i)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});