// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/libs/gl-matrix-2/math/mat3","../../../core/libs/gl-matrix-2/factories/mat3f64","../../../core/libs/gl-matrix-2/factories/mat4f64","../../../core/libs/gl-matrix-2/math/quat","../../../core/libs/gl-matrix-2/factories/quatf64","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../chunks/vec42","../../../core/libs/gl-matrix-2/factories/vec4f64","../../../geometry/ellipsoidUtils","../../../geometry/spatialReferenceEllipsoidUtils","../../../geometry/projection/computeTranslationToOriginAndRotation","../../../geometry/projection/projectBuffer","../../../geometry/projection/projectors","../../../geometry/support/plane","../../../geometry/support/spatialReferenceUtils","../../../geometry/support/vectorStacks","./dito","../webgl-engine/lib/Attribute"],function(t,a,e,s,r,i,n,o,h,c,d,u,l,f,_,g,m,p,b,M){"use strict";class S{constructor(t=o.ZEROS,a=E,e=i.IDENTITY){this._data=[t[0],t[1],t[2],a[0],a[1],a[2],e[0],e[1],e[2],e[3]]}clone(){const t=new S;return t._data=this._data.slice(),t}invalidate(){this._data[3]=-1}get isValid(){return this._data[3]>=0}static fromData(t){const a=new S;return a._data=t.slice(),a}static fromJSON(t){return new S(t.center,t.halfSize,t.quaternion)}copy(t){this._data=t.data.slice()}get center(){return n.set(p.sv3d.get(),this._data[0],this._data[1],this._data[2])}get centerX(){return this._data[0]}get centerY(){return this._data[1]}get centerZ(){return this._data[2]}getCenter(t){return t[0]=this._data[0],t[1]=this._data[1],t[2]=this._data[2],t}set center(t){this._data[0]=t[0],this._data[1]=t[1],this._data[2]=t[2]}setCenter(t,a,e){this._data[0]=t,this._data[1]=a,this._data[2]=e}get halfSize(){return n.set(p.sv3d.get(),this._data[3],this._data[4],this._data[5])}get halfSizeX(){return this._data[3]}get halfSizeY(){return this._data[4]}get halfSizeZ(){return this._data[5]}getHalfSize(t){return t[0]=this._data[3],t[1]=this._data[4],t[2]=this._data[5],t}set halfSize(t){this._data[3]=t[0],this._data[4]=t[1],this._data[5]=t[2]}get quaternion(){return r.set(p.sq4d.get(),this._data[6],this._data[7],this._data[8],this._data[9])}getQuaternion(t){return t[0]=this._data[6],t[1]=this._data[7],t[2]=this._data[8],t[3]=this._data[9],t}set quaternion(t){this._data[6]=t[0],this._data[7]=t[1],this._data[8]=t[2],this._data[9]=t[3]}get data(){return this._data}getCorners(t){const a=Q,e=this._data;a[0]=e[6],a[1]=e[7],a[2]=e[8],a[3]=e[9];for(let s=0;s<8;++s){const r=t[s];r[0]=(1&s?-1:1)*e[3],r[1]=(2&s?-1:1)*e[4],r[2]=(4&s?-1:1)*e[5],n.transformQuat(r,r,a),r[0]+=e[0],r[1]+=e[1],r[2]+=e[2]}}doesIntersectFrustumConservativeApproximation(t){return this.intersectPlane(t[0])<=0&&this.intersectPlane(t[1])<=0&&this.intersectPlane(t[2])<=0&&this.intersectPlane(t[3])<=0&&this.intersectPlane(t[4])<=0&&this.intersectPlane(t[5])<=0}get radius(){const t=this._data[3],a=this._data[4],e=this._data[5];return Math.sqrt(t*t+a*a+e*e)}intersectSphere(t){C[0]=this._data[0]-t[0],C[1]=this._data[1]-t[1],C[2]=this._data[2]-t[2];const a=this.getQuaternion(P);return r.conjugate(Q,a),n.transformQuat(C,C,Q),n.abs(C,C),z[0]=Math.min(C[0],this._data[3]),z[1]=Math.min(C[1],this._data[4]),z[2]=Math.min(C[2],this._data[5]),n.sqrDist(z,C)<t[3]*t[3]}intersectSphereWithMBS(t,a=this.radius){const e=this._data;C[0]=e[0]-t[0],C[1]=e[1]-t[1],C[2]=e[2]-t[2];const s=t[3],r=s+a;return!(n.sqrLen(C)>r*r)&&(Q[0]=-e[6],Q[1]=-e[7],Q[2]=-e[8],Q[3]=e[9],n.transformQuat(C,C,Q),n.abs(C,C),z[0]=Math.min(C[0],e[3]),z[1]=Math.min(C[1],e[4]),z[2]=Math.min(C[2],e[5]),n.sqrDist(z,C)<s*s)}intersectPlane(t){const a=t[0]*this._data[0]+t[1]*this._data[1]+t[2]*this._data[2]+t[3],e=this.projectedRadius(g.getNormal(t));return a>e?1:a<-e?-1:0}intersectRay(t,a,e=0){const s=this._data,r=Q;r[0]=-s[6],r[1]=-s[7],r[2]=-s[8],r[3]=s[9],C[0]=t[0]-s[0],C[1]=t[1]-s[1],C[2]=t[2]-s[2];const i=n.transformQuat(C,C,Q),o=n.transformQuat(z,a,Q);let h=-1/0,c=1/0;const d=this.getHalfSize(F);for(let t=0;t<3;t++){const a=i[t],s=o[t],r=d[t]+e;if(Math.abs(s)>1e-6){const t=(r-a)/s,e=(-r-a)/s;h=Math.max(h,Math.min(t,e)),c=Math.min(c,Math.max(t,e))}else if(a>r||a<-r)return!1}return h<=c}projectedArea(t,e,s,i){const o=this.getQuaternion(P);r.conjugate(Q,o),C[0]=t[0]-this._data[0],C[1]=t[1]-this._data[1],C[2]=t[2]-this._data[2],n.transformQuat(C,C,Q);const c=this.getHalfSize(F),d=C[0]<-c[0]?-1:C[0]>c[0]?1:0,u=C[1]<-c[1]?-1:C[1]>c[1]?1:0,l=C[2]<-c[2]?-1:C[2]>c[2]?1:0,f=Math.abs(d)+Math.abs(u)+Math.abs(l);if(0===f)return 1/0;const _=1===f?4:6,g=6*(d+3*u+9*l+13);a.fromQuat(H,o),a.scale(H,H,c);const m=this.getCenter(T);for(let t=0;t<_;t++){const a=q[g+t];n.set(C,((1&a)<<1)-1,(2&a)-1,((4&a)>>1)-1),n.transformMat3(C,C,H),n.add(x,m,C),x[3]=1,h.transformMat4(x,x,e);const s=1/Math.max(1e-6,x[3]);A[2*t]=x[0]*s,A[2*t+1]=x[1]*s}const p=2*_-2;let b=A[0]*(A[3]-A[p+1])+A[p]*(A[1]-A[p-1]);for(let t=2;t<p;t+=2)b+=A[t]*(A[t+3]-A[t-1]);return Math.abs(b)*s*i*.125}projectedRadius(t){const a=this.getQuaternion(P);return r.conjugate(Q,a),n.transformQuat(C,t,Q),Math.abs(C[0]*this._data[3])+Math.abs(C[1]*this._data[4])+Math.abs(C[2]*this._data[5])}minimumDistancePlane(t){return t[0]*this._data[0]+t[1]*this._data[1]+t[2]*this._data[2]+t[3]-this.projectedRadius(g.getNormal(t))}maximumDistancePlane(t){return t[0]*this._data[0]+t[1]*this._data[1]+t[2]*this._data[2]+t[3]+this.projectedRadius(g.getNormal(t))}toAaBoundingBox(t){const e=this.getQuaternion(P),s=a.fromQuat(H,e),r=this._data[3]*Math.abs(s[0])+this._data[4]*Math.abs(s[3])+this._data[5]*Math.abs(s[6]),i=this._data[3]*Math.abs(s[1])+this._data[4]*Math.abs(s[4])+this._data[5]*Math.abs(s[7]),n=this._data[3]*Math.abs(s[2])+this._data[4]*Math.abs(s[5])+this._data[5]*Math.abs(s[8]);t[0]=this._data[0]-r,t[1]=this._data[1]-i,t[2]=this._data[2]-n,t[3]=this._data[0]+r,t[4]=this._data[1]+i,t[5]=this._data[2]+n}transform(t,a,e,s=0,i=u.getSphericalPCPF(e),o=u.getSphericalPCPF(a),h=_.getProjector(a,o)){if(e===i)a.isGeographic?function(t,a,e,s,i=u.getSphericalPCPF(e)){const o=d.getReferenceEllipsoid(e),h=1+Math.max(0,s)/(o.radius+t.centerZ);t.getCenter(O),O[2]+=s,f.projectBuffer(O,e,0,O,i,0),a.center=O;const c=t.getQuaternion(P);a.quaternion=c,r.conjugate(Q,c),n.set(I,0,0,1),n.transformQuat(I,I,Q);const l=t.getHalfSize(F);n.set(I,l[0]*Math.abs(I[0]),l[1]*Math.abs(I[1]),l[2]*Math.abs(I[2])),n.scale(I,I,o.inverseFlattening),n.add(I,l,I),a.halfSize=n.scale(I,I,h)}(this,t,a,s,o):function(t,a,e,s,i=u.getSphericalPCPF(e),o=_.getProjector(e,i)){t.getCorners(D),t.getCenter(O),O[2]+=s,l.computeTranslationToOriginAndRotation(e,O,N,i),a.setCenter(N[12],N[13],N[14]);const h=2*Math.sqrt(1+N[0]+N[5]+N[10]);Q[0]=(N[6]-N[9])/h,Q[1]=(N[8]-N[2])/h,Q[2]=(N[1]-N[4])/h,Q[3]=.25*h;const c=t.getQuaternion(P);a.quaternion=r.multiply(Q,Q,c),r.conjugate(Q,Q),n.set(Z,0,0,0);const d=a.getCenter(w);for(const t of D)t[2]+=s,o(t,0,t,0),n.sub(I,t,d),n.transformQuat(I,I,Q),n.abs(I,I),n.max(Z,Z,I);a.halfSize=Z}(this,t,a,s,o,h);else if(a.isWGS84&&(e.isWebMercator||m.isPlateCarree(e)))!function(t,a,e,s,r){a.getCenter(T),T[2]+=r;const i=u.getSphericalPCPF(e);f.projectBuffer(T,t,0,T,i,0),v(i,a,T,e,s)}(a,this,e,t,s);else if(a.isWebMercator&&m.isPlateCarree(e))!function(t,a,e,s,r){a.getCenter(T),T[2]+=r,v(t,a,T,e,s)}(a,this,e,t,s);else{const r=this.getCenter(T);r[2]+=s,f.projectBuffer(r,a,0,r,e,0),t.center=r,this!==t&&(t.quaternion=this.getQuaternion(P),t.halfSize=this.getHalfSize(F))}}}const Q=i.create(),P=i.create(),j=i.create(),C=o.create(),z=o.create(),x=c.create();function y(t,a=new S){return b.computeOBB(t,a),a}const A=[.1,.2,.3,.4,.5,.6,.7,.8,.9,1,1.1,1.2],q=(()=>{const t=new Int8Array(162);let a=0;const e=e=>{for(let s=0;s<e.length;s++)t[a+s]=e[s];a+=6};return e([6,2,3,1,5,4]),e([0,2,3,1,5,4]),e([0,2,3,7,5,4]),e([0,1,3,2,6,4]),e([0,1,3,2,0,0]),e([0,1,5,7,3,2]),e([0,1,3,7,6,4]),e([0,1,3,7,6,2]),e([0,1,5,7,6,2]),e([0,1,5,4,6,2]),e([0,1,5,4,0,0]),e([0,1,3,7,5,4]),e([0,2,6,4,0,0]),e([0,0,0,0,0,0]),e([1,3,7,5,0,0]),e([2,3,7,6,4,0]),e([2,3,7,6,0,0]),e([2,3,1,5,7,6]),e([0,1,5,7,6,2]),e([0,1,5,7,6,4]),e([0,1,3,7,6,4]),e([4,5,7,6,2,0]),e([4,5,7,6,0,0]),e([4,5,1,3,7,6]),e([0,2,3,7,5,4]),e([6,2,3,7,5,4]),e([6,2,3,1,5,4]),t})();function v(t,e,s,r,i){const n=e.getQuaternion(P),o=a.fromQuat(H,n),h=e.getHalfSize(F);for(let t=0;t<8;++t){for(let a=0;a<3;++a)O[a]=h[a]*(t&1<<a?-1:1);for(let a=0;a<3;++a){let e=s[a];for(let t=0;t<3;++t)e+=O[t]*o[3*t+a];R[3*t+a]=e}}f.projectBuffer(R,t,0,R,r,0,8),y(B,i)}const R=new Array(24),B=new M.Vertices(R,3),O=o.create(),T=o.create(),w=o.create(),F=o.create(),H=e.create(),N=s.create(),D=[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],I=o.create(),Z=o.create(),U=o.create(),E=o.freeze(-1,-1,-1);t.Obb=S,t.compute=y,t.computeOffsetObb=function(t,a,e,s,i){const h=t.getQuaternion(P);i.quaternion=h,r.conjugate(Q,h);const c=t.getCenter(T),d=t.getHalfSize(F);if(1===s){n.transformQuat(I,c,Q),n.abs(Z,I),n.min(U,Z,d),n.sub(U,Z,U);const s=n.length(U);n.add(U,Z,d);const r=n.length(U);if(s<e)i.center=c,n.set(I,e,e,e),i.halfSize=n.add(I,d,I);else{const o=r>0?1+a/r:1,h=s>0?1+e/s:1,c=(h+o)/2,u=(h-o)/2;n.scale(U,Z,u),i.halfSize=n.scaleAndAdd(U,U,d,c),n.scale(U,Z,c),n.scaleAndAdd(U,U,d,u),n.sign(I,I),n.multiply(I,U,I);const l=t.getQuaternion(j);i.center=n.transformQuat(I,I,l)}}else{i.center=n.scaleAndAdd(I,c,o.UNIT_Z,(e+a)/2);const t=n.transformQuat(I,o.UNIT_Z,Q);n.abs(t,t),i.halfSize=n.scaleAndAdd(Z,d,t,(e-a)/2)}return i},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});