// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/tslib.es6","../../../../core/mathUtils","../../../../core/screenUtils","../../../../core/Logger","../../../../core/has","../../../../core/RandomLCG","../../../../core/Error","../../../../core/accessorSupport/decorators/subclass","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/ellipsoidUtils","../../../../geometry/support/axisAngle","../../../../chunks/sphere","../../camera/constraintUtils","../../camera/constraintUtils/ConstraintOptions","../../camera/constraintUtils/surfaceCollision","./InteractiveController","../utils/navigationUtils","../../support/geometryUtils/ray"],function(t,e,i,r,s,a,n,o,c,h,l,m,p,_,u,d,C,P,g,y,v,R){"use strict";t.ZoomControllerGlobal=class extends y.InteractiveController{constructor(){super(...arguments),this._pickPoint=p.create(),this._tmpP0=l.create(),this._panAxisAngle=u.create(),this._tmpRayDir=p.create(),this._tmpRayDirPick=p.create(),this._targetOnSphere=p.create(),this._navigationMode=1,this._tmpRay={origin:p.create(),direction:p.create()},this.dragBeginPoint=r.createScreenPointArray(),this._normalizedAnchorPoint=l.create(),this._constraintOptions=new P.ConstraintOptions(7,1,0,this.startCamera),this._sphere=d.create(),this._hasPickPoint=!1}get _intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.running)return;h.copy(this.dragBeginPoint,t),v.normalizeCoordinate(this.startCamera,t,this._normalizedAnchorPoint);const e=_.getReferenceEllipsoid(this.view.spatialReference),r=v.pickPointAndInitSphere(this._intersectionHelper,this.startCamera,t,e.radius,0,this.view.basemapTerrain.invisible?v.excludeTerrain:{});if(this._navigationMode=v.navigationMode(this.startCamera,t,this.view.renderCoordsHelper,this.view.viewingMode),1===this._navigationMode)this._hasPickPoint=!!r.scenePickPoint,this._pickPoint=r.scenePickPoint??this._pickPoint,this._sphere=r.sphere;else{let e;R.fromScreenAtEye(this.startCamera,t,this._tmpRay),m.normalize(this._tmpRay.direction,this._tmpRay.direction),null!=r.scenePickPoint&&(m.subtract(this._tmpRayDirPick,this.startCamera.eye,r.scenePickPoint),e=m.length(this._tmpRayDirPick));const s=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(this.startCamera.eye,k);const a=i.clamp(v.getTiltScaleFactor(k,this._tmpRay.direction,v.maxZoomPivotDistanceModifier)*s,v.zoomPivotDistanceClamp[0],v.zoomPivotDistanceClamp[1]),n=this.view.stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,v.pivotSearchAreaSize);let o=null!=n?n:a;null!=e&&(o=Math.min(o,e)),this._hasPickPoint=!0,m.scale(this._tmpRay.direction,this._tmpRay.direction,o),m.add(this._pickPoint,this._tmpRay.origin,this._tmpRay.direction)}}update(t){if(this.running){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,1===this._navigationMode){m.subtract(this._tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const e=m.length(this._tmpRayDir);v.normalizeCoordinate(this.currentCamera,t,this._tmpP0);const i=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let r=e*2**i;const s=this.view.state.constraints.minimumPoiDistance;if(i<0&&r<s&&(r=s),Math.abs(e-r)<1e-6)return;if(this._hasPickPoint&&r<e){const t=1-(1-r/e)*(1-this._sphere[3]/m.length(this.currentCamera.center));this.currentCamera.center=m.scale(f,this.currentCamera.center,t)}m.scale(this._tmpRayDir,this._tmpRayDir,-r/e),this.currentCamera.eye=m.add(f,this.currentCamera.center,this._tmpRayDir),this._constraintOptions.interactionFactor=C.pixelDistanceToInteractionFactor(h.distance(this.dragBeginPoint,t)),C.applyAll(this.view,this.currentCamera,this._constraintOptions),this._hasPickPoint&&(v.sphereOrPlanePointFromScreenPoint(this._sphere,this.currentCamera,this.dragBeginPoint,this._targetOnSphere),u.fromPoints(this._pickPoint,this._targetOnSphere,this._panAxisAngle),v.applyRotation(this.currentCamera,d.getCenter(this._sphere),this._panAxisAngle))}else{const e=m.length(this._tmpRay.direction);v.normalizeCoordinate(this.currentCamera,t,this._tmpP0);const i=12*(this._normalizedAnchorPoint[1]-this._tmpP0[1]);let r=e*2**i;const s=this.view.state.constraints.minimumPoiDistance;if(i<0&&r<s&&(r=s),Math.abs(e-r)<1e-6)return;m.scale(this._tmpRayDir,this._tmpRay.direction,1-r/e),this.currentCamera.eye=m.add(f,this.currentCamera.eye,this._tmpRayDir),this.currentCamera.center=m.add(f,this.currentCamera.center,this._tmpRayDir)}g.applySurfaceCollisionConstraint(this.view,this.currentCamera),this.commitCamera()}}finish(){this.running&&this.finishController()}},t.ZoomControllerGlobal=e.__decorate([c.subclass("esri.views.3d.state.controllers.ZoomControllerGlobal")],t.ZoomControllerGlobal);const f=p.create(),k=p.create();Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});