// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../core/mathUtils","../../../core/unitUtils","../../../chunks/vec32","../../../core/libs/gl-matrix-2/factories/vec3f64","../../../geometry/ellipsoidUtils","../../../geometry/Extent","../../../geometry/support/ray","../../../chunks/sphere","../environment/atmosphereUtils","../webgl-engine/lib/DepthRange"],function(e,t,i,n,r,a,s,o,l,c,m){"use strict";class h{constructor(e,t){this._elevationProvider=e,this._referenceEllipsoid=a.getReferenceEllipsoid(t),this._unitInMeters=i.getMetersPerUnitForSR(t,this._referenceEllipsoid.metersPerDegree)}compute(e,i,r,a){const{eye:o,center:l}=e;let c=o[2]*this._unitInMeters;const m=c,h=c-a,u=this._elevationProvider?.visibleElevationBounds;u&&(c=h>=0?m-this._unitInMeters*u.min:this._unitInMeters*u.max-m),i??=new s({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0});const x={x:i.xmax-i.xmin,y:i.ymax-i.ymin,z:4*Math.max(i.xmax-i.xmin,i.ymax-i.ymin)},p=Math.max(x.x,x.y,x.z);n.subtract(E,l,o),v[0]=E[0]>0?i.xmax:i.xmin,v[1]=E[1]>0?i.ymax:i.ymin,v[2]=E[2]>0?p/2:-p/2,n.subtract(v,v,o),n.normalize(E,E);const f=1.1*n.dot(v,E)*this._unitInMeters,y=Math.sqrt(c*(c+2*this._referenceEllipsoid.radius)),I=Math.max(i.xmax-i.xmin,i.ymax-i.ymin),z=I*_*this._unitInMeters,R=I*g*this._unitInMeters,w=t.clamp((c-R)/(z-R),0,1)**3,P=Math.min(t.lerp(y,f,w),y)*Math.max(Math.log(Math.abs(h)),1);return d(Math.min(P,Math.max(34064e4,p))/this._unitInMeters,M,this._unitInMeters,b)}}class u{constructor(e,t){this._elevationProvider=e,this._referenceEllipsoid=a.getReferenceEllipsoid(t)}compute(e,i,r,a){const{eye:s}=e,h=n.length(s),u=h-this._referenceEllipsoid.radius,_=this._referenceEllipsoid.radius+Math.min(0,a),g=Math.abs(u-a),R=Math.max(g,Math.abs(u)),w=this._elevationProvider?.visibleElevationBounds.max??0,P=c.computeInnerAltitudeFade(R),U=Math.sqrt(R*(R+2*_)),D=h+this._referenceEllipsoid.radius,F=1.2*t.lerp(U,D,P),S=(Math.log(R)-x)/(p-x);d(F,t.clamp(M-S*(M-f),f,M),1,b);const k=this._referenceEllipsoid.radius+w,q=this._referenceEllipsoid.radius+this._referenceEllipsoid.atmosphereHeight,B=Math.max(k,q),H=h-B;if(P>0&&H>y){const i=n.normalize(v,n.scale(v,e.eye,-1)),a=n.normalize(E,e.viewForward),s=t.acosClamped(n.dot(i,a)),c=.5*e.fovY,h=Math.cos(c);let u=m.DepthRange.infinite.near;if(s<=c)u=H*h;else{const t=n.normalize(v,e.viewUp),i=Math.tan(c),r=n.scale(v,t,i),s=n.normalize(v,n.subtract(v,a,r)),m=o.fromValues(e.eye,s,z),d=l.fromRadius(I,B);if(l.intersectRay(d,m,v)){const t=n.subtract(v,v,e.eye);u=n.length(t)*h}}const d=.99*Math.min(r.near,u);if(d<m.DepthRange.infinite.near&&d>b.near){const e=t.lerp(b.near,d,P);b.near=e}}return b}}function d(e,t,i,n){const r=y/i,a=e/t;return a>r?(n.far=e,n.near=a):(n.near=r,n.far=n.near*t),n}const x=7.983,p=16.994,M=2e4,f=100,y=2,_=.001,g=1e-4,v=r.create(),E=r.create(),b={near:0,far:0},I=l.create(),z=o.create();e.createNearFarHeuristic=function(e,t,i){return 1===e?new u(t,i):new h(t,i)},e.minNearDistanceInMeters=y,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});