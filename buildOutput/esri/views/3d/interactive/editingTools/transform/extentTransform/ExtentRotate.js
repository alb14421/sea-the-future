// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../../core/mathUtils","../../../../../../core/libs/gl-matrix-2/math/mat4","../../../../../../chunks/vec32","../../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../../chunks/boundedPlane","../../../../../../geometry/support/plane","../../../../../../geometry/support/vectorStacks","../../../../analysis/images/Factory","../../../../analysis/Slice/RotateManipulator","../../../../analysis/Slice/sliceToolUtils","../../../manipulatorUtils","../../dragEventPipeline3D","../../../../support/geometryUtils/ray","../../../../../interactive/dragEventPipeline","../../../../../interactive/tooltip/infos/ExtentRotateTooltipInfo"],function(t,e,o,a,n,r,s,i,l,p,c,u,d,h,g,_){"use strict";t.ExtentRotate=class{get _object(){return this._tool.object}get _operations(){return this._object.operations}constructor(t,e,o){this._tool=t,this._bounds=e,this._snapRotation=o,this._rotateTooltipInfo=null,this._startAngle=0,this._endAngle=0;const a=this._tool,n=a.view,r=!n.stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result;this.rotateManipulator=new p.RotateManipulator(n,(t,e)=>l.getRotateHeadingTexture(n.stage.textures,{accentColor:t,contrastColor:e,preMultiplyAlpha:r})),a.addHandles([this.rotateManipulator.events.on("grab-changed",t=>this._onGrabChanged(t)),this._createRotateDragPipeline(this.rotateManipulator)]),a.manipulators.add(this.rotateManipulator),a.addHandles([a.events.on("rotate-start",t=>this._startAngle=t.angle),a.events.on("rotate",t=>this._endAngle=t.angle),a.events.on("rotate-stop",()=>{this._startAngle=0,this._endAngle=0})])}destroy(){this._tool.manipulators.remove(this.rotateManipulator),this.rotateManipulator.destroy()}forEachManipulator(t){t(this.rotateManipulator,3)}updateManipulators(t,e){const n=this._bounds.mapBounds.plane[2]<0?Math.PI:0,r=o.rotateX(i.sm4d.get(),t,n);r[12]=0,r[13]=0,r[14]=0,this.rotateManipulator.modelTransform=r,this.rotateManipulator.renderLocation=a.add(i.sv3d.get(),e.origin,e.basis1)}getUpdatedTooltipInfo(){return this.rotateManipulator.focused?this._computeRotateTooltipInfo():null}_computeRotateTooltipInfo(){const t=this._rotateTooltipInfo??=new _.ExtentRotateTooltipInfo({sketchOptions:this._tool.sketchOptions});return t.angle=this._startAngle-this._endAngle,t}_onGrabChanged({action:t,screenPoint:e}){const o=this._tool,a=this._bounds;if("start"!==t||!e)return;const n=c.createRotatePlane(a.displayBounds,o.view.renderCoordsHelper,1,s.create()),r=h.fromScreenNormalized(o.view.state.camera,e);s.intersectRay(n,r,i.sv3d.get())&&(a.backupMapBounds(),o.inputState={type:"rotate",rotatePlane:n})}_createRotateDragPipeline(t){const{_tool:o,_object:a}=this;return g.createManipulatorDragEventPipeline(t,(t,n,r)=>{const s=o.inputState;null!=s&&(n.next(t=>("start"===t.action&&o.events.emit("rotate-start",{object:a,angle:0}),t)).next(d.screenToRenderPlane(o.view,s.rotatePlane)).next(this._renderPlaneToAngle()).next(...this._snapRotation()).next(this._updateGeometry()).next(t=>{const n={object:a,angle:e.rad2deg(t.rotateAngle)};switch(t.action){case"start":case"update":o.events.emit("rotate",n);break;case"end":o.inputState=null,o.events.emit("rotate-stop",n)}return t}),r.next(()=>{null!=o.inputState&&o.events.emit("rotate-stop",{object:a,angle:0}),o.cancelDrag()}))})}_renderPlaneToAngle(){return t=>{const e=u.calculateInputRotationTransform(t.renderStart,t.renderEnd,this._bounds.displayBounds.origin,s.getNormal(t.plane));return{...t,rotateAngle:e}}}_updateGeometry(){const t=this._bounds;return e=>{const o=a.copy(n.create(),t.mapBoundsStart.origin),s="start"===e.action?0:1;if(this._operations){const a=this._operations.rotate(o,e.rotateAngle,s,1);r.copy(t.mapBoundsStart,t.mapBounds),t.updateMapBoundsFromOperation(a)}return e}}},Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})});