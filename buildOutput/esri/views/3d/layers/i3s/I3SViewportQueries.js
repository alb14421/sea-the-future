// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../chunks/vec42","../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../geometry/ellipsoidUtils","../../../../geometry/spatialReferenceEllipsoidUtils","../../../../geometry/projection/projectBoundingSphere","../../../../geometry/projection/projectors","../../../../geometry/support/frustum","../../../../geometry/support/plane","../../../../geometry/support/spatialReferenceUtils","../../../../chunks/sphere","../../../../layers/graphics/dehydratedPoint","../graphics/elevationAlignmentUtils","../graphics/ElevationContext","../graphics/featureExpressionInfoUtils","./I3SUtil","../../support/orientedBoundingBox"],function(e,t,i,s,n,r,o,a,c,l,u,h,d,_,p,m,g,f){"use strict";const v=1e5,b=t.create(),R=c.createPoints(),S=t.create(),M=t.create(),x=t.create(),C=t.create(),I=t.create(),P=new f.Obb,E=t.create(),D=[t.create(),t.create(),t.create(),t.create(),t.create(),t.create(),t.create(),t.create()],F=t.create(),O=t.create(),A=t.create(),V=t.create();return class{get _frustumMbsCenter(){return this._frustumMbs}get _frustumMbsRadius(){return this._frustumMbs[3]}get _frustumPlanes(){return this._frustum}constructor(e,i,o,l,h,_,p,m,g={}){this._indexSR=e,this._renderCoordsHelper=i,this._clippingArea=h,this._elevationProvider=_,this._viewingMode=p,this._options=g,this._frustum=c.create(),this._frustumMbs=s.create(),this._useFrustumCulling=!1,this._poi=t.create(),this._elevationContext=null,this.minDistance=1/0,this.maxDistance=0,this.maxLodLevel=2,this._tmpObb=new f.Obb,this._tmp1=t.create(),this._tmp2=t.create(),this._tmp3=t.create(),this._tmp0=t.create(),this._screenspaceErrorBias=g.screenspaceErrorBias||1,this._progressiveLoadFactor=g.progressiveLoadFactor||1,this.updateCamera(o,l);const v=this._renderCoordsHelper.spatialReference;this._renderSR=v,this._renderSRSphericalPCPF=r.getSphericalPCPF(v),this._isGlobalMode=v===this._renderSRSphericalPCPF,this.updateElevationInfo(m),this._tmpPoint=d.makeDehydratedPoint(0,0,0,e),this._isECEFOBBInLocalMode=this._indexSR.isWGS84&&(v.isWebMercator||u.isPlateCarree(v)),this._indexSREllipsoidRadius=n.getReferenceEllipsoid(this._indexSR).radius,this._indexSRSphericalPCPF=r.getSphericalPCPF(e),this._projectorIndexSRToIndexSRSphericalPCPF=a.getProjector(this._indexSR,this._indexSRSphericalPCPF)}updateElevationInfo(e){null!=e?(this._elevationContext=p.ElevationContext.fromElevationInfo(e),this._elevationContext.updateFeatureExpressionInfoContext(m.createContextWithoutExpressionSupport(m.extractExpressionInfo(e,!1)))):this._elevationContext=null}updateCamera(t,i){if(this._useFrustumCulling=i,i){c.fromMatrix(t.viewMatrix,t.projectionMatrix,this._frustum,R);{const i=t.eye,s=b;e.normalize(s,t.viewForward);const n=R,r=S;e.sub(r,n[4],i);const o=.5*e.dot(r,r)/e.dot(s,r),a=this._frustumMbs,c=a;e.scaleAndAdd(c,i,s,o);const l=1+o;a[3]=l}}this._screenSizeFactor=1/(t.perScreenPixelRatio/2),this._camPos=t.eye,this.minDistance=1/0,this.maxDistance=0}setPointOfInterest(e){this._poi=e}updateScreenSpaceErrorBias(e){const t=this._screenspaceErrorBias;return this._screenspaceErrorBias=e,t}updateClippingArea(e){this._clippingArea=e}expandElevationRange(e,t,i){if(null==this._elevationContext)return;const s=e.serviceMbsInIndexSR;if(!s)return;const n="relative-to-scene"===this._elevationContext.mode?"scene":"ground";if(this._elevationProvider.getSphereElevationBounds){const e=this._elevationProvider.getSphereElevationBounds(s,this._indexSR,n);return void(e&&i.expandElevationRange(e))}const r=s[0],o=s[1],a=s[2],c=this._elevationProvider.getElevation(r,o,a,this._indexSR,n);c&&i.expandElevationRangeValues(c,c);const l=t?null:this._elevationProvider.getRootElevationBounds?.();l&&i.expandElevationRange(l)}getServiceMbsInRenderSR(e){const t=e.serviceMbsInRenderSR;if(g.isValidMbs(t))return t;e.serviceMbsInIndexSR&&i.copy(t,e.serviceMbsInIndexSR);const s=e.elevationRangeMin;if(this._elevationContext&&Number.isFinite(s)){let i=0,n=0;const r=e.elevationRangeMax;switch(this._elevationContext.mode){case"relative-to-ground":case"relative-to-scene":i=this._elevationContext.geometryZWithOffset(t[2],this._renderCoordsHelper)+s-t[2],n=r-s;break;case"on-the-ground":i=s-t[2],n=r-s}t[2]+=i+.5*n,t[3]+=.5*n}else this._elevationContext&&t[3]<v&&(this._tmpPoint.x=t[0],this._tmpPoint.y=t[1],this._tmpPoint.z=t[2],t[2]=_.evaluateElevationAlignmentAtPoint(this._tmpPoint,this._elevationProvider,this._elevationContext,this._renderCoordsHelper));return o.projectBoundingSphere(t,this._indexSR,t,this._renderSR),t}getAndUpdateVisibilityObbInRenderSR(e){{const t=e.visibilityObbInRenderSR;if(t)return t}const t=.01*this._indexSREllipsoidRadius,{serviceMbsInIndexSR:i,serviceObbInIndexSR:s}=e;if(null==s||!i||!s.isValid||this._isECEFOBBInLocalMode&&(s.halfSizeX>t||s.halfSizeY>t||s.halfSizeZ>t))return null;{let t=e.serviceObbInRenderSR;if(null==t)t=new f.Obb,e.serviceObbInRenderSR=t;else if(t.isValid)return t;const n=i[3];let r=0,o=0;const a=s.centerZ,c=this._renderCoordsHelper,l=this._elevationContext;if(l&&e.elevationRangeValid){const t=e.elevationRangeMin,i=e.elevationRangeMax;switch(l.mode){case"relative-to-ground":case"relative-to-scene":r=l.geometryZWithOffset(a,c)+t-a,o=i-t;break;case"on-the-ground":r=t-a,o=i-t}}else if(l&&n<v){const e=this._tmpPoint;e.x=s.centerX,e.y=s.centerY,e.z=a,r=_.evaluateElevationAlignmentAtPoint(e,this._elevationProvider,l,c)-a}const u=o>0,h=u?this._tmpObb:t;return s.transform(h,this._indexSR,this._renderSR,r,this._renderSRSphericalPCPF,this._indexSRSphericalPCPF,this._projectorIndexSRToIndexSRSphericalPCPF),u&&f.computeOffsetObb(h,0,o,this._viewingMode,t),t}}getNodeObbInRenderSRIndependentOfElevationOffset(e){{const t=e.visibilityObbInRenderSR??e.serviceObbInRenderSR??null;if(t?.isValid)return t}const t=e.serviceObbInIndexSR;return t?(t.transform(P,this._indexSR,this._renderSR,void 0,this._renderSRSphericalPCPF,this._indexSRSphericalPCPF,this._projectorIndexSRToIndexSRSphericalPCPF),P):null}ensureElevationAgnosticBoundingVolume(e){return-1===e.elevationAgnosticBoundingVolume[3]&&e.level>0&&(1===this._viewingMode?this._updateElevationAgnosticBoundingVolumeGlobal(e):this._updateElevationAgnosticBoundingVolumeLocal(e)),e.elevationAgnosticBoundingVolume}_updateElevationAgnosticBoundingVolumeGlobal(t){const s=this.getNodeObbInRenderSRIndependentOfElevationOffset(t),n=t.elevationAgnosticBoundingVolume;let r,o=-1;if(s){const t=E;s.getCenter(t),e.normalize(t,t),r=t,s.getCorners(D);for(const i of D){e.normalize(i,i);const s=e.dot(i,t);if(s<=0)return void(n[3]=-1);const r=Math.sqrt(1-s*s);o=Math.max(o,r)}}else{const i=t.serviceMbsInRenderSR;if(!g.isValidMbs(i))return void(n[3]=-1);{const t=e.copy(E,h.getCenter(i)),s=i[3],a=e.len(t);if(a<s)return void(n[3]=-1);o=s/a,e.normalize(t,t),r=t}}i.copyVec3(n,r),n[3]=o+.001}_updateElevationAgnosticBoundingVolumeLocal(t){const s=t.elevationAgnosticBoundingVolume,n=this.getNodeObbInRenderSRIndependentOfElevationOffset(t);if(n){const t=n.getCenter(E);t[2]=0,i.copyVec3(s,t);let r=0;const o=F;n.getCorners(D);for(const t of D){t[2]=0;const i=e.sqrDist(o,t);r=Math.max(r,i)}s[3]=Math.sqrt(r)}else{const n=t.serviceMbsInRenderSR;if(g.isValidMbs(n)){const t=e.copy(E,h.getCenter(n));t[2]=0,i.copyVec3(s,t),s[3]=n[3]}}}isNodeVisible(e){const t=this.getServiceMbsInRenderSR(e);if(!this._isMBSinClippingArea(t))return!1;if(!this._useFrustumCulling)return!0;const i=this.getAndUpdateVisibilityObbInRenderSR(e);return i?i.doesIntersectFrustumConservativeApproximation(this._frustum):c.intersectsSphere(this._frustum,h.wrap(t))}isElevationAgnosticBoundingVolumeVisible(e){return!this._useFrustumCulling||-1===e[3]||(1===this._viewingMode?this._isConeVisibleInFrustum(e):this._isCylinderVisibleInFrustum(e))}_isConeVisibleInFrustum(t){if(!this._isConeVisibleInFrustumMbs(t))return!1;const i=t[3];if(-1===i||i>.9)return!0;const s=this._frustumPlanes,n=this._frustumMbsCenter,r=t,o=e.dot(r,n),a=this._frustumMbsRadius,c=o-a,u=o+a;if(c<=0)return!0;const h=e.scale(x,r,c),d=e.scale(C,r,u),_=i/Math.sqrt(1-i*i);for(const t of s){const i=l.getNormal(t),s=e.normalize(I,i),n=e.dot(s,r);if(Math.abs(1-n)<.01)continue;const o=O;e.scale(o,r,n),e.sub(o,o,s),e.normalize(o,o);const a=A;if(e.scaleAndAdd(a,h,o,c*_),!(l.signedDistance(t,a)<=0||(e.scaleAndAdd(a,d,o,u*_),l.signedDistance(t,a)<=0)))return!1}return!0}_isConeVisibleInFrustumMbs(t){const i=t[3];if(i>.9)return!0;const s=this._frustumMbsRadius,n=this._frustumMbsCenter,r=e.len(n);if(r<=s)return!0;const o=t,a=e.dot(o,n);{const t=e.scale(M,o,a);if(e.dist(t,n)<s)return!0}const c=a/r;if(a<=0)return-c<s;const l=Math.sqrt(1-c*c);if(l<i)return!0;const u=s/r;return l*Math.sqrt(1-u*u)-u*c<i}isObbVisibleIndependentOfElevation(t,i){if(!this._useFrustumCulling)return!0;if(-1===t[3])return!0;const s=this._frustumMbsRadius,n=this._frustumMbsCenter,r=this._frustumPlanes,o=D;if(i.getCorners(o),1===this._viewingMode){const i=t,a=e.dot(i,n),c=a-s,u=a+s;if(c<=0)return!0;for(const t of r){let s=!0;for(const n of o){const r=e.dot(n,i),o=V;if(e.scale(o,n,c/r),l.signedDistance(t,o)<=0){s=!1;break}const a=V;if(e.scale(a,n,u/r),l.signedDistance(t,a)<=0){s=!1;break}}if(s)return!1}}else{const e=n[2]-s,t=n[2]+s;for(const i of r){let s=!0;const n=l.getNormal(i),r=n[0],a=n[1],c=n[2],u=i[3];for(const i of o){const n=r*i[0]+a*i[1]+u;if(n+c*e<=0||n+c*t<=0){s=!1;break}}if(s)return!1}}return!0}_isCylinderVisibleInFrustum(t){const i=this._frustumMbsCenter,s=this._frustumMbsRadius,n=e.copy(M,i);n[2]=0;const r=t[3],o=t;return e.dist(n,o)<=r+s}isGeometryVisible(e){if(!this._useFrustumCulling)return!0;const t=e.geometryObbInRenderSR;return t?.doesIntersectFrustumConservativeApproximation(this._frustum)??this.isNodeVisible(e)}_isMBSinClippingArea(e){return null==this._clippingArea||0!==g.intersectBoundingRectWithMbs(this._clippingArea,e)}_screenSpaceDiameterMbs(t,i){const s=this.getServiceMbsInRenderSR(t),n=Math.sqrt(e.squaredDistance(h.getCenter(s),this._camPos)),r=n-s[3];return this._updateMinMaxDistance(n),r<0?.5*Number.MAX_VALUE:i/r*this._screenSizeFactor}calcCameraDistance(e){return this.calcCameraDistanceToCenter(e)-this.getServiceMbsInRenderSR(e)[3]}calcCameraDistanceToCenter(t){const i=this.getServiceMbsInRenderSR(t),s=e.distance(h.getCenter(i),this._camPos);return this._updateMinMaxDistance(s),s}calcAngleDependentLoD(t){const i=this.getServiceMbsInRenderSR(t),s=i[3],n=(Math.abs(i[0]*(i[0]-this._camPos[0])+i[1]*(i[1]-this._camPos[1])+i[2]*(i[2]-this._camPos[2]))/e.length(h.getCenter(i))+s)/e.distance(h.getCenter(i),this._camPos);return Math.min(1,n)}hasLOD(e){return 0!==e.lodMetric}_getDistanceGlobeMode(t,i){const s=e.length(h.getCenter(i)),n=e.length(t)-s;e.scale(this._tmp0,t,e.dot(t,h.getCenter(i))/e.squaredLength(t));const r=e.squaredDistance(h.getCenter(i),this._tmp0),o=i[3];if(r<=o*o)return Math.abs(n);{const r=e.scale(this._tmp0,h.getCenter(i),1/s),a=s,c=o*o/2/a,l=e.scale(this._tmp1,r,a-c),u=t,d=e.subtract(this._tmp2,u,l),_=e.subtract(this._tmp2,d,e.scale(this._tmp3,r,e.dot(r,d))),p=e.add(this._tmp2,l,e.scale(this._tmp2,_,o/e.length(_)));let m=e.distance(u,p);if(n>=2e5){const t=e.subtract(this._tmp1,u,p);let i=e.dot(t,r)/e.length(t);i<.08&&(i=1e-4),m/=i}return m}}_getDistance(e,t){return this._isGlobalMode?this._getDistanceGlobeMode(e,t):function(e,t){const i=e[0]-t[0],s=e[1]-t[1],n=e[2]-t[2],r=i*i+s*s,o=t[3];if(r<=o*o)return Math.abs(n);const a=Math.sqrt(r)-o;return Math.sqrt(n*n+a*a)}(e,t)}_updateMinMaxDistance(e){e>0?(this.minDistance=Math.min(this.minDistance,e),this.maxDistance=Math.max(this.maxDistance,e)):(this.minDistance=0,this.maxDistance=Math.max(this.maxDistance,-e))}getLodLevel(e){if(0===e.lodMetric)return 0;if(0===e.childCount)return this.maxLodLevel;if(this._useFrustumCulling&&this._progressiveLoadFactor<1){const t=this._progressiveLoadFactor*this._screenspaceErrorBias,i=this._screenspaceErrorBias;return this.evaluateLODmetric(e,t)?this.evaluateLODmetric(e,i)?2:1:0}return this.evaluateLODmetric(e,this._screenspaceErrorBias)?this.maxLodLevel:0}evaluateLODmetric(e,t){switch(e.lodMetric){case 2:{const i=this.getServiceMbsInRenderSR(e),s=this._getDistance(this._camPos,i),n=2*s/this._screenSizeFactor,r=s+i[3];return this._updateMinMaxDistance(r),e.maxError*t<=n}case 1:{let i=this._screenSpaceDiameterMbs(e,e.serviceMbsInIndexSR[3]*t);return this._options.angleDependentLoD&&(i*=this.calcAngleDependentLoD(e)),i<e.maxError}case 3:return this._screenSpaceDiameterMbs(e,e.maxError)*t<10;case 4:return this.calcCameraDistance(e)>e.maxError*t}return!1}distToPOI(t){const i=this.getServiceMbsInRenderSR(t);return e.distance(h.getCenter(i),this._poi)-i[3]}distCameraToPOI(){return e.distance(this._camPos,this._poi)}}});