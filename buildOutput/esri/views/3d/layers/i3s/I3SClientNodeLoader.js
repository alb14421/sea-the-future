// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/Error","../../../../core/maybe","../../../../core/MemCache","../../../../core/promiseUtils","../../../../core/uuid","../../../../core/libs/gl-matrix-2/math/mat3","../../../../core/libs/gl-matrix-2/factories/mat3f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/projection/projectBoundingSphere","../../../../geometry/support/DoubleArray","../../../../geometry/support/meshVertexSpaceUtils","../../../../chunks/sphere","./CachedMeshData","./I3SClientMaterialUtil"],function(e,t,r,o,n,a,s,i,l,d,c,u,m,h,f,p){"use strict";function y(e,t){const{spatialReference:r}=e,o=[1,-1],n=[.5*e.width,.5*e.height,e.hasZ?.5*(e.zmax-e.zmin):0],a=r.isGeographic?r.metersPerUnit:1,s=e.center;let i=0;if(e.hasZ)for(let e=0;e<2;++e)for(let r=0;r<2;++r)for(let l=0;l<2;++l){const d=(s.x+o[e]*n[0]-t.x)*a,c=(s.y+o[r]*n[1]-t.y)*a,u=s.z+o[l]*n[2]-t.z;i=Math.max(d*d+c*c+u*u,i)}else for(let e=0;e<2;++e)for(let r=0;r<2;++r){const l=(s.x+o[e]*n[0]-t.x)*a,d=(s.y+o[r]*n[1]-t.y)*a;i=Math.max(l*l+d*d,i)}return h.fromCenterAndRadius([t.x,t.y,t.z],Math.sqrt(i))}async function x(e,t,o,n){const{transform:a,vertexAttributes:c}=t.loadedMesh,u="source"===e.shading?c.normal:null;if(null==u||null==a||0===a.rotationAngle&&l.exactEquals(a.scale,d.ONES))return{transformed:u,original:c.normal};if(!t.normalsTransformPromise){r.assertIsSome(o,"SceneLayerWorker is needed to transform mesh normals");const e=i.create();s.normalFromMat4(e,a.localMatrix),t.normalsTransformPromise=o.transformNormals({normalMatrix:e,normals:u},n)}return t.normalsTransformPromise}function g(e,t,r){e[t]=255&r,e[t+1]=255&r>>8,e[t+2]=255&r>>16,e[t+3]=255&r>>24}e.I3SClientNodeLoader=class{constructor(e,t,r,o){this._uid=e,this._worker=o,this._id2Meta=new Map,this._oid2Meta=new Map,this._indexSR=t.indexSR,this._vertexSR=t.vertexSR,this._renderSR=t.renderSR,this._memCache=r.newCache(`sl-client-mesh-data-${this._uid}`)}get uid(){return this._uid}get worker(){return this._worker}get indexSR(){return this._indexSR}get renderSR(){return this._renderSR}createMeshNodeInfo(e,t){const r=`mesh${t}`,o=e.extent,n=o.spatialReference,s=this._indexSR,i=y(o,e.origin);c.projectBoundingSphere(i,n,i,s);const l=function(e){const t=e.metadata.displaySource?.source;if(null==t||!Array.isArray(t)||!t.length||t[0]instanceof File)return a.generateUUID();const r=t;let o="";for(const e of r)o+=e.makeHash();return o+JSON.stringify(e.transform?.toJSON()??"")+(m.isRelativeVertexSpace(e.vertexSpace)?JSON.stringify(e.vertexSpace.origin):"")+JSON.stringify(e.spatialReference)}(e);return{type:"mesh",id:r,version:l,oid:t,mbs:i,componentNodeIds:[],unloadedMesh:e,nodeIndex:null,loadMeshPromise:null}}addMeshNode(e,r){if(null!=this.getMeshNodeIndex(r.oid))throw new t("scenelayer",`I3SClientNodeLoader: client side mesh for feature oid=${r.oid} already exists`);r.nodeIndex=e,this._id2Meta.set(r.id,r),this._oid2Meta.set(r.oid,r)}getMeshNodeIndex(e){const t=this._oid2Meta.get(e);return null==t||"mesh"!==t.type?null:t.nodeIndex}getMeshNodeInfo(e){const t=this._oid2Meta.values();for(const r of t)if("mesh"===r.type&&r.id===e)return r;return null}removeNode(e){const t=this._id2Meta.get(e);null!=t&&(this._id2Meta.delete(e),"mesh"===t.type&&this._oid2Meta.delete(t.oid))}async loadNodeJSON(e){const r=this._id2Meta.get(e);if(null==r)throw new t("scenelayer",`I3SClientNodeLoader::loadNodeJSON unable to find node ${e}`);switch(r.type){case"mesh":return this._loadMeshNodeJSON(r);case"mesh-component":return async function(e){return{id:e.id,version:e.meshNodeInfo.version,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null,isEmpty:!1}}(r);default:throw new t("scenelayer",`I3SClientNodeLoader::loadNodeJSON unable to handle node ${e}`)}}async _loadMeshNodeJSON(e){const t=e.id,r=(await this._getMeshData(e)).loadedMesh;if(null==r.components||0===r.components.length)return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null};const o=[],n=r.components;for(let r=0;r<n.length;++r){const n=`${t}-component${r}`,a={type:"mesh-component",id:n,mbs:e.mbs,componentIndex:r,meshNodeInfo:e,textureData:new Map};this._id2Meta.set(a.id,a),e.componentNodeIds.push(n),o.push({id:a.id,href:null,mbs:a.mbs,obb:null})}return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:o}}updateNodeIndex(e,t,r){const o=this._id2Meta.get(e);o&&"mesh"===o.type&&(o.nodeIndex=r)}async loadNodeData(e,o){const a=this._id2Meta.get(e);if(null==a||"mesh-component"!==a.type)throw new t("scenelayer",`Failed to load client node data for node ${e} (unexpected node info)`);const s=a.meshNodeInfo,i=await this._getMeshData(s),l=i.loadedMesh,d=s.oid;if(null==l.components)throw new t("scenelayer",`Failed to load client node data for node ${e} (unexpected null reference)`);const c=l.components[a.componentIndex],{material:m,requiredTextures:h,textureData:f}=await p.convertMeshMaterialToPBRMaterial(c.material);if(null!=f)for(const e of f)null!=e&&a.textureData.set(e.id,e);const y={params:{material:m},type:"ArrayBufferView"},{vertexSpace:M,origin:S,transform:b}=l,w=[S.x,S.y,S.z??0];i.projectionPromise||(r.assertIsSome(this._worker,"SceneLayerWorker is needed to project mesh"),i.projectionPromise=this._worker.project({positions:l.vertexAttributes.position,localMatrix:b?.localMatrix,vertexSpace:M.toJSON(),origin:w,inSpatialReference:l.spatialReference.toJSON(),outSpatialReference:this._vertexSR.toJSON()},o));const{projected:_,original:N,projectedOrigin:v}=await i.projectionPromise,I=u.ensurePackedArray(v);l.vertexAttributes.position=N;const{transformed:D,original:R}=await x(c,i,this._worker,o);l.vertexAttributes.normal=R,n.throwIfAborted(o);const{geometryBuffer:A,geometryDescriptor:O}=function(e,t,r,o,n,a){const s=(t?.length??0)/3,i=3*s;let l=0,d=0,c=!1,u=0,m=!1,h=0,f=!1,p=0,y=0,x=0;l+=4,l+=4,d=l,l+=3*i*4,null!=r&&(c=!0,u=l,l+=3*i*4),null!=o&&(m=!0,h=l,l+=2*i*4),null!=n&&(f=!0,p=l,l+=4*i*1),y=l,l+=8,x=l,l+=8;const M=new ArrayBuffer(l),S=new Uint8Array(M);g(S,0,i),g(S,4,1);const b=new Float32Array(M,d),w=null!=r?new Float32Array(M,u):null,_=null!=o?new Float32Array(M,h):null,N=null!=n?new Uint8Array(M,p):null;for(let a=0;a<s;++a){const s=3*a;for(let i=0;i<3;++i){const l=t[s+i],d=3*l,c=9*a+3*i;if(b[c]=e[d],b[c+1]=e[d+1],b[c+2]=e[d+2],w&&(w[c]=r[d],w[c+1]=r[d+1],w[c+2]=r[d+2]),_){const e=2*l,t=6*a+2*i;_[t]=o[e],_[t+1]=o[e+1]}if(N){const e=4*l,t=12*a+4*i;N[t]=n[e],N[t+1]=n[e+1],N[t+2]=n[e+2],N[t+3]=n[e+3]}}}return g(S,y,a),g(S,y+4,a/2**32),g(S,x,0),g(S,x+4,s-1),{geometryBuffer:M,geometryDescriptor:{isDraco:!1,isLegacy:!0,color:f,normal:c,uv0:m,uvRegion:!1,featureIndex:!0}}}(_,c.faces,D,l.vertexAttributes.uv,l.vertexAttributes.color,d);return{geometryData:{featureDataPosition:I,featureIds:[],geometries:[y]},attributeDataInfo:{attributeData:{},loadedAttributes:[]},geometryBuffer:A,geometryDescriptor:O,requiredTextures:h,textureData:f,normalReferenceFrame:this._vertexSR.isGeographic?"east-north-up":"vertex-reference-frame"}}async loadAttributes(e,t,r){const o=e.numFeatures,n={};for(const{field:{name:e}}of t)n[e]=new Array(o);return n}async loadTextures(e,t,r){const o=e.id,n=this._id2Meta.get(o);if(null==n||"mesh-component"!==n.type)throw new Error(`Failed to load textures for node ${e.id} (unexpected node info)`);const a=[];for(const e of t)a.push(n.textureData.get(e.id)||null);return a}async _getMeshData(e){const t=e.version,r=this._memCache.get(t);if(null==r){if(null!=e.loadMeshPromise)return e.loadMeshPromise;const r=async(r,n)=>{const a=e.unloadedMesh.clone();try{await a.load()}catch(e){n(e)}const s=new f.CachedMeshData(a);this._memCache.put(t,s,o.MinPriority),e.loadMeshPromise=null,r(s)};return e.loadMeshPromise=new Promise((e,t)=>r(e,t)),e.loadMeshPromise}return r}},e.createSphereFromExtent=y,e.sizeOfFloat32=4,e.sizeOfInt32=4,e.sizeOfUInt64=8,e.sizeOfUInt8=1,e.transformNormals=x,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});