// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/asyncUtils","../../../../core/lang","../../../../core/uuid","../../../../layers/support/featureQueryAll"],function(e,t,n,o,r){"use strict";const i={setAttribute(){},rollback(){},commit(){}};function s(e,t,n){const{gidToFeatureInfo:o,oidToFeatureInfo:r,fieldsIndex:i,objectIdField:s,globalIdField:l,featureOrIdentifierList:u}=n;if(!n.featuresResolved&&null!=u){for(const e of u){const t={feature:null,oid:-1,gid:null};if("attributes"in e){t.feature=e;const n=e.attributes;if(null!=n)for(const e in n){if(-1!==t.oid&&null!=t.gid)break;const o=i.normalizeFieldName(e);o===s&&(t.oid=n[e]??-1),o===l&&(t.gid=n[e])}}else t.oid=e.objectId??-1,t.gid=e.globalId;null!=t.gid&&o.set(t.gid,t),-1!==t.oid&&r.set(t.oid,t)}n.featuresResolved=!0}return(-1!==e?r.get(e):null)??(null!=t?o.get(t):null)}function l(e,t,n,r,i=null,l=!0){const u=[],a={gidToFeatureInfo:new Map,oidToFeatureInfo:new Map,featuresResolved:null==n,fieldsIndex:e.fieldsIndex,objectIdField:e.objectIdField,globalIdField:e.globalIdField,featureOrIdentifierList:n};for(const e of t){if(null!=e.error)continue;const t=e.objectId??-1,n=e.globalId,d=(-1===t||l?s(t,n,a):null)??{feature:null,oid:t,gid:n},f={oid:-1===t?d.oid:t,gid:n??d.gid,feature:d.feature,result:e};u.push(f);const c=f.gid?o.normalizeGlobalID(f.gid):null;if(-1===f.oid&&null!=c&&null!=i&&(f.oid=i.get(c)??-1),-1===f.oid&&null!=c){let e=r.get(c);null==e&&(e={gid:f.gid,edits:[]},r.set(c,e)),e.edits.push(f)}}return u}function u(e,t,n){const o=function(e,t){const n=e.get(t);if(n)return n;const o=new a;return e.set(t,o),o}(e,t),r=null!=n&&o.get(n);if(r)return r;const i=new Array;return o.set(n,i),i}const a=Map,d=Map;e.createInteractiveEditSession=function(e,t){const o=t.attributes[e.objectIdField];if(null==o)return i;const r=e.sessions.get(o);if(r)return r;const s=n.clone(t.attributes),l=new Set,u=e.i3sOverrides.createInteractiveEditSession(o),a=new Map;let d=0;const f={setAttribute(n,r){if(0!==d)return;const i=e.fieldsIndex.get(n);if(!i)return;const f=e.attributeStorageInfo.findIndex(e=>e.name===i.name);if(f<0)return;if(!(n in s))throw new Error(`Attribute "${n}" is not an attribute of the edited feature.`);u.setAttribute(f,r);const c=e.attributeStorageInfo[f];let b=!1;l.add(n),e.forEachNode((n,i)=>{const s=((e,t)=>{const n=a.get(e);if(null==n){const n=t.indexOf(o);return a.set(e,n),n}return n})(n,i);if(-1===s)return;const l=e.getAttributeData(n.index);if(l){const o=l[c.name];o&&(o[s]=r,e.setAttributeData(n.index,l,t),b=!0)}}),b&&e.clearMemCache()},rollback(){if(0===d){for(const e of l)this.setAttribute(e,s[e]);u.remove(),d=1,e.sessions.delete(o)}},commit(){0===d&&(u.remove(),d=2,e.sessions.delete(o))}};return e.sessions.set(o,f),f},e.normalizeEditResultsEvent=async function(e,n){const i=new Map,s=l(e,n.addedFeatures,n.edits?.addFeatures,i),u=l(e,n.updatedFeatures,n.edits?.updateFeatures,i),a=l(e,n.deletedFeatures,n.edits?.deleteFeatures,i,n.globalIdToObjectId,!1);return i.size>0&&await async function(e,n){const i=e.i3sOverrides.layer.associatedLayer;if(null==i?.globalIdField)return;const s=i.createQuery(),{objectIdField:l,globalIdField:u}=i;s.where=Array.from(n.values()).map(({gid:e})=>`${u}='${e}'`).join(" OR "),s.returnGeometry=!1,s.outFields=[l,u],s.cacheHint=!1;const a=await t.resultOrAbort(r.queryAllJSON(i,s));if(!a.ok)return;const d=a.value.features;for(const e of d){const t=e.attributes[u],r=e.attributes[l];if(null==t||null==r||-1===r)continue;const i=n.get(o.normalizeGlobalID(t));if(null!=i)for(const e of i.edits)e.oid=r}}(e,i),{adds:s.filter(e=>-1!==e.oid),updates:u.filter(e=>-1!==e.oid),deletes:a.filter(e=>-1!==e.oid)}},e.processAttributeEdits=function(e,t){const n=function(e,t){const n=t.updates;if(!n||0===n.length)return new d;const o=new d,r=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)r.set(e.attributeStorageInfo[t].name,t);return e.forEachNode((t,r)=>{for(const i of n){if(null==i.feature)continue;const n=i.feature,s=i.oid,l=r.indexOf(s);for(const r in n.attributes){const i=e.fieldsIndex.normalizeFieldName(r),a=u(o,t.index,i),d=n.attributes[r];a.push({featureIndex:l,featureId:s,value:d})}}}),o}(e,t),o=function(e,t){const n=new Map,o=t.adds;if(!o||0===o.length||null==e.globalIdField)return n;for(const e of o){const t=e.oid,o=e.feature;"mesh"===o?.geometry?.type&&n.set(t,o)}return n}(e,t);if(0===n.size&&0===o.size)return;const r=new Map;for(let t=0;t<e.attributeStorageInfo.length;t++)r.set(e.attributeStorageInfo[t].name,t);let i=!1;n.forEach((t,n)=>{const o=e.getAttributeData(n);let s=!1;t.forEach((t,n)=>{const l=null!=o?o[n]:null,u=r.get(n);for(const{featureIndex:n,value:o,featureId:r}of t)l&&(l[n]=o,s=!0,i=!0),e.i3sOverrides.updateAttributeValue(r,u,o)}),s&&e.setAttributeData(n,o,null)}),i&&e.clearMemCache();const{fieldsIndex:s,i3sOverrides:l,objectIdField:a,globalIdField:f}=e,c=l.layer.associatedLayer?.infoFor3D,b=new Set(c?[...Object.values(c.assetMapFieldRoles),...Object.values(c.transformFieldRoles)]:[]);for(const[e,t]of o){l.featureAdded(e);const{attributes:n}=t;for(const t in n){if(t!==a&&t!==f&&b.has(t))continue;const o=s.normalizeFieldName(t),i=null!=o?r.get(o):null;if(null==i)continue;const u=n[t];l.updateAttributeValue(e,i,u)}}},e.processGeometryEdits=function(e,t){const n=new Map,o=e=>{for(const{oid:t,feature:o}of e){const e=o?.geometry;"mesh"===e?.type&&n.set(t,e)}};o(t.adds),o(t.updates);for(const e of t.deletes)n.set(e.oid,null);for(const[t,o]of n)e.i3sOverrides.updateGeometry(t,o)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});