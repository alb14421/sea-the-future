// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/ellipsoidUtils","../../../../geometry/spatialReferenceEllipsoidUtils","../../../../geometry/projection/projectBuffer","../../../../geometry/projection/projectVec3Array","../../../../geometry/support/plane","../../state/Frustum"],function(e,t,r,n,s,o,i,c,a){"use strict";function u(e,r,n){return t.cross(e,r,n),t.normalize(e,e),e}function f(e,r,n){return t.sub(e,r,n),t.normalize(e,e),e}function l(e,r){return t.scale(e,e,r/t.len(e)),e}const d=[0,1,2,3,5];function h(e,t,r){for(let n=0;n<r;++n)if(c.signedDistance(e,t[n])<=0)return!1;return!0}function m(e,t,r){for(const n of d)if(h(e[n],t,r))return!0;return!1}function p(e,t,r=t.length){for(let n=0;n<r;++n){const r=t[n];let s=!0;for(const t of e)if(c.signedDistance(t,r)>0){s=!1;break}if(s)return!0}return!1}function _(e,r,n){for(const s of r)if(t.dot(s,e)<n)return!1;return!0}const g=[r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create()],b=[0,0,0,0,0,0],F=[r.create(),r.create(),r.create(),r.create(),r.create(),r.create()],S=r.create(),z=r.create(),v=r.create(),M=r.create(),y=r.create(),R=r.create(),V=r.create(),G=r.create(),A=r.create(),B=r.create(),x=r.create(),D=r.freeze(0,0,0),I=r.create(),j=[r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create(),r.create()],q=[r.create(),r.create(),r.create(),r.create(),r.create()],w=r.create(),C=r.create(),P=r.create(),E=r.create(),T=r.create(),L=r.create(),O=r.create(),k=r.create(),Y=r.create(),H=r.create(),U=[0,1,2,3],W=[0,1,2,3],J=[0,1,3],K=[0,1,3],N=[1,2,3],Q=[1,2,3],X=r.create(),Z=[0,0];function $(e,r,n,s){const o=n.length,i=s.length;if(0===o||0===i)return!0;const c=H;u(c,e,r);const a=i<o,f=a?n:s,l=Z;return function(e,r,n){let s=1/0,o=-1/0;for(const e of n){const n=t.dot(r,e);s=Math.min(s,n),o=Math.max(o,n)}e[0]=s,e[1]=o}(l,c,a?s:n),function(e,r,n,s){let o=1/0,i=-1/0;for(const c of s){const s=t.dot(n,c);if(o=Math.min(o,s),i=Math.max(i,s),o<=r&&i>=e)return!1}return!0}(l[0],l[1],c,f)}const ee=430,te=r.create(),re=r.create(),ne=Math.cos(.25*Math.PI),se=r.fromValues(0,0,1),oe=r.create();function ie(e,t,r){const n={t0:0,t1:1};for(const s of d)if(!ae(e[s],t,r,n))return!1;return n.t0<n.t1}function ce(e,t,r){const n={t0:0,t1:1};for(const s of e)if(!ae(s,t,r,n))return!1;return n.t0<n.t1}function ae(e,t,r,n){let{t0:s,t1:o}=n;const i=c.signedDistance(e,t),a=c.signedDistance(e,r);if(i>=0&&a>=0)return!1;if(i<0&&a>=0){const e=-i/(a-i);if(e<s)return!1;e<o&&(o=e)}else if(i>=0&&a<0){const e=i/(i-a);if(e>o)return!1;e>s&&(s=e)}return n.t0=s,n.t1=o,!0}const ue=[c.fromValues(-1,0,0,1),c.fromValues(1,0,0,-1),c.fromValues(0,-1,0,1),c.fromValues(0,1,0,-1),c.fromValues(0,0,-1,1),c.fromValues(0,0,1,-1)],fe=r.freeze(0,0,1);e.FeatureTileVisibility3D=class{constructor(e,t){this._renderCoordsHelper=e,this.opaqueGround=t,this._cache=new Map,this._cameraForward=r.create(),this._cameraEye=r.create(),this._cameraFovY=55*Math.PI/180,this._frustumBoundingSphereCenter=r.create(),this._frustumBoundingSphereRadius=0,this._frustum=new a.Frustum(e),this._renderSR=e.spatialReference;const o=s.getSphericalPCPF(this._renderSR);this._renderSREllipsoidRadius=n.getReferenceEllipsoid(o).radius}setup(e){this._aboveGround=e.aboveGround,this._frustum.update(e),t.normalize(this._cameraForward,e.viewForward),t.copy(this._cameraEye,e.eye),this._cameraFovY=e.fovY,this._updateFrustumBoundingSphere()}done(){this._cache.clear()}compute(e){if(this._cache.has(e.id))return this._cache.get(e.id);const t=this._isVisibleInFrustum(e);return this._cache.set(e.id,t),t}_isVisibleInFrustum(e){return 2===this._renderCoordsHelper.viewingMode?this._isTileVisibleInFrustumLocal(e):this._isTileVisibleInFrustumGlobal(e)}_updateFrustumBoundingSphere(){const e=this._frustum,r=e.origin,n=G;t.normalize(n,e.direction);const s=e.points,o=A;t.sub(o,s[4],r);const i=.5*t.dot(o,o)/t.dot(n,o),c=this._frustumBoundingSphereCenter;t.scaleAndAdd(c,r,n,i);const a=1+i;this._frustumBoundingSphereRadius=a}_isTileVisibleInFrustumLocal(e){const r=e.spatialReference,n=e.extent,s=this._renderSR;if(!n)return!0;if(b[0]=n[0],b[1]=n[1],b[2]=0,b[3]=n[2],b[4]=n[3],b[5]=0,!o.projectBuffer(b,r,0,b,s,0))return!1;t.set(F[0],b[0],b[1],0),t.set(F[1],b[3],b[1],0),t.set(F[2],b[3],b[4],0),t.set(F[3],b[0],b[4],0),t.set(S,.5*(b[0]+b[3]),.5*(b[1]+b[4]),.5*(b[2]+b[5]));const i=se,c=.5*t.dist(F[0],F[2]),a=this._frustum,u=this._frustumBoundingSphereRadius,f=this._frustumBoundingSphereCenter,l=x;t.sub(l,f,S);const d=t.dot(i,l),h=B;if(t.scaleAndAdd(h,S,i,d),t.dist(h,f)>c+u)return!1;const _=this._cameraForward,z=se,v=t.dot(_,z),M=this._cameraFovY,y=this._cameraEye;if(Math.abs(v)<Math.abs(Math.cos(.5*M))){let e=!0;const r=t.set(oe,_[0],_[1],0),n=t.dot(y,r);for(let s=0;s<4;++s){const o=F[s];if(t.dot(o,r)-n>0){e=!1;break}}if(e)return!1}{const e=F[0],t=F[2];if(e[0]<=y[0]&&y[0]<=t[0]&&e[1]<=y[1]&&y[1]<=t[1])return!0}const R=g,V=this.opaqueGround&&this._aboveGround,G=this.opaqueGround&&!this._aboveGround,A=Math.min(G?ee:1/0,d+u),D=Math.max(V?-430:-1/0,d-u);for(let e=0;e<4;++e)t.scaleAndAdd(R[e],F[e],i,A),t.scaleAndAdd(R[e+4],F[e],i,D);if(m(a.planes,R,8))return!1;if(p(a.planes,R,8))return!0;for(let e=0;e<4;++e){const t=R[e],r=R[e+4];if(ie(a.planes,t,r))return!0;const n=R[(e+1)%4];if(ie(a.planes,t,n))return!0;const s=R[4+(e+1)%4];if(ie(a.planes,r,s))return!0}if(ue[0][3]=+F[0][0],ue[1][3]=-F[2][0],ue[2][3]=+F[0][1],ue[3][3]=-F[2][1],ue[4][3]=+D,ue[5][3]=-A,p(ue,a.points))return!0;if(p(ue,a.points))return!0;for(let e=0;e<4;++e){const t=y,r=a.points[e+4];if(ce(ue,t,r))return!0;const n=a.points[4+(e+1)%4];if(ce(ue,r,n))return!0}return!1}_isTileVisibleInFrustumGlobal(e){if(e.level<2)return!0;const n=e.spatialReference,s=e.extent;if(!s||!n)return!0;const o=this.opaqueGround&&this._aboveGround,a=this.opaqueGround&&!this._aboveGround,d=F,h=.5*(s[0]+s[2]);if(t.set(d[0],s[0],s[1],0),t.set(d[1],s[2],s[1],0),t.set(d[2],s[2],s[3],0),t.set(d[3],s[0],s[3],0),t.set(d[4],h,s[1],0),t.set(d[5],h,s[3],0),!i.projectVec3Array(d,n,0,d,this._renderSR,0,6))return!1;const p=d[0][2]>0,g=d[3][2]<0,b=p||g,G=this._renderSREllipsoidRadius;if(b){const e=v;u(e,fe,d[0]);const r=M;if(u(r,fe,d[1]),p){const n=z,s=d[4],o=y;u(o,s,fe),u(n,o,s);const i=d[0];t.cross(i,e,n),l(i,G);const c=d[1];t.cross(c,r,n),l(c,G)}else if(g){const n=z,s=d[5],o=y;u(o,s,fe),u(n,s,o);const i=d[3];t.cross(i,n,e),l(i,G);const c=d[2];t.cross(c,n,r),l(c,G)}}const A=S,B=t.sub(w,d[3],d[0]);t.normalize(B,B);const x=t.add(C,d[0],d[3]);t.scale(x,x,.5);const H=-t.dot(x,B),Z=t.add(P,d[0],d[1]);t.scale(Z,Z,.5);const se=t.add(E,d[2],d[3]);t.scale(se,se,.5);const oe=t.sub(T,se,Z);t.normalize(oe,oe);const ie=-(H+t.dot(B,Z))/t.dot(B,oe);t.scaleAndAdd(A,Z,oe,ie),l(A,G);const ce=this._frustumBoundingSphereRadius,ae=this._frustumBoundingSphereCenter,ue=this._frustum,le=ue.planes,de=R;t.normalize(de,A);const he=t.dot(d[0],de)/t.len(d[0]),me=ue.origin,pe=ue.points;let _e=!1;if(o){{_e=!0;const e=t.normalize(te,me);for(let n=0;n<4;++n){const s=pe[4+n],o=t.sub(r.create(),s,me);t.normalize(o,o);const i=t.cross(r.create(),e,o);t.normalize(i,i);const c=t.cross(r.create(),o,i);if(t.normalize(c,c),t.dot(me,c)>G){_e=!1;break}}}if(_e&&t.dot(me,de)<G*he-ee)return!1;const e=t.normalize(te,ue.origin);if(t.dot(e,de)<0)return!1;{const e=t.normalize(re,ue.direction);if(t.dot(e,de)>ne)return!1}}const ge=Math.sqrt(1-he*he);if(ge>.9)return!0;let be=!1;const Fe=t.dot(de,ae),Se=t.len(ae);if(Se<=ce&&!le.some(e=>c.signedDistance(e,D)>0)){if(!o)return!0;be=!0}const ze=Fe/Se;if(!be&&Fe<=0&&-Fe>ce)return!1;const ve=ce/Se;if(Math.sqrt(1-ze*ze)*Math.sqrt(1-ve*ve)-ve*ze>ge)return!1;if(!_e){if(d.some(e=>ue.intersectsPoint(e)))return!0;if(ue.intersectsPoint(A))return!0}const Me=I;t.sub(Me,ae,D);const ye=t.dot(Me,de),Re=V;t.scale(Re,de,ye);const Ve=t.dist(Re,ae),Ge=n.isWGS84,Ae=e.lij,Be=Ge&&Ae[2]===2**Ae[0]-1,xe=Ge&&0===Ae[2],De=xe?N:Be?J:U,Ie=xe?Q:Be?K:W;if(!be){const e=d,t=X,r=L,n=O,s=D;for(const o of De){const i=e[o];if(f(r,e[(o+1)%4],i),f(n,s,i),u(t,n,r),_(t,pe,1))return!1}}let je=null;if(!o&&ye<1.01*ce){const e=2.5*ce;if(Ve>he*e+ce)return!1;const r=q,n=e/he;for(let e=0;e<4;++e)t.scale(r[e],d[e],n/G);t.set(r[4],0,0,0),je=r}else{const e=(a?G+ee:ye+ce)/he,r=o?G-ee:(ye-ce)/he,n=j;for(let s=0;s<4;++s){const o=d[s];t.scale(n[s],o,r/G),t.scale(n[s+4],o,e/G)}je=n}if(m(le,je,je.length))return!1;const qe=ue.lines,we=k,Ce=Y;for(const e of qe){t.normalize(Ce,e.direction);for(const e of Ie){const r=je[e];if(t.normalize(we,r),$(Ce,we,je,pe))return!1;const n=(e+1)%4;if(o){const e=je[n];if(t.sub(we,e,r),t.normalize(we,we),$(Ce,we,je,pe))return!1}if(a){const r=je[4+e],s=je[4+n];if(t.sub(we,s,r),t.normalize(we,we),$(Ce,we,je,pe))return!1}}}return!0}},e.isAnyVertexInPolyhedron=p,e.isConvexHullOutsideOfFrustum=m,e.maxLODLevelDelta=4,e.minTileLOD=2,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});