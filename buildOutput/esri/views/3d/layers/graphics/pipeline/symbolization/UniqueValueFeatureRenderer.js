// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../PipelineCommand","../featureData/processingUtils","./factoryUtils","./IconSymbolLayerRenderer","./ObjectSymbolLayerRenderer"],function(e,t,n,a,o,i){"use strict";class r{constructor(e,t){this.index=e,this.features=t}}e.UniqueValueFeatureRenderer=class{constructor(e,t){this._symbols=new Array,this._featureDataPartitioning=new Map,this._loaded=!1,this._loadingPromise=null,this._renderer=null,this._context=t,this._renderer=e}async load(){return null==this._loadingPromise&&(this._loadingPromise=this._load()),this._loadingPromise}async _load(){this._symbols[0]=new o.IconSymbolLayerRenderer(a.createDefaultIconSymbolLayer(),this._context),this._symbols[1]=new i.ObjectSymbolLayerRenderer(a.createDefaultObjectSymbolLayer(),this._context),this._loaded=!0}get loaded(){return this._loaded}async createAddCommand(e){const t=this._context,n=this._partition(e),a=await Promise.all(n.map(async({index:e,features:t})=>{const n=await this._provisionSymbol(e);return await(n?.createAddCommand(t))})),o=t.joinPipelineCommands(a);return o.appendPipelineStateCommand(()=>this._featureDataPartitioning.set(e.id,n)),o}async createRemoveCommand(e){const{_featureDataPartitioning:n,_context:a}=this,o=a.renderCommandContext,i=n.get(e);if(null==i)return new t.PipelineCommand(o,o.createRenderCommandBuffer(),[]);const r=await Promise.all(i.map(async({index:e,features:t})=>{const n=this._getLoadedSymbol(e);return await(n?.createRemoveCommand(t.id))})),s=a.joinPipelineCommands(r);return s.appendPipelineStateCommand(()=>n.delete(e)),s}async createUpdateVisibilityCommand(e){const{_featureDataPartitioning:n,_context:a}=this,o=a.renderCommandContext,i=n.get(e.id);if(null==i)return new t.PipelineCommand(o,o.createRenderCommandBuffer(),[]);const r=await Promise.all(i.map(async({index:e,features:t})=>{const n=this._getLoadedSymbol(e);return await(n?.createUpdateVisibilityCommand(t))}));return a.joinPipelineCommands(r)}async createUpdateLayerViewOpacityCommand(e){const t=this._context,n=[];for(let t=0;t<this._symbols.length;++t){const a=this._symbols[t];null!=a&&a.loaded&&n.push(a.createUpdateLayerViewOpacityCommand(e))}const a=await Promise.all(n);return t.joinPipelineCommands(a)}async createUpdateElevationCommand(){const{_featureDataPartitioning:e,_context:t}=this,n=[];for(const t of e.values()){const e=t.map(async({index:e,features:t})=>{const n=this._getLoadedSymbol(e);return await(n?.createUpdateElevationCommand(t))});n.push(...e)}const a=await Promise.all(n);return t.joinPipelineCommands(a)}async createDestroyCommand(){const{_featureDataPartitioning:e,_context:t}=this,n=[];for(const t of e.keys())n.push(this.createRemoveCommand(t));for(const e of this._symbols)n.push(e.createDestroyCommand());const a=await Promise.all(n);return t.joinPipelineCommands(a)}async _provisionSymbol(e){if(null==e)return null;const t=this._symbols[e];return t?(t.loaded||await t.load(),t):null}_getLoadedSymbol(e){if(null==e)return null;const t=this._symbols[e];return null!=t&&t.loaded?t:null}_partition(e){const t=n.readObjectIds(e);if(null==t)throw new Error("unable to fetch objectIds");const{featureCount:a}=e,o=[[],[]];for(let e=0;e<a;++e)o[t[e]%2].push(e);return o.map((t,n)=>new r(n,e.subset(new Uint32Array(t)))).filter(e=>e.features.featureCount>0)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});