// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/projection/computeTranslationToOriginAndRotation","../../../../geometry/projection/projectBuffer","./elevationAlignmentUtils","../../support/debugFlags","../../support/ElevationProvider","../../webgl-engine/lib/GeometryWithMapPositions"],function(e,t,n,o,a,i,r,s,l,c,u){"use strict";const f=n.create(),p=.01,g=a.create(),m=a.create(),d=a.create(),b=n.create(),T=a.create(),S=new s.SampleElevationInfo;function v(e,t,n,o,a){let i=!1;const s=e.transformation,u=t.requiresSampledElevationInfo;m[0]=s[12],m[1]=s[13],m[2]=s[14],e.invalidateBoundingInfo();const f=e.getMutableAttribute("position"),b=f.data,T=f.size,v=b.length/T,I=new c.SamplePosition(e.mapPositions,n);let h=0,E=0;for(let e=0;e<v;e++){if(d[0]=b[h],d[1]=b[h+1],d[2]=b[h+2],o(I,S),u&&(E+=S.sampledElevation),l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS)b[h]=I.array[I.offset],b[h+1]=I.array[I.offset+1],b[h+2]=S.z,r.projectBuffer(b,n,h,b,a.spatialReference,h,1),b[h]-=m[0],b[h+1]-=m[1],b[h+2]-=m[2],i=!0;else{g[0]=b[h]+m[0],g[1]=b[h+1]+m[1],g[2]=b[h+2]+m[2],a.setAltitude(g,S.z),b[h]=g[0]-m[0],b[h+1]=g[1]-m[1],b[h+2]=g[2]-m[2];const e=p/a.unitInMeters;(Math.abs(d[0]-b[h])>=e||Math.abs(d[1]-b[h+1])>=e||Math.abs(d[2]-b[h+2])>=e)&&(i=!0)}h+=T,I.offset+=3}return E/=v,{update:i,averageGeometrySampledElevation:E}}e.perLodInstanceElevationAligner=function(e,t,n,a,r){const s=e.graphics3DSymbolLayer.lodRenderer;if(null==s)return 0;const c=t.centerPointInElevationSR;a(c,S);const u="absolute-height"!==t.mode?S.sampledElevation:0,f=s.instanceData,m=e.instanceIndex,d=b;f.getGlobalTransform(m,d);const v=o.set(T,d[12],d[13],d[14]);l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS?(g[0]=c.x,g[1]=c.y,g[2]=S.z,i.computeTranslationToOriginAndRotation(c.spatialReference,g,d,r.spatialReference)&&f.setGlobalTransform(m,d)):r.setAltitudeOfTransformation(S.z,d);const I=p/r.unitInMeters;return(l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(d[12]-v[0])>=I||Math.abs(d[13]-v[1])>=I||Math.abs(d[14]-v[2])>=I)&&f.setGlobalTransform(m,d),u},e.perObjectElevationAligner=function(e,n,a,r,c,u){const m=e.stageObject,d=n.centerPointInElevationSR;let b=0;m.usesVerticalDistanceToGround?(r(d,S),s.updateVertexPointGroundDistance(m,S.verticalDistanceToGround),b=S.sampledElevation):(r(d,S),"absolute-height"!==n.mode&&(b=S.sampledElevation));const v=t.copy(f,u??m.transformation),I=o.set(T,v[12],v[13],v[14]);l.debugFlags.TESTS_DISABLE_OPTIMIZATIONS?(g[0]=d.x,g[1]=d.y,g[2]=S.z,i.computeTranslationToOriginAndRotation(d.spatialReference,g,v,c.spatialReference)&&(u?t.copy(u,v):m.transformation=v)):c.setAltitudeOfTransformation(S.z,v);const h=p/c.unitInMeters;return(Math.abs(v[12]-I[0])>=h||Math.abs(v[13]-I[1])>=h||Math.abs(v[14]-I[2])>=h)&&(u?t.copy(u,v):m.transformation=v),b},e.perVertexElevationAligner=function(e,t,n,o,a){const i=e.stageObject,r=i.geometries;let s=0;for(const e of r){if(!u.isGeometryWithMapPositions(e))continue;const{update:r,averageGeometrySampledElevation:l}=v(e,t,n,o,a);s+=l,r&&i.geometryVertexAttributeUpdated(e,"position")}return s/r.length},e.sharedGeometryElevationAligner=function(e,t,n,o,a){const i=e.stageObject,r=i.geometries;if(0===r.length)return 0;let s=0,l=null,c=0,f=!1;for(const e of r){if(!u.isGeometryWithMapPositions(e))continue;const r=e.attributes.get("position");if(r!==l){const{update:i,averageGeometrySampledElevation:s}=v(e,t,n,o,a);c=s,l=r,f=i}f&&i.geometryVertexAttributeUpdated(e,"position"),s+=c}return s/r.length},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});