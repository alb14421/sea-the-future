// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../request","../../../../core/asyncUtils","../../../../core/Error","../../../../core/Logger","../../../../core/memoryEstimations","../../../../core/NestedMap","../../../../core/promiseUtils","../../../../core/Version","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/Indices","../../../../support/requestImageUtils","../../webgl-engine/lib/Attribute","../../webgl-engine/lib/Geometry","../../webgl-engine/lib/Texture","../../webgl-engine/materials/DefaultMaterial"],function(e,t,r,n,s,a,o,i,u,l,c,p,d,f,m,y,g){"use strict";const w=()=>s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");class x{constructor(e,t,r){this.resource=e,this.textures=t,this.cachedMemory=r}}function h(e){throw new n("",`Request for object resource failed: ${e}`)}function b(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(w().warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t?.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(w().warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(w().warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(w().warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else w().warn("Indexed geometries must specify faces"),n=!1;break}default:w().warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(w().warn("Geometry requires material"),n=!1);const s=e.params.vertexAttributes;for(const e in s)s[e].values||(w().warn("Geometries with externally defined attributes are not yet supported"),n=!1);return n}function v(e){const t=c.empty();return e.forEach(e=>{const r=e.boundingInfo;null!=r&&(c.expandWithVec3(t,r.bbMin),c.expandWithVec3(t,r.bbMax))}),t}async function A(e,t){const r=new Array;for(const n in e){const s=e[n],a=s.images[0].data;if(!a){w().warn("Externally referenced texture data is not yet supported");continue}const o=s.encoding+";base64,"+a,i="/textureDefinitions/"+n,u="rgba"===s.channels?s.alphaChannelUsage||"transparency":"none",l={noUnpackFlip:!0,wrap:{s:10497,t:10497},preMultiplyAlpha:1!==M(u)},c=t?.disableTextures?Promise.resolve(null):d.requestImage(o,t);r.push(c.then(e=>({refId:i,image:e,parameters:l,alphaChannelUsage:u})))}const n=await Promise.all(r),s={};for(const e of n)s[e.refId]=e;return s}function M(e){switch(e){case"mask":return 2;case"maskAndTransparency":return 3;case"none":return 1;default:return 0}}function I(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const P=new u.Version(1,2,"wosr");e.LoaderResultWOSR=x,e.createTextureResources=A,e.load=async function(e,n){const s=await async function(e,n){const s=n?.streamDataRequester;if(s)return async function(e,t,n){const s=await r.result(t.request(e,0,n));return!0===s.ok?s.value:(i.throwIfAbortError(s.error),void h(s.error.details.url))}(e,s,n);const a=await r.result(t(e,n));return!0===a.ok?a.value.data:(i.throwIfAbortError(a.error),void h(a.error))}(e,n),o=await A(s.textureDefinitions??{},n);let u=0;for(const e in o)if(o.hasOwnProperty(e)){const t=o[e];u+=t?.image?t.image.width*t.image.height*4:0}return new x(s,o,u+a.estimateNestedObjectMemory(s))},e.processLoadResult=function(e,t){const r=new Array,n=new Array,s=new Array,a=new o.NestedMap,i=e.resource,c=u.Version.parse(i.version||"1.0","wosr");P.validate(c);const d=i.model.name,w=i.model.geometries,x=i.materialDefinitions??{},h=e.textures;let A=0;const U=new Map;for(let e=0;e<w.length;e++){const o=w[e];if(!b(o))continue;const i=I(o),u=o.params.vertexAttributes,c=[],d=e=>{if("PerAttributeArray"===o.params.topology)return null;const t=o.params.faces;for(const r in t)if(r===e)return t[r].values;return null},v=u.position,P=v.values.length/v.valuesPerElement;for(const e in u){const t=u[e],r=t.values,n=d(e)??p.getContinuousIndexArray(P);c.push([e,new f.Attribute(r,n,t.valuesPerElement,!0)])}const E=i.texture,T=h&&h[E];if(T&&!U.has(E)){const{image:e,parameters:t}=T,r=new y.Texture(e,t);n.push(r),U.set(E,r)}const O=U.get(E),R=O?O.id:void 0,k=i.material;let q=a.get(k,E);if(null==q){const e=x[k.slice(k.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=T?M(T.alphaChannelUsage):void 0,n={ambient:l.fromArray(e.diffuse),diffuse:l.fromArray(e.diffuse),opacity:1-(e.transparency||0),textureAlphaMode:r,textureAlphaCutoff:.33,textureId:R,doubleSided:!0,cullFace:0,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:T?.parameters.preMultiplyAlpha??!1};t?.materialParameters&&Object.assign(n,t.materialParameters),q=new g.DefaultMaterial(n,t),a.set(k,E,q)}s.push(q);const C=new m.Geometry(q,c);A+=c.find(e=>"position"===e[0])?.[1]?.indices.length??0,r.push(C)}return{engineResources:[{name:d,stageResources:{textures:n,materials:s,geometries:r},pivotOffset:i.model.pivotOffset,numberOfVertices:A,lodThreshold:null}],referenceBoundingBox:v(r)}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});