// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../Color","../../../../core/has","../../../../core/Error","../../../../core/libs/gl-matrix-2/math/mat4","../../../../core/libs/gl-matrix-2/factories/mat4f64","../../../../core/libs/gl-matrix-2/math/vec2","../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../chunks/vec32","../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../geometry/projection/projectBuffer","../../../../geometry/support/aaBoundingBox","../../../../geometry/support/DoubleArray","../../../../geometry/support/FloatArray","./elevationAlignmentUtils","./Graphics3DObject3DGraphicLayer","./Graphics3DPathSymbolLayerConstants","./Graphics3DSymbolLayer","./graphicUtils","../support/FastSymbolUpdates","../../support/ElevationProvider","../../webgl-engine/lib/Object3D","../../webgl-engine/lib/Path","../../webgl-engine/lib/PathBuilder","../../webgl-engine/lib/PathCapBuilder","../../webgl-engine/lib/PathExtruder","../../webgl-engine/lib/PathGeometry","../../webgl-engine/lib/PathGeometryData","../../webgl-engine/lib/pathGeometryUtils","../../webgl-engine/lib/PathProfile","../../webgl-engine/lib/PathVertex","../../webgl-engine/materials/DefaultMaterial","../../webgl-engine/materials/PathMaterial"],function(e,t,i,a,r,s,n,o,l,h,c,p,u,d,m,f,g,b,_,y,v,x,w,S,C,P,D,V,A,E,U,R,B){"use strict";const z=["polyline"];class G extends b.Graphics3DSymbolLayer{constructor(e,t,i,a){super(e,t,i,a,function(e){return 1===(e.material?.color?.a??0)}(t)),this._intrinsicSize=o.fromValues(1,1),this._upVectorAlignment=1,this._stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const e=this.symbolLayer,t=null!=e.width?e.width:e.height,i=null!=e.height?e.height:t;this._vvConvertOptions=new y.ConvertOptions({supports:{size:!0,color:!0,rotation:!1,opacity:!0},modelSize:[1,1,1],symbolSize:[t,1,i],unitInMeters:this._context.renderCoordsHelper.unitInMeters,fallbackColor:this._getFallbackOpacityAndColor(b.nanFallbackColor),fallbackSize:[t,1,i]});const r=this._context.renderer?.visualVariables;this._fastUpdates=r?.length?y.initFastSymbolUpdatesState(this._context.renderer,this._vvConvertOptions):null;const s=e.anchor||"center";this._upVectorAlignment="heading"===e.profileRotation?0:1;const l=e.profile||"circle";switch(l){default:case"circle":this._profile=E.circleProfiles[s];break;case"quad":this._profile=E.quadProfiles[s]}switch(e.join){case"round":this._extruder=new P.MiterExtruder(0,g.pathNumRoundJoinSubdivisions);break;case"bevel":this._extruder=new P.MiterExtruder(0,1);break;case"miter":this._extruder=new P.MiterExtruder(.8*Math.PI,1);break;default:this._extruder=new P.SimpleExtruder}switch(this._cap){case"none":this._startCap=new C.NoCapBuilder,this._endCap=new C.NoCapBuilder;break;case"butt":default:this._startCap=new C.TriangulationCapBuilder(this._profile,0),this._endCap=new C.TriangulationCapBuilder(this._profile,0,!0);break;case"square":this._startCap=new C.TriangulationCapBuilder(this._profile,-.5),this._endCap=new C.TriangulationCapBuilder(this._profile,.5,!0);break;case"round":{const e="quad"===l;this._startCap=new C.RoundCapBuilder({profile:this._profile,flip:!1,breakNormals:e,subdivisions:g.pathNumRoundCapExtrusionSubdivisions}),this._endCap=new C.RoundCapBuilder({profile:this._profile,flip:!0,breakNormals:e,subdivisions:g.pathNumRoundCapExtrusionSubdivisions});break}}const c=this._materialColor,p=this._getCombinedOpacityAndColor(c),u=h.fromArray(p),d=p[3],m=this.needsDrivenTransparentPass,f=e.material?.emissive,v={diffuse:u,ambient:u,emissiveStrength:f?.strength??0,emissiveSource:1,opacity:d,drivenOpacity:m,hasVertexColors:!1,hasSlicePlane:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(n.set(this._intrinsicSize,t,i),!_.isValidSize(this._intrinsicSize[0])||!_.isValidSize(this._intrinsicSize[1])))throw new a("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");let x;this._fastUpdates?.visualVariables.size||n.scale(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates?x=new B.PathMaterial({...v,...this._fastUpdates.materialParameters,size:o.fromArray(this._intrinsicSize)},this._context):(v.hasVertexColors=this._drivenProperties.color||this._drivenProperties.opacity,v.normalType=1,x=new R.DefaultMaterial(v,this._context)),x.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._materials[0]=x,this._updateTransparentDepedentMaterialParameters()}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,z,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t);return this._createAs3DShape(e,i)}layerOpacityChanged(){const e=this._materialColor,t=this._getCombinedOpacity(e),i=this._materials[0];i&&(i.setParameters({opacity:t}),this._updateTransparentDepedentMaterialParameters())}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,m.needsElevationUpdates3D)}slicePlaneEnabledChanged(){return this._materials[0]?.setParameters({hasSlicePlane:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._materials[0]?.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}applyRendererDiff(e,t){for(const i in e.diff){if("visualVariables"!==i)return 0;if(!y.updateFastSymbolUpdatesState(this._fastUpdates,t,this._vvConvertOptions))return 0;this._materials[0]?.setParameters(this._fastUpdates.materialParameters)}return 2}_getVertexData(e){let t=0;const i=e.paths,a=[],r=e.spatialReference,s=this._context.elevationProvider.spatialReference,n=this._context.renderCoordsHelper.spatialReference;for(const e of i)t+=e.length;const o=u.newDoubleArray(3*t);let l,h=0;for(const t of i){a.push({offset:h,numVertices:t.length});for(const i of t)o[h++]=i[0],o[h++]=i[1],o[h++]=e.hasZ?i[2]:0}return null==s||r.equals(s)||c.projectBuffer(o,r,0,o,s,0,t)?(null==s||s.equals(n)?l=u.doubleArrayFrom(o):(l=u.newDoubleArray(3*t),c.projectBuffer(o,s,0,l,n,0,t)),{pathVertexDataInfos:a,vertexDataES:o,vertexDataRS:l}):null}_createAs3DShape(e,t){const{graphic:i,renderingInfo:a}=e,n=i.geometry,h=this._getVertexData(n);if(null==h)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(0===h.pathVertexDataInfos.length)return 0!==n.paths.length&&n.paths.some(e=>e.length>0)||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)"),null;const c=new Array,u=n.spatialReference,g=p.create(),b=this._context.renderCoordsHelper,_=new v.SamplePosition(h.vertexDataES),C=i.uid,P=d.newFloatArray(h.vertexDataRS.length);for(const e of h.pathVertexDataInfos){const n=e.numVertices;if(n<2)continue;const d=e.offset;if(null!=this._context.clippingExtent&&(p.fromSubBuffer(h.vertexDataES,d,n,g),!p.intersectsClippingArea(g,this._context.clippingExtent)))continue;const f=new Array,v=d+3*n;for(let e=d;e<v;e+=3){_.offset=e;const i=m.evaluateElevationAlignmentAtPoint(_,this._context.elevationProvider,t,b);l.set(I,h.vertexDataRS[e],h.vertexDataRS[e+1],h.vertexDataRS[e+2]),b.setAltitude(I,i),h.vertexDataRS[e]=I[0],h.vertexDataRS[e+1]=I[1],h.vertexDataRS[e+2]=I[2],f.push(U.newPathVertex(this._upVectorAlignment))}const x=new w.Path(f,h.vertexDataES,h.vertexDataRS,d,P);k(x,this._upVectorAlignment,this._context.renderCoordsHelper);const A=new S.PathBuilder(x,this._profile,this._extruder,this._startCap,this._endCap);let E=null;if(this._fastUpdates){const e=this._fastUpdates.visualVariables,t=y.getAttributeValue(e.size?.field,i),a=y.getAttributeValue(e.color?.field,i),r=y.getAttributeValue(e.opacity?.field,i);E=new V.FastUpdatePathGeometry(A,t,a,r)}else{const e=o.clone(this._intrinsicSize);if(this._drivenProperties.size){const t=a.size??["symbol-value","symbol-value","symbol-value"];e[0]*=L(t[0],"symbol-value"===t[2]?this.symbolLayer.height||0:t[2],this.symbolLayer.width||0),e[1]*=L(t[2],"symbol-value"===t[0]?this.symbolLayer.width||0:t[0],this.symbolLayer.height||0)}const t=new V.StaticPathGeometry(A);t.bake(e);const i=this._getDrivenColor(a);i&&t.bakeVertexColors(i),E=t}const R=E.createGeometryData(),B=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:C,layerViewUid:this._context.layerViewUid}),z=new D.PathGeometry(this._materials[0],R,E,u,this._stencilWidth,B);z.transformation=r.translate(s.create(),s.IDENTITY,A.path.origin),c.push(z)}if(0===c.length)return null;const A=new x.Object3D({geometries:c,layerViewUid:this._context.layerViewUid,graphicUid:C}),E=new f.Graphics3DObject3DGraphicLayer(this,A,null,(e,t,i,a,r)=>function(e,t,i,a,r){const s=e.stageObject,n=s.geometries;let o=0;for(const e of n){if(!D.isPathGeometry(e))continue;const t=e.path,n=t.builder.path;o+=O(n,0,i,a),0!==r&&k(n,r,a),t.onPathChanged(e),e.invalidateBoundingInfo(),s.geometryVertexAttributeUpdated(e,"position")}return o/n.length}(e,0,a,r,this._upVectorAlignment),t,null);return E.alignedSampledElevation=0,E.needsElevationUpdates=m.needsElevationUpdates3D(t.mode),E}_getDrivenColor(e){return this._hasDrivenColorOrOpacity?this._getDrivenUInt8ColorWithNaNSupport(e,this._materialColor,!1):null}get _materialColor(){return this.symbolLayer.material?.color}_getFallbackOpacityAndColor(e){return t.toUnitRGBA(this._materialColor)??e}get _cap(){return this.symbolLayer.cap||"butt"}_updateTransparentDepedentMaterialParameters(){const e=this._materials[0];e&&e.setParameters({cullFace:e.transparent||"none"===this._cap?0:2})}}function k(e,t,i){const{origin:a,positions:r}=e;let s=e.offset;switch(t){default:case 0:for(const t of e.vertices)I[0]=r[s++]+a[0],I[1]=r[s++]+a[1],I[2]=r[s++]+a[2],i.worldUpAtPosition(I,I),t.setFrameFromUpVector(I);break;case 1:I[0]=r[s]+a[0],I[1]=r[s+1]+a[1],I[2]=r[s+2]+a[2],i.worldUpAtPosition(I,I),A.computeMinimumRotationTangentFrame(e,I)}}function L(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function O(e,t,i,a){let r=0;const{origin:s,vertices:n,positions:o,positionsES:h}=e,c=e.offset+3*n.length;for(let t=e.offset;t<c;t+=3)l.set(I,h[t],h[t+1],h[t+2]),i(I,M),r+=M.sampledElevation,I[0]=o[t]+s[0],I[1]=o[t+1]+s[1],I[2]=o[t+2]+s[2],a.setAltitude(I,M.z),o[t]=I[0]-s[0],o[t+1]=I[1]-s[1],o[t+2]=I[2]-s[2];return e.updatePathVertexInformation(),r/n.length}const I=h.create(),M=new m.SampleElevationInfo;e.Graphics3DPathSymbolLayer=G,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});