// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/mathUtils","../../../../../core/quantityUtils","../../../../../core/unitUtils","../../../../../core/libs/gl-matrix-2/math/vec2","../../../../../core/libs/gl-matrix-2/factories/vec2f64","../../../../../chunks/vec32","../../../../../core/libs/gl-matrix-2/factories/vec3f64","../../../../../core/libs/gl-matrix-2/factories/vec4f64","../../../../../geometry/ellipsoidUtils","../../../../../geometry/projectionUtils","../../../../../geometry/spatialReferenceEllipsoidUtils","../../../../../geometry/projection/projectDirection","../../../../../geometry/projection/projectPointToVector","../../../../../geometry/projection/projectVectorToVector","../../../../../geometry/support/Indices","../../../../../geometry/support/intersectsBase","../../../../../chunks/sphere","../../../../../geometry/support/triangle","../../support/measurementUtils","../../../support/ElevationProvider","../../../support/mathUtils","../../../../support/euclideanAreaMeasurementUtils","../../../../support/euclideanLengthMeasurementUtils","../../../../support/geodesicMeasurementUtils","../../../../support/measurementUtils"],function(e,t,s,i,n,o,r,h,a,l,c,d,g,p,u,m,_,S,f,P,L,M,C,R,U,A){"use strict";e.MeasurementDataManager=class{get numVertices(){return this._length}get hasStagedVertex(){return null!=this._lastCursorPoint}constructor(e,t,s){this._sceneView=e,this._geodesicAreaMeasurementUtils=t,this._geodesicLengthMeasurementUtils=s,this.validMeasurement=!1,this.positionsWorld=[],this.positionsRender=[],this.positionsFittedWorld=[],this.positionsFittedRender=[],this.positionsGeodesic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=h.create(),this.areaCentroidRenderCoords=h.create(),this.geodesicAreaCentroidRenderCoords=h.create(),this.fittingMode=null,this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=h.create(),this._planeWorldCoords=a.create(),this._worldUp=h.create(),this._worldTangent=h.create(),this._frame=[h.create(),h.create(),h.create()],this._lastPathVersion=-1,this._lastCursorPoint=null,this._mode=null,this._tempU=h.create(),this._tempV=h.create(),this._tempVec3=h.create(),this._tempSphere=S.create();const n=A.computeEuclideanMeasurementSR(e.spatialReference);this._measurementSR=n,this._lengthMeasurementUnit=i.lengthUnitFromSpatialReference(n)??"meters",this._areaMeasurementUnit=i.areaUnitFromSpatialReference(n)??"square-meters"}update(e,t,s,i,n,o){const r=this._lastPathVersion===e.version,h=t?t.equals(this._lastCursorPoint):null==this._lastCursorPoint,a=this._mode===n;return!(r&&!o&&a&&h||(this._lastPathVersion=e.version,this._lastCursorPoint=t,this._updateCursorSegmentLength(e,t),this._update(e,t,s,i,n),0))}_update(e,t,i,n,o){const h=this._sceneView.renderSpatialReference,a=this._measurementSR,l=i.spatialReference;let g=e.numVertices;const u=!(null==t||t.equals(e.lastPoint)||g>2&&t.equals(e.firstPoint)||e.polygonIsClosed);u&&(g+=1);const m=!e.polygonIsClosed&&g>2,_=e.polygonIsClosed||m;this._resize(g);const S=d.getSphericalPCPF(l),f=null!=l&&U.supportsGeodesicMeasurement(l)?l:null,P=null!=f&&c.canProjectWithoutEngine(l,S),{positionsGeodesic:M,positionsWorld:C,positionsRender:R,positionsSpherical:A}=this,V=(e,t)=>{!function(e,t){t.hasZ||(t.z=L.getElevationAtPoint(e,t,"ground")??0)}(i.elevationProvider,e),p.projectPointToVector(e,C[t],a),p.projectPointToVector(e,R[t],h),P&&(p.projectPointToVector(e,M[t],f),p.projectPointToVector(e,A[t],S),r.normalize(A[t],A[t]))};e.forEachVertexPosition((e,t)=>V(e,t)),u&&V(t,g-1);const v=this._updatePathLengths(_);if(this.pathLength=this._length>1?s.createLength(v,this._lengthMeasurementUnit):null,P){const e=this._updateGeodesicPathLengths(_,f);this.geodesicPathLength=null!=e&&this._length>1?e:null}else this.geodesicPathLength=null;if(this._updateMode(o),!_)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),void(this.validMeasurement=!1);this._updateAreaAndPerimeterLength(i,h,a,n),P&&this._updateGeodesicArea(i,f),this.validMeasurement=!0}getData(){return{validMeasurement:this.validMeasurement,numVertices:this.numVertices,hasStagedVertex:this.hasStagedVertex,positionsRender:this.positionsRender,positionsFittedWorld:this.positionsFittedWorld,positionsFittedRender:this.positionsFittedRender,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorld.length=e,this.positionsRender.length=e,this.positionsFittedWorld.length=e,this.positionsFittedRender.length=e,this.positionsGeodesic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorld.push(h.create()),this.positionsRender.push(h.create()),this.positionsFittedWorld.push(o.create()),this.positionsFittedRender.push(h.create()),this.positionsGeodesic.push(h.create()),this.positionsSpherical.push(h.create()),this.positionsStereographic.push(o.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorld,s=this.pathSegmentLengths;let i=0;const n=this._length;for(let o=0;o<n;++o){const h=s[o]=r.distance(t[o],t[(o+1)%n]);(o<n-1||e)&&(i+=h)}return i}_updateGeodesicPathLengths(e,t){const i=this.positionsGeodesic,n=this.geodesicPathSegmentLengths;let o=0;const r=this._length;for(let h=0;h<r;++h){const a=this._geodesicLengthMeasurementUtils.geodesicDistance(i[h],i[(h+1)%r],t);if(null==a)return null;const l=s.toUnit(a,"meters").value,c=n[h]=l;(h<r-1||e)&&(o+=c)}return s.createLength(o,"meters")}_updateAreaAndPerimeterLength(e,t,s,i){const o=e.renderCoordsHelper,h=this.positionsWorld,a=this.positionsRender,l=this.positionsFittedWorld,c=this.positionsFittedRender,d=this._planeWorldCoords,p=this._centroidRenderCoords;M.midpoint3d(a,p),o.worldUpAtPosition(p,this._worldUp),o.worldBasisAtPosition(p,0,this._worldTangent),g.projectDirection(p,this._worldUp,t,this._worldUp,s),g.projectDirection(p,this._worldTangent,t,this._worldTangent,s),h.length>2&&P.bestFitPlane(h,d),this.fittingMode=this._selectFittingMode(d,h,this._worldUp,i);let m=0;if("horizontal"===this.fittingMode){let e=-1/0;a.forEach((t,s)=>{const i=o.getAltitude(a[s]);i>e&&(e=i,m=s)})}const _=h[m];let S=d,f=this._worldTangent;"horizontal"===this.fittingMode?S=this._worldUp:"vertical"===this.fittingMode&&(S=this._tempVec3,f=this._worldUp,M.makeOrthonormal(d,this._worldUp,S)),r.copy(this._frame[2],S),M.makeOrthonormal(f,S,this._frame[0]),r.cross(this._frame[1],this._frame[0],this._frame[2]),r.negate(this._frame[1],this._frame[1]);const L=this._tempVec3,C=this._tempU,R=this._tempV;for(let e=0;e<this._length;++e){const i=l[e],o=c[e];r.subtract(L,h[e],_),n.set(i,r.dot(this._frame[0],L),r.dot(this._frame[1],L)),r.scale(C,this._frame[0],i[0]),r.scale(R,this._frame[1],i[1]),r.add(L,C,R),r.add(L,L,_),u.projectVectorToVector(L,s,o,t)}this.perimeterLength=this._length>0?this._updatePerimeterLengths():null,M.midpoint3d(c,this.areaCentroidRenderCoords),u.projectVectorToVector(this.areaCentroidRenderCoords,t,this.areaCentroidWorldCoords,s),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?this._computeArea():null}_updateGeodesicArea(e,t){const{renderCoordsHelper:s,spatialReference:i}=e,{positionsSpherical:o,positionsStereographic:h}=this,a=this._tempVec3,c=P.fitHemisphere(o,a);if(!c)return void(this.geodesicArea=null);const g=this._tempU,p=this._tempV;M.tangentFrame(a,g,p);for(let e=0;e<this._length;++e){const t=r.dot(o[e],g),s=r.dot(o[e],p),i=r.dot(o[e],a);n.set(h[e],t/i,s/i)}r.scale(a,a,l.getReferenceEllipsoid(i).radius),s.toRenderCoords(a,d.getSphericalPCPF(i),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=c&&0===this.geodesicIntersectingSegments.size?this._computeGeodesicArea(t):null}_updatePerimeterLengths(){const e=this.positionsFittedWorld,t=this.perimeterSegmentLengths;let i=0;for(let s=0;s<this._length;++s)i+=t[s]=n.distance(e[s],e[(s+1)%this._length]);return s.createLength(i,this._lengthMeasurementUnit)}_updateIntersectingSegments(){const e=this.positionsFittedWorld,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const n=e[s],o=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];_.segmentIntersects(n,o,r,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsFittedWorld,t=this.triangleIndices=m.compactIndices(C.triangulate(e));let i=0;for(let s=0;s<t.length;s+=3)i+=f.areaPoints2d(e[t[s]],e[t[s+1]],e[t[s+2]]);return s.createArea(i,this._areaMeasurementUnit)}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const n=e[s],o=e[(s+1)%this._length],r=e[i],h=e[(i+1)%this._length];_.segmentIntersects(n,o,r,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(e){const t=this.positionsGeodesic,i=this.positionsStereographic,n=this.geodesicTriangleIndices=m.compactIndices(C.triangulate(i));let o=0;for(let i=0;i<n.length;i+=3){const r=P.triangleAreaGeodesic(t[n[i]],t[n[i+1]],t[n[i+2]],e,this._geodesicAreaMeasurementUtils);if(null==r)return null;o+=s.toUnit(r,"square-meters").value}return s.createArea(o,"square-meters")}_selectFittingMode(e,s,i,n){const o=s.map(t=>Math.abs(P.planePointDistance(e,t))).reduce((e,t)=>Math.max(e,t),0);P.boundingSphere(s,this._tempSphere);const h=o/(2*this._tempSphere[3]),a=h<n.maxRelativeErrorCoplanar,l=h<n.maxRelativeErrorAlmostCoplanar;let c="horizontal";return a?c="oblique":l&&(c=Math.abs(r.dot(i,e))>Math.cos(t.deg2rad(n.verticalAngleThreshold))?"horizontal":"vertical"),c}_updateCursorSegmentLength(e,t){const s=e.lastPoint;e.isValidPolygon||null==s||null==t?(this.geodesicStagedSegmentLength=null,this.stagedSegmentLength=null):(this.geodesicStagedSegmentLength=this._geodesicLengthMeasurementUtils.geodesicDistanceBetweenPoints(s,t),this.stagedSegmentLength=R.euclideanDistanceBetweenPoints(s,t)?.direct)}_updateMode(e){if(0===e){this.actualMeasurementMode="euclidean";let e=0;null!=this.geodesicPathLength&&(e+=this.geodesicPathLength.value),e>1e5&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=1===e?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=e}},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});