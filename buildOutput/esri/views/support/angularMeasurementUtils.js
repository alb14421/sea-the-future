// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/Cyclical","../../core/quantityUtils","../../core/unitUtils","../../core/libs/gl-matrix-2/math/vec2","../../core/libs/gl-matrix-2/factories/vec2f64","../../chunks/vec32","../../core/libs/gl-matrix-2/factories/vec3f64","../../geometry/projection/projectVectorToVector","../../geometry/support/geodesicUtils","../../geometry/support/spatialReferenceUtils"],function(e,t,r,n,o,c,i,a,l,s,u){"use strict";function g(e,t){if(null==e||null==t)return;const n=p(e,t);return null!=n?r.createAngle(n,"radians","geographic"):void 0}const p=(()=>{const e=a.create(),t=a.create();return(r,n)=>(i.set(e,r.x,r.y,r.z??0),i.set(t,n.x,n.y,n.z??0),d(e,t,r.spatialReference,n.spatialReference))})(),d=(()=>{const e=c.create(),t=a.create(),r=a.create();return(a,g,p,d)=>{if(i.exactEquals(a,g))return;const f=s.geodesicCompatibleSpatialReference(p),v=s.geodesicCompatibleSpatialReference(d);if(f&&v&&u.equals(f,v)&&l.projectVectorToVector(a,p,t,f)&&l.projectVectorToVector(g,d,r,v)){const{azimuth:e}=s.inverseGeodeticSolver(T,t,r,f);return null!=e?n.convertUnit(e,"degrees","radians"):void 0}e[0]=g[0]-a[0],e[1]=g[1]-a[1];let h=o.angle(c.UNIT_Y,e);return e[0]<0&&(h=V-h),h}})();function f(e,t,n){if(!e||!t||!n)return;const o=p(e,t),c=p(t,n);return null!=o&&null!=c?r.createAngle(c-o,"radians","geographic"):void 0}function v(e,t){if(null!=e)switch(t){case"absolute":return h(e);case"relative":{const t=y(e);let n=A.normalize(t,0,!0);return-180===n&&(n=180),r.createAngle(n,"degrees","geographic")}case"relative-bilateral":{const t=y(e),n=Math.abs(A.normalize(t,0,!0));return r.createAngle(n,"degrees","geographic")}}}function h(e){const t=y(e),n=R.normalize(t,0,!0);return r.createAngle(n,"degrees","geographic")}const m=(()=>{const e=a.create();return(t,o,c,a,u,g="geodesic")=>{i.copy(e,o);const p=y(u);if("geodesic"===g){const r=s.geodesicCompatibleSpatialReference(c);if(r&&l.projectVectorToVector(e,c,e,r))return s.directGeodeticSolver(t,e,p,a,r),t[2]=o[2],!!l.projectVectorToVector(t,r,t,c)}const d=r.convertRotationType(p,"geographic","arithmetic"),f=n.convertUnit(d,"degrees","radians"),v=o[0]+a*Math.cos(f),h=o[1]+a*Math.sin(f),m=o[2];return i.set(t,v,h,m),!0}})();function y(e){if(null!=e)return r.convertRotationType(b(e),e.rotationType,"geographic")}function b(e){return n.convertUnit(e.value,e.unit,"degrees")}const T=new s.InverseGeodeticSolverResult,V=2*Math.PI,R=t.cyclicalDegrees,A=new t.Cyclical(-180,180);e.convertAngle=function(e,t,o){let c=n.convertUnit(e.value,e.unit,"degrees");return c=r.convertRotationType(c,e.rotationType,o),c=n.convertUnit(c,"degrees",t),r.createAngle(c,t,o)},e.directionBetweenPoints=g,e.directionForVertices=function(e,t,r,n="absolute"){if(t&&r)switch(n){case"absolute":return g(t,r);case"relative":return v(f(e,t,r),"relative");case"relative-bilateral":return v(f(e,t,r),"relative-bilateral")}},e.getDegreesArithmetic=function(e){if(null!=e)return r.convertRotationType(b(e),e.rotationType,"arithmetic")},e.getDegreesGeographic=y,e.getNormalizedDirection=v,e.getNormalizedGeographicOrientation=h,e.pointFromDistanceAlongAzimuth=m,e.radiansGeographicBetweenVec=d,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});