// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../arcade/ArcadeDate","../core/Error","../core/has","../core/sql/DateOnly","../core/sql/TimeOnly","../geometry/support/jsonUtils","../layers/support/FieldsIndex","./loadArcade","../time/constants"],function(e,t,r,n,i,s,a,o,c,l){"use strict";const d=["geometry","scale","timeProperties"];class u{static async create(e,t,n,i){const{arcade:s,Dictionary:a}=await c.loadArcade();let o;try{o=s.parseScript(e)}catch(t){throw new r("arcade-bad-expression","Failed to parse arcade script",{script:e,error:t})}const l=s.scriptUsesGeometryEngine(o);l&&await s.enableGeometrySupport(),await s.loadDependentModules(new Set,o,null,!1,l);const d={vars:i.reduce((e,t)=>({...e,[t]:null}),{}),spatialReference:t,useAsync:!1},h=s.compileScript(o,d);let p=null;null!=n&&(p=new a(n),p.immutable=!0);const m=new a;return m.immutable=!1,m.setField("scale",0),new u(e,s,o,h,t,m,p,a)}constructor(e,t,r,n,i,s,a,o){this.script=e,this._arcade=t,this._syntaxTree=r,this._compiled=n,this._spatialReference=i,this._viewDict=s,this._configDict=a,this._dictionaryCtor=o,this._dependencies=new Map,this._featureReader=new h,this._dependencies.set("geometry",t.scriptTouchesGeometry(this._syntaxTree)),this._dependencies.set("scale",this._arcade.referencesMember(this._syntaxTree,"scale")),this._dependencies.set("timeProperties",this._arcade.scriptUsesViewProperties(this._syntaxTree,["timeProperties"]))}evaluate(e,r){const n=r.$view?.timeZone;if(r.$view){let e;if(this._viewDict.setField("scale",r.$view.scale),null!=r.$view.timeProperties){const{currentStart:i,currentEnd:s}=r.$view.timeProperties;e=new this._dictionaryCtor({currentStart:null!=i?null!=n?t.ArcadeDate.epochToArcadeDate(i,n):t.ArcadeDate.unknownEpochToArcadeDate(i):void 0,currentEnd:null!=s?null!=n?t.ArcadeDate.epochToArcadeDate(s,n):t.ArcadeDate.unknownEpochToArcadeDate(s):void 0,startIncluded:!0,endIncluded:!0})}this._viewDict.setField("timeProperties",e)}return this._compiled({vars:{$view:this._viewDict,$config:this._configDict,$feature:e},spatialReference:this._spatialReference,timeZone:n})}repurposeFeature(e,t){return this._featureReader.bind(e,t,this._spatialReference),this._featureReader}references(e){return this._dependencies.get(e)??!1}}class h{constructor(){this._boundTarget=null,this._boundSchema={fields:null,fieldsIndex:null,spatialReference:null,get geometryType(){return null},get objectIdField(){return null}},this.arcadeDeclaredClass="esri.arcade.Feature",this._contextTimeZone=null}bind(e,t,r){const n=t??new o(p(e.attributes));this._boundTarget=e,this._boundSchema.fields=n.fields,this._boundSchema.fieldsIndex=n,this._boundSchema.spatialReference=r}_getField(e){return this._boundSchema.fieldsIndex.get(e)}get contextTimeZone(){return this._contextTimeZone}set contextTimeZone(e){this._contextTimeZone=e}readArcadeFeature(){return this}hasField(e){return this._boundSchema.fieldsIndex.has(e)}geometry(){if("fromJSON"in this._boundTarget)return this._boundTarget.geometry;const e=a.fromJSON(this._boundTarget.geometry);if(e){if(!this._boundSchema.spatialReference)throw new Error("InternalError: Expected spatial reference to be defined");e.spatialReference=this._boundSchema.spatialReference}return e}isUnknownDateTimeField(e){return this._boundSchema.fieldsIndex.getTimeZone(e)===l.unknown}field(e,r=!0){const n=this._getField(e);if(n){const r=this._boundTarget.attributes[n.name];if(null==r)return null;switch(n.type){case"date-only":case"esriFieldTypeDateOnly":return i.DateOnly.fromReader(r);case"time-only":case"esriFieldTypeTimeOnly":return s.TimeOnly.fromReader(r);case"esriFieldTypeTimestampOffset":case"timestamp-offset":return t.ArcadeDate.fromReaderAsTimeStampOffset(r);case"date":case"esriFieldTypeDate":return this.isUnknownDateTimeField(e)?t.ArcadeDate.unknownEpochToArcadeDate(r):t.ArcadeDate.epochToArcadeDate(r,this.contextTimeZone??l.system);default:return r}}if(r)throw new Error(`Field ${e} does not exist`);return null}setField(e,t){throw new Error("Unable to update feature attribute values, feature is readonly")}keys(){return this._boundSchema.fieldsIndex.fields.map(e=>e.name)}castToText(e=!1){return JSON.stringify(this._boundTarget)}gdbVersion(){return null}fullSchema(){return this._boundSchema}castAsJson(e=null){return{attributes:this._boundTarget.attributes,geometry:!0===e?.keepGeometryType?this.geometry():this.geometry()?.toJSON()??null}}castAsJsonAsync(e=null,t=null){return Promise.resolve(this.castAsJson(t))}}function p(e){const t=[];for(const r in e)t.push({name:r,alias:r,type:"string"==typeof e[r]?"esriFieldTypeString":"esriFieldTypeDouble"});return t}e.ArcadeExpression=u,e.ArcadeFeatureReader=h,e.collectExpressionDependencies=function(e,t){if(null!=t)for(const r of d)t.hasArcadeDependency(r)&&e.add(r);return e},e.createDictionaryExpression=function(e,t,r){return u.create(e,t,r,["$feature","$view","$config"])},e.createLabelExpression=function(e,t){return u.create(e,t,null,["$feature","$view"])},e.createRendererExpression=function(e,t){return u.create(e,t,null,["$feature","$view"])},e.deriveFields=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});