// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../core/Error","../../core/unitUtils","../../core/accessorSupport/ensureType","../Point","../Polygon","../Polyline","../SpatialReference","./geodesicConstants","./spatialReferenceUtils"],function(e,t,n,i,s,a,o,r,c,l){"use strict";function h(e){if(!e)return null;const t=e.wkid;if(t)return c.spheroids[t];const n=e.wkt2??e.wkt;return n?function(e){const t=c.wktSpheroidRegex.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),s=parseFloat(n[2]);return isNaN(i)||isNaN(s)?null:{a:i,f:0===s?0:1/s}}(n):null}function u(e){const t=h(e);if(function(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function p(e){return null!=e&&e<0?e+360:e}function f(e,t,n){const{a:i,eSq:s}=u(n),a=Math.sqrt(s),o=Math.sin(t[1]*c.toRadians),r=i*t[0]*c.toRadians;let l;return l=s>0?i*((1-s)*(o/(1-s*(o*o))-1/(2*a)*Math.log((1-a*o)/(1+a*o))))*.5:i*o,e[0]=r,e[1]=l,e}function d(e){return l.isGeographic(e)&&!!h(e)}function g(e,n){if("polyline"!==e.type&&"polygon"!==e.type)throw new t("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:s}=e;if(!d(s))throw new t("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const c="polyline"===e.type?e.paths:e.rings,l=[],h=[0,0],u=new m;for(const e of c){const t=[];l.push(t),t.push([e[0][0],e[0][1]]);let i,a,o=e[0][0],r=e[0][1];for(let c=0;c<e.length-1;c++){if(i=e[c+1][0],a=e[c+1][1],o===i&&r===a)continue;const l=[o,r];w(u,[o,r],[i,a],s);const{azimuth:p,distance:f}=u,d=f/n;if(d>1){for(let e=1;e<=d-1;e++)M(h,l,p,e*n,s),t.push(h.slice());M(h,l,p,(f+Math.floor(d-1)*n)/2,s),t.push(h.slice())}M(h,l,p,f,s),t.push(h.slice()),o=h[0],r=h[1]}}const p=i.ensureClass(r,s);return"polyline"===e.type?new o({paths:l,spatialReference:p}):new a({rings:l,spatialReference:p})}class m{constructor(e=0,t=void 0,n=void 0){this.distance=e,this.azimuth=t,this.reverseAzimuth=n}}function M(e,t,n,i,s){const a=t[0],o=t[1],r=a*c.toRadians,l=o*c.toRadians,h=(n??0)*c.toRadians,{a:p,b:f,f:d}=u(s),g=Math.sin(h),m=Math.cos(h),M=(1-d)*Math.tan(l),w=1/Math.sqrt(1+M*M),R=M*w,y=Math.atan2(M,m),v=w*g,b=v*v,z=1-b,S=z*(p*p-f*f)/(f*f),q=1+S/16384*(4096+S*(S*(320-175*S)-768)),x=S/1024*(256+S*(S*(74-47*S)-128));let A,N,G,P=i/(f*q),U=2*Math.PI;for(;Math.abs(P-U)>1e-12;)G=Math.cos(2*y+P),A=Math.sin(P),N=Math.cos(P),U=P,P=i/(f*q)+x*A*(G+x/4*(N*(2*G*G-1)-x/6*G*(4*A*A-3)*(4*G*G-3)));const k=R*A-w*N*m,C=Math.atan2(R*N+w*A*m,(1-d)*Math.sqrt(b+k*k)),D=d/16*z*(4+d*(4-3*z)),F=Math.atan2(A*g,w*N-R*A*m)-(1-D)*d*v*(P+D*A*(G+D*N*(2*G*G-1)));return e[0]=(r+F)/c.toRadians,e[1]=C/c.toRadians,e}function w(e,t,n,i){const s=t[0]*c.toRadians,a=t[1]*c.toRadians,o=n[0]*c.toRadians,r=n[1]*c.toRadians,{a:l,b:h,f:p,radius:f}=u(i),d=o-s,g=Math.atan((1-p)*Math.tan(a)),m=Math.atan((1-p)*Math.tan(r)),M=Math.sin(g),w=Math.cos(g),R=Math.sin(m),y=Math.cos(m);let v,b,z,S,q,x,A,N,G,P,U=1e3,k=d;do{if(A=Math.sin(k),N=Math.cos(k),z=Math.sqrt(y*A*(y*A)+(w*R-M*y*N)*(w*R-M*y*N)),0===z)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;q=M*R+w*y*N,x=Math.atan2(z,q),G=w*y*A/z,b=1-G*G,S=q-2*M*R/b,isNaN(S)&&(S=0),P=p/16*b*(4+p*(4-3*b)),v=k,k=d+(1-P)*p*G*(x+P*z*(S+P*q*(2*S*S-1)))}while(Math.abs(k-v)>1e-12&&--U>0);if(0===U){const t=f,n=Math.acos(Math.sin(a)*Math.sin(r)+Math.cos(a)*Math.cos(r)*Math.cos(o-s))*t,i=o-s,l=Math.sin(i)*Math.cos(r),h=Math.cos(a)*Math.sin(r)-Math.sin(a)*Math.cos(r)*Math.cos(i),u=Math.atan2(l,h);return e.azimuth=u/c.toRadians,e.distance=n,e.reverseAzimuth=void 0,e}const C=b*(l*l-h*h)/(h*h),D=C/1024*(256+C*(C*(74-47*C)-128)),F=h*(1+C/16384*(4096+C*(C*(320-175*C)-768)))*(x-D*z*(S+D/4*(q*(2*S*S-1)-D/6*S*(4*z*z-3)*(4*S*S-3)))),j=Math.atan2(y*Math.sin(k),w*R-M*y*Math.cos(k)),I=Math.atan2(w*Math.sin(k),w*R*Math.cos(k)-M*y);return e.azimuth=j/c.toRadians,e.distance=F,e.reverseAzimuth=I/c.toRadians,e}e.InverseGeodeticSolverResult=m,e.directGeodeticSolver=M,e.geodesicAreas=function(e,i="square-meters"){if(e.some(e=>!d(e.spatialReference)))throw new t("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const s=[];for(let t=0;t<e.length;t++){const n=e[t],i=n.spatialReference,{radius:a,densificationRatio:o}=u(i),r=a*o;s.push(g(n,r))}const a=[],o=[0,0],r=[0,0];for(let e=0;e<s.length;e++){const{rings:t,spatialReference:c}=s[e];let l=0;for(let e=0;e<t.length;e++){const n=t[e];f(o,n[0],c),f(r,n[n.length-1],c);let i=r[0]*o[1]-o[0]*r[1];for(let e=0;e<n.length-1;e++)f(o,n[e+1],c),f(r,n[e],c),i+=r[0]*o[1]-o[0]*r[1];l+=i}l=n.convertUnit(l,"square-meters",i),a.push(l/-2)}return a},e.geodesicCompatibleSpatialReference=function(e){return d(e)?e:l.isWebMercator(e)?r.WGS84:null},e.geodesicDensify=g,e.geodesicDistance=function(e,i,s="meters"){if(!e||!i)throw new t("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!i.spatialReference)throw new t("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!l.equals(e.spatialReference,i.spatialReference))throw new t("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:a}=e;if(!d(a))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===i.x&&e.y===i.y)return new m(0,0,0);const o=new m;return w(o,[e.x,e.y],[i.x,i.y],a),o.distance=n.convertUnit(o.distance,"meters",s),o.azimuth=p(o.azimuth),o.reverseAzimuth=p(o.reverseAzimuth),o},e.geodesicLengths=function(e,i="meters"){if(!e)throw new t("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some(e=>!d(e.spatialReference)))throw new t("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const s=[];for(let t=0;t<e.length;t++){const a=e[t],{spatialReference:o}=a,r="polyline"===a.type?a.paths:a.rings;let c=0;for(let e=0;e<r.length;e++){const t=r[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],s=t[e][0],a=t[e-1][1],r=t[e][1];if(a!==r||i!==s){const e=new m;w(e,[i,a],[s,r],o),n+=e.distance}}c+=n}c=n.convertUnit(c,"meters",i),s.push(c)}return s},e.inverseGeodeticSolver=w,e.isSupported=d,e.pointFromDistance=function(e,n,i){if(!e||null==n||null==i)throw new t("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(i<0||i>360)throw new t("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new t("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:a}=e;if(!d(a))throw new t("geodesic-distance:not-supported","input geometry spatial reference is not supported");const o=[0,0];return M(o,[e.x,e.y],i,n,a),new s({x:o[0],y:o[1],spatialReference:a})},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});