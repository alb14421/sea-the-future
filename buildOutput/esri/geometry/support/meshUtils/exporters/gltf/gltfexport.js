// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../core/promiseUtils","./asset","./glb","./gltf","./imageutils","./node","./scene"],function(e,t,r,n,o,a,i,s){"use strict";const f="model.gltf",u="model.glb";async function c(e,r){const i=new o.GLTF(e,r).gltf,s=i.extras.promises;let c=1,l=1,d=null;await Promise.allSettled(s),t.throwIfAborted(r.signal);const g=r.jsonSpacing??4,m=new Map,w=JSON.stringify(i,(e,t)=>{if("extras"!==e){if(t instanceof ArrayBuffer){if(a.isArrayBufferPNG(t))switch(r.output?.image){case 1:case 2:break;default:{const e=`img${l}.png`;return l++,m.set(e,t),e}}switch(r.output?.buffer){case 1:return a.encodeBase64DataUri(t);case 2:if(d)throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");return void(d=t);default:{const e=`data${c}.bin`;return c++,m.set(e,t),e}}}return t}},g);return 2===r.output?.buffer||2===r.output?.image?m.set(u,new n.GLB(w,d).buffer):m.set(f,w),m}e.exportGLTF=c,e.modelNameGlb=u,e.modelNameGltf=f,e.toBinaryGLTF=async function(e,t){const n=new r.Asset,o=new s.Scene;return n.addScene(o),o.addNode(new i.Node(e)),await async function(e,t){const r=(await c(e,{output:{buffer:2,image:2},jsonSpacing:0,...t})).get(u);if(!(r&&r instanceof ArrayBuffer))throw new Error("failed to export to glb");return r}(n,{origin:e.origin,...t})},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});