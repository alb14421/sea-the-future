// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../chunks/tslib.es6","../core/arrayUtils","../core/deprecate","../core/lang","../core/Logger","../core/accessorSupport/decorators/property","../core/has","../core/accessorSupport/decorators/subclass","../core/accessorSupport/decorators/writer","./Extent","./Geometry","./Point","./SpatialReference","./support/centroid","./support/contains","./support/coordsUtils","./support/extentUtils","./support/intersectsBase","./support/webMercatorUtils","./support/zmUtils"],function(e,t,r,s,n,i,o,a,l,c,u,p,h,g,f,y,d,m,R,w,v){"use strict";var _;function x(e){return!Array.isArray(e[0])}return e.default=_=class extends p{static fromExtent(e){const t=e.clone().normalize(),{spatialReference:r}=e;let s=!1,n=!1;for(const e of t)e.hasZ&&(s=!0),e.hasM&&(n=!0);const i={rings:t.map(e=>{const t=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];if(s&&e.hasZ){const r=e.zmin+.5*(e.zmax-e.zmin);for(let e=0;e<t.length;e++)t[e].push(r)}if(n&&e.hasM){const r=e.mmin+.5*(e.mmax-e.mmin);for(let e=0;e<t.length;e++)t[e].push(r)}return t}),spatialReference:r};return s&&(i.hasZ=!0),n&&(i.hasM=!0),new _(i)}constructor(e){super(function(e){if(!e)return;let{rings:t,hasM:r,hasZ:s,spatialReference:n}=e;var i;switch(t??=[],i=t,"number"==typeof i[0]?.[0]&&(t=[t]),t[0]?.[0]?.length){case 4:s??=!0,r??=!0;break;case 3:s??=!0!==r,r??=!s;break;default:s??=!1,r??=!1}return n??=g.WGS84,{...e,hasM:r,hasZ:s,rings:t,spatialReference:n}}(e)),this.curveRings=void 0,this.rings=[],this.type="polygon"}get cache(){return this.commitProperty("curveRings"),this.commitProperty("hasM"),this.commitProperty("hasZ"),this.commitProperty("rings"),this.commitProperty("spatialReference"),{}}get centroid(){const e=f.polygonCentroid(this);if(!e||isNaN(e[0])||isNaN(e[1])||this.hasZ&&isNaN(e[2]))return null;const t=new h;return t.x=e[0],t.y=e[1],t.spatialReference=this.spatialReference,this.hasZ&&(t.z=e[2]),t}writeCurveRings(e,t){t.curveRings=n.clone(e)}get extent(){const e=m.getPolygonExtent(this),{spatialReference:t}=this;return e?new u({...e,spatialReference:t}):null}get isSelfIntersecting(){return s.deprecatedProperty(i.getLogger(this),"isSelfIntersecting",{replacement:"Please use simplifyOperator.isSimple() instead.",version:"4.33",warnOnce:!0}),R.isSelfIntersecting(this.rings)}writeRings(e,t){t.rings=n.clone(this.rings)}addRing(e){if(!e)return;const t=this.rings,r=t.length;if(x(e)){const s=[];for(let t=0,r=e.length;t<r;t++)s[t]=e[t].toArray();t[r]=s}else t[r]=e.slice();return this.notifyChange("rings"),this}clone(){const e=new _;return e.spatialReference=this.spatialReference,e.rings=n.clone(this.rings),e.curveRings=n.clone(this.curveRings),e.hasZ=this.hasZ,e.hasM=this.hasM,e}equals(e){if(this===e)return!0;if(null==e)return!1;const t=this.spatialReference,s=e.spatialReference;if(null!=t!=(null!=s))return!1;if(null!=t&&null!=s&&!t.equals(s))return!1;if(this.rings.length!==e.rings.length)return!1;const n=([e,t,r,s],[n,i,o,a])=>e===n&&t===i&&(null==r&&null==o||r===o)&&(null==s&&null==a||s===a);for(let t=0;t<this.rings.length;t++){const s=this.rings[t],i=e.rings[t];if(!r.equals(s,i,n))return!1}return!0}contains(e){if(!e)return!1;const t=w.project(e,this.spatialReference);return y.polygonContainsPoint(this,null!=t?t:e)}isClockwise(e){const t=x(e)?e.map(e=>this.hasZ?this.hasM?[e.x,e.y,e.z,e.m]:[e.x,e.y,e.z]:[e.x,e.y]):e;return d.isClockwise(t)}getPoint(e,t){if(!this._validateInputs(e,t))return null;const r=this.rings[e][t],s=this.hasZ,n=this.hasM;return s&&!n?new h(r[0],r[1],r[2],void 0,this.spatialReference):n&&!s?new h(r[0],r[1],void 0,r[2],this.spatialReference):s&&n?new h(r[0],r[1],r[2],r[3],this.spatialReference):new h(r[0],r[1],this.spatialReference)}insertPoint(e,t,r){return this._validateInputs(e,t,!0)?(v.updateSupportFromPoint(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[e].splice(t,0,r),this.notifyChange("rings"),this):this}removePoint(e,t){if(!this._validateInputs(e,t))return null;const r=new h(this.rings[e].splice(t,1)[0],this.spatialReference);return this.notifyChange("rings"),r}removeRing(e){if(!this._validateInputs(e,null))return null;const t=this.rings.splice(e,1)[0],r=this.spatialReference,s=t.map(e=>new h(e,r));return this.notifyChange("rings"),s}setPoint(e,t,r){return this._validateInputs(e,t)?(v.updateSupportFromPoint(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[e][t]=r,this.notifyChange("rings"),this):this}_validateInputs(e,t,r=!1){if(null==e||e<0||e>=this.rings.length)return!1;if(null!=t){const s=this.rings[e];if(r&&(t<0||t>s.length))return!1;if(!r&&(t<0||t>=s.length))return!1}return!0}toJSON(e){return this.write({},e)}},t.__decorate([o.property({readOnly:!0})],e.default.prototype,"cache",null),t.__decorate([o.property({readOnly:!0})],e.default.prototype,"centroid",null),t.__decorate([o.property({json:{write:!0,origins:{"portal-item":{write:!1},"web-map":{write:!1},"web-scene":{write:!1}}}})],e.default.prototype,"curveRings",void 0),t.__decorate([c.writer("curveRings")],e.default.prototype,"writeCurveRings",null),t.__decorate([o.property({readOnly:!0})],e.default.prototype,"extent",null),t.__decorate([o.property({readOnly:!0})],e.default.prototype,"isSelfIntersecting",null),t.__decorate([o.property({type:[[[Number]]],json:{write:{isRequired:!0}}})],e.default.prototype,"rings",void 0),t.__decorate([c.writer("rings")],e.default.prototype,"writeRings",null),e.default=_=t.__decorate([l.subclass("esri.geometry.Polygon")],e.default),e.default.prototype.toJSON.isDefaultToJSON=!0,e.default});