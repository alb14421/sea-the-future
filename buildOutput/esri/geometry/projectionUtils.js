// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../core/Error","../core/promiseUtils","../core/accessorSupport/tracking","../core/accessorSupport/tracking/SimpleObservable","../core/libs/gl-matrix-2/factories/vec3f64","./asserts","./ellipsoidUtils","./Extent","./Multipoint","../chunks/pe","./Point","./Polygon","./Polyline","./SpatialReference","./projection/projectBuffer","./projection/projectors","./projection/projectXYZToVector","./support/GeographicTransformation","./support/spatialReferenceUtils","./support/zscale"],function(e,n,r,t,l,i,o,s,a,u,c,f,p,h,m,d,g,y,R,j,P,x){"use strict";let S=null,w=null,M=null,C={};const Z=new i.SimpleObservable;function E(){return!!S&&f.isLoaded()}function v(){return!!E()||(l.trackAccess(Z),z(),!1)}function z(n){return null==M&&(M=Promise.all([f.load(),new Promise((n,r)=>e(["../chunks/geometryEngineBase"],n,r)).then(e=>e.geometryEngineBase),new Promise((n,r)=>e(["./geometryAdapters/hydrated"],n,r))])),M.then(([,e,{hydratedAdapter:r}])=>{t.throwIfAborted(n),w=r,S=e.default,S._enableProjection(f.pe),Z.notify()})}function b(e,n,r=null,t=null){return Array.isArray(e)?0===e.length?[]:(s.assertNotMeshes(e),G(w,e,e[0].spatialReference,n,r,t)):(s.assertNotMesh(e),G(w,[e],e.spatialReference,n,r,t)[0])}function G(e,n,r,t,l=null,i=null){if(null==r||null==t)return n;if(L(r,t,l))return n.map(e=>B(e,r,t));if(null==l&&a.isSphericalECEF(r))return n.map(e=>B(e,r,d.WGS84)).map(e=>F(e,t));if(null==l&&a.isSphericalECEF(t))return n.map(e=>F(e,d.WGS84)).map(e=>B(e,d.WGS84,t));if(null==l){const e=j.cacheKey(r,t);void 0!==C[e]?l=C[e]:(null==(l=A(r,t,void 0))&&(l=new j),C[e]=l)}if(null==S||null==e)throw new V;return null!=i?S._project(e,n,r,t,l,i):S._project(e,n,r,t,l)}function T(e,n){if(!E())for(const r of e)if(null!=r&&!P.equals(r.spatialReference,n)&&P.isValid(r.spatialReference)&&P.isValid(n)&&!L(r.spatialReference,n))return l.trackAccess(Z),{pending:z(),geometries:null};return{pending:null,geometries:e.map(e=>null==e?null:P.equals(e.spatialReference,n)?e:P.isValid(e.spatialReference)&&P.isValid(n)?F(e,n):null)}}function A(e,n,r=null){if(null==e||null==n)return null;if(null==S||null==w)throw new V;const t=S._getTransformation(w,e,n,r,r?.spatialReference);return null!==t?j.fromGE(t):null}class V extends r{constructor(){super("projection:not-loaded","projection engine not fully loaded yet, please call load()")}}const W={get loadPromise(){return M}};function F(e,n){try{const r=b(e,n);if(null==r)return null;"xmin"in e&&"xmin"in r&&(r.zmin=e.zmin,r.zmax=e.zmax);const t=x.getGeometryZScaler(r.type,e.spatialReference,n);return null!=t&&t(r),r}catch(e){if(!(e instanceof V))throw e;return null}}function L(e,n,r){return!r&&(!!P.equals(e,n)||P.isValid(e)&&P.isValid(n)&&!!y.getProjector(e,n))}async function k(e,n,r,l){if(E())return t.waitTick(l);if(Array.isArray(e)){for(const{source:n,dest:r,geographicTransformation:t}of e)if(n&&r&&!L(n,r,t))return z(l)}else if(e&&n&&!L(e,n,r))return z(l);return t.waitTick(l)}function B(e,n,r){return e?"x"in e?q(e,n,new p,r,0):"xmin"in e?X(e,n,new u,r,0):"rings"in e?U(e,n,new h,r,0):"paths"in e?_(e,n,new m,r,0):"points"in e?O(e,n,new c,r,0):null:null}function q(e,n,r,t,l){N[0]=e.x,N[1]=e.y;const i=e.z;return N[2]=void 0!==i?i:l,g.projectBuffer(N,n,0,N,t,0)?(r.x=N[0],r.y=N[1],r.spatialReference=t,void 0!==i||a.isSphericalPCPF(t)?(r.z=N[2],r.hasZ=!0):(r.z=void 0,r.hasZ=!1),void 0===e.m?(r.m=void 0,r.hasM=!1):(r.m=e.m,r.hasM=!0),r):null}function O(e,n,r,t,l){const{points:i,hasZ:o,hasM:s}=e,u=[],c=i.length,f=[];for(const e of i)f.push(e[0],e[1],o?e[2]:l);if(!g.projectBuffer(f,n,0,f,t,0,c))return null;const p=o||a.isSphericalPCPF(t);for(let e=0;e<c;++e){const n=3*e,r=f[n],t=f[n+1];p&&s?u.push([r,t,f[n+2],i[e][3]]):p?u.push([r,t,f[n+2]]):s?u.push([r,t,i[e][2]]):u.push([r,t])}return r.points=u,r.spatialReference=t,r.hasZ=o,r.hasM=s,r}function _(e,n,r,t,l){const{paths:i,hasZ:o,hasM:s}=e,u=[];if(!Y(i,o??!1,s??!1,n,u,t,l))return null;const c=o||a.isSphericalPCPF(t);return r.paths=u,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function U(e,n,r,t,l){const{rings:i,hasZ:o,hasM:s}=e,u=[];if(!Y(i,o??!1,s??!1,n,u,t,l))return null;const c=o||a.isSphericalPCPF(t);return r.rings=u,r.spatialReference=t,r.hasZ=c,r.hasM=s,r}function X(e,n,r,t,l){const{xmin:i,ymin:o,xmax:s,ymax:u,hasZ:c,hasM:f}=e,p=c?e.zmin:l;if(!R.projectXYZToVector(i,o,p,n,N,t))return null;const h=c||a.isSphericalPCPF(t);r.xmin=N[0],r.ymin=N[1],h&&(r.zmin=N[2]);const m=c?e.zmax:l;return R.projectXYZToVector(s,u,m,n,N,t)?(r.xmax=N[0],r.ymax=N[1],h&&(r.zmax=N[2]),f&&(r.mmin=e.mmin,r.mmax=e.mmax),r.spatialReference=t,r):null}function Y(e,n,r,t,l,i,o=0){const s=new Array;for(const r of e)for(const e of r)s.push(e[0],e[1],n?e[2]:o);if(!g.projectBuffer(s,t,0,s,i,0))return!1;let u=0;l.length=0;const c=n||a.isSphericalPCPF(i);for(const n of e){const e=new Array;for(const t of n)c&&r?e.push([s[u++],s[u++],s[u++],t[3]]):c?e.push([s[u++],s[u++],s[u++]]):r?(e.push([s[u++],s[u++],t[2]]),u++):(e.push([s[u++],s[u++]]),u++);l.push(e)}return!0}const N=o.create();n.canProjectWithoutEngine=L,n.getTransformation=A,n.getTransformations=function(e,n,r=null){if(null==S||null==w)throw new V;const t=S._getTransformationBySuitability(w,e,n,r,r?.spatialReference);if(null!==t){const e=[];for(const n of t)e.push(j.fromGE(n));return e}return[]},n.initializeProjection=k,n.isEqualBaseGCS=function(e,n){if(P.equals(e,n))return!0;if(!P.isValid(e)||!P.isValid(n))return!1;const r=P.isWGS84(e)||P.isWebMercator(e)||P.isCGCS2000(e),t=P.isWGS84(n)||P.isWebMercator(n)||P.isCGCS2000(n);return r&&t},n.isLoaded=E,n.isLoadedOrLoad=v,n.isLoadedOrLoadFor=function(e,n){return!e||!n||L(e,n)||v()},n.load=z,n.project=b,n.projectExtent=function(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=X(e,e.spatialReference,n,r,t)},n.projectMany=G,n.projectMultipoint=function(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=O(e,e.spatialReference,n,r,t)},n.projectOrLoad=function(e,n){const r=T([e],n);return null!=r.pending?{pending:r.pending,geometry:null}:null!=r.geometries?{pending:null,geometry:r.geometries[0]}:{pending:null,geometry:null}},n.projectOrLoadMany=T,n.projectPoint=function(e,n,r=n.spatialReference,t=0){return null!=r&&null!=e.spatialReference&&null!=q(e,e.spatialReference,n,r,t)},n.projectPolygon=function(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=U(e,e.spatialReference,n,r,t)},n.projectPolyline=function(e,n,r=n.spatialReference,t=0){return null!=e.spatialReference&&null!=r&&null!=_(e,e.spatialReference,n,r,t)},n.projectWithZConversion=async function(e,n,r){const t=e.spatialReference;return null!=t&&null!=n&&await k(t,n,null,r),F(e,n)},n.projectWithoutEngine=B,n.requiresLoad=function(e,n){return!L(e,n)&&!E()},n.test=W,n.tryProjectWithZConversion=F,n.unload=function(){S=null,w=null,M=null,C={}},Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});