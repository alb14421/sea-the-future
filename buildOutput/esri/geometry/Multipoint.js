// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../chunks/tslib.es6","../core/lang","../core/accessorSupport/decorators/property","../core/has","../core/Logger","../core/accessorSupport/decorators/subclass","../core/accessorSupport/decorators/writer","./Extent","./Geometry","./Point","./support/zmUtils"],function(t,e,s,i,r,n,o,a,p,h,l,c){"use strict";var u;function d(t){return(e,s)=>null==e?s:null==s?e:t(e,s)}return t.default=u=class extends h{constructor(...t){super(...t),this.points=[],this.type="multipoint"}normalizeCtorArgs(t,e){if(!t&&!e)return{};const s={};var i;Array.isArray(t)?(s.points=t,s.spatialReference=e):!(i=t)||"esri.geometry.SpatialReference"!==i.declaredClass&&null==i.wkid?(t.points&&(s.points=t.points),t.spatialReference&&(s.spatialReference=t.spatialReference),t.hasZ&&(s.hasZ=t.hasZ),t.hasM&&(s.hasM=t.hasM)):s.spatialReference=t;const r=s.points?.[0];return r&&(void 0===s.hasZ&&void 0===s.hasM?(s.hasZ=r.length>2,s.hasM=!1):void 0===s.hasZ?s.hasZ=r.length>3:void 0===s.hasM&&(s.hasM=r.length>3)),s}get cache(){return this.commitProperty("points"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get extent(){const t=this.points;if(!t.length)return null;const e=new p,s=this.hasZ,i=this.hasM,r=s?3:2,n=t[0],o=d(Math.min),a=d(Math.max);let h,l,c,u,[f,m]=n,[y,g]=n;for(let e=0,n=t.length;e<n;e++){const n=t[e],[p,d]=n;if(f=o(f,p),m=o(m,d),y=a(y,p),g=a(g,d),s&&n.length>2){const t=n[2];h=o(h,t),c=a(c,t)}if(i&&n.length>r){const t=n[r];l=o(l,t),u=a(u,t)}}return e.xmin=f,e.ymin=m,e.xmax=y,e.ymax=g,e.spatialReference=this.spatialReference,s?(e.zmin=h,e.zmax=c):(e.zmin=void 0,e.zmax=void 0),i?(e.mmin=l,e.mmax=u):(e.mmin=void 0,e.mmax=void 0),e}writePoints(t,e){e.points=s.clone(this.points)}addPoint(t){return c.updateSupportFromPoint(this,t),Array.isArray(t)?this.points.push(t):this.points.push(t.toArray()),this.notifyChange("points"),this}clone(){const t={points:s.clone(this.points),spatialReference:this.spatialReference};return this.hasZ&&(t.hasZ=!0),this.hasM&&(t.hasM=!0),new u(t)}getPoint(t){if(!this._validateInputs(t))return null;const e=this.points[t],s={x:e[0],y:e[1],spatialReference:this.spatialReference};let i=2;return this.hasZ&&(s.z=e[2],i=3),this.hasM&&(s.m=e[i]),new l(s)}removePoint(t){if(!this._validateInputs(t))return null;const e=new l(this.points.splice(t,1)[0],this.spatialReference);return this.notifyChange("points"),e}setPoint(t,e){return this._validateInputs(t)?(c.updateSupportFromPoint(this,e),Array.isArray(e)||(e=e.toArray()),this.points[t]=e,this.notifyChange("points"),this):this}toJSON(t){return this.write({},t)}_validateInputs(t){return null!=t&&t>=0&&t<this.points.length}},e.__decorate([i.property({readOnly:!0})],t.default.prototype,"cache",null),e.__decorate([i.property()],t.default.prototype,"extent",null),e.__decorate([i.property({type:[[Number]],json:{write:{isRequired:!0}}})],t.default.prototype,"points",void 0),e.__decorate([a.writer("points")],t.default.prototype,"writePoints",null),t.default=u=e.__decorate([o.subclass("esri.geometry.Multipoint")],t.default),t.default.prototype.toJSON.isDefaultToJSON=!0,t.default});