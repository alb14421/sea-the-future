// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../core/workers/workers","./Point","./support/jsonUtils"],function(n,e,t,r){"use strict";function i(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function a(n){return n?Array.isArray(n)?n.map(a):n.toJSON?n.toJSON():n:n}function c(n){return Array.isArray(n)?n.map(n=>r.fromJSON(n)):r.fromJSON(n)}let o;async function u(){return o||(o=e.open("geometryEngineWorker",{strategy:"distributed"})),o}async function s(n,e){return(await u()).invoke("executeGEOperation",{operation:n,parameters:a(e)})}async function f(n,e){const t=await u();return Promise.all(t.broadcast("executeGEOperation",{operation:n,parameters:a(e)}))}function l(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}class p extends Error{constructor(){super("Illegal Argument Exception")}}n.buffer=async function(n,e,t,r=!1){const a=[i(n),n,e,t,r];return c(await s("buffer",a))},n.changeDefaultSpatialReferenceTolerance=async function(n,e){await f("changeDefaultSpatialReferenceTolerance",[n,e])},n.clearDefaultSpatialReferenceTolerance=async function(n){await f("clearDefaultSpatialReferenceTolerance",[n])},n.clip=async function(n,e){return c(await s("clip",[i(n),n,e]))},n.contains=function(n,e){return s("contains",[i(n),n,e])},n.convexHull=async function(n,e=!1){return c(await s("convexHull",[i(n),n,e]))},n.crosses=function(n,e){return s("crosses",[i(n),n,e])},n.cut=async function(n,e){return c(await s("cut",[i(n),n,e]))},n.densify=async function(n,e,t){return c(await s("densify",[i(n),n,e,t]))},n.difference=async function(n,e){return c(await s("difference",[i(n),n,e]))},n.disjoint=function(n,e){return s("disjoint",[i(n),n,e])},n.distance=function(n,e,t){return s("distance",[i(n),n,e,t])},n.equals=function(n,e){return s("equals",[i(n),n,e])},n.extendedSpatialReferenceInfo=function(n){return s("extendedSpatialReferenceInfo",[n])},n.flipHorizontal=async function(n,e){if(null==n)throw new p;const t=n.spatialReference;if(null==(e=e??l(n)))throw new p;const r=n.constructor.fromJSON(await s("flipHorizontal",[t,n,e]));return r.spatialReference=t,r},n.flipVertical=async function(n,e){if(null==n)throw new p;const t=n.spatialReference;if(null==(e=e??l(n)))throw new p;const r=n.constructor.fromJSON(await s("flipVertical",[t,n,e]));return r.spatialReference=t,r},n.generalize=async function(n,e,t,r){return c(await s("generalize",[i(n),n,e,t,r]))},n.geodesicArea=function(n,e,t){return s("geodesicArea",[i(n),n,e,t])},n.geodesicBuffer=async function(n,e,t,r,a,o){const u=[i(n),n,e,t,r,a,o];return c(await s("geodesicBuffer",u))},n.geodesicDensify=async function(n,e,t,r=0){return c(await s("geodesicDensify",[i(n),n,e,t,r]))},n.geodesicLength=function(n,e,t){return s("geodesicLength",[i(n),n,e,t])},n.intersect=async function(n,e){return c(await s("intersect",[i(n),n,e]))},n.intersectLinesToPoints=async function(n,e){return c(await s("intersectLinesToPoints",[i(n),n,e]))},n.intersects=function(n,e){return s("intersects",[i(n),n,e])},n.isSimple=function(n){return s("isSimple",[i(n),n])},n.nearestCoordinate=async function(n,e,r=!0){const a=await s("nearestCoordinate",[i(n),n,e,r]);return{...a,coordinate:t.fromJSON(a.coordinate)}},n.nearestVertex=async function(n,e){const r=await s("nearestVertex",[i(n),n,e]);return{...r,coordinate:t.fromJSON(r.coordinate)}},n.nearestVertices=async function(n,e,r,a){return(await s("nearestVertices",[i(n),n,e,r,a])).map(n=>({...n,coordinate:t.fromJSON(n.coordinate)}))},n.offset=async function(n,e,t,r,a,o){return c(await s("offset",[i(n),n,e,t,r,a,o]))},n.overlaps=function(n,e){return s("overlaps",[i(n),n,e])},n.planarArea=function(n,e){return s("planarArea",[i(n),n,e])},n.planarLength=function(n,e){return s("planarLength",[i(n),n,e])},n.relate=function(n,e,t){return s("relate",[i(n),n,e,t])},n.rotate=async function(n,e,t){if(null==n)throw new p;const r=n.spatialReference;if(null==(t=t??l(n)))throw new p;const i=n.constructor.fromJSON(await s("rotate",[r,n,e,t]));return i.spatialReference=r,i},n.simplify=async function(n){return c(await s("simplify",[i(n),n]))},n.symmetricDifference=async function(n,e){return c(await s("symmetricDifference",[i(n),n,e]))},n.touches=function(n,e){return s("touches",[i(n),n,e])},n.union=async function(n,e=null){const t=function(n,e){let t;return Array.isArray(n)?t=n:(t=[],t.push(n),null!=e&&t.push(e)),t}(n,e);return c(await s("union",[i(t),t]))},n.within=function(n,e){return s("within",[i(n),n,e])},Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});