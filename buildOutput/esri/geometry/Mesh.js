// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["require","exports","../chunks/tslib.es6","../core/Clonable","../core/Error","../core/Loadable","../core/Logger","../core/Promise","../core/promiseUtils","../core/reactiveUtils","../core/accessorSupport/decorators/property","../core/has","../core/RandomLCG","../core/accessorSupport/decorators/subclass","../core/libs/gl-matrix-2/factories/vec3f64","./Geometry","./Point","./Polygon","./support/aaBoundingBox","./support/axisAngleDegrees","./support/MeshComponent","./support/meshErrors","./support/MeshGeoreferencedVertexSpace","./support/MeshLocalVertexSpace","./support/MeshTransform","./support/MeshVertexAttributes","./support/meshVertexSpaceUtils","./support/triangulationUtils","./support/meshUtils/centerAt","./support/meshUtils/extent","./support/meshUtils/loadExternal","./support/meshUtils/meshCloneUtils","./support/meshUtils/Metadata","./support/meshUtils/primitives","./support/meshUtils/rotate","./support/meshUtils/scale"],function(e,t,r,o,s,n,a,i,c,l,p,u,d,h,m,f,x,g,y,v,S,M,_,b,w,C,L,A,U,P,R,F,E,B,G,V){"use strict";var z;const I={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:_,local:b}};t.default=z=class extends(o.ClonableMixin(n.LoadableMixin(i.EsriPromiseMixin(f)))){constructor(e){super(e),this.components=null,this.vertexSpace=new _,this.transform=null,this.metadata=new E.Metadata,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new C.MeshVertexAttributes,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.addHandles(l.watch(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(e=>e.clone())}),()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{spatialReference:e,vertexSpace:t}=this,r=this;return P.computeMeshExtent({get transform(){return r.transform},vertexSpace:t,spatialReference:e,untransformedBounds:this._untransformedBounds})}get _untransformedBounds(){const{vertexAttributes:{position:e},components:t}=this;return 0===e.length||0===t?.length?y.create(y.zero):y.fromBuffer(e)}get origin(){const e=L.vertexSpaceOriginToPoint(this.vertexSpace,this.spatialReference);if(null!=e)return e;const{center:t,zmin:r}=this._transformedExtent;return new x({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(S.from(e)),this.notifyChange("components"))}removeComponent(e){if(this._checkIfLoaded("removeComponent()")){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}a.getLogger(this).error("removeComponent()",M.componentNotFoundMessage)}}rotate(e,t,r,o){return v.composeAxes(e,t,r,O),G.rotate(this,O,o),this}offset(e,t,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:o,vertexAttributes:s}=this,n=s?.position;if(!n)return this;if(L.isRelativeVertexSpace(o)){const[s,n,a]=o.origin;o.origin=m.fromValues(s+e,n+t,a+r)}else{for(let o=0;o<n.length;o+=3)n[o]+=e,n[o+1]+=t,n[o+2]+=r;this.vertexAttributesChanged()}return this}scale(e,t){return this._checkIfLoaded("scale()")?(V.scale(this,e,t),this):this}centerAt(e,t){return this._checkIfLoaded("centerAt()")?(U.centerAt(this,e,t),this):this}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(R.loadExternal(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(e){return super.clone(F.addMeshMaterialCloneContext(F.addMeshTextureCloneContext(e)))}cloneShallow(){return new z({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const[{toBinaryGLTF:r}]=await Promise.all([new Promise((t,r)=>e(["./support/meshUtils/exporters/gltf/gltfexport"],t,r)),this.load(t)]);return c.throwIfAborted(t),await r(this,t)}get usedMemory(){return this.components?this.components.reduce((e,t)=>e+t.memoryUsage,this.vertexAttributes.usedMemory):this.vertexAttributes.usedMemory}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(e){return!!this.loaded||(a.getLogger(this).error(e,M.meshNotLoadedMessage),!1)}static createBox(e,t){if(!(e instanceof x))return a.getLogger(this.prototype).error(".createBox()",M.invalidLocationMessage),null;const r=new z(B.convertUnitGeometry(B.createUnitSizeBox(),e,t));return t?.imageFace&&"all"!==t.imageFace?B.extractSingleFaceOfBox(r,t.imageFace):r}static createSphere(e,t){return e instanceof x?new z(B.convertUnitGeometry(B.createUnitSizeSphere(t?.densificationFactor||0),e,t)):(a.getLogger(this.prototype).error(".createSphere()",M.invalidLocationMessage),null)}static createCylinder(e,t){return e instanceof x?new z(B.convertUnitGeometry(B.createUnitSizeCylinder(t?.densificationFactor||0),e,t)):(a.getLogger(this.prototype).error(".createCylinder()",M.invalidLocationMessage),null)}static createPlane(e,t){if(!(e instanceof x))return a.getLogger(this.prototype).error(".createPlane()",M.invalidLocationMessage),null;const r=t?.facing??"up",o=B.convertPlaneSizeParameter(r,t?.size);return new z(B.convertUnitGeometry(B.createUnitSizePlane(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof g))return a.getLogger(this.prototype).error(".createFromPolygon()",M.invalidPolygonMessage),null;const r=A.triangulate(e);return new z({vertexAttributes:new C.MeshVertexAttributes({position:r.position}),components:[new S({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new _})}static async createFromGLTF(t,r,o){if(!(t instanceof x)){const e=new M.InvalidLocationError;throw a.getLogger(this.prototype).error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:s}=await c.whenOrAbort(new Promise((t,r)=>e(["./support/meshUtils/loadGLTFMesh"],t,r)),o);return new z(await s(t,r,o))}static createWithExternalSource(e,t,r){const o=r?.extent??null,{spatialReference:s}=e,n=r?.transform?.clone()??new w,a=L.selectVertexSpace(e,r),i=r?.unitConversionDisabled,c={source:t,extent:o,unitConversionDisabled:i},l=new E.Metadata;return l.externalSources.push(c),new z({metadata:l,transform:n,vertexSpace:a,spatialReference:s})}static createIncomplete(e,t){const{spatialReference:r}=e,o=t?.transform?.clone()??new w,n=L.selectVertexSpace(e,t),a=new z({transform:o,vertexSpace:n,spatialReference:r});return a.addResolvingPromise(Promise.reject(new s("mesh-incomplete","Mesh resources are not complete"))),a}},r.__decorate([p.property({type:[S],json:{write:!0}})],t.default.prototype,"components",void 0),r.__decorate([p.property({nonNullable:!0,types:I,constructOnly:!0,json:{write:!0},clonable:(e,t)=>F.getMeshCloneContext(t)?.vertexSpace??e.clone(t)})],t.default.prototype,"vertexSpace",void 0),r.__decorate([p.property({type:w,clonable:(e,t)=>{const r=F.getMeshCloneContext(t);return r&&"transform"in r?r.transform:e?.clone()??e},json:{write:!0}})],t.default.prototype,"transform",void 0),r.__decorate([p.property({constructOnly:!0,type:E.Metadata,clonable:(e,t)=>F.getMeshCloneContext(t)?.metadata??e.clone()})],t.default.prototype,"metadata",void 0),r.__decorate([p.property()],t.default.prototype,"hasExtent",null),r.__decorate([p.property()],t.default.prototype,"_transformedExtent",null),r.__decorate([p.property()],t.default.prototype,"_untransformedBounds",null),r.__decorate([p.property()],t.default.prototype,"origin",null),r.__decorate([p.property({readOnly:!0,json:{read:!1}})],t.default.prototype,"extent",null),r.__decorate([p.property({readOnly:!0,json:{read:!1,write:!0,default:!0}})],t.default.prototype,"hasZ",void 0),r.__decorate([p.property({readOnly:!0,json:{read:!1,write:!0,default:!1}})],t.default.prototype,"hasM",void 0),r.__decorate([p.property({type:C.MeshVertexAttributes,nonNullable:!0,json:{write:!0},clonable:(e,t)=>F.getMeshCloneContext(t)?.vertexAttributes??e.clone(t)})],t.default.prototype,"vertexAttributes",void 0),t.default=z=r.__decorate([h.subclass("esri.geometry.Mesh")],t.default);const O=v.create();return t.default});