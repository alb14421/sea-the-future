// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/SimpleGeometryCursor","../../../chunks/Geometry","../../../chunks/Envelope2D","../../../chunks/Transformation2D","../../../chunks/MultiPathImpl","../../../chunks/Point2D","../../../chunks/Envelope","../../../chunks/OperatorClip","../../../chunks/OperatorMultiPartToSinglePart","../../../chunks/OperatorCut"],function(e,t,s,r,n,i,o,a,l,u,m){"use strict";function h(e,t,s,r,n){return new N(n).findSlicesByArea(e,t,s,r)}function c(e,t,s,r,n){return new N(n).sliceIntoStrips(e,t,s,r)}function p(e,t,s,r){return new N(r).recursiveSliceEqualArea(e,t,s)}function _(e){this.currentX=this.calcX(e)}function g(e){if(null===this.curve){const t=(e-this.y0)/(this.y1-this.y0);return o.lerp(this.x0,this.x1,t)}return this.curve.intersectionOfYMonotonicWithAxisX(e,this.x0)}function y(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:_,calcX:g}}function f(e,t){const s=y();return s.x0=e.getStartX(),s.y0=e.getStartY(),s.x1=e.getEndX(),s.y1=e.getEndY(),t&&(s.y0=o.swap(s.x0,s.x0=s.y0),s.y1=o.swap(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=o.swap(s.y0,s.y0=s.y1),s.x1=o.swap(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function d(e){const t=y();return t.x0=e.getStartX(),t.y0=e.getStartY(),t.x1=e.getEndX(),t.y1=e.getEndY(),t.curve=e,t.y1<t.y0&&(t.y1=o.swap(t.y0,t.y0=t.y1),t.x1=o.swap(t.x0,t.x0=t.x1)),t.currentX=Number.NaN,t.nextAET=null,t.prevAET=null,t.startNodeNext=null,t.nextInChain=null,t}function x(e){if(this.x===e.x&&this.y===e.y){const t=null!==this.endEdge,s=null!==e.startEdge;return t&&s?-1:1}return this.y!==e.y?this.y-e.y:this.x-e.x}function A(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:x}}function T(e,t){return{y:e,startingEdges:t}}class E{constructor(e,t,s,r,n,i){this.m_parent=e,this.m_y0=t,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(e,t){return 1===e?0:this.getArea(t)-this.m_area}getError(e){return s.geometryReleaseAssert(0),0}getArea(e){const t=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-t*(e+this.m_t0))*s*(e-this.m_t0),n=!1;for(let t=this.m_parent.m_AETHead;null!==t;t=t.nextAET)if(n=!n,n&&(null!==t.curve||null!==t.nextAET.curve)){const n=this.m_y0+s*this.m_t0,i=this.m_y0+s*e;t.curve&&(r+=S(t.curve,this.m_y0+s*this.m_t0,this.m_y0+s*e)),t.nextAET.curve&&(r-=S(t.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*e)),r+=(i-n)*(t.nextAET.calcX(n)-t.calcX(n)+(t.nextAET.calcX(i)-t.calcX(i)))*.5}return r}}function v(e,t,s){return{polygon:e,from:t,to:s}}function S(e,t,r){const n=[0,0],a=e.intersectionWithAxis2D(!0,t,null,n);s.geometryReleaseAssert(1===a);const l=n[0],u=e.intersectionWithAxis2D(!0,r,null,n);s.geometryReleaseAssert(1===u);const m=n[0],h=o.makeObjectArray(o.Point2D,4);i.getPolynomialCoefs$1(e,h,!0);const c=h[3],p=h[2],_=h[1],g=e.getCoordX(l)-e.getStartX(),y=e.getCoordY(l)-e.getStartY(),f=e=>{const t=e*e;return t*e*(10*(p.x*_.y-p.y*_.x)-15*e*(c.y*_.x-c.x*_.y)+6*t*(p.y*c.x-c.y*p.x))/60},d=e=>(-e*(_.y+e*(p.y+c.y*e))*g+e*(_.x+e*(p.x+c.x*e))*y)/2;return f(m)-f(l)-(d(m)-d(l))}class P extends t.GeometryCursor{constructor(e){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=e}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class N{constructor(e){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new o.KahanSummator(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=e}findSlicesByArea(e,t,r,n){n<0&&s.throwInvalidArgumentException("remainingArea");let o=e,a=null;o.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,a=i.replaceAllCurvesWithBeziers(e,1e-16,!0),function(e){e.getImpl().ensureXYMonotoneSegments()}(a),o=a);const l=Math.abs(o.calculateArea2D());return 0===l||0===r||n>=l||1===r&&0===n?[]:(this.m_splitArea=(l-n)/r,this.m_numberOfCuts=r-1,n>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(o),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(e,s,n,i){if(0===i)return new t.SimpleGeometryCursor([e]);const o=new r.Envelope2D;e.queryLooseEnvelope(o);const a=o.width()+o.height();return new P(this.splitPolygon(e,s,o.xmin-a-1+1,o.xmax+a+1,n,i))}recursiveSliceEqualArea(e,i,a){if(a<=1||e.isEmpty())return new t.SimpleGeometryCursor([e]);{const t=[],l=[];l.push(o.makePair(e.clone(),a));let u=0,m=0;for(;l.length>0;){s.geometryReleaseAssert(m++<2*a);const e=l.at(-1);if(l.pop(),1===e.second){t.push(o.makePair(e.first,u++));continue}const h=new r.Envelope2D;e.first.queryEnvelope(h);const c=h.width()+h.height(),p=new n.Transformation2D;p.setIdentity(),h.width()>h.height()&&(p.setRotateCcw90(),e.first.applyTransformation(p),p.transformEnvInPlace(h));const _=e.first.calculateArea2D(),g=_/e.second,y=_-Math.trunc(e.second/2)*g,f=new N(this.m_progressTracker).findSlicesByArea(e.first,i,1,y),d=new N(this.m_progressTracker).splitPolygon(e.first,i,h.xmin-c-1+1,h.xmax+c+1,f,1),x=d.length;if(s.geometryReleaseAssert(x>0&&x<=2),!p.isIdentity()){const e=new n.Transformation2D;e.setRotateCw90(),d[0].first.applyTransformation(e),2===x&&d[1].first.applyTransformation(e)}2===x?(l.push(o.makePair(d[1].first,e.second-Math.trunc(e.second/2))),l.push(o.makePair(d[0].first,Math.trunc(e.second/2)))):l.push(o.makePair(d[0].first,e.second))}return new P(t)}}recursiveSliceEqualAreaImpl(e,t,r,n){return s.geometryReleaseAssert(0),{}}processTraps(e,t,s){s?this.processTrapsCurves(e,t):this.processTrapsLinear(e,t)}processTrapsLinear(e,t){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),a=t-e,l=(this.m_sumBase-n*(r+s))*a*(r-s);if(l+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(l),void(this.m_areaTracking+=l);const u=new o.KahanSummator(l),m=new o.Envelope1D(0,1);let h=!1;for(;s<1;){const t=this.m_splitArea-this.m_areaTracking,o=[Number.NaN,Number.NaN];if(!(i.quadraticRealRoots$2(-n*a,this.m_sumBase*a,(n*s-this.m_sumBase)*a*s-t,m,!1,o)>0)){h?this.m_areaTracking=u.getResult():this.m_areaTracking+=l;break}{h=!0,r=o[0],this.m_areaTracking=0,s=r,u.me(t);const n=r*a+e;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+l-u.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(l-u.getResult())}}this.m_totalAreaOfTraps.pe(l)}processTrapsCurves(e,t){let s=0,r=1;const n=new E(this,e,t,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const a=t-e,l=new o.KahanSummator(n);let u=!1;for(;s<1;){const m=this.m_splitArea-this.m_areaTracking,h=new E(this,e,t,s,1,m),c=[0],p=new o.Envelope1D(s,1);if(!(i.solve$1(h,p,1,c)>0)){u?this.m_areaTracking=l.getResult():this.m_areaTracking+=n;break}{u=!0,r=c[0],this.m_areaTracking=0,s=r,l.me(m);const t=r*a+e;if(this.m_cuts.push(t),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-l.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-l.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const e=this.m_sortedNodes[this.m_currentScan-1].y,t=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new o.KahanSummator(0);for(let e=this.m_AETHead;null!==e;e=e.nextAET){const i=e.prevAET;s=!s,null!==e.nextAET&&s&&(this.m_bPolygonHasCurves&&(e.curve||e.nextAET.curve)||n.pe(e.nextAET.currentX-e.currentX)),e.advance(t.y),null!==i&&e.currentX<i.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const i=new o.KahanSummator(0);s=!1;let a=!1;for(let e=this.m_AETHead;null!==e;e=e.nextAET)a=a||null!==e.curve,s=!s,null!==e.prevAET&&(s||this.m_bPolygonHasCurves&&(e.curve||e.prevAET.curve)||i.pe(e.currentX-e.prevAET.currentX));this.m_sumA=i.getResult(),this.processTraps(e,t.y,a);for(let e=this.m_AETHead;null!=e;){const s=e.prevAET,r=e.nextAET;if(t.y===e.y1)if(e.prevAET=null,e.nextAET=null,null!==e.nextInChain){const t=e.currentX;e=e.nextInChain,e.currentX=t,e.prevAET=s,s?s.nextAET=e:this.m_AETHead=e,e.nextAET=r,r&&(r.prevAET=e)}else s?s.nextAET=r:this.m_AETHead=r,r&&(r.prevAET=s);e=r}}mergeNewEdgesToAET(){for(let e=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==e;e=e.startNodeNext)Number.isNaN(e.currentX)&&(this.m_sortHelper.push(e),e.currentX=e.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let e=this.m_AETHead,t=0,s=e;for(;null!==e&&t<this.m_sortHelper.length;)e.currentX>this.m_sortHelper[t].currentX?(this.m_sortHelper[t].prevAET=e.prevAET,e.prevAET?e.prevAET.nextAET=this.m_sortHelper[t]:this.m_AETHead=this.m_sortHelper[t],this.m_sortHelper[t].nextAET=e,e.prevAET=this.m_sortHelper[t],t++):(s=e,e=e.nextAET);for(;t<this.m_sortHelper.length;)this.m_sortHelper[t].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[t]:this.m_AETHead=this.m_sortHelper[t],this.m_sortHelper[t].nextAET=null,s=this.m_sortHelper[t],t++;this.m_sortHelper.length=0}sortAET(){for(let e=this.m_AETHead;null!==e;e=e.nextAET)this.m_sortHelper.push(e);this.sortHelper(),this.m_AETHead=null;let e=null;for(const t of this.m_sortHelper)t.prevAET=e,e?e.nextAET=t:this.m_AETHead=t,t.nextAET=null,e=t;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort((e,t)=>e.currentX-t.currentX)}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(e){const t=e.querySegmentIterator();for(t.stripAttributes();t.nextPath();)for(;t.hasNextSegment();){const e=t.nextSegment();if(e.isCurve()){const t=e;if(i.ensureXYMonotoneSegment$1(t),this.m_bHorizontalSweep){const e=o.makeObjectArray(o.Point2D,4);t.queryControlPoints(e);for(const t of e)t.y=o.swap(t.x,t.x=t.y);t.constructPoints(e)}const s=t.getStartY(),r=t.getEndY();if(r===s)continue;r<s&&t.reverse(),this.m_curves.push(t.clone()),this.m_edges.push(d(this.m_curves.at(-1)))}else{const t=this.m_bHorizontalSweep?e.getStartX():e.getStartY();if((this.m_bHorizontalSweep?e.getEndX():e.getEndY())===t)continue;this.m_edges.push(f(e,this.m_bHorizontalSweep))}}this.m_edges.sort((e,t)=>e.y0===t.y0?e.x0-t.x0:e.y0-t.y0)}buildScanNodes(){const e=[];for(const t of this.m_edges){const s=A();s.x=t.x0,s.y=t.y0,s.startEdge=t,s.endEdge=null,e.push(s);const r=A();r.x=t.x1,r.y=t.y1,r.startEdge=null,r.endEdge=t,e.push(r)}e.sort((e,t)=>e.compare(t));let t=0,s=e[t].y;this.m_sortedNodes.push(T(s,e[t].startEdge));let r=t;for(t++;t!==e.length;++t){e[t].y!==s&&(this.m_sortedNodes.push(T(e[t].y,null)),s=e[t].y);const n=e[t].startEdge;if(n){const e=this.m_sortedNodes.at(-1);n.startNodeNext=e.startingEdges,e.startingEdges=n}if(e[r].x!==e[t].x||e[r].y!==e[t].y){if(t-r===2){let t=r;t++,null!==e[r].endEdge&&null!==e[t].startEdge&&(e[r].endEdge.nextInChain=e[t].startEdge)}r=t}}}progress(){}splitPolygonLinear(e,n,a,l,h,c){const p=[];p.push([e,0,c]);const _=[],g=new i.Polyline;for(g.startPathCoords(a,0),g.lineToCoords(l,0);p.length>0;){const i=p.at(-1);p.pop();const y=i[0],f=i[1],d=i[2],x=(new u.OperatorMultiPartToSinglePart).executeMany(new t.SimpleGeometryCursor([y]),n,this.m_progressTracker);for(let t=x.next();null!==t;t=x.next()){const i=t,u=new r.Envelope2D;i.queryLooseEnvelope(u);let y=f,x=d;for(let e=f,t=d-1;e<d;++e,--t)u.ymin>=h[e]&&(y=e+1),u.ymax<=h[t]&&(x=t);if(y!==d)if(x!==f)if(y!==x)if(this.isYMonotone(i))this.splitYMonotone(_,i,n,h,y,x);else{const t=Math.trunc((y+x)/2);g.setXYCoords(0,a,h[t]),g.setXYCoords(1,l,h[t]);const f=(new m.OperatorCut).execute(!1,i,g,null,this.m_progressTracker),d=f.next(),A=f.next(),T=f.next();if(null!==d){if(d.isEmpty()||(t===x-1?(_.push(o.makePair(d,t)),s.geometryReleaseAssert(w(_.at(-1).first,n,e,_.at(-1).second,h,c))):p.push([d,t+1,x])),A.isEmpty()||(t===y?(_.push(o.makePair(A,t-1)),s.geometryReleaseAssert(w(_.at(-1).first,n,e,_.at(-1).second,h,c))):p.push([A,y,t])),null!==T&&!T.isEmpty()){const e=new r.Envelope2D;T.queryLooseEnvelope(e),e.ymin>=h[t]?p.push([T,t+1,x]):e.ymax<=h[t]?p.push([T,y,t]):p.push([T,y,x])}}else t+1===x?(h[t]-u.ymin<u.ymax-h[t]?_.push(o.makePair(i,t)):_.push(o.makePair(i,t+1)),s.geometryReleaseAssert(w(_.at(-1).first,n,e,_.at(-1).second,h,c))):p.push([i,t+1,x])}else _.push(o.makePair(t,y-1));else _.push(o.makePair(t,f-1));else _.push(o.makePair(t,d-1))}}return _}splitPolygon(e,t,s,n,a,u){const m=new r.Envelope2D;e.queryLooseEnvelope(m),m.inflateCoords(0,Math.max(m.width(),m.height()));const h=[],c=[];for(c.push(v(e,0,u));c.length;){const i={...c.at(-1)};if(c.pop(),i.polygon.hasNonLinearSegments()){const e=Math.trunc((i.to+i.from)/2),u=a[e],p=new r.Envelope2D(s,m.ymin,n,u),_=(new l.OperatorClip).execute(i.polygon,p,t,this.m_progressTracker);_.isEmpty()||(e-i.from===0?h.push(o.makePair(_,e-1)):c.push(v(_,i.from,e)));const g=new r.Envelope2D(s,u,n,m.ymax),y=(new l.OperatorClip).execute(i.polygon,g,t,this.m_progressTracker);y.isEmpty()||(i.to-e===1?h.push(o.makePair(y,e)):c.push(v(y,e+1,i.to)))}else{const r=this.splitPolygonLinear(e,t,s,n,a.slice(i.from),i.to-i.from);h.push(...r)}}h.sort((e,t)=>e.second-t.second);const p=[];return i.groupTransform(h,(e,t)=>e.second===t.second,(e,t)=>{const s=new i.Polygon;for(let r=e;r!==t;++r)s.add(h[r].first,!1);p.push(o.makePair(s,h[e].second))}),p}isYMonotone(e){if(1!==e.getPathCount())return!1;const t=e.getXY(0);let s=0,r=0;const n=new o.Point2D;for(let i=1,o=e.getPointCount();i<=o;i++){e.queryXY(i===o?0:i,n);const a=n.y>t.y?1:n.y<t.y?-1:0;if(t.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(e,t,r,n,a,l){const u=new i.EditShape;u.addGeometry(t);const m=u.getFirstPath(u.getFirstGeometry()),h=u.getFirstVertex(m),c=new o.Point2D,p=new o.Point2D;let _=h,g=h;{const e=u.getXY(h);c.setCoordsPoint2D(e),p.setCoordsPoint2D(e)}let y=u.getNextVertex(h);const f=new o.Point2D;for(let e=0,t=u.getPathSize(m);e<t;e++,y=u.getNextVertex(y))u.queryXY(y,f),f.compare(c)<0?(_=y,c.setCoordsPoint2D(f)):f.compare(p)>0&&(g=y,p.setCoordsPoint2D(f));let d=_,x=_,A=d,T=x,E=!1,v=!1,S=a,P=c.y,N=c.y,w=!1;for(;S<l;)if(n[S]<=c.y)S++;else{if(n[S]>=p.y)break;if(!E){const e=u.getNextVertex(d),t=u.getY(e);if(t<P)break;const s=n[S];P<=s&&t>=s?E=!0:(P=t,d=e)}if(!v){const e=u.getPrevVertex(x),t=u.getY(e);if(t<N)break;const s=n[S];N<=s&&t>=s?v=!0:(N=t,x=e)}if(E&&v){w=!0;let t=u.getXY(d);const r=u.getNextVertex(d);let a=u.getXY(r),l=i.nullHandle;if(a.y===t.y)l=a.x<t.x?d:r;else{const e=(n[S]-t.y)/(a.y-t.y);if(0===e)l=d;else if(1===e)l=r;else{const t=u.splitSegmentAxisAware(d,[e],1,null,-1);s.geometryReleaseAssert(1===t),l=u.getNextVertex(d),u.getY(l)!==n[S]&&u.setXYCoords(l,u.getX(l),n[S])}}const m=u.getPrevVertex(x);t=u.getXY(m),a=u.getXY(x);let h=i.nullHandle;if(a.y===t.y)h=a.x<t.x?x:m;else{const e=(n[S]-t.y)/(a.y-t.y);if(0===e)h=m;else if(1===e)h=x;else{const t=u.splitSegmentAxisAware(m,[e],1,null,-1);s.geometryReleaseAssert(1===t),h=u.getNextVertex(m),u.getY(h)!==n[S]&&u.setXYCoords(h,u.getX(h),n[S])}}e.push(o.makePair(this.extractTrapezoid(u,A,l,T,h),S-1)),A=l,T=h,d=l,x=h,P=N=n[S],E=!1,v=!1,S++}}w?e.push(o.makePair(this.extractTrapezoid(u,A,g,T,g),S-1)):e.push(o.makePair(t,S))}extractTrapezoid(e,t,s,r,n){const o=new i.Polygon({vd:e.getVertexDescription()}),l=new a.Point;let u=!0;for(let r=t;;r=e.getNextVertex(r)){const t=e.getSegment(r);if(t?o.addSegment(t,u):(e.queryPoint(r,l),u?o.startPathPoint(l):o.lineToPoint(l)),u=!1,r===s)break}s!==n&&(e.queryPoint(n,l),o.lineToPoint(l)),u=!0;for(let s=n;;s=e.getNextVertex(s)){const n=e.getSegment(s);if(n?o.addSegment(n,u):u||s===t||(e.queryPoint(s,l),o.lineToPoint(l)),u=!1,s===r)break}return o}}function w(e,t,s,n,i,o){const l=new r.Envelope2D;e.queryEnvelope(l);const u=4*a.calculateToleranceFromGeometryForOpFromGeom(t,s,!0).total();return!(n>=0&&!(l.ymin+u>=i[n])||n+1<o&&l.ymax>i[n+1]+u)}class k extends t.GeometryCursor{constructor(e,t,s,r,n,i,o){super(),this.m_resultCursor=null,this.m_method=e,this.m_polygon=t,this.m_sr=s,this.m_ySplits=r?.slice()??null,this.m_transform=n,this.m_bReversePaths=n?.isReflective()??!1,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const e=this.m_resultCursor.next();return e?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(e.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&e.reverseAllPaths()),e):e}getGeometryID(){return this.m_resultCursor?this.m_resultCursor.getGeometryID():-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=c(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const e=this.m_polygon.clone();e.applyTransformation(this.m_transform),this.m_bReversePaths&&e.reverseAllPaths(),this.m_resultCursor=c(e,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=p(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const e=this.m_polygon.clone();e.applyTransformation(this.m_transform),this.m_bReversePaths&&e.reverseAllPaths(),this.m_resultCursor=p(e,this.m_sr,this.m_partCount,this.m_tracker)}}}const C=new class{getOperatorType(){return 10011}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}sliceIntoStrips(e,t,s,r,n,i){return new k(0,e,t,s,n,0,i)}findSlicesByArea(e,t,s,r,n,i){if(!n||n.isIdentity())return h(e,t,s,r,i);{const o=e.clone();return o.applyTransformation(n),h(o,t,s,r,i)}}recursiveSliceEqualArea(e,t,s,r,n){return new k(1,e,t,null,r,s,n)}};e.findSlicesByArea=function(e,t,s,r,n){return C.findSlicesByArea(e,t,s,r,n,null)},e.recursiveSliceEqualArea=function(e,t,s,r){const n=C.recursiveSliceEqualArea(e,t,s,r,null);return Array.from(n)},e.sliceIntoStrips=function(e,t,s,r){const n=C.sliceIntoStrips(e,t,s,0,r,null);return Array.from(n)},e.supportsCurves=function(){return C.supportsCurves()},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});