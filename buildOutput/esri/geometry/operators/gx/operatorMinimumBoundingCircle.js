// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/SimpleGeometryCursor","../../../chunks/Geometry","../../../chunks/MultiPathImpl","../../../chunks/Point2D"],function(e,t,r,n,o){"use strict";class i extends t.GeometryCursor{constructor(e,t,r){super(),this.m_geometryCursor=e,this.m_bMerge=t,this.m_progressTracker=r}tock(){return!0}getRank(){return 1}next(){if(this.m_bMerge)return this.mergedMinimumBoundingCircle();const e=this.m_geometryCursor.next();return e?this.minimumBoundingCircle(e):null}getGeometryID(){return this.m_geometryCursor.getGeometryID()}minimumBoundingCircle(e){if(r.throwIfCurves(e),r.throwIfMesh(e),this.m_progressTracker?.checkProgress(),e.isEmpty())return e.clone();const t=e.getGeometryType();if(t===r.GeometryType.enumPoint)return this.makeCircle([e.getXY()],1);if(t===r.GeometryType.enumLine){const t=e,r=[t.getStartXY(),t.getEndXY()];return this.makeCircle(r,2)}if(t===r.GeometryType.enumEnvelope){const t=e,r=o.makeObjectArray(o.Point2D,2);return t.queryCorner(0,r[0]),t.queryCorner(2,r[1]),this.makeCircle(r,2)}if(r.isMultiVertex(t)){const t=e,r=[0,0,0],o=n.minimumBoundingCircle(t,r),i=new Array(o);for(let e=0;e<o;++e)i[e]=t.getXY(r[e]);return this.makeCircle(i,o)}r.throwInvalidArgumentException("Geometry type not supported.")}makeCircle(e,t){const r=new n.Polygon,i=new n.EllipticArc;if(1===t)i.constructCircleRadius(0,e[0],!1);else if(2===t){const t=o.Point2D.lerp(e[0],e[1],.5),r=o.Point2D.distance(e[0],t),n=o.Point2D.distance(e[1],t);i.constructCircleRadius(Math.max(r,n),t,!1)}else if(3===t){const t=o.Point2D.calculateCircleCenterFromThreePoints(e[0],e[1],e[2]),r=o.Point2D.distance(e[0],t),n=o.Point2D.distance(e[1],t),u=o.Point2D.distance(e[2],t);i.constructCircleRadius(Math.max(r,n,u),t,!1)}return r.addPathFromClosedSegment(i,!1),r}mergedMinimumBoundingCircle(){let e=null,t=this.m_geometryCursor.next();if(!t)return null;e=new n.MultiPoint;const i=e.getImpl();do{switch(r.throwIfCurves(t),r.throwIfMesh(t),this.m_progressTracker?.checkProgress(),t.getGeometryType()){case r.GeometryType.enumPoint:i.addPoint2D(t.getXY());break;case r.GeometryType.enumLine:i.addPoint2D(t.getStartXY()),i.addPoint2D(t.getEndXY());break;case r.GeometryType.enumEnvelope:for(let e=0;e<4;++e){const r=new o.Point2D;t.queryCorner(e,r),i.addPoint2D(r)}break;case r.GeometryType.enumMultiPoint:case r.GeometryType.enumPolyline:case r.GeometryType.enumPolygon:{const e=t.getImpl();for(let t=0,r=e.getPointCount();t<r;t++)i.addPoint2D(e.getXY(t));break}default:r.throwInvalidArgumentException("Geometry type not supported.")}}while(t=this.m_geometryCursor.next());return this.minimumBoundingCircle(e)}}const u=new class{getOperatorType(){return 10113}supportsCurves(){return!1}accelerateGeometry(e,t,r){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,r){return new i(e,t,r)}execute(e,n){const o=new t.SimpleGeometryCursor([e]),i=this.executeMany(o,!1,n).next();return i||r.throwInternalErrorException("null output"),i}minimumBoundingCircle(e,t,r,o){return n.minimumBoundingCirclePoint2D(e,t,r)}};e.execute=function(e){return u.execute(e,null)},e.executeMany=function(e,r){const n=u.executeMany(new t.SimpleGeometryCursor(e),r,null);return Array.from(n)},e.supportsCurves=function(){return u.supportsCurves()},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});