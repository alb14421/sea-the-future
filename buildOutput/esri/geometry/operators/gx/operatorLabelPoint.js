// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../../../chunks/SimpleGeometryCursor","../../../chunks/Geometry","../../../chunks/Envelope","../../../chunks/MultiPathImpl","../../../chunks/Envelope2D","../../../chunks/Point2D","../../../chunks/ProjectionTransformation","../../../chunks/Centroid-DZi-eb9F","../../../chunks/OperatorProximity"],function(e,t,n,o,r,i,s,a,l,u){"use strict";class c extends t.GeometryCursor{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,t){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=t,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(n.throwIfMesh(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(null===e&&n.throwInvalidArgumentException("null pointer is not allowed"),e.getGeometryType()===n.GeometryType.enumPoint)return e;if(e.isEmpty())return new o.Point({vd:e.getDescription()});switch(e.getGeometryType()){case n.GeometryType.enumPolygon:return this.labelPointPolygon(e);case n.GeometryType.enumPolyline:return this.labelPointPolyline(e);case n.GeometryType.enumMultiPoint:return this.labelPointMultiPoint(e);case n.GeometryType.enumEnvelope:return this.labelPointEnvelope(e);default:n.throwInvalidArgumentException("geometry is not supported")}}labelPointPolygon(e){const t=new i.Envelope2D;e.queryEnvelope(t);const c=o.calculateToleranceFromGeometryForOp(null,t,!0).total();let m=null,P=e;if(e.hasNonLinearSegments()){const t=new r.Polygon({copy:e}),o=a.processCurves(t,.25*c,c);n.geometryReleaseAssert(o!==e),m=o,P=m}let y=0,p=0;for(let e=0,t=P.getPathCount();e<t;++e){const t=Math.abs(P.calculateRingArea2D(e));t>p&&(p=t,y=e)}const N=new s.Point2D;if(Math.abs(p)<=2*c*c?N.setNAN():N.assign(l.calculatePolygonCentroid2D(P,y)),Number.isNaN(N.x)){const e=new i.Envelope2D;return P.queryPathEnvelope(y,e),new o.Point({pt:e.getCenter()})}if(P.getPointCount()<4)return new o.Point({x:N.x,y:N.y});const g=s.Point2D.getNAN(),h=[g.clone(),g.clone(),g.clone(),g.clone()],D=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],x=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let d=!1,w=(new u.OperatorProximity2D).getNearestCoordinate(P,N,!0,!1);if(0===w.m_distance&&(d=!0,h[0]=N,w=(new u.OperatorProximity2D).getNearestCoordinate(P,N,!1,!1),w.m_distance>.25*t.minDimension()*1.66666666))return new o.Point({x:N.x,y:N.y});D[0]=w.m_distance,x[0]=0;const b=new s.Point2D;let f=!1,C=.25,E=-1;const A=new i.Envelope2D;P.queryPathEnvelope(y,A);do{let e=Number.NaN;if(h[1]=this.calculateParacentroid_(P,s.lerp(A.xmin,A.xmax,C),c),h[1].isNAN()||(w=(new u.OperatorProximity2D).getNearestCoordinate(P,h[1],!1,!1),e=w.m_distance),e>c&&1===a.isPoint2DInPolygon2D(P,h[1],c))f=!0,D[1]=e,x[1]=s.Point2D.sqrDistance(h[1],N);else if(e>E&&(E=e,b.setCoordsPoint2D(h[1])),C-=.01,C<.1){if(!(E>=0))break;f=!0,D[1]=E,h[1]=b,x[1]=s.Point2D.sqrDistance(h[1],N)}}while(!f);f=!1,C=.5,E=-1;let v=.01,_=1;do{let e=Number.NaN;if(h[2]=this.calculateParacentroid_(P,s.lerp(A.xmin,A.xmax,C),c),h[2].isNAN()||(w=(new u.OperatorProximity2D).getNearestCoordinate(P,h[2],!1,!1),e=w.m_distance),e>c&&1===a.isPoint2DInPolygon2D(P,h[2],c))f=!0,D[2]=e,x[2]=s.Point2D.sqrDistance(h[2],N);else if(e>E&&(E=e,b.setCoordsPoint2D(h[2])),C=.5+v*_,v+=.01,_*=-1,C<.3||C>.7){if(!(E>=0))break;f=!0,D[2]=E,h[2]=b,x[2]=s.Point2D.sqrDistance(h[2],N)}}while(!f);f=!1,C=.75,E=-1;do{let e=Number.NaN;if(h[3]=this.calculateParacentroid_(P,s.lerp(A.xmin,A.xmax,C),c),h[3].isNAN()||(w=(new u.OperatorProximity2D).getNearestCoordinate(P,h[3],!1,!1),e=w.m_distance),e>c&&1===a.isPoint2DInPolygon2D(P,h[3],c))f=!0,D[3]=e,x[3]=s.Point2D.sqrDistance(h[3],N);else if(e>E&&(E=e,b.setCoordsPoint2D(h[3])),C+=.01,C>.9){if(!(E>=0))break;f=!0,D[3]=E,h[3]=b,x[3]=s.Point2D.sqrDistance(h[3],N)}}while(!f);const k=[0,1,2,3],G=d?0:1;for(let e=G;e<4;e++)for(let e=G;e<3;e++){const t=x[e],n=x[e+1];if(s.compareWithNANs(t,n)>0){const o=k[e];k[e]=k[e+1],k[e+1]=o,x[e]=n,x[e+1]=t}}let M=G,S=0,q=0;for(let e=G;e<4;e++){switch(e){case 0:q=2*D[k[e]];break;case 1:q=1.66666666*D[k[e]];break;case 2:q=1.33333333*D[k[e]];break;case 3:q=D[k[e]]}q>S&&(S=q,M=k[e])}return n.geometryReleaseAssert(!h[M].isNAN()),new o.Point({x:h[M].x,y:h[M].y})}labelPointPolyline(e){const t=new s.Point2D;if(e.getPointCount()>2*e.getPathCount()){let n=-1,o=-Number.MAX_VALUE;for(let t=0,r=e.getPathCount();t<r;t++)if(e.getPathSize(t)>2){const r=e.calculatePathLength2D(t);r>o&&(o=r,n=t)}const r=e.getPathStart(n),i=e.getPathEnd(n),s=Math.trunc((r+i)/2);t.assign(e.getXY(s))}else{let n=-Number.MAX_VALUE;const o=e.querySegmentIterator();for(;o.nextPath();)if(o.hasNextSegment()){const e=o.nextSegment(),r=e.calculateLength2D();r>n&&(n=r,t.assign(e.getCoord2D(e.lengthToT(.5*r))))}}return new o.Point({x:t.x,y:t.y})}labelPointMultiPoint(e){const t=new i.Envelope2D;e.queryEnvelope(t);const n=t.getCenter(),r=(new u.OperatorProximity2D).getNearestCoordinate(e,n,!1,!1).m_coordinate;return new o.Point({x:r.x,y:r.y})}labelPointEnvelope(e){const t=e.getCenterXY();return new o.Point({x:t.x,y:t.y})}calculateParacentroid_(e,t,o){const a=new i.Envelope2D;e.queryEnvelope(a);const l=new s.Point2D(t,0);let u=Number.MAX_VALUE,c=Number.MAX_VALUE,m=!1,P=!1;const y=new r.Line;y.setStartXYCoords(l.x,a.ymin-1),y.setEndXYCoords(l.x,a.ymax+1);const p=new i.Envelope2D,N=new s.Point2D,g=new s.Point2D,h=s.makeObjectArray(s.Point2D,2),D=e.querySegmentIterator();for(;D.nextPath();)for(;D.hasNextSegment();){const e=D.nextSegment();if(e.queryEnvelope(p),n.geometryReleaseAssert(e.isMonotoneQuickAndDirty()),N.setCoordsPoint2D(y.getStartXY()),g.setCoordsPoint2D(y.getEndXY()),0===p.clipLine(N,g))continue;if(1!==y.intersect(e,h,null,null,o))continue;const t=h[0].y;u>c?t<u&&(u=t,m=!0):t<c&&(c=t,P=!0)}return m&&P?l.y=(u+c)/2:l.setNAN(),l}}const m=new class{getOperatorType(){return 10203}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t){return new c(e,t)}execute(e,t){return new c(null,t).labelPoint(e)}};e.execute=function(e){return m.execute(e,null)},e.executeMany=function(e){const n=m.executeMany(new t.SimpleGeometryCursor(e),null);return Array.from(n)},e.supportsCurves=function(){return m.supportsCurves()},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});