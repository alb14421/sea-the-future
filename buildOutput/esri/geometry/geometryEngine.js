// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../core/accessorSupport/ensureType","./asserts","../chunks/geometryEngineBase","./SpatialReference","./geometryAdapters/hydrated"],function(e,t,r,n,i,s){"use strict";function o(e){const r=Array.isArray(e)?e[0].spatialReference:e.spatialReference;return r?t.ensureClass(i,r):i.WGS84}function a(e){return"xmin"in e?"center"in e?e.center:null:"x"in e?e:"extent"in e?e.extent?.center??null:null}class c extends Error{constructor(){super("Illegal Argument Exception")}}e.buffer=function(e,t,r,i=!1){return n.GeometryEngineApi.buffer(s.hydratedAdapter,o(e),e,t,r,i)},e.changeDefaultSpatialReferenceTolerance=function(e,t){n.GeometryEngineApi.changeDefaultSpatialReferenceTolerance(e,t)},e.clearDefaultSpatialReferenceTolerance=function(e){n.GeometryEngineApi.clearDefaultSpatialReferenceTolerance(e)},e.clip=function(e,t){return r.assertNotMesh(e),n.GeometryEngineApi.clip(s.hydratedAdapter,o(e),e,t)},e.contains=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.contains(s.hydratedAdapter,o(e),e,t)},e.convexHull=function(e,t=!1){return n.GeometryEngineApi.convexHull(s.hydratedAdapter,o(e),e,t)},e.crosses=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.crosses(s.hydratedAdapter,o(e),e,t)},e.cut=function(e,t){return r.assertNotMesh(e),n.GeometryEngineApi.cut(s.hydratedAdapter,o(e),e,t)},e.densify=function(e,t,i){return r.assertNotMesh(e),n.GeometryEngineApi.densify(s.hydratedAdapter,o(e),e,t,i)},e.difference=function(e,t){return r.assertNotMesh(t),n.GeometryEngineApi.difference(s.hydratedAdapter,o(e),e,t)},e.disjoint=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.disjoint(s.hydratedAdapter,o(e),e,t)},e.distance=function(e,t,i){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.distance(s.hydratedAdapter,o(e),e,t,i)},e.equals=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.equals(s.hydratedAdapter,o(e),e,t)},e.extendedSpatialReferenceInfo=function(e){return n.GeometryEngineApi.extendedSpatialReferenceInfo(e)},e.flipHorizontal=function(e,t){if(null==e)throw new c;const r=e.spatialReference;if(null==(t=t??a(e)))throw new c;const i=e.constructor.fromJSON(n.GeometryEngineApi.flipHorizontal(e,t));return i.spatialReference=r,i},e.flipVertical=function(e,t){if(null==e)throw new c;const r=e.spatialReference;if(null==(t=t??a(e)))throw new c;const i=e.constructor.fromJSON(n.GeometryEngineApi.flipVertical(e,t));return i.spatialReference=r,i},e.generalize=function(e,t,i,a){return r.assertNotMesh(e),n.GeometryEngineApi.generalize(s.hydratedAdapter,o(e),e,t,i,a)},e.geodesicArea=function(e,t,i){return r.assertNotMesh(e),n.GeometryEngineApi.geodesicArea(s.hydratedAdapter,o(e),e,t,i)},e.geodesicBuffer=function(e,t,r,i,a,c){return n.GeometryEngineApi.geodesicBuffer(s.hydratedAdapter,o(e),e,t,r,i,a,c)},e.geodesicDensify=function(e,t,i,a=0){return r.assertNotMesh(e),n.GeometryEngineApi.geodesicDensify(s.hydratedAdapter,o(e),e,t,i,a)},e.geodesicLength=function(e,t,i){return r.assertNotMesh(e),n.GeometryEngineApi.geodesicLength(s.hydratedAdapter,o(e),e,t,i)},e.intersect=function(e,t){return r.assertNotMesh(t),n.GeometryEngineApi.intersect(s.hydratedAdapter,o(e),e,t)},e.intersectLinesToPoints=function(e,t){return n.GeometryEngineApi.intersectLinesToPoints(s.hydratedAdapter,o(e),e,t)},e.intersects=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.intersects(s.hydratedAdapter,o(e),e,t)},e.isSimple=function(e){return r.assertNotMesh(e),n.GeometryEngineApi.isSimple(s.hydratedAdapter,o(e),e)},e.nearestCoordinate=function(e,t,i=!0){return r.assertNotMesh(e),n.GeometryEngineApi.nearestCoordinate(s.hydratedAdapter,o(e),e,t,i)},e.nearestVertex=function(e,t){return r.assertNotMesh(e),n.GeometryEngineApi.nearestVertex(s.hydratedAdapter,o(e),e,t)},e.nearestVertices=function(e,t,i,a){return r.assertNotMesh(e),n.GeometryEngineApi.nearestVertices(s.hydratedAdapter,o(e),e,t,i,a)},e.offset=function(e,t,r,i,a,c){return n.GeometryEngineApi.offset(s.hydratedAdapter,o(e),e,t,r,i,a,c)},e.overlaps=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.overlaps(s.hydratedAdapter,o(e),e,t)},e.planarArea=function(e,t){return r.assertNotMesh(e),n.GeometryEngineApi.planarArea(s.hydratedAdapter,o(e),e,t)},e.planarLength=function(e,t){return r.assertNotMesh(e),n.GeometryEngineApi.planarLength(s.hydratedAdapter,o(e),e,t)},e.relate=function(e,t,i){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.relate(s.hydratedAdapter,o(e),e,t,i)},e.rotate=function(e,t,r){if(null==e)throw new c;const i=e.spatialReference;if(null==(r=r??a(e)))throw new c;const s=e.constructor.fromJSON(n.GeometryEngineApi.rotate(e,t,r));return s.spatialReference=i,s},e.simplify=function(e){return r.assertNotMesh(e),n.GeometryEngineApi.simplify(s.hydratedAdapter,o(e),e)},e.symmetricDifference=function(e,t){return r.assertNotMesh(t),n.GeometryEngineApi.symmetricDifference(s.hydratedAdapter,o(e),e,t)},e.touches=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.touches(s.hydratedAdapter,o(e),e,t)},e.union=function(e){return n.GeometryEngineApi.union(s.hydratedAdapter,o(e),e)},e.within=function(e,t){return r.assertNotMesh(e),r.assertNotMesh(t),n.GeometryEngineApi.within(s.hydratedAdapter,o(e),e,t)},Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});