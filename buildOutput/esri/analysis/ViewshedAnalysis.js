// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.34/esri/copyright.txt for details.
//>>built
define(["exports","../chunks/tslib.es6","./Analysis","./Viewshed","../core/arrayUtils","../core/Collection","../core/collectionUtils","../core/Cyclical","../core/mathUtils","../core/reactiveUtils","../core/accessorSupport/decorators/property","../core/has","../core/Logger","../core/accessorSupport/decorators/subclass","../geometry/Extent","../geometry/projectionUtils"],function(e,t,r,n,s,l,i,a,o,c,u,d,p,h,y,f){"use strict";const m=l.ofType(n);function v(e){return Math.cos(o.deg2rad(e))}function g(e){return Math.sin(o.deg2rad(e))}return e.default=class extends r{constructor(e){super(e),this.type="viewshed",this._extent=null}initialize(){this.addHandles(c.watch(()=>this._computeExtent(),e=>{null==e.pending&&(this._extent=e.extent)},c.syncAndInitial))}get viewsheds(){return this._get("viewsheds")||new m}set viewsheds(e){this._set("viewsheds",i.referenceSetter(e,this.viewsheds,m))}get spatialReference(){for(const e of this.viewsheds)if(null!=e.observer)return e.observer.spatialReference;return null}get extent(){return this._extent}get valid(){return this.viewsheds.every(e=>e.valid)}async waitComputeExtent(){const e=this._computeExtent();null!=e.pending&&await e.pending}_computeExtent(){const{spatialReference:e}=this;if(null==e)return{pending:null,extent:null};const t=this.viewsheds.filter(e=>null!=e.observer),r=t.map(e=>e.observer).toArray(),n=f.projectOrLoadMany(r,e);return null!=n.pending?{pending:n.pending,extent:null}:{pending:null,extent:n.geometries.map((e,r)=>{const n=t.at(r);return null!=e&&null!=n?this._computeViewshedExtent(this.viewsheds.at(r),e):null}).filter(e=>null!=e).reduce((e,t)=>{return n=t,null==(r=e)?n:null==n?r:r.union(n);var r,n},null)}}_computeViewshedExtent(e,t){const{farDistance:r,heading:n,tilt:s,horizontalFieldOfView:l,verticalFieldOfView:i}=e,{spatialReference:c}=t,u=l/2,d=i/2,p=r/c.metersPerUnit,h=[a.cyclicalDegrees.normalize(n-u),n,a.cyclicalDegrees.normalize(n+u)],f=y.fromPoint(t),m=e=>{const t=h.map(t=>a.cyclicalDegrees.normalize(t-e));if(t[0]>t[2]||360===l)return p;const r=t.map(e=>Math.abs(e>180?360-e:e)).reduce((e,t)=>e>t?t:e);return r>90?0:p*Math.cos(o.deg2rad(r))};f.xmax+=m(90),f.xmin-=m(-90),f.ymax+=m(0),f.ymin-=m(180);const w=t.z;if(null!=w){let e=w,t=w;const n=s-90,l=o.clamp(n+d,-90,90),i=o.clamp(n-d,-90,90),a=c?.isGeographic?r:p;e+=a*g(l),t+=a*g(i);const h=v(d)*a,y=g(n)*h*(1-v(u));s<90&&(e-=y),s>90&&(t-=y),f.zmax=Math.max(e,w),f.zmin=Math.min(t,w)}return f}equals(e){return this===e||super.equals(e)&&s.equals(this.viewsheds.toArray(),e.viewsheds.toArray(),(e,t)=>e.equals(t))}clear(){this.viewsheds.removeAll()}},t.__decorate([u.property({type:["viewshed"]})],e.default.prototype,"type",void 0),t.__decorate([u.property({cast:i.castForReferenceSetter,type:m,nonNullable:!0})],e.default.prototype,"viewsheds",null),t.__decorate([u.property({readOnly:!0})],e.default.prototype,"spatialReference",null),t.__decorate([u.property()],e.default.prototype,"_extent",void 0),t.__decorate([u.property()],e.default.prototype,"extent",null),t.__decorate([u.property({readOnly:!0})],e.default.prototype,"valid",null),e.default=t.__decorate([h.subclass("esri.analysis.ViewshedAnalysis")],e.default),e.default});